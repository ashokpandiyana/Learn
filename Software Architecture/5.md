# Chapter 5: Microservices Architecture

## Table of Contents
1. Introduction to Microservices
2. Key Characteristics
3. Service Boundaries & Domain-Driven Design
4. Inter-Service Communication
5. Service Discovery
6. API Gateway Pattern
7. Resilience Patterns
8. Distributed Transactions (Saga Pattern)
9. Advantages and Disadvantages
10. Real-World Implementation

---

## 1. Introduction to Microservices

**Definition:** Microservices architecture is an architectural style that structures an application as a collection of small, autonomous services modeled around a business domain.

### Monolith vs Microservices

```
MONOLITH                           MICROSERVICES
┌──────────────────────┐          ┌─────┐ ┌─────┐ ┌─────┐
│                      │          │User │ │Order│ │Pay  │
│   Single App         │          │Svc  │ │Svc  │ │Svc  │
│                      │          └─────┘ └─────┘ └─────┘
│  - User Module       │             │       │       │
│  - Order Module      │          ┌─────┐ ┌─────┐ ┌─────┐
│  - Payment Module    │          │User │ │Order│ │Pay  │
│                      │          │DB   │ │DB   │ │DB   │
│                      │          └─────┘ └─────┘ └─────┘
└──────────────────────┘
        │
    ┌───────┐
    │Shared │
    │  DB   │
    └───────┘
```

**Key Difference:** Each microservice is independently deployable and has its own database.

---

## 2. Key Characteristics

### 2.1 Independent Deployment

Each service can be deployed without affecting others.

```yaml
# Deploy only Order Service
kubectl apply -f order-service-deployment.yaml

# Other services keep running
# No need to redeploy User Service or Payment Service
```

### 2.2 Single Responsibility

Each service focuses on one business capability.

```typescript
// ❌ Bad: God service doing everything
class EverythingService {
    createUser() {}
    processOrder() {}
    handlePayment() {}
    sendNotification() {}
}

// ✅ Good: Each service has single responsibility
class UserService {
    createUser() {}
    updateUser() {}
    getUser() {}
}

class OrderService {
    createOrder() {}
    updateOrderStatus() {}
    getOrderHistory() {}
}

class PaymentService {
    processPayment() {}
    refundPayment() {}
}
```

### 2.3 Decentralized Data Management

Each service owns its database.

```
User Service        Order Service       Product Service
     ↓                   ↓                    ↓
  ┌─────┐            ┌─────┐              ┌─────┐
  │Users│            │Order│              │Prod │
  │ DB  │            │ DB  │              │ DB  │
  └─────┘            └─────┘              └─────┘

No shared database!
```

### 2.4 Technology Diversity

Different services can use different technologies.

```python
# User Service - Python/Flask + PostgreSQL
@app.route('/users/<id>')
def get_user(id):
    return UserRepository.find(id)

# Order Service - Node.js/Express + MongoDB
app.get('/orders/:id', (req, res) => {
    OrderRepository.findById(req.params.id)
        .then(order => res.json(order));
});

# Analytics Service - Java/Spring + Cassandra
@GetMapping("/analytics")
public Analytics getAnalytics() {
    return analyticsRepository.aggregate();
}
```

---

## 3. Service Boundaries & Domain-Driven Design

### 3.1 Identifying Service Boundaries

Use **Domain-Driven Design (DDD)** to identify bounded contexts.

**Example: E-Commerce System**

```
┌──────────────────────────────────────────────────────┐
│                    E-Commerce Domain                  │
├──────────────┬──────────────┬──────────────┬─────────┤
│User Context  │Order Context │Product       │Payment  │
│              │              │Context       │Context  │
│              │              │              │         │
│- Registration│- Create Order│- Catalog     │- Process│
│- Profile     │- Track Order │- Inventory   │- Refund │
│- Auth        │- History     │- Search      │- Billing│
└──────────────┴──────────────┴──────────────┴─────────┘
      ↓              ↓               ↓             ↓
  User Service   Order Service   Product Svc   Payment Svc
```

### 3.2 Service Design Example

**User Service:**
```java
// User Service - Owns user data
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    // Public API endpoints
    @PostMapping
    public ResponseEntity<UserDTO> createUser(@RequestBody CreateUserRequest req) {
        User user = userService.createUser(req);
        return ResponseEntity.status(201).body(UserMapper.toDTO(user));
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<UserDTO> getUser(@PathVariable Long id) {
        User user = userService.getUserById(id);
        return ResponseEntity.ok(UserMapper.toDTO(user));
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<UserDTO> updateUser(
        @PathVariable Long id,
        @RequestBody UpdateUserRequest req
    ) {
        User user = userService.updateUser(id, req);
        return ResponseEntity.ok(UserMapper.toDTO(user));
    }
}

// User Service owns its database
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String email;
    private String name;
    private String passwordHash;
    private LocalDateTime createdAt;
    
    // Only user-related data
}
```

**Order Service:**
```java
// Order Service - References users but doesn't own user data
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @Autowired
    private OrderService orderService;
    
    @PostMapping
    public ResponseEntity<OrderDTO> createOrder(@RequestBody CreateOrderRequest req) {
        // Order service stores userId but doesn't manage user data
        Order order = orderService.createOrder(req);
        return ResponseEntity.status(201).body(OrderMapper.toDTO(order));
    }
}

@Entity
@Table(name = "orders")
public class Order {
    @Id
    private Long id;
    
    // Reference to user by ID, not foreign key
    private Long userId;  // Not @ManyToOne!
    
    @OneToMany(cascade = CascadeType.ALL)
    private List<OrderItem> items;
    
    private BigDecimal total;
    private OrderStatus status;
}
```

**Key Point:** Order Service stores `userId` but doesn't have direct database relationship. To get user details, it calls User Service via API.

---

## 4. Inter-Service Communication

### 4.1 Synchronous Communication (REST)

**When to use:** Request-response pattern, need immediate result.

```typescript
// Order Service calling User Service
class OrderService {
    constructor(
        private orderRepository: OrderRepository,
        private userServiceClient: UserServiceClient
    ) {}
    
    async createOrder(userId: number, items: OrderItem[]): Promise<Order> {
        // 1. Validate user exists by calling User Service
        try {
            const user = await this.userServiceClient.getUser(userId);
            if (!user) {
                throw new Error('User not found');
            }
        } catch (error) {
            throw new Error('Failed to validate user: ' + error.message);
        }
        
        // 2. Create order
        const order = new Order();
        order.userId = userId;
        order.items = items;
        order.total = this.calculateTotal(items);
        
        // 3. Save order
        return await this.orderRepository.save(order);
    }
}

// HTTP Client for User Service
class UserServiceClient {
    private baseUrl = 'http://user-service:3000';
    
    async getUser(userId: number): Promise<User | null> {
        try {
            const response = await fetch(`${this.baseUrl}/api/users/${userId}`);
            
            if (response.status === 404) {
                return null;
            }
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            return await response.json();
        } catch (error) {
            console.error('Failed to call User Service:', error);
            throw error;
        }
    }
}
```

**Problems with Synchronous:**
- Tight coupling
- Cascading failures
- Latency accumulation

### 4.2 Synchronous Communication (gRPC)

**When to use:** High performance, strong typing needed.

```protobuf
// user.proto - Service definition
syntax = "proto3";

service UserService {
    rpc GetUser (GetUserRequest) returns (UserResponse);
    rpc CreateUser (CreateUserRequest) returns (UserResponse);
}

message GetUserRequest {
    int64 user_id = 1;
}

message UserResponse {
    int64 id = 1;
    string email = 2;
    string name = 3;
    string created_at = 4;
}

message CreateUserRequest {
    string email = 1;
    string name = 2;
    string password = 3;
}
```

```python
# User Service - gRPC Server
import grpc
from concurrent import futures
import user_pb2
import user_pb2_grpc

class UserServiceServicer(user_pb2_grpc.UserServiceServicer):
    def GetUser(self, request, context):
        user_id = request.user_id
        user = user_repository.find_by_id(user_id)
        
        if not user:
            context.set_code(grpc.StatusCode.NOT_FOUND)
            context.set_details('User not found')
            return user_pb2.UserResponse()
        
        return user_pb2.UserResponse(
            id=user.id,
            email=user.email,
            name=user.name,
            created_at=str(user.created_at)
        )

# Start server
server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
user_pb2_grpc.add_UserServiceServicer_to_server(
    UserServiceServicer(), server
)
server.add_insecure_port('[::]:50051')
server.start()
server.wait_for_termination()
```

```python
# Order Service - gRPC Client
import grpc
import user_pb2
import user_pb2_grpc

class UserServiceClient:
    def __init__(self):
        self.channel = grpc.insecure_channel('user-service:50051')
        self.stub = user_pb2_grpc.UserServiceStub(self.channel)
    
    def get_user(self, user_id):
        request = user_pb2.GetUserRequest(user_id=user_id)
        try:
            response = self.stub.GetUser(request)
            return response
        except grpc.RpcError as e:
            if e.code() == grpc.StatusCode.NOT_FOUND:
                return None
            raise
```

**gRPC Benefits:**
- 10x faster than REST
- Strong typing (compile-time checks)
- Bidirectional streaming
- Better for service-to-service communication

### 4.3 Asynchronous Communication (Message Queue)

**When to use:** Fire-and-forget, event-driven, decoupling needed.

```javascript
// Order Service - Publishes event when order is created
const amqp = require('amqplib');

class OrderService {
    constructor(orderRepository, messageQueue) {
        this.orderRepository = orderRepository;
        this.messageQueue = messageQueue;
    }
    
    async createOrder(userId, items) {
        // 1. Create order
        const order = {
            id: generateId(),
            userId: userId,
            items: items,
            total: calculateTotal(items),
            status: 'PENDING',
            createdAt: new Date()
        };
        
        await this.orderRepository.save(order);
        
        // 2. Publish event (fire-and-forget)
        await this.messageQueue.publish('order.created', {
            orderId: order.id,
            userId: order.userId,
            total: order.total,
            items: order.items
        });
        
        return order;
    }
}

// Message Queue Publisher
class MessageQueue {
    constructor() {
        this.connection = null;
        this.channel = null;
    }
    
    async connect() {
        this.connection = await amqp.connect('amqp://rabbitmq:5672');
        this.channel = await this.connection.createChannel();
        
        // Declare exchange
        await this.channel.assertExchange('orders', 'topic', {
            durable: true
        });
    }
    
    async publish(routingKey, message) {
        const content = Buffer.from(JSON.stringify(message));
        
        this.channel.publish(
            'orders',
            routingKey,
            content,
            { persistent: true }
        );
        
        console.log(`Published: ${routingKey}`, message);
    }
}
```

```javascript
// Notification Service - Subscribes to order events
class NotificationService {
    constructor(emailService) {
        this.emailService = emailService;
    }
    
    async start() {
        const connection = await amqp.connect('amqp://rabbitmq:5672');
        const channel = await connection.createChannel();
        
        // Declare queue
        await channel.assertQueue('notification-queue', { durable: true });
        
        // Bind to exchange
        await channel.bindQueue(
            'notification-queue',
            'orders',
            'order.created'  // Listen for order.created events
        );
        
        // Consume messages
        channel.consume('notification-queue', async (msg) => {
            const event = JSON.parse(msg.content.toString());
            
            console.log('Received event:', event);
            
            try {
                // Send notification
                await this.emailService.sendOrderConfirmation(
                    event.userId,
                    event.orderId
                );
                
                // Acknowledge message
                channel.ack(msg);
                
            } catch (error) {
                console.error('Failed to process event:', error);
                // Reject and requeue
                channel.nack(msg, false, true);
            }
        });
    }
}

// Start service
const service = new NotificationService(new EmailService());
service.start();
```

**Benefits:**
- Loose coupling
- Better fault tolerance
- Asynchronous processing
- Can add new subscribers without changing publisher

---

## 5. Service Discovery

**Problem:** In microservices, service instances change dynamically (scaling, failures). How do services find each other?

**Solution:** Service Registry

### 5.1 Client-Side Discovery

```
┌──────────────┐
│Order Service │
└──────┬───────┘
       │ 1. Query registry
       ↓
┌──────────────┐
│Service       │
│Registry      │
│(Consul)      │
└──────┬───────┘
       │ 2. Returns instances
       │    [user-1:3000, user-2:3000]
       ↓
┌──────────────┐
│Order Service │─────3. Call directly───→ User Service (user-1:3000)
└──────────────┘
```

```javascript
// Service Discovery with Consul
const Consul = require('consul');

class ServiceDiscovery {
    constructor() {
        this.consul = new Consul({
            host: 'consul-server',
            port: 8500
        });
    }
    
    // Register service
    async register(serviceName, serviceId, port) {
        await this.consul.agent.service.register({
            id: serviceId,
            name: serviceName,
            address: process.env.HOST,
            port: port,
            check: {
                http: `http://${process.env.HOST}:${port}/health`,
                interval: '10s',
                timeout: '5s'
            }
        });
        
        console.log(`Registered ${serviceName} (${serviceId})`);
    }
    
    // Discover service
    async discover(serviceName) {
        const result = await this.consul.health.service({
            service: serviceName,
            passing: true  // Only healthy instances
        });
        
        // Return list of healthy instances
        return result.map(entry => ({
            address: entry.Service.Address,
            port: entry.Service.Port
        }));
    }
    
    // Get one instance (with load balancing)
    async getServiceInstance(serviceName) {
        const instances = await this.discover(serviceName);
        
        if (instances.length === 0) {
            throw new Error(`No instances found for ${serviceName}`);
        }
        
        // Simple round-robin
        const index = Math.floor(Math.random() * instances.length);
        return instances[index];
    }
}

// Usage in Order Service
class OrderService {
    constructor(orderRepository, serviceDiscovery) {
        this.orderRepository = orderRepository;
        this.serviceDiscovery = serviceDiscovery;
    }
    
    async createOrder(userId, items) {
        // 1. Discover User Service
        const userServiceInstance = await this.serviceDiscovery
            .getServiceInstance('user-service');
        
        // 2. Call User Service
        const userResponse = await fetch(
            `http://${userServiceInstance.address}:${userServiceInstance.port}/users/${userId}`
        );
        
        if (!userResponse.ok) {
            throw new Error('User not found');
        }
        
        // 3. Create order...
        const order = await this.orderRepository.save({
            userId,
            items,
            total: calculateTotal(items)
        });
        
        return order;
    }
}
```

### 5.2 Server-Side Discovery (with Load Balancer)

```
┌──────────────┐
│Order Service │
└──────┬───────┘
       │ 1. Call load balancer
       ↓
┌──────────────┐
│Load Balancer │
│ (Nginx)      │
└──────┬───────┘
       │ 2. Query registry
       ↓
┌──────────────┐
│Service       │
│Registry      │
└──────────────┘
       │ 3. Route to instance
       ↓
┌──────────────┐
│User Service  │ (user-1:3000)
└──────────────┘
```

**Kubernetes Example:**
```yaml
# Service definition - acts as load balancer
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
    - port: 80
      targetPort: 3000
  type: ClusterIP

---
# Deployment with multiple replicas
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
spec:
  replicas: 3  # 3 instances
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: user-service:1.0
        ports:
        - containerPort: 3000
```

```javascript
// Order Service just calls the service name
// Kubernetes handles discovery and load balancing
const userResponse = await fetch('http://user-service/users/123');
```

---

## 6. API Gateway Pattern

**Problem:** Clients don't want to track multiple service endpoints. Need centralized entry point.

**Solution:** API Gateway

```
                          ┌─────────────┐
                          │   Client    │
                          └──────┬──────┘
                                 │
                          ┌──────▼──────┐
                          │ API Gateway │
                          │             │
                          │ - Auth      │
                          │ - Routing   │
                          │ - Rate Limit│
                          │ - Transform │
                          └──────┬──────┘
                                 │
         ┌───────────────────────┼───────────────────────┐
         │                       │                       │
    ┌────▼─────┐          ┌─────▼──────┐         ┌─────▼──────┐
    │  User    │          │   Order    │         │  Product   │
    │  Service │          │   Service  │         │  Service   │
    └──────────┘          └────────────┘         └────────────┘
```

### Implementation Example (Node.js + Express)

```javascript
const express = require('express');
const httpProxy = require('http-proxy-middleware');
const jwt = require('jsonwebtoken');

class APIGateway {
    constructor() {
        this.app = express();
        this.setupMiddleware();
        this.setupRoutes();
    }
    
    setupMiddleware() {
        // 1. Logging
        this.app.use((req, res, next) => {
            console.log(`${req.method} ${req.path}`);
            next();
        });
        
        // 2. Authentication
        this.app.use('/api/*', this.authenticate.bind(this));
        
        // 3. Rate limiting
        this.app.use('/api/*', this.rateLimit.bind(this));
    }
    
    authenticate(req, res, next) {
        const token = req.headers.authorization?.replace('Bearer ', '');
        
        if (!token) {
            return res.status(401).json({ error: 'No token provided' });
        }
        
        try {
            const decoded = jwt.verify(token, process.env.JWT_SECRET);
            req.user = decoded;
            next();
        } catch (error) {
            return res.status(401).json({ error: 'Invalid token' });
        }
    }
    
    rateLimit(req, res, next) {
        // Simple rate limiting (use Redis in production)
        const userId = req.user.id;
        const key = `ratelimit:${userId}`;
        
        // Allow 100 requests per minute
        // Implementation with Redis...
        
        next();
    }
    
    setupRoutes() {
        // User Service routes
        this.app.use('/api/users', httpProxy.createProxyMiddleware({
            target: 'http://user-service:3000',
            changeOrigin: true,
            pathRewrite: {
                '^/api/users': '/users'
            }
        }));
        
        // Order Service routes
        this.app.use('/api/orders', httpProxy.createProxyMiddleware({
            target: 'http://order-service:3001',
            changeOrigin: true,
            pathRewrite: {
                '^/api/orders': '/orders'
            }
        }));
        
        // Product Service routes
        this.app.use('/api/products', httpProxy.createProxyMiddleware({
            target: 'http://product-service:3002',
            changeOrigin: true,
            pathRewrite: {
                '^/api/products': '/products'
            }
        }));
        
        // Health check
        this.app.get('/health', (req, res) => {
            res.json({ status: 'healthy' });
        });
    }
    
    start(port) {
        this.app.listen(port, () => {
            console.log(`API Gateway running on port ${port}`);
        });
    }
}

// Start gateway
const gateway = new APIGateway();
gateway.start(8080);
```

**API Gateway Responsibilities:**
1. **Authentication & Authorization** - Single point for security
2. **Request Routing** - Route to appropriate service
3. **Rate Limiting** - Protect services from overload
4. **Request/Response Transformation** - Adapt protocols
5. **Caching** - Cache responses to reduce load
6. **Monitoring & Logging** - Centralized metrics

---

## 7. Resilience Patterns

Microservices must handle failures gracefully.

### 7.1 Circuit Breaker Pattern

**Problem:** Service A calls Service B, but B is down. A keeps trying, wasting resources.

**Solution:** Circuit Breaker stops calls after threshold failures.

```
States:
CLOSED ──[failures exceed threshold]──> OPEN
  ↑                                       │
  │                                       │
  └──[successful test call]──── HALF_OPEN
```

```javascript
class CircuitBreaker {
    constructor(service, options = {}) {
        this.service = service;
        this.failureThreshold = options.failureThreshold || 5;
        this.timeout = options.timeout || 60000; // 60 seconds
        this.state = 'CLOSED';
        this.failureCount = 0;
        this.nextAttempt = Date.now();
    }
    
    async call(method, ...args) {
        if (this.state === 'OPEN') {
            if (Date.now() < this.nextAttempt) {
                throw new Error('Circuit breaker is OPEN');
            }
            // Try to recover
            this.state = 'HALF_OPEN';
        }
        
        try {
            const result = await this.service[method](...args);
            this.onSuccess();
            return result;
            
        } catch (error) {
            this.onFailure();
            throw error;
        }
    }
    
    onSuccess() {
        this.failureCount = 0;
        this.state = 'CLOSED';
    }
    
    onFailure() {
        this.failureCount++;
        
        if (this.failureCount >= this.failureThreshold) {
            this.state = 'OPEN';
            this.nextAttempt = Date.now() + this.timeout;
            console.log(`Circuit breaker opened. Will retry at ${new Date(this.nextAttempt)}`);
        }
    }
}

// Usage
class OrderService {
    constructor() {
        this.userServiceClient = new UserServiceClient();
        
        // Wrap with circuit breaker
        this.userServiceBreaker = new CircuitBreaker(
            this.userServiceClient,
            { failureThreshold: 5, timeout: 60000 }
        );
    }
    
    async createOrder(userId, items) {
        try {
            // Call through circuit breaker
            const user = await this.userServiceBreaker.call('getUser', userId);
            
            // Create order...
            
        } catch (error) {
            if (error.message === 'Circuit breaker is OPEN') {
                // Handle gracefully
                console.log('User service unavailable, using cached data');
                // Fallback logic...
            }
            throw error;
        }
    }
}
```

### 7.2 Retry with Exponential Backoff

```javascript
class RetryHelper {
    static async retry(fn, maxAttempts = 3, initialDelay = 1000) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
                return await fn();
            } catch (error) {
                lastError = error;
                
                if (attempt === maxAttempts) {
                    throw error;
                }
                
                // Exponential backoff: 1s, 2s, 4s, 8s...
                const delay = initialDelay * Math.pow(2, attempt - 1);
                
                console.log(`Attempt ${attempt} failed. Retrying in ${delay}ms...`);
                await this.sleep(delay);
            }
        }
        
        throw lastError;
    }
    
    static sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// Usage
async function callUnreliableService() {
    return await RetryHelper.retry(
        async () => {
            const response = await fetch('http://flaky-service/api/data');
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            return await response.json();
        },
        3,  // Max 3 attempts
        1000 // Start with 1 second delay
    );
}
```

### 7.3 Bulkhead Pattern

**Isolate resources** so failure in one area doesn't affect others.

```javascript
// Separate thread pools for different dependencies
class ResourcePool {
    constructor(maxSize) {
        this.maxSize = maxSize;
        this.active = 0;
        this.queue = [];
    }
    
    async execute(fn) {
        if (this.active >= this.maxSize) {
            // Wait in queue
            await new Promise(resolve => this.queue.push(resolve));
        }
        
        this.active++;
        
        try {
            return await fn();
        } finally {
            this.active--;
            
            // Process queue
            if (this.queue.length > 0) {
                const resolve = this.queue.shift();
                resolve();
            }
        }
    }
}

// Separate pools for different services
const userServicePool = new ResourcePool(10);
const paymentServicePool = new ResourcePool(5);

// If payment service is slow, it won't block user service calls
await userServicePool.execute(() => getUserData());
await paymentServicePool.execute(() => processPayment());
```

---

## 8. Distributed Transactions (Saga Pattern)

**Problem:** In microservices, traditional ACID transactions across services don't work.

**Solution:** Saga Pattern - sequence of local transactions with compensating transactions for rollback.

### Choreography-Based Saga

Services communicate via events.

```javascript
// Order Service
class OrderService {
    async createOrder(userId, items) {
        // 1. Create order (local transaction)
        const order = await this.orderRepository.save({
            userId,
            items,
            status: 'PENDING',
            total: calculateTotal(items)
        });
        
        // 2. Publish event
        await this.eventBus.publish('OrderCreated', {
            orderId: order.id,
            userId,
            items,
            total: order.total
        });
        
        return order;
    }
    
    // Listen for events
    async onPaymentSucceeded(event) {
        await this.orderRepository.updateStatus(
            event.orderId,
            'CONFIRMED'
        );
        
        await this.eventBus.publish('OrderConfirmed', {
            orderId: event.orderId
        });
    }
    
    async onPaymentFailed(event) {
        // Compensating transaction
        await this.orderRepository.updateStatus(
            event.orderId,
            'CANCELLED'
        );
    }
}

// Payment Service
class PaymentService {
    async onOrderCreated(event) {
        try {
            // Local transaction
            const payment = await this.processPayment(
                event.orderId,
                event.total
            );
            
            await this.eventBus.publish('PaymentSucceeded', {
                orderId: event.orderId,
                paymentId: payment.id
            });
            
        } catch (error) {
            await this.eventBus.publish('PaymentFailed', {
                orderId: event.orderId,
                reason: error.message
            });
        }
    }
}

// Inventory Service
class InventoryService {
    async onOrderConfirmed(event) {
        // Reserve inventory
        await this.reserveItems(event.orderId, event.items);
    }
    
    async onOrderCancelled(event) {
        // Compensating transaction - release inventory
        await this.releaseItems(event.orderId);
    }
}
```

**Flow:**
```
Order Service  ─[OrderCreated]→  Payment Service
                                       ↓
                              [PaymentSucceeded]
                                       ↓
Order Service  ←────────────────────────
      ↓
[OrderConfirmed]
      ↓
Inventory Service (reserves stock)

If payment fails:
Payment Service ─[PaymentFailed]→ Order Service
                                        ↓
                                  [OrderCancelled]
                                        ↓
                              Inventory Service (releases stock)
```

### Orchestration-Based Saga

Central orchestrator coordinates the saga.

```python
# Saga Orchestrator
class OrderSagaOrchestrator:
    def __init__(self, order_service, payment_service, inventory_service):
        self.order_service = order_service
        self.payment_service = payment_service
        self.inventory_service = inventory_service
    
    async def execute_order_saga(self, user_id, items):
        saga_state = {
            'step': 0,
            'compensations': []
        }
        
        try:
            # Step 1: Create order
            order = await self.order_service.create_order(user_id, items)
            saga_state['order_id'] = order.id
            saga_state['compensations'].append(
                lambda: self.order_service.cancel_order(order.id)
            )
            
            # Step 2: Process payment
            payment = await self.payment_service.process_payment(
                order.id,
                order.total
            )
            saga_state['payment_id'] = payment.id
            saga_state['compensations'].append(
                lambda: self.payment_service.refund(payment.id)
            )
            
            # Step 3: Reserve inventory
            await self.inventory_service.reserve(order.id, items)
            saga_state['compensations'].append(
                lambda: self.inventory_service.release(order.id)
            )
            
            # Step 4: Confirm order
            await self.order_service.confirm_order(order.id)
            
            return order
            
        except Exception as error:
            # Execute compensating transactions in reverse order
            print(f"Saga failed at step {saga_state['step']}: {error}")
            
            for compensation in reversed(saga_state['compensations']):
                try:
                    await compensation()
                except Exception as comp_error:
                    print(f"Compensation failed: {comp_error}")
            
            raise error
```

---

## 9. Advantages and Disadvantages

### ✅ Advantages

**1. Independent Deployment**
```bash
# Deploy only Order Service
kubectl set image deployment/order-service order-service=order:v2

# User Service keeps running on v1
```

**2. Technology Diversity**
- Use best tool for each job
- Different languages per service
- Experiment with new tech safely

**3. Scalability**
```yaml
# Scale only the service under load
kubectl scale deployment order-service --replicas=10
# Other services stay at 2 replicas
```

**4. Fault Isolation**
```
If Payment Service crashes:
- Order Service keeps running
- User Service keeps running
- Only payments are affected
```

**5. Team Autonomy**
- Teams own services end-to-end
- Deploy independently
- Choose own tech stack

### ❌ Disadvantages

**1. Complexity**
- Service discovery
- Distributed tracing
- Complex debugging
- Network latency

**2. Data Consistency**
- No ACID transactions
- Eventual consistency
- Saga patterns needed

**3. Testing Challenges**
```
Integration testing requires:
- All services running
- Message brokers
- Databases
- Service mesh
= Complex test environment
```

**4. Operational Overhead**
- Need DevOps expertise
- Container orchestration (Kubernetes)
- Monitoring tools
- Log aggregation

**5. Network Overhead**
```
Monolith: In-process call (< 1ms)
Microservices: HTTP/gRPC call (10-100ms)
```

---

## 10. Real-World Implementation Checklist

### Before Migrating to Microservices

✅ **Have you tried optimizing the monolith?**
✅ **Do you have > 20 developers?**
✅ **Do you have DevOps expertise?**
✅ **Do you need independent scaling?**
✅ **Are domain boundaries clear?**

### What You Need

**Infrastructure:**
- Container orchestration (Kubernetes, Docker Swarm)
- Service mesh (Istio, Linkerd) or API Gateway
- Message broker (Kafka, RabbitMQ)
- Service registry (Consul, Eureka)
- Distributed tracing (Jaeger, Zipkin)
- Centralized logging (ELK, Splunk)
- Monitoring (Prometheus, Grafana)

**Patterns:**
- Circuit breaker
- Retry with backoff
- Saga for distributed transactions
- API Gateway
- Service discovery

**Culture:**
- DevOps mindset
- You build it, you run it
- Automated testing
- CI/CD pipelines

---

## Chapter 5 Summary

### Key Concepts

1. **Microservices** = Small, autonomous services
2. **One database per service** - No shared databases
3. **Inter-service communication** - REST, gRPC, or async messaging
4. **Service discovery** - Dynamic service location
5. **API Gateway** - Single entry point for clients
6. **Resilience patterns** - Circuit breaker, retry, bulkhead
7. **Saga pattern** - Distributed transactions

### When to Use Microservices

✅ Large teams (> 20 developers)
✅ Need independent deployment
✅ Different scaling requirements
✅ Have DevOps maturity

❌ Small team (< 10 developers)
❌ Simple domain
❌ Limited DevOps expertise
❌ Need strong consistency

### Interview Tips

**Common Questions:**
1. "How do microservices communicate?"
2. "How do you handle transactions across services?"
3. "What is the Circuit Breaker pattern?"
4. "Monolith vs Microservices - when to use each?"

**Practice:**
- Draw microservices architecture diagram
- Explain Saga pattern with example
- Discuss trade-offs clearly
- Know patterns (Circuit Breaker, API Gateway, Service Discovery)

### Next Steps

Chapter 6 will cover **Event-Driven Architecture** - an architectural style perfect for real-time, reactive systems.