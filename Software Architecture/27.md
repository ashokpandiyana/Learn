# Chapter 27: Data Consistency Models

## Table of Contents
1. Introduction to Consistency Models
2. Strong Consistency
3. Eventual Consistency
4. Causal Consistency
5. Read-Your-Writes Consistency
6. Monotonic Reads
7. Consistent Prefix Reads
8. Linearizability
9. Serializability
10. Tunable Consistency
11. Real-World Examples

---

## 1. Introduction to Consistency Models

**Definition:** A consistency model defines the rules for how and when changes made by one process become visible to other processes.

### Why It Matters

```
Scenario: Bank account transfer

Without consistency guarantees:
User transfers $100 from Account A to Account B

Possible issues:
- Money deducted from A but not added to B (lost $100!)
- Both see different balances
- Transfer counted twice
- Order of operations unclear

With proper consistency:
- Transfer is atomic
- All users see consistent state
- Order preserved
```

### The Consistency-Performance Trade-off

```
Strong Consistency:
├─ Pros: Always correct, no surprises
└─ Cons: Slow (wait for all nodes), less available

Eventual Consistency:
├─ Pros: Fast, highly available
└─ Cons: Temporary inconsistencies, complex to reason about

Choose based on business requirements!
```

---

## 2. Strong Consistency

**Definition:** After an update completes, all subsequent reads will return the updated value.

### Characteristics

```
Timeline:
T1: Write(x = 1)
T2: Write completes
T3: Read(x) → 1 (guaranteed)
T4: Read(x) → 1 (guaranteed)

All reads after write see new value
No stale data ever
```

### Implementation

```python
# ============================================
# Strong Consistency with Quorum Reads/Writes
# ============================================

class StronglyConsistentStore:
    def __init__(self, replicas):
        self.replicas = replicas
        self.num_replicas = len(replicas)
        self.quorum_size = (self.num_replicas // 2) + 1
    
    async def write(self, key, value):
        """Write with strong consistency"""
        version = self.get_next_version()
        success_count = 0
        
        # Write to all replicas
        for replica in self.replicas:
            try:
                await replica.write(key, value, version)
                success_count += 1
            except Exception as e:
                print(f"Write to {replica.id} failed: {e}")
        
        # Must achieve quorum
        if success_count < self.quorum_size:
            # Rollback successful writes
            await self.rollback_write(key, version)
            raise Exception(
                f"Write failed: only {success_count}/{self.quorum_size} replicas"
            )
        
        print(f"Write successful: {success_count}/{self.num_replicas} replicas")
        return version
    
    async def read(self, key):
        """Read with strong consistency"""
        values = []
        
        # Read from quorum
        for replica in self.replicas[:self.quorum_size]:
            try:
                value = await replica.read(key)
                values.append(value)
            except Exception as e:
                print(f"Read from {replica.id} failed: {e}")
        
        if len(values) < self.quorum_size:
            raise Exception("Could not achieve read quorum")
        
        # Return latest version (highest version number)
        latest = max(values, key=lambda v: v['version'])
        
        # Repair any stale replicas (read repair)
        await self.repair_stale_replicas(key, latest)
        
        return latest['value']

# Properties:
# - Read quorum + Write quorum > N (total replicas)
# - Guarantees reads see latest write
# - Example: N=5, Write quorum=3, Read quorum=3 (3+3>5 ✓)
```

### PostgreSQL Synchronous Replication

```sql
-- ============================================
-- Strong Consistency with Synchronous Replication
-- ============================================

-- postgresql.conf (Primary)
synchronous_standby_names = 'standby1,standby2'  -- Wait for these
synchronous_commit = 'on'  -- Wait for sync before commit

-- Write transaction
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;  -- Blocks until standby confirms (strong consistency)

-- Read from any replica
SELECT * FROM accounts WHERE id = 1;
-- Guaranteed to see committed value (after COMMIT returns)
```

---

## 3. Eventual Consistency

**Definition:** If no new updates are made, eventually all replicas will converge to the same value.

### Characteristics

```
Timeline:
T1: Write(x = 1) to Node A
T2: Read(x) from Node B → 0 (old value)
T3: Read(x) from Node B → 0 (still old)
T4: Read(x) from Node B → 1 (eventually consistent)

Temporary inconsistency allowed
Eventually converges
```

### Use Cases

```
Good for:
✅ Social media posts (ok if not instant)
✅ Product catalogs (prices don't change every second)
✅ Analytics data (approximate is fine)
✅ Caching (stale cache eventually refreshes)

Not good for:
❌ Bank balances
❌ Inventory (overselling risk)
❌ Booking systems (double booking risk)
```

### Implementation

```javascript
// ============================================
// Eventually Consistent Store
// ============================================

class EventuallyConsistentStore {
  constructor(replicas) {
    this.replicas = replicas;
    this.replicationQueue = [];
  }
  
  async write(key, value) {
    // Write to one node (fast)
    const primaryReplica = this.replicas[0];
    await primaryReplica.write(key, value);
    
    // Queue async replication to others
    this.queueReplication(key, value);
    
    // Return immediately (don't wait for replication)
    return { success: true, note: 'Replication in progress' };
  }
  
  queueReplication(key, value) {
    // Background job replicates to other nodes
    setImmediate(async () => {
      for (let i = 1; i < this.replicas.length; i++) {
        try {
          await this.replicas[i].write(key, value);
          console.log(`Replicated to ${this.replicas[i].id}`);
        } catch (error) {
          console.error(`Replication to ${this.replicas[i].id} failed:`, error);
          // Retry later
          this.replicationQueue.push({ key, value, replica: i });
        }
      }
    });
  }
  
  async read(key) {
    // Read from any replica (might be stale)
    const replica = this.replicas[
      Math.floor(Math.random() * this.replicas.length)
    ];
    
    return await replica.read(key);
  }
  
  async retryFailedReplications() {
    /**
     * Background job to retry failed replications
     */
    while (this.replicationQueue.length > 0) {
      const task = this.replicationQueue.shift();
      
      try {
        await this.replicas[task.replica].write(task.key, task.value);
        console.log(`Retry successful: ${this.replicas[task.replica].id}`);
      } catch (error) {
        // Put back in queue
        this.replicationQueue.push(task);
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
  }
}

// DynamoDB Example (Eventually Consistent)
const AWS = require('aws-sdk');
const dynamodb = new AWS.DynamoDB.DocumentClient();

// Write
await dynamodb.put({
  TableName: 'Users',
  Item: { userId: '123', name: 'John' }
}).promise();
// Returns immediately after writing to leader

// Eventually consistent read (default, faster)
const result = await dynamodb.get({
  TableName: 'Users',
  Key: { userId: '123' }
  // ConsistentRead: false (default)
}).promise();
// Might return stale data

// Strongly consistent read (slower)
const consistentResult = await dynamodb.get({
  TableName: 'Users',
  Key: { userId: '123' },
  ConsistentRead: true  // Force strong consistency
}).promise();
// Guaranteed latest data, but 2x latency
```

---

## 4. Causal Consistency

**Definition:** Writes that are causally related must be seen in the same order by all processes.

### Example

```
User A posts: "I got a new dog!" (post1)
User B replies: "What breed?" (post2)

Causal relationship: post2 caused by post1

Causal consistency guarantees:
- Anyone who sees post2 must see post1 first
- Can't see reply before original post

Non-causal events (concurrent):
User C posts: "Weather is nice" (post3)
- post3 independent of post1 and post2
- Can be seen in any order relative to post1/post2
```

### Implementation

```typescript
// ============================================
// Causal Consistency with Version Vectors
// ============================================

interface VersionVector {
  [nodeId: string]: number;
}

class CausalConsistencyStore {
  private nodeId: string;
  private versionVector: VersionVector;
  private data: Map<string, any>;
  
  constructor(nodeId: string) {
    this.nodeId = nodeId;
    this.versionVector = {};
    this.data = new Map();
  }
  
  write(key: string, value: any): { value: any; version: VersionVector } {
    // Increment own version
    this.versionVector[this.nodeId] = (this.versionVector[this.nodeId] || 0) + 1;
    
    // Store value with version
    const entry = {
      value,
      version: { ...this.versionVector }
    };
    
    this.data.set(key, entry);
    
    return entry;
  }
  
  read(key: string) {
    return this.data.get(key);
  }
  
  canApply(remoteVersion: VersionVector): boolean {
    /**
     * Check if remote write can be applied
     * Can apply if all dependencies satisfied
     */
    for (const [nodeId, version] of Object.entries(remoteVersion)) {
      if (nodeId === this.nodeId) continue;
      
      const localVersion = this.versionVector[nodeId] || 0;
      
      // If remote has higher version for other node,
      // we're missing some writes - can't apply yet
      if (version > localVersion) {
        return false;
      }
    }
    
    return true;
  }
  
  applyRemoteWrite(key: string, value: any, version: VersionVector): boolean {
    // Check if we have all dependencies
    if (!this.canApply(version)) {
      console.log(`Cannot apply write - missing dependencies`);
      return false;
    }
    
    // Update version vector (take max of each component)
    for (const [nodeId, remoteVersion] of Object.entries(version)) {
      this.versionVector[nodeId] = Math.max(
        this.versionVector[nodeId] || 0,
        remoteVersion
      );
    }
    
    // Store value
    this.data.set(key, { value, version });
    
    return true;
  }
}

// ============================================
// Example: Social Media Posts
// ============================================

// Node A
const nodeA = new CausalConsistencyStore('A');

// User posts (Node A)
const post1 = nodeA.write('post:1', 'I got a new dog!');
// Version: {A: 1}

// Replicate to Node B
const nodeB = new CausalConsistencyStore('B');
nodeB.applyRemoteWrite('post:1', post1.value, post1.version);

// User replies (Node B)
const post2 = nodeB.write('post:2', 'What breed?');
// Version: {A: 1, B: 1}

// Replicate to Node C
const nodeC = new CausalConsistencyStore('C');

// Try to apply reply first (out of order)
const canApply = nodeC.canApply(post2.version);
// Returns false - missing dependency (post1)

// Must apply original post first
nodeC.applyRemoteWrite('post:1', post1.value, post1.version);
// Now can apply reply
nodeC.applyRemoteWrite('post:2', post2.value, post2.version);

// Causal order preserved!
```

---

## 5. Read-Your-Writes Consistency

**Definition:** After a write, the same client's subsequent reads will always see that write or a later value.

### Example

```
User updates profile:
T1: Write(name = "John Smith")
T2: Read(name) → "John Smith" (guaranteed to see own write)

Another user:
T1: Read(name) → "John Doe" (might see old value)
T3: Read(name) → "John Smith" (eventually sees new value)
```

### Implementation

```python
# ============================================
# Read-Your-Writes Consistency
# ============================================

class ReadYourWritesStore:
    def __init__(self, master, replicas):
        self.master = master
        self.replicas = replicas
        self.user_last_write = {}  # Track last write timestamp per user
    
    async def write(self, user_id, key, value):
        """Write to master"""
        timestamp = time.time()
        
        # Write to master
        await self.master.write(key, value, timestamp)
        
        # Track user's last write
        self.user_last_write[user_id] = timestamp
        
        return timestamp
    
    async def read(self, user_id, key):
        """Read with read-your-writes guarantee"""
        last_write_time = self.user_last_write.get(user_id, 0)
        
        if last_write_time == 0:
            # User hasn't written, can read from any replica
            replica = random.choice(self.replicas)
            return await replica.read(key)
        
        # User has written recently - need to ensure we see that write
        
        # Option 1: Read from master (guaranteed to see all writes)
        return await self.master.read(key)
        
        # Option 2: Check replica lag and choose appropriate replica
        # for replica in self.replicas:
        #     if replica.last_sync_time >= last_write_time:
        #         return await replica.read(key)
        # return await self.master.read(key)  # Fallback to master

# ============================================
# AWS DynamoDB Read-Your-Writes
# ============================================

const AWS = require('aws-sdk');
const dynamodb = new AWS.DynamoDB.DocumentClient();

async function updateAndRead(userId) {
  // Write
  await dynamodb.put({
    TableName: 'Users',
    Item: { userId, name: 'Updated Name' }
  }).promise();
  
  // Immediate read - might be stale (eventual consistency)
  const eventualRead = await dynamodb.get({
    TableName: 'Users',
    Key: { userId },
    ConsistentRead: false  // Default
  }).promise();
  // Might return old name!
  
  // Consistent read - guaranteed to see own write
  const consistentRead = await dynamodb.get({
    TableName: 'Users',
    Key: { userId },
    ConsistentRead: true  // Read-your-writes
  }).promise();
  // Guaranteed to return 'Updated Name'
  
  return consistentRead.Item;
}
```

---

## 6. Monotonic Reads

**Definition:** If a process reads a value, any subsequent reads will return that value or a more recent value (never older).

### Example

```
✅ Monotonic Reads (Good):
T1: Read(x) → 1
T2: Read(x) → 1 (same)
T3: Read(x) → 2 (newer)
T4: Read(x) → 2 (same)

Never goes backward!

❌ Without Monotonic Reads (Bad):
T1: Read(x) from Replica1 → 2 (up-to-date)
T2: Read(x) from Replica2 → 1 (stale)
T3: Read(x) from Replica1 → 2 (up-to-date)

Goes backward - confusing!
```

### Implementation

```python
# ============================================
# Monotonic Reads Implementation
# ============================================

class MonotonicReadsStore:
    def __init__(self, replicas):
        self.replicas = replicas
        self.session_replicas = {}  # Map session to replica
    
    async def read(self, session_id, key):
        """Ensure monotonic reads per session"""
        
        # Sticky session - always read from same replica
        if session_id not in self.session_replicas:
            # Assign replica to session
            self.session_replicas[session_id] = random.choice(self.replicas)
        
        replica = self.session_replicas[session_id]
        
        # Always read from same replica = monotonic reads guaranteed
        return await replica.read(key)

# Alternative: Track last read version
class MonotonicReadsWithVersion:
    def __init__(self, replicas):
        self.replicas = replicas
        self.last_read_version = {}  # session_id -> version
    
    async def read(self, session_id, key):
        """Read with version tracking"""
        last_version = self.last_read_version.get(session_id, 0)
        
        # Try replicas until we find one with version >= last_version
        for replica in self.replicas:
            value = await replica.read(key)
            
            if value['version'] >= last_version:
                # This replica is up-to-date enough
                self.last_read_version[session_id] = value['version']
                return value
        
        # Fallback to master
        value = await self.master.read(key)
        self.last_read_version[session_id] = value['version']
        return value
```

---

## 7. Consistent Prefix Reads

**Definition:** Reads observe a consistent prefix of the write history (operations in order).

### Example

```
Writes in order:
1. INSERT post1
2. INSERT reply1 (to post1)
3. INSERT reply2 (to reply1)

✅ Consistent Prefix:
Read sees:
- []
- [post1]
- [post1, reply1]
- [post1, reply1, reply2]

Always in order!

❌ Without Consistent Prefix:
Read might see:
- [reply1, post1]  ← reply before post (wrong order!)
```

### Implementation

```typescript
// ============================================
// Consistent Prefix Guarantee
// ============================================

interface WriteOperation {
  key: string;
  value: any;
  sequenceNumber: number;
  dependencies: number[];  // Sequence numbers this depends on
}

class ConsistentPrefixStore {
  private writes: WriteOperation[] = [];
  private committedSequence: number = 0;
  
  async write(key: string, value: any, dependsOn: number[] = []): Promise<number> {
    const sequenceNumber = this.writes.length;
    
    const operation: WriteOperation = {
      key,
      value,
      sequenceNumber,
      dependencies: dependsOn
    };
    
    this.writes.push(operation);
    
    // Replicate to other nodes
    await this.replicateOperation(operation);
    
    return sequenceNumber;
  }
  
  canCommit(operation: WriteOperation): boolean {
    /**
     * Can only commit if all dependencies are committed
     */
    return operation.dependencies.every(
      dep => dep <= this.committedSequence
    );
  }
  
  async commitOperations() {
    /**
     * Commit operations in order, ensuring consistent prefix
     */
    while (this.committedSequence < this.writes.length) {
      const nextOp = this.writes[this.committedSequence];
      
      if (this.canCommit(nextOp)) {
        // All dependencies satisfied - can commit
        await this.applyOperation(nextOp);
        this.committedSequence++;
      } else {
        // Missing dependencies - wait
        break;
      }
    }
  }
  
  async read(key: string) {
    /**
     * Read returns consistent prefix
     * Only returns committed operations
     */
    for (let i = this.committedSequence - 1; i >= 0; i--) {
      if (this.writes[i].key === key) {
        return this.writes[i].value;
      }
    }
    
    return null;
  }
}

// Usage
const store = new ConsistentPrefixStore();

// Write operations with dependencies
const seq1 = await store.write('post:1', 'Original post');  // seq=0
const seq2 = await store.write('post:2', 'Reply to post1', [seq1]);  // seq=1, depends on 0
const seq3 = await store.write('post:3', 'Reply to reply', [seq2]);  // seq=2, depends on 1

// Commit in order
await store.commitOperations();

// Read always sees consistent prefix
// Either sees: [], [post1], [post1, reply1], or [post1, reply1, reply2]
// Never: [reply1, post1] or [reply2, post1]
```

---

## 8. Linearizability

**Definition:** Strongest consistency model. Operations appear to happen instantaneously at some point between invocation and response.

### Linearizability Guarantees

```
Guarantees:
1. Once write completes, all subsequent reads see that value
2. Operations have a total order
3. Real-time ordering preserved

Example:
T1: Client A writes x=1
T2: Write completes
T3: Client B reads x → Must return 1 (not 0)

If another client reads after T2, they MUST see 1
```

### Implementation

```java
// ============================================
// Linearizable Key-Value Store
// ============================================
import java.util.concurrent.*;
import java.util.*;

public class LinearizableStore {
    private Map<String, VersionedValue> data;
    private ReadWriteLock lock;
    private long version;
    
    public LinearizableStore() {
        this.data = new ConcurrentHashMap<>();
        this.lock = new ReentrantReadWriteLock();
        this.version = 0;
    }
    
    public long write(String key, String value) {
        lock.writeLock().lock();
        try {
            version++;
            
            VersionedValue versionedValue = new VersionedValue(
                value,
                version,
                System.currentTimeMillis()
            );
            
            data.put(key, versionedValue);
            
            System.out.println(
                "Write: " + key + " = " + value + " (version: " + version + ")"
            );
            
            return version;
            
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public VersionedValue read(String key) {
        lock.readLock().lock();
        try {
            VersionedValue value = data.get(key);
            
            System.out.println(
                "Read: " + key + " = " + 
                (value != null ? value.value : "null") +
                " (version: " + (value != null ? value.version : "N/A") + ")"
            );
            
            return value;
            
        } finally {
            lock.readLock().unlock();
        }
    }
}

class VersionedValue {
    String value;
    long version;
    long timestamp;
    
    VersionedValue(String value, long version, long timestamp) {
        this.value = value;
        this.version = version;
        this.timestamp = timestamp;
    }
}

// Usage
LinearizableStore store = new LinearizableStore();

// Thread 1
new Thread(() -> {
    long v = store.write("x", "1");
    System.out.println("Write completed at version " + v);
}).start();

// Thread 2 (starts slightly after)
new Thread(() -> {
    Thread.sleep(100);  // Wait a bit
    VersionedValue val = store.read("x");
    // GUARANTEED to see "1" (linearizability)
}).start();
```

---

## 9. Serializability

**Definition:** Transactions execute as if they were run serially (one after another), even though they may run concurrently.

### Example

```
Two concurrent transactions:

T1: Read(x)=10, Write(x=15)
T2: Read(x)=10, Write(x=20)

Serializable execution:
Option A: T1 then T2
  T1: Read(x)=10, Write(x=15)
  T2: Read(x)=15, Write(x=20)
  Final: x=20

Option B: T2 then T1
  T2: Read(x)=10, Write(x=20)
  T1: Read(x)=20, Write(x=15)
  Final: x=15

Both are valid serializable outcomes

Non-serializable (invalid):
Final: x=10 (both reads happened before either write)
```

### Implementation with Locks

```python
# ============================================
# Serializability with Two-Phase Locking
# ============================================

class TwoPhaseL ocking:
    def __init__(self):
        self.locks = {}  # key -> lock owner
        self.lock_queue = {}  # key -> waiting transactions
    
    def acquire_lock(self, transaction_id, key, lock_type='read'):
        """Acquire lock (growing phase)"""
        if key in self.locks:
            current_holder = self.locks[key]
            
            if lock_type == 'write' or current_holder['type'] == 'write':
                # Write lock or existing write lock - must wait
                if key not in self.lock_queue:
                    self.lock_queue[key] = []
                
                self.lock_queue[key].append({
                    'transaction_id': transaction_id,
                    'type': lock_type
                })
                
                return False
        
        # Acquire lock
        self.locks[key] = {
            'transaction_id': transaction_id,
            'type': lock_type
        }
        
        return True
    
    def release_all_locks(self, transaction_id):
        """Release all locks (shrinking phase)"""
        # Two-phase locking: Once you release ANY lock,
        # you cannot acquire new locks
        
        keys_to_release = [
            key for key, lock in self.locks.items()
            if lock['transaction_id'] == transaction_id
        ]
        
        for key in keys_to_release:
            del self.locks[key]
            
            # Grant lock to next waiting transaction
            if key in self.lock_queue and self.lock_queue[key]:
                next_tx = self.lock_queue[key].pop(0)
                self.locks[key] = next_tx

# ============================================
# Transaction Example
# ============================================

class Transaction:
    def __init__(self, transaction_id, lock_manager):
        self.id = transaction_id
        self.lock_manager = lock_manager
        self.operations = []
    
    def read(self, key):
        # Acquire read lock
        while not self.lock_manager.acquire_lock(self.id, key, 'read'):
            time.sleep(0.01)  # Wait for lock
        
        value = database.read(key)
        self.operations.append(('read', key))
        return value
    
    def write(self, key, value):
        # Acquire write lock
        while not self.lock_manager.acquire_lock(self.id, key, 'write'):
            time.sleep(0.01)
        
        database.write(key, value)
        self.operations.append(('write', key, value))
    
    def commit(self):
        # Release all locks
        self.lock_manager.release_all_locks(self.id)
        print(f"Transaction {self.id} committed")

# Usage
lock_manager = TwoPhaseL ocking()

# Transaction 1
t1 = Transaction('T1', lock_manager)
x = t1.read('x')  # Acquires read lock on x
t1.write('x', x + 5)  # Upgrades to write lock
t1.commit()  # Releases locks

# Transaction 2 (concurrent)
t2 = Transaction('T2', lock_manager)
x = t2.read('x')  # Waits for T1 to release lock
t2.write('x', x + 10)
t2.commit()

# Result: Serializable (T1 then T2, or T2 then T1)
```

---

## 10. Tunable Consistency

**Definition:** Choose consistency level per operation based on requirements.

### Cassandra Consistency Levels

```python
# ============================================
# Cassandra Tunable Consistency
# ============================================
from cassandra.cluster import Cluster
from cassandra.query import SimpleStatement, ConsistencyLevel

cluster = Cluster(['localhost'])
session = cluster.connect('myapp')

# ============================================
# Write Consistency Levels
# ============================================

# ANY - fastest, least consistent
query_any = SimpleStatement(
    "INSERT INTO logs (id, message) VALUES (?, ?)",
    consistency_level=ConsistencyLevel.ANY
)
# Write succeeds if ANY node acknowledges (even hinted handoff)
# Use for: Logs, metrics (loss acceptable)

# ONE - fast, weak
query_one = SimpleStatement(
    "INSERT INTO posts (id, content) VALUES (?, ?)",
    consistency_level=ConsistencyLevel.ONE
)
# Write succeeds if ONE node acknowledges
# Use for: User-generated content, social media

# QUORUM - balanced
query_quorum = SimpleStatement(
    "INSERT INTO orders (id, total) VALUES (?, ?)",
    consistency_level=ConsistencyLevel.QUORUM
)
# Write succeeds if MAJORITY acknowledges
# Use for: Important data (orders, payments)

# ALL - strongest, slowest
query_all = SimpleStatement(
    "INSERT INTO accounts (id, balance) VALUES (?, ?)",
    consistency_level=ConsistencyLevel.ALL
)
# Write succeeds only if ALL nodes acknowledge
# Use for: Critical data (financial, inventory)

# ============================================
# Read Consistency Levels
# ============================================

# Read with ONE (fast, might be stale)
read_one = SimpleStatement(
    "SELECT * FROM posts WHERE id = ?",
    consistency_level=ConsistencyLevel.ONE
)
result = session.execute(read_one, (post_id,))

# Read with QUORUM (stronger)
read_quorum = SimpleStatement(
    "SELECT * FROM orders WHERE id = ?",
    consistency_level=ConsistencyLevel.QUORUM
)
result = session.execute(read_quorum, (order_id,))
# Reads from majority, returns latest

# Formula for strong consistency:
# R + W > N
# R: Read replicas
# W: Write replicas
# N: Total replicas
# 
# Example: N=3, W=2 (QUORUM), R=2 (QUORUM)
# 2 + 2 > 3 ✓ (strong consistency)
```

---

## 11. Real-World Examples

### Google Spanner

**Unique:** Globally distributed database with strong consistency.

```
How it works:
1. TrueTime API (GPS + atomic clocks)
   - Knows current time within 7ms uncertainty
   
2. Wait out uncertainty
   - After write, wait 7ms
   - Guarantees all nodes see write
   
3. Linearizable reads
   - Reads see all committed writes
   - No stale data

Trade-off:
- Added latency (7ms wait)
- Complex infrastructure (atomic clocks)
- But: Strong consistency globally!
```

### Amazon DynamoDB

```javascript
// ============================================
// DynamoDB Consistency Options
// ============================================

// Eventually consistent read (default, faster)
const eventual = await dynamodb.get({
  TableName: 'Users',
  Key: { userId: '123' },
  ConsistentRead: false  // Default
}).promise();

// Latency: ~5ms
// Might be stale (up to 1 second old)

// Strongly consistent read (slower)
const strong = await dynamodb.get({
  TableName: 'Users',
  Key: { userId: '123' },
  ConsistentRead: true
}).promise();

// Latency: ~10ms (2x slower)
// Guaranteed latest value

// Choose based on use case:
// - User profile → Eventually consistent (ok if slightly stale)
// - Shopping cart → Strongly consistent (must be accurate)
// - Product catalog → Eventually consistent (prices don't change often)
// - Inventory → Strongly consistent (prevent overselling)
```

---

## Chapter 27 Summary

### Key Concepts

1. **Strong Consistency** - All see same data immediately
2. **Eventual Consistency** - All see same data eventually
3. **Causal Consistency** - Preserve cause-effect
4. **Read-Your-Writes** - See own writes immediately
5. **Monotonic Reads** - Never go backward
6. **Consistent Prefix** - See operations in order
7. **Linearizability** - Strongest model
8. **Serializability** - Transactions appear serial
9. **Tunable Consistency** - Choose per operation

### Consistency Hierarchy

```
Strongest (Slowest):
├─ Linearizability
├─ Serializability
├─ Strong Consistency
├─ Causal Consistency
├─ Read-Your-Writes
├─ Monotonic Reads
├─ Consistent Prefix
└─ Eventual Consistency
Weakest (Fastest)
```

### Choosing Consistency Level

| Use Case | Consistency Level | Why |
|----------|------------------|-----|
| **Bank balance** | Strong/Linearizable | Correctness critical |
| **Inventory** | Strong | Prevent overselling |
| **Shopping cart** | Read-your-writes | See own changes |
| **Social media feed** | Eventual | Speed matters, staleness ok |
| **Product catalog** | Eventual | Changes infrequent |
| **Chat messages** | Causal | Preserve conversation order |
| **Analytics** | Eventual | Approximate is fine |

### Consistency Formula

```
For Strong Consistency in Quorum Systems:
R + W > N

Where:
R = Read quorum size
W = Write quorum size  
N = Total replicas

Example: N=5
- W=3, R=3 → 3+3>5 ✓ Strong consistency
- W=2, R=2 → 2+2=4 ✗ Not strong (eventual)
- W=1, R=5 → 1+5>5 ✓ Strong (read all)
```

### Interview Tips

**Common Questions:**
1. "Explain different consistency models"
2. "Strong vs eventual consistency - trade-offs?"
3. "What is linearizability?"
4. "How does read-your-writes work?"

**How to Answer:**
- Draw timelines showing read/write order
- Give concrete examples (bank vs social media)
- Explain trade-offs (consistency vs performance)
- Mention real systems (Spanner, DynamoDB, Cassandra)
- Discuss business requirements driving choice

### Best Practices

1. **Default to eventual** - Use strong only when needed
2. **Document consistency guarantees** - Make explicit
3. **Test with delays** - Simulate replication lag
4. **Provide consistency options** - Let clients choose
5. **Monitor consistency violations** - Track stale reads
6. **Design for AP** - Unless strong consistency required

### Next Steps

Chapter 28 will cover **Service Mesh** - infrastructure layer for microservices providing observability, security, and traffic management without changing application code.