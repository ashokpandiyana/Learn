# Chapter 7: Hexagonal Architecture (Ports & Adapters)

## Table of Contents
1. Introduction to Hexagonal Architecture
2. Core Concepts
3. Ports vs Adapters
4. Primary (Driving) Adapters
5. Secondary (Driven) Adapters
6. Dependency Inversion in Practice
7. Complete Implementation Example
8. Testing in Hexagonal Architecture
9. Advantages and Disadvantages
10. Real-World Applications

---

## 1. Introduction to Hexagonal Architecture

**Definition:** Hexagonal Architecture (also called Ports and Adapters) is an architectural pattern that isolates core business logic from external concerns by defining clear boundaries through ports (interfaces) and adapters (implementations).

**Created by:** Alistair Cockburn (2005)

### The Problem It Solves

Traditional layered architecture often leads to:
```
UI Layer depends on Business Layer
Business Layer depends on Data Layer ‚ùå
‚Üí Business logic coupled to database
‚Üí Hard to test without database
‚Üí Hard to change infrastructure
```

**Hexagonal Architecture Solution:**
```
Business Logic (Core) ‚Üê‚Üí Ports (Interfaces) ‚Üê‚Üí Adapters (Implementations)
                ‚Üì                                      ‚Üì
        No dependencies                      Adapts external systems
        on infrastructure                    to core interfaces
```

### Key Principle

> **"The application is at the center, infrastructure is at the edges."**

Business logic doesn't know about:
- Databases
- Web frameworks
- Message queues
- External APIs

Everything external is accessed through **ports** (interfaces), and **adapters** implement those interfaces.

---

## 2. Core Concepts

### The Hexagon

```
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         /                       \
        /    Primary Ports        \
       /    (Input/Driving)        \
      ‚îÇ                             ‚îÇ
      ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
      ‚îÇ  ‚îÇ                   ‚îÇ    ‚îÇ
      ‚îÇ  ‚îÇ  Core Business    ‚îÇ    ‚îÇ
      ‚îÇ  ‚îÇ      Logic        ‚îÇ    ‚îÇ
      ‚îÇ  ‚îÇ   (Domain)        ‚îÇ    ‚îÇ
      ‚îÇ  ‚îÇ                   ‚îÇ    ‚îÇ
      ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
      ‚îÇ                             ‚îÇ
       \   Secondary Ports         /
        \  (Output/Driven)        /
         \                       /
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Why Hexagon?**
- Not because of 6 sides
- Represents that there can be many ports
- Symmetry: No top/bottom, inside/outside

### Three Layers

**1. Core Domain (Inside the Hexagon)**
- Business logic
- Domain models
- Use cases
- No dependencies on external systems

**2. Ports (Hexagon Boundary)**
- Interfaces/contracts
- Define how to interact with core
- Two types: Primary and Secondary

**3. Adapters (Outside the Hexagon)**
- Implementations of ports
- Connect external world to core
- Can be replaced without changing core

---

## 3. Ports vs Adapters

### Ports (Interfaces)

**Primary Ports (Input/Driving)**
- Define operations that drive the application
- Used by external actors (UI, API, CLI)
- Example: `UserService`, `OrderService`

```typescript
// Primary Port (Interface)
interface OrderService {
    placeOrder(userId: string, items: OrderItem[]): Promise<Order>;
    getOrder(orderId: string): Promise<Order>;
    cancelOrder(orderId: string): Promise<void>;
}
```

**Secondary Ports (Output/Driven)**
- Define operations needed by the application
- Used by the core to interact with external systems
- Example: `OrderRepository`, `EmailSender`, `PaymentGateway`

```typescript
// Secondary Port (Interface)
interface OrderRepository {
    save(order: Order): Promise<Order>;
    findById(orderId: string): Promise<Order | null>;
    findByUserId(userId: string): Promise<Order[]>;
}

interface PaymentGateway {
    processPayment(amount: number, cardToken: string): Promise<PaymentResult>;
}
```

### Adapters (Implementations)

**Primary Adapters (Input)**
- REST controllers
- GraphQL resolvers
- CLI commands
- Message queue consumers

```typescript
// Primary Adapter (REST Controller)
class OrderController {
    constructor(private orderService: OrderService) {}
    
    async createOrder(req: Request, res: Response) {
        const order = await this.orderService.placeOrder(
            req.body.userId,
            req.body.items
        );
        res.status(201).json(order);
    }
}
```

**Secondary Adapters (Output)**
- Database implementations
- Email service clients
- Payment API clients
- File system access

```typescript
// Secondary Adapter (Database Implementation)
class PostgresOrderRepository implements OrderRepository {
    async save(order: Order): Promise<Order> {
        // PostgreSQL-specific code
        await this.db.query('INSERT INTO orders ...', order);
        return order;
    }
    
    async findById(orderId: string): Promise<Order | null> {
        const result = await this.db.query('SELECT * FROM orders WHERE id = ?', orderId);
        return result ? this.mapToOrder(result) : null;
    }
}
```

---

## 4. Primary (Driving) Adapters

Primary adapters drive the application by calling primary ports.

### Example 1: REST API Adapter

```typescript
// Primary Port (Application Service)
interface UserService {
    registerUser(email: string, password: string): Promise<User>;
    authenticateUser(email: string, password: string): Promise<AuthToken>;
    getUserById(userId: string): Promise<User>;
}

// Core Implementation
class UserServiceImpl implements UserService {
    constructor(
        private userRepository: UserRepository,
        private passwordHasher: PasswordHasher,
        private tokenGenerator: TokenGenerator
    ) {}
    
    async registerUser(email: string, password: string): Promise<User> {
        // Business logic
        const existingUser = await this.userRepository.findByEmail(email);
        if (existingUser) {
            throw new Error('Email already registered');
        }
        
        const hashedPassword = await this.passwordHasher.hash(password);
        
        const user = new User({
            id: generateId(),
            email,
            passwordHash: hashedPassword,
            createdAt: new Date()
        });
        
        return await this.userRepository.save(user);
    }
    
    async authenticateUser(email: string, password: string): Promise<AuthToken> {
        const user = await this.userRepository.findByEmail(email);
        if (!user) {
            throw new Error('Invalid credentials');
        }
        
        const isValid = await this.passwordHasher.verify(password, user.passwordHash);
        if (!isValid) {
            throw new Error('Invalid credentials');
        }
        
        return this.tokenGenerator.generate(user.id);
    }
}

// Primary Adapter: REST Controller
import express from 'express';

class UserController {
    private router = express.Router();
    
    constructor(private userService: UserService) {
        this.setupRoutes();
    }
    
    private setupRoutes() {
        this.router.post('/register', this.register.bind(this));
        this.router.post('/login', this.login.bind(this));
        this.router.get('/:id', this.getUser.bind(this));
    }
    
    private async register(req: express.Request, res: express.Response) {
        try {
            const { email, password } = req.body;
            
            // Validation (adapter responsibility)
            if (!email || !password) {
                return res.status(400).json({ error: 'Email and password required' });
            }
            
            // Call core through port
            const user = await this.userService.registerUser(email, password);
            
            // Transform to DTO (adapter responsibility)
            res.status(201).json({
                id: user.id,
                email: user.email
            });
            
        } catch (error: any) {
            res.status(400).json({ error: error.message });
        }
    }
    
    private async login(req: express.Request, res: express.Response) {
        try {
            const { email, password } = req.body;
            const token = await this.userService.authenticateUser(email, password);
            res.json({ token });
        } catch (error: any) {
            res.status(401).json({ error: error.message });
        }
    }
    
    private async getUser(req: express.Request, res: express.Response) {
        try {
            const user = await this.userService.getUserById(req.params.id);
            res.json({
                id: user.id,
                email: user.email
            });
        } catch (error: any) {
            res.status(404).json({ error: 'User not found' });
        }
    }
    
    getRouter() {
        return this.router;
    }
}
```

### Example 2: GraphQL Adapter

```typescript
// Primary Adapter: GraphQL Resolver
import { GraphQLResolverMap } from '@graphql-tools/utils';

class UserResolvers {
    constructor(private userService: UserService) {}
    
    getResolvers(): GraphQLResolverMap {
        return {
            Query: {
                user: async (_, { id }) => {
                    return await this.userService.getUserById(id);
                }
            },
            Mutation: {
                registerUser: async (_, { email, password }) => {
                    return await this.userService.registerUser(email, password);
                },
                login: async (_, { email, password }) => {
                    return await this.userService.authenticateUser(email, password);
                }
            }
        };
    }
}

// GraphQL Schema
const typeDefs = `
    type User {
        id: ID!
        email: String!
    }
    
    type AuthToken {
        token: String!
    }
    
    type Query {
        user(id: ID!): User
    }
    
    type Mutation {
        registerUser(email: String!, password: String!): User
        login(email: String!, password: String!): AuthToken
    }
`;
```

### Example 3: CLI Adapter

```typescript
// Primary Adapter: Command Line Interface
import { Command } from 'commander';

class UserCLI {
    private program = new Command();
    
    constructor(private userService: UserService) {
        this.setupCommands();
    }
    
    private setupCommands() {
        this.program
            .command('register')
            .description('Register a new user')
            .requiredOption('-e, --email <email>', 'User email')
            .requiredOption('-p, --password <password>', 'User password')
            .action(async (options) => {
                try {
                    const user = await this.userService.registerUser(
                        options.email,
                        options.password
                    );
                    console.log(`‚úì User registered: ${user.id}`);
                } catch (error: any) {
                    console.error(`‚úó Error: ${error.message}`);
                    process.exit(1);
                }
            });
        
        this.program
            .command('login')
            .description('Authenticate user')
            .requiredOption('-e, --email <email>', 'User email')
            .requiredOption('-p, --password <password>', 'User password')
            .action(async (options) => {
                try {
                    const token = await this.userService.authenticateUser(
                        options.email,
                        options.password
                    );
                    console.log(`‚úì Authentication successful`);
                    console.log(`Token: ${token}`);
                } catch (error: any) {
                    console.error(`‚úó Error: ${error.message}`);
                    process.exit(1);
                }
            });
    }
    
    run(args: string[]) {
        this.program.parse(args);
    }
}

// Usage: node cli.js register -e user@example.com -p password123
```

---

## 5. Secondary (Driven) Adapters

Secondary adapters implement the ports required by the core.

### Example 1: Database Adapters

```typescript
// Secondary Port (Interface in Core)
interface UserRepository {
    save(user: User): Promise<User>;
    findById(userId: string): Promise<User | null>;
    findByEmail(email: string): Promise<User | null>;
}

// Secondary Adapter: PostgreSQL Implementation
import { Pool } from 'pg';

class PostgresUserRepository implements UserRepository {
    private pool: Pool;
    
    constructor(connectionString: string) {
        this.pool = new Pool({ connectionString });
    }
    
    async save(user: User): Promise<User> {
        const query = `
            INSERT INTO users (id, email, password_hash, created_at)
            VALUES ($1, $2, $3, $4)
            RETURNING *
        `;
        
        const result = await this.pool.query(query, [
            user.id,
            user.email,
            user.passwordHash,
            user.createdAt
        ]);
        
        return this.mapToUser(result.rows[0]);
    }
    
    async findById(userId: string): Promise<User | null> {
        const result = await this.pool.query(
            'SELECT * FROM users WHERE id = $1',
            [userId]
        );
        
        if (result.rows.length === 0) {
            return null;
        }
        
        return this.mapToUser(result.rows[0]);
    }
    
    async findByEmail(email: string): Promise<User | null> {
        const result = await this.pool.query(
            'SELECT * FROM users WHERE email = $1',
            [email]
        );
        
        if (result.rows.length === 0) {
            return null;
        }
        
        return this.mapToUser(result.rows[0]);
    }
    
    private mapToUser(row: any): User {
        return new User({
            id: row.id,
            email: row.email,
            passwordHash: row.password_hash,
            createdAt: row.created_at
        });
    }
}

// Secondary Adapter: MongoDB Implementation
import { MongoClient, Db } from 'mongodb';

class MongoUserRepository implements UserRepository {
    private db: Db;
    
    constructor(client: MongoClient, dbName: string) {
        this.db = client.db(dbName);
    }
    
    async save(user: User): Promise<User> {
        await this.db.collection('users').insertOne({
            _id: user.id,
            email: user.email,
            passwordHash: user.passwordHash,
            createdAt: user.createdAt
        });
        
        return user;
    }
    
    async findById(userId: string): Promise<User | null> {
        const doc = await this.db.collection('users').findOne({ _id: userId });
        
        if (!doc) {
            return null;
        }
        
        return new User({
            id: doc._id,
            email: doc.email,
            passwordHash: doc.passwordHash,
            createdAt: doc.createdAt
        });
    }
    
    async findByEmail(email: string): Promise<User | null> {
        const doc = await this.db.collection('users').findOne({ email });
        
        if (!doc) {
            return null;
        }
        
        return new User({
            id: doc._id,
            email: doc.email,
            passwordHash: doc.passwordHash,
            createdAt: doc.createdAt
        });
    }
}

// Secondary Adapter: In-Memory Implementation (for testing)
class InMemoryUserRepository implements UserRepository {
    private users: Map<string, User> = new Map();
    
    async save(user: User): Promise<User> {
        this.users.set(user.id, user);
        return user;
    }
    
    async findById(userId: string): Promise<User | null> {
        return this.users.get(userId) || null;
    }
    
    async findByEmail(email: string): Promise<User | null> {
        for (const user of this.users.values()) {
            if (user.email === email) {
                return user;
            }
        }
        return null;
    }
}
```

### Example 2: External Service Adapters

```typescript
// Secondary Port
interface EmailSender {
    sendWelcomeEmail(email: string, name: string): Promise<void>;
    sendPasswordResetEmail(email: string, resetToken: string): Promise<void>;
}

// Secondary Adapter: SendGrid Implementation
import sgMail from '@sendgrid/mail';

class SendGridEmailAdapter implements EmailSender {
    constructor(apiKey: string) {
        sgMail.setApiKey(apiKey);
    }
    
    async sendWelcomeEmail(email: string, name: string): Promise<void> {
        await sgMail.send({
            to: email,
            from: 'noreply@example.com',
            subject: 'Welcome!',
            html: `<h1>Welcome ${name}!</h1>`
        });
    }
    
    async sendPasswordResetEmail(email: string, resetToken: string): Promise<void> {
        await sgMail.send({
            to: email,
            from: 'noreply@example.com',
            subject: 'Password Reset',
            html: `<p>Reset token: ${resetToken}</p>`
        });
    }
}

// Secondary Adapter: Console Implementation (for development)
class ConsoleEmailAdapter implements EmailSender {
    async sendWelcomeEmail(email: string, name: string): Promise<void> {
        console.log(`üìß [EMAIL] Welcome email to ${email}`);
        console.log(`   Subject: Welcome!`);
        console.log(`   Body: Welcome ${name}!`);
    }
    
    async sendPasswordResetEmail(email: string, resetToken: string): Promise<void> {
        console.log(`üìß [EMAIL] Password reset to ${email}`);
        console.log(`   Reset Token: ${resetToken}`);
    }
}
```

### Example 3: Payment Gateway Adapter

```typescript
// Secondary Port
interface PaymentGateway {
    processPayment(amount: number, currency: string, cardToken: string): Promise<PaymentResult>;
    refundPayment(transactionId: string): Promise<void>;
}

interface PaymentResult {
    transactionId: string;
    status: 'success' | 'failed';
    message: string;
}

// Secondary Adapter: Stripe Implementation
import Stripe from 'stripe';

class StripePaymentAdapter implements PaymentGateway {
    private stripe: Stripe;
    
    constructor(apiKey: string) {
        this.stripe = new Stripe(apiKey, { apiVersion: '2023-10-16' });
    }
    
    async processPayment(
        amount: number,
        currency: string,
        cardToken: string
    ): Promise<PaymentResult> {
        try {
            const charge = await this.stripe.charges.create({
                amount: Math.round(amount * 100), // Stripe uses cents
                currency: currency.toLowerCase(),
                source: cardToken,
                description: 'Order payment'
            });
            
            return {
                transactionId: charge.id,
                status: 'success',
                message: 'Payment processed successfully'
            };
            
        } catch (error: any) {
            return {
                transactionId: '',
                status: 'failed',
                message: error.message
            };
        }
    }
    
    async refundPayment(transactionId: string): Promise<void> {
        await this.stripe.refunds.create({
            charge: transactionId
        });
    }
}

// Secondary Adapter: Mock Implementation (for testing)
class MockPaymentAdapter implements PaymentGateway {
    async processPayment(
        amount: number,
        currency: string,
        cardToken: string
    ): Promise<PaymentResult> {
        console.log(`üí≥ [MOCK] Processing payment: ${amount} ${currency}`);
        
        // Simulate success
        return {
            transactionId: `mock_${Date.now()}`,
            status: 'success',
            message: 'Mock payment successful'
        };
    }
    
    async refundPayment(transactionId: string): Promise<void> {
        console.log(`üí≥ [MOCK] Refunding: ${transactionId}`);
    }
}
```

---

## 6. Dependency Inversion in Practice

**Key Principle:** Dependencies point inward toward the core.

```
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ  Adapter     ‚îÇ
         ‚îÇ  (External)  ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚îÇ
                ‚îÇ implements
                ‚ñº
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ  Port        ‚îÇ
         ‚îÇ  (Interface) ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚îÇ
                ‚îÇ depends on
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ  Core        ‚îÇ
         ‚îÇ  Domain      ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Example: Order Processing

```typescript
// ============================================
// CORE DOMAIN (No external dependencies)
// ============================================

// Domain Model
class Order {
    constructor(
        public id: string,
        public userId: string,
        public items: OrderItem[],
        public total: number,
        public status: OrderStatus,
        public createdAt: Date
    ) {}
    
    cancel(): void {
        if (this.status === 'SHIPPED') {
            throw new Error('Cannot cancel shipped order');
        }
        this.status = 'CANCELLED';
    }
}

// Secondary Ports (Interfaces defined in core)
interface OrderRepository {
    save(order: Order): Promise<Order>;
    findById(orderId: string): Promise<Order | null>;
}

interface PaymentService {
    processPayment(orderId: string, amount: number): Promise<string>;
}

interface NotificationService {
    notifyOrderCreated(userId: string, orderId: string): Promise<void>;
}

// Primary Port (Application Service)
class OrderServiceImpl {
    constructor(
        private orderRepository: OrderRepository,
        private paymentService: PaymentService,
        private notificationService: NotificationService
    ) {
        // Core depends on interfaces (ports)
        // NOT on concrete implementations (adapters)
    }
    
    async placeOrder(userId: string, items: OrderItem[]): Promise<Order> {
        // Business logic
        const total = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
        
        const order = new Order(
            generateId(),
            userId,
            items,
            total,
            'PENDING',
            new Date()
        );
        
        // Use ports (core doesn't know about adapters)
        await this.orderRepository.save(order);
        
        try {
            await this.paymentService.processPayment(order.id, order.total);
            order.status = 'PAID';
            await this.orderRepository.save(order);
            
        } catch (error) {
            order.status = 'PAYMENT_FAILED';
            await this.orderRepository.save(order);
            throw error;
        }
        
        await this.notificationService.notifyOrderCreated(userId, order.id);
        
        return order;
    }
}

// ============================================
// ADAPTERS (Depend on core interfaces)
// ============================================

// Secondary Adapter: Database
class PostgresOrderRepository implements OrderRepository {
    // Implementation...
}

// Secondary Adapter: Payment
class StripePaymentAdapter implements PaymentService {
    async processPayment(orderId: string, amount: number): Promise<string> {
        // Stripe-specific code
        return 'txn_123';
    }
}

// Secondary Adapter: Notifications
class EmailNotificationAdapter implements NotificationService {
    async notifyOrderCreated(userId: string, orderId: string): Promise<void> {
        // Email-specific code
    }
}

// Primary Adapter: REST API
class OrderController {
    constructor(private orderService: OrderServiceImpl) {}
    
    async createOrder(req: Request, res: Response) {
        const order = await this.orderService.placeOrder(
            req.body.userId,
            req.body.items
        );
        res.json(order);
    }
}

// ============================================
// DEPENDENCY INJECTION (Wire everything)
// ============================================

// Create adapters
const orderRepository = new PostgresOrderRepository(dbConnection);
const paymentService = new StripePaymentAdapter(stripeApiKey);
const notificationService = new EmailNotificationAdapter(emailConfig);

// Inject into core
const orderService = new OrderServiceImpl(
    orderRepository,
    paymentService,
    notificationService
);

// Inject into controller
const orderController = new OrderController(orderService);
```

**Benefits:**
- Core has zero dependencies on adapters
- Can swap PostgreSQL for MongoDB without changing core
- Can swap Stripe for PayPal without changing core
- Easy to test with mock adapters

---

## 7. Complete Implementation Example

Let's build a complete Todo application using Hexagonal Architecture.

```typescript
// ============================================
// DOMAIN (Core)
// ============================================

// Domain Model
class Todo {
    constructor(
        public id: string,
        public userId: string,
        public title: string,
        public description: string,
        public completed: boolean,
        public createdAt: Date,
        public completedAt?: Date
    ) {}
    
    complete(): void {
        if (this.completed) {
            throw new Error('Todo is already completed');
        }
        this.completed = true;
        this.completedAt = new Date();
    }
    
    uncomplete(): void {
        this.completed = false;
        this.completedAt = undefined;
    }
}

// ============================================
// PORTS (Interfaces)
// ============================================

// Secondary Ports
interface TodoRepository {
    save(todo: Todo): Promise<Todo>;
    findById(id: string): Promise<Todo | null>;
    findByUserId(userId: string): Promise<Todo[]>;
    delete(id: string): Promise<void>;
}

// Primary Port (Application Service)
interface TodoService {
    createTodo(userId: string, title: string, description: string): Promise<Todo>;
    getTodo(id: string): Promise<Todo>;
    getUserTodos(userId: string): Promise<Todo[]>;
    completeTodo(id: string): Promise<Todo>;
    deleteTodo(id: string): Promise<void>;
}

// ============================================
// APPLICATION SERVICE (Core Implementation)
// ============================================

class TodoServiceImpl implements TodoService {
    constructor(private todoRepository: TodoRepository) {}
    
    async createTodo(userId: string, title: string, description: string): Promise<Todo> {
        // Validation (business rule)
        if (title.length < 3) {
            throw new Error('Title must be at least 3 characters');
        }
        
        const todo = new Todo(
            generateId(),
            userId,
            title,
            description,
            false,
            new Date()
        );
        
        return await this.todoRepository.save(todo);
    }
    
    async getTodo(id: string): Promise<Todo> {
        const todo = await this.todoRepository.findById(id);
        if (!todo) {
            throw new Error('Todo not found');
        }
        return todo;
    }
    
    async getUserTodos(userId: string): Promise<Todo[]> {
        return await this.todoRepository.findByUserId(userId);
    }
    
    async completeTodo(id: string): Promise<Todo> {
        const todo = await this.getTodo(id);
        todo.complete();  // Domain logic
        return await this.todoRepository.save(todo);
    }
    
    async deleteTodo(id: string): Promise<void> {
        const todo = await this.getTodo(id);
        await this.todoRepository.delete(todo.id);
    }
}

// ============================================
// SECONDARY ADAPTERS (Infrastructure)
// ============================================

// Database Adapter
class PostgresTodoRepository implements TodoRepository {
    constructor(private pool: any) {}
    
    async save(todo: Todo): Promise<Todo> {
        const query = `
            INSERT INTO todos (id, user_id, title, description, completed, created_at, completed_at)
            VALUES ($1, $2, $3, $4, $5, $6, $7)
            ON CONFLICT (id) DO UPDATE SET
                title = $3,
                description = $4,
                completed = $5,
                completed_at = $7
            RETURNING *
        `;
        
        const result = await this.pool.query(query, [
            todo.id,
            todo.userId,
            todo.title,
            todo.description,
            todo.completed,
            todo.createdAt,
            todo.completedAt
        ]);
        
        return this.mapToTodo(result.rows[0]);
    }
    
    async findById(id: string): Promise<Todo | null> {
        const result = await this.pool.query(
            'SELECT * FROM todos WHERE id = $1',
            [id]
        );
        
        if (result.rows.length === 0) {
            return null;
        }
        
        return this.mapToTodo(result.rows[0]);
    }
    
    async findByUserId(userId: string): Promise<Todo[]> {
        const result = await this.pool.query(
            'SELECT * FROM todos WHERE user_id = $1 ORDER BY created_at DESC',
            [userId]
        );
        
        return result.rows.map(row => this.mapToTodo(row));
    }
    
    async delete(id: string): Promise<void> {
        await this.pool.query('DELETE FROM todos WHERE id = $1', [id]);
    }
    
    private mapToTodo(row: any): Todo {
        return new Todo(
            row.id,
            row.user_id,
            row.title,
            row.description,
            row.completed,
            row.created_at,
            row.completed_at
        );
    }
}

// In-Memory Adapter (for testing)
class InMemoryTodoRepository implements TodoRepository {
    private todos: Map<string, Todo> = new Map();
    
    async save(todo: Todo): Promise<Todo> {
        this.todos.set(todo.id, todo);
        return todo;
    }
    
    async findById(id: string): Promise<Todo | null> {
        return this.todos.get(id) || null;
    }
    
    async findByUserId(userId: string): Promise<Todo[]> {
        return Array.from(this.todos.values())
            .filter(todo => todo.userId === userId);
    }
    
    async delete(id: string): Promise<void> {
        this.todos.delete(id);
    }
}

// ============================================
// PRIMARY ADAPTERS (UI/API)
// ============================================

// REST API Adapter
import express from 'express';

class TodoController {
    private router = express.Router();
    
    constructor(private todoService: TodoService) {
        this.setupRoutes();
    }
    
    private setupRoutes() {
        this.router.post('/', this.createTodo.bind(this));
        this.router.get('/:id', this.getTodo.bind(this));
        this.router.get('/user/:userId', this.getUserTodos.bind(this));
        this.router.put('/:id/complete', this.completeTodo.bind(this));
        this.router.delete('/:id', this.deleteTodo.bind(this));
    }
    
    private async createTodo(req: express.Request, res: express.Response) {
        try {
            const { userId, title, description } = req.body;
            const todo = await this.todoService.createTodo(userId, title, description);
            res.status(201).json(todo);
        } catch (error: any) {
            res.status(400).json({ error: error.message });
        }
    }
    
    private async getTodo(req: express.Request, res: express.Response) {
        try {
            const todo = await this.todoService.getTodo(req.params.id);
            res.json(todo);
        } catch (error: any) {
            res.status(404).json({ error: error.message });
        }
    }
    
    private async getUserTodos(req: express.Request, res: express.Response) {
        try {
            const todos = await this.todoService.getUserTodos(req.params.userId);
            res.json(todos);
        } catch (error: any) {
            res.status(400).json({ error: error.message });
        }
    }
    
    private async completeTodo(req: express.Request, res: express.Response) {
        try {
            const todo = await this.todoService.completeTodo(req.params.id);
            res.json(todo);
        } catch (error: any) {
            res.status(400).json({ error: error.message });
        }
    }
    
    private async deleteTodo(req: express.Request, res: express.Response) {
        try {
            await this.todoService.deleteTodo(req.params.id);
            res.status(204).send();
        } catch (error: any) {
            res.status(404).json({ error: error.message });
        }
    }
    
    getRouter() {
        return this.router;
    }
}

// ============================================
// COMPOSITION ROOT (Wire everything together)
// ============================================

import { Pool } from 'pg';

// Configuration
const pool = new Pool({
    host: 'localhost',
    database: 'todos',
    user: 'postgres',
    password: 'password'
});

// Create adapters
const todoRepository = new PostgresTodoRepository(pool);

// Create core service
const todoService = new TodoServiceImpl(todoRepository);

// Create controllers
const todoController = new TodoController(todoService);

// Setup Express app
const app = express();
app.use(express.json());
app.use('/todos', todoController.getRouter());

app.listen(3000, () => {
    console.log('Server running on port 3000');
});
```

---

## 8. Testing in Hexagonal Architecture

One of the biggest advantages: Easy testing!

### Unit Testing Core Logic

```typescript
describe('TodoService', () => {
    let todoService: TodoService;
    let mockRepository: TodoRepository;
    
    beforeEach(() => {
        // Use in-memory repository for tests
        mockRepository = new InMemoryTodoRepository();
        todoService = new TodoServiceImpl(mockRepository);
    });
    
    describe('createTodo', () => {
        it('should create a todo', async () => {
            const todo = await todoService.createTodo(
                'user_123',
                'Buy groceries',
                'Milk, eggs, bread'
            );
            
            expect(todo.id).toBeDefined();
            expect(todo.title).toBe('Buy groceries');
            expect(todo.completed).toBe(false);
        });
        
        it('should throw error for short title', async () => {
            await expect(
                todoService.createTodo('user_123', 'Go', 'Too short')
            ).rejects.toThrow('Title must be at least 3 characters');
        });
    });
    
    describe('completeTodo', () => {
        it('should mark todo as completed', async () => {
            const created = await todoService.createTodo(
                'user_123',
                'Task',
                'Description'
            );
            
            const completed = await todoService.completeTodo(created.id);
            
            expect(completed.completed).toBe(true);
            expect(completed.completedAt).toBeDefined();
        });
        
        it('should throw error when completing already completed todo', async () => {
            const created = await todoService.createTodo(
                'user_123',
                'Task',
                'Description'
            );
            
            await todoService.completeTodo(created.id);
            
            // Try to complete again
            await expect(
                todoService.completeTodo(created.id)
            ).rejects.toThrow('Todo is already completed');
        });
    });
});
```

### Integration Testing with Mock Adapters

```typescript
describe('TodoController Integration', () => {
    let app: express.Application;
    let todoService: TodoService;
    
    beforeEach(() => {
        const repository = new InMemoryTodoRepository();
        todoService = new TodoServiceImpl(repository);
        const controller = new TodoController(todoService);
        
        app = express();
        app.use(express.json());
        app.use('/todos', controller.getRouter());
    });
    
    it('should create todo via API', async () => {
        const response = await request(app)
            .post('/todos')
            .send({
                userId: 'user_123',
                title: 'Test Todo',
                description: 'Test Description'
            })
            .expect(201);
        
        expect(response.body.id).toBeDefined();
        expect(response.body.title).toBe('Test Todo');
    });
    
    it('should get user todos', async () => {
        // Create some todos
        await todoService.createTodo('user_123', 'Todo 1', 'Desc 1');
        await todoService.createTodo('user_123', 'Todo 2', 'Desc 2');
        
        const response = await request(app)
            .get('/todos/user/user_123')
            .expect(200);
        
        expect(response.body).toHaveLength(2);
    });
});
```

---

## 9. Advantages and Disadvantages

### ‚úÖ Advantages

**1. Testability**
```typescript
// Test with in-memory repository (fast)
const testRepo = new InMemoryTodoRepository();
const service = new TodoServiceImpl(testRepo);
await service.createTodo(...);  // No database needed!
```

**2. Flexibility**
```typescript
// Swap implementations easily
const prodRepo = new PostgresTodoRepository(pool);
const devRepo = new InMemoryTodoRepository();

const service = process.env.NODE_ENV === 'production'
    ? new TodoServiceImpl(prodRepo)
    : new TodoServiceImpl(devRepo);
```

**3. Technology Independence**
- Business logic doesn't know about databases, frameworks, etc.
- Can migrate from PostgreSQL to MongoDB without touching core
- Can add GraphQL API without changing business logic

**4. Clean Architecture**
- Clear separation of concerns
- Dependencies point inward
- Easy to understand

**5. Maintainability**
- Changes in infrastructure don't affect business logic
- Each component has single responsibility
- Easy to locate and fix bugs

### ‚ùå Disadvantages

**1. Initial Complexity**
- More files and interfaces
- Steeper learning curve
- Can feel like over-engineering for simple apps

**2. Boilerplate Code**
```typescript
// Need to define port + adapter for each dependency
interface UserRepository { }  // Port
class PostgresUserRepo implements UserRepository { }  // Adapter
class MongoUserRepo implements UserRepository { }  // Another adapter
```

**3. Indirection**
- More layers between input and output
- Can be harder to trace through code
- Need to understand architecture to navigate

**4. Not Always Needed**
- Overkill for simple CRUD applications
- Small projects might not benefit
- Prototypes and POCs don't need this level of structure

---

## 10. Real-World Applications

### When to Use Hexagonal Architecture

‚úÖ **Long-lived applications**
- Will be maintained for years
- Technology might need to change
- Business logic is complex

‚úÖ **Multiple interfaces**
- REST API + GraphQL + CLI
- Web + Mobile + Desktop
- Public API + Internal tools

‚úÖ **Testing is critical**
- Need high test coverage
- Complex business rules
- Regulatory compliance

‚úÖ **Team collaboration**
- Multiple teams working on same codebase
- Clear boundaries needed
- Domain experts involved

### When NOT to Use

‚ùå **Simple CRUD apps**
‚ùå **Short-lived prototypes**
‚ùå **Very small team (1-2 developers)**
‚ùå **Simple data transformations**

### Real Examples

**Good fit:**
- Banking systems (complex business rules)
- Healthcare platforms (multiple integrations)
- E-commerce platforms (multiple payment gateways)

**Not needed:**
- Simple blog
- TODO list app for personal use
- Static website

---

## Chapter 7 Summary

### Key Concepts

1. **Hexagonal Architecture** = Core business logic at center, infrastructure at edges
2. **Ports** = Interfaces/contracts
3. **Adapters** = Implementations
4. **Primary (Driving)** = Trigger the app (UI, API, CLI)
5. **Secondary (Driven)** = Used by the app (DB, email, payment)

### Architecture Rules

- Core has NO dependencies on infrastructure
- All dependencies point INWARD
- External systems accessed through ports
- Adapters implement ports

### Benefits

- ‚úÖ Highly testable
- ‚úÖ Technology independent
- ‚úÖ Easy to swap implementations
- ‚úÖ Clean separation of concerns

### Trade-offs

- ‚ùå More initial complexity
- ‚ùå More boilerplate
- ‚ùå Overkill for simple apps

### Interview Tips

**Common Questions:**
1. "What is Hexagonal Architecture?"
2. "Explain Ports vs Adapters"
3. "How does dependency inversion work here?"
4. "When would you use Hexagonal Architecture?"

**How to Answer:**
- Draw the hexagon diagram
- Explain with concrete examples
- Mention testability benefits
- Discuss when NOT to use it

### Next Steps

You've now completed Chapters 4-7 covering:
- Layered Architecture
- Microservices Architecture
- Event-Driven Architecture
- Hexagonal Architecture

These form the foundation of modern software architecture patterns. Practice implementing them in real projects to master the concepts!