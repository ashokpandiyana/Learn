# Chapter 14: API Design

## Table of Contents
1. Introduction to API Design
2. RESTful API Design Principles
3. GraphQL vs REST
4. gRPC and Protocol Buffers
5. API Versioning Strategies
6. Rate Limiting and Throttling
7. Pagination, Filtering, and Sorting
8. Authentication and Authorization
9. Error Handling
10. API Documentation
11. Best Practices

---

## 1. Introduction to API Design

**Definition:** An API (Application Programming Interface) is a contract between services that defines how they communicate.

### Good API Characteristics

1. **Consistent** - Predictable patterns
2. **Well-documented** - Easy to understand
3. **Versioned** - Backward compatible
4. **Secure** - Protected from unauthorized access
5. **Performant** - Fast responses
6. **Reliable** - Handles errors gracefully

---

## 2. RESTful API Design Principles

**REST (Representational State Transfer)** is an architectural style for designing networked applications.

### REST Principles

**1. Resource-Based URLs**

```http
✅ Good (nouns, not verbs)
GET    /users
GET    /users/123
POST   /users
PUT    /users/123
DELETE /users/123

GET    /users/123/orders
POST   /users/123/orders

❌ Bad (verbs in URLs)
GET  /getUsers
POST /createUser
POST /users/delete/123
```

**2. HTTP Methods (Verbs)**

| Method | Purpose | Idempotent | Safe |
|--------|---------|------------|------|
| **GET** | Retrieve resource | Yes | Yes |
| **POST** | Create resource | No | No |
| **PUT** | Update/Replace resource | Yes | No |
| **PATCH** | Partial update | No | No |
| **DELETE** | Delete resource | Yes | No |

**3. HTTP Status Codes**

```
2xx Success
200 OK              - Request succeeded
201 Created         - Resource created
202 Accepted        - Async processing started
204 No Content      - Success, no response body

3xx Redirection
301 Moved Permanently
304 Not Modified    - Use cached version

4xx Client Errors
400 Bad Request     - Invalid syntax
401 Unauthorized    - Authentication required
403 Forbidden       - Authenticated but not authorized
404 Not Found       - Resource doesn't exist
409 Conflict        - Conflict with current state
422 Unprocessable   - Validation failed
429 Too Many Requests - Rate limit exceeded

5xx Server Errors
500 Internal Server Error
502 Bad Gateway
503 Service Unavailable
504 Gateway Timeout
```

### Complete REST API Example

```javascript
// ============================================
// Express.js REST API
// ============================================
const express = require('express');
const app = express();

app.use(express.json());

// ============================================
// GET - Retrieve all users
// ============================================
app.get('/api/v1/users', async (req, res) => {
    try {
        // Query parameters for filtering
        const { role, active, page = 1, limit = 20 } = req.query;
        
        const filters = {};
        if (role) filters.role = role;
        if (active !== undefined) filters.active = active === 'true';
        
        // Pagination
        const skip = (page - 1) * limit;
        
        const users = await db.collection('users')
            .find(filters)
            .skip(skip)
            .limit(parseInt(limit))
            .toArray();
        
        const total = await db.collection('users').countDocuments(filters);
        
        res.status(200).json({
            data: users,
            meta: {
                page: parseInt(page),
                limit: parseInt(limit),
                total: total,
                totalPages: Math.ceil(total / limit)
            }
        });
        
    } catch (error) {
        res.status(500).json({
            error: {
                message: 'Failed to retrieve users',
                code: 'INTERNAL_ERROR'
            }
        });
    }
});

// ============================================
// GET - Retrieve single user
// ============================================
app.get('/api/v1/users/:id', async (req, res) => {
    try {
        const user = await db.collection('users').findOne({
            _id: req.params.id
        });
        
        if (!user) {
            return res.status(404).json({
                error: {
                    message: 'User not found',
                    code: 'USER_NOT_FOUND'
                }
            });
        }
        
        // Don't expose sensitive fields
        delete user.password;
        
        res.status(200).json({ data: user });
        
    } catch (error) {
        res.status(500).json({
            error: {
                message: 'Failed to retrieve user',
                code: 'INTERNAL_ERROR'
            }
        });
    }
});

// ============================================
// POST - Create user
// ============================================
app.post('/api/v1/users', async (req, res) => {
    try {
        // Validate request body
        const { email, name, password } = req.body;
        
        if (!email || !name || !password) {
            return res.status(400).json({
                error: {
                    message: 'Missing required fields',
                    code: 'VALIDATION_ERROR',
                    fields: {
                        email: !email ? 'Email is required' : null,
                        name: !name ? 'Name is required' : null,
                        password: !password ? 'Password is required' : null
                    }
                }
            });
        }
        
        // Check if user exists
        const existing = await db.collection('users').findOne({ email });
        if (existing) {
            return res.status(409).json({
                error: {
                    message: 'User already exists',
                    code: 'USER_EXISTS'
                }
            });
        }
        
        // Create user
        const hashedPassword = await bcrypt.hash(password, 10);
        
        const newUser = {
            email,
            name,
            password: hashedPassword,
            createdAt: new Date(),
            active: true
        };
        
        const result = await db.collection('users').insertOne(newUser);
        
        // Don't return password
        delete newUser.password;
        
        res.status(201)
            .location(`/api/v1/users/${result.insertedId}`)
            .json({ data: newUser });
        
    } catch (error) {
        res.status(500).json({
            error: {
                message: 'Failed to create user',
                code: 'INTERNAL_ERROR'
            }
        });
    }
});

// ============================================
// PUT - Update user (full replacement)
// ============================================
app.put('/api/v1/users/:id', async (req, res) => {
    try {
        const { email, name, active } = req.body;
        
        // Validate all required fields present
        if (!email || !name || active === undefined) {
            return res.status(400).json({
                error: {
                    message: 'All fields required for PUT',
                    code: 'VALIDATION_ERROR'
                }
            });
        }
        
        const result = await db.collection('users').findOneAndUpdate(
            { _id: req.params.id },
            {
                $set: {
                    email,
                    name,
                    active,
                    updatedAt: new Date()
                }
            },
            { returnDocument: 'after' }
        );
        
        if (!result.value) {
            return res.status(404).json({
                error: {
                    message: 'User not found',
                    code: 'USER_NOT_FOUND'
                }
            });
        }
        
        delete result.value.password;
        
        res.status(200).json({ data: result.value });
        
    } catch (error) {
        res.status(500).json({
            error: {
                message: 'Failed to update user',
                code: 'INTERNAL_ERROR'
            }
        });
    }
});

// ============================================
// PATCH - Partial update
// ============================================
app.patch('/api/v1/users/:id', async (req, res) => {
    try {
        const updates = {};
        
        // Only update provided fields
        if (req.body.email !== undefined) updates.email = req.body.email;
        if (req.body.name !== undefined) updates.name = req.body.name;
        if (req.body.active !== undefined) updates.active = req.body.active;
        
        if (Object.keys(updates).length === 0) {
            return res.status(400).json({
                error: {
                    message: 'No fields to update',
                    code: 'VALIDATION_ERROR'
                }
            });
        }
        
        updates.updatedAt = new Date();
        
        const result = await db.collection('users').findOneAndUpdate(
            { _id: req.params.id },
            { $set: updates },
            { returnDocument: 'after' }
        );
        
        if (!result.value) {
            return res.status(404).json({
                error: {
                    message: 'User not found',
                    code: 'USER_NOT_FOUND'
                }
            });
        }
        
        delete result.value.password;
        
        res.status(200).json({ data: result.value });
        
    } catch (error) {
        res.status(500).json({
            error: {
                message: 'Failed to update user',
                code: 'INTERNAL_ERROR'
            }
        });
    }
});

// ============================================
// DELETE - Delete user
// ============================================
app.delete('/api/v1/users/:id', async (req, res) => {
    try {
        const result = await db.collection('users').deleteOne({
            _id: req.params.id
        });
        
        if (result.deletedCount === 0) {
            return res.status(404).json({
                error: {
                    message: 'User not found',
                    code: 'USER_NOT_FOUND'
                }
            });
        }
        
        res.status(204).send();  // No content
        
    } catch (error) {
        res.status(500).json({
            error: {
                message: 'Failed to delete user',
                code: 'INTERNAL_ERROR'
            }
        });
    }
});

// ============================================
// Nested resources
// ============================================
app.get('/api/v1/users/:userId/orders', async (req, res) => {
    try {
        const orders = await db.collection('orders')
            .find({ userId: req.params.userId })
            .toArray();
        
        res.status(200).json({ data: orders });
        
    } catch (error) {
        res.status(500).json({
            error: {
                message: 'Failed to retrieve orders',
                code: 'INTERNAL_ERROR'
            }
        });
    }
});

app.listen(3000, () => {
    console.log('API server running on port 3000');
});
```

### REST Design Best Practices

**1. Use Plural Nouns**
```http
✅ /users
✅ /products
❌ /user
❌ /product
```

**2. Use Query Parameters for Filtering**
```http
GET /users?role=admin&active=true
GET /products?category=electronics&price_lt=1000
```

**3. Version Your API**
```http
GET /api/v1/users
GET /api/v2/users
```

**4. Use HATEOAS (Hypermedia)**
```json
{
  "data": {
    "id": "123",
    "name": "John Doe",
    "email": "john@example.com"
  },
  "links": {
    "self": "/api/v1/users/123",
    "orders": "/api/v1/users/123/orders",
    "avatar": "/api/v1/users/123/avatar"
  }
}
```

---

## 3. GraphQL vs REST

### REST Challenges

**Over-fetching:** Get more data than needed
```json
GET /users/123
{
  "id": 123,
  "name": "John",
  "email": "john@example.com",
  "bio": "...",
  "avatar": "...",
  "address": {...},
  "preferences": {...}
}
// Only needed name and email!
```

**Under-fetching:** Need multiple requests
```
GET /users/123           → User data
GET /users/123/orders    → Orders
GET /users/123/posts     → Posts
= 3 round trips
```

### GraphQL Solution

**Single endpoint, flexible queries:**

```graphql
# GraphQL Schema
type User {
  id: ID!
  name: String!
  email: String!
  orders: [Order!]!
  posts: [Post!]!
}

type Order {
  id: ID!
  total: Float!
  items: [OrderItem!]!
}

type Post {
  id: ID!
  title: String!
  content: String!
}

type Query {
  user(id: ID!): User
  users(limit: Int, offset: Int): [User!]!
}

type Mutation {
  createUser(name: String!, email: String!): User!
  updateUser(id: ID!, name: String, email: String): User!
  deleteUser(id: ID!): Boolean!
}
```

### GraphQL Implementation

```typescript
// ============================================
// GraphQL Server (Apollo Server)
// ============================================
import { ApolloServer, gql } from 'apollo-server';

// Type definitions
const typeDefs = gql`
  type User {
    id: ID!
    name: String!
    email: String!
    orders: [Order!]!
  }
  
  type Order {
    id: ID!
    userId: ID!
    total: Float!
    createdAt: String!
  }
  
  type Query {
    user(id: ID!): User
    users: [User!]!
  }
  
  type Mutation {
    createUser(name: String!, email: String!): User!
  }
`;

// Resolvers
const resolvers = {
  Query: {
    user: async (_, { id }, context) => {
      return await context.db.collection('users').findOne({ _id: id });
    },
    
    users: async (_, __, context) => {
      return await context.db.collection('users').find().toArray();
    }
  },
  
  User: {
    // Resolve nested orders field
    orders: async (parent, _, context) => {
      return await context.db.collection('orders')
        .find({ userId: parent.id })
        .toArray();
    }
  },
  
  Mutation: {
    createUser: async (_, { name, email }, context) => {
      const newUser = {
        name,
        email,
        createdAt: new Date()
      };
      
      const result = await context.db.collection('users').insertOne(newUser);
      
      return { id: result.insertedId, ...newUser };
    }
  }
};

// Create server
const server = new ApolloServer({
  typeDefs,
  resolvers,
  context: ({ req }) => ({
    db: database,
    user: req.user  // From auth middleware
  })
});

server.listen().then(({ url }) => {
  console.log(`GraphQL server ready at ${url}`);
});
```

### GraphQL Queries

```graphql
# Query 1: Get only needed fields
query {
  user(id: "123") {
    name
    email
  }
}

# Response
{
  "data": {
    "user": {
      "name": "John Doe",
      "email": "john@example.com"
    }
  }
}

# Query 2: Get user with nested orders (single request!)
query {
  user(id: "123") {
    name
    email
    orders {
      id
      total
      createdAt
    }
  }
}

# Query 3: Multiple resources in one request
query {
  user(id: "123") {
    name
  }
  users {
    id
    name
  }
}

# Mutation: Create user
mutation {
  createUser(name: "Jane Doe", email: "jane@example.com") {
    id
    name
    email
  }
}
```

### REST vs GraphQL Comparison

| Aspect | REST | GraphQL |
|--------|------|---------|
| **Endpoints** | Multiple (/users, /orders) | Single (/graphql) |
| **Over-fetching** | Common | No - client specifies fields |
| **Under-fetching** | Common (multiple requests) | No - one request gets all |
| **Versioning** | URL-based (/v1/, /v2/) | Schema evolution |
| **Caching** | HTTP caching built-in | Requires custom logic |
| **Learning Curve** | Easy | Steeper |
| **Tooling** | Mature | Growing |
| **Best For** | Simple APIs, public APIs | Complex data requirements |

---

## 4. gRPC and Protocol Buffers

**gRPC:** High-performance RPC framework using HTTP/2 and Protocol Buffers.

### Protocol Buffers Definition

```protobuf
// user.proto
syntax = "proto3";

package user;

service UserService {
  rpc GetUser (GetUserRequest) returns (User);
  rpc CreateUser (CreateUserRequest) returns (User);
  rpc ListUsers (ListUsersRequest) returns (ListUsersResponse);
  rpc UpdateUser (UpdateUserRequest) returns (User);
  rpc DeleteUser (DeleteUserRequest) returns (DeleteUserResponse);
}

message User {
  string id = 1;
  string name = 2;
  string email = 3;
  int64 created_at = 4;
}

message GetUserRequest {
  string id = 1;
}

message CreateUserRequest {
  string name = 1;
  string email = 2;
}

message ListUsersRequest {
  int32 page = 1;
  int32 limit = 2;
}

message ListUsersResponse {
  repeated User users = 1;
  int32 total = 2;
}

message UpdateUserRequest {
  string id = 1;
  string name = 2;
  string email = 3;
}

message DeleteUserRequest {
  string id = 1;
}

message DeleteUserResponse {
  bool success = 1;
}
```

### gRPC Server Implementation

```python
# ============================================
# Python gRPC Server
# ============================================
import grpc
from concurrent import futures
import user_pb2
import user_pb2_grpc

class UserService(user_pb2_grpc.UserServiceServicer):
    def __init__(self, db):
        self.db = db
    
    def GetUser(self, request, context):
        """Get user by ID"""
        user = self.db.find_one({'_id': request.id})
        
        if not user:
            context.set_code(grpc.StatusCode.NOT_FOUND)
            context.set_details('User not found')
            return user_pb2.User()
        
        return user_pb2.User(
            id=user['_id'],
            name=user['name'],
            email=user['email'],
            created_at=int(user['created_at'].timestamp())
        )
    
    def CreateUser(self, request, context):
        """Create new user"""
        new_user = {
            'name': request.name,
            'email': request.email,
            'created_at': datetime.now()
        }
        
        result = self.db.insert_one(new_user)
        
        return user_pb2.User(
            id=str(result.inserted_id),
            name=new_user['name'],
            email=new_user['email'],
            created_at=int(new_user['created_at'].timestamp())
        )
    
    def ListUsers(self, request, context):
        """List users with pagination"""
        skip = (request.page - 1) * request.limit
        
        users = list(self.db.find().skip(skip).limit(request.limit))
        total = self.db.count_documents({})
        
        response_users = [
            user_pb2.User(
                id=str(user['_id']),
                name=user['name'],
                email=user['email'],
                created_at=int(user['created_at'].timestamp())
            )
            for user in users
        ]
        
        return user_pb2.ListUsersResponse(
            users=response_users,
            total=total
        )

def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    
    user_pb2_grpc.add_UserServiceServicer_to_server(
        UserService(database),
        server
    )
    
    server.add_insecure_port('[::]:50051')
    server.start()
    
    print('gRPC server started on port 50051')
    server.wait_for_termination()

if __name__ == '__main__':
    serve()
```

### gRPC Client

```python
# ============================================
# Python gRPC Client
# ============================================
import grpc
import user_pb2
import user_pb2_grpc

def run():
    # Create channel
    channel = grpc.insecure_channel('localhost:50051')
    stub = user_pb2_grpc.UserServiceStub(channel)
    
    # Create user
    response = stub.CreateUser(
        user_pb2.CreateUserRequest(
            name='John Doe',
            email='john@example.com'
        )
    )
    print(f'Created user: {response.id}')
    
    # Get user
    user = stub.GetUser(user_pb2.GetUserRequest(id=response.id))
    print(f'User: {user.name} - {user.email}')
    
    # List users
    users_response = stub.ListUsers(
        user_pb2.ListUsersRequest(page=1, limit=10)
    )
    print(f'Total users: {users_response.total}')
    for user in users_response.users:
        print(f'  {user.name}')

if __name__ == '__main__':
    run()
```

### REST vs GraphQL vs gRPC

| Feature | REST | GraphQL | gRPC |
|---------|------|---------|------|
| **Protocol** | HTTP/1.1 | HTTP/1.1 | HTTP/2 |
| **Format** | JSON | JSON | Protocol Buffers |
| **Speed** | Medium | Medium | Very Fast |
| **Browser Support** | Yes | Yes | Limited |
| **Streaming** | No | Subscriptions | Yes (bidirectional) |
| **Type Safety** | No | Yes (schema) | Yes (proto) |
| **Best For** | Public APIs | Complex queries | Internal services |

---

## 5. API Versioning Strategies

### Strategy 1: URL Versioning

```http
GET /api/v1/users
GET /api/v2/users

✅ Pros: Clear, easy to route
❌ Cons: Multiple codebases
```

```javascript
// Express routing
app.use('/api/v1', v1Router);
app.use('/api/v2', v2Router);

// v1Router
v1Router.get('/users', (req, res) => {
  // V1 implementation
});

// v2Router
v2Router.get('/users', (req, res) => {
  // V2 implementation (breaking changes)
});
```

### Strategy 2: Header Versioning

```http
GET /api/users
Accept: application/vnd.myapp.v1+json

GET /api/users
Accept: application/vnd.myapp.v2+json
```

```javascript
app.get('/api/users', (req, res) => {
  const version = req.get('Accept').includes('v2') ? 'v2' : 'v1';
  
  if (version === 'v2') {
    // V2 response format
    res.json({ data: users, meta: {...} });
  } else {
    // V1 response format
    res.json(users);
  }
});
```

### Strategy 3: Query Parameter Versioning

```http
GET /api/users?version=1
GET /api/users?version=2
```

### Best Practices

1. **Version Major Changes Only** - Minor changes don't need new version
2. **Deprecate Gracefully** - Give users time to migrate
3. **Document Changes** - Clear changelog
4. **Support Multiple Versions** - Transition period

```javascript
// Deprecation header
res.set('X-API-Warn', 'This version is deprecated. Please use v2.');
```

---

## 6. Rate Limiting and Throttling

**Purpose:** Prevent abuse, ensure fair usage, protect infrastructure.

### Implementation

```javascript
// ============================================
// Express Rate Limiting
// ============================================
const rateLimit = require('express-rate-limit');
const RedisStore = require('rate-limit-redis');
const redis = require('redis');

const redisClient = redis.createClient({
  host: 'localhost',
  port: 6379
});

// Global rate limit: 100 requests per 15 minutes
const globalLimiter = rateLimit({
  store: new RedisStore({
    client: redisClient,
    prefix: 'rl:global:'
  }),
  windowMs: 15 * 60 * 1000,  // 15 minutes
  max: 100,  // Limit each IP to 100 requests per window
  message: 'Too many requests, please try again later.',
  standardHeaders: true,  // Return rate limit info in headers
  legacyHeaders: false
});

// Strict rate limit for expensive endpoints
const strictLimiter = rateLimit({
  store: new RedisStore({
    client: redisClient,
    prefix: 'rl:strict:'
  }),
  windowMs: 60 * 1000,  // 1 minute
  max: 5,  // Only 5 requests per minute
  message: 'Rate limit exceeded for this endpoint'
});

// Apply globally
app.use('/api/', globalLimiter);

// Apply to specific routes
app.post('/api/v1/orders', strictLimiter, createOrderHandler);
```

### Custom Rate Limiting

```typescript
import Redis from 'ioredis';

class RateLimiter {
  private redis: Redis;
  
  constructor() {
    this.redis = new Redis();
  }
  
  async checkLimit(
    key: string,
    maxRequests: number,
    windowSeconds: number
  ): Promise<{ allowed: boolean; remaining: number; resetAt: Date }> {
    const now = Date.now();
    const windowKey = `ratelimit:${key}:${Math.floor(now / (windowSeconds * 1000))}`;
    
    // Increment counter
    const count = await this.redis.incr(windowKey);
    
    // Set expiry on first request
    if (count === 1) {
      await this.redis.expire(windowKey, windowSeconds);
    }
    
    const allowed = count <= maxRequests;
    const remaining = Math.max(0, maxRequests - count);
    const resetAt = new Date(
      Math.ceil(now / (windowSeconds * 1000)) * windowSeconds * 1000
    );
    
    return { allowed, remaining, resetAt };
  }
}

// Middleware
async function rateLimitMiddleware(req: any, res: any, next: any) {
  const limiter = new RateLimiter();
  
  // Rate limit by user ID or IP
  const key = req.user?.id || req.ip;
  
  const result = await limiter.checkLimit(key, 100, 60);  // 100 per minute
  
  // Set rate limit headers
  res.set({
    'X-RateLimit-Limit': '100',
    'X-RateLimit-Remaining': result.remaining.toString(),
    'X-RateLimit-Reset': result.resetAt.toISOString()
  });
  
  if (!result.allowed) {
    return res.status(429).json({
      error: {
        message: 'Rate limit exceeded',
        code: 'RATE_LIMIT_EXCEEDED',
        retryAfter: result.resetAt
      }
    });
  }
  
  next();
}
```

### Tiered Rate Limiting

```javascript
const getRateLimit = (userTier) => {
  switch (userTier) {
    case 'free':
      return { max: 100, windowMs: 60 * 60 * 1000 };  // 100/hour
    case 'basic':
      return { max: 1000, windowMs: 60 * 60 * 1000 };  // 1000/hour
    case 'premium':
      return { max: 10000, windowMs: 60 * 60 * 1000 };  // 10000/hour
    default:
      return { max: 10, windowMs: 60 * 60 * 1000 };  // 10/hour
  }
};

app.use((req, res, next) => {
  const tier = req.user?.tier || 'free';
  const limits = getRateLimit(tier);
  
  const limiter = rateLimit({
    windowMs: limits.windowMs,
    max: limits.max,
    keyGenerator: (req) => req.user?.id || req.ip
  });
  
  limiter(req, res, next);
});
```

---

## 7. Pagination, Filtering, and Sorting

### Pagination

**Offset-Based:**
```http
GET /api/users?page=2&limit=20

Response:
{
  "data": [...],
  "meta": {
    "page": 2,
    "limit": 20,
    "total": 150,
    "totalPages": 8
  }
}
```

```javascript
app.get('/api/users', async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 20;
  const skip = (page - 1) * limit;
  
  const users = await db.collection('users')
    .find()
    .skip(skip)
    .limit(limit)
    .toArray();
  
  const total = await db.collection('users').countDocuments();
  
  res.json({
    data: users,
    meta: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit)
    },
    links: {
      self: `/api/users?page=${page}&limit=${limit}`,
      next: page < Math.ceil(total / limit) 
        ? `/api/users?page=${page + 1}&limit=${limit}` 
        : null,
      prev: page > 1 
        ? `/api/users?page=${page - 1}&limit=${limit}` 
        : null
    }
  });
});
```

**Cursor-Based (Better for large datasets):**
```http
GET /api/users?cursor=eyJpZCI6MTIzfQ==&limit=20

Response:
{
  "data": [...],
  "meta": {
    "next_cursor": "eyJpZCI6MTQzfQ==",
    "has_more": true
  }
}
```

```javascript
app.get('/api/users', async (req, res) => {
  const limit = parseInt(req.query.limit) || 20;
  
  // Decode cursor (base64 encoded last ID)
  const cursor = req.query.cursor 
    ? JSON.parse(Buffer.from(req.query.cursor, 'base64').toString())
    : null;
  
  const query = cursor ? { _id: { $gt: cursor.id } } : {};
  
  const users = await db.collection('users')
    .find(query)
    .sort({ _id: 1 })
    .limit(limit + 1)  // Get one extra to check if more exist
    .toArray();
  
  const hasMore = users.length > limit;
  if (hasMore) users.pop();  // Remove extra
  
  const nextCursor = hasMore 
    ? Buffer.from(JSON.stringify({ id: users[users.length - 1]._id })).toString('base64')
    : null;
  
  res.json({
    data: users,
    meta: {
      next_cursor: nextCursor,
      has_more: hasMore
    }
  });
});
```

### Filtering

```http
GET /api/products?category=electronics&price_min=100&price_max=500&in_stock=true
```

```javascript
app.get('/api/products', async (req, res) => {
  const filters = {};
  
  // String filter
  if (req.query.category) {
    filters.category = req.query.category;
  }
  
  // Range filter
  if (req.query.price_min || req.query.price_max) {
    filters.price = {};
    if (req.query.price_min) filters.price.$gte = parseFloat(req.query.price_min);
    if (req.query.price_max) filters.price.$lte = parseFloat(req.query.price_max);
  }
  
  // Boolean filter
  if (req.query.in_stock !== undefined) {
    filters.in_stock = req.query.in_stock === 'true';
  }
  
  // Text search
  if (req.query.search) {
    filters.$text = { $search: req.query.search };
  }
  
  const products = await db.collection('products')
    .find(filters)
    .toArray();
  
  res.json({ data: products });
});
```

### Sorting

```http
GET /api/products?sort=-price,name

- = descending
+ or no prefix = ascending
```

```javascript
app.get('/api/products', async (req, res) => {
  const sortStr = req.query.sort || '-created_at';
  
  // Parse sort string: "-price,name" -> { price: -1, name: 1 }
  const sort = {};
  sortStr.split(',').forEach(field => {
    if (field.startsWith('-')) {
      sort[field.substring(1)] = -1;  // Descending
    } else {
      sort[field] = 1;  // Ascending
    }
  });
  
  const products = await db.collection('products')
    .find()
    .sort(sort)
    .toArray();
  
  res.json({ data: products });
});
```

---

## 8. Authentication and Authorization

### JWT Authentication

```javascript
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

// Login endpoint
app.post('/api/auth/login', async (req, res) => {
  const { email, password } = req.body;
  
  // Find user
  const user = await db.collection('users').findOne({ email });
  if (!user) {
    return res.status(401).json({
      error: { message: 'Invalid credentials', code: 'AUTH_FAILED' }
    });
  }
  
  // Verify password
  const valid = await bcrypt.compare(password, user.password);
  if (!valid) {
    return res.status(401).json({
      error: { message: 'Invalid credentials', code: 'AUTH_FAILED' }
    });
  }
  
  // Generate JWT
  const token = jwt.sign(
    { 
      userId: user._id,
      email: user.email,
      role: user.role
    },
    process.env.JWT_SECRET,
    { expiresIn: '24h' }
  );
  
  res.json({
    token,
    user: {
      id: user._id,
      name: user.name,
      email: user.email
    }
  });
});

// Auth middleware
function authenticate(req, res, next) {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({
      error: { message: 'No token provided', code: 'AUTH_REQUIRED' }
    });
  }
  
  const token = authHeader.substring(7);
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({
      error: { message: 'Invalid token', code: 'INVALID_TOKEN' }
    });
  }
}

// Protected route
app.get('/api/profile', authenticate, (req, res) => {
  res.json({ user: req.user });
});
```

### Authorization (Role-Based)

```javascript
function authorize(...allowedRoles) {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({
        error: { message: 'Authentication required', code: 'AUTH_REQUIRED' }
      });
    }
    
    if (!allowedRoles.includes(req.user.role)) {
      return res.status(403).json({
        error: { message: 'Insufficient permissions', code: 'FORBIDDEN' }
      });
    }
    
    next();
  };
}

// Only admins can delete users
app.delete('/api/users/:id', 
  authenticate,
  authorize('admin'),
  deleteUserHandler
);

// Admins and moderators can edit posts
app.put('/api/posts/:id',
  authenticate,
  authorize('admin', 'moderator'),
  updatePostHandler
);
```

---

## 9. Error Handling

### Consistent Error Format

```javascript
// Error response format
{
  "error": {
    "message": "User-friendly error message",
    "code": "ERROR_CODE",
    "details": {
      "field": "Specific field error"
    },
    "request_id": "req_123abc",
    "timestamp": "2024-01-15T10:30:00Z"
  }
}
```

### Error Handling Middleware

```javascript
// Custom error class
class APIError extends Error {
  constructor(message, statusCode, code, details = null) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.details = details;
  }
}

// Error handler middleware
app.use((err, req, res, next) => {
  // Log error
  console.error('API Error:', {
    message: err.message,
    stack: err.stack,
    requestId: req.id
  });
  
  // Determine status code
  const statusCode = err.statusCode || 500;
  
  // Send error response
  res.status(statusCode).json({
    error: {
      message: err.message || 'Internal server error',
      code: err.code || 'INTERNAL_ERROR',
      details: err.details || null,
      request_id: req.id,
      timestamp: new Date().toISOString()
    }
  });
});

// Usage
app.post('/api/users', async (req, res, next) => {
  try {
    if (!req.body.email) {
      throw new APIError(
        'Email is required',
        400,
        'VALIDATION_ERROR',
        { field: 'email' }
      );
    }
    
    // Create user...
    
  } catch (error) {
    next(error);
  }
});
```

---

## 10. API Documentation

### OpenAPI (Swagger)

```yaml
openapi: 3.0.0
info:
  title: User API
  version: 1.0.0
  description: API for managing users

servers:
  - url: https://api.example.com/v1

paths:
  /users:
    get:
      summary: List users
      parameters:
        - name: page
          in: query
          schema:
            type: integer
            default: 1
        - name: limit
          in: query
          schema:
            type: integer
            default: 20
      responses:
        '200':
          description: Successful response
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/User'
                  meta:
                    $ref: '#/components/schemas/PaginationMeta'
    
    post:
      summary: Create user
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateUserRequest'
      responses:
        '201':
          description: User created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'

components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: string
        name:
          type: string
        email:
          type: string
          format: email
        created_at:
          type: string
          format: date-time
    
    CreateUserRequest:
      type: object
      required:
        - name
        - email
        - password
      properties:
        name:
          type: string
        email:
          type: string
          format: email
        password:
          type: string
          format: password
```

---

## Chapter 14 Summary

### Key Concepts

1. **REST** - Resource-based URLs, HTTP methods
2. **GraphQL** - Flexible queries, single endpoint
3. **gRPC** - High performance, Protocol Buffers
4. **Versioning** - URL, header, or query parameter
5. **Rate Limiting** - Prevent abuse
6. **Pagination** - Offset or cursor-based
7. **Authentication** - JWT tokens
8. **Error Handling** - Consistent format

### API Design Principles

1. **Consistency** - Predictable patterns
2. **Documentation** - Clear and complete
3. **Versioning** - Plan for changes
4. **Security** - Authentication + Authorization
5. **Performance** - Caching, pagination
6. **Error Handling** - Helpful error messages

### Technology Comparison

| Use Case | Technology |
|----------|-----------|
| **Public API** | REST |
| **Complex queries** | GraphQL |
| **Internal services** | gRPC |
| **Real-time** | WebSocket, GraphQL Subscriptions |

### Best Practices

1. Use plural nouns for resources
2. Version your API from the start
3. Implement rate limiting
4. Paginate large datasets
5. Return appropriate HTTP status codes
6. Provide comprehensive error messages
7. Document with OpenAPI/Swagger
8. Use HTTPS everywhere

### Interview Tips

**Common Questions:**
1. "Design a REST API for [domain]"
2. "REST vs GraphQL - when to use each?"
3. "How do you version APIs?"
4. "Explain rate limiting"
5. "How do you handle authentication?"

**How to Answer:**
- Draw API structure
- Show example requests/responses
- Discuss HTTP methods and status codes
- Explain trade-offs
- Mention security concerns

### Next Steps

Chapter 15 will cover **Horizontal vs Vertical Scaling** - understanding different scaling strategies and when to apply them.