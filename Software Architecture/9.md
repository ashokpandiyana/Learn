# Chapter 9: Serverless Architecture

## Table of Contents
1. Introduction to Serverless
2. Function as a Service (FaaS)
3. Backend as a Service (BaaS)
4. AWS Lambda Deep Dive
5. Event-Driven Serverless
6. Cold Starts and Performance
7. Implementation Examples
8. Serverless Patterns
9. Cost Optimization
10. Advantages and Disadvantages
11. When to Use Serverless

---

## 1. Introduction to Serverless

**Definition:** Serverless is a cloud computing execution model where the cloud provider dynamically manages the allocation and provisioning of servers. Applications are broken into individual functions that are invoked by events.

### What "Serverless" Really Means

```
Traditional Server:
┌─────────────────────────┐
│  Your Server (24/7)     │
│  - You manage           │
│  - You scale            │
│  - You pay fixed cost   │
│  - Always running       │
└─────────────────────────┘

Serverless:
┌─────────────────────────┐
│  Cloud Provider's Servers│
│  - Provider manages     │
│  - Auto-scales          │
│  - Pay per execution    │
│  - Runs on demand       │
└─────────────────────────┘
```

**Key Characteristics:**
1. **No server management** - Provider handles infrastructure
2. **Automatic scaling** - Scales from 0 to infinity
3. **Pay per use** - Only charged for actual execution time
4. **Event-driven** - Functions triggered by events
5. **Stateless** - Each invocation is independent

### Serverless vs Traditional

| Aspect | Traditional | Serverless |
|--------|------------|------------|
| **Server Management** | You manage | Provider manages |
| **Scaling** | Manual/Auto-scaling | Automatic |
| **Pricing** | Pay for uptime | Pay per request |
| **Idle Cost** | Yes (server always on) | No (pay only when running) |
| **Deployment** | Deploy entire app | Deploy individual functions |
| **State** | Can be stateful | Stateless |
| **Cold Start** | No | Yes |
| **Execution Time Limit** | No limit | Limited (AWS: 15 min) |

---

## 2. Function as a Service (FaaS)

**Definition:** FaaS is a category of serverless computing where you write and deploy individual functions that are executed in response to events.

### Popular FaaS Providers

- **AWS Lambda** - Most popular, rich ecosystem
- **Google Cloud Functions** - Good for GCP users
- **Azure Functions** - Microsoft's offering
- **Cloudflare Workers** - Edge computing
- **Netlify Functions** - JAMstack focused

### AWS Lambda Example

```javascript
// handler.js - Simple Lambda function
exports.handler = async (event) => {
    console.log('Event:', JSON.stringify(event, null, 2));
    
    // Your business logic
    const name = event.queryStringParameters?.name || 'World';
    
    // Return response
    return {
        statusCode: 200,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'
        },
        body: JSON.stringify({
            message: `Hello, ${name}!`,
            timestamp: new Date().toISOString()
        })
    };
};
```

### Function Lifecycle

```
1. Event Trigger
   ↓
2. Cold Start (if needed)
   - Download code
   - Initialize runtime
   - Initialize function
   ↓
3. Execute Handler
   ↓
4. Return Response
   ↓
5. Container Kept Warm (for a while)
   OR
   Container Destroyed
```

---

## 3. Backend as a Service (BaaS)

**Definition:** BaaS provides pre-built backend services so you don't have to build and manage them yourself.

### Common BaaS Services

**Authentication:**
- AWS Cognito
- Auth0
- Firebase Authentication

**Database:**
- AWS DynamoDB
- Firebase Firestore
- MongoDB Atlas

**Storage:**
- AWS S3
- Google Cloud Storage
- Azure Blob Storage

**Messaging:**
- AWS SNS/SQS
- Firebase Cloud Messaging
- Twilio

### Example: Using BaaS

```typescript
// Using AWS SDK to interact with BaaS services
import { DynamoDB } from 'aws-sdk';
import { S3 } from 'aws-sdk';
import { SES } from 'aws-sdk';

const dynamodb = new DynamoDB.DocumentClient();
const s3 = new S3();
const ses = new SES();

export const handler = async (event: any) => {
    // 1. Store data in DynamoDB (BaaS Database)
    await dynamodb.put({
        TableName: 'Users',
        Item: {
            userId: '123',
            email: 'user@example.com',
            createdAt: Date.now()
        }
    }).promise();
    
    // 2. Upload file to S3 (BaaS Storage)
    await s3.putObject({
        Bucket: 'my-bucket',
        Key: 'user-123/profile.jpg',
        Body: Buffer.from('...'),
        ContentType: 'image/jpeg'
    }).promise();
    
    // 3. Send email via SES (BaaS Email)
    await ses.sendEmail({
        Source: 'noreply@example.com',
        Destination: {
            ToAddresses: ['user@example.com']
        },
        Message: {
            Subject: { Data: 'Welcome!' },
            Body: { Text: { Data: 'Welcome to our service!' } }
        }
    }).promise();
    
    return { statusCode: 200, body: 'Success' };
};
```

---

## 4. AWS Lambda Deep Dive

### Lambda Function Structure

```python
# lambda_function.py
import json
import boto3
from datetime import datetime

# Initialize outside handler for reuse (warm starts)
dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('Orders')

def lambda_handler(event, context):
    """
    Main handler function
    
    Args:
        event: Input event data (API Gateway, S3, etc.)
        context: Runtime information (request ID, memory limit, etc.)
    
    Returns:
        Response object
    """
    
    # Log event
    print(f"Event: {json.dumps(event)}")
    print(f"Request ID: {context.request_id}")
    print(f"Memory Limit: {context.memory_limit_in_mb} MB")
    print(f"Time Remaining: {context.get_remaining_time_in_millis()} ms")
    
    try:
        # Parse input
        body = json.loads(event.get('body', '{}'))
        
        # Business logic
        order = {
            'orderId': context.request_id,
            'customerId': body.get('customerId'),
            'items': body.get('items', []),
            'total': calculate_total(body.get('items', [])),
            'createdAt': datetime.now().isoformat(),
            'status': 'PENDING'
        }
        
        # Save to DynamoDB
        table.put_item(Item=order)
        
        # Return success response
        return {
            'statusCode': 201,
            'headers': {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps({
                'orderId': order['orderId'],
                'status': order['status']
            })
        }
        
    except Exception as e:
        # Error handling
        print(f"Error: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps({'error': 'Internal server error'})
        }

def calculate_total(items):
    return sum(item['price'] * item['quantity'] for item in items)
```

### Lambda Configuration

```yaml
# serverless.yml (Serverless Framework)
service: order-service

provider:
  name: aws
  runtime: python3.9
  region: us-east-1
  memorySize: 512  # MB
  timeout: 30      # seconds
  
  environment:
    ORDERS_TABLE: ${self:service}-orders-${self:provider.stage}
  
  iamRoleStatements:
    - Effect: Allow
      Action:
        - dynamodb:PutItem
        - dynamodb:GetItem
        - dynamodb:Query
      Resource:
        - arn:aws:dynamodb:${self:provider.region}:*:table/${self:provider.environment.ORDERS_TABLE}

functions:
  createOrder:
    handler: lambda_function.lambda_handler
    events:
      - http:
          path: /orders
          method: post
          cors: true
    
  getOrder:
    handler: get_order.lambda_handler
    events:
      - http:
          path: /orders/{id}
          method: get
          cors: true

resources:
  Resources:
    OrdersTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.ORDERS_TABLE}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: orderId
            AttributeType: S
        KeySchema:
          - AttributeName: orderId
            KeyType: HASH
```

### Lambda Event Sources

**1. API Gateway (HTTP)**
```javascript
// Event from API Gateway
{
  "httpMethod": "POST",
  "path": "/users",
  "queryStringParameters": { "page": "1" },
  "headers": {
    "Content-Type": "application/json",
    "Authorization": "Bearer token..."
  },
  "body": "{\"name\":\"John\",\"email\":\"john@example.com\"}",
  "requestContext": {
    "requestId": "abc-123",
    "identity": {
      "sourceIp": "1.2.3.4"
    }
  }
}
```

**2. S3 (File Upload)**
```javascript
// Event from S3
{
  "Records": [
    {
      "eventName": "ObjectCreated:Put",
      "s3": {
        "bucket": {
          "name": "my-bucket"
        },
        "object": {
          "key": "uploads/image.jpg",
          "size": 1024000
        }
      }
    }
  ]
}

// Lambda handler for S3 events
exports.handler = async (event) => {
    for (const record of event.Records) {
        const bucket = record.s3.bucket.name;
        const key = record.s3.object.key;
        
        console.log(`Processing file: s3://${bucket}/${key}`);
        
        // Download file
        const s3Object = await s3.getObject({
            Bucket: bucket,
            Key: key
        }).promise();
        
        // Process file (e.g., resize image, extract text)
        const processed = await processFile(s3Object.Body);
        
        // Upload processed file
        await s3.putObject({
            Bucket: bucket,
            Key: `processed/${key}`,
            Body: processed
        }).promise();
    }
    
    return { statusCode: 200 };
};
```

**3. DynamoDB Streams**
```javascript
// Event from DynamoDB Streams
{
  "Records": [
    {
      "eventName": "INSERT",
      "dynamodb": {
        "NewImage": {
          "userId": { "S": "123" },
          "email": { "S": "user@example.com" },
          "status": { "S": "active" }
        }
      }
    }
  ]
}

// Lambda handler for DynamoDB Streams
exports.handler = async (event) => {
    for (const record of event.Records) {
        if (record.eventName === 'INSERT') {
            const newUser = record.dynamodb.NewImage;
            
            // Send welcome email
            await sendWelcomeEmail(
                newUser.email.S,
                newUser.userId.S
            );
        }
    }
};
```

**4. EventBridge (Scheduled)**
```javascript
// Event from EventBridge (CloudWatch Events)
{
  "source": "aws.events",
  "detail-type": "Scheduled Event",
  "time": "2024-01-15T10:00:00Z"
}

// Lambda handler for scheduled events
exports.handler = async (event) => {
    console.log('Running daily cleanup job...');
    
    // Delete old records
    await deleteOldRecords();
    
    // Generate daily report
    await generateDailyReport();
    
    return { statusCode: 200 };
};
```

**5. SQS (Queue)**
```javascript
// Event from SQS
{
  "Records": [
    {
      "messageId": "msg-123",
      "body": "{\"orderId\":\"order-456\",\"action\":\"process\"}"
    }
  ]
}

// Lambda handler for SQS
exports.handler = async (event) => {
    for (const record of event.Records) {
        const message = JSON.parse(record.body);
        
        // Process order
        await processOrder(message.orderId);
        
        // SQS automatically deletes message if Lambda succeeds
    }
};
```

---

## 5. Event-Driven Serverless

Serverless architectures are naturally event-driven.

### Example: E-Commerce Order Flow

```typescript
// ============================================
// Lambda 1: Create Order (API Gateway trigger)
// ============================================
import { DynamoDB, SNS } from 'aws-sdk';

const dynamodb = new DynamoDB.DocumentClient();
const sns = new SNS();

export const createOrder = async (event: any) => {
    const order = JSON.parse(event.body);
    
    // Save order to DynamoDB
    await dynamodb.put({
        TableName: 'Orders',
        Item: {
            orderId: generateId(),
            customerId: order.customerId,
            items: order.items,
            total: calculateTotal(order.items),
            status: 'PENDING',
            createdAt: Date.now()
        }
    }).promise();
    
    // Publish event to SNS
    await sns.publish({
        TopicArn: process.env.ORDER_TOPIC_ARN!,
        Message: JSON.stringify({
            eventType: 'OrderCreated',
            orderId: order.orderId,
            customerId: order.customerId,
            total: order.total
        })
    }).promise();
    
    return {
        statusCode: 201,
        body: JSON.stringify({ orderId: order.orderId })
    };
};

// ============================================
// Lambda 2: Process Payment (SNS trigger)
// ============================================
export const processPayment = async (event: any) => {
    for (const record of event.Records) {
        const message = JSON.parse(record.Sns.Message);
        
        if (message.eventType === 'OrderCreated') {
            // Process payment
            const paymentResult = await chargeCustomer(
                message.customerId,
                message.total
            );
            
            // Update order status
            await dynamodb.update({
                TableName: 'Orders',
                Key: { orderId: message.orderId },
                UpdateExpression: 'SET #status = :status, paymentId = :paymentId',
                ExpressionAttributeNames: { '#status': 'status' },
                ExpressionAttributeValues: {
                    ':status': paymentResult.success ? 'PAID' : 'PAYMENT_FAILED',
                    ':paymentId': paymentResult.transactionId
                }
            }).promise();
            
            // Publish payment event
            if (paymentResult.success) {
                await sns.publish({
                    TopicArn: process.env.ORDER_TOPIC_ARN!,
                    Message: JSON.stringify({
                        eventType: 'PaymentProcessed',
                        orderId: message.orderId
                    })
                }).promise();
            }
        }
    }
};

// ============================================
// Lambda 3: Update Inventory (SNS trigger)
// ============================================
export const updateInventory = async (event: any) => {
    for (const record of event.Records) {
        const message = JSON.parse(record.Sns.Message);
        
        if (message.eventType === 'PaymentProcessed') {
            // Get order details
            const order = await dynamodb.get({
                TableName: 'Orders',
                Key: { orderId: message.orderId }
            }).promise();
            
            // Reduce inventory
            for (const item of order.Item.items) {
                await dynamodb.update({
                    TableName: 'Inventory',
                    Key: { productId: item.productId },
                    UpdateExpression: 'SET quantity = quantity - :qty',
                    ExpressionAttributeValues: {
                        ':qty': item.quantity
                    }
                }).promise();
            }
            
            // Publish inventory updated event
            await sns.publish({
                TopicArn: process.env.ORDER_TOPIC_ARN!,
                Message: JSON.stringify({
                    eventType: 'InventoryUpdated',
                    orderId: message.orderId
                })
            }).promise();
        }
    }
};

// ============================================
// Lambda 4: Send Notification (SNS trigger)
// ============================================
import { SES } from 'aws-sdk';
const ses = new SES();

export const sendNotification = async (event: any) => {
    for (const record of event.Records) {
        const message = JSON.parse(record.Sns.Message);
        
        if (message.eventType === 'InventoryUpdated') {
            // Get customer email
            const customer = await dynamodb.get({
                TableName: 'Customers',
                Key: { customerId: message.customerId }
            }).promise();
            
            // Send confirmation email
            await ses.sendEmail({
                Source: 'orders@example.com',
                Destination: {
                    ToAddresses: [customer.Item.email]
                },
                Message: {
                    Subject: { Data: 'Order Confirmed' },
                    Body: {
                        Text: {
                            Data: `Your order ${message.orderId} has been confirmed!`
                        }
                    }
                }
            }).promise();
        }
    }
};
```

**Event Flow:**
```
API Request → Lambda: Create Order
                ↓
            SNS Topic
                ↓
      ┌─────────┴─────────────────────┐
      ↓                 ↓               ↓
Lambda: Process    Lambda: Update  Lambda: Send
Payment            Inventory       Notification
      ↓                 ↓               ↓
  DynamoDB          DynamoDB         SES
```

---

## 6. Cold Starts and Performance

### What is a Cold Start?

```
Cold Start:
Request → Container doesn't exist
       → Download code
       → Initialize runtime
       → Initialize function
       → Execute (500-3000ms total)

Warm Start:
Request → Container exists
       → Execute immediately (1-10ms)
```

### Cold Start Factors

**1. Runtime**
- **Fastest:** Node.js, Python (~100-200ms)
- **Medium:** Go, Java (~500-1000ms)
- **Slowest:** .NET, Java with large dependencies (~1-3s)

**2. Memory/CPU**
- More memory = More CPU = Faster cold starts
- 128 MB: Slow
- 512 MB: Medium
- 3008 MB: Fast

**3. Code Size**
- Smaller packages = Faster cold starts
- Use layers for dependencies
- Tree-shake unused code

**4. VPC**
- Lambda in VPC: +10s cold start (previously)
- Now improved with Hyperplane ENIs

### Reducing Cold Starts

```javascript
// ============================================
// Bad: Initialize inside handler
// ============================================
exports.handler = async (event) => {
    // ❌ Creates new connection every invocation (cold + warm)
    const dynamodb = new AWS.DynamoDB.DocumentClient();
    const s3 = new AWS.S3();
    
    // Use services...
};

// ============================================
// Good: Initialize outside handler
// ============================================
const AWS = require('aws-sdk');
// ✅ Initialized once during cold start, reused on warm starts
const dynamodb = new AWS.DynamoDB.DocumentClient();
const s3 = new AWS.S3();

exports.handler = async (event) => {
    // Reuse connections
    await dynamodb.put(...).promise();
    await s3.putObject(...).promise();
};

// ============================================
// Best: Lazy initialization
// ============================================
let dynamodb;
let s3;

function getDynamoDB() {
    if (!dynamodb) {
        dynamodb = new AWS.DynamoDB.DocumentClient();
    }
    return dynamodb;
}

exports.handler = async (event) => {
    // Only initialize when needed
    await getDynamoDB().put(...).promise();
};
```

### Keeping Functions Warm

```javascript
// ============================================
// Provisioned Concurrency (AWS)
// ============================================
// In serverless.yml
functions:
  myFunction:
    handler: handler.main
    provisionedConcurrency: 5  # Keep 5 instances warm

// ============================================
// Scheduled Warm-up
// ============================================
exports.handler = async (event) => {
    // Check if this is a warm-up ping
    if (event.source === 'warmup') {
        console.log('WarmUp ping');
        return 'Warmed up!';
    }
    
    // Normal logic
    // ...
};

// Schedule warm-up every 5 minutes
// serverless.yml
functions:
  myFunction:
    handler: handler.main
    events:
      - schedule:
          rate: rate(5 minutes)
          input:
            source: warmup
```

### Performance Optimization

```typescript
// ============================================
// Connection Pooling
// ============================================
import { Pool } from 'pg';

// Single pool reused across invocations
const pool = new Pool({
    host: process.env.DB_HOST,
    max: 1,  // Lambda has limited concurrency
    idleTimeoutMillis: 600000,  // 10 minutes
    connectionTimeoutMillis: 5000
});

export const handler = async (event: any) => {
    const client = await pool.connect();
    
    try {
        const result = await client.query('SELECT * FROM users');
        return { statusCode: 200, body: JSON.stringify(result.rows) };
    } finally {
        client.release();
    }
};

// ============================================
// Parallel Execution
// ============================================
export const handler = async (event: any) => {
    // ❌ Sequential (slow)
    const user = await getUser(userId);
    const orders = await getOrders(userId);
    const products = await getProducts(orderIds);
    
    // ✅ Parallel (fast)
    const [user, orders, products] = await Promise.all([
        getUser(userId),
        getOrders(userId),
        getProducts(orderIds)
    ]);
    
    return { user, orders, products };
};
```

---

## 7. Implementation Examples

### Example 1: REST API with Lambda

```javascript
// ============================================
// Users API - Multiple Lambdas
// ============================================

// GET /users
exports.listUsers = async (event) => {
    const result = await dynamodb.scan({
        TableName: 'Users',
        Limit: 100
    }).promise();
    
    return {
        statusCode: 200,
        body: JSON.stringify(result.Items)
    };
};

// GET /users/{id}
exports.getUser = async (event) => {
    const userId = event.pathParameters.id;
    
    const result = await dynamodb.get({
        TableName: 'Users',
        Key: { userId }
    }).promise();
    
    if (!result.Item) {
        return {
            statusCode: 404,
            body: JSON.stringify({ error: 'User not found' })
        };
    }
    
    return {
        statusCode: 200,
        body: JSON.stringify(result.Item)
    };
};

// POST /users
exports.createUser = async (event) => {
    const user = JSON.parse(event.body);
    
    // Validate
    if (!user.email || !user.name) {
        return {
            statusCode: 400,
            body: JSON.stringify({ error: 'Email and name required' })
        };
    }
    
    // Create user
    const newUser = {
        userId: uuidv4(),
        email: user.email,
        name: user.name,
        createdAt: Date.now()
    };
    
    await dynamodb.put({
        TableName: 'Users',
        Item: newUser
    }).promise();
    
    return {
        statusCode: 201,
        body: JSON.stringify(newUser)
    };
};

// PUT /users/{id}
exports.updateUser = async (event) => {
    const userId = event.pathParameters.id;
    const updates = JSON.parse(event.body);
    
    const result = await dynamodb.update({
        TableName: 'Users',
        Key: { userId },
        UpdateExpression: 'SET #name = :name, email = :email',
        ExpressionAttributeNames: { '#name': 'name' },
        ExpressionAttributeValues: {
            ':name': updates.name,
            ':email': updates.email
        },
        ReturnValues: 'ALL_NEW'
    }).promise();
    
    return {
        statusCode: 200,
        body: JSON.stringify(result.Attributes)
    };
};

// DELETE /users/{id}
exports.deleteUser = async (event) => {
    const userId = event.pathParameters.id;
    
    await dynamodb.delete({
        TableName: 'Users',
        Key: { userId }
    }).promise();
    
    return {
        statusCode: 204,
        body: ''
    };
};
```

### Example 2: Image Processing Pipeline

```python
# Lambda 1: Upload Handler
import boto3
import json

s3 = boto3.client('s3')
sqs = boto3.client('sqs')

def lambda_handler(event, context):
    """Handle image upload"""
    
    # Get file from request
    file_content = event['body']
    file_name = event['queryStringParameters']['fileName']
    
    # Upload to S3
    bucket = 'images-raw'
    key = f'uploads/{file_name}'
    
    s3.put_object(
        Bucket=bucket,
        Key=key,
        Body=file_content,
        ContentType='image/jpeg'
    )
    
    # Send message to SQS for processing
    sqs.send_message(
        QueueUrl=os.environ['PROCESSING_QUEUE_URL'],
        MessageBody=json.dumps({
            'bucket': bucket,
            'key': key,
            'operations': ['resize', 'optimize', 'watermark']
        })
    )
    
    return {
        'statusCode': 200,
        'body': json.dumps({'message': 'Upload successful', 'key': key})
    }

# Lambda 2: Image Processor (SQS trigger)
from PIL import Image
import io

def lambda_handler(event, context):
    """Process images from queue"""
    
    for record in event['Records']:
        message = json.loads(record['body'])
        
        # Download image from S3
        response = s3.get_object(
            Bucket=message['bucket'],
            Key=message['key']
        )
        image_data = response['Body'].read()
        image = Image.open(io.BytesIO(image_data))
        
        # Process image
        for operation in message['operations']:
            if operation == 'resize':
                image = image.resize((800, 600))
            elif operation == 'optimize':
                # Optimize compression
                pass
            elif operation == 'watermark':
                # Add watermark
                pass
        
        # Save processed image
        buffer = io.BytesIO()
        image.save(buffer, format='JPEG', quality=85)
        buffer.seek(0)
        
        s3.put_object(
            Bucket='images-processed',
            Key=f'processed/{message["key"]}',
            Body=buffer,
            ContentType='image/jpeg'
        )
        
        print(f'Processed: {message["key"]}')

# Lambda 3: Cleanup Old Images (Scheduled)
from datetime import datetime, timedelta

def lambda_handler(event, context):
    """Delete images older than 30 days"""
    
    cutoff_date = datetime.now() - timedelta(days=30)
    
    # List objects
    response = s3.list_objects_v2(Bucket='images-processed')
    
    for obj in response.get('Contents', []):
        if obj['LastModified'].replace(tzinfo=None) < cutoff_date:
            s3.delete_object(
                Bucket='images-processed',
                Key=obj['Key']
            )
            print(f'Deleted old image: {obj["Key"]}')
```

---

## 8. Serverless Patterns

### Pattern 1: Fan-Out

One event triggers multiple functions.

```typescript
// SNS Topic receives event
// Multiple Lambdas subscribe

// Lambda 1: Send Email
export const sendEmail = async (event: any) => {
    const message = JSON.parse(event.Records[0].Sns.Message);
    await sendEmailNotification(message.userId, message.orderId);
};

// Lambda 2: Send SMS
export const sendSMS = async (event: any) => {
    const message = JSON.parse(event.Records[0].Sns.Message);
    await sendSMSNotification(message.userId, message.orderId);
};

// Lambda 3: Update Analytics
export const updateAnalytics = async (event: any) => {
    const message = JSON.parse(event.Records[0].Sns.Message);
    await recordOrderEvent(message.orderId);
};
```

### Pattern 2: Pipes and Filters

Chain of functions processing data.

```
S3 Upload → Lambda 1 (Validate) → Lambda 2 (Transform) → Lambda 3 (Store)
```

### Pattern 3: Backend for Frontend (BFF)

Separate Lambda for each client type.

```typescript
// Lambda for Web Client
export const webBFF = async (event: any) => {
    // Aggregated data for web
    const [user, orders, recommendations] = await Promise.all([
        getUser(userId),
        getOrders(userId),
        getRecommendations(userId)
    ]);
    
    return {
        statusCode: 200,
        body: JSON.stringify({
            user,
            orders,
            recommendations
        })
    };
};

// Lambda for Mobile Client
export const mobileBFF = async (event: any) => {
    // Minimal data for mobile
    const user = await getUser(userId);
    const recentOrders = await getRecentOrders(userId, 5);
    
    return {
        statusCode: 200,
        body: JSON.stringify({
            user: {
                name: user.name,
                avatar: user.avatar
            },
            recentOrders
        })
    };
};
```

---

## 9. Cost Optimization

### AWS Lambda Pricing

```
Cost = (Number of Requests × $0.20 per 1M requests)
     + (Duration × Memory × $0.00001667 per GB-second)
```

### Example Calculation

```
Function: 512 MB memory, 200ms duration
Requests: 10 million per month

Request Cost:
10,000,000 × $0.20 / 1,000,000 = $2.00

Compute Cost:
10,000,000 × 0.2s × 0.5GB × $0.00001667 = $16.67

Total: $18.67 per month
```

### Cost Optimization Tips

**1. Right-Size Memory**
```javascript
// Test different memory settings
// 512 MB: 200ms = $16.67
// 1024 MB: 100ms = $16.67  ← Better performance, same cost!
// 3008 MB: 50ms = $25.01   ← Best performance, higher cost
```

**2. Reduce Execution Time**
```javascript
// ❌ Slow (1000ms)
const data = await fetchData();
const processed = await processData(data);
const result = await saveData(processed);

// ✅ Fast (300ms) - Parallel where possible
const [data, config] = await Promise.all([
    fetchData(),
    getConfig()
]);
const processed = processData(data, config);
await saveData(processed);
```

**3. Use Appropriate Memory**
```
Small tasks (< 100KB data): 128-256 MB
Medium tasks (API calls): 512-1024 MB
Large tasks (data processing): 1536-3008 MB
```

**4. Batch Processing**
```javascript
// ❌ Process one item per invocation (expensive)
exports.handler = async (event) => {
    const item = event.item;
    await processItem(item);
};

// ✅ Process batch per invocation (cheaper)
exports.handler = async (event) => {
    const items = event.items;  // Up to 1000 items
    await Promise.all(items.map(processItem));
};
```

---

## 10. Advantages and Disadvantages

### ✅ Advantages

**1. No Server Management**
```
Traditional:
- Provision servers
- Install OS
- Configure networking
- Install dependencies
- Monitor servers
- Apply security patches
= Lots of work!

Serverless:
- Write code
- Deploy
= Done!
```

**2. Automatic Scaling**
```
Traffic: 0 → 10,000 requests/second
Serverless: Auto-scales from 0 → 10,000 concurrent executions
Traditional: Need to configure auto-scaling, load balancers, etc.
```

**3. Pay Per Use**
```
Traditional Server:
- 1 server running 24/7
- Cost: $50/month (even if idle 90% of time)

Serverless:
- Only pay for actual execution
- 1M requests, 200ms each
- Cost: $18.67/month
```

**4. Built-in High Availability**
- Functions automatically deployed across multiple AZs
- No need to configure failover
- Provider handles redundancy

**5. Focus on Business Logic**
```javascript
// Just write this:
exports.handler = async (event) => {
    const user = await createUser(event.body);
    return { statusCode: 201, body: JSON.stringify(user) };
};

// Provider handles:
// - HTTP server
// - Load balancing
// - Scaling
// - Monitoring
// - Logging
```

### ❌ Disadvantages

**1. Cold Starts**
```
First request after idle: 500-3000ms
Subsequent requests: 1-10ms

Problem for:
- Real-time applications
- User-facing APIs with strict latency requirements
```

**2. Execution Time Limits**
```
AWS Lambda: 15 minutes max
Google Cloud Functions: 9 minutes max
Azure Functions: 10 minutes max

Not suitable for:
- Long-running batch jobs
- Video encoding
- Large data processing
```

**3. Stateless Architecture**
```javascript
// ❌ Can't do this:
let counter = 0;  // Resets on cold start
exports.handler = async () => {
    counter++;
    return counter;  // Unreliable!
};

// ✅ Must use external storage:
exports.handler = async () => {
    const counter = await redis.incr('counter');
    return counter;
};
```

**4. Vendor Lock-In**
```
AWS Lambda code → Hard to migrate to Google Cloud Functions
- Different event formats
- Different APIs
- Different configurations

Mitigation: Use frameworks like Serverless Framework
```

**5. Debugging Challenges**
```
Traditional:
- Attach debugger
- Set breakpoints
- Step through code

Serverless:
- Rely on logs
- CloudWatch Logs
- Distributed tracing needed
```

**6. Limited Execution Environment**
```
AWS Lambda:
- /tmp: 512 MB only
- Memory: Max 10 GB
- CPU: Tied to memory
- No GPU access
```

---

## 11. When to Use Serverless

### ✅ Good Use Cases

**1. Event-Driven Workloads**
```
- File uploads → Process images
- Database changes → Sync data
- API requests → CRUD operations
- Scheduled tasks → Daily reports
```

**2. Variable Traffic**
```
Traffic Pattern:
- Peak: 10,000 req/s (during business hours)
- Off-peak: 10 req/s (at night)

Traditional: Must provision for peak = waste money
Serverless: Auto-scales = cost efficient
```

**3. Microservices / APIs**
```
POST /users     → Lambda: Create User
GET  /users/:id → Lambda: Get User
PUT  /users/:id → Lambda: Update User
```

**4. Data Processing Pipelines**
```
S3 Upload → Lambda: Validate
         → Lambda: Transform
         → Lambda: Load to DW
```

**5. Chatbots & Webhooks**
```
Slack Event → Lambda: Process Command
GitHub Webhook → Lambda: Run CI/CD
```

### ❌ Not Good For

**1. Long-Running Tasks**
```
❌ Video encoding (hours)
❌ Machine learning training
❌ Large batch processing (> 15 min)

Use: EC2, ECS, Batch
```

**2. Stateful Applications**
```
❌ WebSocket servers with persistent connections
❌ Game servers
❌ Real-time multiplayer

Use: EC2, ECS with sticky sessions
```

**3. Consistent Low Latency Required**
```
❌ High-frequency trading
❌ Real-time gaming
❌ IoT with < 10ms latency

Cold starts are a problem
```

**4. Complex Dependencies**
```
❌ Large ML models (> 250 MB)
❌ GPU-required workloads
❌ Custom system libraries

Lambda has size and environment limits
```

---

## Chapter 9 Summary

### Key Concepts

1. **Serverless** = No server management, pay per use
2. **FaaS** = Function as a Service (Lambda, Cloud Functions)
3. **BaaS** = Backend as a Service (DynamoDB, Auth0)
4. **Event-Driven** = Functions triggered by events
5. **Stateless** = Each invocation is independent
6. **Cold Starts** = Initial latency when function not warm

### Architecture Patterns

- **Fan-Out**: One event → Multiple functions
- **Pipes and Filters**: Chain of processing
- **Backend for Frontend**: Client-specific APIs
- **Event Sourcing**: Events trigger state changes

### Cost Model

```
Cost = Requests + (Duration × Memory)
- First 1M requests free
- Pay only for execution time
- No idle costs
```

### When to Use

✅ **Good for:**
- Variable traffic
- Event-driven workloads
- Microservices APIs
- Data processing pipelines
- Rapid prototyping

❌ **Not good for:**
- Long-running tasks (> 15 min)
- Consistent low latency (< 10ms)
- Stateful applications
- Complex dependencies

### Interview Tips

**Common Questions:**
1. "What is serverless architecture?"
2. "Explain cold starts and how to mitigate them"
3. "When would you NOT use serverless?"
4. "How does serverless pricing work?"
5. "Compare Lambda vs EC2"

**How to Answer:**
- Define serverless clearly (no server management, pay per use)
- Give concrete examples (image processing, APIs)
- Discuss cold starts honestly with solutions
- Mention limitations (execution time, state)
- Compare costs with calculations

### AWS Services Summary

| Category | Service | Purpose |
|----------|---------|---------|
| **Compute** | Lambda | Run functions |
| **API** | API Gateway | HTTP APIs |
| **Database** | DynamoDB | NoSQL database |
| **Storage** | S3 | Object storage |
| **Messaging** | SNS/SQS | Pub/Sub, Queues |
| **Auth** | Cognito | User authentication |
| **Email** | SES | Send emails |

### Next Steps

Chapter 10 will cover **Load Balancing** - distributing traffic across multiple servers for high availability and scalability.