# Chapter 6: Event-Driven Architecture

## Table of Contents
1. Introduction to Event-Driven Architecture
2. Core Concepts
3. Event Sourcing
4. CQRS (Command Query Responsibility Segregation)
5. Event Bus and Message Brokers
6. Pub/Sub Pattern
7. Event Storming
8. Implementation Examples
9. Advantages and Disadvantages
10. Real-World Use Cases

---

## 1. Introduction to Event-Driven Architecture

**Definition:** Event-Driven Architecture (EDA) is an architectural pattern where the flow of the program is determined by events. Components communicate by producing and consuming events asynchronously.

### Traditional Request-Response vs Event-Driven

```
REQUEST-RESPONSE (Synchronous)
Client ‚îÄ[Request]‚Üí Service ‚îÄ[Response]‚Üí Client
        Waits...            Returns

EVENT-DRIVEN (Asynchronous)
Producer ‚îÄ[Event]‚Üí Event Bus ‚Üí Consumer 1
                            ‚Üí Consumer 2
                            ‚Üí Consumer 3
Producer continues immediately, doesn't wait
```

**Key Difference:** Producer doesn't know or care who consumes the event. Loose coupling!

---

## 2. Core Concepts

### 2.1 Events

**What is an Event?**
An event is a significant change in state.

**Event Structure:**
```typescript
interface Event {
    eventId: string;          // Unique identifier
    eventType: string;        // Type of event
    timestamp: Date;          // When it occurred
    aggregateId: string;      // Entity ID
    aggregateType: string;    // Entity type
    version: number;          // Event version
    data: any;                // Event payload
    metadata?: {              // Optional metadata
        userId: string;
        correlationId: string;
        causationId: string;
    };
}
```

**Example Events:**
```javascript
// User Registration Event
{
    eventId: "evt_123",
    eventType: "UserRegistered",
    timestamp: "2024-01-15T10:30:00Z",
    aggregateId: "user_456",
    aggregateType: "User",
    version: 1,
    data: {
        email: "user@example.com",
        name: "John Doe",
        registrationSource: "web"
    },
    metadata: {
        userId: "system",
        correlationId: "req_789"
    }
}

// Order Placed Event
{
    eventId: "evt_789",
    eventType: "OrderPlaced",
    timestamp: "2024-01-15T11:00:00Z",
    aggregateId: "order_123",
    aggregateType: "Order",
    version: 1,
    data: {
        customerId: "user_456",
        items: [
            { productId: "prod_1", quantity: 2, price: 29.99 },
            { productId: "prod_2", quantity: 1, price: 49.99 }
        ],
        total: 109.97
    }
}
```

### 2.2 Event Types

**1. Domain Events**
- Represent business occurrences
- Examples: OrderPlaced, PaymentProcessed, UserRegistered

**2. Integration Events**
- Cross-boundary communication
- Published to external systems
- Examples: OrderConfirmedEvent sent to shipping partner

**3. System Events**
- Technical events
- Examples: ServiceStarted, CacheCleared, DatabaseBackupCompleted

### 2.3 Event Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Producer   ‚îÇ Publishes event
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Event Bus   ‚îÇ Routes event
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚ñº              ‚ñº              ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇConsumer 1 ‚îÇ  ‚îÇConsumer 2 ‚îÇ  ‚îÇConsumer 3 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 3. Event Sourcing

**Definition:** Instead of storing current state, store the sequence of events that led to that state.

### Traditional CRUD vs Event Sourcing

```
TRADITIONAL (State-based)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Users Table      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ id: 1            ‚îÇ
‚îÇ name: "John Doe" ‚îÇ  ‚Üê Current state only
‚îÇ email: "j@e.com" ‚îÇ
‚îÇ status: "active" ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

EVENT SOURCING (Event-based)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Event Store                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ UserCreated(name: "Jon Do")     ‚îÇ Event 1
‚îÇ UserEmailUpdated(email:"j@e")   ‚îÇ Event 2
‚îÇ UserNameCorrected("John Doe")   ‚îÇ Event 3
‚îÇ UserActivated()                 ‚îÇ Event 4
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì Replay events
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Current State    ‚îÇ
‚îÇ name: "John Doe" ‚îÇ
‚îÇ email: "j@e.com" ‚îÇ
‚îÇ status: "active" ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Implementation Example

```typescript
// Event definitions
interface UserEvent {
    eventType: string;
    timestamp: Date;
    data: any;
}

class UserCreatedEvent implements UserEvent {
    eventType = 'UserCreated';
    constructor(
        public timestamp: Date,
        public data: {
            userId: string;
            email: string;
            name: string;
        }
    ) {}
}

class UserEmailUpdatedEvent implements UserEvent {
    eventType = 'UserEmailUpdated';
    constructor(
        public timestamp: Date,
        public data: {
            userId: string;
            oldEmail: string;
            newEmail: string;
        }
    ) {}
}

class UserDeactivatedEvent implements UserEvent {
    eventType = 'UserDeactivated';
    constructor(
        public timestamp: Date,
        public data: {
            userId: string;
            reason: string;
        }
    ) {}
}

// Aggregate - Reconstructed from events
class User {
    private id: string;
    private email: string;
    private name: string;
    private status: 'active' | 'inactive';
    private version: number = 0;
    
    // Apply event to update state
    apply(event: UserEvent): void {
        switch (event.eventType) {
            case 'UserCreated':
                this.id = event.data.userId;
                this.email = event.data.email;
                this.name = event.data.name;
                this.status = 'active';
                break;
                
            case 'UserEmailUpdated':
                this.email = event.data.newEmail;
                break;
                
            case 'UserDeactivated':
                this.status = 'inactive';
                break;
        }
        this.version++;
    }
    
    // Reconstruct from event history
    static fromHistory(events: UserEvent[]): User {
        const user = new User();
        events.forEach(event => user.apply(event));
        return user;
    }
}

// Event Store
class EventStore {
    private events: Map<string, UserEvent[]> = new Map();
    
    // Save event
    async save(aggregateId: string, event: UserEvent): Promise<void> {
        if (!this.events.has(aggregateId)) {
            this.events.set(aggregateId, []);
        }
        this.events.get(aggregateId)!.push(event);
        
        // In production: persist to database
        console.log(`Event saved: ${event.eventType} for ${aggregateId}`);
    }
    
    // Get all events for an aggregate
    async getEvents(aggregateId: string): Promise<UserEvent[]> {
        return this.events.get(aggregateId) || [];
    }
    
    // Rebuild current state
    async load(aggregateId: string): Promise<User | null> {
        const events = await this.getEvents(aggregateId);
        
        if (events.length === 0) {
            return null;
        }
        
        return User.fromHistory(events);
    }
}

// Usage
const eventStore = new EventStore();

// Create user
await eventStore.save('user_123', new UserCreatedEvent(
    new Date(),
    {
        userId: 'user_123',
        email: 'john@example.com',
        name: 'John Doe'
    }
));

// Update email
await eventStore.save('user_123', new UserEmailUpdatedEvent(
    new Date(),
    {
        userId: 'user_123',
        oldEmail: 'john@example.com',
        newEmail: 'johndoe@example.com'
    }
));

// Deactivate user
await eventStore.save('user_123', new UserDeactivatedEvent(
    new Date(),
    {
        userId: 'user_123',
        reason: 'User requested account closure'
    }
));

// Reconstruct current state
const user = await eventStore.load('user_123');
console.log(user);
// User {
//   id: 'user_123',
//   email: 'johndoe@example.com',
//   name: 'John Doe',
//   status: 'inactive',
//   version: 3
// }
```

### Benefits of Event Sourcing

**1. Complete Audit Trail**
```typescript
// Can answer: "What was the user's email on Jan 15?"
async function getUserStateAtTime(userId: string, targetDate: Date): Promise<User> {
    const events = await eventStore.getEvents(userId);
    const eventsUntilDate = events.filter(e => e.timestamp <= targetDate);
    return User.fromHistory(eventsUntilDate);
}
```

**2. Temporal Queries**
```sql
-- How many orders were placed in Q1?
SELECT COUNT(*) FROM events
WHERE event_type = 'OrderPlaced'
AND timestamp BETWEEN '2024-01-01' AND '2024-03-31';
```

**3. Event Replay**
```typescript
// Fix bug by replaying events with corrected logic
async function replayEvents() {
    const allEvents = await eventStore.getAllEvents();
    
    for (const event of allEvents) {
        // Apply corrected business logic
        await processEventWithNewLogic(event);
    }
}
```

**4. Debugging**
```typescript
// Reproduce exact state that caused bug
const buggyUser = await getUserStateAtTime('user_123', bugOccurredAt);
```

---

## 4. CQRS (Command Query Responsibility Segregation)

**Definition:** Separate read and write operations into different models.

### Traditional vs CQRS

```
TRADITIONAL (Same model for reads and writes)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Client  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ
     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Single Model   ‚îÇ Read + Write
‚îÇ  + Database     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

CQRS (Separate models)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Client  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ
     ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ Commands         ‚îÇ Queries            ‚îÇ
     ‚ñº                  ‚ñº                    ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ
‚îÇCommand   ‚îÇ      ‚îÇQuery       ‚îÇ           ‚îÇ
‚îÇModel     ‚îÇ      ‚îÇModel       ‚îÇ           ‚îÇ
‚îÇ(Write DB)‚îÇ      ‚îÇ(Read DB)   ‚îÇ           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ
     ‚îÇ                  ‚îÇ                   ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[Events]‚îÄ‚îÄ‚îÄ‚îÄ‚îò                   ‚îÇ
```

### Implementation Example

```python
# ============================================
# COMMAND SIDE (Writes)
# ============================================

# Commands
class CreateOrderCommand:
    def __init__(self, user_id, items):
        self.user_id = user_id
        self.items = items
        self.timestamp = datetime.now()

class CancelOrderCommand:
    def __init__(self, order_id, reason):
        self.order_id = order_id
        self.reason = reason
        self.timestamp = datetime.now()

# Command Handler
class OrderCommandHandler:
    def __init__(self, event_store, event_bus):
        self.event_store = event_store
        self.event_bus = event_bus
    
    def handle_create_order(self, command: CreateOrderCommand):
        # Validate command
        if not command.items:
            raise ValueError("Order must have items")
        
        # Create domain event
        event = OrderCreatedEvent(
            order_id=generate_id(),
            user_id=command.user_id,
            items=command.items,
            total=self._calculate_total(command.items),
            timestamp=command.timestamp
        )
        
        # Save to event store (write database)
        self.event_store.save(event)
        
        # Publish event to update read models
        self.event_bus.publish(event)
        
        return event.order_id
    
    def handle_cancel_order(self, command: CancelOrderCommand):
        # Load aggregate from events
        order = self.event_store.load_aggregate(command.order_id)
        
        # Business logic
        if order.status == 'SHIPPED':
            raise ValueError("Cannot cancel shipped order")
        
        # Create event
        event = OrderCancelledEvent(
            order_id=command.order_id,
            reason=command.reason,
            timestamp=command.timestamp
        )
        
        self.event_store.save(event)
        self.event_bus.publish(event)

# ============================================
# QUERY SIDE (Reads)
# ============================================

# Read Models (Optimized for queries)
class OrderSummaryReadModel:
    """Denormalized view optimized for listing orders"""
    def __init__(self):
        self.orders = {}  # In production: Redis or materialized view
    
    def project(self, event):
        """Update read model based on events"""
        if isinstance(event, OrderCreatedEvent):
            self.orders[event.order_id] = {
                'order_id': event.order_id,
                'user_id': event.user_id,
                'total': event.total,
                'status': 'PENDING',
                'created_at': event.timestamp,
                'item_count': len(event.items)
            }
        
        elif isinstance(event, OrderCancelledEvent):
            if event.order_id in self.orders:
                self.orders[event.order_id]['status'] = 'CANCELLED'

class OrderDetailsReadModel:
    """Detailed view for single order"""
    def __init__(self):
        self.order_details = {}
    
    def project(self, event):
        if isinstance(event, OrderCreatedEvent):
            self.order_details[event.order_id] = {
                'order_id': event.order_id,
                'user_id': event.user_id,
                'items': event.items,
                'total': event.total,
                'status': 'PENDING',
                'created_at': event.timestamp,
                'history': [{'event': 'created', 'timestamp': event.timestamp}]
            }
        
        elif isinstance(event, OrderCancelledEvent):
            if event.order_id in self.order_details:
                order = self.order_details[event.order_id]
                order['status'] = 'CANCELLED'
                order['history'].append({
                    'event': 'cancelled',
                    'reason': event.reason,
                    'timestamp': event.timestamp
                })

# Query Handler
class OrderQueryHandler:
    def __init__(self, summary_model, details_model):
        self.summary_model = summary_model
        self.details_model = details_model
    
    def get_user_orders(self, user_id):
        """Fast query from denormalized read model"""
        return [
            order for order in self.summary_model.orders.values()
            if order['user_id'] == user_id
        ]
    
    def get_order_details(self, order_id):
        """Get full order details"""
        return self.details_model.order_details.get(order_id)
    
    def get_order_history(self, order_id):
        """Get order event history"""
        order = self.details_model.order_details.get(order_id)
        return order['history'] if order else []

# ============================================
# Event Projector (Updates Read Models)
# ============================================

class EventProjector:
    def __init__(self, read_models):
        self.read_models = read_models
    
    def project_event(self, event):
        """Update all read models with new event"""
        for read_model in self.read_models:
            read_model.project(event)

# ============================================
# Usage
# ============================================

# Setup
event_store = EventStore()
event_bus = EventBus()

summary_model = OrderSummaryReadModel()
details_model = OrderDetailsReadModel()
projector = EventProjector([summary_model, details_model])

command_handler = OrderCommandHandler(event_store, event_bus)
query_handler = OrderQueryHandler(summary_model, details_model)

# Subscribe projector to events
event_bus.subscribe(projector.project_event)

# WRITE: Create order (command)
order_id = command_handler.handle_create_order(
    CreateOrderCommand(
        user_id='user_123',
        items=[
            {'product_id': 'prod_1', 'quantity': 2, 'price': 29.99},
            {'product_id': 'prod_2', 'quantity': 1, 'price': 49.99}
        ]
    )
)

# READ: Query orders (from read model, very fast)
user_orders = query_handler.get_user_orders('user_123')
print(user_orders)

order_details = query_handler.get_order_details(order_id)
print(order_details)
```

### CQRS Benefits

**1. Optimized Reads**
```sql
-- Read model can be denormalized for fast queries
SELECT order_id, user_name, total, status
FROM order_summary_view  -- Materialized view
WHERE user_id = 123;
-- No JOINs needed!
```

**2. Independent Scaling**
```
Write DB: 2 instances (fewer writes)
Read DB: 10 instances (many reads)
```

**3. Different Storage Technologies**
```
Command Side: PostgreSQL (ACID for writes)
Query Side: Elasticsearch (fast full-text search)
```

---

## 5. Event Bus and Message Brokers

### 5.1 Kafka Implementation

```javascript
const { Kafka } = require('kafkajs');

// Kafka configuration
const kafka = new Kafka({
    clientId: 'order-service',
    brokers: ['kafka1:9092', 'kafka2:9092', 'kafka3:9092']
});

// ============================================
// PRODUCER (Publishes Events)
// ============================================

class EventProducer {
    constructor() {
        this.producer = kafka.producer();
    }
    
    async connect() {
        await this.producer.connect();
    }
    
    async publishEvent(topic, event) {
        await this.producer.send({
            topic: topic,
            messages: [
                {
                    key: event.aggregateId,  // Partition key
                    value: JSON.stringify(event),
                    headers: {
                        'event-type': event.eventType,
                        'correlation-id': event.metadata.correlationId
                    }
                }
            ]
        });
        
        console.log(`Published ${event.eventType} to ${topic}`);
    }
    
    async disconnect() {
        await this.producer.disconnect();
    }
}

// Usage in Order Service
class OrderService {
    constructor(orderRepository, eventProducer) {
        this.orderRepository = orderRepository;
        this.eventProducer = eventProducer;
    }
    
    async placeOrder(userId, items) {
        // Create order
        const order = await this.orderRepository.save({
            userId,
            items,
            status: 'PENDING',
            total: this.calculateTotal(items)
        });
        
        // Publish event
        await this.eventProducer.publishEvent('order-events', {
            eventId: generateId(),
            eventType: 'OrderPlaced',
            aggregateId: order.id,
            aggregateType: 'Order',
            timestamp: new Date(),
            data: {
                orderId: order.id,
                userId: userId,
                items: items,
                total: order.total
            },
            metadata: {
                correlationId: generateId()
            }
        });
        
        return order;
    }
}

// ============================================
// CONSUMER (Subscribes to Events)
// ============================================

class EventConsumer {
    constructor(groupId) {
        this.consumer = kafka.consumer({ 
            groupId: groupId 
        });
        this.handlers = new Map();
    }
    
    async connect() {
        await this.consumer.connect();
    }
    
    async subscribe(topic) {
        await this.consumer.subscribe({ 
            topic: topic, 
            fromBeginning: false 
        });
    }
    
    registerHandler(eventType, handler) {
        this.handlers.set(eventType, handler);
    }
    
    async start() {
        await this.consumer.run({
            eachMessage: async ({ topic, partition, message }) => {
                const event = JSON.parse(message.value.toString());
                
                console.log(`Received ${event.eventType} from ${topic}`);
                
                const handler = this.handlers.get(event.eventType);
                if (handler) {
                    try {
                        await handler(event);
                        
                        // Commit offset (message processed)
                        // Auto-commit is enabled by default
                        
                    } catch (error) {
                        console.error(`Error handling ${event.eventType}:`, error);
                        // Implement retry logic or dead letter queue
                    }
                }
            }
        });
    }
}

// Email Service - Consumes OrderPlaced events
class EmailService {
    async start() {
        const consumer = new EventConsumer('email-service-group');
        await consumer.connect();
        await consumer.subscribe('order-events');
        
        // Register event handlers
        consumer.registerHandler('OrderPlaced', async (event) => {
            await this.sendOrderConfirmationEmail(
                event.data.userId,
                event.data.orderId
            );
        });
        
        consumer.registerHandler('OrderShipped', async (event) => {
            await this.sendShippingNotification(
                event.data.userId,
                event.data.trackingNumber
            );
        });
        
        await consumer.start();
    }
    
    async sendOrderConfirmationEmail(userId, orderId) {
        console.log(`Sending confirmation email to user ${userId} for order ${orderId}`);
        // Email logic...
    }
    
    async sendShippingNotification(userId, trackingNumber) {
        console.log(`Sending shipping notification to user ${userId}`);
        // Email logic...
    }
}

// Start consumer
const emailService = new EmailService();
emailService.start();
```

### 5.2 RabbitMQ Implementation

```python
import pika
import json

# ============================================
# PRODUCER
# ============================================

class EventPublisher:
    def __init__(self):
        self.connection = pika.BlockingConnection(
            pika.ConnectionParameters('rabbitmq')
        )
        self.channel = self.connection.channel()
        
        # Declare exchange
        self.channel.exchange_declare(
            exchange='events',
            exchange_type='topic',
            durable=True
        )
    
    def publish(self, routing_key, event):
        self.channel.basic_publish(
            exchange='events',
            routing_key=routing_key,
            body=json.dumps(event),
            properties=pika.BasicProperties(
                delivery_mode=2,  # Persistent
                content_type='application/json'
            )
        )
        print(f"Published {event['eventType']} with routing key {routing_key}")
    
    def close(self):
        self.connection.close()

# Usage
publisher = EventPublisher()

publisher.publish('order.placed', {
    'eventType': 'OrderPlaced',
    'orderId': 'order_123',
    'userId': 'user_456',
    'total': 109.97
})

# ============================================
# CONSUMER
# ============================================

class EventSubscriber:
    def __init__(self, queue_name):
        self.connection = pika.BlockingConnection(
            pika.ConnectionParameters('rabbitmq')
        )
        self.channel = self.connection.channel()
        self.queue_name = queue_name
        
        # Declare queue
        self.channel.queue_declare(queue=queue_name, durable=True)
        
        # QoS - process one message at a time
        self.channel.basic_qos(prefetch_count=1)
    
    def bind(self, routing_key):
        self.channel.queue_bind(
            exchange='events',
            queue=self.queue_name,
            routing_key=routing_key
        )
    
    def subscribe(self, callback):
        def wrapper(ch, method, properties, body):
            event = json.loads(body)
            try:
                callback(event)
                ch.basic_ack(delivery_tag=method.delivery_tag)
            except Exception as e:
                print(f"Error processing event: {e}")
                # Reject and requeue
                ch.basic_nack(
                    delivery_tag=method.delivery_tag,
                    requeue=True
                )
        
        self.channel.basic_consume(
            queue=self.queue_name,
            on_message_callback=wrapper
        )
        
        print(f"Waiting for events on {self.queue_name}...")
        self.channel.start_consuming()

# Email Service
def handle_order_event(event):
    event_type = event['eventType']
    
    if event_type == 'OrderPlaced':
        print(f"Sending confirmation for order {event['orderId']}")
        # Send email...
    
    elif event_type == 'OrderShipped':
        print(f"Sending shipping notification for order {event['orderId']}")
        # Send email...

subscriber = EventSubscriber('email-queue')
subscriber.bind('order.*')  # Subscribe to order.* events
subscriber.subscribe(handle_order_event)
```

---

## 6. Pub/Sub Pattern

**Pattern:** Publishers publish messages to topics. Subscribers subscribe to topics.

```
Publisher 1 ‚îÄ‚îê
Publisher 2 ‚îÄ‚îº‚îÄ‚îÄ‚Üí Topic: "orders" ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚Üí Subscriber 1
Publisher 3 ‚îÄ‚îò                       ‚îú‚îÄ‚îÄ‚Üí Subscriber 2
                                     ‚îî‚îÄ‚îÄ‚Üí Subscriber 3
```

**Key Characteristics:**
- Publishers don't know subscribers
- Subscribers don't know publishers
- Many-to-many communication
- Topic-based routing

### Implementation with Redis Pub/Sub

```javascript
const redis = require('redis');

// ============================================
// PUBLISHER
// ============================================

class Publisher {
    constructor() {
        this.client = redis.createClient({
            host: 'redis',
            port: 6379
        });
    }
    
    async connect() {
        await this.client.connect();
    }
    
    async publish(channel, message) {
        await this.client.publish(channel, JSON.stringify(message));
        console.log(`Published to ${channel}:`, message);
    }
}

// ============================================
// SUBSCRIBER
// ============================================

class Subscriber {
    constructor(name) {
        this.name = name;
        this.client = redis.createClient({
            host: 'redis',
            port: 6379
        });
    }
    
    async connect() {
        await this.client.connect();
    }
    
    async subscribe(channel, handler) {
        await this.client.subscribe(channel, (message) => {
            const event = JSON.parse(message);
            console.log(`[${this.name}] Received from ${channel}:`, event);
            handler(event);
        });
    }
}

// Usage
async function demo() {
    // Create publisher
    const publisher = new Publisher();
    await publisher.connect();
    
    // Create subscribers
    const emailSubscriber = new Subscriber('Email Service');
    await emailSubscriber.connect();
    await emailSubscriber.subscribe('order-events', (event) => {
        if (event.type === 'OrderPlaced') {
            console.log('Sending confirmation email...');
        }
    });
    
    const analyticsSubscriber = new Subscriber('Analytics Service');
    await analyticsSubscriber.connect();
    await analyticsSubscriber.subscribe('order-events', (event) => {
        console.log('Updating analytics dashboard...');
    });
    
    // Publish event (both subscribers will receive it)
    await publisher.publish('order-events', {
        type: 'OrderPlaced',
        orderId: 'order_123',
        total: 109.97
    });
}

demo();
```

---

## 7. Event Storming

**Definition:** Workshop technique for exploring complex business domains through events.

### Event Storming Process

**1. Identify Domain Events**
```
Orange Sticky Notes = Domain Events
- UserRegistered
- OrderPlaced
- PaymentProcessed
- OrderShipped
- OrderDelivered
```

**2. Identify Commands**
```
Blue Sticky Notes = Commands (User Actions)
- RegisterUser
- PlaceOrder
- ProcessPayment
- ShipOrder
```

**3. Identify Aggregates**
```
Yellow Sticky Notes = Aggregates (Entities)
- User
- Order
- Payment
- Shipment
```

**4. Map the Flow**
```
[RegisterUser] ‚Üí UserRegistered
                      ‚Üì
[PlaceOrder] ‚Üí OrderPlaced
                      ‚Üì
[ProcessPayment] ‚Üí PaymentProcessed
                      ‚Üì
[ShipOrder] ‚Üí OrderShipped
                      ‚Üì
              OrderDelivered
```

### Event Storming Example: E-Commerce

```
Timeline:

[User] RegisterUser ‚Üí UserRegistered ‚Üí SendWelcomeEmail
                           ‚Üì
[User] BrowseProducts ‚Üí ProductViewed ‚Üí TrackAnalytics
                           ‚Üì
[User] AddToCart ‚Üí ItemAddedToCart ‚Üí UpdateCartCount
                           ‚Üì
[User] PlaceOrder ‚Üí OrderPlaced ‚Üí ReserveInventory
                           ‚Üì            ‚Üì
                    PaymentProcessed   InventoryReserved
                           ‚Üì            ‚Üì
                    [Warehouse] ShipOrder ‚Üí OrderShipped
                           ‚Üì
                    NotifyCustomer ‚Üí EmailSent
                           ‚Üì
                    [Courier] UpdateTracking ‚Üí TrackingUpdated
                           ‚Üì
                    OrderDelivered ‚Üí RequestFeedback
```

---

## 8. Implementation Example: Real-Time Notification System

Let's build a complete event-driven notification system.

```typescript
// ============================================
// Event Definitions
// ============================================

interface DomainEvent {
    eventId: string;
    eventType: string;
    timestamp: Date;
    data: any;
}

// ============================================
// Event Bus
// ============================================

class EventBus {
    private subscribers: Map<string, Array<(event: DomainEvent) => void>> = new Map();
    
    subscribe(eventType: string, handler: (event: DomainEvent) => void): void {
        if (!this.subscribers.has(eventType)) {
            this.subscribers.set(eventType, []);
        }
        this.subscribers.get(eventType)!.push(handler);
    }
    
    async publish(event: DomainEvent): Promise<void> {
        const handlers = this.subscribers.get(event.eventType) || [];
        
        for (const handler of handlers) {
            try {
                await handler(event);
            } catch (error) {
                console.error(`Error in handler for ${event.eventType}:`, error);
            }
        }
    }
}

// ============================================
// Services
// ============================================

class OrderService {
    constructor(private eventBus: EventBus) {}
    
    async placeOrder(userId: string, items: any[]): Promise<string> {
        const orderId = this.generateId();
        
        // Business logic...
        
        // Publish event
        await this.eventBus.publish({
            eventId: this.generateId(),
            eventType: 'OrderPlaced',
            timestamp: new Date(),
            data: {
                orderId,
                userId,
                items,
                total: this.calculateTotal(items)
            }
        });
        
        return orderId;
    }
    
    private generateId(): string {
        return `order_${Date.now()}_${Math.random()}`;
    }
    
    private calculateTotal(items: any[]): number {
        return items.reduce((sum, item) => sum + item.price * item.quantity, 0);
    }
}

class PaymentService {
    constructor(private eventBus: EventBus) {
        // Subscribe to OrderPlaced events
        this.eventBus.subscribe('OrderPlaced', this.handleOrderPlaced.bind(this));
    }
    
    private async handleOrderPlaced(event: DomainEvent): Promise<void> {
        console.log(`Processing payment for order ${event.data.orderId}`);
        
        // Simulate payment processing
        await this.delay(1000);
        
        // Publish PaymentProcessed event
        await this.eventBus.publish({
            eventId: this.generateId(),
            eventType: 'PaymentProcessed',
            timestamp: new Date(),
            data: {
                orderId: event.data.orderId,
                amount: event.data.total,
                status: 'success'
            }
        });
    }
    
    private delay(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    private generateId(): string {
        return `payment_${Date.now()}_${Math.random()}`;
    }
}

class EmailService {
    constructor(private eventBus: EventBus) {
        this.eventBus.subscribe('OrderPlaced', this.sendOrderConfirmation.bind(this));
        this.eventBus.subscribe('PaymentProcessed', this.sendPaymentReceipt.bind(this));
    }
    
    private async sendOrderConfirmation(event: DomainEvent): Promise<void> {
        console.log(`üìß Sending order confirmation to user ${event.data.userId}`);
        console.log(`   Order ID: ${event.data.orderId}`);
        console.log(`   Total: $${event.data.total}`);
    }
    
    private async sendPaymentReceipt(event: DomainEvent): Promise<void> {
        console.log(`üìß Sending payment receipt for order ${event.data.orderId}`);
        console.log(`   Amount: $${event.data.amount}`);
    }
}

class AnalyticsService {
    constructor(private eventBus: EventBus) {
        this.eventBus.subscribe('OrderPlaced', this.trackOrder.bind(this));
        this.eventBus.subscribe('PaymentProcessed', this.trackPayment.bind(this));
    }
    
    private async trackOrder(event: DomainEvent): Promise<void> {
        console.log(`üìä Analytics: Order placed - $${event.data.total}`);
    }
    
    private async trackPayment(event: DomainEvent): Promise<void> {
        console.log(`üìä Analytics: Payment processed - $${event.data.amount}`);
    }
}

// ============================================
// Application Setup
// ============================================

async function main() {
    const eventBus = new EventBus();
    
    // Initialize services
    const orderService = new OrderService(eventBus);
    const paymentService = new PaymentService(eventBus);
    const emailService = new EmailService(eventBus);
    const analyticsService = new AnalyticsService(eventBus);
    
    // Place an order
    console.log('=== Placing Order ===\n');
    
    await orderService.placeOrder('user_123', [
        { productId: 'prod_1', name: 'Laptop', price: 999, quantity: 1 },
        { productId: 'prod_2', name: 'Mouse', price: 25, quantity: 2 }
    ]);
    
    // Events will be processed asynchronously
    // Output:
    // üìß Sending order confirmation to user user_123
    // üìä Analytics: Order placed - $1049
    // Processing payment for order order_...
    // üìß Sending payment receipt for order order_...
    // üìä Analytics: Payment processed - $1049
}

main();
```

---

## 9. Advantages and Disadvantages

### ‚úÖ Advantages

**1. Loose Coupling**
- Services don't know about each other
- Can add/remove consumers without changing producers

**2. Scalability**
```
High load on Email Service?
‚Üí Add more Email Service instances
‚Üí Other services unaffected
```

**3. Real-Time Processing**
- Events processed as they happen
- Perfect for real-time dashboards, notifications

**4. Audit Trail**
- Every change is an event
- Complete history of what happened

**5. Flexibility**
- Easy to add new features
- Just add new event consumers

### ‚ùå Disadvantages

**1. Complexity**
- Distributed system complexity
- Event ordering challenges
- Debugging is harder

**2. Eventual Consistency**
```
Order placed ‚Üí Event published ‚Üí Email sent
              [Small delay]
User refreshes ‚Üí Order might not be visible yet
```

**3. Event Schema Evolution**
```javascript
// V1 event
{ eventType: 'OrderPlaced', orderId: 1, total: 100 }

// V2 event (added currency field)
{ eventType: 'OrderPlaced', orderId: 2, total: 100, currency: 'USD' }

// Old consumers must handle both versions!
```

**4. Duplicate Events**
- Network issues can cause duplicates
- Must implement idempotency

**5. Testing Challenges**
- Need to test async flows
- Event ordering matters

---

## 10. Real-World Use Cases

### When to Use Event-Driven Architecture

‚úÖ **Real-time systems**
- Live dashboards
- Real-time notifications
- IoT data processing

‚úÖ **Audit requirements**
- Financial systems
- Healthcare records
- Compliance tracking

‚úÖ **Complex workflows**
- E-commerce order processing
- Insurance claim processing
- Supply chain management

‚úÖ **Microservices integration**
- Loose coupling between services
- Async communication

### When NOT to Use

‚ùå **Simple CRUD applications**
‚ùå **Strong consistency required**
‚ùå **Small team without expertise**
‚ùå **Simple sequential workflows**

---

## Chapter 6 Summary

### Key Concepts

1. **Events** = State changes that have already happened
2. **Event Sourcing** = Store events, not current state
3. **CQRS** = Separate read and write models
4. **Event Bus** = Routes events to subscribers
5. **Pub/Sub** = Publishers and subscribers decoupled

### Patterns

- **Event Sourcing**: Complete audit trail, temporal queries
- **CQRS**: Optimized reads and writes
- **Saga**: Distributed transactions with events
- **Event-Driven Microservices**: Async communication

### Technology Stack

- **Message Brokers**: Kafka, RabbitMQ, AWS SNS/SQS
- **Event Stores**: EventStoreDB, custom solutions
- **Stream Processing**: Kafka Streams, Apache Flink

### Interview Tips

**Common Questions:**
1. "Explain Event Sourcing vs traditional storage"
2. "What is CQRS and when to use it?"
3. "How do you handle eventual consistency?"
4. "Kafka vs RabbitMQ - differences?"

**Prepare:**
- Draw event flow diagrams
- Explain eventual consistency trade-offs
- Know Kafka basics (topics, partitions, consumer groups)
- Understand idempotency

### Next Steps

Chapter 7 will cover **Hexagonal Architecture (Ports & Adapters)** - a pattern for isolating business logic from external concerns.