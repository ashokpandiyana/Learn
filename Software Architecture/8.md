# Chapter 8: Clean Architecture

## Table of Contents
1. Introduction to Clean Architecture
2. The Dependency Rule
3. Four Layers of Clean Architecture
4. Entities (Enterprise Business Rules)
5. Use Cases (Application Business Rules)
6. Interface Adapters
7. Frameworks & Drivers
8. Crossing Boundaries
9. Complete Implementation Example
10. Testing Strategy
11. Advantages and Disadvantages

---

## 1. Introduction to Clean Architecture

**Definition:** Clean Architecture, introduced by Robert C. Martin (Uncle Bob), is an architectural pattern that emphasizes separation of concerns through layers, with dependencies pointing inward toward business logic.

**The Goal:** Create systems that are:
- **Independent of frameworks**
- **Testable** without UI, database, or external services
- **Independent of UI** - Can swap UI without changing business logic
- **Independent of database** - Business rules don't know about the database
- **Independent of external agencies** - Business rules don't know about external services

### The Clean Architecture Diagram

```
┌─────────────────────────────────────────────────┐
│        Frameworks & Drivers (Blue)              │
│  ┌───────────────────────────────────────────┐ │
│  │    Interface Adapters (Green)             │ │
│  │  ┌─────────────────────────────────────┐ │ │
│  │  │  Application Business Rules (Yellow)│ │ │
│  │  │  ┌───────────────────────────────┐  │ │ │
│  │  │  │ Enterprise Business Rules (Red)│  │ │ │
│  │  │  │        ENTITIES               │  │ │ │
│  │  │  │                               │  │ │ │
│  │  │  └───────────────────────────────┘  │ │ │
│  │  │         USE CASES                   │ │ │
│  │  └─────────────────────────────────────┘ │ │
│  │    Controllers, Gateways, Presenters     │ │
│  └───────────────────────────────────────────┘ │
│  Web, DB, UI, External Interfaces, Devices    │
└─────────────────────────────────────────────────┘

Dependencies flow INWARD →
```

---

## 2. The Dependency Rule

**The Golden Rule:** Source code dependencies must point only inward, toward higher-level policies.

```
Frameworks & Drivers
        ↓ depends on
Interface Adapters
        ↓ depends on
Use Cases
        ↓ depends on
Entities

❌ NEVER the reverse!
```

**What this means:**
- Inner circles know nothing about outer circles
- Entities don't know about Use Cases
- Use Cases don't know about Controllers
- Nothing in inner circle can mention anything in outer circle

### Example: Dependency Rule Violation

```typescript
// ❌ BAD: Entity depends on framework
import { Request } from 'express';  // Outer layer dependency!

class User {
    constructor(
        public id: string,
        public email: string
    ) {}
    
    // Violates dependency rule - entity knows about HTTP
    static fromRequest(req: Request): User {
        return new User(req.body.id, req.body.email);
    }
}
```

```typescript
// ✅ GOOD: Entity is pure business logic
class User {
    constructor(
        public id: string,
        public email: string,
        public passwordHash: string
    ) {}
    
    // Domain logic only
    isEmailValid(): boolean {
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(this.email);
    }
    
    changeEmail(newEmail: string): void {
        if (!this.isEmailValid()) {
            throw new Error('Invalid email format');
        }
        this.email = newEmail;
    }
}
```

---

## 3. Four Layers of Clean Architecture

### Layer 1: Entities (Core - Red Circle)
- **What:** Enterprise-wide business rules
- **Contains:** Domain models, business objects
- **No dependencies:** Most stable, least likely to change

### Layer 2: Use Cases (Yellow Circle)
- **What:** Application-specific business rules
- **Contains:** Application services, interactors
- **Depends on:** Entities only

### Layer 3: Interface Adapters (Green Circle)
- **What:** Convert data between use cases and external formats
- **Contains:** Controllers, presenters, gateways
- **Depends on:** Use Cases and Entities

### Layer 4: Frameworks & Drivers (Blue Circle)
- **What:** Frameworks, tools, and glue code
- **Contains:** Web frameworks, databases, UI
- **Depends on:** Interface Adapters

---

## 4. Entities (Enterprise Business Rules)

**Definition:** Objects that encapsulate enterprise-wide Critical Business Rules.

### Characteristics
- Pure business logic
- No framework dependencies
- No infrastructure knowledge
- Can be used by multiple applications

### Implementation Example

```java
// Entity: Order
public class Order {
    private final String id;
    private final String customerId;
    private final List<OrderItem> items;
    private final Money total;
    private OrderStatus status;
    private final LocalDateTime createdAt;
    private LocalDateTime completedAt;
    
    public Order(String id, String customerId, List<OrderItem> items) {
        this.id = id;
        this.customerId = customerId;
        this.items = new ArrayList<>(items);
        this.total = calculateTotal(items);
        this.status = OrderStatus.PENDING;
        this.createdAt = LocalDateTime.now();
        
        validateOrder();
    }
    
    // Business Rule: Order must have items
    private void validateOrder() {
        if (items.isEmpty()) {
            throw new InvalidOrderException("Order must contain at least one item");
        }
        
        if (total.isNegative()) {
            throw new InvalidOrderException("Order total cannot be negative");
        }
    }
    
    // Business Rule: Calculate total
    private Money calculateTotal(List<OrderItem> items) {
        return items.stream()
            .map(OrderItem::getSubtotal)
            .reduce(Money.ZERO, Money::add);
    }
    
    // Business Rule: Can only cancel pending orders
    public void cancel() {
        if (status != OrderStatus.PENDING) {
            throw new IllegalStateException(
                "Cannot cancel order with status: " + status
            );
        }
        this.status = OrderStatus.CANCELLED;
    }
    
    // Business Rule: Complete order
    public void complete() {
        if (status != OrderStatus.PAID) {
            throw new IllegalStateException(
                "Can only complete paid orders"
            );
        }
        this.status = OrderStatus.COMPLETED;
        this.completedAt = LocalDateTime.now();
    }
    
    // Business Rule: Apply discount
    public Money applyDiscount(DiscountPolicy policy) {
        return policy.apply(this.total);
    }
    
    // Getters (no setters - immutability)
    public String getId() { return id; }
    public String getCustomerId() { return customerId; }
    public List<OrderItem> getItems() { return new ArrayList<>(items); }
    public Money getTotal() { return total; }
    public OrderStatus getStatus() { return status; }
}

// Value Object: Money
public class Money {
    public static final Money ZERO = new Money(0);
    
    private final BigDecimal amount;
    
    public Money(double amount) {
        this.amount = BigDecimal.valueOf(amount);
    }
    
    public Money add(Money other) {
        return new Money(this.amount.add(other.amount).doubleValue());
    }
    
    public boolean isNegative() {
        return amount.compareTo(BigDecimal.ZERO) < 0;
    }
}

// Value Object: OrderItem
public class OrderItem {
    private final String productId;
    private final String productName;
    private final int quantity;
    private final Money price;
    
    public OrderItem(String productId, String productName, int quantity, Money price) {
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be positive");
        }
        
        this.productId = productId;
        this.productName = productName;
        this.quantity = quantity;
        this.price = price;
    }
    
    public Money getSubtotal() {
        return new Money(price.getAmount().doubleValue() * quantity);
    }
    
    // Getters...
}

// Enum: OrderStatus
public enum OrderStatus {
    PENDING,
    PAID,
    CANCELLED,
    COMPLETED
}
```

**Key Points:**
- No imports from outer layers
- Pure Java/language constructs only
- Rich domain logic
- Validates its own invariants

---

## 5. Use Cases (Application Business Rules)

**Definition:** Application-specific business rules. Orchestrate the flow of data to and from entities.

### Characteristics
- Coordinate entity interactions
- Contain application-specific business rules
- Do NOT contain framework-specific code
- Depend only on entities

### Implementation Example

```typescript
// Use Case: Create Order
export class CreateOrderUseCase {
    constructor(
        private orderRepository: OrderRepository,
        private productRepository: ProductRepository,
        private paymentGateway: PaymentGateway,
        private eventPublisher: EventPublisher
    ) {}
    
    async execute(request: CreateOrderRequest): Promise<CreateOrderResponse> {
        // 1. Validate request
        this.validateRequest(request);
        
        // 2. Load products
        const products = await this.loadProducts(request.items);
        
        // 3. Create order entity (business logic in entity)
        const orderItems = this.createOrderItems(request.items, products);
        const order = new Order(
            generateId(),
            request.customerId,
            orderItems
        );
        
        // 4. Process payment
        const paymentResult = await this.paymentGateway.processPayment({
            amount: order.getTotal(),
            customerId: request.customerId,
            paymentMethod: request.paymentMethod
        });
        
        if (!paymentResult.success) {
            throw new PaymentFailedException(paymentResult.errorMessage);
        }
        
        // 5. Save order
        await this.orderRepository.save(order);
        
        // 6. Publish event
        await this.eventPublisher.publish(new OrderCreatedEvent({
            orderId: order.getId(),
            customerId: order.getCustomerId(),
            total: order.getTotal(),
            timestamp: new Date()
        }));
        
        // 7. Return response
        return this.buildResponse(order, paymentResult);
    }
    
    private validateRequest(request: CreateOrderRequest): void {
        if (!request.customerId) {
            throw new ValidationException('Customer ID is required');
        }
        
        if (!request.items || request.items.length === 0) {
            throw new ValidationException('Order must contain items');
        }
        
        if (!request.paymentMethod) {
            throw new ValidationException('Payment method is required');
        }
    }
    
    private async loadProducts(items: CreateOrderItem[]): Promise<Map<string, Product>> {
        const productIds = items.map(item => item.productId);
        const products = await this.productRepository.findByIds(productIds);
        
        // Verify all products exist
        if (products.length !== productIds.length) {
            throw new ProductNotFoundException('Some products not found');
        }
        
        const productMap = new Map<string, Product>();
        products.forEach(p => productMap.set(p.getId(), p));
        return productMap;
    }
    
    private createOrderItems(
        requestItems: CreateOrderItem[],
        products: Map<string, Product>
    ): OrderItem[] {
        return requestItems.map(item => {
            const product = products.get(item.productId)!;
            return new OrderItem(
                product.getId(),
                product.getName(),
                item.quantity,
                product.getPrice()
            );
        });
    }
    
    private buildResponse(
        order: Order,
        paymentResult: PaymentResult
    ): CreateOrderResponse {
        return {
            orderId: order.getId(),
            status: order.getStatus(),
            total: order.getTotal(),
            paymentTransactionId: paymentResult.transactionId,
            createdAt: order.getCreatedAt()
        };
    }
}

// Request/Response DTOs (Data Transfer Objects)
export interface CreateOrderRequest {
    customerId: string;
    items: CreateOrderItem[];
    paymentMethod: string;
}

export interface CreateOrderItem {
    productId: string;
    quantity: number;
}

export interface CreateOrderResponse {
    orderId: string;
    status: string;
    total: Money;
    paymentTransactionId: string;
    createdAt: Date;
}

// Interfaces (Ports) - Defined in Use Case layer
export interface OrderRepository {
    save(order: Order): Promise<void>;
    findById(orderId: string): Promise<Order | null>;
}

export interface ProductRepository {
    findByIds(productIds: string[]): Promise<Product[]>;
}

export interface PaymentGateway {
    processPayment(request: PaymentRequest): Promise<PaymentResult>;
}

export interface EventPublisher {
    publish(event: DomainEvent): Promise<void>;
}
```

**Key Points:**
- Orchestrates business logic
- Defines interfaces (ports) for dependencies
- No framework dependencies
- Testable with mock implementations

---

## 6. Interface Adapters

**Definition:** Convert data from the format most convenient for use cases and entities to the format most convenient for external agencies.

### Types of Adapters

**1. Controllers** - Convert HTTP requests to use case input
**2. Presenters** - Format use case output for display
**3. Gateways** - Implement repository interfaces
**4. View Models** - Data structures for UI

### Implementation Example

```python
# ============================================
# CONTROLLER (Input Adapter)
# ============================================

from flask import Flask, request, jsonify
from typing import Dict, Any

class OrderController:
    """Converts HTTP requests to use case requests"""
    
    def __init__(self, create_order_use_case: CreateOrderUseCase):
        self.create_order_use_case = create_order_use_case
    
    def create_order(self) -> tuple[Dict[str, Any], int]:
        """HTTP endpoint handler"""
        try:
            # 1. Extract data from HTTP request
            data = request.get_json()
            
            # 2. Validate HTTP-specific concerns
            if not data:
                return {'error': 'Request body required'}, 400
            
            # 3. Convert to use case request
            use_case_request = CreateOrderRequest(
                customer_id=data.get('customerId'),
                items=[
                    CreateOrderItem(
                        product_id=item['productId'],
                        quantity=item['quantity']
                    )
                    for item in data.get('items', [])
                ],
                payment_method=data.get('paymentMethod')
            )
            
            # 4. Execute use case
            response = self.create_order_use_case.execute(use_case_request)
            
            # 5. Convert to HTTP response
            return self._to_http_response(response), 201
            
        except ValidationException as e:
            return {'error': str(e)}, 400
        except PaymentFailedException as e:
            return {'error': 'Payment failed', 'details': str(e)}, 402
        except Exception as e:
            # Log error
            return {'error': 'Internal server error'}, 500
    
    def _to_http_response(self, response: CreateOrderResponse) -> Dict[str, Any]:
        """Convert use case response to HTTP JSON"""
        return {
            'orderId': response.order_id,
            'status': response.status,
            'total': response.total.amount,
            'paymentTransactionId': response.payment_transaction_id,
            'createdAt': response.created_at.isoformat()
        }

# ============================================
# PRESENTER (Output Adapter)
# ============================================

class OrderPresenter:
    """Formats data for presentation"""
    
    def present_order(self, order: Order) -> OrderViewModel:
        """Convert domain entity to view model"""
        return OrderViewModel(
            id=order.id,
            customer_id=order.customer_id,
            items=self._present_items(order.items),
            total=f"${order.total.amount:.2f}",  # Format for display
            status=self._format_status(order.status),
            created_at=order.created_at.strftime('%B %d, %Y at %I:%M %p')
        )
    
    def _present_items(self, items: list[OrderItem]) -> list[OrderItemViewModel]:
        return [
            OrderItemViewModel(
                product_name=item.product_name,
                quantity=item.quantity,
                price=f"${item.price.amount:.2f}",
                subtotal=f"${item.get_subtotal().amount:.2f}"
            )
            for item in items
        ]
    
    def _format_status(self, status: OrderStatus) -> str:
        """Human-readable status"""
        status_map = {
            OrderStatus.PENDING: 'Pending Payment',
            OrderStatus.PAID: 'Paid',
            OrderStatus.CANCELLED: 'Cancelled',
            OrderStatus.COMPLETED: 'Completed'
        }
        return status_map.get(status, 'Unknown')

# View Models (for UI)
class OrderViewModel:
    def __init__(self, id, customer_id, items, total, status, created_at):
        self.id = id
        self.customer_id = customer_id
        self.items = items
        self.total = total  # Already formatted: "$123.45"
        self.status = status  # Already formatted: "Pending Payment"
        self.created_at = created_at  # Already formatted: "January 15, 2024 at 3:30 PM"

class OrderItemViewModel:
    def __init__(self, product_name, quantity, price, subtotal):
        self.product_name = product_name
        self.quantity = quantity
        self.price = price
        self.subtotal = subtotal

# ============================================
# GATEWAY (Repository Implementation)
# ============================================

import psycopg2
from typing import Optional

class PostgresOrderRepository(OrderRepository):
    """Database adapter implementing repository interface"""
    
    def __init__(self, connection_string: str):
        self.conn = psycopg2.connect(connection_string)
    
    def save(self, order: Order) -> None:
        """Persist order to database"""
        cursor = self.conn.cursor()
        
        # Save order
        cursor.execute("""
            INSERT INTO orders (id, customer_id, total, status, created_at)
            VALUES (%s, %s, %s, %s, %s)
        """, (
            order.id,
            order.customer_id,
            order.total.amount,
            order.status.value,
            order.created_at
        ))
        
        # Save order items
        for item in order.items:
            cursor.execute("""
                INSERT INTO order_items 
                (order_id, product_id, product_name, quantity, price)
                VALUES (%s, %s, %s, %s, %s)
            """, (
                order.id,
                item.product_id,
                item.product_name,
                item.quantity,
                item.price.amount
            ))
        
        self.conn.commit()
    
    def find_by_id(self, order_id: str) -> Optional[Order]:
        """Retrieve order from database"""
        cursor = self.conn.cursor()
        
        # Get order
        cursor.execute("""
            SELECT id, customer_id, total, status, created_at
            FROM orders WHERE id = %s
        """, (order_id,))
        
        row = cursor.fetchone()
        if not row:
            return None
        
        # Get order items
        cursor.execute("""
            SELECT product_id, product_name, quantity, price
            FROM order_items WHERE order_id = %s
        """, (order_id,))
        
        item_rows = cursor.fetchall()
        
        # Reconstruct domain entity
        items = [
            OrderItem(
                product_id=item_row[0],
                product_name=item_row[1],
                quantity=item_row[2],
                price=Money(item_row[3])
            )
            for item_row in item_rows
        ]
        
        return Order(
            id=row[0],
            customer_id=row[1],
            items=items
        )
```

---

## 7. Frameworks & Drivers

**Definition:** Outermost layer containing frameworks and tools. This is where all the details go.

### Components
- Web frameworks (Express, Flask, Spring)
- Database drivers (PostgreSQL, MongoDB)
- UI frameworks (React, Angular)
- External services (AWS SDK, Stripe SDK)

### Example: Application Composition

```typescript
// ============================================
// Main.ts - Composition Root
// ============================================

import express from 'express';
import { Pool } from 'pg';

// Frameworks & Drivers Layer
const app = express();
const dbPool = new Pool({
    host: 'localhost',
    database: 'orders_db',
    user: 'postgres',
    password: 'password'
});

// Create Adapters (Interface Adapters Layer)
const orderRepository = new PostgresOrderRepository(dbPool);
const productRepository = new PostgresProductRepository(dbPool);
const paymentGateway = new StripePaymentGateway(process.env.STRIPE_KEY!);
const eventPublisher = new KafkaEventPublisher('kafka:9092');

// Create Use Cases (Application Business Rules)
const createOrderUseCase = new CreateOrderUseCase(
    orderRepository,
    productRepository,
    paymentGateway,
    eventPublisher
);

// Create Controllers (Interface Adapters)
const orderController = new OrderController(createOrderUseCase);

// Setup Routes (Frameworks & Drivers)
app.use(express.json());

app.post('/orders', (req, res) => {
    orderController.createOrder(req, res);
});

app.get('/orders/:id', (req, res) => {
    orderController.getOrder(req, res);
});

// Start Server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});

// ============================================
// Configuration for different environments
// ============================================

function createProductionDependencies() {
    return {
        orderRepository: new PostgresOrderRepository(dbPool),
        paymentGateway: new StripePaymentGateway(process.env.STRIPE_KEY!)
    };
}

function createDevelopmentDependencies() {
    return {
        orderRepository: new InMemoryOrderRepository(),
        paymentGateway: new MockPaymentGateway()
    };
}

function createTestDependencies() {
    return {
        orderRepository: new InMemoryOrderRepository(),
        paymentGateway: new MockPaymentGateway()
    };
}
```

---

## 8. Crossing Boundaries

**Problem:** How do we pass data across boundaries while maintaining the dependency rule?

**Solution:** Use simple data structures (DTOs, Request/Response models).

### Boundary Crossing Example

```java
// ============================================
// WRONG: Passing entities across boundaries
// ============================================

// Controller (Adapter layer)
@RestController
public class OrderController {
    @PostMapping("/orders")
    public ResponseEntity<Order> createOrder(@RequestBody Order order) {
        // ❌ BAD: Controller receives and returns entity
        // Entity (inner layer) exposed to outer layer
        Order created = orderService.create(order);
        return ResponseEntity.ok(created);
    }
}

// ============================================
// CORRECT: Using DTOs for boundary crossing
// ============================================

// Request DTO (defined in Use Case layer)
public class CreateOrderRequest {
    private String customerId;
    private List<OrderItemDTO> items;
    private String paymentMethod;
    
    // Getters and setters
}

public class OrderItemDTO {
    private String productId;
    private int quantity;
    
    // Getters and setters
}

// Response DTO (defined in Use Case layer)
public class CreateOrderResponse {
    private String orderId;
    private String status;
    private double total;
    private String transactionId;
    
    // Getters and setters
}

// Controller (Adapter layer)
@RestController
public class OrderController {
    private final CreateOrderUseCase createOrderUseCase;
    
    @PostMapping("/orders")
    public ResponseEntity<CreateOrderResponse> createOrder(
        @RequestBody CreateOrderRequest request
    ) {
        // ✅ GOOD: DTOs cross the boundary
        CreateOrderResponse response = createOrderUseCase.execute(request);
        return ResponseEntity.ok(response);
    }
}

// Use Case (Application Business Rules)
public class CreateOrderUseCase {
    private final OrderRepository orderRepository;
    
    public CreateOrderResponse execute(CreateOrderRequest request) {
        // Convert DTO to Entity (inner layer)
        Order order = this.buildOrder(request);
        
        // Execute business logic
        orderRepository.save(order);
        
        // Convert Entity back to DTO
        return new CreateOrderResponse(
            order.getId(),
            order.getStatus().toString(),
            order.getTotal().getAmount(),
            order.getPaymentTransactionId()
        );
    }
    
    private Order buildOrder(CreateOrderRequest request) {
        // Conversion logic
        List<OrderItem> items = request.getItems().stream()
            .map(dto -> new OrderItem(
                dto.getProductId(),
                // ... fetch product details
            ))
            .collect(Collectors.toList());
        
        return new Order(generateId(), request.getCustomerId(), items);
    }
}
```

### The Dependency Inversion Trick

**Problem:** Use case needs to call database, but can't depend on it.

**Solution:** Define interface in use case layer, implement in adapter layer.

```typescript
// ============================================
// Use Case Layer (Inner)
// ============================================

// Interface defined in use case layer
export interface OrderRepository {
    save(order: Order): Promise<void>;
    findById(orderId: string): Promise<Order | null>;
}

// Use case depends on interface
export class CreateOrderUseCase {
    constructor(private orderRepository: OrderRepository) {}
    
    async execute(request: CreateOrderRequest): Promise<CreateOrderResponse> {
        // Use the interface
        await this.orderRepository.save(order);
    }
}

// ============================================
// Adapter Layer (Outer)
// ============================================

// Implementation in adapter layer
export class PostgresOrderRepository implements OrderRepository {
    constructor(private pool: Pool) {}
    
    async save(order: Order): Promise<void> {
        // PostgreSQL-specific code
        await this.pool.query(
            'INSERT INTO orders ...',
            [order.id, order.customerId, ...]
        );
    }
    
    async findById(orderId: string): Promise<Order | null> {
        // PostgreSQL-specific code
        const result = await this.pool.query(
            'SELECT * FROM orders WHERE id = $1',
            [orderId]
        );
        return this.mapToOrder(result.rows[0]);
    }
}

// ============================================
// Dependency flows inward!
// ============================================

// PostgresOrderRepository (outer) implements OrderRepository (inner)
// Use case (inner) depends on OrderRepository interface (inner)
// PostgresOrderRepository (outer) depends on both interface and use case
// Dependency points INWARD ✓
```

---

## 9. Complete Implementation Example

Let's build a complete User Registration system with Clean Architecture.

```typescript
// ============================================
// LAYER 1: ENTITIES (Enterprise Business Rules)
// ============================================

// Domain Entity
export class User {
    private constructor(
        private readonly id: string,
        private email: string,
        private readonly passwordHash: string,
        private emailVerified: boolean,
        private readonly createdAt: Date,
        private verifiedAt?: Date
    ) {}
    
    // Factory method
    static create(id: string, email: string, passwordHash: string): User {
        return new User(
            id,
            email.toLowerCase(),
            passwordHash,
            false,
            new Date()
        );
    }
    
    // Business rules
    verifyEmail(): void {
        if (this.emailVerified) {
            throw new Error('Email already verified');
        }
        this.emailVerified = true;
        this.verifiedAt = new Date();
    }
    
    changeEmail(newEmail: string): void {
        if (!this.isValidEmail(newEmail)) {
            throw new Error('Invalid email format');
        }
        this.email = newEmail.toLowerCase();
        this.emailVerified = false; // Require re-verification
        this.verifiedAt = undefined;
    }
    
    private isValidEmail(email: string): boolean {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
    
    // Getters
    getId(): string { return this.id; }
    getEmail(): string { return this.email; }
    getPasswordHash(): string { return this.passwordHash; }
    isEmailVerified(): boolean { return this.emailVerified; }
    getCreatedAt(): Date { return this.createdAt; }
}

// Value Object
export class Email {
    private constructor(private readonly value: string) {}
    
    static create(email: string): Email {
        const normalized = email.trim().toLowerCase();
        
        if (!this.isValid(normalized)) {
            throw new Error('Invalid email format');
        }
        
        return new Email(normalized);
    }
    
    private static isValid(email: string): boolean {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
    
    getValue(): string {
        return this.value;
    }
    
    equals(other: Email): boolean {
        return this.value === other.value;
    }
}

// ============================================
// LAYER 2: USE CASES (Application Business Rules)
// ============================================

// Interfaces (Ports) - Defined in use case layer
export interface UserRepository {
    save(user: User): Promise<void>;
    findByEmail(email: string): Promise<User | null>;
    findById(userId: string): Promise<User | null>;
}

export interface PasswordHasher {
    hash(password: string): Promise<string>;
    verify(password: string, hash: string): Promise<boolean>;
}

export interface EmailService {
    sendVerificationEmail(email: string, token: string): Promise<void>;
}

export interface TokenGenerator {
    generate(): string;
}

// Request/Response DTOs
export interface RegisterUserRequest {
    email: string;
    password: string;
}

export interface RegisterUserResponse {
    userId: string;
    email: string;
    message: string;
}

// Use Case: Register User
export class RegisterUserUseCase {
    constructor(
        private userRepository: UserRepository,
        private passwordHasher: PasswordHasher,
        private emailService: EmailService,
        private tokenGenerator: TokenGenerator
    ) {}
    
    async execute(request: RegisterUserRequest): Promise<RegisterUserResponse> {
        // 1. Validate input
        this.validateRequest(request);
        
        // 2. Check if user exists
        const existingUser = await this.userRepository.findByEmail(request.email);
        if (existingUser) {
            throw new Error('Email already registered');
        }
        
        // 3. Hash password
        const passwordHash = await this.passwordHasher.hash(request.password);
        
        // 4. Create user entity
        const user = User.create(
            this.generateUserId(),
            request.email,
            passwordHash
        );
        
        // 5. Save user
        await this.userRepository.save(user);
        
        // 6. Send verification email
        const verificationToken = this.tokenGenerator.generate();
        await this.emailService.sendVerificationEmail(
            user.getEmail(),
            verificationToken
        );
        
        // 7. Return response
        return {
            userId: user.getId(),
            email: user.getEmail(),
            message: 'User registered successfully. Please check your email to verify.'
        };
    }
    
    private validateRequest(request: RegisterUserRequest): void {
        if (!request.email || !request.password) {
            throw new Error('Email and password are required');
        }
        
        if (request.password.length < 8) {
            throw new Error('Password must be at least 8 characters');
        }
    }
    
    private generateUserId(): string {
        return `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}

// Use Case: Verify Email
export interface VerifyEmailRequest {
    userId: string;
    token: string;
}

export class VerifyEmailUseCase {
    constructor(
        private userRepository: UserRepository,
        private tokenValidator: TokenValidator
    ) {}
    
    async execute(request: VerifyEmailRequest): Promise<void> {
        // 1. Validate token
        if (!this.tokenValidator.isValid(request.token, request.userId)) {
            throw new Error('Invalid or expired verification token');
        }
        
        // 2. Get user
        const user = await this.userRepository.findById(request.userId);
        if (!user) {
            throw new Error('User not found');
        }
        
        // 3. Verify email (domain logic in entity)
        user.verifyEmail();
        
        // 4. Save user
        await this.userRepository.save(user);
    }
}

// ============================================
// LAYER 3: INTERFACE ADAPTERS
// ============================================

// Controller (Input Adapter)
import { Request, Response } from 'express';

export class UserController {
    constructor(
        private registerUserUseCase: RegisterUserUseCase,
        private verifyEmailUseCase: VerifyEmailUseCase
    ) {}
    
    async register(req: Request, res: Response): Promise<void> {
        try {
            const request: RegisterUserRequest = {
                email: req.body.email,
                password: req.body.password
            };
            
            const response = await this.registerUserUseCase.execute(request);
            
            res.status(201).json({
                success: true,
                data: response
            });
            
        } catch (error: any) {
            res.status(400).json({
                success: false,
                error: error.message
            });
        }
    }
    
    async verifyEmail(req: Request, res: Response): Promise<void> {
        try {
            const request: VerifyEmailRequest = {
                userId: req.params.userId,
                token: req.query.token as string
            };
            
            await this.verifyEmailUseCase.execute(request);
            
            res.status(200).json({
                success: true,
                message: 'Email verified successfully'
            });
            
        } catch (error: any) {
            res.status(400).json({
                success: false,
                error: error.message
            });
        }
    }
}

// Repository Implementation (Output Adapter)
import { Pool } from 'pg';

export class PostgresUserRepository implements UserRepository {
    constructor(private pool: Pool) {}
    
    async save(user: User): Promise<void> {
        await this.pool.query(`
            INSERT INTO users (id, email, password_hash, email_verified, created_at, verified_at)
            VALUES ($1, $2, $3, $4, $5, $6)
            ON CONFLICT (id) DO UPDATE SET
                email = $2,
                email_verified = $4,
                verified_at = $6
        `, [
            user.getId(),
            user.getEmail(),
            user.getPasswordHash(),
            user.isEmailVerified(),
            user.getCreatedAt(),
            user.isEmailVerified() ? new Date() : null
        ]);
    }
    
    async findByEmail(email: string): Promise<User | null> {
        const result = await this.pool.query(
            'SELECT * FROM users WHERE email = $1',
            [email.toLowerCase()]
        );
        
        if (result.rows.length === 0) {
            return null;
        }
        
        return this.mapToUser(result.rows[0]);
    }
    
    async findById(userId: string): Promise<User | null> {
        const result = await this.pool.query(
            'SELECT * FROM users WHERE id = $1',
            [userId]
        );
        
        if (result.rows.length === 0) {
            return null;
        }
        
        return this.mapToUser(result.rows[0]);
    }
    
    private mapToUser(row: any): User {
        return User.create(
            row.id,
            row.email,
            row.password_hash
        );
    }
}

// Password Hasher Implementation
import bcrypt from 'bcrypt';

export class BcryptPasswordHasher implements PasswordHasher {
    async hash(password: string): Promise<string> {
        return await bcrypt.hash(password, 10);
    }
    
    async verify(password: string, hash: string): Promise<boolean> {
        return await bcrypt.compare(password, hash);
    }
}

// Email Service Implementation
import nodemailer from 'nodemailer';

export class NodemailerEmailService implements EmailService {
    private transporter: nodemailer.Transporter;
    
    constructor() {
        this.transporter = nodemailer.createTransport({
            host: 'smtp.gmail.com',
            port: 587,
            auth: {
                user: process.env.EMAIL_USER,
                pass: process.env.EMAIL_PASSWORD
            }
        });
    }
    
    async sendVerificationEmail(email: string, token: string): Promise<void> {
        await this.transporter.sendMail({
            from: 'noreply@example.com',
            to: email,
            subject: 'Verify your email',
            html: `
                <h1>Email Verification</h1>
                <p>Click the link below to verify your email:</p>
                <a href="https://example.com/verify?token=${token}">Verify Email</a>
            `
        });
    }
}

// ============================================
// LAYER 4: FRAMEWORKS & DRIVERS
// ============================================

// Main application setup
import express from 'express';
import { Pool } from 'pg';

const app = express();
app.use(express.json());

// Create database pool
const pool = new Pool({
    host: 'localhost',
    database: 'users_db',
    user: 'postgres',
    password: 'password'
});

// Wire up dependencies
const userRepository = new PostgresUserRepository(pool);
const passwordHasher = new BcryptPasswordHasher();
const emailService = new NodemailerEmailService();
const tokenGenerator = new UuidTokenGenerator();

const registerUserUseCase = new RegisterUserUseCase(
    userRepository,
    passwordHasher,
    emailService,
    tokenGenerator
);

const verifyEmailUseCase = new VerifyEmailUseCase(
    userRepository,
    tokenGenerator
);

const userController = new UserController(
    registerUserUseCase,
    verifyEmailUseCase
);

// Setup routes
app.post('/users/register', (req, res) => userController.register(req, res));
app.get('/users/:userId/verify', (req, res) => userController.verifyEmail(req, res));

// Start server
app.listen(3000, () => {
    console.log('Server running on port 3000');
});
```

---

## 10. Testing Strategy

Clean Architecture makes testing easy at every level.

### Unit Testing Entities

```typescript
describe('User Entity', () => {
    it('should create a user with unverified email', () => {
        const user = User.create('user_123', 'test@example.com', 'hashedpassword');
        
        expect(user.getId()).toBe('user_123');
        expect(user.getEmail()).toBe('test@example.com');
        expect(user.isEmailVerified()).toBe(false);
    });
    
    it('should verify email', () => {
        const user = User.create('user_123', 'test@example.com', 'hashedpassword');
        
        user.verifyEmail();
        
        expect(user.isEmailVerified()).toBe(true);
    });
    
    it('should not allow double verification', () => {
        const user = User.create('user_123', 'test@example.com', 'hashedpassword');
        user.verifyEmail();
        
        expect(() => user.verifyEmail()).toThrow('Email already verified');
    });
    
    it('should normalize email to lowercase', () => {
        const user = User.create('user_123', 'TEST@EXAMPLE.COM', 'hashedpassword');
        
        expect(user.getEmail()).toBe('test@example.com');
    });
});
```

### Unit Testing Use Cases

```typescript
describe('RegisterUserUseCase', () => {
    let useCase: RegisterUserUseCase;
    let mockUserRepository: jest.Mocked<UserRepository>;
    let mockPasswordHasher: jest.Mocked<PasswordHasher>;
    let mockEmailService: jest.Mocked<EmailService>;
    let mockTokenGenerator: jest.Mocked<TokenGenerator>;
    
    beforeEach(() => {
        mockUserRepository = {
            save: jest.fn(),
            findByEmail: jest.fn(),
            findById: jest.fn()
        };
        
        mockPasswordHasher = {
            hash: jest.fn(),
            verify: jest.fn()
        };
        
        mockEmailService = {
            sendVerificationEmail: jest.fn()
        };
        
        mockTokenGenerator = {
            generate: jest.fn()
        };
        
        useCase = new RegisterUserUseCase(
            mockUserRepository,
            mockPasswordHasher,
            mockEmailService,
            mockTokenGenerator
        );
    });
    
    it('should register a new user', async () => {
        // Arrange
        mockUserRepository.findByEmail.mockResolvedValue(null);
        mockPasswordHasher.hash.mockResolvedValue('hashedpassword');
        mockTokenGenerator.generate.mockReturnValue('token123');
        
        const request: RegisterUserRequest = {
            email: 'test@example.com',
            password: 'password123'
        };
        
        // Act
        const response = await useCase.execute(request);
        
        // Assert
        expect(response.email).toBe('test@example.com');
        expect(mockUserRepository.save).toHaveBeenCalledTimes(1);
        expect(mockEmailService.sendVerificationEmail).toHaveBeenCalledWith(
            'test@example.com',
            'token123'
        );
    });
    
    it('should not register duplicate email', async () => {
        // Arrange
        const existingUser = User.create('existing', 'test@example.com', 'hash');
        mockUserRepository.findByEmail.mockResolvedValue(existingUser);
        
        const request: RegisterUserRequest = {
            email: 'test@example.com',
            password: 'password123'
        };
        
        // Act & Assert
        await expect(useCase.execute(request)).rejects.toThrow('Email already registered');
        expect(mockUserRepository.save).not.toHaveBeenCalled();
    });
    
    it('should validate password length', async () => {
        const request: RegisterUserRequest = {
            email: 'test@example.com',
            password: 'short'
        };
        
        await expect(useCase.execute(request)).rejects.toThrow(
            'Password must be at least 8 characters'
        );
    });
});
```

### Integration Testing

```typescript
describe('User Registration Integration', () => {
    let app: express.Application;
    let userRepository: InMemoryUserRepository;
    
    beforeEach(() => {
        // Use in-memory implementations for testing
        userRepository = new InMemoryUserRepository();
        const passwordHasher = new BcryptPasswordHasher();
        const emailService = new MockEmailService();
        const tokenGenerator = new UuidTokenGenerator();
        
        const registerUseCase = new RegisterUserUseCase(
            userRepository,
            passwordHasher,
            emailService,
            tokenGenerator
        );
        
        const controller = new UserController(registerUseCase, null);
        
        app = express();
        app.use(express.json());
        app.post('/users/register', (req, res) => controller.register(req, res));
    });
    
    it('should register user via API', async () => {
        const response = await request(app)
            .post('/users/register')
            .send({
                email: 'test@example.com',
                password: 'password123'
            })
            .expect(201);
        
        expect(response.body.success).toBe(true);
        expect(response.body.data.email).toBe('test@example.com');
        
        // Verify user was saved
        const savedUser = await userRepository.findByEmail('test@example.com');
        expect(savedUser).not.toBeNull();
    });
});
```

---

## 11. Advantages and Disadvantages

### ✅ Advantages

**1. Independent of Frameworks**
```typescript
// Can switch from Express to Fastify without changing use cases
// Old: Express
app.post('/users', controller.register);

// New: Fastify
fastify.post('/users', controller.register);
// Use case remains unchanged!
```

**2. Testable**
- Test entities in isolation
- Test use cases with mocks
- No need for database in unit tests

**3. Independent of UI**
```typescript
// Same use case used by REST, GraphQL, and CLI
const useCase = new RegisterUserUseCase(...);

// REST
app.post('/users', () => useCase.execute(...));

// GraphQL
resolvers.Mutation.registerUser = () => useCase.execute(...);

// CLI
program.command('register').action(() => useCase.execute(...));
```

**4. Independent of Database**
```typescript
// Development: In-memory
const repo = new InMemoryUserRepository();

// Production: PostgreSQL
const repo = new PostgresUserRepository(pool);

// Testing: Mock
const repo = new MockUserRepository();

// Use case works with all!
const useCase = new RegisterUserUseCase(repo, ...);
```

**5. Business Rules are Protected**
- Core logic isolated from external changes
- Changes in UI don't affect business logic
- Changes in database don't affect business logic

### ❌ Disadvantages

**1. Complexity**
- More files and layers
- Steeper learning curve
- Can feel like over-engineering

**2. Boilerplate**
```typescript
// Need to define:
- Entity: User
- Repository interface: UserRepository
- Repository impl: PostgresUserRepository
- Use case: RegisterUserUseCase
- Request DTO: RegisterUserRequest
- Response DTO: RegisterUserResponse
- Controller: UserController

// Just to register a user!
```

**3. Indirection**
- More hops between layers
- Harder to trace flow
- Need to understand architecture

**4. Not Always Necessary**
- Overkill for simple CRUD
- Prototypes don't need this
- Small projects suffer from overhead

---

## Chapter 8 Summary

### Key Concepts

1. **The Dependency Rule** - Dependencies point inward
2. **Four Layers**:
   - Entities (Enterprise Business Rules)
   - Use Cases (Application Business Rules)
   - Interface Adapters (Controllers, Presenters, Gateways)
   - Frameworks & Drivers (External tools)
3. **Independence** - Framework, UI, Database, and External agency independence

### Architecture Principles

- Business logic in center
- Dependencies flow inward
- Interfaces defined by inner layers
- Implementations in outer layers

### When to Use

✅ **Long-lived applications**
✅ **Complex business rules**
✅ **Multiple interfaces (web, mobile, API)**
✅ **High testability requirements**
✅ **Large teams**

❌ **Simple CRUD applications**
❌ **Prototypes**
❌ **Very small projects**

### Interview Tips

**Common Questions:**
1. "What is Clean Architecture?"
2. "Explain the dependency rule"
3. "How do you cross boundaries?"
4. "When would you NOT use Clean Architecture?"

**How to Answer:**
- Draw concentric circles diagram
- Explain dependencies flow inward
- Give concrete examples
- Mention Uncle Bob (Robert C. Martin)
- Discuss trade-offs

### Comparison with Other Patterns

| Pattern | Similarity | Difference |
|---------|-----------|------------|
| Hexagonal | Both isolate core | Clean has more explicit layers |
| Onion | Very similar | Clean more prescriptive |
| Layered | Both use layers | Clean enforces inward dependency |

### Next Steps

Chapter 9 will cover **Serverless Architecture** - a cloud-native approach where infrastructure management is abstracted away.