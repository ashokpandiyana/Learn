# Chapter 28: Service Mesh

## Table of Contents
1. Introduction to Service Mesh
2. Service Mesh Architecture
3. Istio Deep Dive
4. Linkerd
5. Traffic Management
6. Security with mTLS
7. Observability
8. Circuit Breaking and Retries
9. Service Mesh vs API Gateway
10. Implementation Examples
11. When to Use Service Mesh

---

## 1. Introduction to Service Mesh

**Definition:** A service mesh is a dedicated infrastructure layer for handling service-to-service communication in microservices architectures.

### The Problem Without Service Mesh

```
Microservices (20 services):

Each service must implement:
- Load balancing
- Service discovery
- Circuit breaking
- Retries
- Timeouts
- Metrics collection
- Distributed tracing
- Mutual TLS

= 20 services × 8 features = 160 implementations!
= Duplicated code in every service
= Different implementations (inconsistent)
= Hard to update (must change all services)
```

### The Solution: Service Mesh

```
Service Mesh approach:

Each service gets a sidecar proxy
Sidecar handles:
- Load balancing
- Service discovery
- Circuit breaking
- Retries
- Timeouts
- Metrics
- Tracing
- mTLS

Application code: Just business logic
Infrastructure concerns: Handled by mesh

= Centralized, consistent, automatic
= Update mesh, all services benefit
```

---

## 2. Service Mesh Architecture

### Components

**1. Data Plane (Sidecar Proxies)**
```
Every service gets a sidecar proxy

Service A ←→ Proxy A ←→ Proxy B ←→ Service B

All traffic goes through proxies
Proxies handle infrastructure concerns
Services just send/receive
```

**2. Control Plane**
```
Central component that:
- Configures proxies
- Manages certificates
- Provides service discovery
- Collects telemetry

Examples: Istio, Linkerd, Consul Connect
```

### How It Works

```
Request Flow:

1. Service A makes request to Service B
   Service A → localhost:15001 (sidecar)

2. Sidecar intercepts
   - Checks circuit breaker
   - Applies retries
   - Adds tracing headers
   - Encrypts with mTLS

3. Routes to Service B's sidecar
   Proxy A → Proxy B (encrypted)

4. Service B's sidecar
   - Decrypts
   - Checks authorization
   - Forwards to Service B

5. Service B processes
   Service B → Response

6. Response flows back through proxies
   Proxy B → Proxy A → Service A
```

---

## 3. Istio Deep Dive

**Istio:** Most popular service mesh, built on Envoy proxy.

### Istio Architecture

```
┌─────────────────────────────────────┐
│        Control Plane (istiod)       │
│  - Pilot (traffic management)       │
│  - Citadel (certificate mgmt)       │
│  - Galley (configuration)           │
└────────────┬────────────────────────┘
             │ Configure
             ↓
┌────────────────────────────────────┐
│         Data Plane (Envoy)         │
│  Sidecar proxy in each pod         │
└────────────────────────────────────┘
```

### Installation

```bash
# ============================================
# Install Istio on Kubernetes
# ============================================

# Download Istio
curl -L https://istio.io/downloadIstio | sh -
cd istio-1.19.0

# Install Istio
istioctl install --set profile=demo -y

# Enable sidecar injection for namespace
kubectl label namespace default istio-injection=enabled

# Deploy application (sidecar auto-injected)
kubectl apply -f app-deployment.yaml

# Verify
kubectl get pods
# NAME                     READY   STATUS
# myapp-7d8f9c-abc         2/2     Running
#                          ↑↑
#                  app + sidecar
```

### Istio Configuration Examples

```yaml
# ============================================
# Virtual Service (Traffic Routing)
# ============================================
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: user-service
spec:
  hosts:
  - user-service
  http:
  - match:
    - headers:
        version:
          exact: v2
    route:
    - destination:
        host: user-service
        subset: v2
  - route:
    - destination:
        host: user-service
        subset: v1
      weight: 90
    - destination:
        host: user-service
        subset: v2
      weight: 10

---
# Destination Rule (Load Balancing, Circuit Breaking)
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: user-service
spec:
  host: user-service
  trafficPolicy:
    # Load balancing
    loadBalancer:
      simple: LEAST_REQUEST
    
    # Connection pool
    connectionPool:
      tcp:
        maxConnections: 100
      http:
        http1MaxPendingRequests: 10
        http2MaxRequests: 100
    
    # Circuit breaker
    outlierDetection:
      consecutiveErrors: 5
      interval: 30s
      baseEjectionTime: 30s
      maxEjectionPercent: 50
  
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
    trafficPolicy:
      # Different policy for v2
      loadBalancer:
        simple: ROUND_ROBIN

---
# Retry Policy
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: order-service
spec:
  hosts:
  - order-service
  http:
  - route:
    - destination:
        host: order-service
    retries:
      attempts: 3
      perTryTimeout: 2s
      retryOn: 5xx,reset,connect-failure,refused-stream

---
# Timeout
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: payment-service
spec:
  hosts:
  - payment-service
  http:
  - route:
    - destination:
        host: payment-service
    timeout: 10s
```

---

## 4. Linkerd

**Linkerd:** Lightweight service mesh focused on simplicity.

### Installation

```bash
# ============================================
# Install Linkerd
# ============================================

# Install CLI
curl -sL https://run.linkerd.io/install | sh

# Install control plane
linkerd install | kubectl apply -f -

# Verify
linkerd check

# Inject sidecar into deployment
kubectl get deploy myapp -o yaml | linkerd inject - | kubectl apply -f -

# Or annotate namespace for auto-injection
kubectl annotate namespace default linkerd.io/inject=enabled
```

### Linkerd Configuration

```yaml
# ============================================
# Service Profile (Retries, Timeouts)
# ============================================
apiVersion: linkerd.io/v1alpha2
kind: ServiceProfile
metadata:
  name: user-service.default.svc.cluster.local
  namespace: default
spec:
  routes:
  - name: GET /users/{id}
    condition:
      method: GET
      pathRegex: /users/[^/]*
    timeout: 5s
    retries:
      limit: 3
      timeout: 1s
  
  - name: POST /users
    condition:
      method: POST
      pathRegex: /users
    timeout: 10s
    retries:
      limit: 0  # Don't retry POST (not idempotent)

---
# Traffic Split (Canary Deployment)
apiVersion: split.smi-spec.io/v1alpha1
kind: TrafficSplit
metadata:
  name: user-service-split
spec:
  service: user-service
  backends:
  - service: user-service-v1
    weight: 90  # 90% traffic to v1
  - service: user-service-v2
    weight: 10  # 10% traffic to v2 (canary)
```

---

## 5. Traffic Management

### Canary Deployment

```yaml
# ============================================
# Canary Deployment with Istio
# ============================================

# Stage 1: Route 95% to v1, 5% to v2 (test)
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: myapp-canary
spec:
  hosts:
  - myapp
  http:
  - route:
    - destination:
        host: myapp
        subset: v1
      weight: 95
    - destination:
        host: myapp
        subset: v2
      weight: 5

# Monitor metrics for v2
# If good, gradually increase

# Stage 2: 50/50
# weight: 50 for v1, 50 for v2

# Stage 3: 100% to v2
# weight: 0 for v1, 100 for v2

# Stage 4: Remove v1
```

### A/B Testing

```yaml
# ============================================
# A/B Testing Based on Headers
# ============================================
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: myapp-ab-test
spec:
  hosts:
  - myapp
  http:
  # Premium users → v2
  - match:
    - headers:
        user-tier:
          exact: premium
    route:
    - destination:
        host: myapp
        subset: v2
  
  # Free users → v1
  - match:
    - headers:
        user-tier:
          exact: free
    route:
    - destination:
        host: myapp
        subset: v1
  
  # Default → v1
  - route:
    - destination:
        host: myapp
        subset: v1
```

### Traffic Mirroring (Shadow Traffic)

```yaml
# ============================================
# Mirror Traffic to New Version
# ============================================
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: myapp-mirror
spec:
  hosts:
  - myapp
  http:
  - route:
    - destination:
        host: myapp
        subset: v1
      weight: 100
    mirror:
      host: myapp
      subset: v2
    mirrorPercentage:
      value: 100

# All traffic goes to v1 (production)
# Copy of traffic also sent to v2 (for testing)
# v2 responses discarded
# Test v2 with real traffic without impacting users!
```

---

## 6. Security with mTLS

**Mutual TLS:** Both client and server authenticate each other.

### Automatic mTLS with Istio

```yaml
# ============================================
# Enable mTLS for all services
# ============================================
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: default
spec:
  mtls:
    mode: STRICT  # Require mTLS for all traffic

# Istio automatically:
# - Issues certificates to each service
# - Rotates certificates
# - Encrypts service-to-service traffic
# - Validates certificates

# No code changes needed!
```

### Authorization Policies

```yaml
# ============================================
# Service-to-Service Authorization
# ============================================
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: payment-service-authz
  namespace: default
spec:
  selector:
    matchLabels:
      app: payment-service
  
  action: ALLOW
  rules:
  # Rule 1: Only order-service can call payment-service
  - from:
    - source:
        principals: ["cluster.local/ns/default/sa/order-service"]
    to:
    - operation:
        methods: ["POST"]
        paths: ["/v1/charge"]
  
  # Rule 2: Admin service can call any method
  - from:
    - source:
        principals: ["cluster.local/ns/default/sa/admin-service"]

---
# Deny all by default, explicit allow
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: deny-all
  namespace: default
spec:
  {} # Empty spec = deny all

# Then create specific allow policies
```

---

## 7. Observability

### Distributed Tracing

```yaml
# ============================================
# Jaeger for Distributed Tracing
# ============================================

# Istio automatically adds tracing headers
# Application must propagate headers

# Example: Propagate tracing headers
app.get('/api/users/:id', async (req, res) => {
  // Extract tracing headers
  const tracingHeaders = {
    'x-request-id': req.headers['x-request-id'],
    'x-b3-traceid': req.headers['x-b3-traceid'],
    'x-b3-spanid': req.headers['x-b3-spanid'],
    'x-b3-parentspanid': req.headers['x-b3-parentspanid'],
    'x-b3-sampled': req.headers['x-b3-sampled'],
    'x-b3-flags': req.headers['x-b3-flags']
  };
  
  // Call another service (propagate headers)
  const orders = await fetch('http://order-service/orders', {
    headers: tracingHeaders
  });
  
  res.json({ user, orders });
});

# Trace visualization in Jaeger:
# user-service → order-service → payment-service → database
#   50ms           100ms            200ms           150ms
# Total: 500ms (with detailed breakdown)
```

### Metrics with Prometheus

```yaml
# ============================================
# Istio Metrics (Automatic)
# ============================================

# Request count by service
istio_requests_total{
  destination_service="user-service",
  response_code="200"
}

# Request duration
istio_request_duration_milliseconds_bucket{
  destination_service="user-service",
  le="100"  # 100ms bucket
}

# Examples of automatic metrics:
# - Request rate (requests/sec)
# - Error rate (errors/sec)
# - Duration (p50, p95, p99)
# - Success rate (%)

# Query in Prometheus:
# Request rate:
rate(istio_requests_total[5m])

# Error rate:
rate(istio_requests_total{response_code=~"5.."}[5m])

# P95 latency:
histogram_quantile(0.95, 
  rate(istio_request_duration_milliseconds_bucket[5m])
)
```

### Grafana Dashboards

```yaml
# Istio provides pre-built Grafana dashboards:
# - Service Dashboard (per service metrics)
# - Workload Dashboard (per pod metrics)  
# - Performance Dashboard (latency, throughput)
# - Mesh Dashboard (overall health)

# Access Grafana
kubectl port-forward svc/grafana 3000:3000 -n istio-system

# Open http://localhost:3000
# Select Istio dashboards
```

---

## 8. Circuit Breaking and Retries

### Circuit Breaking Configuration

```yaml
# ============================================
# Circuit Breaker with Istio
# ============================================
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: payment-service
spec:
  host: payment-service
  trafficPolicy:
    outlierDetection:
      # Eject instance after 5 consecutive errors
      consecutiveErrors: 5
      
      # Check every 30 seconds
      interval: 30s
      
      # Keep ejected for 30 seconds
      baseEjectionTime: 30s
      
      # Max 50% of instances can be ejected
      maxEjectionPercent: 50
      
      # Minimum health check interval
      minHealthPercent: 50

# How it works:
# 1. Payment service instance returns 5 errors
# 2. Istio ejects instance from load balancer
# 3. No traffic sent to unhealthy instance for 30s
# 4. After 30s, instance rejoins
# 5. If still unhealthy, ejected again
```

### Retry Configuration

```yaml
# ============================================
# Retry Policy
# ============================================
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: user-service
spec:
  hosts:
  - user-service
  http:
  - route:
    - destination:
        host: user-service
    
    # Retry configuration
    retries:
      attempts: 3              # Max 3 attempts
      perTryTimeout: 2s        # 2s per attempt
      retryOn: 5xx,reset,connect-failure,refused-stream
    
    # Overall timeout
    timeout: 10s

# Retry logic:
# Attempt 1: Fails after 2s → Retry
# Attempt 2: Fails after 2s → Retry
# Attempt 3: Fails after 2s → Return error
# Total: 6s (or 10s overall timeout)
```

---

## 9. Service Mesh vs API Gateway

### Comparison

| Feature | Service Mesh | API Gateway |
|---------|--------------|-------------|
| **Scope** | Internal (service-to-service) | External (client-to-service) |
| **Location** | Between services | At edge |
| **Purpose** | Infrastructure for microservices | API management |
| **Authentication** | mTLS between services | API keys, OAuth for clients |
| **Use Together?** | Yes | API Gateway → Service Mesh |

### Combined Architecture

```
┌─────────┐
│ Client  │
└────┬────┘
     │
     ▼
┌─────────────┐
│ API Gateway │ ← External clients
│ - Auth      │
│ - Rate Limit│
└────┬────────┘
     │
     ▼
┌─────────────────────────────┐
│      Service Mesh           │
│                             │
│  ┌────────┐   ┌────────┐  │
│  │Service │───│Service │  │ ← Internal services
│  │   A    │   │   B    │  │   with mTLS
│  └────────┘   └────────┘  │
│                             │
└─────────────────────────────┘

API Gateway: External → Internal
Service Mesh: Internal ← → Internal
```

---

## 10. Implementation Examples

### Complete Istio Setup

```yaml
# ============================================
# Complete Microservices with Istio
# ============================================

# Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: myapp
  labels:
    istio-injection: enabled

---
# User Service Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
  namespace: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
      version: v1
  template:
    metadata:
      labels:
        app: user-service
        version: v1
    spec:
      containers:
      - name: user-service
        image: myapp/user-service:v1
        ports:
        - containerPort: 3000
        env:
        - name: ORDER_SERVICE_URL
          value: http://order-service:8080

---
# Order Service Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: order-service
  namespace: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: order-service
  template:
    metadata:
      labels:
        app: order-service
    spec:
      containers:
      - name: order-service
        image: myapp/order-service:v1
        ports:
        - containerPort: 8080
        env:
        - name: PAYMENT_SERVICE_URL
          value: http://payment-service:9000

---
# Services
apiVersion: v1
kind: Service
metadata:
  name: user-service
  namespace: myapp
spec:
  selector:
    app: user-service
  ports:
  - port: 3000
    targetPort: 3000

---
apiVersion: v1
kind: Service
metadata:
  name: order-service
  namespace: myapp
spec:
  selector:
    app: order-service
  ports:
  - port: 8080
    targetPort: 8080

---
# Virtual Service with all features
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: user-service
  namespace: myapp
spec:
  hosts:
  - user-service
  http:
  - match:
    - uri:
        prefix: /api/
    route:
    - destination:
        host: user-service
        port:
          number: 3000
    
    # Retry on failures
    retries:
      attempts: 3
      perTryTimeout: 2s
      retryOn: 5xx,reset
    
    # Overall timeout
    timeout: 10s
    
    # Fault injection (testing)
    fault:
      delay:
        percentage:
          value: 0.1  # 10% of requests
        fixedDelay: 5s  # Add 5s delay
      abort:
        percentage:
          value: 0.01  # 1% of requests
        httpStatus: 503  # Return 503

---
# Destination Rule
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: user-service
  namespace: myapp
spec:
  host: user-service
  trafficPolicy:
    # Load balancing
    loadBalancer:
      consistentHash:
        httpHeaderName: x-user-id  # Sticky sessions by user
    
    # Circuit breaker
    outlierDetection:
      consecutiveErrors: 5
      interval: 10s
      baseEjectionTime: 30s
    
    # Connection pool limits
    connectionPool:
      tcp:
        maxConnections: 100
      http:
        http1MaxPendingRequests: 50
        http2MaxRequests: 100
        maxRequestsPerConnection: 2

---
# mTLS Configuration
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: myapp
spec:
  mtls:
    mode: STRICT  # All service-to-service traffic encrypted

---
# Authorization Policy
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: user-service-authz
  namespace: myapp
spec:
  selector:
    matchLabels:
      app: user-service
  
  action: ALLOW
  rules:
  # Only allow from order-service
  - from:
    - source:
        principals: ["cluster.local/ns/myapp/sa/order-service"]
    to:
    - operation:
        methods: ["GET", "POST"]
```

### Application Code (Simplified)

```javascript
// ============================================
// Service code (No mesh logic!)
// ============================================

// User Service
const express = require('express');
const app = express();

app.get('/users/:id', async (req, res) => {
  // Just business logic - no:
  // - Load balancing code
  // - Circuit breaker code
  // - Retry logic
  // - Tracing code
  // - mTLS code
  // All handled by sidecar!
  
  const user = await db.query(
    'SELECT * FROM users WHERE id = $1',
    [req.params.id]
  );
  
  // Call order service (simple HTTP)
  const orders = await fetch(
    `http://order-service:8080/orders?userId=${req.params.id}`
  ).then(r => r.json());
  
  res.json({ user, orders });
});

app.listen(3000);

// Sidecar handles:
// ✓ Load balancing to order-service
// ✓ Circuit breaking
// ✓ Retries
// ✓ Timeouts
// ✓ mTLS encryption
// ✓ Distributed tracing
// ✓ Metrics collection
```

---

## 11. When to Use Service Mesh

### ✅ Good Use Cases

**1. Many Microservices (10+)**
```
With 20+ microservices:
- Service mesh provides consistency
- Centralized traffic management
- Uniform security policies
```

**2. Polyglot Architecture**
```
Services in different languages:
- Java
- Python
- Go
- Node.js

Service mesh provides consistent features
regardless of language
```

**3. Complex Communication Patterns**
```
Need:
- Canary deployments
- Traffic splitting
- Fault injection
- Advanced routing

Service mesh makes this easy
```

**4. Security Requirements**
```
Need:
- Zero-trust networking
- mTLS everywhere
- Service-to-service authentication

Service mesh provides out-of-box
```

### ❌ When NOT to Use

**1. Small Number of Services (< 5)**
```
Service mesh adds:
- Complexity
- Resource overhead (sidecars)
- Learning curve

Not worth it for small systems
```

**2. Simple Communication**
```
If just need:
- Simple HTTP calls
- Basic load balancing

Don't need service mesh
```

**3. Limited Resources**
```
Sidecar overhead:
- ~50MB memory per pod
- ~0.1 CPU per pod

For 100 pods:
- 5GB memory
- 10 CPU cores

Consider cost
```

**4. Team Expertise**
```
Service mesh requires:
- Kubernetes knowledge
- Networking understanding
- Debugging distributed systems

Ensure team is ready
```

---

## Chapter 28 Summary

### Key Concepts

1. **Service Mesh** - Infrastructure layer for microservices
2. **Sidecar Proxy** - Proxy injected alongside each service
3. **Control Plane** - Manages and configures proxies
4. **Data Plane** - Sidecar proxies handling traffic
5. **mTLS** - Automatic mutual TLS
6. **Traffic Management** - Routing, splitting, mirroring
7. **Observability** - Metrics, tracing, logging
8. **Resilience** - Circuit breaking, retries, timeouts

### Popular Service Meshes

| Service Mesh | Pros | Cons | Best For |
|--------------|------|------|----------|
| **Istio** | Feature-rich, mature | Complex, resource-heavy | Large enterprises |
| **Linkerd** | Simple, lightweight | Fewer features | Simplicity focused |
| **Consul Connect** | Service discovery + mesh | HashiCorp ecosystem | Existing Consul users |
| **AWS App Mesh** | AWS integration | AWS-only | AWS-native apps |

### Service Mesh Features

**Traffic Management:**
- Load balancing (round-robin, least request, consistent hash)
- Traffic splitting (canary, A/B testing)
- Traffic mirroring (shadow traffic)
- Fault injection (chaos testing)

**Security:**
- Automatic mTLS
- Certificate management
- Authorization policies
- Encryption at rest/transit

**Observability:**
- Distributed tracing (Jaeger, Zipkin)
- Metrics (Prometheus)
- Access logs
- Service graphs

**Resilience:**
- Circuit breaking
- Retries with backoff
- Timeouts
- Rate limiting

### Implementation Checklist

Before adopting service mesh:
- [ ] Have 10+ microservices
- [ ] Team familiar with Kubernetes
- [ ] Complex traffic management needed
- [ ] Security requirements (mTLS)
- [ ] Budget for additional resources
- [ ] Observability gaps to fill

### Interview Tips

**Common Questions:**
1. "What is a service mesh?"
2. "How does sidecar proxy work?"
3. "Service mesh vs API gateway?"
4. "When would you use a service mesh?"
5. "Explain mTLS in service mesh"

**How to Answer:**
- Draw sidecar architecture
- Explain control plane vs data plane
- Give concrete examples (Istio, Linkerd)
- Discuss when NOT to use (small systems)
- Mention observability benefits

### Best Practices

1. **Start simple** - Don't need mesh for 3 services
2. **Gradual adoption** - Enable per namespace
3. **Monitor overhead** - Track sidecar resource usage
4. **Security first** - Enable mTLS early
5. **Observability** - Use tracing and metrics
6. **Test in staging** - Complex failure modes
7. **Document** - Mesh configuration and policies

### Service Mesh vs Alternatives

```
No Mesh (Library):
- Each service includes circuit breaker library
- Pros: No infrastructure overhead
- Cons: Language-specific, inconsistent

API Gateway:
- Central gateway for external traffic
- Pros: Single entry point
- Cons: Doesn't help service-to-service

Service Mesh:
- Sidecar for each service
- Pros: Consistent, language-agnostic
- Cons: Complex, resource overhead
```

Congratulations! You've completed Chapters 25-28 covering Cloud Computing Models, Distributed Systems Concepts, Data Consistency Models, and Service Mesh - advanced topics essential for modern distributed architectures!