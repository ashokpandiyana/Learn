# Chapter 36: DDD Strategic Design - In-Depth Guide

## What is Domain-Driven Design (DDD)?

Domain-Driven Design is an approach to software development that centers the development on programming a domain model that has a rich understanding of the processes and rules of a domain. The strategic design patterns help us organize large systems and establish boundaries between different parts of the system.

---

## 1. Bounded Contexts

### Definition
A **Bounded Context** is a central pattern in DDD. It defines the boundary within which a particular domain model is valid. Within this boundary, all terms, definitions, and rules have specific meanings.

### Why Bounded Contexts Matter
- Different parts of an organization may use the same term differently
- A "Customer" in Sales means something different than a "Customer" in Support
- Without boundaries, models become bloated and contradictory

### Example Scenario

```python
# ❌ BAD: Single unified model (no bounded contexts)
class Customer:
    def __init__(self):
        self.id = None
        self.name = None
        self.email = None
        # Sales context fields
        self.credit_limit = None
        self.sales_rep = None
        # Support context fields
        self.support_tickets = []
        self.satisfaction_score = None
        # Shipping context fields
        self.shipping_addresses = []
        self.preferred_carrier = None
        # Billing context fields
        self.payment_methods = []
        self.outstanding_balance = None
```

```python
# ✅ GOOD: Separate bounded contexts

# SALES CONTEXT
class SalesCustomer:
    def __init__(self, customer_id, name, email):
        self.customer_id = customer_id
        self.name = name
        self.email = email
        self.credit_limit = 0
        self.assigned_sales_rep = None
    
    def check_credit_limit(self, order_amount):
        return order_amount <= self.credit_limit

# SUPPORT CONTEXT
class SupportCustomer:
    def __init__(self, customer_id, name, email):
        self.customer_id = customer_id
        self.name = name
        self.email = email
        self.tickets = []
        self.priority_level = "standard"
    
    def create_ticket(self, issue):
        ticket = SupportTicket(issue, self.priority_level)
        self.tickets.append(ticket)
        return ticket

# SHIPPING CONTEXT
class ShippingCustomer:
    def __init__(self, customer_id, name):
        self.customer_id = customer_id
        self.name = name
        self.addresses = []
        self.preferred_carrier = None
    
    def add_shipping_address(self, address):
        self.addresses.append(address)
```

### Visual Representation

```
┌─────────────────────────┐
│   E-Commerce System     │
│                         │
│  ┌─────────────────┐   │
│  │ Sales Context   │   │
│  │ - SalesCustomer │   │
│  │ - Order         │   │
│  │ - Quote         │   │
│  └─────────────────┘   │
│                         │
│  ┌─────────────────┐   │
│  │Support Context  │   │
│  │ - SupportCustomer│  │
│  │ - Ticket        │   │
│  │ - KnowledgeBase │   │
│  └─────────────────┘   │
│                         │
│  ┌─────────────────┐   │
│  │Shipping Context │   │
│  │ - ShippingCustomer│ │
│  │ - Shipment      │   │
│  │ - Carrier       │   │
│  └─────────────────┘   │
└─────────────────────────┘
```

---

## 2. Ubiquitous Language

### Definition
A **Ubiquitous Language** is a common, rigorous language between developers and domain experts. This language should be used everywhere: in code, conversations, documentation, and diagrams.

### Key Principles
- The language evolves with understanding
- Business experts and developers use the SAME terms
- Code should reflect the language (class names, method names, etc.)
- No "translation layer" between business and technical terms

### Example: E-Commerce Domain

```javascript
// ❌ BAD: Technical jargon not aligned with business
class ShoppingBasket {
    constructor() {
        this.items = [];
    }
    
    addSKU(productCode, qty) {
        this.items.push({sku: productCode, amount: qty});
    }
    
    doCheckout(paymentInfo) {
        // Process payment...
    }
}

// ✅ GOOD: Uses ubiquitous language
class ShoppingCart {
    constructor() {
        this.lineItems = [];
    }
    
    addProduct(product, quantity) {
        const lineItem = new LineItem(product, quantity);
        this.lineItems.push(lineItem);
    }
    
    placeOrder(paymentMethod, shippingAddress) {
        // Business understands "place order" terminology
        const order = new Order(this.lineItems, paymentMethod, shippingAddress);
        return order.submit();
    }
}

class LineItem {
    constructor(product, quantity) {
        this.product = product;
        this.quantity = quantity;
        this.subtotal = product.price * quantity;
    }
}
```

### Building Ubiquitous Language

```python
# Workshop with domain experts leads to this language:

class LoanApplication:
    """
    A LoanApplication represents a customer's request for credit.
    Domain experts call this 'application', not 'request' or 'form'.
    """
    def __init__(self, applicant, requested_amount):
        self.applicant = applicant
        self.requested_amount = requested_amount
        self.status = ApplicationStatus.PENDING
    
    def submit_for_underwriting(self):
        """
        'Underwriting' is the domain term for credit evaluation.
        We don't say 'evaluation' or 'assessment'.
        """
        if not self.applicant.is_eligible():
            self.status = ApplicationStatus.REJECTED
            return False
        
        self.status = ApplicationStatus.UNDER_REVIEW
        return True
    
    def approve(self, approved_amount, interest_rate):
        """
        Domain experts distinguish between 'requested' and 'approved' amounts
        """
        self.approved_amount = approved_amount
        self.interest_rate = interest_rate
        self.status = ApplicationStatus.APPROVED
```

---

## 3. Context Mapping

### Definition
**Context Mapping** defines the relationship between different bounded contexts. It makes integration patterns explicit.

### Types of Context Relationships

#### 3.1 Shared Kernel
Two contexts share a small but common model. Changes must be coordinated.

```python
# Shared Kernel: Common models shared between contexts
# shared_kernel/models.py
class CustomerId:
    """Shared across Sales and Billing contexts"""
    def __init__(self, value):
        if not value or len(value) < 5:
            raise ValueError("Invalid customer ID")
        self.value = value
    
    def __eq__(self, other):
        return self.value == other.value

# Sales Context uses it
from shared_kernel.models import CustomerId

class SalesOrder:
    def __init__(self, customer_id: CustomerId):
        self.customer_id = customer_id
        # ...

# Billing Context uses it
class Invoice:
    def __init__(self, customer_id: CustomerId):
        self.customer_id = customer_id
        # ...
```

#### 3.2 Customer-Supplier
Downstream context (customer) depends on upstream context (supplier).

```javascript
// SUPPLIER: Order Context (Upstream)
class Order {
    constructor(orderId, items, total) {
        this.orderId = orderId;
        this.items = items;
        this.total = total;
    }
    
    // Supplier provides this API for downstream contexts
    toShippingRequest() {
        return {
            orderId: this.orderId,
            items: this.items.map(item => ({
                productId: item.productId,
                quantity: item.quantity,
                weight: item.weight
            })),
            totalWeight: this.calculateTotalWeight()
        };
    }
}

// CUSTOMER: Shipping Context (Downstream)
class ShippingService {
    createShipment(orderData) {
        // Shipping context depends on Order context's data format
        const shipment = new Shipment(
            orderData.orderId,
            orderData.items,
            orderData.totalWeight
        );
        return shipment;
    }
}
```

#### 3.3 Conformist
Downstream context conforms to upstream model without negotiation.

```python
# Upstream: External Payment Gateway (we have no control)
class PaymentGatewayAPI:
    """Third-party API we must conform to"""
    def process_payment(self, card_number, expiry, cvv, amount_cents):
        # External API format
        pass

# Downstream: Our Billing Context (Conformist)
class PaymentProcessor:
    def __init__(self, gateway: PaymentGatewayAPI):
        self.gateway = gateway
    
    def charge_customer(self, payment_info, amount):
        # We conform to their API format
        return self.gateway.process_payment(
            payment_info['card_number'],
            payment_info['expiry'],
            payment_info['cvv'],
            int(amount * 100)  # Convert to cents as they require
        )
```

#### 3.4 Anti-Corruption Layer (ACL)
Protects downstream context from upstream's model through translation layer.

```python
# External Legacy System (Upstream - problematic model)
class LegacyCustomerAPI:
    def get_customer_data(self, cust_num):
        # Returns messy legacy format
        return {
            'CUST_NUM': cust_num,
            'F_NAME': 'John',
            'L_NAME': 'Doe',
            'ADDR_LINE_1': '123 Main St',
            'STAT': 'A',  # A=Active, I=Inactive
            'CREDIT_LMT': '5000.00'
        }

# Anti-Corruption Layer
class CustomerAdapter:
    """Translates between legacy system and our clean model"""
    def __init__(self, legacy_api: LegacyCustomerAPI):
        self.legacy_api = legacy_api
    
    def get_customer(self, customer_id):
        legacy_data = self.legacy_api.get_customer_data(customer_id)
        
        # Translate to our clean domain model
        return Customer(
            id=legacy_data['CUST_NUM'],
            first_name=legacy_data['F_NAME'],
            last_name=legacy_data['L_NAME'],
            address=legacy_data['ADDR_LINE_1'],
            is_active=legacy_data['STAT'] == 'A',
            credit_limit=float(legacy_data['CREDIT_LMT'])
        )

# Our Clean Domain Model
class Customer:
    def __init__(self, id, first_name, last_name, address, is_active, credit_limit):
        self.id = id
        self.first_name = first_name
        self.last_name = last_name
        self.address = address
        self.is_active = is_active
        self.credit_limit = credit_limit
```

#### 3.5 Open Host Service
Context provides a well-defined API for many consumers.

```javascript
// Catalog Context provides Open Host Service
class CatalogAPI {
    constructor(catalogService) {
        this.catalogService = catalogService;
    }
    
    // Well-documented REST API
    async getProduct(productId) {
        const product = await this.catalogService.findProduct(productId);
        return {
            id: product.id,
            name: product.name,
            description: product.description,
            price: product.price,
            availability: product.stockQuantity > 0,
            _links: {
                self: `/api/products/${product.id}`,
                category: `/api/categories/${product.categoryId}`
            }
        };
    }
    
    async searchProducts(query, page = 1, limit = 20) {
        // Standardized API for multiple consumers
        const results = await this.catalogService.search(query, page, limit);
        return {
            items: results.items,
            pagination: {
                page: page,
                limit: limit,
                total: results.total
            }
        };
    }
}

// Multiple contexts can consume this API
// - Shopping Cart Context
// - Recommendation Context
// - Search Context
```

#### 3.6 Published Language
Uses a standard, published format (XML Schema, JSON Schema, Protocol Buffers).

```python
from dataclasses import dataclass
from typing import List
import json

# Published Language: Standard Event Format
@dataclass
class OrderPlacedEvent:
    """
    Standard event format published to event bus.
    All contexts understand this schema.
    """
    event_id: str
    event_type: str = "order.placed"
    timestamp: str
    order_id: str
    customer_id: str
    items: List[dict]
    total_amount: float
    
    def to_json(self):
        return json.dumps(self.__dict__)
    
    @classmethod
    def from_json(cls, json_str):
        data = json.loads(json_str)
        return cls(**data)

# Order Context publishes
class OrderService:
    def place_order(self, order):
        # ... process order ...
        
        # Publish using standard format
        event = OrderPlacedEvent(
            event_id=generate_uuid(),
            timestamp=datetime.now().isoformat(),
            order_id=order.id,
            customer_id=order.customer_id,
            items=[item.to_dict() for item in order.items],
            total_amount=order.total
        )
        self.event_bus.publish(event.to_json())

# Shipping Context subscribes
class ShippingEventHandler:
    def handle_order_placed(self, event_json):
        event = OrderPlacedEvent.from_json(event_json)
        # Create shipment from standard event
        self.create_shipment_for_order(event.order_id, event.items)
```

### Context Map Diagram

```
┌──────────────────────────────────────────────────────────┐
│                   Context Map                            │
│                                                          │
│  ┌─────────────┐          ┌──────────────┐             │
│  │   Orders    │──────────│   Shipping   │             │
│  │  (Upstream) │ Customer │ (Downstream) │             │
│  └─────────────┘ Supplier └──────────────┘             │
│         │                                               │
│         │ Published                                     │
│         │ Language                                      │
│         ▼                                               │
│  ┌─────────────┐                                       │
│  │  Inventory  │                                       │
│  │             │                                       │
│  └─────────────┘                                       │
│         ▲                                               │
│         │ ACL                                           │
│         │                                               │
│  ┌─────────────┐                                       │
│  │   Legacy    │                                       │
│  │   System    │                                       │
│  └─────────────┘                                       │
└──────────────────────────────────────────────────────────┘
```

---

## 4. Anti-Corruption Layer in Detail

### Purpose
The ACL acts as a translator and isolator, preventing external models from corrupting your domain model.

### Complete Example: Integrating with Legacy Banking System

```python
# Legacy Banking System (External)
class LegacyBankingAPI:
    def execute_transaction(self, params):
        """
        Legacy system with terrible API design
        Returns: [status_code, message, transaction_id, balance]
        """
        # Simulated legacy call
        return [200, "SUCCESS", "TXN123456", 95000.50]
    
    def get_account_info(self, account_number):
        """
        Returns array: [acc_num, type, balance, status, date_opened, ...]
        """
        return ["ACC001", "CHK", 95000.50, "ACTV", "20200115"]

# Anti-Corruption Layer: Adapter
class BankingSystemAdapter:
    def __init__(self, legacy_api: LegacyBankingAPI):
        self.legacy_api = legacy_api
    
    def transfer_money(self, from_account, to_account, amount):
        # Translate our domain model to legacy format
        legacy_params = {
            'from_acc': from_account.number,
            'to_acc': to_account.number,
            'amt': amount.value,
            'currency': amount.currency
        }
        
        result = self.legacy_api.execute_transaction(legacy_params)
        
        # Translate legacy response to our domain model
        return TransactionResult(
            success=result[0] == 200,
            message=result[1],
            transaction_id=result[2],
            new_balance=Money(result[3], amount.currency)
        )
    
    def get_account(self, account_number):
        legacy_data = self.legacy_api.get_account_info(account_number)
        
        # Translate to our clean model
        return Account(
            number=legacy_data[0],
            type=AccountType.from_legacy_code(legacy_data[1]),
            balance=Money(legacy_data[2], "USD"),
            status=AccountStatus.ACTIVE if legacy_data[3] == "ACTV" else AccountStatus.INACTIVE,
            opened_date=datetime.strptime(legacy_data[4], "%Y%m%d")
        )

# Our Clean Domain Model
class Money:
    def __init__(self, value, currency):
        self.value = value
        self.currency = currency

class Account:
    def __init__(self, number, type, balance, status, opened_date):
        self.number = number
        self.type = type
        self.balance = balance
        self.status = status
        self.opened_date = opened_date

class TransactionResult:
    def __init__(self, success, message, transaction_id, new_balance):
        self.success = success
        self.message = message
        self.transaction_id = transaction_id
        self.new_balance = new_balance

# Our Domain Service (Clean, no knowledge of legacy system)
class MoneyTransferService:
    def __init__(self, banking_adapter: BankingSystemAdapter):
        self.banking_adapter = banking_adapter
    
    def transfer(self, from_account_number, to_account_number, amount):
        # Work with clean domain objects
        from_account = self.banking_adapter.get_account(from_account_number)
        to_account = self.banking_adapter.get_account(to_account_number)
        
        if from_account.balance.value < amount.value:
            raise InsufficientFundsError()
        
        return self.banking_adapter.transfer_money(from_account, to_account, amount)
```

---

## Best Practices for Strategic DDD

### 1. Start with Bounded Contexts
- Map out your business domains first
- Identify different meanings of the same terms
- Don't create too many contexts initially (start with 3-5)

### 2. Invest in Ubiquitous Language
- Hold regular workshops with domain experts
- Create a glossary
- Update code when language evolves

### 3. Make Context Boundaries Explicit
```python
# Use namespaces/packages to enforce boundaries
project/
  sales/
    domain/
      customer.py
      order.py
  support/
    domain/
      customer.py
      ticket.py
```

### 4. Design Integration Carefully
- Choose the right context relationship pattern
- Document context maps
- Use ACL when integrating with problematic systems

### 5. Evolve Your Understanding
- Context boundaries aren't perfect initially
- Refactor as you learn more about the domain
- Split contexts that grow too large

---

## Common Pitfalls

1. **Anemic Domain Model**: Using bounded contexts but still having transaction scripts
2. **God Context**: One context trying to handle everything
3. **No Clear Boundaries**: Contexts bleeding into each other
4. **Ignoring the Team Structure**: Conway's Law - your architecture will mirror your organization
5. **Over-Engineering**: Creating too many contexts too early

---

## Key Takeaways

- **Bounded Contexts** divide large systems into manageable parts with clear boundaries
- **Ubiquitous Language** ensures everyone speaks the same language within a context
- **Context Mapping** makes integration patterns explicit and manageable
- **Anti-Corruption Layer** protects your domain from external influences
- Strategic DDD is about **organization and communication**, not just code