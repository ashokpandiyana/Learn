# Chapter 18: Content Delivery

## Table of Contents
1. Introduction to Content Delivery
2. CDN Architecture
3. Edge Computing
4. Geographic Distribution
5. Static vs Dynamic Content
6. Cache Headers and Controls
7. Image Optimization
8. Video Streaming
9. HTTP/2 and HTTP/3
10. Real-World CDN Configuration
11. Performance Metrics

---

## 1. Introduction to Content Delivery

**Definition:** Content delivery is the process of delivering digital content (images, videos, HTML, CSS, JS) to users efficiently.

### The Latency Problem

```
User in Tokyo → Origin Server in New York
Distance: 10,000 km
Speed of light: 300,000 km/s
Minimum latency: 33ms (one way)
Round trip: 66ms

Plus:
- Routing overhead: +20ms
- Network congestion: +30ms
- Server processing: +20ms

Total: ~136ms just for network!
```

### CDN Solution

```
User in Tokyo → CDN Edge in Tokyo
Distance: 50 km
Latency: ~5ms

Improvement: 27x faster!
```

---

## 2. CDN Architecture

**Definition:** Content Delivery Network (CDN) is a geographically distributed network of servers that cache content close to users.

### How CDN Works

```
Step 1: User requests https://example.com/image.jpg
        ↓
Step 2: DNS resolves to nearest CDN edge server
        ↓
Step 3: CDN edge checks cache
        ↓
Step 4a: Cache HIT → Return immediately (fast!)
        ↓
Step 4b: Cache MISS → Fetch from origin → Cache → Return (slow first time)
```

### CDN Request Flow

```javascript
// ============================================
// Request Flow Example
// ============================================

// First Request (Cache Miss)
User (Tokyo) → CDN Edge (Tokyo)
                ↓ Cache Miss
              Origin (US)
                ↓ Fetch
              Return to Edge
                ↓ Store in cache
              Return to User
Time: 200ms

// Second Request (Cache Hit)
User (Tokyo) → CDN Edge (Tokyo)
                ↓ Cache Hit
              Return to User
Time: 10ms

// 20x faster for subsequent requests!
```

### CDN Configuration

```javascript
// ============================================
// CloudFront Configuration (AWS)
// ============================================
const AWS = require('aws-sdk');
const cloudfront = new AWS.CloudFront();

const params = {
  DistributionConfig: {
    CallerReference: Date.now().toString(),
    Comment: 'My CDN Distribution',
    Enabled: true,
    
    // Origin - where to fetch content
    Origins: {
      Quantity: 1,
      Items: [
        {
          Id: 'my-s3-bucket',
          DomainName: 'my-bucket.s3.amazonaws.com',
          S3OriginConfig: {
            OriginAccessIdentity: ''
          }
        }
      ]
    },
    
    // Default cache behavior
    DefaultCacheBehavior: {
      TargetOriginId: 'my-s3-bucket',
      ViewerProtocolPolicy: 'redirect-to-https',
      AllowedMethods: {
        Quantity: 2,
        Items: ['GET', 'HEAD']
      },
      
      // Cache settings
      MinTTL: 0,
      MaxTTL: 31536000,  // 1 year
      DefaultTTL: 86400,  // 1 day
      
      // Compression
      Compress: true,
      
      ForwardedValues: {
        QueryString: false,
        Cookies: { Forward: 'none' }
      }
    },
    
    // Custom cache behaviors
    CacheBehaviors: {
      Quantity: 2,
      Items: [
        {
          PathPattern: '/api/*',
          TargetOriginId: 'my-s3-bucket',
          MinTTL: 0,
          MaxTTL: 300,  // 5 minutes for API
          DefaultTTL: 60
        },
        {
          PathPattern: '/images/*',
          TargetOriginId: 'my-s3-bucket',
          MinTTL: 86400,
          MaxTTL: 31536000,  // 1 year for images
          DefaultTTL: 604800  // 1 week
        }
      ]
    }
  }
};

cloudfront.createDistribution(params, (err, data) => {
  if (err) console.error(err);
  else console.log('CDN created:', data.Distribution.DomainName);
});
```

---

## 3. Edge Computing

**Definition:** Run code at CDN edge locations, closer to users.

### Cloudflare Workers Example

```javascript
// ============================================
// Cloudflare Worker (runs at edge)
// ============================================

addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request));
});

async function handleRequest(request) {
  const url = new URL(request.url);
  
  // 1. Serve static files from cache
  if (url.pathname.startsWith('/static/')) {
    return await cacheFirst(request);
  }
  
  // 2. API requests with authentication
  if (url.pathname.startsWith('/api/')) {
    return await handleAPI(request);
  }
  
  // 3. A/B testing at edge
  if (url.pathname === '/') {
    return await handleABTest(request);
  }
  
  // 4. Default: fetch from origin
  return await fetch(request);
}

async function cacheFirst(request) {
  const cache = caches.default;
  
  // Check cache
  let response = await cache.match(request);
  
  if (!response) {
    // Cache miss - fetch from origin
    response = await fetch(request);
    
    // Cache for 1 year if successful
    if (response.status === 200) {
      const newResponse = new Response(response.body, response);
      newResponse.headers.set('Cache-Control', 'public, max-age=31536000');
      await cache.put(request, newResponse.clone());
      return newResponse;
    }
  }
  
  return response;
}

async function handleAPI(request) {
  // Authenticate at edge (faster than origin)
  const token = request.headers.get('Authorization');
  
  if (!token) {
    return new Response('Unauthorized', { status: 401 });
  }
  
  // Verify JWT at edge
  try {
    await verifyJWT(token);
  } catch (error) {
    return new Response('Invalid token', { status: 401 });
  }
  
  // Forward to origin
  return await fetch(request);
}

async function handleABTest(request) {
  // A/B testing at edge
  const cookie = request.headers.get('Cookie');
  const variant = cookie?.includes('variant=B') ? 'B' : 'A';
  
  if (variant === 'B') {
    // Serve variant B
    return new Response(VARIANT_B_HTML, {
      headers: { 'Content-Type': 'text/html' }
    });
  } else {
    // Serve variant A
    return new Response(VARIANT_A_HTML, {
      headers: { 'Content-Type': 'text/html' }
    });
  }
}
```

### AWS Lambda@Edge

```javascript
// ============================================
// Lambda@Edge (runs at CloudFront edges)
// ============================================

exports.handler = async (event) => {
  const request = event.Records[0].cf.request;
  const headers = request.headers;
  
  // 1. Add security headers
  const response = {
    status: '200',
    headers: {
      'strict-transport-security': [{
        key: 'Strict-Transport-Security',
        value: 'max-age=31536000'
      }],
      'x-content-type-options': [{
        key: 'X-Content-Type-Options',
        value: 'nosniff'
      }],
      'x-frame-options': [{
        key: 'X-Frame-Options',
        value: 'DENY'
      }]
    }
  };
  
  // 2. Redirect mobile users
  const userAgent = headers['user-agent'][0].value;
  if (userAgent.includes('Mobile')) {
    return {
      status: '302',
      headers: {
        'location': [{
          key: 'Location',
          value: 'https://m.example.com' + request.uri
        }]
      }
    };
  }
  
  // 3. Customize based on location
  const country = headers['cloudfront-viewer-country'][0].value;
  if (country === 'CN') {
    // Serve China-specific content
    request.uri = '/cn' + request.uri;
  }
  
  return request;
};
```

---

## 4. Geographic Distribution

### Multi-Region Deployment

```
┌─────────────────────────────────────────────────┐
│              Global DNS (Route 53)              │
│         Geolocation-based routing               │
└────────┬────────────────┬──────────────────────┘
         │                │
         ▼                ▼
    ┌────────┐       ┌────────┐       ┌────────┐
    │US West │       │Europe  │       │Asia    │
    │Region  │       │Region  │       │Region  │
    └───┬────┘       └───┬────┘       └───┬────┘
        │                │                 │
    ┌───▼─────┐     ┌───▼─────┐     ┌────▼────┐
    │App + DB │     │App + DB │     │App + DB │
    └─────────┘     └─────────┘     └─────────┘
```

### DNS-Based Routing

```javascript
// ============================================
// AWS Route 53 - Geolocation Routing
// ============================================
const AWS = require('aws-sdk');
const route53 = new AWS.Route53();

const params = {
  ChangeBatch: {
    Changes: [
      {
        Action: 'CREATE',
        ResourceRecordSet: {
          Name: 'api.example.com',
          Type: 'A',
          GeoLocation: {
            ContinentCode: 'NA'  // North America
          },
          TTL: 60,
          ResourceRecords: [
            { Value: '54.123.45.67' }  // US server IP
          ]
        }
      },
      {
        Action: 'CREATE',
        ResourceRecordSet: {
          Name: 'api.example.com',
          Type: 'A',
          GeoLocation: {
            ContinentCode: 'EU'  // Europe
          },
          TTL: 60,
          ResourceRecords: [
            { Value: '52.234.56.78' }  // EU server IP
          ]
        }
      },
      {
        Action: 'CREATE',
        ResourceRecordSet: {
          Name: 'api.example.com',
          Type: 'A',
          GeoLocation: {
            ContinentCode: 'AS'  // Asia
          },
          TTL: 60,
          ResourceRecords: [
            { Value: '13.234.78.90' }  // Asia server IP
          ]
        }
      }
    ]
  },
  HostedZoneId: 'Z1234567890ABC'
};

route53.changeResourceRecordSets(params, (err, data) => {
  if (err) console.error(err);
  else console.log('Geolocation routing configured');
});
```

---

## 5. Static vs Dynamic Content

### Static Content (Cacheable)

**Characteristics:**
- Same for all users
- Doesn't change frequently
- Examples: Images, CSS, JS, videos, fonts

**Optimization:**
```javascript
// ============================================
// Serving Static Content
// ============================================
const express = require('express');
const app = express();

// Static files with aggressive caching
app.use('/static', express.static('public', {
  maxAge: '1y',  // Cache for 1 year
  immutable: true,
  etag: true,
  lastModified: true
}));

// Custom headers for different file types
app.get('/images/:filename', (req, res) => {
  // Images: cache for 1 year
  res.set({
    'Cache-Control': 'public, max-age=31536000, immutable',
    'Content-Type': 'image/jpeg'
  });
  res.sendFile(`images/${req.params.filename}`);
});

app.get('/css/:filename', (req, res) => {
  // CSS: cache for 1 month
  res.set({
    'Cache-Control': 'public, max-age=2592000',
    'Content-Type': 'text/css'
  });
  res.sendFile(`css/${req.params.filename}`);
});
```

### Dynamic Content (Personalized)

**Characteristics:**
- Different for each user
- Changes frequently
- Examples: User profile, dashboard, personalized feed

**Optimization:**
```javascript
app.get('/api/user/profile', authenticate, async (req, res) => {
  // User-specific data - can't cache in CDN
  // But can cache in application
  
  const cacheKey = `profile:${req.user.id}`;
  
  // Check Redis cache
  const cached = await redis.get(cacheKey);
  if (cached) {
    res.set('X-Cache', 'HIT');
    return res.json(JSON.parse(cached));
  }
  
  // Query database
  const profile = await db.query(
    'SELECT * FROM users WHERE id = ?',
    [req.user.id]
  );
  
  // Cache for 5 minutes
  await redis.setex(cacheKey, 300, JSON.stringify(profile));
  
  res.set({
    'Cache-Control': 'private, max-age=300',  // Private (not CDN)
    'X-Cache': 'MISS'
  });
  
  res.json(profile);
});
```

### Semi-Dynamic Content

**Characteristics:**
- Same for groups of users
- Changes periodically

**Example: Product listing**

```javascript
app.get('/api/products', async (req, res) => {
  const category = req.query.category || 'all';
  const cacheKey = `products:${category}`;
  
  // Check cache (same for all users in category)
  const cached = await redis.get(cacheKey);
  if (cached) {
    res.set({
      'Cache-Control': 'public, max-age=300',  // 5 minutes
      'X-Cache': 'HIT'
    });
    return res.json(JSON.parse(cached));
  }
  
  // Query database
  const products = await db.query(
    'SELECT * FROM products WHERE category = ? AND active = true',
    [category]
  );
  
  // Cache for 5 minutes
  await redis.setex(cacheKey, 300, JSON.stringify(products));
  
  res.set({
    'Cache-Control': 'public, max-age=300',
    'X-Cache': 'MISS'
  });
  
  res.json(products);
});
```

---

## 6. Cache Headers and Controls

### Cache-Control Header

```http
Cache-Control Directives:

public              - Can be cached by anyone (CDN, browser)
private             - Only browser can cache (not CDN)
no-cache            - Must revalidate before using
no-store            - Don't cache at all
max-age=3600        - Cache for 3600 seconds
s-maxage=7200       - CDN cache for 7200 seconds (different from browser)
must-revalidate     - Must check with server when stale
immutable           - Never changes, don't revalidate
```

### Examples by Content Type

```javascript
// ============================================
// Cache Headers by Content Type
// ============================================

// 1. Versioned static assets (never change)
app.get('/static/app.v123.js', (req, res) => {
  res.set({
    'Cache-Control': 'public, max-age=31536000, immutable',
    'Content-Type': 'application/javascript'
  });
  res.sendFile('app.js');
});
// Aggressive caching - file will never change

// 2. Images (long cache)
app.get('/images/:id', (req, res) => {
  res.set({
    'Cache-Control': 'public, max-age=2592000',  // 30 days
    'Content-Type': 'image/jpeg'
  });
  res.sendFile(`images/${req.params.id}`);
});

// 3. HTML (short cache, must revalidate)
app.get('/', (req, res) => {
  res.set({
    'Cache-Control': 'public, max-age=300, must-revalidate',  // 5 min
    'Content-Type': 'text/html'
  });
  res.sendFile('index.html');
});

// 4. API responses (short cache, public)
app.get('/api/products', (req, res) => {
  res.set({
    'Cache-Control': 'public, max-age=60',  // 1 minute
    'Content-Type': 'application/json'
  });
  res.json(products);
});

// 5. User-specific data (private, no CDN cache)
app.get('/api/user/cart', authenticate, (req, res) => {
  res.set({
    'Cache-Control': 'private, max-age=300',  // 5 min in browser only
    'Content-Type': 'application/json'
  });
  res.json(userCart);
});

// 6. Sensitive data (no cache)
app.get('/api/user/payment-methods', authenticate, (req, res) => {
  res.set({
    'Cache-Control': 'private, no-cache, no-store, must-revalidate',
    'Pragma': 'no-cache',
    'Expires': '0'
  });
  res.json(paymentMethods);
});
```

### ETag for Conditional Requests

```javascript
const crypto = require('crypto');

app.get('/api/products', async (req, res) => {
  const products = await db.query('SELECT * FROM products');
  
  // Generate ETag (hash of content)
  const etag = crypto
    .createHash('md5')
    .update(JSON.stringify(products))
    .digest('hex');
  
  // Check if client has current version
  if (req.headers['if-none-match'] === etag) {
    // Client has current version
    return res.status(304).send();  // Not Modified
  }
  
  // Send full response with ETag
  res.set({
    'ETag': etag,
    'Cache-Control': 'public, max-age=300'
  });
  
  res.json(products);
});

// Client request flow:
// Request 1: GET /api/products
//            Response: 200, ETag: "abc123", Body: {...}
//            Size: 500KB
//
// Request 2: GET /api/products
//            If-None-Match: "abc123"
//            Response: 304 Not Modified
//            Size: 0KB (just headers)
//
// Bandwidth saved: 500KB
```

---

## 7. Image Optimization

### Responsive Images

```html
<!-- ============================================ -->
<!-- Serve different image sizes -->
<!-- ============================================ -->

<!-- Method 1: srcset for different resolutions -->
<img 
  src="image-400.jpg"
  srcset="image-400.jpg 400w,
          image-800.jpg 800w,
          image-1200.jpg 1200w"
  sizes="(max-width: 600px) 400px,
         (max-width: 1000px) 800px,
         1200px"
  alt="Product"
/>

<!-- Browser chooses appropriate size -->
<!-- Mobile: Downloads 400px version (50KB) -->
<!-- Desktop: Downloads 1200px version (200KB) -->

<!-- Method 2: Picture element for different formats -->
<picture>
  <!-- Modern browsers: WebP (smaller) -->
  <source srcset="image.webp" type="image/webp">
  
  <!-- Fallback: JPEG -->
  <img src="image.jpg" alt="Product">
</picture>

<!-- WebP: 50KB -->
<!-- JPEG: 150KB -->
<!-- Saved: 100KB (67% smaller) -->
```

### Image Processing at Edge

```javascript
// ============================================
// Cloudflare Image Resizing
// ============================================

addEventListener('fetch', event => {
  event.respondWith(handleImage(event.request));
});

async function handleImage(request) {
  const url = new URL(request.url);
  
  // Parse query parameters
  const width = url.searchParams.get('w');
  const quality = url.searchParams.get('q') || '85';
  const format = url.searchParams.get('f') || 'auto';
  
  // Fetch original image
  const imageUrl = url.pathname;
  const response = await fetch(`https://origin.example.com${imageUrl}`);
  
  // Resize at edge (no origin processing needed!)
  if (width) {
    return new Response(response.body, {
      headers: {
        'Content-Type': response.headers.get('Content-Type'),
        'Cache-Control': 'public, max-age=31536000',
        'CF-Image-Resize': `width=${width},quality=${quality},format=${format}`
      }
    });
  }
  
  return response;
}

// Usage:
// https://cdn.example.com/image.jpg?w=400&q=80&f=webp
// CDN resizes, converts format, and caches at edge
```

### Image Optimization Service

```python
# ============================================
# Image Optimization Service
# ============================================
from PIL import Image
import io

def optimize_image(image_data, width=None, quality=85, format='JPEG'):
    """Optimize image size and quality"""
    img = Image.open(io.BytesIO(image_data))
    
    # Resize if width specified
    if width and img.width > width:
        ratio = width / img.width
        new_height = int(img.height * ratio)
        img = img.resize((width, new_height), Image.LANCZOS)
    
    # Convert to RGB if necessary
    if img.mode in ('RGBA', 'LA', 'P'):
        background = Image.new('RGB', img.size, (255, 255, 255))
        background.paste(img, mask=img.split()[-1] if img.mode == 'RGBA' else None)
        img = background
    
    # Save with optimization
    output = io.BytesIO()
    img.save(output, format=format, quality=quality, optimize=True)
    
    original_size = len(image_data)
    optimized_size = len(output.getvalue())
    
    print(f"Original: {original_size} bytes")
    print(f"Optimized: {optimized_size} bytes")
    print(f"Saved: {(1 - optimized_size/original_size)*100:.1f}%")
    
    return output.getvalue()

# Usage
with open('large-image.jpg', 'rb') as f:
    original = f.read()

# Optimize: resize to 800px width, 80% quality
optimized = optimize_image(original, width=800, quality=80)

# Result:
# Original: 2,500,000 bytes (2.5MB)
# Optimized: 250,000 bytes (250KB)
# Saved: 90%
```

---

## 8. Video Streaming

### Adaptive Bitrate Streaming (HLS)

```python
# ============================================
# HLS (HTTP Live Streaming) Generation
# ============================================
import subprocess

def create_hls_variants(input_video):
    """Create multiple quality variants"""
    
    variants = [
        {'name': '360p', 'width': 640, 'bitrate': '800k'},
        {'name': '480p', 'width': 854, 'bitrate': '1400k'},
        {'name': '720p', 'width': 1280, 'bitrate': '2800k'},
        {'name': '1080p', 'width': 1920, 'bitrate': '5000k'}
    ]
    
    for variant in variants:
        # Generate variant with ffmpeg
        output = f"video_{variant['name']}.m3u8"
        
        subprocess.run([
            'ffmpeg',
            '-i', input_video,
            '-vf', f"scale={variant['width']}:-2",
            '-c:v', 'libx264',
            '-b:v', variant['bitrate'],
            '-c:a', 'aac',
            '-b:a', '128k',
            '-hls_time', '10',  # 10 second segments
            '-hls_list_size', '0',
            '-f', 'hls',
            output
        ])
        
        print(f"Created {variant['name']} variant")
    
    # Create master playlist
    create_master_playlist(variants)

def create_master_playlist(variants):
    """Create master playlist linking all variants"""
    content = '#EXTM3U\n'
    
    for variant in variants:
        bandwidth = int(variant['bitrate'][:-1]) * 1000
        content += f'#EXT-X-STREAM-INF:BANDWIDTH={bandwidth},'
        content += f'RESOLUTION={variant["width"]}x{int(variant["width"]*9/16)}\n'
        content += f'video_{variant["name"]}.m3u8\n'
    
    with open('master.m3u8', 'w') as f:
        f.write(content)
    
    print("Master playlist created")

# Result:
# master.m3u8 (player starts here)
# ├── video_360p.m3u8 (low quality, small bandwidth)
# ├── video_480p.m3u8
# ├── video_720p.m3u8
# └── video_1080p.m3u8 (high quality, large bandwidth)

# Player automatically switches quality based on bandwidth
```

### Video Player with CDN

```html
<!-- ============================================ -->
<!-- HLS Video Player -->
<!-- ============================================ -->
<!DOCTYPE html>
<html>
<head>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
</head>
<body>
  <video id="video" controls width="800"></video>
  
  <script>
    const video = document.getElementById('video');
    const videoSrc = 'https://cdn.example.com/videos/master.m3u8';
    
    if (Hls.isSupported()) {
      const hls = new Hls({
        // Adaptive bitrate settings
        maxBufferLength: 30,        // Buffer 30 seconds
        maxBufferSize: 60 * 1000 * 1000,  // 60MB max buffer
        startLevel: -1,             // Auto-select quality
        
        // Debug
        debug: false
      });
      
      hls.loadSource(videoSrc);
      hls.attachMedia(video);
      
      // Monitor quality changes
      hls.on(Hls.Events.LEVEL_SWITCHED, (event, data) => {
        console.log(`Quality switched to level ${data.level}`);
      });
      
      video.play();
    }
  </script>
</body>
</html>

<!-- User experience:
  - Slow connection: Automatically plays 360p
  - Fast connection: Automatically plays 1080p
  - Connection fluctuates: Seamlessly switches quality
-->
```

---

## 9. HTTP/2 and HTTP/3

### HTTP/1.1 Problems

```
Problem 1: Head-of-line blocking
Request 1 (large file) → blocks → Request 2, 3, 4 wait

Problem 2: Multiple connections needed
6 parallel downloads = 6 TCP connections

Problem 3: Uncompressed headers
Headers sent with every request (wasteful)
```

### HTTP/2 Solutions

```
1. Multiplexing
   Single connection → Multiple concurrent requests
   
2. Server Push
   Server sends resources before client requests
   
3. Header Compression (HPACK)
   Compress headers, send differences only
   
4. Binary Protocol
   Faster parsing than text
```

### HTTP/2 Server Push

```javascript
// ============================================
// Express with HTTP/2 Server Push
// ============================================
const http2 = require('http2');
const fs = require('fs');

const server = http2.createSecureServer({
  key: fs.readFileSync('key.pem'),
  cert: fs.readFileSync('cert.pem')
});

server.on('stream', (stream, headers) => {
  const path = headers[':path'];
  
  if (path === '/') {
    // Push resources before client requests them
    stream.pushStream({ ':path': '/style.css' }, (err, pushStream) => {
      if (!err) {
        pushStream.respond({
          ':status': 200,
          'content-type': 'text/css'
        });
        pushStream.end(fs.readFileSync('style.css'));
      }
    });
    
    stream.pushStream({ ':path': '/script.js' }, (err, pushStream) => {
      if (!err) {
        pushStream.respond({
          ':status': 200,
          'content-type': 'application/javascript'
        });
        pushStream.end(fs.readFileSync('script.js'));
      }
    });
    
    // Send HTML
    stream.respond({
      ':status': 200,
      'content-type': 'text/html'
    });
    stream.end(fs.readFileSync('index.html'));
  }
});

server.listen(8443);

// Client receives:
// 1. HTML
// 2. CSS (pushed)
// 3. JS (pushed)
// All in parallel over single connection!
```

### HTTP/3 (QUIC)

**Advantages over HTTP/2:**
- Built on UDP (not TCP)
- No head-of-line blocking
- Faster connection establishment (0-RTT)
- Better mobile performance

```
HTTP/1.1 connection:
- TCP handshake: 1 RTT
- TLS handshake: 2 RTT
- Total: 3 RTT (~300ms)

HTTP/3 connection:
- QUIC handshake: 0-1 RTT
- Total: 0-1 RTT (~0-100ms)
```

---

## 10. Real-World CDN Configuration

### Nginx as Reverse Proxy Cache

```nginx
# ============================================
# nginx.conf - CDN-like configuration
# ============================================

http {
    # Cache path configuration
    proxy_cache_path /var/cache/nginx/static
                     levels=1:2
                     keys_zone=static_cache:100m
                     max_size=10g
                     inactive=60d
                     use_temp_path=off;
    
    proxy_cache_path /var/cache/nginx/api
                     levels=1:2
                     keys_zone=api_cache:50m
                     max_size=1g
                     inactive=1h;
    
    upstream backend {
        server backend1.example.com:3000;
        server backend2.example.com:3000;
    }
    
    server {
        listen 80;
        server_name cdn.example.com;
        
        # Static content (images, CSS, JS)
        location /static/ {
            proxy_pass http://backend;
            proxy_cache static_cache;
            
            # Cache for 1 year
            proxy_cache_valid 200 365d;
            proxy_cache_valid 404 1m;
            
            # Cache even with Set-Cookie
            proxy_ignore_headers Set-Cookie;
            
            # Add cache status header
            add_header X-Cache-Status $upstream_cache_status;
            add_header Cache-Control "public, max-age=31536000, immutable";
            
            # Enable gzip
            gzip on;
            gzip_types image/jpeg image/png text/css application/javascript;
        }
        
        # API responses (short cache)
        location /api/products {
            proxy_pass http://backend;
            proxy_cache api_cache;
            
            # Cache for 1 minute
            proxy_cache_valid 200 1m;
            
            # Use request method + URI as cache key
            proxy_cache_key "$request_method$request_uri";
            
            # Don't cache if has auth header
            proxy_cache_bypass $http_authorization;
            
            add_header X-Cache-Status $upstream_cache_status;
            add_header Cache-Control "public, max-age=60";
        }
        
        # Don't cache user-specific data
        location /api/user/ {
            proxy_pass http://backend;
            proxy_no_cache 1;
            proxy_cache_bypass 1;
            
            add_header Cache-Control "private, no-cache";
        }
    }
}
```

---

## 11. Performance Metrics

### Measuring CDN Performance

```javascript
// ============================================
// Performance Monitoring
// ============================================

class CDNPerformanceMonitor {
  static measureLoadTime(url) {
    return new Promise((resolve) => {
      const start = performance.now();
      
      fetch(url)
        .then(response => response.blob())
        .then(() => {
          const end = performance.now();
          const duration = end - start;
          
          resolve({
            url,
            duration,
            timestamp: new Date()
          });
        });
    });
  }
  
  static async compareOriginVsCDN() {
    const results = {};
    
    // Measure origin
    results.origin = await this.measureLoadTime(
      'https://origin.example.com/image.jpg'
    );
    
    // Measure CDN
    results.cdn = await this.measureLoadTime(
      'https://cdn.example.com/image.jpg'
    );
    
    const improvement = (
      (results.origin.duration - results.cdn.duration) / 
      results.origin.duration * 100
    );
    
    console.log(`Origin: ${results.origin.duration.toFixed(2)}ms`);
    console.log(`CDN: ${results.cdn.duration.toFixed(2)}ms`);
    console.log(`Improvement: ${improvement.toFixed(1)}%`);
    
    return results;
  }
}

// Usage
CDNPerformanceMonitor.compareOriginVsCDN();

// Example output:
// Origin: 450.23ms
// CDN: 45.67ms
// Improvement: 89.9%
```

---

## Chapter 18 Summary

### Key Concepts

1. **CDN** - Distributed caching network
2. **Edge Computing** - Run code at edge locations
3. **Geographic Distribution** - Deploy in multiple regions
4. **Static Content** - Aggressive caching (1 year)
5. **Dynamic Content** - Short cache or no cache
6. **Cache Headers** - Control caching behavior
7. **Image Optimization** - Responsive images, format conversion
8. **Video Streaming** - Adaptive bitrate (HLS)
9. **HTTP/2** - Multiplexing, server push, compression

### CDN Benefits

| Metric | Without CDN | With CDN | Improvement |
|--------|-------------|----------|-------------|
| **Latency** | 200-500ms | 10-50ms | 10x faster |
| **Bandwidth Cost** | High | Low | 60-80% savings |
| **Origin Load** | High | Low | 90% reduction |
| **Availability** | Single origin | Distributed | Much higher |

### Content Delivery Strategy

```
Static Assets (Images, CSS, JS):
- Serve from CDN
- Cache for 1 year
- Use versioning (app.v123.js)

API Responses:
- Cache public data for 1-5 minutes
- Don't cache user-specific data
- Use ETag for validation

Large Files (Videos):
- Use adaptive streaming (HLS)
- Serve from CDN
- Multiple quality levels

User-Generated Content:
- Upload to S3/GCS
- Serve through CDN
- Optimize on upload
```

### Interview Tips

**Common Questions:**
1. "How does a CDN work?"
2. "How do you optimize image delivery?"
3. "Explain cache headers"
4. "What is edge computing?"

**How to Answer:**
- Draw CDN architecture
- Explain cache hit/miss flow
- Discuss cache headers
- Give latency comparisons with numbers
- Mention specific CDNs (CloudFront, Cloudflare)

### Best Practices

1. **Use CDN for static content** - Images, CSS, JS
2. **Set appropriate cache headers** - Based on content type
3. **Version assets** - Enable long cache times
4. **Optimize images** - Resize, compress, modern formats
5. **Use adaptive streaming** - For videos
6. **Enable compression** - Gzip for text, WebP for images
7. **Implement HTTP/2** - Better performance
8. **Monitor cache hit ratio** - Target > 80%

### Next Steps

Chapter 19 will cover **High Availability Design** - building systems that stay online even when components fail.