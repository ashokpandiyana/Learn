# Chapter 37: DDD Tactical Design - In-Depth Guide

## Introduction to Tactical Design

While Strategic Design focuses on **organizing large systems**, Tactical Design focuses on **implementing the domain model** with patterns that represent business logic clearly and maintainably.

---

## 1. Entities

### Definition
An **Entity** is an object that has a distinct identity that runs through time and different representations. Two entities are considered the same if they have the same identity, regardless of their attribute values.

### Key Characteristics
- Has a unique identity (ID)
- Mutable (can change over time)
- Identity remains constant through lifecycle
- Equality based on identity, not attributes

### Example: Customer Entity

```python
from dataclasses import dataclass
from typing import Optional
from datetime import datetime
import uuid

class Customer:
    """
    Customer is an Entity because:
    - It has a unique identity (customer_id)
    - Two customers with same name are different if they have different IDs
    - Attributes can change but identity remains the same
    """
    def __init__(self, name: str, email: str, customer_id: Optional[str] = None):
        self.customer_id = customer_id or str(uuid.uuid4())
        self.name = name
        self.email = email
        self.created_at = datetime.now()
        self.updated_at = datetime.now()
    
    def update_email(self, new_email: str):
        """Business logic for changing email"""
        if not self._is_valid_email(new_email):
            raise ValueError("Invalid email format")
        
        self.email = new_email
        self.updated_at = datetime.now()
    
    def _is_valid_email(self, email: str) -> bool:
        return "@" in email
    
    def __eq__(self, other):
        """Equality based on identity, not attributes"""
        if not isinstance(other, Customer):
            return False
        return self.customer_id == other.customer_id
    
    def __hash__(self):
        return hash(self.customer_id)
    
    def __repr__(self):
        return f"Customer(id={self.customer_id}, name={self.name})"

# Usage
customer1 = Customer("John Doe", "john@example.com", "CUST-001")
customer2 = Customer("John Doe", "john@example.com", "CUST-002")

print(customer1 == customer2)  # False - different identities
print(customer1 == customer1)  # True - same identity

customer1.update_email("newemail@example.com")
# Still the same customer, just with updated attributes
```

### Example: Order Entity (JavaScript)

```javascript
class Order {
    /**
     * Order is an Entity with:
     * - Unique orderId
     * - Lifecycle (Pending -> Processing -> Shipped -> Delivered)
     * - Mutable state
     */
    constructor(orderId, customerId) {
        this.orderId = orderId || this.generateOrderId();
        this.customerId = customerId;
        this.items = [];
        this.status = OrderStatus.PENDING;
        this.createdAt = new Date();
        this.totalAmount = 0;
    }
    
    generateOrderId() {
        return `ORD-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    
    addItem(product, quantity) {
        if (this.status !== OrderStatus.PENDING) {
            throw new Error('Cannot modify order after it has been submitted');
        }
        
        const lineItem = new LineItem(product, quantity);
        this.items.push(lineItem);
        this.recalculateTotal();
    }
    
    submit() {
        if (this.items.length === 0) {
            throw new Error('Cannot submit empty order');
        }
        this.status = OrderStatus.PROCESSING;
    }
    
    ship(trackingNumber) {
        if (this.status !== OrderStatus.PROCESSING) {
            throw new Error('Order must be in processing state to ship');
        }
        this.status = OrderStatus.SHIPPED;
        this.trackingNumber = trackingNumber;
    }
    
    recalculateTotal() {
        this.totalAmount = this.items.reduce(
            (sum, item) => sum + item.subtotal, 
            0
        );
    }
    
    equals(other) {
        return other instanceof Order && this.orderId === other.orderId;
    }
}

const OrderStatus = {
    PENDING: 'PENDING',
    PROCESSING: 'PROCESSING',
    SHIPPED: 'SHIPPED',
    DELIVERED: 'DELIVERED',
    CANCELLED: 'CANCELLED'
};
```

---

## 2. Value Objects

### Definition
A **Value Object** is an object that represents a descriptive aspect of the domain with no conceptual identity. Two value objects are the same if all their attributes are the same.

### Key Characteristics
- No unique identity
- Immutable
- Equality based on all attributes
- Should be created in a valid state
- Often represent measurements, quantities, or descriptions

### Example: Money Value Object

```python
from dataclasses import dataclass
from decimal import Decimal

@dataclass(frozen=True)  # frozen=True makes it immutable
class Money:
    """
    Money is a Value Object because:
    - $100 USD is the same as any other $100 USD
    - No unique identity needed
    - Immutable - you don't change money, you create new money
    """
    amount: Decimal
    currency: str
    
    def __post_init__(self):
        if self.amount < 0:
            raise ValueError("Amount cannot be negative")
        if not self.currency or len(self.currency) != 3:
            raise ValueError("Currency must be 3-letter code")
    
    def add(self, other: 'Money') -> 'Money':
        """Returns new Money object - immutable"""
        if self.currency != other.currency:
            raise ValueError("Cannot add money in different currencies")
        return Money(self.amount + other.amount, self.currency)
    
    def multiply(self, factor: Decimal) -> 'Money':
        """Returns new Money object"""
        return Money(self.amount * factor, self.currency)
    
    def __str__(self):
        return f"{self.currency} {self.amount:.2f}"

# Usage
price1 = Money(Decimal("100.00"), "USD")
price2 = Money(Decimal("50.00"), "USD")
total = price1.add(price2)  # Creates new Money object
print(total)  # USD 150.00

# Value objects are compared by value
another_100 = Money(Decimal("100.00"), "USD")
print(price1 == another_100)  # True - same value
```

### Example: Address Value Object (JavaScript)

```javascript
class Address {
    /**
     * Address is a Value Object:
     * - Two addresses with same details are considered equal
     * - Immutable - to change address, create new one
     */
    constructor(street, city, state, zipCode, country) {
        // Validate in constructor
        if (!street || !city || !zipCode) {
            throw new Error('Invalid address');
        }
        
        // Use Object.freeze to make immutable
        this._street = street;
        this._city = city;
        this._state = state;
        this._zipCode = zipCode;
        this._country = country || 'USA';
        
        Object.freeze(this);
    }
    
    get street() { return this._street; }
    get city() { return this._city; }
    get state() { return this._state; }
    get zipCode() { return this._zipCode; }
    get country() { return this._country; }
    
    equals(other) {
        if (!(other instanceof Address)) return false;
        return this._street === other._street &&
               this._city === other._city &&
               this._state === other._state &&
               this._zipCode === other._zipCode &&
               this._country === other._country;
    }
    
    toString() {
        return `${this._street}, ${this._city}, ${this._state} ${this._zipCode}, ${this._country}`;
    }
    
    // Create new address instead of modifying
    withStreet(newStreet) {
        return new Address(newStreet, this._city, this._state, this._zipCode, this._country);
    }
}

// Usage
const address1 = new Address('123 Main St', 'Springfield', 'IL', '62701');
const address2 = new Address('123 Main St', 'Springfield', 'IL', '62701');

console.log(address1.equals(address2));  // true - same value

// To "change" address, create a new one
const newAddress = address1.withStreet('456 Oak Ave');
console.log(newAddress.street);  // '456 Oak Ave'
console.log(address1.street);    // '123 Main St' - unchanged
```

### More Value Object Examples

```python
# Email Value Object
class Email:
    def __init__(self, value: str):
        if not self._is_valid(value):
            raise ValueError(f"Invalid email: {value}")
        self._value = value
    
    @property
    def value(self):
        return self._value
    
    def _is_valid(self, email: str) -> bool:
        return "@" in email and "." in email.split("@")[1]
    
    def __eq__(self, other):
        return isinstance(other, Email) and self._value == other._value
    
    def __hash__(self):
        return hash(self._value)

# DateRange Value Object
from datetime import date

class DateRange:
    def __init__(self, start: date, end: date):
        if start > end:
            raise ValueError("Start date must be before end date")
        self._start = start
        self._end = end
    
    @property
    def start(self):
        return self._start
    
    @property
    def end(self):
        return self._end
    
    def contains(self, check_date: date) -> bool:
        return self._start <= check_date <= self._end
    
    def overlaps_with(self, other: 'DateRange') -> bool:
        return (self._start <= other._end and self._end >= other._start)
    
    def __eq__(self, other):
        return (isinstance(other, DateRange) and 
                self._start == other._start and 
                self._end == other._end)
```

---

## 3. Aggregates

### Definition
An **Aggregate** is a cluster of domain objects (entities and value objects) that are treated as a single unit. One entity is the **Aggregate Root**, which is the only member accessible from outside.

### Key Characteristics
- Aggregate Root controls access to members
- Maintains consistency boundaries
- External objects can only reference the root
- Transactions should not span multiple aggregates
- Each aggregate has its own repository

### Why Aggregates Matter
- **Consistency**: Ensures invariants are maintained
- **Encapsulation**: Hides internal complexity
- **Transaction Boundaries**: Defines what changes together
- **Performance**: Right-sized units for database operations

### Example: Order Aggregate

```python
from typing import List
from dataclasses import dataclass

class Order:
    """
    Order is the Aggregate Root
    - Controls access to OrderItems
    - Maintains consistency (total, item limits, etc.)
    - Only way to modify items is through Order methods
    """
    def __init__(self, order_id: str, customer_id: str):
        self.order_id = order_id
        self.customer_id = customer_id
        self._items: List[OrderItem] = []  # Private - not accessible directly
        self.total_amount = Money(Decimal("0"), "USD")
        self.status = OrderStatus.DRAFT
        self.max_items = 50
    
    def add_item(self, product_id: str, name: str, price: Money, quantity: int):
        """
        Only way to add items - maintains invariants
        """
        # Business rule: Maximum 50 items per order
        if len(self._items) >= self.max_items:
            raise DomainException(f"Cannot add more than {self.max_items} items")
        
        # Business rule: Quantity must be positive
        if quantity <= 0:
            raise DomainException("Quantity must be positive")
        
        # Check if item already exists
        existing_item = self._find_item(product_id)
        if existing_item:
            existing_item.increase_quantity(quantity)
        else:
            item = OrderItem(product_id, name, price, quantity)
            self._items.append(item)
        
        self._recalculate_total()
    
    def remove_item(self, product_id: str):
        """Maintain consistency when removing items"""
        item = self._find_item(product_id)
        if not item:
            raise DomainException(f"Item {product_id} not found")
        
        self._items.remove(item)
        self._recalculate_total()
    
    def submit(self):
        """Business logic for submitting order"""
        if not self._items:
            raise DomainException("Cannot submit empty order")
        
        if self.status != OrderStatus.DRAFT:
            raise DomainException("Only draft orders can be submitted")
        
        self.status = OrderStatus.SUBMITTED
    
    def get_items(self) -> List['OrderItem']:
        """Return copy to prevent external modification"""
        return list(self._items)
    
    def _find_item(self, product_id: str) -> 'OrderItem':
        return next((item for item in self._items if item.product_id == product_id), None)
    
    def _recalculate_total(self):
        """Private method - maintains consistency"""
        total = Decimal("0")
        for item in self._items:
            total += item.subtotal.amount
        self.total_amount = Money(total, "USD")

class OrderItem:
    """
    OrderItem is part of the aggregate but NOT the root
    - Can only be accessed through Order
    - No direct repository
    """
    def __init__(self, product_id: str, name: str, unit_price: Money, quantity: int):
        self.product_id = product_id
        self.name = name
        self.unit_price = unit_price
        self.quantity = quantity
        self.subtotal = unit_price.multiply(Decimal(quantity))
    
    def increase_quantity(self, additional: int):
        self.quantity += additional
        self.subtotal = self.unit_price.multiply(Decimal(self.quantity))

class OrderStatus:
    DRAFT = "DRAFT"
    SUBMITTED = "SUBMITTED"
    CONFIRMED = "CONFIRMED"
    SHIPPED = "SHIPPED"
```

### Example: Bank Account Aggregate (JavaScript)

```javascript
class BankAccount {
    /**
     * BankAccount Aggregate Root
     * - Maintains balance consistency
     * - Controls all transactions
     * - Enforces business rules
     */
    constructor(accountId, accountHolder, initialBalance = 0) {
        this.accountId = accountId;
        this.accountHolder = accountHolder;
        this._balance = initialBalance;
        this._transactions = [];  // Part of aggregate
        this.overdraftLimit = 0;
        this.status = 'ACTIVE';
    }
    
    deposit(amount, description) {
        if (amount <= 0) {
            throw new Error('Deposit amount must be positive');
        }
        
        const transaction = new Transaction(
            'DEPOSIT',
            amount,
            description,
            this._balance
        );
        
        this._balance += amount;
        transaction.setNewBalance(this._balance);
        this._transactions.push(transaction);
        
        return transaction;
    }
    
    withdraw(amount, description) {
        if (amount <= 0) {
            throw new Error('Withdrawal amount must be positive');
        }
        
        // Business rule: Cannot exceed overdraft limit
        const availableBalance = this._balance + this.overdraftLimit;
        if (amount > availableBalance) {
            throw new Error('Insufficient funds');
        }
        
        const transaction = new Transaction(
            'WITHDRAWAL',
            -amount,
            description,
            this._balance
        );
        
        this._balance -= amount;
        transaction.setNewBalance(this._balance);
        this._transactions.push(transaction);
        
        return transaction;
    }
    
    transfer(amount, toAccount, description) {
        // Withdraw from this account
        this.withdraw(amount, `Transfer to ${toAccount.accountId}: ${description}`);
        
        // Deposit to target account
        toAccount.deposit(amount, `Transfer from ${this.accountId}: ${description}`);
    }
    
    getBalance() {
        return this._balance;
    }
    
    getTransactions() {
        // Return copy to prevent external modification
        return [...this._transactions];
    }
    
    freeze() {
        this.status = 'FROZEN';
    }
    
    canWithdraw() {
        return this.status === 'ACTIVE';
    }
}

class Transaction {
    /**
     * Transaction is part of BankAccount aggregate
     * - Cannot exist independently
     * - No separate repository
     */
    constructor(type, amount, description, balanceAtTime) {
        this.transactionId = this.generateId();
        this.type = type;
        this.amount = amount;
        this.description = description;
        this.timestamp = new Date();
        this.balanceAtTime = balanceAtTime;
        this.newBalance = null;
    }
    
    generateId() {
        return `TXN-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    
    setNewBalance(balance) {
        this.newBalance = balance;
    }
}

// Usage
const account = new BankAccount('ACC-001', 'John Doe', 1000);
account.deposit(500, 'Salary');
account.withdraw(200, 'ATM Withdrawal');

console.log(`Balance: $${account.getBalance()}`);  // Balance: $1300
console.log(`Transactions: ${account.getTransactions().length}`);  // Transactions: 2
```

### Aggregate Design Guidelines

```python
"""
Good Aggregate Design Principles:
1. Keep aggregates small
2. Reference other aggregates by ID only
3. Use eventual consistency between aggregates
4. One transaction per aggregate
"""

# ✅ GOOD: Small aggregate, references by ID
class Order:
    def __init__(self, order_id: str, customer_id: str):  # Reference customer by ID
        self.order_id = order_id
        self.customer_id = customer_id  # Not a full Customer object
        self._items = []

# ❌ BAD: Large aggregate with nested entities
class Order:
    def __init__(self, order_id: str, customer: Customer):  # Full customer object
        self.order_id = order_id
        self.customer = customer  # Bad: now Customer is part of Order aggregate
        self.customer.addresses = []  # Bad: too much in one aggregate
        self.shipping_address = customer.addresses[0]
        self._items = []
        self.payment = Payment()  # Bad: Payment should be separate aggregate
```

---

## 4. Repositories

### Definition
A **Repository** provides the illusion of an in-memory collection of aggregates. It encapsulates data access logic and provides a clean interface for domain objects.

### Key Characteristics
- One repository per aggregate root
- Hides persistence mechanism
- Provides collection-like interface
- Returns domain objects, not database records

### Example: Order Repository

```python
from abc import ABC, abstractmethod
from typing import List, Optional

class OrderRepository(ABC):
    """
    Abstract repository - domain doesn't care about implementation
    """
    @abstractmethod
    def save(self, order: Order) -> None:
        """Persist or update an order"""
        pass
    
    @abstractmethod
    def find_by_id(self, order_id: str) -> Optional[Order]:
        """Retrieve order by ID"""
        pass
    
    @abstractmethod
    def find_by_customer(self, customer_id: str) -> List[Order]:
        """Find all orders for a customer"""
        pass
    
    @abstractmethod
    def delete(self, order: Order) -> None:
        """Remove an order"""
        pass

# Implementation using PostgreSQL
import psycopg2

class PostgresOrderRepository(OrderRepository):
    def __init__(self, connection):
        self.connection = connection
    
    def save(self, order: Order) -> None:
        cursor = self.connection.cursor()
        
        # Check if order exists
        cursor.execute(
            "SELECT order_id FROM orders WHERE order_id = %s",
            (order.order_id,)
        )
        exists = cursor.fetchone() is not None
        
        if exists:
            # Update existing order
            cursor.execute("""
                UPDATE orders 
                SET customer_id = %s, total_amount = %s, status = %s
                WHERE order_id = %s
            """, (order.customer_id, order.total_amount.amount, 
                  order.status, order.order_id))
            
            # Delete old items
            cursor.execute("DELETE FROM order_items WHERE order_id = %s", 
                          (order.order_id,))
        else:
            # Insert new order
            cursor.execute("""
                INSERT INTO orders (order_id, customer_id, total_amount, status)
                VALUES (%s, %s, %s, %s)
            """, (order.order_id, order.customer_id, 
                  order.total_amount.amount, order.status))
        
        # Insert items
        for item in order.get_items():
            cursor.execute("""
                INSERT INTO order_items 
                (order_id, product_id, name, unit_price, quantity, subtotal)
                VALUES (%s, %s, %s, %s, %s, %s)
            """, (order.order_id, item.product_id, item.name,
                  item.unit_price.amount, item.quantity, 
                  item.subtotal.amount))
        
        self.connection.commit()
    
    def find_by_id(self, order_id: str) -> Optional[Order]:
        cursor = self.connection.cursor()
        
        # Fetch order
        cursor.execute("""
            SELECT order_id, customer_id, total_amount, status
            FROM orders WHERE order_id = %s
        """, (order_id,))
        
        row = cursor.fetchone()
        if not row:
            return None
        
        # Reconstruct aggregate root
        order = Order(row[0], row[1])
        order.total_amount = Money(Decimal(row[2]), "USD")
        order.status = row[3]
        
        # Fetch items
        cursor.execute("""
            SELECT product_id, name, unit_price, quantity
            FROM order_items WHERE order_id = %s
        """, (order_id,))
        
        for item_row in cursor.fetchall():
            price = Money(Decimal(item_row[2]), "USD")
            order.add_item(item_row[0], item_row[1], price, item_row[3])
        
        return order
    
    def find_by_customer(self, customer_id: str) -> List[Order]:
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT order_id FROM orders WHERE customer_id = %s
        """, (customer_id,))
        
        orders = []
        for row in cursor.fetchall():
            order = self.find_by_id(row[0])
            if order:
                orders.append(order)
        
        return orders
    
    def delete(self, order: Order) -> None:
        cursor = self.connection.cursor()
        cursor.execute("DELETE FROM order_items WHERE order_id = %s", 
                      (order.order_id,))
        cursor.execute("DELETE FROM orders WHERE order_id = %s", 
                      (order.order_id,))
        self.connection.commit()
```

### Repository Usage in Application Service

```python
class OrderService:
    def __init__(self, order_repository: OrderRepository):
        self.order_repository = order_repository
    
    def place_order(self, customer_id: str, items: List[dict]):
        # Create aggregate
        order = Order(generate_order_id(), customer_id)
        
        # Add items through aggregate root
        for item_data in items:
            price = Money(Decimal(item_data['price']), "USD")
            order.add_item(
                item_data['product_id'],
                item_data['name'],
                price,
                item_data['quantity']
            )
        
        # Submit order (business logic)
        order.submit()
        
        # Persist through repository
        self.order_repository.save(order)
        
        return order.order_id
```

---

## 5. Factories

### Definition
A **Factory** encapsulates the logic of creating complex domain objects and aggregates. It ensures objects are created in a valid state.

### When to Use Factories
- Complex creation logic
- Multiple steps required
- Need to enforce invariants during creation
- Reconstitution from database

### Example: Order Factory

```python
class OrderFactory:
    """
    Factory for creating Order aggregates
    """
    @staticmethod
    def create_new_order(customer_id: str) -> Order:
        """Create a fresh order"""
        order_id = OrderFactory._generate_order_id()
        return Order(order_id, customer_id)
    
    @staticmethod
    def create_from_data(data: dict) -> Order:
        """Reconstitute order from database data"""
        order = Order(data['order_id'], data['customer_id'])
        order.status = data['status']
        order.total_amount = Money(Decimal(data['total_amount']), "USD")
        
        for item_data in data.get('items', []):
            price = Money(Decimal(item_data['unit_price']), "USD")
            order.add_item(
                item_data['product_id'],
                item_data['name'],
                price,
                item_data['quantity']
            )
        
        return order
    
    @staticmethod
    def _generate_order_id() -> str:
        return f"ORD-{datetime.now().strftime('%Y%m%d')}-{uuid.uuid4().hex[:8]}"

# Usage
order = OrderFactory.create_new_order("CUST-123")
```

### Example: Complex Factory (JavaScript)

```javascript
class UserFactory {
    /**
     * Factory for creating User aggregates with validation
     */
    static createNewUser(email, password, userType) {
        // Validate inputs
        if (!this.isValidEmail(email)) {
            throw new Error('Invalid email format');
        }
        
        if (!this.isStrongPassword(password)) {
            throw new Error('Password does not meet requirements');
        }
        
        const userId = this.generateUserId();
        const hashedPassword = this.hashPassword(password);
        
        // Create appropriate user type
        switch(userType) {
            case 'ADMIN':
                return new AdminUser(userId, email, hashedPassword);
            case 'PREMIUM':
                return new PremiumUser(userId, email, hashedPassword);
            default:
                return new StandardUser(userId, email, hashedPassword);
        }
    }
    
    static fromDatabase(userData) {
        // Reconstitute from database
        const user = new User(userData.userId, userData.email);
        user.createdAt = new Date(userData.createdAt);
        user.lastLogin = userData.lastLogin ? new Date(userData.lastLogin) : null;
        user.isActive = userData.isActive;
        return user;
    }
    
    static generateUserId() {
        return `USER-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    
    static hashPassword(password) {
        // Simple hash for example (use bcrypt in production)
        return Buffer.from(password).toString('base64');
    }
    
    static isValidEmail(email) {
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    }
    
    static isStrongPassword(password) {
        return password.length >= 8 && /[A-Z]/.test(password) && /[0-9]/.test(password);
    }
}
```

---

## 6. Domain Events

### Definition
A **Domain Event** is something that happened in the domain that domain experts care about. Events represent state changes and trigger side effects.

### Key Characteristics
- Immutable
- Past tense naming (OrderPlaced, PaymentProcessed)
- Contains relevant data
- Timestamp
- Can trigger other actions

### Example: Domain Events in E-Commerce

```python
from dataclasses import dataclass
from datetime import datetime
from typing import List

@dataclass(frozen=True)
class DomainEvent:
    """Base class for all domain events"""
    event_id: str
    occurred_at: datetime

@dataclass(frozen=True)
class OrderPlacedEvent(DomainEvent):
    """Event fired when an order is placed"""
    order_id: str
    customer_id: str
    total_amount: float
    items: List[dict]

@dataclass(frozen=True)
class OrderShippedEvent(DomainEvent):
    """Event fired when an order is shipped"""
    order_id: str
    tracking_number: str
    carrier: str

@dataclass(frozen=True)
class PaymentProcessedEvent(DomainEvent):
    """Event fired when payment is processed"""
    payment_id: str
    order_id: str
    amount: float
    payment_method: str

# Order aggregate that raises events
class Order:
    def __init__(self, order_id: str, customer_id: str):
        self.order_id = order_id
        self.customer_id = customer_id
        self._items = []
        self.status = OrderStatus.DRAFT
        self._domain_events: List[DomainEvent] = []  # Event queue
    
    def submit(self):
        if not self._items:
            raise DomainException("Cannot submit empty order")
        
        self.status = OrderStatus.SUBMITTED
        
        # Raise domain event
        event = OrderPlacedEvent(
            event_id=str(uuid.uuid4()),
            occurred_at=datetime.now(),
            order_id=self.order_id,
            customer_id=self.customer_id,
            total_amount=self.total_amount.amount,
            items=[{'product_id': item.product_id, 'quantity': item.quantity} 
                   for item in self._items]
        )
        self._domain_events.append(event)
    
    def ship(self, tracking_number: str, carrier: str):
        if self.status != OrderStatus.CONFIRMED:
            raise DomainException("Can only ship confirmed orders")
        
        self.status = OrderStatus.SHIPPED
        self.tracking_number = tracking_number
        
        # Raise event
        event = OrderShippedEvent(
            event_id=str(uuid.uuid4()),
            occurred_at=datetime.now(),
            order_id=self.order_id,
            tracking_number=tracking_number,
            carrier=carrier
        )
        self._domain_events.append(event)
    
    def get_domain_events(self) -> List[DomainEvent]:
        """Get events to be published"""
        return list(self._domain_events)
    
    def clear_domain_events(self):
        """Clear events after publishing"""
        self._domain_events.clear()

# Event Handlers
class OrderEventHandler:
    def __init__(self, email_service, inventory_service):
        self.email_service = email_service
        self.inventory_service = inventory_service
    
    def handle_order_placed(self, event: OrderPlacedEvent):
        """React to OrderPlacedEvent"""
        # Send confirmation email
        self.email_service.send_order_confirmation(
            event.customer_id, 
            event.order_id
        )
        
        # Reserve inventory
        for item in event.items:
            self.inventory_service.reserve_stock(
                item['product_id'], 
                item['quantity']
            )
    
    def handle_order_shipped(self, event: OrderShippedEvent):
        """React to OrderShippedEvent"""
        # Send shipping notification
        self.email_service.send_shipping_notification(
            event.order_id,
            event.tracking_number
        )

# Application Service that publishes events
class OrderService:
    def __init__(self, order_repository, event_publisher):
        self.order_repository = order_repository
        self.event_publisher = event_publisher
    
    def place_order(self, customer_id: str, items: List[dict]):
        order = Order(generate_order_id(), customer_id)
        
        for item in items:
            order.add_item(item['product_id'], item['name'], 
                          Money(Decimal(item['price']), "USD"), 
                          item['quantity'])
        
        order.submit()  # This raises OrderPlacedEvent
        
        # Save order
        self.order_repository.save(order)
        
        # Publish events
        for event in order.get_domain_events():
            self.event_publisher.publish(event)
        
        order.clear_domain_events()
        
        return order.order_id
```

---

## Putting It All Together: Complete Example

```python
"""
Complete DDD Tactical Pattern Example: Banking Domain
"""

# Value Objects
class Money:
    def __init__(self, amount: Decimal, currency: str):
        self.amount = amount
        self.currency = currency

# Entities
class Transaction:
    def __init__(self, transaction_id: str, amount: Money, type: str):
        self.transaction_id = transaction_id
        self.amount = amount
        self.type = type
        self.timestamp = datetime.now()

# Aggregate Root
class BankAccount:
    def __init__(self, account_id: str, owner_id: str, initial_balance: Money):
        self.account_id = account_id
        self.owner_id = owner_id
        self._balance = initial_balance
        self._transactions: List[Transaction] = []
        self._domain_events: List[DomainEvent] = []
    
    def deposit(self, amount: Money) -> Transaction:
        if amount.currency != self._balance.currency:
            raise DomainException("Currency mismatch")
        
        transaction = Transaction(
            generate_transaction_id(),
            amount,
            "DEPOSIT"
        )
        
        self._transactions.append(transaction)
        self._balance = Money(
            self._balance.amount + amount.amount,
            self._balance.currency
        )
        
        # Raise event
        event = MoneyDepositedEvent(
            event_id=str(uuid.uuid4()),
            occurred_at=datetime.now(),
            account_id=self.account_id,
            amount=amount.amount
        )
        self._domain_events.append(event)
        
        return transaction
    
    def get_balance(self) -> Money:
        return Money(self._balance.amount, self._balance.currency)

# Repository
class BankAccountRepository(ABC):
    @abstractmethod
    def save(self, account: BankAccount) -> None:
        pass
    
    @abstractmethod
    def find_by_id(self, account_id: str) -> Optional[BankAccount]:
        pass

# Factory
class BankAccountFactory:
    @staticmethod
    def create_account(owner_id: str, initial_deposit: Money) -> BankAccount:
        if initial_deposit.amount < Decimal("100"):
            raise DomainException("Minimum initial deposit is $100")
        
        account_id = f"ACC-{uuid.uuid4().hex[:8]}"
        return BankAccount(account_id, owner_id, initial_deposit)

# Domain Service
class BankingService:
    def __init__(self, account_repository: BankAccountRepository):
        self.account_repository = account_repository
    
    def transfer_money(self, from_account_id: str, to_account_id: str, 
                      amount: Money):
        from_account = self.account_repository.find_by_id(from_account_id)
        to_account = self.account_repository.find_by_id(to_account_id)
        
        if not from_account or not to_account:
            raise DomainException("Account not found")
        
        # Business logic coordinates between two aggregates
        from_account.withdraw(amount)
        to_account.deposit(amount)
        
        self.account_repository.save(from_account)
        self.account_repository.save(to_account)
```

---

## Key Takeaways

1. **Entities** have identity and lifecycle - use for things that change over time
2. **Value Objects** are immutable and compared by value - use for measurements and descriptions
3. **Aggregates** maintain consistency boundaries - keep them small and focused
4. **Repositories** abstract data access - one per aggregate root
5. **Factories** encapsulate complex creation - ensure valid initial state
6. **Domain Events** capture what happened - enable reactive behavior

The tactical patterns work together to create a rich, maintainable domain model that accurately represents business logic.