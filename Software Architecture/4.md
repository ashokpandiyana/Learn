# Chapter 4: Layered Architecture

## Table of Contents
1. Introduction to Layered Architecture
2. Three-Tier Architecture
3. N-Tier Architecture
4. Implementation Examples
5. Advantages and Disadvantages
6. Best Practices
7. When to Use Layered Architecture

---

## 1. Introduction to Layered Architecture

**Definition:** Layered (or N-Tier) architecture organizes the system into layers, where each layer has a specific role and responsibility. Each layer provides services to the layer above it and uses services from the layer below it.

**Core Principle:** **Separation of Concerns** - Each layer handles a specific aspect of the application.

### Key Characteristics

1. **Unidirectional Dependencies** - Higher layers depend on lower layers, never the reverse
2. **Abstraction** - Each layer hides implementation details from layers above
3. **Modularity** - Clear boundaries between layers
4. **Testability** - Each layer can be tested independently

### Common Layer Structure

```
┌─────────────────────────────────┐
│   Presentation Layer           │  ← User Interface, API Controllers
├─────────────────────────────────┤
│   Business Logic Layer         │  ← Business Rules, Domain Logic
├─────────────────────────────────┤
│   Data Access Layer            │  ← Database Operations, ORM
├─────────────────────────────────┤
│   Database Layer               │  ← Persistent Storage
└─────────────────────────────────┘
```

---

## 2. Three-Tier Architecture

The most common layered architecture pattern consists of three primary tiers:

### 2.1 Presentation Layer (UI Layer)

**Responsibilities:**
- Handle user interactions
- Display data to users
- Validate user input (basic validation)
- Route requests to business layer
- Transform business objects to UI models

**Technologies:**
- **Web:** React, Angular, Vue.js, HTML/CSS
- **Mobile:** React Native, Flutter, Swift, Kotlin
- **Desktop:** Electron, WPF, JavaFX
- **Backend:** REST Controllers, GraphQL Resolvers

**Example - REST API Controller (Node.js/Express):**

```javascript
// Presentation Layer - User Controller
const express = require('express');
const router = express.Router();
const UserService = require('../services/UserService');

class UserController {
    constructor() {
        this.userService = new UserService();
    }
    
    // GET /api/users/:id
    async getUserById(req, res) {
        try {
            // 1. Extract and validate input
            const userId = parseInt(req.params.id);
            if (isNaN(userId)) {
                return res.status(400).json({ 
                    error: 'Invalid user ID' 
                });
            }
            
            // 2. Call business layer
            const user = await this.userService.getUserById(userId);
            
            // 3. Transform to DTO (Data Transfer Object)
            const userDTO = {
                id: user.id,
                name: user.name,
                email: user.email,
                // Don't expose password or internal fields
            };
            
            // 4. Return response
            return res.status(200).json(userDTO);
            
        } catch (error) {
            console.error('Error in getUserById:', error);
            return res.status(500).json({ 
                error: 'Internal server error' 
            });
        }
    }
    
    // POST /api/users
    async createUser(req, res) {
        try {
            // 1. Validate request body
            const { name, email, password } = req.body;
            
            if (!name || !email || !password) {
                return res.status(400).json({ 
                    error: 'Missing required fields' 
                });
            }
            
            // 2. Call business layer
            const newUser = await this.userService.createUser({
                name,
                email,
                password
            });
            
            // 3. Return created resource
            return res.status(201).json({
                id: newUser.id,
                name: newUser.name,
                email: newUser.email
            });
            
        } catch (error) {
            if (error.message === 'Email already exists') {
                return res.status(409).json({ error: error.message });
            }
            return res.status(500).json({ 
                error: 'Internal server error' 
            });
        }
    }
}

module.exports = UserController;
```

**Key Points:**
- Controllers should be **thin** - minimal logic
- Only handle HTTP concerns (request/response)
- Delegate business logic to service layer
- Transform between DTOs and domain models

---

### 2.2 Business Logic Layer (Service Layer)

**Responsibilities:**
- Implement business rules and workflows
- Coordinate between presentation and data layers
- Validate business rules
- Handle transactions
- Apply business logic transformations

**Example - Service Layer (Node.js):**

```javascript
// Business Logic Layer - User Service
const UserRepository = require('../repositories/UserRepository');
const EmailService = require('./EmailService');
const bcrypt = require('bcrypt');

class UserService {
    constructor() {
        this.userRepository = new UserRepository();
        this.emailService = new EmailService();
    }
    
    async getUserById(userId) {
        // Business validation
        if (userId <= 0) {
            throw new Error('Invalid user ID');
        }
        
        // Fetch from data layer
        const user = await this.userRepository.findById(userId);
        
        if (!user) {
            throw new Error('User not found');
        }
        
        return user;
    }
    
    async createUser(userData) {
        // Business validation
        this._validateUserData(userData);
        
        // Check if email already exists (business rule)
        const existingUser = await this.userRepository.findByEmail(
            userData.email
        );
        
        if (existingUser) {
            throw new Error('Email already exists');
        }
        
        // Business logic - hash password
        const hashedPassword = await bcrypt.hash(userData.password, 10);
        
        // Create user through data layer
        const newUser = await this.userRepository.create({
            name: userData.name,
            email: userData.email,
            password: hashedPassword,
            createdAt: new Date(),
            status: 'active'  // Business rule: new users are active
        });
        
        // Business workflow - send welcome email
        await this.emailService.sendWelcomeEmail(newUser.email, newUser.name);
        
        return newUser;
    }
    
    async updateUserProfile(userId, updates) {
        // Get existing user
        const user = await this.getUserById(userId);
        
        // Business rules
        if (updates.email && updates.email !== user.email) {
            // Check if new email is available
            const emailTaken = await this.userRepository.findByEmail(
                updates.email
            );
            if (emailTaken) {
                throw new Error('Email already in use');
            }
        }
        
        // Apply updates
        const updatedUser = await this.userRepository.update(userId, {
            name: updates.name || user.name,
            email: updates.email || user.email,
            updatedAt: new Date()
        });
        
        return updatedUser;
    }
    
    async deactivateUser(userId, reason) {
        const user = await this.getUserById(userId);
        
        // Business rule: can't deactivate already inactive users
        if (user.status === 'inactive') {
            throw new Error('User is already inactive');
        }
        
        // Business logic: soft delete
        await this.userRepository.update(userId, {
            status: 'inactive',
            deactivatedAt: new Date(),
            deactivationReason: reason
        });
        
        // Workflow: notify user
        await this.emailService.sendDeactivationEmail(user.email);
        
        return true;
    }
    
    _validateUserData(userData) {
        if (!userData.name || userData.name.length < 2) {
            throw new Error('Name must be at least 2 characters');
        }
        
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(userData.email)) {
            throw new Error('Invalid email format');
        }
        
        if (!userData.password || userData.password.length < 8) {
            throw new Error('Password must be at least 8 characters');
        }
    }
}

module.exports = UserService;
```

**Key Points:**
- Contains **all business logic**
- No knowledge of HTTP, database technology, or UI
- Coordinates between different repositories
- Implements workflows and business rules

---

### 2.3 Data Access Layer (Repository Layer)

**Responsibilities:**
- Abstract database operations
- Provide CRUD operations
- Handle database connections
- Execute queries
- Map database records to domain objects

**Example - Repository Layer (Node.js with PostgreSQL):**

```javascript
// Data Access Layer - User Repository
const { Pool } = require('pg');

class UserRepository {
    constructor() {
        this.pool = new Pool({
            host: process.env.DB_HOST,
            port: process.env.DB_PORT,
            database: process.env.DB_NAME,
            user: process.env.DB_USER,
            password: process.env.DB_PASSWORD
        });
    }
    
    async findById(userId) {
        const query = 'SELECT * FROM users WHERE id = $1';
        const result = await this.pool.query(query, [userId]);
        
        if (result.rows.length === 0) {
            return null;
        }
        
        return this._mapToUser(result.rows[0]);
    }
    
    async findByEmail(email) {
        const query = 'SELECT * FROM users WHERE email = $1';
        const result = await this.pool.query(query, [email]);
        
        if (result.rows.length === 0) {
            return null;
        }
        
        return this._mapToUser(result.rows[0]);
    }
    
    async create(userData) {
        const query = `
            INSERT INTO users (name, email, password, created_at, status)
            VALUES ($1, $2, $3, $4, $5)
            RETURNING *
        `;
        
        const values = [
            userData.name,
            userData.email,
            userData.password,
            userData.createdAt,
            userData.status
        ];
        
        const result = await this.pool.query(query, values);
        return this._mapToUser(result.rows[0]);
    }
    
    async update(userId, updates) {
        const query = `
            UPDATE users
            SET name = $1, email = $2, updated_at = $3
            WHERE id = $4
            RETURNING *
        `;
        
        const values = [
            updates.name,
            updates.email,
            updates.updatedAt || new Date(),
            userId
        ];
        
        const result = await this.pool.query(query, values);
        
        if (result.rows.length === 0) {
            throw new Error('User not found');
        }
        
        return this._mapToUser(result.rows[0]);
    }
    
    async delete(userId) {
        const query = 'DELETE FROM users WHERE id = $1';
        const result = await this.pool.query(query, [userId]);
        return result.rowCount > 0;
    }
    
    async findAll(limit = 100, offset = 0) {
        const query = `
            SELECT * FROM users
            ORDER BY created_at DESC
            LIMIT $1 OFFSET $2
        `;
        
        const result = await this.pool.query(query, [limit, offset]);
        return result.rows.map(row => this._mapToUser(row));
    }
    
    // Private helper to map database row to domain object
    _mapToUser(row) {
        return {
            id: row.id,
            name: row.name,
            email: row.email,
            password: row.password,
            createdAt: row.created_at,
            updatedAt: row.updated_at,
            status: row.status,
            deactivatedAt: row.deactivated_at,
            deactivationReason: row.deactivation_reason
        };
    }
}

module.exports = UserRepository;
```

**Key Points:**
- Only layer that knows about database
- Abstracts SQL/query details
- Maps between database schema and domain objects
- No business logic - purely data operations

---

## 3. N-Tier Architecture

N-Tier extends the three-tier model by adding more specialized layers.

### Common N-Tier Layers

```
┌─────────────────────────────────┐
│   Presentation Layer           │
├─────────────────────────────────┤
│   Application Layer            │  ← Use Case orchestration
├─────────────────────────────────┤
│   Domain Layer                 │  ← Core business entities
├─────────────────────────────────┤
│   Infrastructure Layer         │  ← External services, DB
└─────────────────────────────────┘
```

### Example - E-Commerce System (Java/Spring Boot)

```java
// ============================================
// PRESENTATION LAYER - REST Controller
// ============================================
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @Autowired
    private OrderService orderService;
    
    @PostMapping
    public ResponseEntity<OrderDTO> createOrder(@RequestBody CreateOrderRequest request) {
        try {
            Order order = orderService.createOrder(
                request.getCustomerId(),
                request.getItems()
            );
            
            OrderDTO dto = OrderMapper.toDTO(order);
            return ResponseEntity.status(HttpStatus.CREATED).body(dto);
            
        } catch (InsufficientStockException e) {
            return ResponseEntity.status(HttpStatus.CONFLICT)
                .body(null);
        }
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<OrderDTO> getOrder(@PathVariable Long id) {
        Order order = orderService.getOrderById(id);
        return ResponseEntity.ok(OrderMapper.toDTO(order));
    }
}

// ============================================
// APPLICATION LAYER - Service (Use Cases)
// ============================================
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private InventoryService inventoryService;
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private NotificationService notificationService;
    
    public Order createOrder(Long customerId, List<OrderItem> items) {
        // 1. Validate inventory
        for (OrderItem item : items) {
            if (!inventoryService.hasStock(item.getProductId(), item.getQuantity())) {
                throw new InsufficientStockException(
                    "Product " + item.getProductId() + " out of stock"
                );
            }
        }
        
        // 2. Calculate total
        BigDecimal total = items.stream()
            .map(item -> item.getPrice().multiply(
                new BigDecimal(item.getQuantity())
            ))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        // 3. Create order (domain logic)
        Order order = new Order();
        order.setCustomerId(customerId);
        order.setItems(items);
        order.setTotal(total);
        order.setStatus(OrderStatus.PENDING);
        order.setCreatedAt(LocalDateTime.now());
        
        // 4. Save order
        order = orderRepository.save(order);
        
        // 5. Reserve inventory
        for (OrderItem item : items) {
            inventoryService.reserveStock(item.getProductId(), item.getQuantity());
        }
        
        // 6. Process payment
        try {
            paymentService.processPayment(order.getId(), total);
            order.setStatus(OrderStatus.PAID);
        } catch (PaymentException e) {
            order.setStatus(OrderStatus.PAYMENT_FAILED);
            // Rollback inventory
            for (OrderItem item : items) {
                inventoryService.releaseStock(item.getProductId(), item.getQuantity());
            }
            throw e;
        }
        
        // 7. Send confirmation
        notificationService.sendOrderConfirmation(customerId, order);
        
        return orderRepository.save(order);
    }
    
    public Order getOrderById(Long orderId) {
        return orderRepository.findById(orderId)
            .orElseThrow(() -> new OrderNotFoundException("Order not found: " + orderId));
    }
}

// ============================================
// DOMAIN LAYER - Business Entities
// ============================================
@Entity
@Table(name = "orders")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private Long customerId;
    
    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id")
    private List<OrderItem> items;
    
    @Column(nullable = false)
    private BigDecimal total;
    
    @Enumerated(EnumType.STRING)
    private OrderStatus status;
    
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // Business methods
    public void cancel() {
        if (this.status == OrderStatus.SHIPPED) {
            throw new IllegalStateException("Cannot cancel shipped order");
        }
        this.status = OrderStatus.CANCELLED;
        this.updatedAt = LocalDateTime.now();
    }
    
    public boolean canBeRefunded() {
        return this.status == OrderStatus.DELIVERED 
            && ChronoUnit.DAYS.between(this.createdAt, LocalDateTime.now()) <= 30;
    }
    
    // Getters and setters...
}

@Entity
@Table(name = "order_items")
public class OrderItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private Long productId;
    private String productName;
    private BigDecimal price;
    private Integer quantity;
    
    public BigDecimal getSubtotal() {
        return price.multiply(new BigDecimal(quantity));
    }
    
    // Getters and setters...
}

// ============================================
// INFRASTRUCTURE LAYER - Repository
// ============================================
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    List<Order> findByCustomerId(Long customerId);
    
    List<Order> findByStatus(OrderStatus status);
    
    @Query("SELECT o FROM Order o WHERE o.createdAt >= :startDate AND o.createdAt <= :endDate")
    List<Order> findByDateRange(
        @Param("startDate") LocalDateTime startDate,
        @Param("endDate") LocalDateTime endDate
    );
}

// External service integration
@Service
public class PaymentService {
    
    @Autowired
    private PaymentGatewayClient paymentGateway;
    
    public void processPayment(Long orderId, BigDecimal amount) {
        PaymentRequest request = new PaymentRequest();
        request.setOrderId(orderId);
        request.setAmount(amount);
        request.setCurrency("USD");
        
        PaymentResponse response = paymentGateway.charge(request);
        
        if (!response.isSuccess()) {
            throw new PaymentException("Payment failed: " + response.getError());
        }
    }
}
```

---

## 4. Advantages and Disadvantages

### ✅ Advantages

**1. Separation of Concerns**
- Each layer has clear responsibility
- Easier to understand and maintain
- Changes localized to specific layers

**2. Testability**
```java
// Easy to test business layer in isolation
@Test
public void testCreateOrder_InsufficientStock() {
    // Mock dependencies
    when(inventoryService.hasStock(1L, 5)).thenReturn(false);
    
    // Test business logic
    assertThrows(InsufficientStockException.class, () -> {
        orderService.createOrder(customerId, items);
    });
}
```

**3. Reusability**
- Business logic can be used by multiple presentation layers (web, mobile, CLI)
- Data access layer can be reused across services

**4. Independent Development**
- Teams can work on different layers simultaneously
- Frontend and backend teams work independently

**5. Technology Flexibility**
- Can change database without affecting business layer
- Can swap UI framework without changing business logic

### ❌ Disadvantages

**1. Performance Overhead**
```
Request → Controller → Service → Repository → Database
                                            ↓
Response ← Controller ← Service ← Repository ← Database
```
- Multiple layers add latency
- More object creation and copying

**2. Can Become Monolithic**
- All layers typically deployed together
- Tight coupling can develop over time
- Difficult to scale individual components

**3. Potential Over-Engineering**
```python
# Simple operation becomes verbose
def get_user(user_id):
    # Could be one query, but goes through 3 layers
    controller = UserController()
    service = UserService()
    repository = UserRepository()
    return controller.get(user_id)  # Calls service, which calls repository
```

**4. Cross-Cutting Concerns**
- Logging, security, caching span all layers
- Can be repetitive to implement

**5. Changes Ripple Across Layers**
```
Add new field to User
↓
1. Update database schema
2. Update repository mapping
3. Update domain model
4. Update service logic
5. Update DTO
6. Update controller
```

---

## 5. Best Practices

### 5.1 Strict Layer Isolation

**❌ Bad: Skipping Layers**
```python
# Controller directly accessing repository
class UserController:
    def get_user(self, user_id):
        # BAD: Controller talking directly to repository
        return UserRepository().find_by_id(user_id)
```

**✅ Good: Respecting Layer Boundaries**
```python
class UserController:
    def __init__(self, user_service):
        self.user_service = user_service
    
    def get_user(self, user_id):
        # GOOD: Go through service layer
        return self.user_service.get_user_by_id(user_id)
```

### 5.2 Use Dependency Injection

**✅ Good Example:**
```typescript
// Inject dependencies, don't create them
class OrderService {
    constructor(
        private orderRepository: IOrderRepository,
        private inventoryService: IInventoryService,
        private paymentService: IPaymentService
    ) {}
    
    async createOrder(order: Order): Promise<Order> {
        // Use injected dependencies
        await this.inventoryService.reserve(order.items);
        await this.paymentService.process(order.total);
        return this.orderRepository.save(order);
    }
}

// Easy to test with mocks
const mockRepo = new MockOrderRepository();
const mockInventory = new MockInventoryService();
const mockPayment = new MockPaymentService();
const service = new OrderService(mockRepo, mockInventory, mockPayment);
```

### 5.3 Keep DTOs Separate from Domain Models

```csharp
// Domain model - rich with business logic
public class Order {
    public long Id { get; set; }
    public List<OrderItem> Items { get; set; }
    public decimal Total { get; set; }
    public OrderStatus Status { get; set; }
    
    // Business logic
    public void Cancel() {
        if (Status == OrderStatus.Shipped)
            throw new InvalidOperationException("Cannot cancel shipped order");
        Status = OrderStatus.Cancelled;
    }
    
    public bool CanRefund() {
        return Status == OrderStatus.Delivered 
            && (DateTime.Now - CreatedAt).Days <= 30;
    }
}

// DTO - simple data transfer, no logic
public class OrderDTO {
    public long Id { get; set; }
    public decimal Total { get; set; }
    public string Status { get; set; }
    public DateTime CreatedAt { get; set; }
    // Only data needed by client
}
```

### 5.4 Handle Cross-Cutting Concerns with Middleware/AOP

```javascript
// Logging middleware (cross-cutting concern)
function loggingMiddleware(req, res, next) {
    console.log(`${req.method} ${req.path}`);
    const start = Date.now();
    
    res.on('finish', () => {
        const duration = Date.now() - start;
        console.log(`Response: ${res.statusCode} (${duration}ms)`);
    });
    
    next();
}

// Authentication middleware
function authMiddleware(req, res, next) {
    const token = req.headers.authorization;
    if (!token) {
        return res.status(401).json({ error: 'Unauthorized' });
    }
    // Verify token...
    next();
}

// Apply to all routes
app.use(loggingMiddleware);
app.use(authMiddleware);
```

---

## 6. When to Use Layered Architecture

### ✅ Good Fit For:

**1. Traditional Enterprise Applications**
- HR systems, CRM, ERP
- Well-defined business logic
- CRUD-heavy operations

**2. Small to Medium Applications**
- Single team (< 20 developers)
- Clear domain boundaries
- Simple deployment requirements

**3. Rapid Development**
- Need to ship quickly
- Familiar pattern to most developers
- Plenty of frameworks support this (Spring Boot, ASP.NET, Django)

**4. Learning Projects**
- Easy to understand
- Good introduction to software architecture
- Clear separation helps beginners

### ❌ Not Ideal For:

**1. Microservices**
- Need independent deployment
- Different scaling requirements per service
- Multiple teams working independently

**2. Real-Time Systems**
- Layer overhead adds latency
- Need direct hardware access
- High-performance requirements

**3. Complex Domain Logic**
- Consider Domain-Driven Design instead
- Layered architecture can become messy with complex domains
- May need Event Sourcing or CQRS

**4. Highly Distributed Systems**
- Multiple data sources
- Complex integration patterns
- Event-driven requirements

---

## 7. Real-World Example: Complete Application

Let's build a simple blog application with layered architecture:

```python
# ============================================
# PRESENTATION LAYER - Flask Controllers
# ============================================
from flask import Flask, request, jsonify
from services.post_service import PostService
from services.comment_service import CommentService

app = Flask(__name__)
post_service = PostService()
comment_service = CommentService()

@app.route('/posts', methods=['POST'])
def create_post():
    data = request.json
    
    # Validate input
    if not data.get('title') or not data.get('content'):
        return jsonify({'error': 'Title and content required'}), 400
    
    # Call service layer
    post = post_service.create_post(
        title=data['title'],
        content=data['content'],
        author_id=data['author_id']
    )
    
    return jsonify(post.to_dict()), 201

@app.route('/posts/<int:post_id>', methods=['GET'])
def get_post(post_id):
    post = post_service.get_post_with_comments(post_id)
    return jsonify(post.to_dict(include_comments=True)), 200

@app.route('/posts/<int:post_id>/comments', methods=['POST'])
def add_comment(post_id):
    data = request.json
    comment = comment_service.add_comment(
        post_id=post_id,
        author_id=data['author_id'],
        content=data['content']
    )
    return jsonify(comment.to_dict()), 201

# ============================================
# BUSINESS LOGIC LAYER - Services
# ============================================
from repositories.post_repository import PostRepository
from repositories.comment_repository import CommentRepository
from models.post import Post
from datetime import datetime

class PostService:
    def __init__(self):
        self.post_repo = PostRepository()
        self.comment_repo = CommentRepository()
    
    def create_post(self, title, content, author_id):
        # Validate business rules
        if len(title) > 200:
            raise ValueError("Title too long (max 200 characters)")
        
        if len(content) < 10:
            raise ValueError("Content too short (min 10 characters)")
        
        # Create domain object
        post = Post(
            title=title,
            content=content,
            author_id=author_id,
            created_at=datetime.now(),
            published=False
        )
        
        # Save through repository
        return self.post_repo.save(post)
    
    def get_post_with_comments(self, post_id):
        post = self.post_repo.find_by_id(post_id)
        if not post:
            raise ValueError(f"Post {post_id} not found")
        
        # Enrich with comments
        comments = self.comment_repo.find_by_post_id(post_id)
        post.comments = comments
        
        return post
    
    def publish_post(self, post_id):
        post = self.post_repo.find_by_id(post_id)
        
        # Business rule: can't publish empty posts
        if not post.content:
            raise ValueError("Cannot publish empty post")
        
        post.published = True
        post.published_at = datetime.now()
        
        return self.post_repo.update(post)

class CommentService:
    def __init__(self):
        self.comment_repo = CommentRepository()
        self.post_repo = PostRepository()
    
    def add_comment(self, post_id, author_id, content):
        # Validate post exists
        post = self.post_repo.find_by_id(post_id)
        if not post:
            raise ValueError(f"Post {post_id} not found")
        
        # Business rule: can't comment on unpublished posts
        if not post.published:
            raise ValueError("Cannot comment on unpublished post")
        
        # Create comment
        comment = Comment(
            post_id=post_id,
            author_id=author_id,
            content=content,
            created_at=datetime.now()
        )
        
        return self.comment_repo.save(comment)

# ============================================
# DOMAIN LAYER - Models
# ============================================
class Post:
    def __init__(self, id=None, title=None, content=None, author_id=None,
                 created_at=None, published=False, published_at=None):
        self.id = id
        self.title = title
        self.content = content
        self.author_id = author_id
        self.created_at = created_at
        self.published = published
        self.published_at = published_at
        self.comments = []
    
    def to_dict(self, include_comments=False):
        data = {
            'id': self.id,
            'title': self.title,
            'content': self.content,
            'author_id': self.author_id,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'published': self.published
        }
        
        if include_comments:
            data['comments'] = [c.to_dict() for c in self.comments]
        
        return data

class Comment:
    def __init__(self, id=None, post_id=None, author_id=None,
                 content=None, created_at=None):
        self.id = id
        self.post_id = post_id
        self.author_id = author_id
        self.content = content
        self.created_at = created_at
    
    def to_dict(self):
        return {
            'id': self.id,
            'post_id': self.post_id,
            'author_id': self.author_id,
            'content': self.content,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }

# ============================================
# DATA ACCESS LAYER - Repositories
# ============================================
import psycopg2
from psycopg2.extras import RealDictCursor

class PostRepository:
    def __init__(self):
        self.conn = psycopg2.connect(
            host="localhost",
            database="blog_db",
            user="postgres",
            password="password"
        )
    
    def save(self, post):
        cursor = self.conn.cursor(cursor_factory=RealDictCursor)
        
        query = """
            INSERT INTO posts (title, content, author_id, created_at, published)
            VALUES (%s, %s, %s, %s, %s)
            RETURNING *
        """
        
        cursor.execute(query, (
            post.title,
            post.content,
            post.author_id,
            post.created_at,
            post.published
        ))
        
        row = cursor.fetchone()
        self.conn.commit()
        
        return self._map_to_post(row)
    
    def find_by_id(self, post_id):
        cursor = self.conn.cursor(cursor_factory=RealDictCursor)
        cursor.execute("SELECT * FROM posts WHERE id = %s", (post_id,))
        row = cursor.fetchone()
        
        if row:
            return self._map_to_post(row)
        return None
    
    def update(self, post):
        cursor = self.conn.cursor(cursor_factory=RealDictCursor)
        
        query = """
            UPDATE posts
            SET title = %s, content = %s, published = %s, published_at = %s
            WHERE id = %s
            RETURNING *
        """
        
        cursor.execute(query, (
            post.title,
            post.content,
            post.published,
            post.published_at,
            post.id
        ))
        
        row = cursor.fetchone()
        self.conn.commit()
        
        return self._map_to_post(row)
    
    def _map_to_post(self, row):
        return Post(
            id=row['id'],
            title=row['title'],
            content=row['content'],
            author_id=row['author_id'],
            created_at=row['created_at'],
            published=row['published'],
            published_at=row.get('published_at')
        )

class CommentRepository:
    def __init__(self):
        self.conn = psycopg2.connect(
            host="localhost",
            database="blog_db",
            user="postgres",
            password="password"
        )
    
    def save(self, comment):
        cursor = self.conn.cursor(cursor_factory=RealDictCursor)
        
        query = """
            INSERT INTO comments (post_id, author_id, content, created_at)
            VALUES (%s, %s, %s, %s)
            RETURNING *
        """
        
        cursor.execute(query, (
            comment.post_id,
            comment.author_id,
            comment.content,
            comment.created_at
        ))
        
        row = cursor.fetchone()
        self.conn.commit()
        
        return self._map_to_comment(row)
    
    def find_by_post_id(self, post_id):
        cursor = self.conn.cursor(cursor_factory=RealDictCursor)
        cursor.execute(
            "SELECT * FROM comments WHERE post_id = %s ORDER BY created_at",
            (post_id,)
        )
        rows = cursor.fetchall()
        
        return [self._map_to_comment(row) for row in rows]
    
    def _map_to_comment(self, row):
        return Comment(
            id=row['id'],
            post_id=row['post_id'],
            author_id=row['author_id'],
            content=row['content'],
            created_at=row['created_at']
        )
```

---

## Chapter 4 Summary

### Key Concepts

1. **Layered Architecture** organizes code into horizontal layers with specific responsibilities
2. **Three-Tier** is most common: Presentation, Business Logic, Data Access
3. Each layer should **only depend on the layer below it**
4. Use **dependency injection** for testability and flexibility
5. Keep **domain models separate from DTOs**

### Advantages
- ✅ Clear separation of concerns
- ✅ Easy to test
- ✅ Familiar to most developers
- ✅ Good for traditional applications

### Disadvantages
- ❌ Can become monolithic
- ❌ Performance overhead
- ❌ Changes ripple across layers
- ❌ Not ideal for distributed systems

### When to Use
- Traditional enterprise applications
- Small to medium-sized projects
- CRUD-heavy applications
- Single team development

### Interview Tips

**Common Questions:**
1. "What are the layers in a three-tier architecture?"
2. "Why shouldn't the presentation layer call the repository directly?"
3. "What's the difference between domain models and DTOs?"
4. "How do you handle cross-cutting concerns in layered architecture?"

**How to Answer:**
- Draw the layer diagram
- Explain the responsibility of each layer
- Give concrete code examples
- Mention trade-offs and alternatives

### Next Steps

In Chapter 5, we'll explore **Microservices Architecture** - a distributed approach that addresses some of the limitations of layered architecture for large-scale systems.