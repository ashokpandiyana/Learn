# Chapter 41: Modern Architecture Patterns - In-Depth Guide

## Introduction

Modern architecture patterns have evolved to address challenges in contemporary software development: cloud-native applications, microservices complexity, legacy system migration, and reactive systems. This chapter explores cutting-edge patterns that are shaping modern software architecture.

---

## 1. Backend for Frontend (BFF) Pattern

### The Problem

Traditional APIs try to serve all clients (web, mobile, IoT) with the same endpoints. This creates issues:
- **Over-fetching**: Mobile apps get data they don't need
- **Under-fetching**: Multiple requests needed for one screen
- **Tight coupling**: Changes for web affect mobile
- **Performance**: Mobile has different optimization needs

### The Solution: BFF Pattern

Create separate backend services for each frontend type.

```
┌──────────────────────────────────────────────────────┐
│                  CLIENT LAYER                        │
│                                                      │
│  ┌─────────┐  ┌──────────┐  ┌────────────┐         │
│  │   Web   │  │  Mobile  │  │    IoT     │         │
│  │   App   │  │   App    │  │  Device    │         │
│  └────┬────┘  └─────┬────┘  └──────┬─────┘         │
└───────┼─────────────┼──────────────┼────────────────┘
        │             │              │
        ▼             ▼              ▼
┌───────────┐  ┌──────────┐  ┌────────────┐
│    Web    │  │  Mobile  │  │    IoT     │
│    BFF    │  │   BFF    │  │    BFF     │
└─────┬─────┘  └─────┬────┘  └──────┬─────┘
      │              │               │
      └──────────────┼───────────────┘
                     │
        ┌────────────┼────────────┐
        ▼            ▼            ▼
┌────────────┐  ┌─────────┐  ┌──────────┐
│   User     │  │ Product │  │  Order   │
│  Service   │  │ Service │  │ Service  │
└────────────┘  └─────────┘  └──────────┘
```

### Implementation Example

```javascript
/**
 * Mobile BFF - Optimized for mobile constraints
 */
class MobileBFF {
    constructor(userService, productService, orderService) {
        this.userService = userService;
        this.productService = productService;
        this.orderService = orderService;
    }
    
    /**
     * Single endpoint for home screen
     * Aggregates data from multiple services
     * Returns only what mobile needs
     */
    async getHomeScreen(userId) {
        // Mobile needs: user info, featured products, recent order
        // Do parallel calls for performance
        const [user, featuredProducts, recentOrder] = await Promise.all([
            this.userService.getUser(userId),
            this.productService.getFeaturedProducts(5), // Only 5 for mobile
            this.orderService.getMostRecentOrder(userId)
        ]);
        
        // Return mobile-optimized format
        return {
            user: {
                name: user.name,
                // Omit unnecessary fields for bandwidth
                avatarUrl: user.avatarUrl + '?size=small' // Smaller images
            },
            featuredProducts: featuredProducts.map(p => ({
                id: p.id,
                name: p.name,
                price: p.price,
                thumbnailUrl: p.thumbnailUrl // Not full resolution
                // Omit long descriptions
            })),
            recentOrder: recentOrder ? {
                id: recentOrder.id,
                status: recentOrder.status,
                total: recentOrder.total
                // Omit detailed item list
            } : null
        };
    }
    
    /**
     * Optimized search for mobile
     */
    async search(query) {
        // Mobile: Return fewer results, prioritize speed
        const products = await this.productService.search(query, {
            limit: 10, // Fewer results
            fields: ['id', 'name', 'price', 'thumbnail'], // Minimal fields
            sort: 'relevance'
        });
        
        return {
            results: products,
            total: products.length,
            // Pre-calculate to reduce mobile processing
            hasMore: products.length === 10
        };
    }
}

/**
 * Web BFF - Optimized for rich desktop experience
 */
class WebBFF {
    constructor(userService, productService, orderService) {
        this.userService = userService;
        this.productService = productService;
        this.orderService = orderService;
    }
    
    /**
     * Web home screen can handle more data
     */
    async getHomeScreen(userId) {
        const [user, featuredProducts, recentOrders, recommendations] = await Promise.all([
            this.userService.getUser(userId),
            this.productService.getFeaturedProducts(20), // More products
            this.orderService.getRecentOrders(userId, 5), // Multiple orders
            this.productService.getRecommendations(userId, 10)
        ]);
        
        // Web can handle richer data
        return {
            user: {
                ...user, // Include all user fields
                preferences: user.preferences,
                addresses: user.addresses
            },
            featuredProducts: featuredProducts.map(p => ({
                ...p, // All product fields
                reviews: p.reviews,
                relatedProducts: p.relatedProducts
            })),
            recentOrders: recentOrders, // Full order details
            recommendations: recommendations
        };
    }
    
    /**
     * Rich search for web
     */
    async search(query, filters) {
        // Web: More results, advanced filtering
        const products = await this.productService.search(query, {
            limit: 50, // More results
            filters: filters, // Complex filters
            fields: '*', // All fields
            facets: true // Include faceting info
        });
        
        return {
            results: products,
            total: products.total,
            facets: products.facets, // For filter UI
            suggestions: products.suggestions
        };
    }
}

/**
 * Express.js setup
 */
const express = require('express');

// Mobile BFF on port 3001
const mobileBFF = express();
mobileBFF.get('/home', async (req, res) => {
    const mobileController = new MobileBFF(userService, productService, orderService);
    const data = await mobileController.getHomeScreen(req.user.id);
    res.json(data);
});

// Web BFF on port 3002
const webBFF = express();
webBFF.get('/home', async (req, res) => {
    const webController = new WebBFF(userService, productService, orderService);
    const data = await webController.getHomeScreen(req.user.id);
    res.json(data);
});
```

### Python BFF Example

```python
"""
BFF Pattern in Python with FastAPI
"""

from fastapi import FastAPI
from typing import List, Optional
import asyncio

# Mobile BFF
mobile_app = FastAPI()

class MobileBFF:
    def __init__(self, user_service, product_service):
        self.user_service = user_service
        self.product_service = product_service
    
    async def get_product_listing(self, category_id: str, page: int = 1):
        """
        Mobile-optimized product listing
        - Smaller images
        - Fewer products per page
        - Minimal data
        """
        products = await self.product_service.get_products(
            category_id=category_id,
            page=page,
            page_size=10,  # Mobile: 10 per page
            image_size='thumbnail'
        )
        
        # Transform for mobile
        return {
            'products': [
                {
                    'id': p.id,
                    'name': p.name,
                    'price': p.price,
                    'image': p.thumbnail_url,
                    'rating': p.average_rating
                    # Exclude: long description, reviews, specifications
                }
                for p in products
            ],
            'page': page,
            'has_more': len(products) == 10
        }

# Web BFF
web_app = FastAPI()

class WebBFF:
    def __init__(self, user_service, product_service):
        self.user_service = user_service
        self.product_service = product_service
    
    async def get_product_listing(self, category_id: str, page: int = 1):
        """
        Web-optimized product listing
        - High-res images
        - More products per page
        - Rich data
        """
        products = await self.product_service.get_products(
            category_id=category_id,
            page=page,
            page_size=50,  # Web: 50 per page
            image_size='large'
        )
        
        # Transform for web
        return {
            'products': [
                {
                    'id': p.id,
                    'name': p.name,
                    'price': p.price,
                    'images': p.all_images,  # Multiple images
                    'description': p.description,  # Full description
                    'rating': p.average_rating,
                    'review_count': p.review_count,
                    'specifications': p.specifications,
                    'availability': p.availability
                    # Include all details
                }
                for p in products
            ],
            'page': page,
            'total_pages': products.total_pages,
            'filters': self._get_available_filters(category_id)
        }

@mobile_app.get('/products/{category_id}')
async def mobile_products(category_id: str, page: int = 1):
    bff = MobileBFF(user_service, product_service)
    return await bff.get_product_listing(category_id, page)

@web_app.get('/products/{category_id}')
async def web_products(category_id: str, page: int = 1):
    bff = WebBFF(user_service, product_service)
    return await bff.get_product_listing(category_id, page)
```

### When to Use BFF

**Use BFF when:**
- Different clients have significantly different needs
- Performance optimization varies by client type
- Teams are organized by frontend platform
- You need to evolve APIs independently

**Don't use BFF when:**
- All clients have similar needs
- Team is small and overhead isn't justified
- Single API already performs well

---

## 2. Strangler Fig Pattern (Legacy Migration)

### The Problem

Rewriting legacy systems is risky:
- Takes months/years
- Big bang deployment is dangerous
- Hard to validate correctness
- Business continuity at risk

### The Solution: Strangler Fig Pattern

Gradually replace legacy system by routing new features to new system while legacy continues to run.

Named after strangler fig trees that grow around host trees.

```
Phase 1: Initial State
┌──────────────────────┐
│   Legacy System      │
│  (All traffic)       │
└──────────────────────┘

Phase 2: Start Strangling
┌──────────────────────┐
│     Router/Proxy     │
└────┬────────────┬────┘
     │            │
     ▼            ▼
┌─────────┐  ┌────────┐
│ Legacy  │  │  New   │
│ (90%)   │  │ (10%)  │
└─────────┘  └────────┘

Phase 3: Progressive Migration
┌──────────────────────┐
│     Router/Proxy     │
└────┬────────────┬────┘
     │            │
     ▼            ▼
┌─────────┐  ┌────────┐
│ Legacy  │  │  New   │
│ (40%)   │  │ (60%)  │
└─────────┘  └────────┘

Phase 4: Complete
┌──────────────────────┐
│   New System         │
│  (All traffic)       │
└──────────────────────┘
```

### Implementation

```javascript
/**
 * Strangler Fig Pattern Implementation
 */

class StranglerRouter {
    constructor(legacyService, newService) {
        this.legacyService = legacyService;
        this.newService = newService;
        this.routingRules = this.loadRoutingRules();
    }
    
    /**
     * Progressive routing configuration
     */
    loadRoutingRules() {
        return {
            // Routes fully migrated to new system
            '/api/users': { target: 'new', percentage: 100 },
            '/api/products': { target: 'new', percentage: 100 },
            
            // Routes being migrated (canary)
            '/api/orders': { target: 'new', percentage: 20 }, // 20% to new
            
            // Routes still in legacy
            '/api/reports': { target: 'legacy', percentage: 100 },
            '/api/analytics': { target: 'legacy', percentage: 100 }
        };
    }
    
    /**
     * Route requests based on rules
     */
    async routeRequest(path, request) {
        const rule = this.routingRules[path];
        
        if (!rule) {
            // Not configured, use legacy by default
            return this.legacyService.handleRequest(path, request);
        }
        
        // Determine which service to use
        const useNewService = this.shouldUseNewService(rule);
        
        if (useNewService) {
            try {
                // Try new service
                const response = await this.newService.handleRequest(path, request);
                
                // Optional: Shadow traffic to verify correctness
                this.shadowToLegacy(path, request);
                
                return response;
            } catch (error) {
                // Fallback to legacy on error
                console.error('New service failed, falling back to legacy', error);
                return this.legacyService.handleRequest(path, request);
            }
        } else {
            return this.legacyService.handleRequest(path, request);
        }
    }
    
    shouldUseNewService(rule) {
        if (rule.target === 'new' && rule.percentage === 100) {
            return true;
        }
        
        if (rule.target === 'legacy') {
            return false;
        }
        
        // Canary: Use percentage-based routing
        return Math.random() * 100 < rule.percentage;
    }
    
    /**
     * Shadow traffic: Send to both systems, compare results
     */
    async shadowToLegacy(path, request) {
        try {
            const legacyResponse = await this.legacyService.handleRequest(path, request);
            const newResponse = await this.newService.handleRequest(path, request);
            
            // Compare responses
            if (!this.responsesMatch(legacyResponse, newResponse)) {
                this.logDiscrepancy(path, legacyResponse, newResponse);
            }
        } catch (error) {
            // Don't fail main request if shadowing fails
            console.error('Shadow request failed', error);
        }
    }
    
    responsesMatch(legacy, newResponse) {
        // Compare relevant fields
        return JSON.stringify(legacy) === JSON.stringify(newResponse);
    }
}

/**
 * Express.js integration
 */
const express = require('express');
const app = express();

const router = new StranglerRouter(legacyService, newService);

// Intercept all requests
app.use(async (req, res, next) => {
    const response = await router.routeRequest(req.path, req);
    res.json(response);
});
```

### Python Implementation

```python
"""
Strangler Fig Pattern with Feature Flags
"""

from typing import Dict, Any
import random
from enum import Enum

class TargetSystem(Enum):
    LEGACY = "legacy"
    NEW = "new"
    CANARY = "canary"

class StranglerFacade:
    """
    Facade that gradually routes traffic from legacy to new system
    """
    
    def __init__(self, legacy_service, new_service):
        self.legacy_service = legacy_service
        self.new_service = new_service
        self.routing_config = self._load_config()
    
    def _load_config(self) -> Dict[str, Dict[str, Any]]:
        """
        Configuration can be loaded from database/config service
        Allows changing routing without deployment
        """
        return {
            'create_order': {
                'target': TargetSystem.NEW,
                'percentage': 100,
                'shadow': False
            },
            'get_order': {
                'target': TargetSystem.CANARY,
                'percentage': 30,  # 30% to new system
                'shadow': True     # Compare responses
            },
            'cancel_order': {
                'target': TargetSystem.LEGACY,
                'percentage': 100,
                'shadow': False
            }
        }
    
    async def execute(self, operation: str, **kwargs):
        """
        Route operation to appropriate system
        """
        config = self.routing_config.get(operation)
        
        if not config:
            # Default to legacy for unknown operations
            return await self.legacy_service.execute(operation, **kwargs)
        
        # Determine target
        if config['target'] == TargetSystem.NEW:
            return await self._call_new_system(operation, **kwargs)
        
        elif config['target'] == TargetSystem.LEGACY:
            return await self._call_legacy_system(operation, **kwargs)
        
        elif config['target'] == TargetSystem.CANARY:
            return await self._canary_routing(
                operation, 
                config['percentage'],
                config.get('shadow', False),
                **kwargs
            )
    
    async def _canary_routing(self, operation: str, percentage: int, 
                             shadow: bool, **kwargs):
        """
        Percentage-based routing with optional shadowing
        """
        use_new = random.randint(1, 100) <= percentage
        
        if use_new:
            try:
                result = await self._call_new_system(operation, **kwargs)
                
                # Optional: Shadow to legacy for comparison
                if shadow:
                    await self._shadow_to_legacy(operation, result, **kwargs)
                
                return result
            except Exception as e:
                # Fallback to legacy on error
                print(f"New system failed: {e}, falling back to legacy")
                return await self._call_legacy_system(operation, **kwargs)
        else:
            return await self._call_legacy_system(operation, **kwargs)
    
    async def _call_new_system(self, operation: str, **kwargs):
        """Call new system with monitoring"""
        print(f"Routing {operation} to NEW system")
        return await self.new_service.execute(operation, **kwargs)
    
    async def _call_legacy_system(self, operation: str, **kwargs):
        """Call legacy system with monitoring"""
        print(f"Routing {operation} to LEGACY system")
        return await self.legacy_service.execute(operation, **kwargs)
    
    async def _shadow_to_legacy(self, operation: str, new_result: Any, **kwargs):
        """
        Send same request to legacy, compare results
        """
        try:
            legacy_result = await self.legacy_service.execute(operation, **kwargs)
            
            if legacy_result != new_result:
                # Log discrepancy for investigation
                self._log_discrepancy(operation, legacy_result, new_result)
        except Exception as e:
            # Don't fail main request
            print(f"Shadow request failed: {e}")

# Usage
async def main():
    facade = StranglerFacade(legacy_service, new_service)
    
    # As you gain confidence, update routing config
    # Week 1: 10% to new system
    # Week 2: 30% to new system
    # Week 3: 50% to new system
    # Week 4: 100% to new system
    
    result = await facade.execute('get_order', order_id='12345')
```

### Migration Strategy

```python
"""
Complete migration timeline
"""

class MigrationPlan:
    """
    6-month strangler fig migration plan
    """
    
    PHASES = [
        {
            'month': 1,
            'focus': 'Infrastructure & Routing',
            'tasks': [
                'Set up router/proxy',
                'Implement routing rules',
                'Set up monitoring',
                'Establish rollback procedures'
            ],
            'traffic_to_new': '0%'
        },
        {
            'month': 2,
            'focus': 'First Feature Migration',
            'tasks': [
                'Migrate read-only endpoints',
                'Enable shadowing',
                'Compare responses',
                'Fix discrepancies'
            ],
            'traffic_to_new': '10%'
        },
        {
            'month': 3,
            'focus': 'Expand Coverage',
            'tasks': [
                'Migrate more read endpoints',
                'Start migrating writes',
                'Increase canary percentage',
                'Monitor error rates'
            ],
            'traffic_to_new': '30%'
        },
        {
            'month': 4,
            'focus': 'Core Features',
            'tasks': [
                'Migrate critical write paths',
                'Dual-write to both systems',
                'Validate data consistency',
                'Increase traffic gradually'
            ],
            'traffic_to_new': '60%'
        },
        {
            'month': 5,
            'focus': 'Final Migration',
            'tasks': [
                'Migrate remaining features',
                'Full traffic cutover',
                'Keep legacy as backup',
                'Monitor closely'
            ],
            'traffic_to_new': '100%'
        },
        {
            'month': 6,
            'focus': 'Decommission',
            'tasks': [
                'Remove routing layer',
                'Decommission legacy',
                'Clean up code',
                'Document lessons learned'
            ],
            'traffic_to_new': '100%'
        }
    ]
```

---

## 3. CQRS with Event Sourcing

### Command Query Responsibility Segregation (CQRS)

**Principle**: Separate read and write models.

```
Traditional (Single Model)
┌────────────────────┐
│  Application       │
│  ┌──────────────┐  │
│  │ Single Model │  │
│  └──────┬───────┘  │
│         │          │
│    ┌────▼─────┐    │
│    │ Database │    │
│    └──────────┘    │
└────────────────────┘

CQRS (Separate Models)
┌──────────────────────────────────┐
│  Application                     │
│  ┌──────────┐    ┌─────────────┐ │
│  │ Command  │    │    Query    │ │
│  │  Model   │    │    Model    │ │
│  └────┬─────┘    └──────┬──────┘ │
│       │                 │        │
│  ┌────▼─────┐    ┌──────▼──────┐ │
│  │  Write   │───▶│    Read     │ │
│  │    DB    │ │  │     DB      │ │
│  └──────────┘ │  └─────────────┘ │
│               │                  │
│            Events                │
└──────────────────────────────────┘
```

### CQRS Implementation

```javascript
/**
 * CQRS Pattern Implementation
 */

// COMMAND SIDE (Writes)
class OrderCommandHandler {
    constructor(eventStore, eventBus) {
        this.eventStore = eventStore;
        this.eventBus = eventBus;
    }
    
    /**
     * Handle command: Create Order
     */
    async createOrder(command) {
        const { customerId, items, totalAmount } = command;
        
        // Validate command
        if (items.length === 0) {
            throw new Error('Order must have items');
        }
        
        // Create event
        const event = {
            type: 'OrderCreated',
            aggregateId: generateOrderId(),
            timestamp: new Date(),
            data: {
                customerId,
                items,
                totalAmount,
                status: 'pending'
            }
        };
        
        // Store event
        await this.eventStore.append(event);
        
        // Publish event
        await this.eventBus.publish(event);
        
        return { orderId: event.aggregateId };
    }
    
    /**
     * Handle command: Cancel Order
     */
    async cancelOrder(command) {
        const { orderId, reason } = command;
        
        // Load order from event store
        const order = await this.loadOrder(orderId);
        
        // Business logic
        if (order.status === 'shipped') {
            throw new Error('Cannot cancel shipped order');
        }
        
        // Create event
        const event = {
            type: 'OrderCancelled',
            aggregateId: orderId,
            timestamp: new Date(),
            data: { reason }
        };
        
        await this.eventStore.append(event);
        await this.eventBus.publish(event);
        
        return { success: true };
    }
    
    async loadOrder(orderId) {
        // Rebuild state from events
        const events = await this.eventStore.getEvents(orderId);
        return this.replayEvents(events);
    }
    
    replayEvents(events) {
        const order = { items: [], status: 'pending' };
        
        for (const event of events) {
            switch (event.type) {
                case 'OrderCreated':
                    Object.assign(order, event.data);
                    break;
                case 'OrderCancelled':
                    order.status = 'cancelled';
                    break;
                // ... other events
            }
        }
        
        return order;
    }
}

// QUERY SIDE (Reads)
class OrderQueryHandler {
    constructor(readDatabase) {
        this.db = readDatabase;
    }
    
    /**
     * Query: Get Order Details
     * Optimized read model
     */
    async getOrder(orderId) {
        // Read from denormalized table
        const order = await this.db.query(
            'SELECT * FROM order_view WHERE order_id = $1',
            [orderId]
        );
        
        return order;
    }
    
    /**
     * Query: Get Customer Orders
     * Pre-joined, pre-calculated
     */
    async getCustomerOrders(customerId) {
        // Read model is optimized for this query
        const orders = await this.db.query(`
            SELECT 
                o.order_id,
                o.total_amount,
                o.status,
                o.created_at,
                COUNT(oi.id) as item_count
            FROM order_view o
            LEFT JOIN order_items oi ON o.order_id = oi.order_id
            WHERE o.customer_id = $1
            GROUP BY o.order_id
            ORDER BY o.created_at DESC
        `, [customerId]);
        
        return orders;
    }
}

// EVENT HANDLER (Updates Read Model)
class OrderEventHandler {
    constructor(readDatabase) {
        this.db = readDatabase;
    }
    
    /**
     * When OrderCreated event occurs, update read model
     */
    async onOrderCreated(event) {
        const { aggregateId, data } = event;
        
        // Insert into read database
        await this.db.query(`
            INSERT INTO order_view 
            (order_id, customer_id, total_amount, status, created_at)
            VALUES ($1, $2, $3, $4, $5)
        `, [
            aggregateId,
            data.customerId,
            data.totalAmount,
            data.status,
            event.timestamp
        ]);
        
        // Insert items
        for (const item of data.items) {
            await this.db.query(`
                INSERT INTO order_items
                (order_id, product_id, quantity, price)
                VALUES ($1, $2, $3, $4)
            `, [aggregateId, item.productId, item.quantity, item.price]);
        }
    }
    
    /**
     * When OrderCancelled event occurs, update read model
     */
    async onOrderCancelled(event) {
        await this.db.query(`
            UPDATE order_view
            SET status = 'cancelled', updated_at = $2
            WHERE order_id = $1
        `, [event.aggregateId, event.timestamp]);
    }
}
```

### Event Sourcing Implementation

```python
"""
Event Sourcing: Store events, not state
"""

from typing import List, Dict, Any
from datetime import datetime
import json

class EventStore:
    """
    Persist all events
    Current state is derived by replaying events
    """
    
    def __init__(self, database):
        self.db = database
    
    async def append_event(self, event: Dict[str, Any]):
        """
        Append event to store
        Events are immutable - never updated or deleted
        """
        await self.db.execute("""
            INSERT INTO events 
            (aggregate_id, event_type, event_data, timestamp, version)
            VALUES ($1, $2, $3, $4, $5)
        """, [
            event['aggregate_id'],
            event['type'],
            json.dumps(event['data']),
            event['timestamp'],
            event.get('version', 1)
        ])
    
    async def get_events(self, aggregate_id: str) -> List[Dict]:
        """Get all events for an aggregate"""
        rows = await self.db.fetch("""
            SELECT event_type, event_data, timestamp, version
            FROM events
            WHERE aggregate_id = $1
            ORDER BY version ASC
        """, aggregate_id)
        
        return [
            {
                'type': row['event_type'],
                'data': json.loads(row['event_data']),
                'timestamp': row['timestamp'],
                'version': row['version']
            }
            for row in rows
        ]

class BankAccount:
    """
    Aggregate rebuilt from events
    """
    
    def __init__(self, account_id: str):
        self.account_id = account_id
        self.balance = 0
        self.transactions = []
        self.version = 0
    
    @classmethod
    async def load(cls, account_id: str, event_store: EventStore):
        """
        Load account by replaying all events
        """
        account = cls(account_id)
        events = await event_store.get_events(account_id)
        
        for event in events:
            account.apply_event(event)
        
        return account
    
    def apply_event(self, event: Dict):
        """Apply event to rebuild state"""
        if event['type'] == 'AccountOpened':
            self.balance = event['data']['initial_balance']
        
        elif event['type'] == 'MoneyDeposited':
            self.balance += event['data']['amount']
            self.transactions.append(event)
        
        elif event['type'] == 'MoneyWithdrawn':
            self.balance -= event['data']['amount']
            self.transactions.append(event)
        
        self.version += 1
    
    async def deposit(self, amount: float, event_store: EventStore):
        """
        Create and store deposit event
        """
        event = {
            'aggregate_id': self.account_id,
            'type': 'MoneyDeposited',
            'data': {'amount': amount},
            'timestamp': datetime.now(),
            'version': self.version + 1
        }
        
        # Store event
        await event_store.append_event(event)
        
        # Apply to current state
        self.apply_event(event)
    
    async def withdraw(self, amount: float, event_store: EventStore):
        """
        Create and store withdrawal event
        """
        if amount > self.balance:
            raise ValueError('Insufficient funds')
        
        event = {
            'aggregate_id': self.account_id,
            'type': 'MoneyWithdrawn',
            'data': {'amount': amount},
            'timestamp': datetime.now(),
            'version': self.version + 1
        }
        
        await event_store.append_event(event)
        self.apply_event(event)

# Usage
async def main():
    event_store = EventStore(database)
    
    # Create new account
    account = BankAccount('ACC-001')
    
    # Open account
    await event_store.append_event({
        'aggregate_id': 'ACC-001',
        'type': 'AccountOpened',
        'data': {'initial_balance': 1000},
        'timestamp': datetime.now(),
        'version': 1
    })
    
    # Load account (replays events)
    account = await BankAccount.load('ACC-001', event_store)
    print(f"Balance: ${account.balance}")  # 1000
    
    # Deposit
    await account.deposit(500, event_store)
    print(f"Balance: ${account.balance}")  # 1500
    
    # Withdraw
    await account.withdraw(200, event_store)
    print(f"Balance: ${account.balance}")  # 1300
    
    # Reload account - same state
    account2 = await BankAccount.load('ACC-001', event_store)
    print(f"Balance: ${account2.balance}")  # 1300
```

### Benefits of CQRS + Event Sourcing

```python
"""
Key benefits
"""

benefits = {
    'performance': {
        'read_optimization': 'Denormalized read models for fast queries',
        'write_optimization': 'Simple event appends, no complex updates',
        'scaling': 'Scale reads and writes independently'
    },
    
    'audit_trail': {
        'complete_history': 'Every change is recorded',
        'temporal_queries': 'Can query state at any point in time',
        'debugging': 'Replay events to reproduce bugs'
    },
    
    'flexibility': {
        'multiple_read_models': 'Create specialized views for different needs',
        'evolving_models': 'Add new read models without changing writes',
        'event_replay': 'Rebuild state from events if corrupted'
    },
    
    'business_insights': {
        'analytics': 'Rich event stream for analysis',
        'ml_training': 'Events as training data',
        'real_time_processing': 'React to events as they happen'
    }
}
```

---

## 4. Reactive Architecture

### Reactive Manifesto Principles

1. **Responsive**: System responds in timely manner
2. **Resilient**: System stays responsive despite failures
3. **Elastic**: System scales up/down based on load
4. **Message-Driven**: Asynchronous message passing

### Implementation

```javascript
/**
 * Reactive Architecture with RxJS
 */

const { Subject, fromEvent, merge } = require('rxjs');
const { 
    debounceTime, 
    distinctUntilChanged, 
    switchMap,
    retry,
    catchError 
} = require('rxjs/operators');

class ReactiveSearchService {
    constructor(searchAPI) {
        this.searchAPI = searchAPI;
        this.searchResults$ = new Subject();
    }
    
    /**
     * Reactive search with debouncing, deduplication
     */
    setupReactiveSearch(inputElement) {
        // Create observable from input events
        const search$ = fromEvent(inputElement, 'input').pipe(
            // Extract value
            map(event => event.target.value),
            
            // Wait 300ms after user stops typing
            debounceTime(300),
            
            // Only search if value changed
            distinctUntilChanged(),
            
            // Cancel previous search, start new one
            switchMap(query => this.search(query)),
            
            // Retry on failure
            retry(3),
            
            // Handle errors gracefully
            catchError(error => {
                console.error('Search failed', error);
                return of([]);
            })
        );
        
        // Subscribe to results
        search$.subscribe(results => {
            this.searchResults$.next(results);
        });
    }
    
    async search(query) {
        return this.searchAPI.search(query);
    }
}

/**
 * Backpressure handling
 */
class ReactiveDataProcessor {
    constructor() {
        this.dataStream$ = new Subject();
    }
    
    /**
     * Handle high-volume data stream with backpressure
     */
    processStream() {
        this.dataStream$.pipe(
            // Buffer items for 1 second or until 100 items
            bufferTime(1000, null, 100),
            
            // Process in batches
            switchMap(batch => this.processBatch(batch)),
            
            // Retry failed batches
            retry(3)
        ).subscribe(
            result => console.log('Batch processed', result),
            error => console.error('Processing failed', error)
        );
    }
    
    async processBatch(items) {
        // Process batch together for efficiency
        return await this.database.bulkInsert(items);
    }
    
    // Producer can push data without blocking
    pushData(item) {
        this.dataStream$.next(item);
    }
}
```

---

## Summary

Modern architecture patterns address contemporary challenges:

- **BFF**: Optimize APIs for different client types
- **Strangler Fig**: Safely migrate legacy systems
- **CQRS + Event Sourcing**: Separate reads/writes, maintain complete history
- **Reactive**: Build responsive, resilient systems

Choose patterns based on your specific needs, not trends!