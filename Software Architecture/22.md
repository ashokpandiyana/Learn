# Chapter 22: Authentication & Authorization

## Table of Contents
1. Authentication vs Authorization
2. Session-Based Authentication
3. Token-Based Authentication (JWT)
4. OAuth 2.0
5. OpenID Connect
6. Multi-Factor Authentication (MFA)
7. Role-Based Access Control (RBAC)
8. Attribute-Based Access Control (ABAC)
9. Single Sign-On (SSO)
10. Security Best Practices
11. Implementation Examples

---

## 1. Authentication vs Authorization

### Authentication (AuthN)

**Definition:** Verifying who you are.
**Question:** "Are you really Alice?"

**Methods:**
- Password
- Biometrics (fingerprint, face)
- Security token
- One-time password (OTP)

### Authorization (AuthZ)

**Definition:** Verifying what you can do.
**Question:** "Can Alice delete this file?"

**Methods:**
- Role-based (RBAC)
- Attribute-based (ABAC)
- Access Control Lists (ACL)
- Claims-based

### Example

```
Authentication:
User enters: email=alice@example.com, password=secret123
System verifies: ✓ Credentials valid
Result: User is Alice ✓

Authorization:
Alice requests: DELETE /api/users/123
System checks: Does Alice have 'delete_users' permission?
Result: 
- If Admin role → Yes, allowed ✓
- If Regular user → No, forbidden ✗
```

---

## 2. Session-Based Authentication

**How it works:** Server creates session, stores on server, sends session ID to client.

### Flow

```
1. Login:
   Client → POST /login {email, password}
   Server → Verify credentials
         → Create session in database/Redis
         → Return session cookie

2. Authenticated Request:
   Client → GET /api/profile (with session cookie)
   Server → Read session from store
         → Verify session valid
         → Return user data

3. Logout:
   Client → POST /logout (with session cookie)
   Server → Delete session from store
         → Clear cookie
```

### Implementation

```javascript
// ============================================
// Express.js Session Authentication
// ============================================
const express = require('express');
const session = require('express-session');
const RedisStore = require('connect-redis')(session);
const redis = require('redis');
const bcrypt = require('bcrypt');

const app = express();
const redisClient = redis.createClient();

// Session middleware
app.use(session({
  store: new RedisStore({ client: redisClient }),
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: true,      // HTTPS only
    httpOnly: true,    // Not accessible via JavaScript
    maxAge: 24 * 60 * 60 * 1000,  // 24 hours
    sameSite: 'strict'
  }
}));

// ============================================
// Login endpoint
// ============================================
app.post('/api/login', async (req, res) => {
  const { email, password } = req.body;
  
  // Find user
  const user = await db.query(
    'SELECT * FROM users WHERE email = $1',
    [email]
  );
  
  if (!user) {
    return res.status(401).json({
      error: 'Invalid credentials'
    });
  }
  
  // Verify password
  const validPassword = await bcrypt.compare(password, user.password_hash);
  
  if (!validPassword) {
    return res.status(401).json({
      error: 'Invalid credentials'
    });
  }
  
  // Create session
  req.session.userId = user.id;
  req.session.email = user.email;
  req.session.role = user.role;
  
  // Session automatically saved to Redis
  
  res.json({
    message: 'Login successful',
    user: {
      id: user.id,
      email: user.email,
      name: user.name
    }
  });
});

// ============================================
// Protected endpoint
// ============================================
function requireAuth(req, res, next) {
  if (!req.session.userId) {
    return res.status(401).json({
      error: 'Authentication required'
    });
  }
  next();
}

app.get('/api/profile', requireAuth, async (req, res) => {
  // Session data available
  const user = await db.query(
    'SELECT * FROM users WHERE id = $1',
    [req.session.userId]
  );
  
  res.json({ user });
});

// ============================================
// Logout endpoint
// ============================================
app.post('/api/logout', (req, res) => {
  // Destroy session
  req.session.destroy((err) => {
    if (err) {
      return res.status(500).json({ error: 'Logout failed' });
    }
    
    res.clearCookie('connect.sid');
    res.json({ message: 'Logged out successfully' });
  });
});
```

### Pros and Cons

**Pros:**
- ✅ Server controls sessions (can revoke anytime)
- ✅ Simple to implement
- ✅ Secure (session data on server)

**Cons:**
- ❌ Requires server-side storage (Redis)
- ❌ Hard to scale (sticky sessions or shared store)
- ❌ CSRF vulnerability (need CSRF tokens)

---

## 3. Token-Based Authentication (JWT)

**How it works:** Server creates signed token, sends to client, client includes in requests.

### JWT Structure

```
Header.Payload.Signature

Header (base64):
{
  "alg": "HS256",
  "typ": "JWT"
}

Payload (base64):
{
  "sub": "user123",
  "email": "alice@example.com",
  "role": "admin",
  "iat": 1642089600,
  "exp": 1642176000
}

Signature:
HMACSHA256(
  base64(header) + "." + base64(payload),
  secret_key
)

Final JWT:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZW1haWwiOiJhbGljZUBleGFtcGxlLmNvbSIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTY0MjA4OTYwMCwiZXhwIjoxNjQyMTc2MDAwfQ.4Hb-5X9c8Y7Z6m3n2k1j0h9g8f7e6d5c4b3a2
```

### Implementation

```typescript
// ============================================
// JWT Authentication
// ============================================
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';
import { Request, Response, NextFunction } from 'express';

const JWT_SECRET = process.env.JWT_SECRET!;
const JWT_EXPIRY = '24h';
const REFRESH_TOKEN_EXPIRY = '7d';

// ============================================
// Login with JWT
// ============================================
app.post('/api/auth/login', async (req: Request, res: Response) => {
  const { email, password } = req.body;
  
  // Find user
  const user = await db.query(
    'SELECT * FROM users WHERE email = $1',
    [email]
  );
  
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Verify password
  const validPassword = await bcrypt.compare(password, user.password_hash);
  
  if (!validPassword) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Create access token (short-lived)
  const accessToken = jwt.sign(
    {
      sub: user.id,
      email: user.email,
      role: user.role
    },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRY }
  );
  
  // Create refresh token (long-lived)
  const refreshToken = jwt.sign(
    {
      sub: user.id,
      type: 'refresh'
    },
    JWT_SECRET,
    { expiresIn: REFRESH_TOKEN_EXPIRY }
  );
  
  // Store refresh token in database
  await db.query(
    'INSERT INTO refresh_tokens (user_id, token, expires_at) VALUES ($1, $2, $3)',
    [user.id, refreshToken, new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)]
  );
  
  res.json({
    accessToken,
    refreshToken,
    expiresIn: 24 * 60 * 60  // seconds
  });
});

// ============================================
// Authentication Middleware
// ============================================
function authenticateJWT(req: Request, res: Response, next: NextFunction) {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({
      error: 'No token provided'
    });
  }
  
  const token = authHeader.substring(7);
  
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    
    // Attach user info to request
    req.user = decoded;
    next();
    
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      return res.status(401).json({
        error: 'Token expired',
        code: 'TOKEN_EXPIRED'
      });
    }
    
    return res.status(401).json({
      error: 'Invalid token'
    });
  }
}

// ============================================
// Refresh Token Endpoint
// ============================================
app.post('/api/auth/refresh', async (req: Request, res: Response) => {
  const { refreshToken } = req.body;
  
  if (!refreshToken) {
    return res.status(401).json({ error: 'Refresh token required' });
  }
  
  try {
    // Verify refresh token
    const decoded = jwt.verify(refreshToken, JWT_SECRET) as any;
    
    if (decoded.type !== 'refresh') {
      return res.status(401).json({ error: 'Invalid token type' });
    }
    
    // Check if refresh token exists in database
    const storedToken = await db.query(
      'SELECT * FROM refresh_tokens WHERE user_id = $1 AND token = $2',
      [decoded.sub, refreshToken]
    );
    
    if (!storedToken) {
      return res.status(401).json({ error: 'Invalid refresh token' });
    }
    
    // Get user
    const user = await db.query(
      'SELECT * FROM users WHERE id = $1',
      [decoded.sub]
    );
    
    // Generate new access token
    const newAccessToken = jwt.sign(
      {
        sub: user.id,
        email: user.email,
        role: user.role
      },
      JWT_SECRET,
      { expiresIn: JWT_EXPIRY }
    );
    
    res.json({
      accessToken: newAccessToken,
      expiresIn: 24 * 60 * 60
    });
    
  } catch (error) {
    return res.status(401).json({ error: 'Invalid refresh token' });
  }
});

// ============================================
// Protected Route
// ============================================
app.get('/api/profile', authenticateJWT, async (req: Request, res: Response) => {
  // req.user available from middleware
  const user = await db.query(
    'SELECT id, email, name FROM users WHERE id = $1',
    [req.user.sub]
  );
  
  res.json({ user });
});

// ============================================
// Logout (Revoke Refresh Token)
// ============================================
app.post('/api/auth/logout', authenticateJWT, async (req: Request, res: Response) => {
  const { refreshToken } = req.body;
  
  // Delete refresh token from database
  await db.query(
    'DELETE FROM refresh_tokens WHERE user_id = $1 AND token = $2',
    [req.user.sub, refreshToken]
  );
  
  res.json({ message: 'Logged out successfully' });
});
```

### JWT Pros and Cons

**Pros:**
- ✅ Stateless (no server-side storage)
- ✅ Scales horizontally easily
- ✅ Works across domains
- ✅ Mobile-friendly

**Cons:**
- ❌ Can't revoke tokens (until expiry)
- ❌ Token size (sent with every request)
- ❌ Payload visible (base64 encoded, not encrypted)

---

## 4. OAuth 2.0

**Definition:** Industry-standard protocol for authorization. Allows third-party apps to access user data without sharing passwords.

### OAuth 2.0 Flows

**Authorization Code Flow (Most Secure)**

```
1. User clicks "Login with Google"
   App → Redirect to Google

2. User logs in to Google
   Google → Shows consent screen
   User → Approves

3. Google redirects back with code
   Google → https://yourapp.com/callback?code=ABC123

4. App exchanges code for tokens
   App → POST to Google with code
   Google → Returns access_token + refresh_token

5. App uses access token
   App → GET https://api.google.com/userinfo
         Authorization: Bearer access_token
```

### Implementation

```python
# ============================================
# OAuth 2.0 Server (Authorization Server)
# ============================================
from flask import Flask, request, redirect, jsonify
import secrets
import jwt
from datetime import datetime, timedelta

app = Flask(__name__)

# In-memory stores (use database in production)
authorization_codes = {}
access_tokens = {}

# ============================================
# Step 1: Authorization Endpoint
# ============================================
@app.route('/oauth/authorize')
def authorize():
    """
    Client initiates OAuth flow
    URL: /oauth/authorize?client_id=123&redirect_uri=...&response_type=code&scope=read
    """
    client_id = request.args.get('client_id')
    redirect_uri = request.args.get('redirect_uri')
    scope = request.args.get('scope', 'read')
    state = request.args.get('state')  # CSRF protection
    
    # Verify client_id and redirect_uri
    client = get_client(client_id)
    if not client or redirect_uri not in client['allowed_redirect_uris']:
        return jsonify({'error': 'invalid_client'}), 400
    
    # In real implementation: Show login page if not logged in
    # For demo: Assume user is logged in
    
    user_id = 'user_123'  # From session
    
    # Generate authorization code
    auth_code = secrets.token_urlsafe(32)
    
    # Store authorization code
    authorization_codes[auth_code] = {
        'user_id': user_id,
        'client_id': client_id,
        'scope': scope,
        'redirect_uri': redirect_uri,
        'expires_at': datetime.now() + timedelta(minutes=10)
    }
    
    # Redirect back to client with code
    redirect_url = f"{redirect_uri}?code={auth_code}"
    if state:
        redirect_url += f"&state={state}"
    
    return redirect(redirect_url)

# ============================================
# Step 2: Token Endpoint
# ============================================
@app.route('/oauth/token', methods=['POST'])
def token():
    """
    Client exchanges authorization code for tokens
    """
    grant_type = request.form.get('grant_type')
    code = request.form.get('code')
    client_id = request.form.get('client_id')
    client_secret = request.form.get('client_secret')
    redirect_uri = request.form.get('redirect_uri')
    
    # Verify client credentials
    client = get_client(client_id)
    if not client or client['secret'] != client_secret:
        return jsonify({'error': 'invalid_client'}), 401
    
    if grant_type == 'authorization_code':
        # Verify authorization code
        if code not in authorization_codes:
            return jsonify({'error': 'invalid_grant'}), 400
        
        auth_data = authorization_codes[code]
        
        # Verify code not expired
        if datetime.now() > auth_data['expires_at']:
            del authorization_codes[code]
            return jsonify({'error': 'expired_code'}), 400
        
        # Verify redirect_uri matches
        if redirect_uri != auth_data['redirect_uri']:
            return jsonify({'error': 'invalid_grant'}), 400
        
        # Generate access token
        access_token = jwt.sign(
            {
                'sub': auth_data['user_id'],
                'client_id': client_id,
                'scope': auth_data['scope'],
                'exp': datetime.now() + timedelta(hours=1)
            },
            JWT_SECRET
        )
        
        # Generate refresh token
        refresh_token = secrets.token_urlsafe(32)
        
        # Store tokens
        access_tokens[access_token] = {
            'user_id': auth_data['user_id'],
            'scope': auth_data['scope']
        }
        
        # Delete authorization code (one-time use)
        del authorization_codes[code]
        
        return jsonify({
            'access_token': access_token,
            'token_type': 'Bearer',
            'expires_in': 3600,
            'refresh_token': refresh_token,
            'scope': auth_data['scope']
        })
    
    elif grant_type == 'refresh_token':
        # Handle refresh token grant
        # Similar to authorization code flow
        pass
    
    return jsonify({'error': 'unsupported_grant_type'}), 400

# ============================================
# Protected Resource
# ============================================
@app.route('/api/userinfo')
def userinfo():
    """Resource server - requires valid access token"""
    auth_header = request.headers.get('Authorization')
    
    if not auth_header or not auth_header.startswith('Bearer '):
        return jsonify({'error': 'No token provided'}), 401
    
    token = auth_header[7:]
    
    try:
        decoded = jwt.verify(token, JWT_SECRET)
        
        # Get user info
        user = get_user(decoded['sub'])
        
        return jsonify({
            'sub': user['id'],
            'email': user['email'],
            'name': user['name']
        })
        
    except jwt.ExpiredSignatureError:
        return jsonify({'error': 'Token expired'}), 401
    except jwt.InvalidTokenError:
        return jsonify({'error': 'Invalid token'}), 401
```

### OAuth 2.0 Client (Using Google OAuth)

```javascript
// ============================================
// OAuth Client - Login with Google
// ============================================
const { OAuth2Client } = require('google-auth-library');

const client = new OAuth2Client(
  process.env.GOOGLE_CLIENT_ID,
  process.env.GOOGLE_CLIENT_SECRET,
  'http://localhost:3000/auth/google/callback'
);

// Step 1: Redirect to Google
app.get('/auth/google', (req, res) => {
  const authUrl = client.generateAuthUrl({
    access_type: 'offline',
    scope: [
      'https://www.googleapis.com/auth/userinfo.profile',
      'https://www.googleapis.com/auth/userinfo.email'
    ],
    state: generateCSRFToken()  // CSRF protection
  });
  
  res.redirect(authUrl);
});

// Step 2: Handle callback from Google
app.get('/auth/google/callback', async (req, res) => {
  const { code, state } = req.query;
  
  // Verify CSRF token
  if (!verifyCSRFToken(state)) {
    return res.status(403).send('Invalid state parameter');
  }
  
  try {
    // Exchange code for tokens
    const { tokens } = await client.getToken(code);
    client.setCredentials(tokens);
    
    // Get user info from Google
    const ticket = await client.verifyIdToken({
      idToken: tokens.id_token,
      audience: process.env.GOOGLE_CLIENT_ID
    });
    
    const payload = ticket.getPayload();
    
    // Find or create user in your database
    let user = await db.query(
      'SELECT * FROM users WHERE google_id = $1',
      [payload.sub]
    );
    
    if (!user) {
      user = await db.query(
        'INSERT INTO users (google_id, email, name) VALUES ($1, $2, $3) RETURNING *',
        [payload.sub, payload.email, payload.name]
      );
    }
    
    // Create your own JWT for the user
    const yourToken = jwt.sign(
      { sub: user.id, email: user.email },
      JWT_SECRET,
      { expiresIn: '24h' }
    );
    
    // Send token to client
    res.redirect(`/auth/success?token=${yourToken}`);
    
  } catch (error) {
    console.error('OAuth error:', error);
    res.status(500).send('Authentication failed');
  }
});
```

---

## 5. OpenID Connect

**Definition:** Authentication layer on top of OAuth 2.0. Provides user identity.

```
OAuth 2.0: Authorization ("Can I access your photos?")
OpenID Connect: Authentication ("Who are you?")
```

### ID Token

```json
{
  "iss": "https://accounts.google.com",
  "sub": "110169484474386276334",
  "azp": "your-client-id",
  "aud": "your-client-id",
  "iat": 1642089600,
  "exp": 1642093200,
  
  "email": "user@example.com",
  "email_verified": true,
  "name": "John Doe",
  "picture": "https://lh3.googleusercontent.com/...",
  "given_name": "John",
  "family_name": "Doe",
  "locale": "en"
}
```

---

## 6. Multi-Factor Authentication (MFA)

**Definition:** Require multiple forms of verification.

### Types

1. **Something you know** - Password, PIN
2. **Something you have** - Phone, security key
3. **Something you are** - Fingerprint, face

### TOTP (Time-Based One-Time Password)

```python
# ============================================
# MFA with TOTP (Google Authenticator)
# ============================================
import pyotp
import qrcode
import io

class MFAManager:
    def __init__(self):
        self.issuer_name = "MyApp"
    
    def generate_secret(self, user_email):
        """Generate TOTP secret for user"""
        secret = pyotp.random_base32()
        
        # Store secret in database
        db.execute(
            "UPDATE users SET mfa_secret = %s WHERE email = %s",
            (secret, user_email)
        )
        
        return secret
    
    def get_qr_code(self, user_email, secret):
        """Generate QR code for Google Authenticator"""
        # Create provisioning URI
        totp = pyotp.TOTP(secret)
        uri = totp.provisioning_uri(
            name=user_email,
            issuer_name=self.issuer_name
        )
        
        # Generate QR code
        qr = qrcode.QRCode(version=1, box_size=10, border=5)
        qr.add_data(uri)
        qr.make(fit=True)
        
        img = qr.make_image(fill_color="black", back_color="white")
        
        # Return as bytes
        buffer = io.BytesIO()
        img.save(buffer, format='PNG')
        return buffer.getvalue()
    
    def verify_totp(self, user_email, token):
        """Verify TOTP token"""
        # Get user's secret
        user = db.query(
            "SELECT mfa_secret FROM users WHERE email = %s",
            (user_email,)
        )
        
        if not user or not user['mfa_secret']:
            return False
        
        # Verify token
        totp = pyotp.TOTP(user['mfa_secret'])
        return totp.verify(token, valid_window=1)  # Allow 30s window

# ============================================
# MFA Endpoints
# ============================================

@app.route('/api/mfa/setup', methods=['POST'])
@require_auth
def setup_mfa():
    """Setup MFA for user"""
    user_email = request.user['email']
    
    # Generate secret
    secret = mfa_manager.generate_secret(user_email)
    
    # Generate QR code
    qr_code = mfa_manager.get_qr_code(user_email, secret)
    
    return {
        'secret': secret,
        'qr_code': base64.b64encode(qr_code).decode('utf-8')
    }

@app.route('/api/auth/login', methods=['POST'])
def login_with_mfa():
    """Login with MFA"""
    email = request.json['email']
    password = request.json['password']
    mfa_token = request.json.get('mfa_token')
    
    # Verify password
    user = verify_credentials(email, password)
    if not user:
        return {'error': 'Invalid credentials'}, 401
    
    # Check if MFA enabled
    if user['mfa_enabled']:
        if not mfa_token:
            # Password correct but MFA required
            return {
                'mfa_required': True,
                'message': 'Please provide MFA token'
            }, 401
        
        # Verify MFA token
        if not mfa_manager.verify_totp(email, mfa_token):
            return {'error': 'Invalid MFA token'}, 401
    
    # Generate JWT
    token = generate_jwt(user)
    
    return {'token': token}
```

---

## 7. Role-Based Access Control (RBAC)

**Definition:** Permissions assigned to roles, users assigned to roles.

### RBAC Model

```
Users → Roles → Permissions

User: Alice
  ↓
Role: Admin
  ↓
Permissions:
  - user:read
  - user:write
  - user:delete
  - post:read
  - post:write
  - post:delete
```

### Implementation

```typescript
// ============================================
// RBAC Implementation
// ============================================

interface Permission {
  resource: string;
  action: string;
}

interface Role {
  name: string;
  permissions: Permission[];
}

class RBACManager {
  private roles: Map<string, Role> = new Map();
  private userRoles: Map<string, string[]> = new Map();
  
  constructor() {
    this.initializeRoles();
  }
  
  private initializeRoles(): void {
    // Define roles and permissions
    this.roles.set('admin', {
      name: 'admin',
      permissions: [
        { resource: 'user', action: 'read' },
        { resource: 'user', action: 'write' },
        { resource: 'user', action: 'delete' },
        { resource: 'post', action: 'read' },
        { resource: 'post', action: 'write' },
        { resource: 'post', action: 'delete' },
        { resource: 'settings', action: 'write' }
      ]
    });
    
    this.roles.set('editor', {
      name: 'editor',
      permissions: [
        { resource: 'post', action: 'read' },
        { resource: 'post', action: 'write' },
        { resource: 'user', action: 'read' }
      ]
    });
    
    this.roles.set('viewer', {
      name: 'viewer',
      permissions: [
        { resource: 'post', action: 'read' },
        { resource: 'user', action: 'read' }
      ]
    });
  }
  
  assignRole(userId: string, roleName: string): void {
    if (!this.roles.has(roleName)) {
      throw new Error(`Role ${roleName} does not exist`);
    }
    
    if (!this.userRoles.has(userId)) {
      this.userRoles.set(userId, []);
    }
    
    this.userRoles.get(userId)!.push(roleName);
  }
  
  hasPermission(
    userId: string,
    resource: string,
    action: string
  ): boolean {
    const userRoleNames = this.userRoles.get(userId) || [];
    
    for (const roleName of userRoleNames) {
      const role = this.roles.get(roleName);
      
      if (role) {
        const hasPermission = role.permissions.some(
          p => p.resource === resource && p.action === action
        );
        
        if (hasPermission) {
          return true;
        }
      }
    }
    
    return false;
  }
  
  getUserPermissions(userId: string): Permission[] {
    const userRoleNames = this.userRoles.get(userId) || [];
    const permissions: Permission[] = [];
    
    for (const roleName of userRoleNames) {
      const role = this.roles.get(roleName);
      if (role) {
        permissions.push(...role.permissions);
      }
    }
    
    // Remove duplicates
    return Array.from(
      new Set(permissions.map(p => JSON.stringify(p)))
    ).map(p => JSON.parse(p));
  }
}

// ============================================
// Authorization Middleware
// ============================================

const rbac = new RBACManager();

// Assign roles
rbac.assignRole('user_alice', 'admin');
rbac.assignRole('user_bob', 'editor');
rbac.assignRole('user_charlie', 'viewer');

function requirePermission(resource: string, action: string) {
  return (req: any, res: any, next: any) => {
    const userId = req.user?.sub;
    
    if (!userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    if (!rbac.hasPermission(userId, resource, action)) {
      return res.status(403).json({
        error: 'Forbidden',
        message: `Missing permission: ${resource}:${action}`
      });
    }
    
    next();
  };
}

// Usage
app.delete('/api/users/:id',
  authenticateJWT,
  requirePermission('user', 'delete'),
  async (req, res) => {
    // Only users with 'user:delete' permission can access
    await deleteUser(req.params.id);
    res.json({ message: 'User deleted' });
  }
);

app.get('/api/posts',
  authenticateJWT,
  requirePermission('post', 'read'),
  async (req, res) => {
    // Anyone with 'post:read' can access
    const posts = await getPosts();
    res.json(posts);
  }
);
```

---

## 8. Attribute-Based Access Control (ABAC)

**Definition:** Access decisions based on attributes (user, resource, environment).

```python
# ============================================
# ABAC Implementation
# ============================================

class ABACManager:
    def evaluate(self, user, resource, action, environment):
        """
        Evaluate access based on attributes
        
        user: { id, role, department, clearance_level }
        resource: { id, owner_id, classification, department }
        action: 'read', 'write', 'delete'
        environment: { time, location, ip_address }
        """
        
        # Rule 1: Users can always read their own resources
        if action == 'read' and resource['owner_id'] == user['id']:
            return True
        
        # Rule 2: Admins can do anything
        if user['role'] == 'admin':
            return True
        
        # Rule 3: Users can read resources from their department
        if (action == 'read' and 
            user['department'] == resource['department']):
            return True
        
        # Rule 4: Can only access classified resources with sufficient clearance
        if resource.get('classification'):
            if user.get('clearance_level', 0) < resource['classification']:
                return False
        
        # Rule 5: No access outside business hours (except admins)
        if user['role'] != 'admin':
            hour = environment['time'].hour
            if hour < 9 or hour > 17:
                return False
        
        # Rule 6: Department managers can write to their department's resources
        if (action == 'write' and
            user['role'] == 'manager' and
            user['department'] == resource['department']):
            return True
        
        # Default: Deny
        return False

# Usage
abac = ABACManager()

user = {
    'id': 'user_123',
    'role': 'manager',
    'department': 'engineering',
    'clearance_level': 3
}

resource = {
    'id': 'doc_456',
    'owner_id': 'user_789',
    'classification': 2,
    'department': 'engineering'
}

environment = {
    'time': datetime.now(),
    'location': 'office',
    'ip_address': '10.0.1.50'
}

# Check permission
can_write = abac.evaluate(user, resource, 'write', environment)
if can_write:
    # Allow write operation
    pass
else:
    # Deny with 403 Forbidden
    pass
```

---

## 9. Single Sign-On (SSO)

**Definition:** Login once, access multiple applications.

### SAML 2.0 Flow

```
1. User accesses App
   App → Redirect to Identity Provider (IdP)

2. User logs in to IdP
   IdP → Authenticates user
      → Creates SAML assertion
      → Redirects back to App with assertion

3. App verifies SAML assertion
   App → Validates signature
      → Creates session
      → User logged in
```

### Implementation with Passport.js

```javascript
// ============================================
// SAML SSO with Passport
// ============================================
const passport = require('passport');
const SamlStrategy = require('passport-saml').Strategy;

passport.use(new SamlStrategy(
  {
    entryPoint: 'https://idp.example.com/saml/sso',
    issuer: 'myapp',
    callbackUrl: 'https://myapp.com/auth/saml/callback',
    cert: fs.readFileSync('/path/to/idp-cert.pem', 'utf-8')
  },
  function(profile, done) {
    // SAML assertion verified
    // profile contains user info from IdP
    
    // Find or create user
    User.findOrCreate({ saml_id: profile.nameID }, (err, user) => {
      if (err) return done(err);
      return done(null, user);
    });
  }
));

// Initiate SSO
app.get('/auth/saml', passport.authenticate('saml'));

// SSO callback
app.post('/auth/saml/callback',
  passport.authenticate('saml', {
    failureRedirect: '/login',
    failureFlash: true
  }),
  (req, res) => {
    // Successful authentication
    res.redirect('/dashboard');
  }
);
```

---

## Chapter 22 Summary

### Key Concepts

1. **Authentication** - Verify identity (who you are)
2. **Authorization** - Verify permissions (what you can do)
3. **Sessions** - Server-side state
4. **JWT** - Stateless tokens
5. **OAuth 2.0** - Delegated authorization
6. **OpenID Connect** - Authentication layer on OAuth
7. **MFA** - Multiple verification factors
8. **RBAC** - Role-based permissions
9. **ABAC** - Attribute-based permissions
10. **SSO** - Single login for multiple apps

### Authentication Methods Comparison

| Method | Scalability | Security | Complexity | Use Case |
|--------|-------------|----------|------------|----------|
| **Sessions** | Medium | High | Low | Traditional web apps |
| **JWT** | High | Medium | Medium | APIs, mobile apps |
| **OAuth 2.0** | High | High | High | Third-party integration |
| **SAML** | Medium | High | High | Enterprise SSO |

### Authorization Models

| Model | Complexity | Flexibility | Use Case |
|-------|------------|-------------|----------|
| **RBAC** | Low | Medium | Most applications |
| **ABAC** | High | High | Complex requirements |
| **ACL** | Low | Low | Simple permissions |

### Security Best Practices

1. **Always use HTTPS** - Encrypt tokens in transit
2. **Hash passwords** - bcrypt with salt
3. **Short-lived tokens** - Access token: 1 hour, Refresh: 7 days
4. **Validate all inputs** - Prevent injection attacks
5. **Implement MFA** - For sensitive operations
6. **Rate limit** - Login attempts
7. **Audit logs** - Track authentication events

### Interview Tips

**Common Questions:**
1. "Sessions vs JWT - when to use each?"
2. "Explain OAuth 2.0 flow"
3. "What is RBAC?"
4. "How does MFA work?"

**How to Answer:**
- Draw flow diagrams
- Explain trade-offs
- Give security considerations
- Mention standards (OAuth, OpenID Connect, SAML)
- Discuss implementation details

### Next Steps

Chapter 23 will cover **Security Best Practices** - protecting against common vulnerabilities, OWASP Top 10, and securing your application.