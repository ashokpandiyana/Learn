# Chapter 25: Cloud Computing Models

## Table of Contents
1. Introduction to Cloud Computing
2. IaaS (Infrastructure as a Service)
3. PaaS (Platform as a Service)
4. SaaS (Software as a Service)
5. Cloud Deployment Models
6. Cloud-Native Architecture
7. Shared Responsibility Model
8. Cost Optimization
9. Cloud Provider Comparison
10. Migration Strategies
11. Real-World Examples

---

## 1. Introduction to Cloud Computing

**Definition:** Cloud computing is the delivery of computing services (servers, storage, databases, networking, software) over the internet ("the cloud") on a pay-as-you-go basis.

### Key Characteristics

**1. On-Demand Self-Service**
- Provision resources without human interaction
- Instant access through web portal or API

**2. Broad Network Access**
- Available over network from any device
- Accessible via standard protocols

**3. Resource Pooling**
- Multi-tenant model
- Resources dynamically assigned
- Location independence

**4. Rapid Elasticity**
- Scale up/down automatically
- Appear unlimited to users
- Match demand in real-time

**5. Measured Service**
- Pay for what you use
- Resource usage monitored
- Transparent pricing

### Cloud vs Traditional

```
Traditional Data Center:
- Buy servers upfront ($10,000+)
- 3-6 months to provision
- Fixed capacity (over or under provisioned)
- You manage everything
- High upfront cost

Cloud:
- Pay per hour ($0.10/hour)
- Provision in minutes
- Scale capacity as needed
- Provider manages infrastructure
- No upfront cost
```

---

## 2. IaaS (Infrastructure as a Service)

**Definition:** Rent virtualized computing resources. You manage VMs, operating systems, applications.

### What You Get

```
Provider Manages:
- Physical servers
- Storage
- Networking hardware
- Hypervisor

You Manage:
- Operating system
- Middleware
- Runtime
- Applications
- Data
```

### Major IaaS Providers

**AWS EC2 Example:**

```python
# ============================================
# Launch EC2 Instance
# ============================================
import boto3

ec2 = boto3.client('ec2', region_name='us-east-1')

# Launch instance
response = ec2.run_instances(
    ImageId='ami-0c55b159cbfafe1f0',  # Ubuntu 20.04
    InstanceType='t3.medium',  # 2 vCPU, 4GB RAM
    MinCount=1,
    MaxCount=1,
    
    # Network configuration
    SubnetId='subnet-12345',
    SecurityGroupIds=['sg-67890'],
    
    # Storage
    BlockDeviceMappings=[
        {
            'DeviceName': '/dev/sda1',
            'Ebs': {
                'VolumeSize': 50,  # 50 GB
                'VolumeType': 'gp3',
                'DeleteOnTermination': True
            }
        }
    ],
    
    # User data (bootstrap script)
    UserData='''#!/bin/bash
        apt-get update
        apt-get install -y nodejs npm
        npm install -g pm2
        
        # Clone application
        git clone https://github.com/myapp/api.git /app
        cd /app
        npm install
        pm2 start server.js
    ''',
    
    # Tags
    TagSpecifications=[{
        'ResourceType': 'instance',
        'Tags': [
            {'Key': 'Name', 'Value': 'API-Server'},
            {'Key': 'Environment', 'Value': 'Production'}
        ]
    }]
)

instance_id = response['Instances'][0]['InstanceId']
print(f"Instance launched: {instance_id}")

# ============================================
# Manage Instance
# ============================================

# Stop instance
ec2.stop_instances(InstanceIds=[instance_id])

# Start instance
ec2.start_instances(InstanceIds=[instance_id])

# Terminate instance
ec2.terminate_instances(InstanceIds=[instance_id])

# Resize instance (change instance type)
ec2.modify_instance_attribute(
    InstanceId=instance_id,
    InstanceType={'Value': 't3.large'}  # Upgrade
)
```

**Google Compute Engine Example:**

```python
# ============================================
# Google Cloud Compute Engine
# ============================================
from googleapiclient import discovery
from google.oauth2 import service_account

credentials = service_account.Credentials.from_service_account_file(
    'credentials.json'
)

compute = discovery.build('compute', 'v1', credentials=credentials)

# Instance configuration
instance_config = {
    'name': 'api-server-1',
    'machineType': 'zones/us-central1-a/machineTypes/n1-standard-2',
    
    'disks': [{
        'boot': True,
        'autoDelete': True,
        'initializeParams': {
            'sourceImage': 'projects/ubuntu-os-cloud/global/images/family/ubuntu-2004-lts',
            'diskSizeGb': '50'
        }
    }],
    
    'networkInterfaces': [{
        'network': 'global/networks/default',
        'accessConfigs': [{
            'type': 'ONE_TO_ONE_NAT',
            'name': 'External NAT'
        }]
    }],
    
    'metadata': {
        'items': [{
            'key': 'startup-script',
            'value': '''#!/bin/bash
                apt-get update
                apt-get install -y nodejs npm
                # ... setup script
            '''
        }]
    }
}

# Create instance
operation = compute.instances().insert(
    project='my-project',
    zone='us-central1-a',
    body=instance_config
).execute()

print(f"Instance creation started: {operation['name']}")
```

### When to Use IaaS

✅ **Good for:**
- Full control over environment needed
- Custom software stack
- Legacy application migration (lift-and-shift)
- Compliance requirements (specific OS/config)

❌ **Not ideal for:**
- Want to avoid infrastructure management
- Need rapid deployment
- Small team without ops expertise

---

## 3. PaaS (Platform as a Service)

**Definition:** Platform for developing, running, and managing applications without managing infrastructure.

### What You Get

```
Provider Manages:
- Infrastructure (servers, storage, network)
- Operating system
- Middleware
- Runtime environment
- Auto-scaling
- Load balancing

You Manage:
- Application code
- Data
- Configuration
```

### AWS Elastic Beanstalk Example

```python
# ============================================
# Deploy to Elastic Beanstalk
# ============================================

# 1. Create application
eb_client = boto3.client('elasticbeanstalk')

app_response = eb_client.create_application(
    ApplicationName='MyApp',
    Description='My Node.js application'
)

# 2. Upload application code to S3
s3 = boto3.client('s3')
s3.upload_file(
    'app.zip',
    'my-app-versions',
    'v1.0.0.zip'
)

# 3. Create application version
version_response = eb_client.create_application_version(
    ApplicationName='MyApp',
    VersionLabel='v1.0.0',
    SourceBundle={
        'S3Bucket': 'my-app-versions',
        'S3Key': 'v1.0.0.zip'
    }
)

# 4. Create environment
env_response = eb_client.create_environment(
    ApplicationName='MyApp',
    EnvironmentName='MyApp-prod',
    VersionLabel='v1.0.0',
    
    SolutionStackName='64bit Amazon Linux 2 v5.5.0 running Node.js 16',
    
    OptionSettings=[
        # Instance type
        {
            'Namespace': 'aws:autoscaling:launchconfiguration',
            'OptionName': 'InstanceType',
            'Value': 't3.medium'
        },
        # Auto-scaling
        {
            'Namespace': 'aws:autoscaling:asg',
            'OptionName': 'MinSize',
            'Value': '2'
        },
        {
            'Namespace': 'aws:autoscaling:asg',
            'OptionName': 'MaxSize',
            'Value': '10'
        },
        # Load balancer
        {
            'Namespace': 'aws:elasticbeanstalk:environment',
            'OptionName': 'LoadBalancerType',
            'Value': 'application'
        },
        # Environment variables
        {
            'Namespace': 'aws:elasticbeanstalk:application:environment',
            'OptionName': 'DATABASE_URL',
            'Value': 'postgresql://...'
        },
        {
            'Namespace': 'aws:elasticbeanstalk:application:environment',
            'OptionName': 'NODE_ENV',
            'Value': 'production'
        }
    ]
)

print(f"Environment created: {env_response['EnvironmentName']}")
print(f"URL: {env_response['CNAME']}")

# Elastic Beanstalk automatically:
# - Creates load balancer
# - Launches EC2 instances
# - Sets up auto-scaling
# - Configures monitoring
# - Manages deployments
```

### Heroku Example (Pure PaaS)

```bash
# ============================================
# Deploy to Heroku (Git-based)
# ============================================

# 1. Create Heroku app
heroku create myapp

# 2. Add database
heroku addons:create heroku-postgresql:hobby-dev

# 3. Set environment variables
heroku config:set NODE_ENV=production
heroku config:set API_KEY=your-api-key

# 4. Deploy (just git push!)
git push heroku main

# Heroku automatically:
# - Detects Node.js app (package.json)
# - Installs dependencies (npm install)
# - Runs build scripts
# - Starts application (npm start)
# - Manages scaling, load balancing

# 5. Scale application
heroku ps:scale web=3  # 3 dynos (containers)

# 6. View logs
heroku logs --tail

# Everything managed - just push code!
```

### Google App Engine Example

```yaml
# ============================================
# app.yaml - App Engine Configuration
# ============================================
runtime: nodejs16

# Automatic scaling
automatic_scaling:
  min_instances: 2
  max_instances: 10
  target_cpu_utilization: 0.6
  target_throughput_utilization: 0.7

# Environment variables
env_variables:
  NODE_ENV: production
  DATABASE_URL: postgresql://...

# Handlers
handlers:
  # Static files
  - url: /static
    static_dir: static
    secure: always
    
  # API routes
  - url: /.*
    script: auto
    secure: always

# Health check
liveness_check:
  path: "/health/live"
  check_interval_sec: 30
  timeout_sec: 4
  failure_threshold: 2

readiness_check:
  path: "/health/ready"
  check_interval_sec: 5
  timeout_sec: 4
  failure_threshold: 2
```

```bash
# Deploy to App Engine
gcloud app deploy

# App Engine automatically:
# - Builds container
# - Deploys to managed infrastructure
# - Sets up load balancing
# - Manages scaling
# - Provides SSL certificate
# - Monitors health
```

### When to Use PaaS

✅ **Good for:**
- Focus on code, not infrastructure
- Rapid development and deployment
- Automatic scaling needed
- Small teams

❌ **Not ideal for:**
- Need custom OS configuration
- Vendor lock-in concerns
- Cost-sensitive at scale (can be expensive)
- Need specific infrastructure setup

---

## 4. SaaS (Software as a Service)

**Definition:** Fully managed applications accessed via web browser. Provider manages everything.

### Characteristics

```
Provider Manages:
- Infrastructure
- Platform
- Application
- Updates
- Security
- Backups

You Manage:
- User data
- Access control
- Configuration
```

### Examples

**1. Salesforce (CRM)**
```
No code to write or deploy
Just:
- Create account
- Configure workflows
- Add users
- Enter data

Salesforce handles:
- Servers
- Database
- Updates
- Security
- Backups
```

**2. Building Multi-Tenant SaaS**

```typescript
// ============================================
// Multi-Tenant SaaS Architecture
// ============================================

interface Tenant {
  id: string;
  name: string;
  subdomain: string;
  plan: 'free' | 'basic' | 'premium';
  features: string[];
}

class MultiTenantService {
  private db: Database;
  
  async getTenantFromRequest(req: Request): Promise<Tenant> {
    // Method 1: Subdomain-based
    const subdomain = req.hostname.split('.')[0];
    const tenant = await this.db.query(
      'SELECT * FROM tenants WHERE subdomain = $1',
      [subdomain]
    );
    
    // Method 2: Header-based
    // const tenantId = req.headers['x-tenant-id'];
    
    return tenant;
  }
  
  async getUserData(userId: string, tenantId: string): Promise<any> {
    // Data isolated by tenant
    return await this.db.query(
      'SELECT * FROM users WHERE id = $1 AND tenant_id = $2',
      [userId, tenantId]
    );
  }
  
  async checkFeatureAccess(tenant: Tenant, feature: string): Promise<boolean> {
    // Feature gating by plan
    const planFeatures = {
      free: ['basic_features'],
      basic: ['basic_features', 'advanced_reports'],
      premium: ['basic_features', 'advanced_reports', 'api_access', 'white_label']
    };
    
    return planFeatures[tenant.plan].includes(feature);
  }
}

// Middleware
async function tenantMiddleware(req: any, res: any, next: any) {
  try {
    const tenant = await multiTenantService.getTenantFromRequest(req);
    
    if (!tenant) {
      return res.status(404).json({ error: 'Tenant not found' });
    }
    
    // Attach tenant to request
    req.tenant = tenant;
    next();
    
  } catch (error) {
    res.status(500).json({ error: 'Failed to identify tenant' });
  }
}

// Protected route with tenant isolation
app.get('/api/users', tenantMiddleware, authenticate, async (req, res) => {
  // Data automatically scoped to tenant
  const users = await db.query(
    'SELECT * FROM users WHERE tenant_id = $1',
    [req.tenant.id]
  );
  
  res.json(users);
});

// Feature-gated endpoint
app.get('/api/reports/advanced', 
  tenantMiddleware,
  authenticate,
  async (req, res) => {
    // Check if tenant has access to feature
    const hasAccess = await multiTenantService.checkFeatureAccess(
      req.tenant,
      'advanced_reports'
    );
    
    if (!hasAccess) {
      return res.status(403).json({
        error: 'Feature not available in your plan',
        upgrade_url: '/pricing'
      });
    }
    
    const reports = await generateAdvancedReports(req.tenant.id);
    res.json(reports);
  }
);
```

---

## 5. Cloud Deployment Models

### Public Cloud

**Definition:** Services offered over public internet, available to anyone.

**Providers:** AWS, Azure, GCP, DigitalOcean

**Characteristics:**
- Lowest cost
- Highest scalability
- Shared infrastructure
- Less control

```python
# Public cloud deployment
# Everything in AWS

vpc = create_vpc()
subnets = create_subnets(vpc)
instances = launch_ec2_instances(subnets)
database = create_rds_instance(subnets)

# Accessible from internet
# Managed by AWS
# Pay-as-you-go
```

### Private Cloud

**Definition:** Dedicated cloud infrastructure for single organization.

**Solutions:** OpenStack, VMware vSphere, Azure Stack

**Characteristics:**
- Greater control
- Enhanced security
- Higher cost
- Limited scalability

```yaml
# ============================================
# OpenStack Private Cloud
# ============================================
# Deploy on your own hardware

heat_template_version: 2015-04-30

description: Private cloud deployment

resources:
  my_instance:
    type: OS::Nova::Server
    properties:
      name: api-server
      image: ubuntu-20.04
      flavor: m1.medium
      networks:
        - network: private-network
      
  my_volume:
    type: OS::Cinder::Volume
    properties:
      size: 100
      
  my_network:
    type: OS::Neutron::Net
    properties:
      name: private-network

# Full control over infrastructure
# Runs in your data center
# You manage everything
```

### Hybrid Cloud

**Definition:** Combination of public and private clouds.

```
Architecture:
┌─────────────────────┐         ┌─────────────────────┐
│  Private Cloud      │         │  Public Cloud       │
│  (On-Premise)       │←───VPN──│  (AWS)             │
│                     │         │                     │
│  - Customer Data    │         │  - Web Tier        │
│  - Core Database    │         │  - App Tier        │
│  - Legacy Systems   │         │  - Caching         │
└─────────────────────┘         └─────────────────────┘

Use Cases:
- Keep sensitive data on-premise
- Burst to cloud for peak traffic
- Gradual cloud migration
- Regulatory compliance
```

**Implementation:**

```python
# ============================================
# Hybrid Cloud Data Sync
# ============================================

class HybridCloudSync:
    def __init__(self):
        self.on_premise_db = connect_to_on_premise()
        self.cloud_db = connect_to_aws_rds()
        self.vpn_connected = self.check_vpn_connection()
    
    async def sync_to_cloud(self):
        """Sync data from on-premise to cloud"""
        if not self.vpn_connected:
            raise Exception("VPN connection required")
        
        # Get recent changes from on-premise
        changes = await self.on_premise_db.query("""
            SELECT * FROM customers 
            WHERE updated_at > NOW() - INTERVAL '1 hour'
        """)
        
        # Sync to cloud (for analytics, backup)
        for record in changes:
            await self.cloud_db.query("""
                INSERT INTO customers (id, name, email, updated_at)
                VALUES ($1, $2, $3, $4)
                ON CONFLICT (id) DO UPDATE
                SET name = $2, email = $3, updated_at = $4
            """, [record['id'], record['name'], record['email'], record['updated_at']])
        
        print(f"Synced {len(changes)} records to cloud")
    
    async def run_analytics_in_cloud(self):
        """Run analytics on cloud copy (don't burden on-premise DB)"""
        results = await self.cloud_db.query("""
            SELECT 
                DATE_TRUNC('month', created_at) as month,
                COUNT(*) as customer_count,
                AVG(order_total) as avg_order
            FROM customers
            GROUP BY month
            ORDER BY month DESC
        """)
        
        return results

# Schedule hourly sync
schedule.every().hour.do(sync.sync_to_cloud)
```

### Multi-Cloud

**Definition:** Using multiple cloud providers.

```
AWS: Primary application hosting
GCP: Machine learning workloads
Azure: Active Directory integration

Benefits:
- Avoid vendor lock-in
- Use best service from each provider
- Geographic diversity

Challenges:
- Complex management
- Multiple billing systems
- Different APIs
- Higher operational overhead
```

---

## 6. Cloud-Native Architecture

**Definition:** Applications designed specifically for cloud environments.

### Cloud-Native Principles

**1. Microservices Architecture**
```
Not: One monolithic app
But: Many small services
```

**2. Containerization**
```
Package apps in containers (Docker)
Run anywhere consistently
```

**3. Dynamic Orchestration**
```
Kubernetes manages containers
Auto-scaling, self-healing
```

**4. DevOps & CI/CD**
```
Automated testing and deployment
Infrastructure as code
```

### Cloud-Native Application Example

```yaml
# ============================================
# Kubernetes Deployment (Cloud-Native)
# ============================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-server
  labels:
    app: api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: api
  template:
    metadata:
      labels:
        app: api
    spec:
      containers:
      - name: api
        image: myapp/api:v1.0.0
        ports:
        - containerPort: 3000
        
        # Environment from ConfigMap
        envFrom:
        - configMapRef:
            name: api-config
        
        # Secrets from Secret
        env:
        - name: DATABASE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: password
        
        # Resource limits
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        
        # Health checks
        livenessProbe:
          httpGet:
            path: /health/live
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5

---
# Service (Load Balancer)
apiVersion: v1
kind: Service
metadata:
  name: api-service
spec:
  type: LoadBalancer
  selector:
    app: api
  ports:
  - port: 80
    targetPort: 3000

---
# Horizontal Pod Autoscaler
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: api-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: api-server
  minReplicas: 3
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

### 12-Factor App Methodology

```
1. Codebase: One codebase in version control
2. Dependencies: Explicitly declare dependencies
3. Config: Store config in environment
4. Backing Services: Treat as attached resources
5. Build, Release, Run: Strict separation
6. Processes: Stateless processes
7. Port Binding: Self-contained
8. Concurrency: Scale via process model
9. Disposability: Fast startup/shutdown
10. Dev/Prod Parity: Keep environments similar
11. Logs: Treat as event streams
12. Admin Processes: Run as one-off processes
```

---

## 7. Shared Responsibility Model

### AWS Shared Responsibility

```
┌────────────────────────────────────────────┐
│          Customer Responsibility           │
├────────────────────────────────────────────┤
│  - Data                                    │
│  - Platform, Applications                  │
│  - Identity & Access Management            │
│  - Operating System                        │
│  - Network & Firewall Configuration        │
│  - Client-Side Encryption                  │
│  - Server-Side Encryption                  │
│  - Network Traffic Protection              │
└────────────────────────────────────────────┘
            Security "IN" the Cloud

┌────────────────────────────────────────────┐
│           AWS Responsibility               │
├────────────────────────────────────────────┤
│  - Physical Security                       │
│  - Infrastructure                          │
│  - Network Infrastructure                  │
│  - Hypervisor                             │
│  - Hardware                                │
│  - Data Centers                            │
│  - Regions & Availability Zones            │
└────────────────────────────────────────────┘
            Security "OF" the Cloud
```

### By Service Model

```
IaaS (EC2):
You: OS, apps, data, network config, security groups
AWS: Hardware, hypervisor, physical security

PaaS (Elastic Beanstalk):
You: Application code, data
AWS: OS, runtime, infrastructure

SaaS (S3):
You: Data, access policies
AWS: Everything else
```

---

## 8. Cost Optimization

### Reserved Instances vs On-Demand

```python
# ============================================
# Cost Comparison
# ============================================

# On-Demand (pay per hour)
on_demand_cost = {
    't3.medium': 0.0416  # per hour
}

monthly_cost = on_demand_cost['t3.medium'] * 24 * 30
# $29.95/month

# Reserved Instance (1-year commitment)
reserved_cost = {
    't3.medium': 0.0260  # per hour (37% savings)
}

monthly_cost_reserved = reserved_cost['t3.medium'] * 24 * 30
# $18.72/month

# Savings: $11.23/month per instance
# For 10 instances: $112.30/month = $1,347/year

# Reserved Instance (3-year commitment)
reserved_3yr_cost = {
    't3.medium': 0.0166  # per hour (60% savings)
}

monthly_cost_reserved_3yr = reserved_3yr_cost['t3.medium'] * 24 * 30
# $11.95/month

# Savings: $17.99/month per instance
# For 10 instances: $179.90/month = $2,159/year
```

### Spot Instances (For Fault-Tolerant Workloads)

```python
# ============================================
# Launch Spot Instance
# ============================================

# Spot instances: Up to 90% cheaper
# Can be terminated with 2-minute warning

response = ec2.request_spot_instances(
    SpotPrice='0.02',  # Max price willing to pay
    InstanceCount=5,
    LaunchSpecification={
        'ImageId': 'ami-12345',
        'InstanceType': 't3.medium',
        'SecurityGroupIds': ['sg-12345'],
        'SubnetId': 'subnet-12345',
        
        # User data to handle termination
        'UserData': '''#!/bin/bash
            # Check for termination notice every 5 seconds
            while true; do
                if curl -s http://169.254.169.254/latest/meta-data/spot/termination-time | grep -q 404; then
                    sleep 5
                else
                    # 2-minute warning received
                    echo "Termination notice received"
                    
                    # Graceful shutdown
                    pm2 stop all
                    
                    # Drain tasks
                    python drain_tasks.py
                    
                    exit 0
                fi
            done
        '''
    }
)

# Good for:
# - Batch processing
# - CI/CD runners
# - Data analysis
# - Fault-tolerant workloads

# Not good for:
# - Databases
# - Stateful applications
# - Critical always-on services
```

### Cost Optimization Strategies

```python
# ============================================
# Automated Cost Optimization
# ============================================

class CostOptimizer:
    def __init__(self):
        self.ec2 = boto3.client('ec2')
        self.cloudwatch = boto3.client('cloudwatch')
    
    def find_idle_resources(self):
        """Find underutilized resources"""
        
        # Get all running instances
        instances = self.ec2.describe_instances(
            Filters=[{'Name': 'instance-state-name', 'Values': ['running']}]
        )
        
        idle_instances = []
        
        for reservation in instances['Reservations']:
            for instance in reservation['Instances']:
                instance_id = instance['InstanceId']
                
                # Get CPU utilization
                cpu_stats = self.cloudwatch.get_metric_statistics(
                    Namespace='AWS/EC2',
                    MetricName='CPUUtilization',
                    Dimensions=[{'Name': 'InstanceId', 'Value': instance_id}],
                    StartTime=datetime.now() - timedelta(days=7),
                    EndTime=datetime.now(),
                    Period=3600,  # 1 hour
                    Statistics=['Average']
                )
                
                # Calculate average CPU
                if cpu_stats['Datapoints']:
                    avg_cpu = sum(d['Average'] for d in cpu_stats['Datapoints']) / len(cpu_stats['Datapoints'])
                    
                    if avg_cpu < 5:  # Less than 5% CPU for a week
                        idle_instances.append({
                            'instance_id': instance_id,
                            'avg_cpu': avg_cpu,
                            'type': instance['InstanceType']
                        })
        
        return idle_instances
    
    def rightsize_recommendations(self):
        """Recommend instance type changes"""
        
        # Example: Instance using 20% CPU consistently
        # Recommendation: Downgrade from t3.large → t3.medium
        # Savings: ~$30/month
        
        pass
    
    def cleanup_unused_resources(self):
        """Delete unused resources"""
        
        # Unattached EBS volumes
        volumes = self.ec2.describe_volumes(
            Filters=[{'Name': 'status', 'Values': ['available']}]
        )
        
        for volume in volumes['Volumes']:
            # Check if unused for > 30 days
            # Delete if confirmed unused
            pass
        
        # Unused Elastic IPs
        addresses = self.ec2.describe_addresses(
            Filters=[{'Name': 'instance-id', 'Values': []}]
        )
        
        # Release unattached IPs
        for address in addresses['Addresses']:
            print(f"Unused Elastic IP: {address['PublicIp']} - $3.60/month wasted")
```

---

## 9. Cloud Provider Comparison

### Service Mapping

| Service | AWS | Azure | GCP |
|---------|-----|-------|-----|
| **Compute** | EC2 | Virtual Machines | Compute Engine |
| **Containers** | ECS, EKS | AKS | GKE |
| **Serverless** | Lambda | Functions | Cloud Functions |
| **Storage** | S3 | Blob Storage | Cloud Storage |
| **Database (SQL)** | RDS | SQL Database | Cloud SQL |
| **Database (NoSQL)** | DynamoDB | Cosmos DB | Firestore |
| **Cache** | ElastiCache | Redis Cache | Memorystore |
| **CDN** | CloudFront | Azure CDN | Cloud CDN |
| **Load Balancer** | ALB/NLB | Load Balancer | Cloud Load Balancing |
| **Queue** | SQS | Queue Storage | Pub/Sub |
| **DNS** | Route 53 | DNS | Cloud DNS |

### Choosing a Provider

```
Choose AWS if:
✅ Largest service catalog
✅ Most mature
✅ Best third-party integrations
✅ Need widest range of services

Choose Azure if:
✅ Microsoft shop (.NET, Windows, Active Directory)
✅ Hybrid cloud requirements
✅ Enterprise agreements with Microsoft
✅ Strong compliance requirements

Choose GCP if:
✅ Data analytics (BigQuery)
✅ Machine learning (TensorFlow)
✅ Kubernetes (GKE is best)
✅ Open source friendly
```

---

## 10. Migration Strategies

### The 6 Rs of Cloud Migration

**1. Rehost (Lift and Shift)**
```
Move as-is to cloud
- Fastest migration
- Minimal changes
- Don't get cloud benefits

Example: VM → EC2
```

**2. Replatform (Lift, Tinker, and Shift)**
```
Minor optimizations
- Some cloud services
- Managed databases

Example: Self-hosted MySQL → RDS
```

**3. Repurchase (Drop and Shop)**
```
Move to SaaS
- Replace custom with SaaS

Example: Custom CRM → Salesforce
```

**4. Refactor (Re-architect)**
```
Rebuild for cloud
- Microservices
- Serverless
- Fully cloud-native

Example: Monolith → Microservices on EKS
```

**5. Retire**
```
Decommission unused apps
- Save costs
- Reduce complexity
```

**6. Retain**
```
Keep on-premise
- Not ready for cloud
- Compliance reasons
```

### Migration Example

```python
# ============================================
# Database Migration to Cloud
# ============================================

class DatabaseMigration:
    def __init__(self, source_db, target_db):
        self.source = source_db
        self.target = target_db
    
    def migrate(self):
        """Migrate database with minimal downtime"""
        
        # Phase 1: Setup replication (0 downtime)
        print("Phase 1: Setting up replication...")
        self.setup_replication()
        
        # Phase 2: Sync data (0 downtime)
        print("Phase 2: Initial sync...")
        self.initial_sync()
        
        # Phase 3: Monitor replication lag
        print("Phase 3: Monitoring replication...")
        while self.get_replication_lag() > 1:  # Wait until < 1 second lag
            time.sleep(10)
        
        # Phase 4: Cut over (brief downtime)
        print("Phase 4: Cutting over...")
        
        # Stop application
        self.stop_application()
        
        # Wait for final sync
        time.sleep(5)
        
        # Update application config to use new database
        self.update_connection_string(self.target)
        
        # Start application
        self.start_application()
        
        print("Migration complete!")
        
        # Phase 5: Cleanup (after verification)
        # Keep old database for 1 week as backup
        schedule.schedule_at(
            datetime.now() + timedelta(days=7),
            self.decommission_old_database
        )
```

---

## Chapter 25 Summary

### Key Concepts

1. **IaaS** - Rent virtual machines, manage OS and apps
2. **PaaS** - Platform for apps, manage code only
3. **SaaS** - Fully managed software
4. **Public Cloud** - Shared infrastructure (AWS, Azure, GCP)
5. **Private Cloud** - Dedicated infrastructure
6. **Hybrid Cloud** - Mix of public and private
7. **Cloud-Native** - Built for cloud (microservices, containers)
8. **Shared Responsibility** - Security split between you and provider

### Service Model Comparison

| Aspect | IaaS | PaaS | SaaS |
|--------|------|------|------|
| **Control** | High | Medium | Low |
| **Flexibility** | High | Medium | Low |
| **Management** | You manage OS+ | You manage code | Provider manages all |
| **Time to Deploy** | Hours | Minutes | Instant |
| **Expertise Required** | High | Medium | Low |
| **Use Case** | Custom stack | Web/mobile apps | Business tools |
| **Examples** | EC2, GCE | Heroku, App Engine | Gmail, Salesforce |

### Cost Optimization

**Strategies:**
1. **Right-sizing** - Use appropriate instance types
2. **Reserved Instances** - 1-3 year commitments (37-60% savings)
3. **Spot Instances** - For fault-tolerant workloads (up to 90% savings)
4. **Auto-scaling** - Scale down during low traffic
5. **Cleanup** - Delete unused resources
6. **Storage tiers** - S3 Standard → Glacier for old data

### Migration Path

```
1. Assess current infrastructure
2. Classify applications (6 Rs)
3. Start with Rehost (quick wins)
4. Gradually Refactor critical apps
5. Move to managed services (RDS, ElastiCache)
6. Adopt cloud-native patterns
```

### Interview Tips

**Common Questions:**
1. "IaaS vs PaaS vs SaaS - differences?"
2. "When would you use each service model?"
3. "What is the shared responsibility model?"
4. "How do you optimize cloud costs?"
5. "Public vs Private vs Hybrid cloud?"

**How to Answer:**
- Use concrete examples (EC2 for IaaS, Heroku for PaaS)
- Explain control vs convenience trade-off
- Discuss shared responsibility clearly
- Mention cost optimization strategies
- Give real migration scenarios

### Next Steps

Chapter 26 will cover **Distributed Systems Concepts** - CAP theorem, consensus algorithms, distributed transactions, and the challenges of building distributed systems.