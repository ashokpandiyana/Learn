# Chapter 3: Design Patterns (Gang of Four)

## Table of Contents
1. Introduction to Design Patterns
2. Creational Patterns
3. Structural Patterns
4. Behavioral Patterns
5. When to Use Each Pattern

---

## 1. Introduction to Design Patterns

**What are Design Patterns?**
Design patterns are reusable solutions to commonly occurring problems in software design. They represent best practices refined by experienced developers.

**Benefits:**
- Proven solutions
- Common vocabulary for developers
- Speed up development
- Prevent subtle issues

**Categories:**
1. **Creational** - Object creation mechanisms
2. **Structural** - Object composition
3. **Behavioral** - Communication between objects

---

## 2. CREATIONAL PATTERNS

Creational patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.

---

### 2.1 Singleton Pattern

**Intent:** Ensure a class has only one instance and provide a global point of access to it.

**When to Use:**
- Database connections
- Configuration managers
- Logging services
- Thread pools

**Structure:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Singleton     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ - instance      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + getInstance() ‚îÇ
‚îÇ - Singleton()   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### Implementation Examples

**Python (Thread-Safe):**
```python
import threading

class DatabaseConnection:
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                # Double-check locking
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialize()
        return cls._instance
    
    def _initialize(self):
        self.connection = "Connected to database"
        print("Database connection created")
    
    def query(self, sql):
        return f"Executing: {sql}"

# Usage
db1 = DatabaseConnection()
db2 = DatabaseConnection()

print(db1 is db2)  # True - same instance
print(db1.query("SELECT * FROM users"))
```

**Java (Enum Singleton - Best Practice):**
```java
public enum DatabaseConnection {
    INSTANCE;
    
    private Connection connection;
    
    DatabaseConnection() {
        // Initialize connection
        this.connection = createConnection();
    }
    
    private Connection createConnection() {
        System.out.println("Creating database connection");
        // Return actual connection
        return new Connection();
    }
    
    public void query(String sql) {
        System.out.println("Executing: " + sql);
    }
}

// Usage
DatabaseConnection.INSTANCE.query("SELECT * FROM users");
// Thread-safe, serialization-safe, prevents reflection attacks
```

**JavaScript (Module Pattern):**
```javascript
const DatabaseConnection = (() => {
    let instance;
    
    function createInstance() {
        return {
            connection: "Connected to database",
            query: function(sql) {
                return `Executing: ${sql}`;
            }
        };
    }
    
    return {
        getInstance: function() {
            if (!instance) {
                instance = createInstance();
            }
            return instance;
        }
    };
})();

// Usage
const db1 = DatabaseConnection.getInstance();
const db2 = DatabaseConnection.getInstance();

console.log(db1 === db2);  // true
console.log(db1.query("SELECT * FROM users"));
```

**‚ö†Ô∏è Warnings:**
- Makes unit testing difficult (global state)
- Can hide dependencies
- Consider dependency injection instead
- Multi-threading requires careful implementation

---

### 2.2 Factory Pattern

**Intent:** Define an interface for creating objects, but let subclasses decide which class to instantiate.

**When to Use:**
- When you don't know the exact types of objects needed beforehand
- When object creation logic is complex
- When you want to centralize object creation

#### Simple Factory

```python
from abc import ABC, abstractmethod

# Product interface
class Vehicle(ABC):
    @abstractmethod
    def drive(self):
        pass

# Concrete products
class Car(Vehicle):
    def drive(self):
        return "Driving a car üöó"

class Bike(Vehicle):
    def drive(self):
        return "Riding a bike üö≤"

class Truck(Vehicle):
    def drive(self):
        return "Driving a truck üöö"

# Simple Factory
class VehicleFactory:
    @staticmethod
    def create_vehicle(vehicle_type):
        if vehicle_type == "car":
            return Car()
        elif vehicle_type == "bike":
            return Bike()
        elif vehicle_type == "truck":
            return Truck()
        else:
            raise ValueError(f"Unknown vehicle type: {vehicle_type}")

# Usage
factory = VehicleFactory()

vehicle1 = factory.create_vehicle("car")
print(vehicle1.drive())  # Driving a car üöó

vehicle2 = factory.create_vehicle("bike")
print(vehicle2.drive())  # Riding a bike üö≤
```

#### Factory Method Pattern

```java
// Product interface
interface Logger {
    void log(String message);
}

// Concrete products
class FileLogger implements Logger {
    public void log(String message) {
        System.out.println("Logging to file: " + message);
    }
}

class DatabaseLogger implements Logger {
    public void log(String message) {
        System.out.println("Logging to database: " + message);
    }
}

class ConsoleLogger implements Logger {
    public void log(String message) {
        System.out.println("Console: " + message);
    }
}

// Creator (abstract)
abstract class Application {
    // Factory method
    protected abstract Logger createLogger();
    
    public void run() {
        Logger logger = createLogger();
        logger.log("Application started");
        // Application logic...
        logger.log("Application finished");
    }
}

// Concrete creators
class DevelopmentApp extends Application {
    @Override
    protected Logger createLogger() {
        return new ConsoleLogger();  // Use console in development
    }
}

class ProductionApp extends Application {
    @Override
    protected Logger createLogger() {
        return new DatabaseLogger();  // Use database in production
    }
}

// Usage
Application devApp = new DevelopmentApp();
devApp.run();  // Uses ConsoleLogger

Application prodApp = new ProductionApp();
prodApp.run();  // Uses DatabaseLogger
```

---

### 2.3 Abstract Factory Pattern

**Intent:** Provide an interface for creating families of related objects without specifying concrete classes.

**When to Use:**
- System needs to be independent of how products are created
- System needs to work with multiple families of products
- You want to ensure products from the same family are used together

```typescript
// Abstract products
interface Button {
    render(): void;
    onClick(): void;
}

interface Checkbox {
    render(): void;
    toggle(): void;
}

// Concrete products - Windows family
class WindowsButton implements Button {
    render(): void {
        console.log("Rendering Windows button");
    }
    
    onClick(): void {
        console.log("Windows button clicked");
    }
}

class WindowsCheckbox implements Checkbox {
    render(): void {
        console.log("Rendering Windows checkbox");
    }
    
    toggle(): void {
        console.log("Windows checkbox toggled");
    }
}

// Concrete products - Mac family
class MacButton implements Button {
    render(): void {
        console.log("Rendering Mac button");
    }
    
    onClick(): void {
        console.log("Mac button clicked");
    }
}

class MacCheckbox implements Checkbox {
    render(): void {
        console.log("Rendering Mac checkbox");
    }
    
    toggle(): void {
        console.log("Mac checkbox toggled");
    }
}

// Abstract factory
interface GUIFactory {
    createButton(): Button;
    createCheckbox(): Checkbox;
}

// Concrete factories
class WindowsFactory implements GUIFactory {
    createButton(): Button {
        return new WindowsButton();
    }
    
    createCheckbox(): Checkbox {
        return new WindowsCheckbox();
    }
}

class MacFactory implements GUIFactory {
    createButton(): Button {
        return new MacButton();
    }
    
    createCheckbox(): Checkbox {
        return new MacCheckbox();
    }
}

// Client code
class Application {
    private button: Button;
    private checkbox: Checkbox;
    
    constructor(factory: GUIFactory) {
        this.button = factory.createButton();
        this.checkbox = factory.createCheckbox();
    }
    
    render(): void {
        this.button.render();
        this.checkbox.render();
    }
}

// Usage
const os = "Windows";  // Could come from configuration
let factory: GUIFactory;

if (os === "Windows") {
    factory = new WindowsFactory();
} else {
    factory = new MacFactory();
}

const app = new Application(factory);
app.render();  // Renders Windows or Mac UI consistently
```

---

### 2.4 Builder Pattern

**Intent:** Separate the construction of a complex object from its representation, allowing the same construction process to create different representations.

**When to Use:**
- Object has many optional parameters
- Step-by-step construction is needed
- Want to create different representations of the same object

```java
// Product
class Pizza {
    private String dough;
    private String sauce;
    private String topping;
    private boolean cheese;
    private boolean pepperoni;
    private boolean mushrooms;
    private boolean olives;
    private String size;
    
    // Private constructor - only builder can create
    private Pizza(PizzaBuilder builder) {
        this.dough = builder.dough;
        this.sauce = builder.sauce;
        this.topping = builder.topping;
        this.cheese = builder.cheese;
        this.pepperoni = builder.pepperoni;
        this.mushrooms = builder.mushrooms;
        this.olives = builder.olives;
        this.size = builder.size;
    }
    
    @Override
    public String toString() {
        return String.format("Pizza [size=%s, dough=%s, sauce=%s, " +
                           "cheese=%b, pepperoni=%b, mushrooms=%b, olives=%b]",
                           size, dough, sauce, cheese, pepperoni, mushrooms, olives);
    }
    
    // Builder class
    public static class PizzaBuilder {
        // Required parameters
        private final String size;
        
        // Optional parameters with defaults
        private String dough = "regular";
        private String sauce = "tomato";
        private String topping = "standard";
        private boolean cheese = false;
        private boolean pepperoni = false;
        private boolean mushrooms = false;
        private boolean olives = false;
        
        public PizzaBuilder(String size) {
            this.size = size;
        }
        
        public PizzaBuilder dough(String dough) {
            this.dough = dough;
            return this;
        }
        
        public PizzaBuilder sauce(String sauce) {
            this.sauce = sauce;
            return this;
        }
        
        public PizzaBuilder cheese(boolean cheese) {
            this.cheese = cheese;
            return this;
        }
        
        public PizzaBuilder pepperoni(boolean pepperoni) {
            this.pepperoni = pepperoni;
            return this;
        }
        
        public PizzaBuilder mushrooms(boolean mushrooms) {
            this.mushrooms = mushrooms;
            return this;
        }
        
        public PizzaBuilder olives(boolean olives) {
            this.olives = olives;
            return this;
        }
        
        public Pizza build() {
            return new Pizza(this);
        }
    }
}

// Usage
Pizza pizza1 = new Pizza.PizzaBuilder("large")
    .dough("thin crust")
    .sauce("white")
    .cheese(true)
    .pepperoni(true)
    .build();

Pizza pizza2 = new Pizza.PizzaBuilder("small")
    .cheese(true)
    .mushrooms(true)
    .olives(true)
    .build();

System.out.println(pizza1);
System.out.println(pizza2);
```

**Modern Alternative (Python):**
```python
from dataclasses import dataclass
from typing import Optional

@dataclass
class Pizza:
    size: str
    dough: str = "regular"
    sauce: str = "tomato"
    cheese: bool = False
    pepperoni: bool = False
    mushrooms: bool = False
    olives: bool = False

# Usage - clean and readable
pizza1 = Pizza(
    size="large",
    dough="thin crust",
    sauce="white",
    cheese=True,
    pepperoni=True
)

pizza2 = Pizza(
    size="small",
    cheese=True,
    mushrooms=True
)
```

---

### 2.5 Prototype Pattern

**Intent:** Create new objects by copying existing objects (prototypes) rather than creating from scratch.

**When to Use:**
- Object creation is expensive
- Want to avoid subclasses of creator
- Number of classes needed is reduced by cloning

```python
import copy
from abc import ABC, abstractmethod

class Prototype(ABC):
    @abstractmethod
    def clone(self):
        pass

class Document(Prototype):
    def __init__(self, title, content, metadata):
        self.title = title
        self.content = content
        self.metadata = metadata  # Complex object
    
    def clone(self):
        # Deep copy to avoid shared references
        return copy.deepcopy(self)
    
    def __str__(self):
        return f"Document(title={self.title}, content={self.content[:20]}...)"

# Usage
original = Document(
    title="Report Template",
    content="This is a template for all reports...",
    metadata={"author": "Admin", "version": "1.0"}
)

# Clone and customize
report1 = original.clone()
report1.title = "Q1 Report"
report1.content = "Q1 sales were excellent..."
report1.metadata["author"] = "John"

report2 = original.clone()
report2.title = "Q2 Report"
report2.content = "Q2 sales continued to grow..."
report2.metadata["author"] = "Jane"

print(original)  # Original unchanged
print(report1)
print(report2)

# Verify they're independent
print(report1.metadata is report2.metadata)  # False - deep copy
```

**JavaScript Implementation:**
```javascript
class Shape {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
    }
    
    clone() {
        return Object.create(
            Object.getPrototypeOf(this),
            Object.getOwnPropertyDescriptors(this)
        );
    }
}

class Circle extends Shape {
    constructor(x, y, color, radius) {
        super(x, y, color);
        this.radius = radius;
    }
    
    clone() {
        return new Circle(this.x, this.y, this.color, this.radius);
    }
}

// Usage
const originalCircle = new Circle(10, 20, "red", 5);
const clonedCircle = originalCircle.clone();

clonedCircle.x = 30;
clonedCircle.color = "blue";

console.log(originalCircle);  // x: 10, color: "red"
console.log(clonedCircle);    // x: 30, color: "blue"
```

---

## 3. STRUCTURAL PATTERNS

Structural patterns deal with object composition and typically identify simple ways to realize relationships between different objects.

---

### 3.1 Adapter Pattern

**Intent:** Convert the interface of a class into another interface clients expect. Allows incompatible interfaces to work together.

**When to Use:**
- Want to use an existing class but its interface doesn't match
- Need to create a reusable class that cooperates with unrelated classes
- Legacy code integration

```python
# Target interface (what client expects)
class MediaPlayer:
    def play(self, file_type, file_name):
        pass

# Adaptee (existing incompatible interface)
class AdvancedMediaPlayer:
    def play_mp4(self, file_name):
        print(f"Playing MP4: {file_name}")
    
    def play_vlc(self, file_name):
        print(f"Playing VLC: {file_name}")

# Adapter
class MediaAdapter(MediaPlayer):
    def __init__(self):
        self.advanced_player = AdvancedMediaPlayer()
    
    def play(self, file_type, file_name):
        if file_type == "mp4":
            self.advanced_player.play_mp4(file_name)
        elif file_type == "vlc":
            self.advanced_player.play_vlc(file_name)
        else:
            raise ValueError(f"Unsupported format: {file_type}")

# Client
class AudioPlayer(MediaPlayer):
    def play(self, file_type, file_name):
        if file_type == "mp3":
            print(f"Playing MP3: {file_name}")
        elif file_type in ["mp4", "vlc"]:
            # Use adapter for advanced formats
            adapter = MediaAdapter()
            adapter.play(file_type, file_name)
        else:
            print(f"Unsupported format: {file_type}")

# Usage
player = AudioPlayer()
player.play("mp3", "song.mp3")      # Direct
player.play("mp4", "video.mp4")     # Through adapter
player.play("vlc", "movie.vlc")     # Through adapter
```

**Real-World Example - Third-Party API Adapter:**
```typescript
// Target interface your app uses
interface PaymentProcessor {
    processPayment(amount: number, currency: string): Promise<string>;
    refund(transactionId: string): Promise<boolean>;
}

// Stripe API (adaptee - different interface)
class StripeAPI {
    async createCharge(amountInCents: number, currencyCode: string) {
        // Stripe expects amount in cents
        console.log(`Stripe: Charging ${amountInCents} ${currencyCode}`);
        return { id: "ch_stripe_123", status: "succeeded" };
    }
    
    async createRefund(chargeId: string) {
        console.log(`Stripe: Refunding ${chargeId}`);
        return { status: "succeeded" };
    }
}

// Adapter
class StripeAdapter implements PaymentProcessor {
    private stripe: StripeAPI;
    
    constructor() {
        this.stripe = new StripeAPI();
    }
    
    async processPayment(amount: number, currency: string): Promise<string> {
        // Convert dollars to cents for Stripe
        const amountInCents = Math.round(amount * 100);
        const result = await this.stripe.createCharge(amountInCents, currency.toLowerCase());
        return result.id;
    }
    
    async refund(transactionId: string): Promise<boolean> {
        const result = await this.stripe.createRefund(transactionId);
        return result.status === "succeeded";
    }
}

// Usage
const processor: PaymentProcessor = new StripeAdapter();
const txId = await processor.processPayment(99.99, "USD");  // App uses dollars
const refunded = await processor.refund(txId);
```

---

### 3.2 Decorator Pattern

**Intent:** Attach additional responsibilities to an object dynamically. Provides a flexible alternative to subclassing.

**When to Use:**
- Want to add responsibilities to individual objects, not entire class
- Extension by subclassing is impractical
- Need to add/remove responsibilities dynamically

```java
// Component interface
interface Coffee {
    String getDescription();
    double getCost();
}

// Concrete component
class SimpleCoffee implements Coffee {
    public String getDescription() {
        return "Simple coffee";
    }
    
    public double getCost() {
        return 2.0;
    }
}

// Decorator base
abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;
    
    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
    
    public String getDescription() {
        return coffee.getDescription();
    }
    
    public double getCost() {
        return coffee.getCost();
    }
}

// Concrete decorators
class Milk extends CoffeeDecorator {
    public Milk(Coffee coffee) {
        super(coffee);
    }
    
    public String getDescription() {
        return coffee.getDescription() + ", milk";
    }
    
    public double getCost() {
        return coffee.getCost() + 0.5;
    }
}

class Sugar extends CoffeeDecorator {
    public Sugar(Coffee coffee) {
        super(coffee);
    }
    
    public String getDescription() {
        return coffee.getDescription() + ", sugar";
    }
    
    public double getCost() {
        return coffee.getCost() + 0.2;
    }
}

class WhippedCream extends CoffeeDecorator {
    public WhippedCream(Coffee coffee) {
        super(coffee);
    }
    
    public String getDescription() {
        return coffee.getDescription() + ", whipped cream";
    }
    
    public double getCost() {
        return coffee.getCost() + 0.7;
    }
}

// Usage
Coffee coffee = new SimpleCoffee();
System.out.println(coffee.getDescription() + " $" + coffee.getCost());
// Output: Simple coffee $2.0

coffee = new Milk(coffee);
System.out.println(coffee.getDescription() + " $" + coffee.getCost());
// Output: Simple coffee, milk $2.5

coffee = new Sugar(coffee);
System.out.println(coffee.getDescription() + " $" + coffee.getCost());
// Output: Simple coffee, milk, sugar $2.7

coffee = new WhippedCream(coffee);
System.out.println(coffee.getDescription() + " $" + coffee.getCost());
// Output: Simple coffee, milk, sugar, whipped cream $3.4
```

**Python Example - File I/O Decorators:**
```python
from abc import ABC, abstractmethod

# Component
class DataSource(ABC):
    @abstractmethod
    def write_data(self, data):
        pass
    
    @abstractmethod
    def read_data(self):
        pass

# Concrete component
class FileDataSource(DataSource):
    def __init__(self, filename):
        self.filename = filename
    
    def write_data(self, data):
        with open(self.filename, 'w') as f:
            f.write(data)
    
    def read_data(self):
        with open(self.filename, 'r') as f:
            return f.read()

# Decorator base
class DataSourceDecorator(DataSource):
    def __init__(self, source):
        self._source = source
    
    def write_data(self, data):
        self._source.write_data(data)
    
    def read_data(self):
        return self._source.read_data()

# Concrete decorators
class EncryptionDecorator(DataSourceDecorator):
    def write_data(self, data):
        encrypted = self._encrypt(data)
        super().write_data(encrypted)
    
    def read_data(self):
        data = super().read_data()
        return self._decrypt(data)
    
    def _encrypt(self, data):
        # Simple encryption for demo
        return ''.join(chr(ord(c) + 1) for c in data)
    
    def _decrypt(self, data):
        return ''.join(chr(ord(c) - 1) for c in data)

class CompressionDecorator(DataSourceDecorator):
    def write_data(self, data):
        compressed = self._compress(data)
        super().write_data(compressed)
    
    def read_data(self):
        data = super().read_data()
        return self._decompress(data)
    
    def _compress(self, data):
        # Simple compression simulation
        return data.replace(" ", "")
    
    def _decompress(self, data):
        # Simple decompression simulation
        return data  # In real scenario, restore spaces

# Usage
source = FileDataSource("data.txt")
source = EncryptionDecorator(source)
source = CompressionDecorator(source)

source.write_data("Hello World")  # Compressed and encrypted
data = source.read_data()          # Decrypted and decompressed
print(data)  # "Hello World"
```

---

### 3.3 Facade Pattern

**Intent:** Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.

**When to Use:**
- Want to provide a simple interface to a complex subsystem
- Need to decouple subsystem from clients
- Want to layer your subsystems

```javascript
// Complex subsystems
class CPU {
    freeze() { console.log("CPU: Freezing..."); }
    jump(position) { console.log(`CPU: Jumping to ${position}`); }
    execute() { console.log("CPU: Executing..."); }
}

class Memory {
    load(position, data) {
        console.log(`Memory: Loading data at ${position}`);
    }
}

class HardDrive {
    read(sector, size) {
        console.log(`HardDrive: Reading ${size} bytes from sector ${sector}`);
        return "boot data";
    }
}

// Facade - simplifies the complex boot process
class ComputerFacade {
    constructor() {
        this.cpu = new CPU();
        this.memory = new Memory();
        this.hardDrive = new HardDrive();
    }
    
    start() {
        console.log("Starting computer...");
        this.cpu.freeze();
        this.memory.load(0, this.hardDrive.read(0, 1024));
        this.cpu.jump(0);
        this.cpu.execute();
        console.log("Computer started!");
    }
}

// Client code - simple to use
const computer = new ComputerFacade();
computer.start();  // One simple method instead of dealing with subsystems
```

**Real-World Example - E-Commerce Order Facade:**
```python
# Complex subsystems
class InventorySystem:
    def check_availability(self, product_id, quantity):
        print(f"Checking inventory for {product_id}, qty: {quantity}")
        return True
    
    def reserve_items(self, product_id, quantity):
        print(f"Reserving {quantity} of {product_id}")

class PaymentGateway:
    def process_payment(self, amount, card_info):
        print(f"Processing payment: ${amount}")
        return "txn_12345"

class ShippingService:
    def calculate_shipping(self, address):
        print(f"Calculating shipping to {address}")
        return 9.99
    
    def create_shipment(self, order_id, address):
        print(f"Creating shipment for order {order_id}")
        return "ship_67890"

class NotificationService:
    def send_confirmation(self, email, order_id):
        print(f"Sending confirmation to {email} for order {order_id}")

# Facade - simplifies complex order process
class OrderFacade:
    def __init__(self):
        self.inventory = InventorySystem()
        self.payment = PaymentGateway()
        self.shipping = ShippingService()
        self.notifications = NotificationService()
    
    def place_order(self, product_id, quantity, card_info, address, email):
        print("\n--- Starting order process ---")
        
        # Check inventory
        if not self.inventory.check_availability(product_id, quantity):
            return {"success": False, "error": "Out of stock"}
        
        # Calculate costs
        shipping_cost = self.shipping.calculate_shipping(address)
        total = (quantity * 29.99) + shipping_cost
        
        # Process payment
        transaction_id = self.payment.process_payment(total, card_info)
        
        # Reserve inventory
        self.inventory.reserve_items(product_id, quantity)
        
        # Create shipment
        order_id = "ORD_001"
        shipment_id = self.shipping.create_shipment(order_id, address)
        
        # Send notification
        self.notifications.send_confirmation(email, order_id)
        
        print("--- Order completed ---\n")
        
        return {
            "success": True,
            "order_id": order_id,
            "transaction_id": transaction_id,
            "shipment_id": shipment_id
        }

# Client code - simple one-line order
facade = OrderFacade()
result = facade.place_order(
    product_id="PROD_123",
    quantity=2,
    card_info={"number": "4111111111111111"},
    address="123 Main St",
    email="customer@example.com"
)
print(result)
```

---

### 3.4 Proxy Pattern

**Intent:** Provide a surrogate or placeholder for another object to control access to it.

**Types:**
- **Virtual Proxy** - Lazy initialization
- **Protection Proxy** - Access control
- **Remote Proxy** - Represents object in different address space
- **Cache Proxy** - Caching results

```python
from abc import ABC, abstractmethod

# Subject interface
class Image(ABC):
    @abstractmethod
    def display(self):
        pass

# Real subject - expensive to create
class RealImage(Image):
    def __init__(self, filename):
        self.filename = filename
        self._load_from_disk()
    
    def _load_from_disk(self):
        print(f"Loading image from disk: {self.filename}")
        # Simulate expensive operation
        import time
        time.sleep(1)
    
    def display(self):
        print(f"Displaying image: {self.filename}")

# Proxy - controls access and lazy loads
class ProxyImage(Image):
    def __init__(self, filename):
        self.filename = filename
        self._real_image = None  # Not loaded yet
    
    def display(self):
        # Lazy loading - only create real image when needed
        if self._real_image is None:
            self._real_image = RealImage(self.filename)
        self._real_image.display()

# Usage
print("Creating proxy...")
image1 = ProxyImage("photo1.jpg")  # Fast - real image not loaded
image2 = ProxyImage("photo2.jpg")  # Fast - real image not loaded

print("\nDisplaying image1 (first time)...")
image1.display()  # Slow - loads from disk

print("\nDisplaying image1 (second time)...")
image1.display()  # Fast - already loaded

print("\nDisplaying image2 (first time)...")
image2.display()  # Slow - loads from disk
```

**Protection Proxy Example:**
```typescript
interface BankAccount {
    getBalance(): number;
    withdraw(amount: number): boolean;
    deposit(amount: number): void;
}

class RealBankAccount implements BankAccount {
    private balance: number;
    
    constructor(initialBalance: number) {
        this.balance = initialBalance;
    }
    
    getBalance(): number {
        return this.balance;
    }
    
    withdraw(amount: number): boolean {
        if (amount <= this.balance) {
            this.balance -= amount;
            console.log(`Withdrew $${amount}. New balance: $${this.balance}`);
            return true;
        }
        return false;
    }
    
    deposit(amount: number): void {
        this.balance += amount;
        console.log(`Deposited $${amount}. New balance: $${this.balance}`);
    }
}

class ProtectedBankAccount implements BankAccount {
    private account: RealBankAccount;
    private user: string;
    private authorizedUsers: string[];
    
    constructor(account: RealBankAccount, user: string) {
        this.account = account;
        this.user = user;
        this.authorizedUsers = ["owner", "admin"];
    }
    
    private isAuthorized(): boolean {
        return this.authorizedUsers.includes(this.user);
    }
    
    getBalance(): number {
        if (this.isAuthorized()) {
            return this.account.getBalance();
        }
        throw new Error("Access denied: Not authorized to view balance");
    }
    
    withdraw(amount: number): boolean {
        if (!this.isAuthorized()) {
            throw new Error("Access denied: Not authorized to withdraw");
        }
        return this.account.withdraw(amount);
    }
    
    deposit(amount: number): void {
        // Anyone can deposit
        this.account.deposit(amount);
    }
}

// Usage
const realAccount = new RealBankAccount(1000);

const ownerProxy = new ProtectedBankAccount(realAccount, "owner");
console.log(ownerProxy.getBalance());  // 1000 - Allowed
ownerProxy.withdraw(100);               // Allowed

const guestProxy = new ProtectedBankAccount(realAccount, "guest");
guestProxy.deposit(50);                 // Allowed
// guestProxy.getBalance();             // Error: Access denied
// guestProxy.withdraw(50);             // Error: Access denied
```

---

### 3.5 Composite Pattern

**Intent:** Compose objects into tree structures to represent part-whole hierarchies. Lets clients treat individual objects and compositions uniformly.

**When to Use:**
- Want to represent part-whole hierarchies
- Want clients to ignore difference between compositions and individual objects

```java
import java.util.*;

// Component
interface FileSystemComponent {
    void display(String indent);
    int getSize();
}

// Leaf
class File implements FileSystemComponent {
    private String name;
    private int size;
    
    public File(String name, int size) {
        this.name = name;
        this.size = size;
    }
    
    public void display(String indent) {
        System.out.println(indent + "üìÑ " + name + " (" + size + " KB)");
    }
    
    public int getSize() {
        return size;
    }
}

// Composite
class Directory implements FileSystemComponent {
    private String name;
    private List<FileSystemComponent> children;
    
    public Directory(String name) {
        this.name = name;
        this.children = new ArrayList<>();
    }
    
    public void add(FileSystemComponent component) {
        children.add(component);
    }
    
    public void remove(FileSystemComponent component) {
        children.remove(component);
    }
    
    public void display(String indent) {
        System.out.println(indent + "üìÅ " + name + "/");
        for (FileSystemComponent child : children) {
            child.display(indent + "  ");
        }
    }
    
    public int getSize() {
        int total = 0;
        for (FileSystemComponent child : children) {
            total += child.getSize();
        }
        return total;
    }
}

// Usage
Directory root = new Directory("root");

Directory documents = new Directory("documents");
documents.add(new File("resume.pdf", 150));
documents.add(new File("cover-letter.docx", 80));

Directory photos = new Directory("photos");
photos.add(new File("vacation1.jpg", 2000));
photos.add(new File("vacation2.jpg", 2500));

Directory music = new Directory("music");
music.add(new File("song1.mp3", 3500));
music.add(new File("song2.mp3", 4000));

root.add(documents);
root.add(photos);
root.add(music);
root.add(new File("readme.txt", 10));

root.display("");
System.out.println("\nTotal size: " + root.getSize() + " KB");

/* Output:
üìÅ root/
  üìÅ documents/
    üìÑ resume.pdf (150 KB)
    üìÑ cover-letter.docx (80 KB)
  üìÅ photos/
    üìÑ vacation1.jpg (2000 KB)
    üìÑ vacation2.jpg (2500 KB)
  üìÅ music/
    üìÑ song1.mp3 (3500 KB)
    üìÑ song2.mp3 (4000 KB)
  üìÑ readme.txt (10 KB)

Total size: 12240 KB
*/
```

---

## 4. BEHAVIORAL PATTERNS

Behavioral patterns are concerned with algorithms and the assignment of responsibilities between objects.

---

### 4.1 Observer Pattern

**Intent:** Define a one-to-many dependency so that when one object changes state, all dependents are notified automatically.

**When to Use:**
- Changes to one object require changing others
- Don't know how many objects need to be changed
- Want loose coupling between subject and observers

```python
from abc import ABC, abstractmethod

# Observer interface
class Observer(ABC):
    @abstractmethod
    def update(self, temperature, humidity, pressure):
        pass

# Subject
class WeatherStation:
    def __init__(self):
        self._observers = []
        self._temperature = 0
        self._humidity = 0
        self._pressure = 0
    
    def register_observer(self, observer):
        self._observers.append(observer)
    
    def remove_observer(self, observer):
        self._observers.remove(observer)
    
    def notify_observers(self):
        for observer in self._observers:
            observer.update(self._temperature, self._humidity, self._pressure)
    
    def set_measurements(self, temperature, humidity, pressure):
        self._temperature = temperature
        self._humidity = humidity
        self._pressure = pressure
        self.notify_observers()

# Concrete observers
class PhoneDisplay(Observer):
    def update(self, temperature, humidity, pressure):
        print(f"üì± Phone Display: {temperature}¬∞F, {humidity}% humidity")

class WindowDisplay(Observer):
    def update(self, temperature, humidity, pressure):
        print(f"ü™ü Window Display: Temp={temperature}¬∞F, " +
              f"Humidity={humidity}%, Pressure={pressure}")

class WeatherLogger(Observer):
    def __init__(self):
        self.log = []
    
    def update(self, temperature, humidity, pressure):
        self.log.append({
            'temp': temperature,
            'humidity': humidity,
            'pressure': pressure
        })
        print(f"üìù Logger: Recorded measurement #{len(self.log)}")

# Usage
station = WeatherStation()

phone = PhoneDisplay()
window = WindowDisplay()
logger = WeatherLogger()

station.register_observer(phone)
station.register_observer(window)
station.register_observer(logger)

print("=== First measurement ===")
station.set_measurements(75, 65, 30.4)

print("\n=== Second measurement ===")
station.set_measurements(78, 70, 29.2)

print("\n=== Removing phone display ===")
station.remove_observer(phone)

print("\n=== Third measurement ===")
station.set_measurements(72, 60, 30.1)
```

---

### 4.2 Strategy Pattern

**Intent:** Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients.

**When to Use:**
- Have many related classes that differ only in behavior
- Need different variants of an algorithm
- Want to isolate business logic from implementation details

```typescript
// Strategy interface
interface PaymentStrategy {
    pay(amount: number): void;
    validateDetails(): boolean;
}

// Concrete strategies
class CreditCardStrategy implements PaymentStrategy {
    private cardNumber: string;
    private cvv: string;
    private expiry: string;
    
    constructor(cardNumber: string, cvv: string, expiry: string) {
        this.cardNumber = cardNumber;
        this.cvv = cvv;
        this.expiry = expiry;
    }
    
    validateDetails(): boolean {
        console.log("Validating credit card details...");
        // Validation logic
        return true;
    }
    
    pay(amount: number): void {
        if (this.validateDetails()) {
            console.log(`Paid $${amount} using Credit Card ending in ${this.cardNumber.slice(-4)}`);
        }
    }
}

class PayPalStrategy implements PaymentStrategy {
    private email: string;
    private password: string;
    
    constructor(email: string, password: string) {
        this.email = email;
        this.password = password;
    }
    
    validateDetails(): boolean {
        console.log("Logging into PayPal...");
        // Authentication logic
        return true;
    }
    
    pay(amount: number): void {
        if (this.validateDetails()) {
            console.log(`Paid $${amount} using PayPal account ${this.email}`);
        }
    }
}

class CryptoStrategy implements PaymentStrategy {
    private walletAddress: string;
    
    constructor(walletAddress: string) {
        this.walletAddress = walletAddress;
    }
    
    validateDetails(): boolean {
        console.log("Validating wallet address...");
        return true;
    }
    
    pay(amount: number): void {
        if (this.validateDetails()) {
            console.log(`Paid $${amount} in crypto to wallet ${this.walletAddress}`);
        }
    }
}

// Context
class ShoppingCart {
    private items: { name: string, price: number }[] = [];
    private paymentStrategy: PaymentStrategy;
    
    addItem(name: string, price: number): void {
        this.items.push({ name, price });
    }
    
    setPaymentStrategy(strategy: PaymentStrategy): void {
        this.paymentStrategy = strategy;
    }
    
    checkout(): void {
        const total = this.items.reduce((sum, item) => sum + item.price, 0);
        console.log(`\nTotal amount: $${total}`);
        
        if (this.paymentStrategy) {
            this.paymentStrategy.pay(total);
        } else {
            console.log("Please select a payment method");
        }
    }
}

// Usage
const cart = new ShoppingCart();
cart.addItem("Laptop", 999);
cart.addItem("Mouse", 25);

// Pay with credit card
cart.setPaymentStrategy(
    new CreditCardStrategy("1234-5678-9012-3456", "123", "12/25")
);
cart.checkout();

// Change to PayPal
cart.setPaymentStrategy(
    new PayPalStrategy("user@example.com", "password123")
);
cart.checkout();

// Change to Crypto
cart.setPaymentStrategy(
    new CryptoStrategy("0x1234567890abcdef")
);
cart.checkout();
```

---

### 4.3 Command Pattern

**Intent:** Encapsulate a request as an object, letting you parameterize clients with different requests, queue requests, and support undoable operations.

**When to Use:**
- Want to parameterize objects with operations
- Need to queue operations
- Need to support undo/redo
- Want to log changes

```python
from abc import ABC, abstractmethod

# Command interface
class Command(ABC):
    @abstractmethod
    def execute(self):
        pass
    
    @abstractmethod
    def undo(self):
        pass

# Receiver
class TextEditor:
    def __init__(self):
        self.text = ""
    
    def write(self, text):
        self.text += text
    
    def delete(self, length):
        self.text = self.text[:-length]
    
    def get_text(self):
        return self.text

# Concrete commands
class WriteCommand(Command):
    def __init__(self, editor, text):
        self.editor = editor
        self.text = text
    
    def execute(self):
        self.editor.write(self.text)
    
    def undo(self):
        self.editor.delete(len(self.text))

class DeleteCommand(Command):
    def __init__(self, editor, length):
        self.editor = editor
        self.length = length
        self.deleted_text = ""
    
    def execute(self):
        # Save deleted text for undo
        self.deleted_text = self.editor.get_text()[-self.length:]
        self.editor.delete(self.length)
    
    def undo(self):
        self.editor.write(self.deleted_text)

# Invoker
class TextEditorInvoker:
    def __init__(self):
        self.history = []
        self.current = -1
    
    def execute_command(self, command):
        # Remove any commands after current if we're not at the end
        self.history = self.history[:self.current + 1]
        
        command.execute()
        self.history.append(command)
        self.current += 1
    
    def undo(self):
        if self.current >= 0:
            command = self.history[self.current]
            command.undo()
            self.current -= 1
            print("Undo successful")
        else:
            print("Nothing to undo")
    
    def redo(self):
        if self.current < len(self.history) - 1:
            self.current += 1
            command = self.history[self.current]
            command.execute()
            print("Redo successful")
        else:
            print("Nothing to redo")

# Usage
editor = TextEditor()
invoker = TextEditorInvoker()

# Execute commands
invoker.execute_command(WriteCommand(editor, "Hello "))
print(f"Text: '{editor.get_text()}'")  # "Hello "

invoker.execute_command(WriteCommand(editor, "World"))
print(f"Text: '{editor.get_text()}'")  # "Hello World"

invoker.execute_command(DeleteCommand(editor, 5))
print(f"Text: '{editor.get_text()}'")  # "Hello "

# Undo
invoker.undo()
print(f"After undo: '{editor.get_text()}'")  # "Hello World"

invoker.undo()
print(f"After undo: '{editor.get_text()}'")  # "Hello "

# Redo
invoker.redo()
print(f"After redo: '{editor.get_text()}'")  # "Hello World"

# New command after undo clears redo history
invoker.undo()
invoker.execute_command(WriteCommand(editor, "Python!"))
print(f"Text: '{editor.get_text()}'")  # "Hello Python!"

invoker.redo()  # Nothing to redo
```

---

### 4.4 Template Method Pattern

**Intent:** Define the skeleton of an algorithm in a method, deferring some steps to subclasses. Lets subclasses redefine certain steps without changing the algorithm's structure.

**When to Use:**
- Have multiple classes with similar algorithms but different implementations
- Want to control which parts of algorithm can be overridden
- Want to avoid code duplication

```java
// Abstract class with template method
abstract class DataProcessor {
    // Template method - defines the algorithm skeleton
    public final void process() {
        readData();
        processData();
        saveData();
        
        // Hook method - optional step
        if (shouldNotify()) {
            sendNotification();
        }
    }
    
    // Abstract methods - must be implemented
    protected abstract void readData();
    protected abstract void processData();
    protected abstract void saveData();
    
    // Hook method - can be overridden, default implementation
    protected boolean shouldNotify() {
        return true;
    }
    
    protected void sendNotification() {
        System.out.println("Sending notification...");
    }
}

// Concrete class 1
class CSVDataProcessor extends DataProcessor {
    @Override
    protected void readData() {
        System.out.println("Reading data from CSV file");
    }
    
    @Override
    protected void processData() {
        System.out.println("Processing CSV data");
        System.out.println("- Parsing columns");
        System.out.println("- Validating data types");
    }
    
    @Override
    protected void saveData() {
        System.out.println("Saving processed data to database");
    }
}

// Concrete class 2
class JSONDataProcessor extends DataProcessor {
    @Override
    protected void readData() {
        System.out.println("Reading data from JSON file");
    }
    
    @Override
    protected void processData() {
        System.out.println("Processing JSON data");
        System.out.println("- Parsing JSON structure");
        System.out.println("- Transforming nested objects");
    }
    
    @Override
    protected void saveData() {
        System.out.println("Saving processed data to NoSQL database");
    }
    
    @Override
    protected boolean shouldNotify() {
        return false;  // Don't send notification for JSON processing
    }
}

// Usage
System.out.println("=== Processing CSV ===");
DataProcessor csvProcessor = new CSVDataProcessor();
csvProcessor.process();

System.out.println("\n=== Processing JSON ===");
DataProcessor jsonProcessor = new JSONDataProcessor();
jsonProcessor.process();
```

---

### 4.5 Iterator Pattern

**Intent:** Provide a way to access elements of a collection sequentially without exposing its underlying representation.

```python
from collections.abc import Iterator, Iterable

class Book:
    def __init__(self, title, author):
        self.title = title
        self.author = author
    
    def __str__(self):
        return f"'{self.title}' by {self.author}"

class BookIterator(Iterator):
    def __init__(self, books):
        self._books = books
        self._index = 0
    
    def __next__(self):
        if self._index < len(self._books):
            book = self._books[self._index]
            self._index += 1
            return book
        raise StopIteration

class BookCollection(Iterable):
    def __init__(self):
        self._books = []
    
    def add_book(self, book):
        self._books.append(book)
    
    def __iter__(self):
        return BookIterator(self._books)

# Usage
library = BookCollection()
library.add_book(Book("1984", "George Orwell"))
library.add_book(Book("To Kill a Mockingbird", "Harper Lee"))
library.add_book(Book("The Great Gatsby", "F. Scott Fitzgerald"))

print("Books in library:")
for book in library:
    print(f"- {book}")
```

---

## Chapter 3 Summary

### Pattern Selection Guide

| Problem | Pattern to Use |
|---------|---------------|
| Need only one instance | Singleton |
| Create objects without specifying exact class | Factory/Abstract Factory |
| Complex object construction | Builder |
| Clone existing objects | Prototype |
| Interface incompatibility | Adapter |
| Add functionality dynamically | Decorator |
| Simplify complex subsystem | Facade |
| Control access to object | Proxy |
| Tree structures | Composite |
| One-to-many dependencies | Observer |
| Interchangeable algorithms | Strategy |
| Encapsulate requests | Command |
| Algorithm skeleton | Template Method |
| Sequential access | Iterator |

### Key Takeaways

1. **Know When to Use** - Patterns solve specific problems
2. **Don't Force Patterns** - Use only when needed
3. **Understand Trade-offs** - Each pattern has pros/cons
4. **Combine Patterns** - Patterns work together
5. **Learn from Practice** - Recognize patterns in existing code

### Interview Preparation

**Study Approach:**
1. Understand the problem each pattern solves
2. Remember 2-3 patterns from each category thoroughly
3. Be able to code at least one example from scratch
4. Know real-world examples for each pattern

**Most Important for Interviews:**
- Singleton, Factory, Builder (Creational)
- Adapter, Decorator, Facade (Structural)
- Observer, Strategy, Command (Behavioral)

**Practice:**
- Implement patterns in your preferred language
- Identify patterns in frameworks you use
- Explain patterns without looking at notes

Congratulations! You now have a solid foundation in Software Architecture principles and patterns. Practice implementing these in real projects to master them.