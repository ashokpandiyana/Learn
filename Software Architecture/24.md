# Chapter 24: Network Security

## Table of Contents
1. Introduction to Network Security
2. VPC (Virtual Private Cloud)
3. Subnets and Network Segmentation
4. Security Groups vs NACLs
5. DDoS Protection
6. Web Application Firewall (WAF)
7. Zero Trust Architecture
8. VPN and Private Connectivity
9. Network Monitoring
10. Real-World Network Architecture
11. Security Best Practices

---

## 1. Introduction to Network Security

**Definition:** Network security is the practice of protecting networks from unauthorized access, misuse, malfunction, modification, or denial of service.

### Defense in Depth

```
Layer 1: Perimeter (Firewall, DDoS protection)
         â†“
Layer 2: Network (VPC, subnets, routing)
         â†“
Layer 3: Host (Security groups, OS hardening)
         â†“
Layer 4: Application (Input validation, auth)
         â†“
Layer 5: Data (Encryption, access control)

Multiple layers of defense - if one fails, others protect
```

---

## 2. VPC (Virtual Private Cloud)

**Definition:** Isolated virtual network in the cloud where you can launch resources.

### VPC Components

```
VPC (10.0.0.0/16)
â”œâ”€â”€ Internet Gateway (for public internet access)
â”œâ”€â”€ NAT Gateway (for private subnet internet access)
â”œâ”€â”€ Route Tables
â”œâ”€â”€ Subnets
â”‚   â”œâ”€â”€ Public Subnet (10.0.1.0/24)
â”‚   â”œâ”€â”€ Private Subnet (10.0.2.0/24)
â”‚   â””â”€â”€ Database Subnet (10.0.3.0/24)
â””â”€â”€ Security Groups / NACLs
```

### AWS VPC Configuration

```python
# ============================================
# Create VPC with Boto3
# ============================================
import boto3

class VPCSetup:
    def __init__(self):
        self.ec2 = boto3.client('ec2', region_name='us-east-1')
    
    def create_vpc(self):
        """Create VPC with subnets"""
        
        # 1. Create VPC
        vpc_response = self.ec2.create_vpc(
            CidrBlock='10.0.0.0/16',
            TagSpecifications=[{
                'ResourceType': 'vpc',
                'Tags': [{'Key': 'Name', 'Value': 'MyApp-VPC'}]
            }]
        )
        
        vpc_id = vpc_response['Vpc']['VpcId']
        print(f"Created VPC: {vpc_id}")
        
        # 2. Create Internet Gateway
        igw_response = self.ec2.create_internet_gateway(
            TagSpecifications=[{
                'ResourceType': 'internet-gateway',
                'Tags': [{'Key': 'Name', 'Value': 'MyApp-IGW'}]
            }]
        )
        
        igw_id = igw_response['InternetGateway']['InternetGatewayId']
        
        # Attach to VPC
        self.ec2.attach_internet_gateway(
            InternetGatewayId=igw_id,
            VpcId=vpc_id
        )
        
        # 3. Create Subnets
        
        # Public subnet (for load balancers)
        public_subnet = self.ec2.create_subnet(
            VpcId=vpc_id,
            CidrBlock='10.0.1.0/24',
            AvailabilityZone='us-east-1a',
            TagSpecifications=[{
                'ResourceType': 'subnet',
                'Tags': [{'Key': 'Name', 'Value': 'Public-Subnet'}]
            }]
        )
        
        public_subnet_id = public_subnet['Subnet']['SubnetId']
        
        # Private subnet (for application servers)
        private_subnet = self.ec2.create_subnet(
            VpcId=vpc_id,
            CidrBlock='10.0.2.0/24',
            AvailabilityZone='us-east-1a',
            TagSpecifications=[{
                'ResourceType': 'subnet',
                'Tags': [{'Key': 'Name', 'Value': 'Private-Subnet'}]
            }]
        )
        
        private_subnet_id = private_subnet['Subnet']['SubnetId']
        
        # Database subnet (for databases)
        db_subnet = self.ec2.create_subnet(
            VpcId=vpc_id,
            CidrBlock='10.0.3.0/24',
            AvailabilityZone='us-east-1a',
            TagSpecifications=[{
                'ResourceType': 'subnet',
                'Tags': [{'Key': 'Name', 'Value': 'Database-Subnet'}]
            }]
        )
        
        db_subnet_id = db_subnet['Subnet']['SubnetId']
        
        # 4. Create NAT Gateway (for private subnet internet access)
        # Allocate Elastic IP
        eip_response = self.ec2.allocate_address(Domain='vpc')
        allocation_id = eip_response['AllocationId']
        
        nat_response = self.ec2.create_nat_gateway(
            SubnetId=public_subnet_id,
            AllocationId=allocation_id,
            TagSpecifications=[{
                'ResourceType': 'natgateway',
                'Tags': [{'Key': 'Name', 'Value': 'MyApp-NAT'}]
            }]
        )
        
        nat_gateway_id = nat_response['NatGateway']['NatGatewayId']
        
        # 5. Create Route Tables
        
        # Public route table (internet access)
        public_rt = self.ec2.create_route_table(
            VpcId=vpc_id,
            TagSpecifications=[{
                'ResourceType': 'route-table',
                'Tags': [{'Key': 'Name', 'Value': 'Public-RT'}]
            }]
        )
        
        public_rt_id = public_rt['RouteTable']['RouteTableId']
        
        # Add route to internet gateway
        self.ec2.create_route(
            RouteTableId=public_rt_id,
            DestinationCidrBlock='0.0.0.0/0',
            GatewayId=igw_id
        )
        
        # Associate with public subnet
        self.ec2.associate_route_table(
            RouteTableId=public_rt_id,
            SubnetId=public_subnet_id
        )
        
        # Private route table (NAT gateway)
        private_rt = self.ec2.create_route_table(
            VpcId=vpc_id,
            TagSpecifications=[{
                'ResourceType': 'route-table',
                'Tags': [{'Key': 'Name', 'Value': 'Private-RT'}]
            }]
        )
        
        private_rt_id = private_rt['RouteTable']['RouteTableId']
        
        # Add route to NAT gateway
        self.ec2.create_route(
            RouteTableId=private_rt_id,
            DestinationCidrBlock='0.0.0.0/0',
            NatGatewayId=nat_gateway_id
        )
        
        # Associate with private subnet
        self.ec2.associate_route_table(
            RouteTableId=private_rt_id,
            SubnetId=private_subnet_id
        )
        
        print("VPC setup complete!")
        
        return {
            'vpc_id': vpc_id,
            'public_subnet_id': public_subnet_id,
            'private_subnet_id': private_subnet_id,
            'db_subnet_id': db_subnet_id
        }

# Create VPC
vpc_setup = VPCSetup()
vpc_config = vpc_setup.create_vpc()
```

---

## 3. Subnets and Network Segmentation

### Network Segmentation Strategy

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              VPC (10.0.0.0/16)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  Public Subnet (10.0.1.0/24)        â”‚      â”‚
â”‚  â”‚  - Load Balancers                   â”‚      â”‚
â”‚  â”‚  - NAT Gateways                     â”‚      â”‚
â”‚  â”‚  - Bastion Hosts                    â”‚      â”‚
â”‚  â”‚  Internet accessible                 â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  Private Subnet (10.0.2.0/24)       â”‚      â”‚
â”‚  â”‚  - Application Servers              â”‚      â”‚
â”‚  â”‚  - Worker Nodes                     â”‚      â”‚
â”‚  â”‚  No direct internet access          â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  Database Subnet (10.0.3.0/24)      â”‚      â”‚
â”‚  â”‚  - RDS Databases                    â”‚      â”‚
â”‚  â”‚  - Redis/ElastiCache                â”‚      â”‚
â”‚  â”‚  Isolated, no internet              â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Traffic Flow:
Internet â†’ Load Balancer (Public) 
        â†’ App Servers (Private) 
        â†’ Database (Database subnet)
```

### Terraform VPC Configuration

```hcl
# ============================================
# Terraform VPC Configuration
# ============================================

# VPC
resource "aws_vpc" "main" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_hostnames = true
  enable_dns_support   = true
  
  tags = {
    Name = "MyApp-VPC"
  }
}

# Internet Gateway
resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id
  
  tags = {
    Name = "MyApp-IGW"
  }
}

# Public Subnet
resource "aws_subnet" "public" {
  vpc_id                  = aws_vpc.main.id
  cidr_block              = "10.0.1.0/24"
  availability_zone       = "us-east-1a"
  map_public_ip_on_launch = true
  
  tags = {
    Name = "Public-Subnet"
    Tier = "Public"
  }
}

# Private Subnet
resource "aws_subnet" "private" {
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.2.0/24"
  availability_zone = "us-east-1a"
  
  tags = {
    Name = "Private-Subnet"
    Tier = "Private"
  }
}

# Database Subnet
resource "aws_subnet" "database" {
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.3.0/24"
  availability_zone = "us-east-1a"
  
  tags = {
    Name = "Database-Subnet"
    Tier = "Database"
  }
}

# NAT Gateway
resource "aws_eip" "nat" {
  vpc = true
}

resource "aws_nat_gateway" "main" {
  allocation_id = aws_eip.nat.id
  subnet_id     = aws_subnet.public.id
  
  tags = {
    Name = "MyApp-NAT"
  }
}

# Route Tables
resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id
  
  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.main.id
  }
  
  tags = {
    Name = "Public-RT"
  }
}

resource "aws_route_table" "private" {
  vpc_id = aws_vpc.main.id
  
  route {
    cidr_block     = "0.0.0.0/0"
    nat_gateway_id = aws_nat_gateway.main.id
  }
  
  tags = {
    Name = "Private-RT"
  }
}

# Route Table Associations
resource "aws_route_table_association" "public" {
  subnet_id      = aws_subnet.public.id
  route_table_id = aws_route_table.public.id
}

resource "aws_route_table_association" "private" {
  subnet_id      = aws_subnet.private.id
  route_table_id = aws_route_table.private.id
}
```

---

## 4. Security Groups vs NACLs

### Security Groups (Stateful)

**Characteristics:**
- Stateful (return traffic automatically allowed)
- Instance-level (attached to EC2, RDS, etc.)
- Allow rules only (no deny rules)
- Evaluated together (if any rule allows, traffic allowed)

```python
# ============================================
# Security Group Configuration
# ============================================

# Load Balancer Security Group
load_balancer_sg = ec2.create_security_group(
    GroupName='LoadBalancer-SG',
    Description='Security group for load balancer',
    VpcId=vpc_id
)

# Allow inbound HTTP/HTTPS from internet
ec2.authorize_security_group_ingress(
    GroupId=load_balancer_sg['GroupId'],
    IpPermissions=[
        {
            'IpProtocol': 'tcp',
            'FromPort': 80,
            'ToPort': 80,
            'IpRanges': [{'CidrIp': '0.0.0.0/0'}]  # Allow from anywhere
        },
        {
            'IpProtocol': 'tcp',
            'FromPort': 443,
            'ToPort': 443,
            'IpRanges': [{'CidrIp': '0.0.0.0/0'}]
        }
    ]
)

# Application Server Security Group
app_server_sg = ec2.create_security_group(
    GroupName='AppServer-SG',
    Description='Security group for application servers',
    VpcId=vpc_id
)

# Allow inbound only from load balancer
ec2.authorize_security_group_ingress(
    GroupId=app_server_sg['GroupId'],
    IpPermissions=[
        {
            'IpProtocol': 'tcp',
            'FromPort': 3000,
            'ToPort': 3000,
            'UserIdGroupPairs': [{
                'GroupId': load_balancer_sg['GroupId']  # Only from LB
            }]
        }
    ]
)

# Database Security Group
database_sg = ec2.create_security_group(
    GroupName='Database-SG',
    Description='Security group for database',
    VpcId=vpc_id
)

# Allow inbound only from application servers
ec2.authorize_security_group_ingress(
    GroupId=database_sg['GroupId'],
    IpPermissions=[
        {
            'IpProtocol': 'tcp',
            'FromPort': 5432,
            'ToPort': 5432,
            'UserIdGroupPairs': [{
                'GroupId': app_server_sg['GroupId']  # Only from app servers
            }]
        }
    ]
)
```

**Result:**
```
Internet â†’ Load Balancer (ports 80, 443)
         â†’ App Server (port 3000, only from LB)
         â†’ Database (port 5432, only from App)

Database is NOT accessible from internet or load balancer!
```

### Network ACLs (Stateless)

**Characteristics:**
- Stateless (must allow both inbound and outbound)
- Subnet-level
- Allow and deny rules
- Rules evaluated in order (lowest number first)

```python
# ============================================
# Network ACL Configuration
# ============================================

# Create NACL
nacl = ec2.create_network_acl(
    VpcId=vpc_id,
    TagSpecifications=[{
        'ResourceType': 'network-acl',
        'Tags': [{'Key': 'Name', 'Value': 'Private-NACL'}]
    }]
)

nacl_id = nacl['NetworkAcl']['NetworkAclId']

# Inbound rules
inbound_rules = [
    # Rule 100: Allow HTTP from load balancer subnet
    {
        'RuleNumber': 100,
        'Protocol': '6',  # TCP
        'RuleAction': 'allow',
        'CidrBlock': '10.0.1.0/24',  # Load balancer subnet
        'PortRange': {'From': 3000, 'To': 3000}
    },
    # Rule 110: Allow return traffic (ephemeral ports)
    {
        'RuleNumber': 110,
        'Protocol': '6',
        'RuleAction': 'allow',
        'CidrBlock': '0.0.0.0/0',
        'PortRange': {'From': 1024, 'To': 65535}  # Ephemeral ports
    },
    # Rule 200: Deny all other inbound
    {
        'RuleNumber': 200,
        'Protocol': '-1',  # All protocols
        'RuleAction': 'deny',
        'CidrBlock': '0.0.0.0/0'
    }
]

for rule in inbound_rules:
    ec2.create_network_acl_entry(
        NetworkAclId=nacl_id,
        Egress=False,  # Inbound
        **rule
    )

# Outbound rules
outbound_rules = [
    # Rule 100: Allow responses to load balancer
    {
        'RuleNumber': 100,
        'Protocol': '6',
        'RuleAction': 'allow',
        'CidrBlock': '10.0.1.0/24',
        'PortRange': {'From': 1024, 'To': 65535}
    },
    # Rule 110: Allow database traffic
    {
        'RuleNumber': 110,
        'Protocol': '6',
        'RuleAction': 'allow',
        'CidrBlock': '10.0.3.0/24',
        'PortRange': {'From': 5432, 'To': 5432}
    },
    # Rule 200: Deny all other outbound
    {
        'RuleNumber': 200,
        'Protocol': '-1',
        'RuleAction': 'deny',
        'CidrBlock': '0.0.0.0/0'
    }
]

for rule in outbound_rules:
    ec2.create_network_acl_entry(
        NetworkAclId=nacl_id,
        Egress=True,  # Outbound
        **rule
    )
```

### Security Groups vs NACLs

| Feature | Security Group | NACL |
|---------|----------------|------|
| **Level** | Instance | Subnet |
| **State** | Stateful | Stateless |
| **Rules** | Allow only | Allow + Deny |
| **Evaluation** | All rules | Order (lowest first) |
| **Return Traffic** | Auto-allowed | Must be explicitly allowed |
| **Use Case** | Fine-grained control | Subnet-level filtering |

---

## 5. DDoS Protection

**Definition:** Distributed Denial of Service - overwhelm system with traffic.

### Types of DDoS Attacks

**1. Volumetric Attacks**
```
Send massive amounts of traffic
Example: 100 Gbps of junk traffic
Goal: Saturate bandwidth
```

**2. Protocol Attacks**
```
Exploit protocol weaknesses
Example: SYN flood (TCP handshake abuse)
Goal: Exhaust server resources
```

**3. Application Layer Attacks**
```
Target application endpoints
Example: Flood expensive API calls
Goal: Exhaust application resources
```

### DDoS Mitigation

```python
# ============================================
# Rate Limiting (Application Layer)
# ============================================
from collections import defaultdict
import time

class DDoSProtection:
    def __init__(self):
        self.request_counts = defaultdict(list)
        self.blocked_ips = {}
    
    def is_allowed(self, ip_address, max_requests=100, window_seconds=60):
        """Check if request is allowed"""
        now = time.time()
        
        # Check if IP is blocked
        if ip_address in self.blocked_ips:
            if now < self.blocked_ips[ip_address]:
                return False, "IP blocked"
            else:
                # Unblock expired block
                del self.blocked_ips[ip_address]
        
        # Clean old requests
        self.request_counts[ip_address] = [
            ts for ts in self.request_counts[ip_address]
            if now - ts < window_seconds
        ]
        
        # Add current request
        self.request_counts[ip_address].append(now)
        
        # Check rate limit
        count = len(self.request_counts[ip_address])
        
        if count > max_requests:
            # Block IP for 1 hour
            self.blocked_ips[ip_address] = now + 3600
            
            # Alert security team
            self.alert_security(f"Possible DDoS from {ip_address}: {count} requests")
            
            return False, f"Rate limit exceeded: {count} requests in {window_seconds}s"
        
        return True, None

# Middleware
ddos_protection = DDoSProtection()

@app.before_request
def check_ddos():
    allowed, reason = ddos_protection.is_allowed(request.remote_addr)
    
    if not allowed:
        return jsonify({
            'error': 'Too many requests',
            'reason': reason
        }), 429
```

### AWS Shield and CloudFront

```javascript
// ============================================
// CloudFront with DDoS Protection
// ============================================
const AWS = require('aws-sdk');
const cloudfront = new AWS.CloudFront();

const distributionConfig = {
  CallerReference: Date.now().toString(),
  Comment: 'CloudFront with DDoS protection',
  Enabled: true,
  
  Origins: {
    Quantity: 1,
    Items: [{
      Id: 'origin1',
      DomainName: 'api.example.com',
      CustomOriginConfig: {
        HTTPPort: 80,
        HTTPSPort: 443,
        OriginProtocolPolicy: 'https-only',
        OriginSslProtocols: {
          Quantity: 1,
          Items: ['TLSv1.2']
        }
      },
      // Shield Standard (free) automatically enabled
      // Shield Advanced (paid) provides:
      // - DDoS Response Team (DRT)
      // - Cost protection
      // - Advanced metrics
    }]
  },
  
  DefaultCacheBehavior: {
    TargetOriginId: 'origin1',
    ViewerProtocolPolicy: 'redirect-to-https',
    AllowedMethods: {
      Quantity: 7,
      Items: ['GET', 'HEAD', 'OPTIONS', 'PUT', 'POST', 'PATCH', 'DELETE']
    },
    
    // Rate limiting at edge
    TrustedKeyGroups: {
      Enabled: false,
      Quantity: 0
    }
  },
  
  // Geographic restrictions
  Restrictions: {
    GeoRestriction: {
      RestrictionType: 'blacklist',
      Quantity: 2,
      Items: ['CN', 'RU']  // Block specific countries if needed
    }
  }
};

// AWS WAF for additional protection
const waf = new AWS.WAFv2();

// Create rate-based rule
const rateRule = {
  Name: 'RateLimitRule',
  Priority: 1,
  Statement: {
    RateBasedStatement: {
      Limit: 2000,  // 2000 requests per 5 minutes
      AggregateKeyType: 'IP'
    }
  },
  Action: {
    Block: {}  // Block if limit exceeded
  },
  VisibilityConfig: {
    SampledRequestsEnabled: true,
    CloudWatchMetricsEnabled: true,
    MetricName: 'RateLimitRule'
  }
};
```

---

## 6. Web Application Firewall (WAF)

### WAF Rules

```python
# ============================================
# AWS WAF Rule Configuration
# ============================================
import boto3

waf = boto3.client('wafv2')

# Create Web ACL
web_acl = waf.create_web_acl(
    Name='MyApp-WAF',
    Scope='REGIONAL',
    DefaultAction={'Allow': {}},
    Rules=[
        # Rule 1: Block SQL Injection
        {
            'Name': 'BlockSQLInjection',
            'Priority': 1,
            'Statement': {
                'SqliMatchStatement': {
                    'FieldToMatch': {
                        'AllQueryArguments': {}
                    },
                    'TextTransformations': [{
                        'Priority': 0,
                        'Type': 'URL_DECODE'
                    }]
                }
            },
            'Action': {'Block': {}},
            'VisibilityConfig': {
                'SampledRequestsEnabled': True,
                'CloudWatchMetricsEnabled': True,
                'MetricName': 'SQLInjectionBlock'
            }
        },
        
        # Rule 2: Block XSS
        {
            'Name': 'BlockXSS',
            'Priority': 2,
            'Statement': {
                'XssMatchStatement': {
                    'FieldToMatch': {
                        'Body': {}
                    },
                    'TextTransformations': [{
                        'Priority': 0,
                        'Type': 'HTML_ENTITY_DECODE'
                    }]
                }
            },
            'Action': {'Block': {}},
            'VisibilityConfig': {
                'SampledRequestsEnabled': True,
                'CloudWatchMetricsEnabled': True,
                'MetricName': 'XSSBlock'
            }
        },
        
        # Rule 3: Geographic blocking
        {
            'Name': 'BlockCountries',
            'Priority': 3,
            'Statement': {
                'GeoMatchStatement': {
                    'CountryCodes': ['CN', 'RU', 'KP']
                }
            },
            'Action': {'Block': {}},
            'VisibilityConfig': {
                'SampledRequestsEnabled': True,
                'CloudWatchMetricsEnabled': True,
                'MetricName': 'GeoBlock'
            }
        },
        
        # Rule 4: Rate limiting
        {
            'Name': 'RateLimit',
            'Priority': 4,
            'Statement': {
                'RateBasedStatement': {
                    'Limit': 2000,
                    'AggregateKeyType': 'IP'
                }
            },
            'Action': {'Block': {}},
            'VisibilityConfig': {
                'SampledRequestsEnabled': True,
                'CloudWatchMetricsEnabled': True,
                'MetricName': 'RateLimit'
            }
        }
    ],
    VisibilityConfig={
        'SampledRequestsEnabled': True,
        'CloudWatchMetricsEnabled': True,
        'MetricName': 'MyAppWAF'
    }
)
```

---

## 7. Zero Trust Architecture

**Principle:** "Never trust, always verify" - don't trust anything inside or outside network.

### Traditional vs Zero Trust

```
Traditional (Castle and Moat):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Firewall               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Inside = Trusted              â”‚
â”‚  - No verification             â”‚
â”‚  - Full access                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Problem: Once inside, attacker has full access

Zero Trust:
Every request verified:
â”œâ”€ Who (authentication)
â”œâ”€ What (authorization)
â”œâ”€ Where (location)
â”œâ”€ When (time)
â””â”€ How (device posture)

No implicit trust, even inside network
```

### Implementation

```typescript
// ============================================
// Zero Trust Access Control
// ============================================

interface AccessRequest {
  userId: string;
  resource: string;
  action: string;
  ipAddress: string;
  deviceId: string;
  timestamp: Date;
}

class ZeroTrustController {
  async evaluateAccess(request: AccessRequest): Promise<boolean> {
    // 1. Authenticate user
    const user = await this.authenticateUser(request.userId);
    if (!user) {
      return false;
    }
    
    // 2. Verify device
    const device = await this.verifyDevice(request.deviceId);
    if (!device || !device.compliant) {
      // Device not registered or non-compliant
      return false;
    }
    
    // 3. Check location
    const locationAllowed = await this.checkLocation(
      request.ipAddress,
      user.allowedLocations
    );
    if (!locationAllowed) {
      return false;
    }
    
    // 4. Verify time-based access
    const hour = request.timestamp.getHours();
    if (hour < 6 || hour > 22) {
      // Outside business hours
      if (!user.roles.includes('admin')) {
        return false;
      }
    }
    
    // 5. Check authorization
    const authorized = await this.checkPermission(
      user,
      request.resource,
      request.action
    );
    if (!authorized) {
      return false;
    }
    
    // 6. Risk-based assessment
    const riskScore = await this.calculateRiskScore(request);
    if (riskScore > 70) {
      // High risk - require additional verification
      await this.requireMFA(user.id);
      return false;  // Wait for MFA
    }
    
    // 7. Log access
    await this.auditLog(request, true);
    
    return true;
  }
  
  private async calculateRiskScore(request: AccessRequest): Promise<number> {
    let score = 0;
    
    // New location?
    if (await this.isNewLocation(request.userId, request.ipAddress)) {
      score += 30;
    }
    
    // New device?
    if (await this.isNewDevice(request.userId, request.deviceId)) {
      score += 40;
    }
    
    // Access to sensitive resource?
    if (request.resource.includes('admin') || request.resource.includes('payment')) {
      score += 20;
    }
    
    // Unusual time?
    const hour = request.timestamp.getHours();
    if (hour < 6 || hour > 22) {
      score += 10;
    }
    
    return score;
  }
}
```

---

## 8. VPN and Private Connectivity

### Site-to-Site VPN

```
Corporate Office â†â†’ VPN Tunnel â†â†’ AWS VPC
(On-premise)                      (Cloud)

Encrypted connection over internet
```

### AWS VPN Configuration

```python
# ============================================
# AWS Site-to-Site VPN
# ============================================

# Create Customer Gateway (on-premise router)
customer_gateway = ec2.create_customer_gateway(
    Type='ipsec.1',
    PublicIp='203.0.113.5',  # Your office public IP
    BgpAsn=65000  # Your BGP ASN
)

# Create Virtual Private Gateway
vpn_gateway = ec2.create_vpn_gateway(
    Type='ipsec.1',
    TagSpecifications=[{
        'ResourceType': 'vpn-gateway',
        'Tags': [{'Key': 'Name', 'Value': 'MyApp-VGW'}]
    }]
)

# Attach to VPC
ec2.attach_vpn_gateway(
    VpcId=vpc_id,
    VpnGatewayId=vpn_gateway['VpnGateway']['VpnGatewayId']
)

# Create VPN Connection
vpn_connection = ec2.create_vpn_connection(
    Type='ipsec.1',
    CustomerGatewayId=customer_gateway['CustomerGateway']['CustomerGatewayId'],
    VpnGatewayId=vpn_gateway['VpnGateway']['VpnGatewayId'],
    Options={
        'StaticRoutesOnly': False,  # Use BGP
        'TunnelOptions': [{
            'PreSharedKey': 'your-pre-shared-key'
        }]
    }
)

# Now office can securely access private resources in VPC
```

### AWS PrivateLink

```
Service Provider VPC â†â†’ PrivateLink â†â†’ Consumer VPC

No internet exposure
Private IP connectivity
```

---

## 9. Network Monitoring

### VPC Flow Logs

```python
# ============================================
# Enable VPC Flow Logs
# ============================================

# Create CloudWatch log group
logs = boto3.client('logs')
logs.create_log_group(LogGroupName='/aws/vpc/flowlogs')

# Create flow log
ec2.create_flow_logs(
    ResourceType='VPC',
    ResourceIds=[vpc_id],
    TrafficType='ALL',  # ACCEPT, REJECT, or ALL
    LogDestinationType='cloud-watch-logs',
    LogGroupName='/aws/vpc/flowlogs',
    DeliverLogsPermissionArn='arn:aws:iam::123456789:role/VPCFlowLogsRole'
)

# ============================================
# Analyze Flow Logs
# ============================================

class FlowLogAnalyzer:
    def __init__(self, log_group):
        self.logs = boto3.client('logs')
        self.log_group = log_group
    
    def find_rejected_connections(self, hours=24):
        """Find rejected connection attempts"""
        start_time = int((datetime.now() - timedelta(hours=hours)).timestamp() * 1000)
        
        # Query flow logs
        response = self.logs.filter_log_events(
            logGroupName=self.log_group,
            startTime=start_time,
            filterPattern='[version, account, eni, source, destination, srcport, destport, protocol, packets, bytes, start, end, action="REJECT", status]'
        )
        
        # Analyze rejected connections
        rejected_by_source = defaultdict(int)
        
        for event in response['events']:
            # Parse flow log
            fields = event['message'].split()
            source_ip = fields[3]
            dest_port = fields[6]
            
            rejected_by_source[source_ip] += 1
        
        # Find suspicious sources
        for source_ip, count in rejected_by_source.items():
            if count > 100:
                print(f"âš ï¸  Suspicious: {source_ip} had {count} rejected connections")
        
        return rejected_by_source
    
    def detect_port_scanning(self):
        """Detect port scanning activity"""
        # Look for single source accessing many ports
        
        response = self.logs.filter_log_events(
            logGroupName=self.log_group,
            startTime=int((datetime.now() - timedelta(hours=1)).timestamp() * 1000)
        )
        
        # Track unique destination ports per source
        source_ports = defaultdict(set)
        
        for event in response['events']:
            fields = event['message'].split()
            source_ip = fields[3]
            dest_port = fields[6]
            
            source_ports[source_ip].add(dest_port)
        
        # Alert if source accessed > 20 different ports
        for source_ip, ports in source_ports.items():
            if len(ports) > 20:
                print(f"ğŸš¨ Port scan detected from {source_ip}: {len(ports)} ports")
                # Block IP, alert security team
```

---

## 10. Real-World Network Architecture

### Production VPC Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  VPC (10.0.0.0/16)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Availability Zone 1                       â”‚    â”‚
â”‚  â”‚                                            â”‚    â”‚
â”‚  â”‚  Public Subnet (10.0.1.0/24)              â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚    â”‚
â”‚  â”‚  â”‚Load Balancerâ”‚  â”‚NAT Gateway  â”‚        â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚    â”‚
â”‚  â”‚                                            â”‚    â”‚
â”‚  â”‚  Private Subnet (10.0.2.0/24)             â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚    â”‚
â”‚  â”‚  â”‚App Server 1 â”‚  â”‚App Server 2 â”‚        â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚    â”‚
â”‚  â”‚                                            â”‚    â”‚
â”‚  â”‚  Database Subnet (10.0.3.0/24)            â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚    â”‚
â”‚  â”‚  â”‚  Primary DB â”‚                          â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Availability Zone 2                       â”‚    â”‚
â”‚  â”‚                                            â”‚    â”‚
â”‚  â”‚  Public Subnet (10.0.11.0/24)             â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚    â”‚
â”‚  â”‚  â”‚Load Balancerâ”‚  â”‚NAT Gateway  â”‚        â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚    â”‚
â”‚  â”‚                                            â”‚    â”‚
â”‚  â”‚  Private Subnet (10.0.12.0/24)            â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚    â”‚
â”‚  â”‚  â”‚App Server 3 â”‚  â”‚App Server 4 â”‚        â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚    â”‚
â”‚  â”‚                                            â”‚    â”‚
â”‚  â”‚  Database Subnet (10.0.13.0/24)           â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚    â”‚
â”‚  â”‚  â”‚ Replica DB  â”‚                          â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

High Availability:
- 2 Availability Zones
- Load balancers in both AZs
- Application servers in both AZs
- Database with cross-AZ replication
```

---

## 11. Security Best Practices

### Network Security Checklist

```python
NETWORK_SECURITY_CHECKLIST = {
    'VPC Configuration': [
        'VPC created with appropriate CIDR block',
        'Subnets created for each tier (public, private, database)',
        'Multiple availability zones used',
        'Flow logs enabled'
    ],
    
    'Access Control': [
        'Security groups configured with least privilege',
        'NACLs configured for subnet-level filtering',
        'No 0.0.0.0/0 inbound on private resources',
        'Database not publicly accessible'
    ],
    
    'Internet Access': [
        'Internet gateway only for public subnet',
        'NAT gateway for private subnet outbound',
        'No direct internet for database subnet',
        'Bastion host for admin access (if needed)'
    ],
    
    'Encryption': [
        'TLS 1.2+ for all external connections',
        'VPN for site-to-site connections',
        'PrivateLink for AWS service access',
        'Encryption in transit for all data'
    ],
    
    'Monitoring': [
        'VPC flow logs enabled',
        'CloudWatch alarms configured',
        'GuardDuty enabled',
        'Security Hub enabled'
    ],
    
    'DDoS Protection': [
        'CloudFront in front of application',
        'AWS Shield enabled',
        'WAF rules configured',
        'Rate limiting implemented'
    ],
    
    'Updates & Patching': [
        'Regular security patches applied',
        'AMIs updated monthly',
        'Vulnerability scanning enabled',
        'Automated patching configured'
    ]
}
```

---

## Chapter 24 Summary

### Key Concepts

1. **VPC** - Isolated virtual network in cloud
2. **Subnets** - Network segmentation (public, private, database)
3. **Security Groups** - Stateful, instance-level firewall
4. **NACLs** - Stateless, subnet-level firewall
5. **DDoS Protection** - Shield against volumetric attacks
6. **WAF** - Application-level firewall
7. **Zero Trust** - Never trust, always verify
8. **VPN** - Encrypted connections
9. **Network Monitoring** - Flow logs, intrusion detection

### Network Security Layers

| Layer | Technology | Purpose |
|-------|------------|---------|
| **Perimeter** | CloudFront, Shield | DDoS protection |
| **Application** | WAF | SQL injection, XSS blocking |
| **Network** | VPC, Subnets | Network isolation |
| **Instance** | Security Groups | Instance-level firewall |
| **Subnet** | NACLs | Subnet-level firewall |
| **Monitoring** | Flow Logs, GuardDuty | Threat detection |

### Security Group vs NACL

**Use Security Groups for:**
- Instance-level protection
- Allow rules
- Stateful connections

**Use NACLs for:**
- Subnet-level protection
- Deny rules (block specific IPs)
- Additional defense layer

### DDoS Protection Strategy

```
Level 1: CloudFront/CloudFlare (absorb at edge)
Level 2: AWS Shield (network layer protection)
Level 3: WAF (application layer filtering)
Level 4: Rate limiting (application code)
Level 5: Auto-scaling (handle legitimate spikes)
```

### Interview Tips

**Common Questions:**
1. "Explain VPC architecture"
2. "Security Groups vs NACLs?"
3. "How do you prevent DDoS?"
4. "What is Zero Trust?"
5. "How do you secure a database in VPC?"

**How to Answer:**
- Draw VPC diagram with subnets
- Explain public vs private subnets
- Show security group rules
- Discuss defense in depth
- Mention specific AWS/cloud services

### Best Practices

1. **Least Privilege** - Minimal access required
2. **Network Segmentation** - Isolate tiers
3. **No Public Databases** - Always in private subnet
4. **Use NAT Gateway** - For private subnet internet
5. **Enable Flow Logs** - Monitor traffic
6. **Multi-AZ** - High availability
7. **Regular Audits** - Review security groups
8. **Encrypt Everything** - VPN, TLS, encryption at rest

Congratulations! You've completed Chapters 21-24 covering Disaster Recovery, Authentication & Authorization, Security Best Practices, and Network Security - critical topics for building secure, resilient systems!