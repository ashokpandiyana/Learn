# Chapter 2: Software Development Principles

## Table of Contents
1. SOLID Principles
2. DRY (Don't Repeat Yourself)
3. KISS (Keep It Simple, Stupid)
4. YAGNI (You Aren't Gonna Need It)
5. Separation of Concerns
6. Composition over Inheritance
7. Other Important Principles

---

## 1. SOLID Principles

SOLID is an acronym for five design principles that make software designs more understandable, flexible, and maintainable.

### 1.1 Single Responsibility Principle (SRP)

**Definition:** A class should have only one reason to change. Each class should have only one responsibility or job.

**Why It Matters:**
- Easier to understand and test
- Changes are localized
- Reduces coupling

#### ❌ Bad Example (Violates SRP)

```python
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email
    
    def save_to_database(self):
        # Database logic
        db.execute(f"INSERT INTO users VALUES ('{self.name}', '{self.email}')")
    
    def send_welcome_email(self):
        # Email logic
        smtp.send(self.email, "Welcome!")
    
    def generate_report(self):
        # Report generation logic
        return f"Report for {self.name}"
    
    def validate_email(self):
        # Validation logic
        return "@" in self.email
```

**Problems:**
- User class has 4 responsibilities: user data, database, email, reporting, validation
- Changing database logic requires modifying User class
- Hard to test each functionality independently
- Violates SRP

#### ✅ Good Example (Follows SRP)

```python
# 1. User entity - Only manages user data
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

# 2. Repository - Only handles database operations
class UserRepository:
    def __init__(self, database):
        self.db = database
    
    def save(self, user):
        self.db.execute(
            "INSERT INTO users VALUES (?, ?)",
            (user.name, user.email)
        )
    
    def find_by_email(self, email):
        return self.db.query("SELECT * FROM users WHERE email = ?", email)

# 3. Email service - Only handles email operations
class EmailService:
    def __init__(self, smtp_client):
        self.smtp = smtp_client
    
    def send_welcome_email(self, user):
        self.smtp.send(
            to=user.email,
            subject="Welcome!",
            body=f"Hello {user.name}"
        )

# 4. Report generator - Only handles reporting
class UserReportGenerator:
    def generate(self, user):
        return f"User Report\n" \
               f"Name: {user.name}\n" \
               f"Email: {user.email}"

# 5. Validator - Only handles validation
class EmailValidator:
    @staticmethod
    def is_valid(email):
        return "@" in email and "." in email.split("@")[1]

# Usage
user = User("John Doe", "john@example.com")

if EmailValidator.is_valid(user.email):
    repo = UserRepository(database)
    repo.save(user)
    
    email_service = EmailService(smtp_client)
    email_service.send_welcome_email(user)
```

**Benefits:**
- Each class has one clear responsibility
- Easy to test each component independently
- Changes are isolated (changing email logic doesn't affect User class)
- Can swap implementations easily

---

### 1.2 Open/Closed Principle (OCP)

**Definition:** Software entities should be open for extension but closed for modification. You should be able to add new functionality without changing existing code.

**Why It Matters:**
- Reduces risk of breaking existing functionality
- Promotes code reuse
- Enables plugin architectures

#### ❌ Bad Example (Violates OCP)

```java
class PaymentProcessor {
    public void processPayment(String paymentType, double amount) {
        if (paymentType.equals("CreditCard")) {
            // Credit card processing logic
            System.out.println("Processing credit card: $" + amount);
        } else if (paymentType.equals("PayPal")) {
            // PayPal processing logic
            System.out.println("Processing PayPal: $" + amount);
        } else if (paymentType.equals("Bitcoin")) {
            // Bitcoin processing logic
            System.out.println("Processing Bitcoin: $" + amount);
        }
        // Need to modify this class every time we add a new payment method!
    }
}
```

**Problems:**
- Must modify PaymentProcessor for every new payment method
- Violates OCP (not closed for modification)
- Risk of breaking existing payment methods
- Code becomes longer and harder to maintain

#### ✅ Good Example (Follows OCP)

```java
// Abstract interface - closed for modification
interface PaymentMethod {
    void process(double amount);
}

// Concrete implementations - open for extension
class CreditCardPayment implements PaymentMethod {
    private String cardNumber;
    
    public CreditCardPayment(String cardNumber) {
        this.cardNumber = cardNumber;
    }
    
    @Override
    public void process(double amount) {
        System.out.println("Processing credit card " + cardNumber + ": $" + amount);
        // Credit card specific logic
    }
}

class PayPalPayment implements PaymentMethod {
    private String email;
    
    public PayPalPayment(String email) {
        this.email = email;
    }
    
    @Override
    public void process(double amount) {
        System.out.println("Processing PayPal " + email + ": $" + amount);
        // PayPal specific logic
    }
}

class BitcoinPayment implements PaymentMethod {
    private String walletAddress;
    
    public BitcoinPayment(String walletAddress) {
        this.walletAddress = walletAddress;
    }
    
    @Override
    public void process(double amount) {
        System.out.println("Processing Bitcoin " + walletAddress + ": $" + amount);
        // Bitcoin specific logic
    }
}

// Payment processor - never needs modification when adding new payment methods
class PaymentProcessor {
    public void processPayment(PaymentMethod paymentMethod, double amount) {
        paymentMethod.process(amount);
    }
}

// Usage
PaymentProcessor processor = new PaymentProcessor();

// Can add new payment methods without modifying PaymentProcessor
processor.processPayment(new CreditCardPayment("1234-5678"), 100.0);
processor.processPayment(new PayPalPayment("user@email.com"), 50.0);
processor.processPayment(new BitcoinPayment("1A2B3C4D"), 200.0);

// Adding a new payment method (e.g., Apple Pay)
class ApplePayPayment implements PaymentMethod {
    @Override
    public void process(double amount) {
        System.out.println("Processing Apple Pay: $" + amount);
    }
}
// No need to modify PaymentProcessor!
```

---

### 1.3 Liskov Substitution Principle (LSP)

**Definition:** Objects of a superclass should be replaceable with objects of its subclasses without breaking the application. Derived classes must be substitutable for their base classes.

**Why It Matters:**
- Ensures correct inheritance hierarchies
- Prevents unexpected behavior
- Enables polymorphism

#### ❌ Bad Example (Violates LSP)

```python
class Bird:
    def fly(self):
        return "Flying in the sky"

class Sparrow(Bird):
    def fly(self):
        return "Sparrow flying"

class Ostrich(Bird):  # Problem: Ostriches can't fly!
    def fly(self):
        raise Exception("Ostriches cannot fly!")

# Code that expects all birds to fly
def make_bird_fly(bird: Bird):
    print(bird.fly())

# This works
sparrow = Sparrow()
make_bird_fly(sparrow)  # Output: Sparrow flying

# This breaks! (Violates LSP)
ostrich = Ostrich()
make_bird_fly(ostrich)  # Exception: Ostriches cannot fly!
```

**Problem:**
- Ostrich cannot be substituted for Bird
- Violates LSP because it changes expected behavior
- Causes runtime errors

#### ✅ Good Example (Follows LSP)

```python
# Better abstraction
class Bird:
    def move(self):
        pass

class FlyingBird(Bird):
    def move(self):
        return self.fly()
    
    def fly(self):
        return "Flying in the sky"

class Sparrow(FlyingBird):
    def fly(self):
        return "Sparrow flying at 50 km/h"

class Eagle(FlyingBird):
    def fly(self):
        return "Eagle soaring at 100 km/h"

class FlightlessBird(Bird):
    def move(self):
        return self.walk()
    
    def walk(self):
        return "Walking on ground"

class Ostrich(FlightlessBird):
    def walk(self):
        return "Ostrich running at 70 km/h"

class Penguin(FlightlessBird):
    def walk(self):
        return "Penguin waddling"
    
    def swim(self):
        return "Penguin swimming"

# Now substitution works correctly
def make_bird_move(bird: Bird):
    print(bird.move())

sparrow = Sparrow()
ostrich = Ostrich()
penguin = Penguin()

make_bird_move(sparrow)   # Works: Sparrow flying at 50 km/h
make_bird_move(ostrich)   # Works: Ostrich running at 70 km/h
make_bird_move(penguin)   # Works: Penguin waddling
```

**Real-World Example:**

```typescript
// Bad: Square violates LSP when inheriting from Rectangle
class Rectangle {
    protected width: number;
    protected height: number;
    
    setWidth(width: number) {
        this.width = width;
    }
    
    setHeight(height: number) {
        this.height = height;
    }
    
    getArea(): number {
        return this.width * this.height;
    }
}

class Square extends Rectangle {
    setWidth(width: number) {
        this.width = width;
        this.height = width;  // Problem: changing both!
    }
    
    setHeight(height: number) {
        this.width = height;  // Problem: changing both!
        this.height = height;
    }
}

// This breaks with Square
function testRectangle(rect: Rectangle) {
    rect.setWidth(5);
    rect.setHeight(4);
    console.log(rect.getArea());  // Expected: 20
}

testRectangle(new Rectangle());  // Output: 20 ✓
testRectangle(new Square());     // Output: 16 ✗ (Violates LSP!)

// Good: Use composition or separate hierarchies
interface Shape {
    getArea(): number;
}

class Rectangle implements Shape {
    constructor(private width: number, private height: number) {}
    
    getArea(): number {
        return this.width * this.height;
    }
}

class Square implements Shape {
    constructor(private side: number) {}
    
    getArea(): number {
        return this.side * this.side;
    }
}
```

---

### 1.4 Interface Segregation Principle (ISP)

**Definition:** Clients should not be forced to depend on interfaces they don't use. Many specific interfaces are better than one general-purpose interface.

**Why It Matters:**
- Reduces coupling
- Makes code more flexible
- Easier to understand and implement

#### ❌ Bad Example (Violates ISP)

```java
// Fat interface - forces clients to implement methods they don't need
interface Worker {
    void work();
    void eat();
    void sleep();
    void attendMeeting();
    void writeCode();
    void designSystem();
}

// Human worker - implements all methods (makes sense)
class HumanWorker implements Worker {
    public void work() { System.out.println("Working..."); }
    public void eat() { System.out.println("Eating lunch"); }
    public void sleep() { System.out.println("Sleeping"); }
    public void attendMeeting() { System.out.println("In meeting"); }
    public void writeCode() { System.out.println("Coding..."); }
    public void designSystem() { System.out.println("Designing..."); }
}

// Robot worker - forced to implement irrelevant methods!
class RobotWorker implements Worker {
    public void work() { System.out.println("Working..."); }
    
    // Robots don't eat or sleep!
    public void eat() { throw new UnsupportedOperationException(); }
    public void sleep() { throw new UnsupportedOperationException(); }
    
    public void attendMeeting() { System.out.println("In meeting"); }
    public void writeCode() { System.out.println("Coding..."); }
    public void designSystem() { System.out.println("Designing..."); }
}
```

#### ✅ Good Example (Follows ISP)

```java
// Segregated interfaces - each client implements only what it needs
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

interface Sleepable {
    void sleep();
}

interface Attendable {
    void attendMeeting();
}

interface Codeable {
    void writeCode();
}

interface Designable {
    void designSystem();
}

// Human implements all relevant interfaces
class HumanWorker implements Workable, Eatable, Sleepable, 
                               Attendable, Codeable, Designable {
    public void work() { System.out.println("Working..."); }
    public void eat() { System.out.println("Eating lunch"); }
    public void sleep() { System.out.println("Sleeping"); }
    public void attendMeeting() { System.out.println("In meeting"); }
    public void writeCode() { System.out.println("Coding..."); }
    public void designSystem() { System.out.println("Designing..."); }
}

// Robot only implements relevant interfaces
class RobotWorker implements Workable, Attendable, Codeable {
    public void work() { System.out.println("Working 24/7..."); }
    public void attendMeeting() { System.out.println("In virtual meeting"); }
    public void writeCode() { System.out.println("Auto-coding..."); }
    // No need to implement eat() or sleep()!
}

// Manager might only need certain capabilities
class Manager implements Workable, Eatable, Attendable, Designable {
    public void work() { System.out.println("Managing..."); }
    public void eat() { System.out.println("Business lunch"); }
    public void attendMeeting() { System.out.println("Leading meeting"); }
    public void designSystem() { System.out.println("High-level design"); }
    // Doesn't write code or sleep at work!
}

// Usage with specific interfaces
class WorkManager {
    public void manageWork(Workable worker) {
        worker.work();
    }
    
    public void scheduleBreak(Eatable worker) {
        worker.eat();
    }
}
```

---

### 1.5 Dependency Inversion Principle (DIP)

**Definition:** 
- High-level modules should not depend on low-level modules. Both should depend on abstractions.
- Abstractions should not depend on details. Details should depend on abstractions.

**Why It Matters:**
- Reduces coupling between modules
- Makes code more testable
- Easier to swap implementations

#### ❌ Bad Example (Violates DIP)

```csharp
// Low-level module
public class MySQLDatabase
{
    public void SaveUser(string name, string email)
    {
        Console.WriteLine($"Saving to MySQL: {name}, {email}");
        // MySQL-specific code
    }
    
    public string GetUser(int id)
    {
        return $"User from MySQL with id: {id}";
    }
}

// High-level module depends directly on low-level module
public class UserService
{
    private MySQLDatabase database;  // Tight coupling to MySQL!
    
    public UserService()
    {
        this.database = new MySQLDatabase();  // Hard-coded dependency
    }
    
    public void CreateUser(string name, string email)
    {
        database.SaveUser(name, email);
    }
    
    public string GetUserById(int id)
    {
        return database.GetUser(id);
    }
}

// Problems:
// 1. Cannot test UserService without MySQL
// 2. Cannot switch to PostgreSQL or MongoDB
// 3. UserService knows too much about MySQL
```

#### ✅ Good Example (Follows DIP)

```csharp
// Abstraction (interface)
public interface IDatabase
{
    void SaveUser(string name, string email);
    string GetUser(int id);
}

// Low-level modules implement the abstraction
public class MySQLDatabase : IDatabase
{
    public void SaveUser(string name, string email)
    {
        Console.WriteLine($"Saving to MySQL: {name}, {email}");
        // MySQL-specific code
    }
    
    public string GetUser(int id)
    {
        return $"User from MySQL with id: {id}";
    }
}

public class PostgreSQLDatabase : IDatabase
{
    public void SaveUser(string name, string email)
    {
        Console.WriteLine($"Saving to PostgreSQL: {name}, {email}");
        // PostgreSQL-specific code
    }
    
    public string GetUser(int id)
    {
        return $"User from PostgreSQL with id: {id}";
    }
}

public class MongoDBDatabase : IDatabase
{
    public void SaveUser(string name, string email)
    {
        Console.WriteLine($"Saving to MongoDB: {name}, {email}");
        // MongoDB-specific code
    }
    
    public string GetUser(int id)
    {
        return $"User from MongoDB with id: {id}";
    }
}

// High-level module depends on abstraction
public class UserService
{
    private readonly IDatabase database;  // Depends on interface!
    
    // Dependency injection via constructor
    public UserService(IDatabase database)
    {
        this.database = database;
    }
    
    public void CreateUser(string name, string email)
    {
        database.SaveUser(name, email);
    }
    
    public string GetUserById(int id)
    {
        return database.GetUser(id);
    }
}

// Usage - we can easily swap implementations!
class Program
{
    static void Main()
    {
        // Use MySQL
        IDatabase mysqlDb = new MySQLDatabase();
        UserService userService1 = new UserService(mysqlDb);
        userService1.CreateUser("John", "john@example.com");
        
        // Switch to PostgreSQL - no changes to UserService!
        IDatabase postgresDb = new PostgreSQLDatabase();
        UserService userService2 = new UserService(postgresDb);
        userService2.CreateUser("Jane", "jane@example.com");
        
        // Switch to MongoDB
        IDatabase mongoDb = new MongoDBDatabase();
        UserService userService3 = new UserService(mongoDb);
        userService3.CreateUser("Bob", "bob@example.com");
    }
}

// Easy to test with mock
public class MockDatabase : IDatabase
{
    public void SaveUser(string name, string email)
    {
        Console.WriteLine("Mock: User saved");
    }
    
    public string GetUser(int id)
    {
        return "Mock user";
    }
}

// Test
var mockDb = new MockDatabase();
var testService = new UserService(mockDb);
testService.CreateUser("Test", "test@test.com");  // Uses mock, no real DB needed!
```

**Benefits:**
- UserService can work with any database
- Easy to test with mocks
- Can change database without modifying UserService
- Both high and low-level modules depend on the IDatabase abstraction

---

## 2. DRY (Don't Repeat Yourself)

**Definition:** Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.

**Why It Matters:**
- Changes need to be made in only one place
- Reduces bugs from inconsistent updates
- Easier to maintain

#### ❌ Bad Example (Violates DRY)

```javascript
// Repeated validation logic
function createUser(name, email, age) {
    if (!name || name.length < 2) {
        throw new Error("Name must be at least 2 characters");
    }
    if (!email || !email.includes("@")) {
        throw new Error("Invalid email format");
    }
    if (!age || age < 18) {
        throw new Error("Must be 18 or older");
    }
    // Create user...
}

function updateUser(userId, name, email, age) {
    if (!name || name.length < 2) {  // Repeated!
        throw new Error("Name must be at least 2 characters");
    }
    if (!email || !email.includes("@")) {  // Repeated!
        throw new Error("Invalid email format");
    }
    if (!age || age < 18) {  // Repeated!
        throw new Error("Must be 18 or older");
    }
    // Update user...
}

// If validation rules change, must update in multiple places!
```

#### ✅ Good Example (Follows DRY)

```javascript
// Single source of truth for validation
class UserValidator {
    static validateName(name) {
        if (!name || name.length < 2) {
            throw new Error("Name must be at least 2 characters");
        }
    }
    
    static validateEmail(email) {
        if (!email || !email.includes("@")) {
            throw new Error("Invalid email format");
        }
    }
    
    static validateAge(age) {
        if (!age || age < 18) {
            throw new Error("Must be 18 or older");
        }
    }
    
    static validateUser(name, email, age) {
        this.validateName(name);
        this.validateEmail(email);
        this.validateAge(age);
    }
}

function createUser(name, email, age) {
    UserValidator.validateUser(name, email, age);
    // Create user...
}

function updateUser(userId, name, email, age) {
    UserValidator.validateUser(name, email, age);
    // Update user...
}

// Now validation rules are in ONE place!
```

**Note:** Don't confuse DRY with removing all code duplication. If two pieces of code are similar but represent different concepts, don't force them together. **Duplication is better than the wrong abstraction.**

---

## 3. KISS (Keep It Simple, Stupid)

**Definition:** Systems work best when they're kept simple. Avoid unnecessary complexity.

**Why It Matters:**
- Easier to understand and maintain
- Fewer bugs
- Faster development

#### ❌ Bad Example (Over-complicated)

```python
# Over-engineered solution
class AbstractFactoryBuilderSingletonProxyAdapter:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def create_user_builder_factory(self):
        return UserBuilderFactory(UserBuilder(User()))
    
    def build_with_chain_of_responsibility(self, data):
        handler_chain = ValidationHandler()
        handler_chain.set_next(TransformationHandler()) \
                     .set_next(PersistenceHandler()) \
                     .set_next(NotificationHandler())
        return handler_chain.handle(data)

# Just to add a user!
factory = AbstractFactoryBuilderSingletonProxyAdapter()
result = factory.build_with_chain_of_responsibility(user_data)
```

#### ✅ Good Example (Simple and Clear)

```python
# Simple, readable solution
class UserService:
    def __init__(self, repository, email_service):
        self.repository = repository
        self.email_service = email_service
    
    def create_user(self, name, email):
        # Validate
        if not self._is_valid_email(email):
            raise ValueError("Invalid email")
        
        # Create
        user = User(name, email)
        self.repository.save(user)
        
        # Notify
        self.email_service.send_welcome(user)
        
        return user
    
    def _is_valid_email(self, email):
        return "@" in email

# Clear and straightforward
service = UserService(UserRepository(), EmailService())
user = service.create_user("John", "john@example.com")
```

**Guideline:**
- Start simple, add complexity only when needed
- Prefer clear code over clever code
- If you can't explain it simply, it's probably too complex

---

## 4. YAGNI (You Aren't Gonna Need It)

**Definition:** Don't implement features until you actually need them. Don't add functionality on the speculation that it might be useful later.

**Why It Matters:**
- Reduces wasted effort
- Less code to maintain
- Faster initial development

#### ❌ Bad Example (Violates YAGNI)

```typescript
// Building features "just in case"
class UserManager {
    // Current requirement: Store name and email
    // But developer adds "future-proofing"...
    
    createUser(
        name: string,
        email: string,
        middleName?: string,  // Not needed yet
        phoneNumber?: string,  // Not needed yet
        address?: Address,  // Not needed yet
        socialSecurityNumber?: string,  // Not needed yet
        preferences?: UserPreferences,  // Not needed yet
        metadata?: Map<string, any>  // "For future extensibility"
    ) {
        // Complex handling of all these optional fields
        // that nobody actually uses yet...
    }
    
    // Methods for features not in requirements
    archiveUser() { /* Not needed yet */ }
    exportUserData() { /* Not needed yet */ }
    migrateUserToNewSystem() { /* Not needed yet */ }
    calculateUserLifetimeValue() { /* Not needed yet */ }
}
```

#### ✅ Good Example (Follows YAGNI)

```typescript
// Implement only what's needed NOW
class UserManager {
    createUser(name: string, email: string): User {
        return new User(name, email);
    }
    
    getUser(id: string): User {
        return this.repository.findById(id);
    }
    
    updateUserEmail(id: string, newEmail: string): void {
        const user = this.getUser(id);
        user.email = newEmail;
        this.repository.save(user);
    }
}

// When phoneNumber is actually needed, add it then:
// updateUserPhone(id: string, phone: string): void { ... }
```

**Balance:** YAGNI doesn't mean write bad code. It means don't add features speculatively. Still design for maintainability and extensibility through good principles (SOLID, etc.).

---

## 5. Separation of Concerns

**Definition:** Different concerns or responsibilities should be separated into distinct sections of code.

**Why It Matters:**
- Organized codebase
- Easier to modify one concern without affecting others
- Better testability

#### Example: Three-Tier Architecture

```python
# ============ PRESENTATION LAYER ============
# Concern: Handle HTTP requests/responses
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/users', methods=['POST'])
def create_user_endpoint():
    data = request.json
    
    # Delegate to business logic layer
    user_service = UserService(UserRepository(database))
    user = user_service.create_user(data['name'], data['email'])
    
    return jsonify({
        'id': user.id,
        'name': user.name,
        'email': user.email
    }), 201

# ============ BUSINESS LOGIC LAYER ============
# Concern: Business rules and workflows
class UserService:
    def __init__(self, repository):
        self.repository = repository
    
    def create_user(self, name, email):
        # Business validation
        if not self._is_valid_email(email):
            raise ValueError("Invalid email format")
        
        if self.repository.exists_by_email(email):
            raise ValueError("Email already registered")
        
        # Business logic
        user = User(name=name, email=email)
        user.created_at = datetime.now()
        
        # Persist
        self.repository.save(user)
        
        return user
    
    def _is_valid_email(self, email):
        return "@" in email and "." in email

# ============ DATA ACCESS LAYER ============
# Concern: Database operations
class UserRepository:
    def __init__(self, database):
        self.db = database
    
    def save(self, user):
        self.db.execute(
            "INSERT INTO users (name, email, created_at) VALUES (?, ?, ?)",
            (user.name, user.email, user.created_at)
        )
    
    def exists_by_email(self, email):
        result = self.db.query(
            "SELECT COUNT(*) FROM users WHERE email = ?",
            (email,)
        )
        return result[0] > 0
    
    def find_by_id(self, user_id):
        result = self.db.query(
            "SELECT * FROM users WHERE id = ?",
            (user_id,)
        )
        return User(**result[0]) if result else None
```

**Benefits:**
- Can change database without touching business logic
- Can change API format without touching database layer
- Each layer can be tested independently

---

## 6. Composition over Inheritance

**Definition:** Favor object composition over class inheritance. Build functionality by composing objects rather than inheriting from base classes.

**Why It Matters:**
- More flexible
- Avoids deep inheritance hierarchies
- Easier to change behavior at runtime

#### ❌ Bad Example (Deep Inheritance)

```java
// Inheritance explosion
class Animal {
    void eat() { }
}

class FlyingAnimal extends Animal {
    void fly() { }
}

class SwimmingAnimal extends Animal {
    void swim() { }
}

// Problem: What about animals that both fly and swim?
// Can't inherit from both FlyingAnimal and SwimmingAnimal

class Duck extends ??? {  // Ducks fly AND swim!
    // Forced to duplicate code or use complex multiple inheritance
}

class Penguin extends SwimmingAnimal {
    // But penguins are birds... this hierarchy is confusing
}
```

#### ✅ Good Example (Composition)

```java
// Separate capabilities as interfaces
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

interface Walkable {
    void walk();
}

// Concrete implementations
class WingsFlight implements Flyable {
    public void fly() {
        System.out.println("Flying with wings");
    }
}

class WaterSwim implements Swimmable {
    public void swim() {
        System.out.println("Swimming in water");
    }
}

class LegWalk implements Walkable {
    public void walk() {
        System.out.println("Walking on legs");
    }
}

// Compose animals from capabilities
class Duck {
    private Flyable flightCapability;
    private Swimmable swimCapability;
    private Walkable walkCapability;
    
    public Duck() {
        this.flightCapability = new WingsFlight();
        this.swimCapability = new WaterSwim();
        this.walkCapability = new LegWalk();
    }
    
    public void fly() {
        flightCapability.fly();
    }
    
    public void swim() {
        swimCapability.swim();
    }
    
    public void walk() {
        walkCapability.walk();
    }
}

class Penguin {
    private Swimmable swimCapability;
    private Walkable walkCapability;
    // No flight capability!
    
    public Penguin() {
        this.swimCapability = new WaterSwim();
        this.walkCapability = new LegWalk();
    }
    
    public void swim() {
        swimCapability.swim();
    }
    
    public void walk() {
        walkCapability.walk();
    }
}

// Can even change behavior at runtime!
class Airplane {
    private Flyable flightCapability;
    
    public void setFlightMode(Flyable mode) {
        this.flightCapability = mode;
    }
    
    public void fly() {
        flightCapability.fly();
    }
}
```

---

## 7. Other Important Principles

### 7.1 Law of Demeter (Principle of Least Knowledge)

**Definition:** A method should only talk to its immediate friends. Don't talk to strangers.

```javascript
// Bad: Chain of calls (talking to strangers)
user.getAddress().getCity().getName();

// Good: Ask directly
user.getCityName();

// Implementation
class User {
    constructor(address) {
        this.address = address;
    }
    
    getCityName() {
        return this.address.getCityName();  // Delegate to address
    }
}
```

### 7.2 Fail Fast

**Definition:** Detect and report errors as early as possible.

```python
def process_payment(amount, currency):
    # Bad: Check at the end
    # ... lots of processing ...
    if amount <= 0:
        raise ValueError("Invalid amount")
    
    # Good: Check immediately
    if amount <= 0:
        raise ValueError("Invalid amount")
    
    if currency not in ['USD', 'EUR', 'GBP']:
        raise ValueError("Unsupported currency")
    
    # Now do processing knowing inputs are valid
    # ... processing ...
```

### 7.3 Principle of Least Astonishment

**Definition:** Code should behave in a way that users expect. Don't surprise users.

```ruby
# Bad: Surprising behavior
def save_user(user)
  # Surprisingly also sends email!
  database.save(user)
  email_service.send_welcome(user)
end

# Good: Clear and predictable
def save_user(user)
  database.save(user)
end

def save_user_and_send_welcome(user)
  save_user(user)
  email_service.send_welcome(user)
end
```

---

## Chapter 2 Summary

### Key Takeaways

1. **SOLID** - Five principles for maintainable OOP
   - **S**ingle Responsibility: One reason to change
   - **O**pen/Closed: Open for extension, closed for modification
   - **L**iskov Substitution: Subtypes must be substitutable
   - **I**nterface Segregation: Many specific interfaces over one general
   - **D**ependency Inversion: Depend on abstractions, not concretions

2. **DRY** - Don't repeat yourself (but don't over-abstract)

3. **KISS** - Keep it simple, avoid unnecessary complexity

4. **YAGNI** - Don't build what you don't need yet

5. **Separation of Concerns** - Organize code by responsibility

6. **Composition over Inheritance** - Build with composition, not deep hierarchies

### Interview Tips

**Common Questions:**
- "Explain SOLID principles with examples"
- "When would you violate DRY?" (Answer: When duplication is accidental, not essential)
- "Give an example of over-engineering" (KISS/YAGNI violation)
- "How do you ensure code is maintainable?"

**How to Answer:**
- Use concrete examples from your experience
- Explain the "why" behind each principle
- Mention trade-offs and when to bend rules
- Show you understand these are guidelines, not laws

### Next Steps

In Chapter 3, we'll explore Design Patterns - proven solutions to common problems that apply these principles in practice.