<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 3: System Models</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        h1 {
            color: #2c3e50;
            border-bottom: 4px solid #667eea;
            padding-bottom: 15px;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        h2 {
            color: #667eea;
            margin-top: 50px;
            margin-bottom: 25px;
            font-size: 2em;
            border-left: 6px solid #764ba2;
            padding-left: 15px;
        }
        
        h3 {
            color: #34495e;
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.5em;
        }
        
        h4 {
            color: #555;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        .definition {
            background: linear-gradient(135deg, #e0f7fa 0%, #b2ebf2 100%);
            border-left: 5px solid #00acc1;
            padding: 25px;
            margin: 25px 0;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .example {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            border-left: 5px solid #ff9800;
            padding: 25px;
            margin: 25px 0;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .key-point {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-left: 5px solid #4caf50;
            padding: 25px;
            margin: 25px 0;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .warning {
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
            border-left: 5px solid #f44336;
            padding: 25px;
            margin: 25px 0;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .architecture-diagram {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 12px;
            margin: 30px 0;
            border: 2px solid #dee2e6;
        }
        
        .arch-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }
        
        .node {
            padding: 20px;
            border-radius: 12px;
            color: white;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            min-width: 100px;
            transition: transform 0.3s ease;
        }
        
        .node:hover {
            transform: scale(1.1);
        }
        
        .client {
            background: linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%);
        }
        
        .server {
            background: linear-gradient(135deg, #2196F3 0%, #42A5F5 100%);
        }
        
        .peer {
            background: linear-gradient(135deg, #FF9800 0%, #FFA726 100%);
        }
        
        .arrow {
            font-size: 2em;
            color: #666;
            margin: 0 10px;
        }
        
        .connection-line {
            width: 60px;
            height: 3px;
            background: #666;
            margin: 0 10px;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        
        .comparison-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: bold;
        }
        
        .comparison-table td {
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .comparison-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .comparison-table tr:hover {
            background: #e3f2fd;
        }
        
        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #667eea;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        code {
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
        }
        
        .model-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 25px;
            margin: 20px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        
        .model-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
            border-color: #667eea;
        }
        
        .grid-3 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .failure-scenario {
            background: white;
            border: 3px solid #f44336;
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            position: relative;
        }
        
        .failure-badge {
            position: absolute;
            top: -15px;
            left: 20px;
            background: #f44336;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .timeline {
            position: relative;
            padding: 20px 0;
        }
        
        .timeline-item {
            display: flex;
            align-items: center;
            margin: 20px 0;
            position: relative;
        }
        
        .timeline-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            margin-right: 20px;
            flex-shrink: 0;
        }
        
        .timeline-content {
            flex: 1;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid #667eea;
        }
        
        ul {
            margin: 15px 0 15px 30px;
        }
        
        li {
            margin-bottom: 10px;
        }
        
        strong {
            color: #2c3e50;
        }
        
        .interactive-demo {
            background: linear-gradient(135deg, #fce4ec 0%, #f8bbd0 100%);
            padding: 25px;
            border-radius: 12px;
            margin: 30px 0;
            border: 2px solid #e91e63;
        }
        
        .demo-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            margin: 10px 5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .demo-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.3);
        }
        
        .demo-output {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            min-height: 100px;
            font-family: monospace;
            white-space: pre-wrap;
            border: 1px solid #e0e0e0;
        }
        
        .attack-demo {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .attacker {
            background: linear-gradient(135deg, #f44336 0%, #e57373 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
        }
        
        .honest-node {
            background: linear-gradient(135deg, #4CAF50 0%, #81C784 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
        }
        
        .security-layer {
            background: white;
            border: 2px solid #9C27B0;
            border-radius: 8px;
            padding: 20px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .security-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #9C27B0 0%, #BA68C8 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5em;
            flex-shrink: 0;
        }
        
        .timing-diagram {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border: 2px solid #dee2e6;
        }
        
        .clock {
            display: inline-block;
            width: 60px;
            height: 60px;
            border: 3px solid #667eea;
            border-radius: 50%;
            position: relative;
            margin: 10px;
        }
        
        .clock-hand {
            position: absolute;
            background: #667eea;
            transform-origin: bottom center;
            left: 50%;
            bottom: 50%;
        }
        
        .highlight-box {
            background: linear-gradient(135deg, #FFF9C4 0%, #FFF59D 100%);
            border: 2px solid #FBC02D;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèóÔ∏è Chapter 3: System Models</h1>
        
        <div class="definition">
            <h3>üìñ What are System Models?</h3>
            <p><strong>System models</strong> are abstractions that help us reason about distributed systems by defining assumptions about:</p>
            <ul>
                <li>How components interact (architecture)</li>
                <li>How they communicate (interaction)</li>
                <li>What can go wrong (failures)</li>
                <li>Security threats and protections</li>
                <li>Timing and synchronization</li>
            </ul>
            <p><strong>Why models matter:</strong> They help us design systems that work correctly even when assumptions are violated!</p>
        </div>
        
        <h2>1Ô∏è‚É£ Architecture Models</h2>
        
        <p>Architecture models describe the <strong>structure and organization</strong> of distributed systems - how components are arranged and interact.</p>
        
        <h3>üî∑ Client-Server Architecture</h3>
        
        <div class="architecture-diagram">
            <div class="arch-container">
                <div class="node client">Client 1</div>
                <div class="arrow">‚Üí</div>
                <div class="node server" style="font-size: 1.3em;">SERVER</div>
                <div class="arrow">‚Üê</div>
                <div class="node client">Client 2</div>
            </div>
            <div class="arch-container">
                <div class="node client">Client 3</div>
                <div class="arrow">‚Üó</div>
                <div style="text-align: center; margin: 0 20px;">
                    <div style="color: #666; font-weight: bold;">All requests</div>
                    <div style="color: #666; font-weight: bold;">go through server</div>
                </div>
                <div class="arrow">‚Üñ</div>
                <div class="node client">Client 4</div>
            </div>
        </div>
        
        <div class="key-point">
            <h4>Characteristics:</h4>
            <ul>
                <li><strong>Clients:</strong> Request services (web browsers, mobile apps)</li>
                <li><strong>Server:</strong> Provides services (web server, database server)</li>
                <li><strong>Asymmetric:</strong> Different roles and responsibilities</li>
                <li><strong>Centralized control:</strong> Server manages resources and state</li>
                <li><strong>Many-to-one:</strong> Multiple clients, typically one (or few) servers</li>
            </ul>
        </div>
        
        <div class="example">
            <h3>üåê Real-World Example: Netflix</h3>
            <ul>
                <li><strong>Clients:</strong> Your TV app, phone app, web browser</li>
                <li><strong>Servers:</strong> Netflix's backend (authentication, catalog, streaming)</li>
                <li><strong>Flow:</strong>
                    <ul>
                        <li>Client requests movie list ‚Üí Server sends catalog</li>
                        <li>Client selects movie ‚Üí Server authenticates and starts stream</li>
                        <li>Server tracks watch progress, recommendations</li>
                    </ul>
                </li>
            </ul>
        </div>
        
        <h4>Variations:</h4>
        
        <div class="model-card">
            <h4>üîÑ Multi-Tier Architecture (N-Tier)</h4>
            <div class="architecture-diagram">
                <div class="arch-container">
                    <div class="node client">Client<br>(Browser)</div>
                    <div class="arrow">‚Üî</div>
                    <div class="node server">Web Server<br>(Frontend)</div>
                    <div class="arrow">‚Üî</div>
                    <div class="node server">App Server<br>(Business Logic)</div>
                    <div class="arrow">‚Üî</div>
                    <div class="node server" style="background: linear-gradient(135deg, #9C27B0 0%, #BA68C8 100%);">Database<br>(Data)</div>
                </div>
            </div>
            <p><strong>Example:</strong> E-commerce website with presentation layer, business logic layer, and data layer</p>
        </div>
        
        <div class="model-card">
            <h4>‚öñÔ∏è Load-Balanced Architecture</h4>
            <div class="architecture-diagram">
                <div class="arch-container" style="flex-direction: column;">
                    <div class="node client">Clients</div>
                    <div class="arrow" style="transform: rotate(90deg);">‚Üí</div>
                    <div class="node server" style="background: linear-gradient(135deg, #FF9800 0%, #FFA726 100%);">Load Balancer</div>
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <div class="node server">Server 1</div>
                        <div class="node server">Server 2</div>
                        <div class="node server">Server 3</div>
                    </div>
                </div>
            </div>
            <p><strong>Example:</strong> Google Search distributes queries across thousands of servers</p>
        </div>
        
        <h3>üî∂ Peer-to-Peer (P2P) Architecture</h3>
        
        <div class="architecture-diagram">
            <div class="arch-container">
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;">
                    <div class="node peer">Peer 1</div>
                    <div class="node peer">Peer 2</div>
                    <div class="node peer">Peer 3</div>
                </div>
            </div>
            <div style="text-align: center; margin: 20px 0;">
                <div style="font-size: 1.5em; color: #666;">‚ü∑ All interconnected ‚ü∑</div>
            </div>
            <div class="arch-container">
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;">
                    <div class="node peer">Peer 4</div>
                    <div class="node peer">Peer 5</div>
                    <div class="node peer">Peer 6</div>
                </div>
            </div>
        </div>
        
        <div class="key-point">
            <h4>Characteristics:</h4>
            <ul>
                <li><strong>All peers are equal:</strong> No central server</li>
                <li><strong>Symmetric roles:</strong> Each peer is both client and server</li>
                <li><strong>Decentralized:</strong> No single point of control</li>
                <li><strong>Self-organizing:</strong> Peers join/leave dynamically</li>
                <li><strong>Scalable:</strong> More peers = more capacity</li>
            </ul>
        </div>
        
        <div class="example">
            <h3>üìÅ Real-World Example: BitTorrent</h3>
            <ul>
                <li><strong>No central server</strong> stores the complete file</li>
                <li><strong>Each peer</strong> has pieces of the file</li>
                <li><strong>Peers share with each other:</strong> You download from multiple peers simultaneously</li>
                <li><strong>You also upload</strong> pieces you have to others</li>
                <li><strong>More popular files</strong> = more peers = faster downloads</li>
            </ul>
            <pre><code>// P2P Example: Finding peers
class Peer {
    constructor(id, files) {
        this.id = id;
        this.files = files;
        this.connectedPeers = [];
    }
    
    // Peer can request from other peers
    async requestFile(filename) {
        for (const peer of this.connectedPeers) {
            if (peer.hasFile(filename)) {
                return await peer.sendFile(filename);
            }
        }
    }
    
    // Peer can serve to other peers
    async sendFile(filename) {
        if (this.files.includes(filename)) {
            return this.readFile(filename);
        }
    }
}</code></pre>
        </div>
        
        <h4>P2P Variations:</h4>
        <ul>
            <li><strong>Unstructured P2P:</strong> Random connections (Gnutella)</li>
            <li><strong>Structured P2P:</strong> Organized topology using DHT (Chord, Kademlia)</li>
            <li><strong>Hybrid P2P:</strong> Central index server + P2P transfers (early Napster)</li>
        </ul>
        
        <h3>üî∑üî∂ Hybrid Architecture</h3>
        
        <div class="architecture-diagram">
            <div class="arch-container" style="flex-direction: column;">
                <div class="node server">Central Coordination Server</div>
                <div class="arrow" style="transform: rotate(90deg);">‚Üì</div>
                <div style="background: #fff3e0; padding: 20px; border-radius: 12px; border: 2px dashed #ff9800;">
                    <div style="text-align: center; margin-bottom: 15px; font-weight: bold; color: #f57c00;">P2P Network</div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;">
                        <div class="node peer" style="padding: 10px; font-size: 0.9em;">Peer 1</div>
                        <div class="node peer" style="padding: 10px; font-size: 0.9em;">Peer 2</div>
                        <div class="node peer" style="padding: 10px; font-size: 0.9em;">Peer 3</div>
                        <div class="node peer" style="padding: 10px; font-size: 0.9em;">Peer 4</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="key-point">
            <h4>Characteristics:</h4>
            <ul>
                <li><strong>Combines both models:</strong> Central coordination + P2P data transfer</li>
                <li><strong>Best of both worlds:</strong> Centralized discovery, distributed delivery</li>
                <li><strong>Examples:</strong> Skype (initially), Spotify, some blockchain systems</li>
            </ul>
        </div>
        
        <div class="example">
            <h3>üéµ Real-World Example: Spotify</h3>
            <ul>
                <li><strong>Central servers:</strong> Authentication, music catalog, search</li>
                <li><strong>P2P component:</strong> Music streaming between nearby clients</li>
                <li><strong>How it works:</strong>
                    <ul>
                        <li>You search for a song ‚Üí Server provides metadata</li>
                        <li>Streaming can come from: Spotify servers OR nearby users playing the same song</li>
                        <li>Reduces bandwidth costs for Spotify</li>
                        <li>Faster delivery for users</li>
                    </ul>
                </li>
            </ul>
        </div>
        
        <table class="comparison-table">
            <tr>
                <th>Aspect</th>
                <th>Client-Server</th>
                <th>Peer-to-Peer</th>
                <th>Hybrid</th>
            </tr>
            <tr>
                <td><strong>Scalability</strong></td>
                <td>‚ö†Ô∏è Limited by server</td>
                <td>‚úÖ Excellent (grows with users)</td>
                <td>‚úÖ Good</td>
            </tr>
            <tr>
                <td><strong>Reliability</strong></td>
                <td>‚ùå Server is SPOF</td>
                <td>‚úÖ No SPOF</td>
                <td>‚ö†Ô∏è Server needed for coordination</td>
            </tr>
            <tr>
                <td><strong>Control</strong></td>
                <td>‚úÖ Full control</td>
                <td>‚ùå No control</td>
                <td>‚úÖ Partial control</td>
            </tr>
            <tr>
                <td><strong>Security</strong></td>
                <td>‚úÖ Easier to secure</td>
                <td>‚ùå Hard to secure</td>
                <td>‚ö†Ô∏è Moderate</td>
            </tr>
            <tr>
                <td><strong>Consistency</strong></td>
                <td>‚úÖ Easy (central state)</td>
                <td>‚ùå Very hard</td>
                <td>‚ö†Ô∏è Moderate</td>
            </tr>
            <tr>
                <td><strong>Cost</strong></td>
                <td>üí∞üí∞ High (server infrastructure)</td>
                <td>üí∞ Low (users provide resources)</td>
                <td>üí∞üí∞ Medium</td>
            </tr>
            <tr>
                <td><strong>Use Cases</strong></td>
                <td>Web apps, databases, APIs</td>
                <td>File sharing, blockchain</td>
                <td>Messaging, streaming, CDN</td>
            </tr>
        </table>
        
        <h2>2Ô∏è‚É£ Interaction Models</h2>
        
        <p>Interaction models describe <strong>how components communicate and coordinate</strong> in a distributed system.</p>
        
        <div class="definition">
            <h3>Key Questions:</h3>
            <ul>
                <li>Does the sender wait for a response? (Synchronous vs Asynchronous)</li>
                <li>Are interactions time-dependent or time-independent?</li>
                <li>How do we handle message delays and failures?</li>
            </ul>
        </div>
        
        <h3>üîÑ Synchronous Interaction</h3>
        
        <div class="timeline">
            <div class="timeline-item">
                <div class="timeline-dot"></div>
                <div class="timeline-content">
                    <strong>T1:</strong> Client sends request ‚Üí Server
                </div>
            </div>
            <div class="timeline-item">
                <div class="timeline-dot" style="background: #ccc;"></div>
                <div class="timeline-content" style="background: #f0f0f0; border-left-color: #ccc;">
                    <strong>T2-T5:</strong> Client BLOCKED, waiting... ‚è≥
                </div>
            </div>
            <div class="timeline-item">
                <div class="timeline-dot"></div>
                <div class="timeline-content">
                    <strong>T6:</strong> Server processes and returns response
                </div>
            </div>
            <div class="timeline-item">
                <div class="timeline-dot"></div>
                <div class="timeline-content">
                    <strong>T7:</strong> Client receives response and continues
                </div>
            </div>
        </div>
        
        <div class="key-point">
            <h4>Characteristics:</h4>
            <ul>
                <li><strong>Blocking:</strong> Sender waits for receiver to respond</li>
                <li><strong>Time-bound:</strong> Assumes bounded processing and communication time</li>
                <li><strong>Tight coupling:</strong> Both parties must be available simultaneously</li>
                <li><strong>Simpler reasoning:</strong> Linear, step-by-step execution</li>
            </ul>
        </div>
        
        <h3>‚ö° Asynchronous Interaction</h3>
        
        <div class="timeline">
            <div class="timeline-item">
                <div class="timeline-dot"></div>
                <div class="timeline-content">
                    <strong>T1:</strong> Client sends request ‚Üí Server
                </div>
            </div>
            <div class="timeline-item">
                <div class="timeline-dot" style="background: #4caf50;"></div>
                <div class="timeline-content" style="border-left-color: #4caf50;">
                    <strong>T2:</strong> Client continues with other work ‚úÖ
                </div>
            </div>
            <div class="timeline-item">
                <div class="timeline-dot" style="background: #4caf50;"></div>
                <div class="timeline-content" style="border-left-color: #4caf50;">
                    <strong>T3:</strong> Client doing more work ‚úÖ
                </div>
            </div>
            <div class="timeline-item">
                <div class="timeline-dot"></div>
                <div class="timeline-content">
                    <strong>T4:</strong> Server processes request
                </div>
            </div>
            <div class="timeline-item">
                <div class="timeline-dot" style="background: #9c27b0;"></div>
                <div class="timeline-content" style="border-left-color: #9c27b0;">
                    <strong>T5:</strong> Client receives callback/notification with result
                </div>
            </div>
        </div>
        
        <div class="key-point">
            <h4>Characteristics:</h4>
            <ul>
                <li><strong>Non-blocking:</strong> Sender continues immediately</li>
                <li><strong>Time-independent:</strong> No assumption about response time</li>
                <li><strong>Loose coupling:</strong> Parties don't need to be available simultaneously</li>
                <li><strong>Complex reasoning:</strong> Must handle callbacks, promises, events</li>
            </ul>
        </div>
        
        <pre><code>// Synchronous Example
function processOrder(orderId) {
    const order = fetchOrder(orderId);        // WAIT
    const payment = processPayment(order);    // WAIT
    const shipping = arrangeShipping(order);  // WAIT
    return {order, payment, shipping};
}
// Total time: sum of all operations

// Asynchronous Example
async function processOrder(orderId) {
    const orderPromise = fetchOrder(orderId);
    
    // Don't wait! Start other operations
    doOtherWork();
    
    // When ready, await the result
    const order = await orderPromise;
    
    // Can even parallelize independent operations
    const [payment, shipping] = await Promise.all([
        processPayment(order),
        arrangeShipping(order)
    ]);
    
    return {order, payment, shipping};
}
// Total time: max of operations (parallelized!)</code></pre>
        
        <h2>3Ô∏è‚É£ Failure Models</h2>
        
        <p>Failure models describe <strong>what can go wrong</strong> in a distributed system and help us design systems that handle failures gracefully.</p>
        
        <div class="warning">
            <h3>‚ö†Ô∏è The Fundamental Challenge</h3>
            <p><strong>In distributed systems, failures are the norm, not the exception!</strong></p>
            <p>Networks fail, machines crash, messages get lost. We must design for failure.</p>
        </div>
        
        <h3>üí• Types of Failures</h3>
        
        <div class="failure-scenario">
            <div class="failure-badge">CRASH FAILURE</div>
            <h4 style="margin-top: 20px;">Crash Failures (Fail-Stop)</h4>
            <p><strong>What happens:</strong> A component stops working and doesn't respond to any messages.</p>
            <p><strong>Characteristics:</strong></p>
            <ul>
                <li>Component crashes and halts permanently</li>
                <li>Stops sending/receiving messages</li>
                <li>Other components can detect the failure (eventually)</li>
                <li><strong>Benign:</strong> The failed component doesn't produce incorrect results</li>
            </ul>
            
            <div class="architecture-diagram">
                <div class="arch-container">
                    <div class="node client">Client</div>
                    <div class="arrow">‚Üí</div>
                    <div class="node server" style="background: linear-gradient(135deg, #f44336 0%, #e57373 100%); text-decoration: line-through;">
                        ‚ùå Server<br>(Crashed)
                    </div>
                </div>
                <p style="text-align: center; margin-top: 15px; color: #f44336; font-weight: bold;">No response, server is dead</p>
            </div>
            
            <div class="example">
                <h4>Examples:</h4>
                <ul>
                    <li>Server runs out of memory and crashes</li>
                    <li>Power failure</li>
                    <li>Hardware failure (disk dies, CPU overheats)</li>
                    <li>Software bug causes segmentation fault</li>
                </ul>
                
                <h4>Detection:</h4>
                <pre><code>// Heartbeat mechanism
class FailureDetector {
    constructor(timeout = 5000) {
        this.timeout = timeout;
        this.lastHeartbeat = Date.now();
    }
    
    receiveHeartbeat() {
        this.lastHeartbeat = Date.now();
    }
    
    isAlive() {
        const elapsed = Date.now() - this.lastHeartbeat;
        return elapsed < this.timeout;
    }
}

// Usage
const detector = new FailureDetector();
setInterval(() => {
    if (!detector.isAlive()) {
        console.log("Server crashed! Failing over to backup...");
        failoverToBackup();
    }
}, 1000);</code></pre>
            </div>
        </div>
        
        <div class="failure-scenario">
            <div class="failure-badge">OMISSION FAILURE</div>
            <h4 style="margin-top: 20px;">Omission Failures</h4>
            <p><strong>What happens:</strong> A component fails to send or receive messages, but continues operating.</p>
            <p><strong>Types:</strong></p>
            <ul>
                <li><strong>Send Omission:</strong> Component fails to send a message</li>
                <li><strong>Receive Omission:</strong> Component fails to receive a message</li>
                <li><strong>Channel Omission:</strong> Message is lost in the network</li>
            </ul>
            
            <div class="architecture-diagram">
                <div class="arch-container">
                    <div class="node client">Client</div>
                    <div style="margin: 0 20px; text-align: center;">
                        <div>‚Üí Message sent</div>
                        <div style="color: #f44336; font-weight: bold; margin: 10px 0;">‚ùå LOST in network</div>
                        <div style="color: #999;">(packet dropped)</div>
                    </div>
                    <div class="node server">Server<br>(Running fine)</div>
                </div>
            </div>
            
            <div class="example">
                <h4>Examples:</h4>
                <ul>
                    <li>Network congestion causes packet loss</li>
                    <li>Buffer overflow in network switch</li>
                    <li>Firewall drops packets</li>
                    <li>Full receive buffer (receiver too slow)</li>
                </ul>
                
                <h4>Handling:</h4>
                <pre><code>// Retry with timeout
async function sendWithRetry(message, maxRetries = 3) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await sendMessage(message, {
                timeout: 5000
            });
            return response; // Success!
        } catch (error) {
            if (i === maxRetries - 1) {
                throw new Error("Max retries exceeded");
            }
            console.log(`Retry ${i + 1}/${maxRetries}...`);
            await sleep(1000 * Math.pow(2, i)); // Exponential backoff
        }
    }
}

// Acknowledgments
async function sendReliable(message) {
    const messageId = generateId();
    
    while (true) {
        await sendMessage({id: messageId, data: message});
        
        // Wait for acknowledgment
        const ack = await waitForAck(messageId, 5000);
        if (ack) {
            return; // Message delivered!
        }
        
        console.log("No ACK received, retrying...");
    }
}</code></pre>
            </div>
        </div>
        
        <div class="failure-scenario">
            <div class="failure-badge">TIMING FAILURE</div>
            <h4 style="margin-top: 20px;">Timing Failures</h4>
            <p><strong>What happens:</strong> Component responds, but too late (or too early).</p>
            <p><strong>Characteristics:</strong></p>
            <ul>
                <li>Response arrives outside expected time bounds</li>
                <li>Real-time systems are vulnerable</li>
                <li>Can cause cascading failures</li>
            </ul>
            
            <div class="example">
                <h4>Examples:</h4>
                <ul>
                    <li>Database query takes 30 seconds instead of 100ms</li>
                    <li>Network latency spike during live streaming</li>
                    <li>Stock trading system misses execution window</li>
                </ul>
            </div>
        </div>
        
        <div class="failure-scenario">
            <div class="failure-badge">BYZANTINE FAILURE</div>
            <h4 style="margin-top: 20px;">Byzantine Failures (Arbitrary Failures)</h4>
            <p><strong>What happens:</strong> A component behaves arbitrarily - sends wrong data, lies, or acts maliciously.</p>
            <p><strong>Characteristics:</strong></p>
            <ul>
                <li><strong>Most severe:</strong> Component produces incorrect results</li>
                <li><strong>Hard to detect:</strong> Appears to be working normally</li>
                <li><strong>Can be malicious or accidental</strong> (bugs, corruption)</li>
                <li><strong>Named after Byzantine Generals Problem</strong></li>
            </ul>
            
            <div class="architecture-diagram">
                <h4 style="text-align: center; color: #f44336;">Byzantine Node Behavior</h4>
                <div class="attack-demo">
                    <div class="honest-node">Honest Node A<br>Says: "Value = 5"</div>
                    <div class="attacker">Byzantine Node<br>Tells A: "Value = 5"<br>Tells B: "Value = 10" üòà</div>
                    <div class="honest-node">Honest Node B<br>Confused!</div>
                </div>
                <p style="text-align: center; margin-top: 15px; color: #f44336;">The Byzantine node sends different (conflicting) information to different nodes!</p>
            </div>
            
            <div class="example">
                <h4>Examples:</h4>
                <ul>
                    <li><strong>Malicious:</strong> Hacked server sends fake data</li>
                    <li><strong>Accidental:</strong> Bit flip in memory corrupts data</li>
                    <li><strong>Blockchain:</strong> Miner tries to double-spend</li>
                    <li><strong>Sensor:</strong> Faulty temperature sensor reports random values</li>
                </ul>
                
                <h4>Byzantine Generals Problem:</h4>
                <p>Byzantine generals must agree on a battle plan, but some generals may be traitors:</p>
                <div class="architecture-diagram">
                    <div style="margin: 20px 0;">
                        <div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">
                            <div class="honest-node">General 1<br>Vote: Attack</div>
                            <div class="honest-node">General 2<br>Vote: Attack</div>
                            <div class="attacker">Traitor<br>Tells 1: Attack<br>Tells 2: Retreat</div>
                            <div class="honest-node">General 3<br>Vote: Attack</div>
                        </div>
                    </div>
                    <p style="text-align: center; font-weight: bold;">How do honest generals reach consensus despite traitors?</p>
                </div>
                
                <h4>Solution Requirements:</h4>
                <ul>
                    <li>Need <strong>3f + 1</strong> nodes to tolerate <strong>f</strong> Byzantine failures</li>
                    <li>Example: To tolerate 1 Byzantine node, need at least 4 total nodes</li>
                    <li>Use consensus algorithms: PBFT, Tendermint, or Proof-of-Work</li>
                </ul>
                
                <pre><code>// Simplified Byzantine detection
class ByzantineDetector {
    collectVotes(nodes) {
        const votes = {};
        
        // Collect votes from all nodes
        for (const node of nodes) {
            const value = node.getValue();
            votes[value] = (votes[value] || 0) + 1;
        }
        
        // Find majority
        const threshold = Math.floor(nodes.length / 2) + 1;
        for (const [value, count] of Object.entries(votes)) {
            if (count >= threshold) {
                return value; // Majority agrees
            }
        }
        
        return null; // No consensus
    }
}</code></pre>
            </div>
        </div>
        
        <table class="comparison-table">
            <tr>
                <th>Failure Type</th>
                <th>Behavior</th>
                <th>Detection</th>
                <th>Severity</th>
            </tr>
            <tr>
                <td><strong>Crash</strong></td>
                <td>Stops completely</td>
                <td>Easy (no response)</td>
                <td>Low</td>
            </tr>
            <tr>
                <td><strong>Omission</strong></td>
                <td>Drops messages</td>
                <td>Moderate (timeouts)</td>
                <td>Medium</td>
            </tr>
            <tr>
                <td><strong>Timing</strong></td>
                <td>Responds too late</td>
                <td>Moderate (SLO monitoring)</td>
                <td>Medium</td>
            </tr>
            <tr>
                <td><strong>Byzantine</strong></td>
                <td>Arbitrary/malicious</td>
                <td>Very Hard (inconsistencies)</td>
                <td>Very High</td>
            </tr>
        </table>
        
        <h2>4Ô∏è‚É£ Security Models</h2>
        
        <p>Security models describe <strong>threats and protections</strong> in distributed systems.</p>
        
        <div class="definition">
            <h3>Security Concerns in Distributed Systems:</h3>
            <ul>
                <li><strong>Confidentiality:</strong> Keep data secret from unauthorized parties</li>
                <li><strong>Integrity:</strong> Prevent unauthorized modification</li>
                <li><strong>Availability:</strong> Ensure services remain accessible</li>
                <li><strong>Authentication:</strong> Verify identity of users/components</li>
                <li><strong>Authorization:</strong> Control access to resources</li>
                <li><strong>Non-repudiation:</strong> Prove actions were taken</li>
            </ul>
        </div>
        
        <h3>üõ°Ô∏è Security Layers</h3>
        
        <div class="security-layer">
            <div class="security-icon">üîê</div>
            <div>
                <h4>Encryption (Confidentiality)</h4>
                <p>Protects data in transit and at rest using cryptography (TLS/SSL, AES)</p>
                <p><strong>Example:</strong> HTTPS encrypts web traffic so eavesdroppers can't read it</p>
            </div>
        </div>
        
        <div class="security-layer">
            <div class="security-icon">üë§</div>
            <div>
                <h4>Authentication</h4>
                <p>Verify identity using passwords, tokens, certificates, biometrics</p>
                <p><strong>Example:</strong> JWT tokens, OAuth, mutual TLS</p>
            </div>
        </div>
        
        <div class="security-layer">
            <div class="security-icon">‚úÖ</div>
            <div>
                <h4>Authorization (Access Control)</h4>
                <p>Define who can access what resources</p>
                <p><strong>Example:</strong> Role-Based Access Control (RBAC), Access Control Lists (ACL)</p>
            </div>
        </div>
        
        <div class="security-layer">
            <div class="security-icon">üîç</div>
            <div>
                <h4>Integrity Checking</h4>
                <p>Detect tampering using checksums, digital signatures, MACs</p>
                <p><strong>Example:</strong> Hash functions (SHA-256), message authentication codes</p>
            </div>
        </div>
        
        <h3>‚öîÔ∏è Common Attacks</h3>
        
        <div class="model-card">
            <h4>1. Man-in-the-Middle Attack</h4>
            <div class="architecture-diagram">
                <div class="arch-container">
                    <div class="node client">Client</div>
                    <div class="arrow">‚Üí</div>
                    <div class="attacker">üëπ Attacker<br>(Intercepts)</div>
                    <div class="arrow">‚Üí</div>
                    <div class="node server">Server</div>
                </div>
                <p style="text-align: center; margin-top: 15px;">Attacker intercepts and potentially modifies messages</p>
            </div>
            <p><strong>Defense:</strong> TLS/SSL encryption with certificate validation</p>
        </div>
        
        <div class="model-card">
            <h4>2. Denial of Service (DoS)</h4>
            <div class="architecture-diagram">
                <div class="arch-container">
                    <div style="text-align: center;">
                        <div class="attacker" style="margin-bottom: 10px;">üëπ Attacker sends massive traffic</div>
                        <div style="display: flex; gap: 5px; justify-content: center; margin: 10px 0;">
                            <div style="font-size: 2em;">‚ö°‚ö°‚ö°‚ö°‚ö°‚ö°‚ö°</div>
                        </div>
                        <div class="node server" style="background: linear-gradient(135deg, #f44336 0%, #e57373 100%);">Server Overwhelmed</div>
                    </div>
                </div>
            </div>
            <p><strong>Defense:</strong> Rate limiting, load balancers, DDoS protection services (Cloudflare)</p>
        </div>
        
        <div class="model-card">
            <h4>3. Replay Attack</h4>
            <p>Attacker captures valid message and resends it later</p>
            <p><strong>Example:</strong> Capture "transfer $100" and replay it multiple times</p>
            <p><strong>Defense:</strong> Timestamps, nonces, sequence numbers</p>
        </div>
        
        <pre><code>// Security Example: Authentication & Authorization
class SecureSystem {
    constructor() {
        this.users = new Map();
        this.sessions = new Map();
    }
    
    // Authentication: Verify identity
    async login(username, password) {
        const user = this.users.get(username);
        
        // Hash password (never store plaintext!)
        const hashedPassword = await this.hash(password);
        
        if (user && user.password === hashedPassword) {
            // Generate secure session token
            const token = this.generateToken();
            this.sessions.set(token, {
                username,
                role: user.role,
                expiry: Date.now() + 3600000 // 1 hour
            });
            return token;
        }
        
        throw new Error("Invalid credentials");
    }
    
    // Authorization: Check permissions
    hasPermission(token, resource, action) {
        const session = this.sessions.get(token);
        
        if (!session || session.expiry < Date.now()) {
            return false; // Expired or invalid
        }
        
        // Role-based access control
        const permissions = {
            admin: ['read', 'write', 'delete'],
            user: ['read', 'write'],
            guest: ['read']
        };
        
        return permissions[session.role]?.includes(action);
    }
    
    // Example usage
    async accessResource(token, resource, action) {
        if (!this.hasPermission(token, resource, action)) {
            throw new Error("Unauthorized");
        }
        
        // Proceed with action
        return await this.performAction(resource, action);
    }
}</code></pre>
        
        <h2>5Ô∏è‚É£ Timing Models</h2>
        
        <p>Timing models describe <strong>assumptions about time and synchronization</strong> in distributed systems.</p>
        
        <div class="warning">
            <h3>‚è∞ The Time Problem</h3>
            <p>In distributed systems, there's <strong>no global clock</strong>. Each machine has its own clock, and they drift apart!</p>
            <p>This makes reasoning about order of events challenging.</p>
        </div>
        
        <h3>üìç Synchronous Model</h3>
        
        <div class="timing-diagram">
            <div class="key-point">
                <h4>Assumptions:</h4>
                <ul>
                    <li><strong>Bounded processing time:</strong> Process takes at most T time</li>
                    <li><strong>Bounded message delay:</strong> Messages arrive within D time</li>
                    <li><strong>Bounded clock drift:</strong> Clocks drift at most œÅ</li>
                </ul>
                <p><strong>In simple terms:</strong> Everything happens within known time bounds</p>
            </div>
            
            <div class="timeline">
                <div class="timeline-item">
                    <div class="timeline-dot"></div>
                    <div class="timeline-content">
                        <strong>T0:</strong> Send message
                    </div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-dot"></div>
                    <div class="timeline-content" style="background: #e8f5e9; border-left-color: #4caf50;">
                        <strong>T0 + D:</strong> Message guaranteed to arrive by this time ‚úÖ
                    </div>
                </div>
            </div>
        </div>
        
        <div class="example">
            <h4>Characteristics:</h4>
            <ul>
                <li><strong>Predictable:</strong> Can use timeouts reliably</li>
                <li><strong>Easier algorithms:</strong> Timeout = failure detection</li>
                <li><strong>Rare in practice:</strong> Hard to guarantee bounds</li>
            </ul>
            
            <h4>Example Systems:</h4>
            <ul>
                <li>Hard real-time systems (aircraft control, medical devices)</li>
                <li>Synchronous circuits</li>
                <li>Some embedded systems</li>
            </ul>
            
            <pre><code>// Synchronous system assumption
async function callWithTimeout(service, timeout = 1000) {
    const promise = service.call();
    const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error("Timeout")), timeout)
    );
    
    // If it doesn't respond in 1s, we KNOW it failed
    return Promise.race([promise, timeoutPromise]);
}</code></pre>
        </div>
        
        <h3>üåä Asynchronous Model</h3>
        
        <div class="timing-diagram">
            <div class="warning">
                <h4>Assumptions:</h4>
                <ul>
                    <li><strong>No bounds:</strong> Processing can take arbitrarily long</li>
                    <li><strong>No bounds on delays:</strong> Messages can be delayed indefinitely</li>
                    <li><strong>No bounds on clock drift:</strong> Clocks can drift arbitrarily</li>
                </ul>
                <p><strong>In simple terms:</strong> Make NO timing assumptions!</p>
            </div>
            
            <div class="timeline">
                <div class="timeline-item">
                    <div class="timeline-dot"></div>
                    <div class="timeline-content">
                        <strong>T0:</strong> Send message
                    </div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-dot" style="background: #ff9800;"></div>
                    <div class="timeline-content" style="background: #fff3e0; border-left-color: #ff9800;">
                        <strong>T?:</strong> Message arrives... eventually? Maybe never? ü§∑
                    </div>
                </div>
            </div>
        </div>
        
        <div class="example">
            <h4>Characteristics:</h4>
            <ul>
                <li><strong>Most realistic:</strong> Matches real Internet behavior</li>
                <li><strong>Hard algorithms:</strong> Can't distinguish slow from crashed</li>
                <li><strong>Can't use timeouts:</strong> Might just be slow!</li>
                <li><strong>But... impossible to solve some problems!</strong> (e.g., consensus in fully asynchronous model with failures - FLP impossibility)</li>
            </ul>
            
            <h4>Example Systems:</h4>
            <ul>
                <li>Internet applications</li>
                <li>Wide-area networks</li>
                <li>Most distributed systems</li>
            </ul>
            
            <div class="highlight-box">
                <h4>‚ö†Ô∏è The Impossibility Result (FLP)</h4>
                <p><strong>Fischer-Lynch-Paterson theorem:</strong> In a fully asynchronous system with even one faulty process, it's impossible to guarantee consensus!</p>
                <p>This is why we need the partially synchronous model...</p>
            </div>
        </div>
        
        <h3>‚öñÔ∏è Partially Synchronous Model (Reality!)</h3>
        
        <div class="timing-diagram">
            <div class="key-point">
                <h4>Assumptions:</h4>
                <ul>
                    <li><strong>Eventually synchronous:</strong> System behaves asynchronously most of the time, but eventually becomes synchronous</li>
                    <li><strong>Unknown bounds:</strong> Bounds exist but we don't know them</li>
                    <li><strong>Practical:</strong> Matches real-world systems</li>
                </ul>
                <p><strong>In simple terms:</strong> Sometimes slow, sometimes fast, but not permanently broken</p>
            </div>
            
            <div class="timeline">
                <div class="timeline-item">
                    <div class="timeline-dot" style="background: #ff9800;"></div>
                    <div class="timeline-content" style="background: #fff3e0; border-left-color: #ff9800;">
                        <strong>Period 1:</strong> Asynchronous (network issues, delays)
                    </div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-dot" style="background: #4caf50;"></div>
                    <div class="timeline-content" style="background: #e8f5e9; border-left-color: #4caf50;">
                        <strong>Period 2:</strong> Synchronous (stable, predictable)
                    </div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-dot" style="background: #ff9800;"></div>
                    <div class="timeline-content" style="background: #fff3e0; border-left-color: #ff9800;">
                        <strong>Period 3:</strong> Asynchronous again
                    </div>
                </div>
            </div>
        </div>
        
        <div class="example">
            <h4>Characteristics:</h4>
            <ul>
                <li><strong>Realistic:</strong> Best matches actual systems</li>
                <li><strong>Solvable:</strong> Consensus IS possible! (Paxos, Raft work here)</li>
                <li><strong>Design approach:</strong> Make progress when synchronous, stay safe when asynchronous</li>
            </ul>
            
            <h4>Example Systems:</h4>
            <ul>
                <li>Modern cloud systems</li>
                <li>Consensus protocols (Paxos, Raft)</li>
                <li>Blockchain (with eventual finality)</li>
            </ul>
            
            <pre><code>// Partially synchronous: Adaptive timeout
class AdaptiveTimeout {
    constructor() {
        this.timeouts = [];
        this.baseTimeout = 1000;
    }
    
    recordResponse(responseTime) {
        this.timeouts.push(responseTime);
        if (this.timeouts.length > 100) {
            this.timeouts.shift(); // Keep last 100
        }
    }
    
    getTimeout() {
        if (this.timeouts.length === 0) {
            return this.baseTimeout;
        }
        
        // Calculate based on recent history
        const avg = this.average(this.timeouts);
        const stdDev = this.standardDeviation(this.timeouts);
        
        // Timeout = avg + 3 * stdDev (covers ~99.7% of cases)
        return Math.max(this.baseTimeout, avg + 3 * stdDev);
    }
}</code></pre>
        </div>
        
        <table class="comparison-table">
            <tr>
                <th>Model</th>
                <th>Timing Bounds</th>
                <th>Failure Detection</th>
                <th>Consensus</th>
                <th>Reality</th>
            </tr>
            <tr>
                <td><strong>Synchronous</strong></td>
                <td>‚úÖ Known bounds</td>
                <td>‚úÖ Reliable (timeout = failure)</td>
                <td>‚úÖ Easy</td>
                <td>‚ùå Unrealistic</td>
            </tr>
            <tr>
                <td><strong>Asynchronous</strong></td>
                <td>‚ùå No bounds</td>
                <td>‚ùå Impossible</td>
                <td>‚ùå Impossible (FLP)</td>
                <td>‚ö†Ô∏è Too pessimistic</td>
            </tr>
            <tr>
                <td><strong>Partially Synchronous</strong></td>
                <td>‚ö†Ô∏è Unknown/eventual</td>
                <td>‚úÖ Eventually reliable</td>
                <td>‚úÖ Possible</td>
                <td>‚úÖ Realistic!</td>
            </tr>
        </table>
        
        <div class="interactive-demo">
            <h3>üéÆ Interactive: Failure Detection Demo</h3>
            <p>See how different timing models affect failure detection:</p>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="demo-button" onclick="simulateSync()">Synchronous System</button>
                <button class="demo-button" onclick="simulateAsync()">Asynchronous System</button>
                <button class="demo-button" onclick="simulatePartialSync()">Partially Synchronous</button>
            </div>
            <div id="timingDemo" class="demo-output">Click a button to see how failure detection works...</div>
        </div>
        
        <div style="margin-top: 50px; padding: 30px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 12px;">
            <h3>üîë Key Takeaways from Chapter 3</h3>
            <ul style="line-height: 2;">
                <li><strong>Architecture Models:</strong> Client-Server (centralized), P2P (decentralized), Hybrid (best of both)</li>
                <li><strong>Interaction Models:</strong> Sync (blocking, simple) vs Async (non-blocking, efficient)</li>
                <li><strong>Failure Models:</strong> Crash (stops), Omission (drops messages), Byzantine (malicious) - design for each!</li>
                <li><strong>Security:</strong> Encryption, authentication, authorization, integrity - layer your defenses</li>
                <li><strong>Timing Models:</strong> Partially synchronous is realistic - asynchronous usually, synchronous eventually</li>
                <li><strong>Design Principle:</strong> Assume the worst, optimize for the common case</li>
            </ul>
        </div>
        
        <div style="margin-top: 30px; padding: 25px; background: #fff3e0; border-radius: 12px; border-left: 5px solid #ff9800;">
            <h3>üìù Practice Questions</h3>
            <ol style="line-height: 2;">
                <li>Why is P2P more scalable than Client-Server, but Client-Server easier to maintain?</li>
                <li>Give an example where synchronous communication is better than asynchronous</li>
                <li>Why is Byzantine failure the hardest to handle?</li>
                <li>Why do we need 3f+1 nodes to tolerate f Byzantine failures?</li>
                <li>Why can't we solve consensus in a purely asynchronous system with failures?</li>
                <li>Design a system: Would you choose sync or async? Client-server or P2P? Which failure model?</li>
            </ol>
        </div>
    </div>
    
    <script>
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        async function simulateSync() {
            const output = document.getElementById('timingDemo');
            output.textContent = '=== SYNCHRONOUS SYSTEM ===\n';
            output.textContent += 'Timeout bound: 1000ms\n\n';
            
            output.textContent += 'Sending heartbeat to Server A...\n';
            await sleep(300);
            output.textContent += 'Response received in 300ms ‚úÖ\n\n';
            
            output.textContent += 'Sending heartbeat to Server B...\n';
            await sleep(500);
            output.textContent += 'No response after 1000ms ‚è∞\n';
            output.textContent += 'FAILURE DETECTED! Server B is down ‚ùå\n\n';
            
            output.textContent += 'Result: Reliable failure detection!\n';
            output.textContent += 'We know for certain that Server B crashed.';
        }
        
        async function simulateAsync() {
            const output = document.getElementById('timingDemo');
            output.textContent = '=== ASYNCHRONOUS SYSTEM ===\n';
            output.textContent += 'No timeout bounds\n\n';
            
            output.textContent += 'Sending message to Server A...\n';
            await sleep(300);
            output.textContent += 'Response received ‚úÖ\n\n';
            
            output.textContent += 'Sending message to Server B...\n';
            await sleep(500);
            output.textContent += 'No response yet...\n';
            await sleep(500);
            output.textContent += 'Still no response...\n';
            await sleep(500);
            output.textContent += 'Still waiting...\n\n';
            
            output.textContent += 'Problem: Is Server B crashed or just slow? ü§∑\n';
            output.textContent += 'Cannot reliably detect failures!\n';
            output.textContent += 'We must wait indefinitely...';
        }
        
        async function simulatePartialSync() {
            const output = document.getElementById('timingDemo');
            output.textContent = '=== PARTIALLY SYNCHRONOUS SYSTEM ===\n';
            output.textContent += 'Adaptive timeout (adjusts based on history)\n\n';
            
            output.textContent += 'Recent response times: 100ms, 150ms, 200ms\n';
            output.textContent += 'Calculated timeout: 500ms\n\n';
            
            output.textContent += 'Sending message to Server A...\n';
            await sleep(300);
            output.textContent += 'Response in 180ms ‚úÖ (within timeout)\n';
            output.textContent += 'Updated timeout: 450ms\n\n';
            
            output.textContent += 'Network congestion detected!\n';
            await sleep(400);
            output.textContent += 'Recent response times increased: 400ms, 600ms, 800ms\n';
            output.textContent += 'Adjusted timeout: 1500ms\n\n';
            
            output.textContent += 'Sending message to Server B...\n';
            await sleep(500);
            output.textContent += 'No response after 1500ms\n';
            output.textContent += 'LIKELY FAILED ‚ö†Ô∏è\n\n';
            
            output.textContent += 'Result: Eventual reliable detection!\n';
            output.textContent += 'System adapts to network conditions.';
        }
    </script>
</body>
</html>