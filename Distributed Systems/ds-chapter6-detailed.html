<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 6: Consistency Models</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        h1 {
            color: #2c3e50;
            border-bottom: 4px solid #667eea;
            padding-bottom: 15px;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-align: center;
        }
        
        h2 {
            color: #667eea;
            margin-top: 50px;
            margin-bottom: 25px;
            font-size: 2em;
            border-left: 6px solid #764ba2;
            padding-left: 15px;
        }
        
        h3 {
            color: #34495e;
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.5em;
        }
        
        h4 {
            color: #555;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        .definition {
            background: linear-gradient(135deg, #e0f7fa 0%, #b2ebf2 100%);
            border-left: 5px solid #00acc1;
            padding: 25px;
            margin: 25px 0;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .example {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            border-left: 5px solid #ff9800;
            padding: 25px;
            margin: 25px 0;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .key-point {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-left: 5px solid #4caf50;
            padding: 25px;
            margin: 25px 0;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .warning {
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
            border-left: 5px solid #f44336;
            padding: 25px;
            margin: 25px 0;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .problem-box {
            background: linear-gradient(135deg, #fce4ec 0%, #f8bbd0 100%);
            border: 3px solid #e91e63;
            padding: 25px;
            margin: 25px 0;
            border-radius: 10px;
        }
        
        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #667eea;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        code {
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
        }
        
        .timeline-diagram {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 12px;
            margin: 30px 0;
            border: 2px solid #dee2e6;
        }
        
        .operation {
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .op-type {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 5px 15px;
            border-radius: 5px;
            font-weight: bold;
            min-width: 80px;
            text-align: center;
        }
        
        .op-write {
            background: linear-gradient(135deg, #4caf50 0%, #66bb6a 100%);
        }
        
        .op-read {
            background: linear-gradient(135deg, #2196f3 0%, #42a5f5 100%);
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        
        .comparison-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: bold;
        }
        
        .comparison-table td {
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .comparison-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .comparison-table tr:hover {
            background: #e3f2fd;
        }
        
        .visual-example {
            background: white;
            border: 2px solid #667eea;
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
        }
        
        .replica {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 10px;
            min-width: 150px;
            text-align: center;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .data-value {
            background: #fff;
            color: #333;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 1.1em;
        }
        
        .cap-triangle {
            width: 400px;
            height: 400px;
            margin: 30px auto;
            position: relative;
        }
        
        .cap-vertex {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            font-size: 1.1em;
        }
        
        .consistency-vertex {
            background: linear-gradient(135deg, #4caf50 0%, #66bb6a 100%);
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .availability-vertex {
            background: linear-gradient(135deg, #2196f3 0%, #42a5f5 100%);
            bottom: 0;
            left: 0;
        }
        
        .partition-vertex {
            background: linear-gradient(135deg, #ff9800 0%, #ffa726 100%);
            bottom: 0;
            right: 0;
        }
        
        .cap-edge {
            position: absolute;
            background: #ccc;
            height: 3px;
        }
        
        ul {
            margin: 15px 0 15px 30px;
        }
        
        li {
            margin-bottom: 10px;
        }
        
        strong {
            color: #2c3e50;
        }
        
        .interactive-demo {
            background: linear-gradient(135deg, #fce4ec 0%, #f8bbd0 100%);
            padding: 25px;
            border-radius: 12px;
            margin: 30px 0;
            border: 2px solid #e91e63;
        }
        
        .demo-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            margin: 10px 5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .demo-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.3);
        }
        
        .demo-output {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            min-height: 100px;
            font-family: monospace;
            white-space: pre-wrap;
            border: 1px solid #e0e0e0;
        }
        
        .consistency-spectrum {
            background: linear-gradient(to right, #4caf50, #ff9800, #f44336);
            height: 40px;
            border-radius: 20px;
            margin: 30px 0;
            position: relative;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .spectrum-label {
            position: absolute;
            top: -30px;
            font-weight: bold;
            color: white;
            background: #333;
            padding: 5px 15px;
            border-radius: 5px;
            font-size: 0.9em;
        }
        
        .highlight {
            background: linear-gradient(135deg, #fff9c4 0%, #fff59d 100%);
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .anomaly-box {
            background: #ffebee;
            border: 2px solid #f44336;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .guarantee-box {
            background: #e8f5e9;
            border: 2px solid #4caf50;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .scenario {
            background: white;
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 15px 0;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Chapter 6: Consistency Models</h1>
        
        <div class="problem-box">
            <h3>ü§î The Fundamental Trade-off</h3>
            <p style="font-size: 1.2em;"><strong>How consistent should our data be across replicas?</strong></p>
            <p>When data is replicated across multiple servers (for availability and performance), replicas may temporarily have different values. <strong>Consistency models</strong> define what guarantees the system provides about the values read from replicas.</p>
            <p><strong>The spectrum:</strong> Stronger consistency = slower but correct. Weaker consistency = faster but may see stale data.</p>
        </div>
        
        <div class="consistency-spectrum">
            <span class="spectrum-label" style="left: 5%;">Strong<br>(Slow, Correct)</span>
            <span class="spectrum-label" style="left: 45%;">Middle Ground</span>
            <span class="spectrum-label" style="right: 5%;">Weak<br>(Fast, Eventually Correct)</span>
        </div>
        
        <h2>1Ô∏è‚É£ Strong Consistency (Linearizability)</h2>
        
        <div class="definition">
            <h4>What is Strong Consistency?</h4>
            <p><strong>Also called Linearizability</strong> - the strongest consistency model.</p>
            <p><strong>Guarantee:</strong> Every read returns the most recent write. The system behaves as if there's <strong>only one copy</strong> of the data, even though it's replicated.</p>
            <p><strong>In other words:</strong> Operations appear to happen instantaneously at some point between their invocation and response.</p>
        </div>
        
        <div class="visual-example">
            <h4>Timeline: Strong Consistency</h4>
            <div class="timeline-diagram">
                <div style="text-align: center; margin-bottom: 20px;">
                    <div class="replica">Replica A</div>
                    <div class="replica">Replica B</div>
                    <div class="replica">Replica C</div>
                </div>
                
                <div class="operation">
                    <div class="op-type op-write">WRITE</div>
                    <div style="flex: 1;">Client 1 writes X = 5</div>
                    <div style="color: #4caf50; font-weight: bold;">‚úì Success</div>
                </div>
                
                <div style="text-align: center; margin: 20px 0; color: #667eea; font-weight: bold;">
                    ‚Üì ALL replicas updated BEFORE write completes ‚Üì
                </div>
                
                <div style="text-align: center; margin-bottom: 20px;">
                    <div class="replica">Replica A<div class="data-value">X = 5</div></div>
                    <div class="replica">Replica B<div class="data-value">X = 5</div></div>
                    <div class="replica">Replica C<div class="data-value">X = 5</div></div>
                </div>
                
                <div class="operation">
                    <div class="op-type op-read">READ</div>
                    <div style="flex: 1;">Client 2 reads X from any replica</div>
                    <div style="color: #2196f3; font-weight: bold;">Returns: 5 ‚úì</div>
                </div>
                
                <div style="background: #e8f5e9; padding: 15px; border-radius: 8px; margin-top: 20px;">
                    <strong>‚úÖ Guarantee:</strong> Any read after write completion sees the new value, regardless of which replica it reads from!
                </div>
            </div>
        </div>
        
        <div class="example">
            <h4>üè¶ Real-World Example: Bank Account</h4>
            <div class="scenario">
                <strong>Scenario:</strong> You deposit $100 at ATM 1
                <ol style="margin-left: 20px; margin-top: 10px;">
                    <li>ATM 1 writes: Balance = $1100 (was $1000)</li>
                    <li>Write is replicated to ALL bank servers</li>
                    <li>Write completes (you get receipt)</li>
                    <li>Immediately check balance at ATM 2</li>
                    <li>ATM 2 reads from ANY server ‚Üí Shows $1100 ‚úì</li>
                </ol>
                <div style="background: #e8f5e9; padding: 10px; border-radius: 5px; margin-top: 10px;">
                    <strong>Why it matters:</strong> You'd be very unhappy if ATM 2 showed $1000! Banking REQUIRES strong consistency.
                </div>
            </div>
        </div>
        
        <pre><code>// Strong Consistency Implementation (Simplified)
class StronglyConsistentStore {
    constructor(replicas) {
        this.replicas = replicas;
        this.lock = new Lock();
    }
    
    async write(key, value) {
        // Lock to ensure linearizability
        await this.lock.acquire();
        
        try {
            // Write to ALL replicas synchronously
            const promises = this.replicas.map(replica => 
                replica.write(key, value)
            );
            
            // Wait for ALL replicas to acknowledge
            await Promise.all(promises);
            
            console.log('Write completed - all replicas updated');
            return true;
            
        } finally {
            await this.lock.release();
        }
    }
    
    async read(key) {
        // Read from any replica (they're all consistent)
        const replica = this.replicas[0];
        const value = await replica.read(key);
        return value;
    }
}

// Usage
const store = new StronglyConsistentStore([replica1, replica2, replica3]);

await store.write('balance', 1100);
// At this point, ALL replicas have balance = 1100

const balance = await store.read('balance');
console.log(balance); // Always 1100, from any replica</code></pre>
        
        <div class="key-point">
            <h4>‚úÖ Advantages:</h4>
            <ul>
                <li>Easiest to reason about - behaves like single machine</li>
                <li>No anomalies or surprises</li>
                <li>Perfect for critical data (financial transactions, inventory)</li>
            </ul>
        </div>
        
        <div class="warning">
            <h4>‚ùå Disadvantages:</h4>
            <ul>
                <li><strong>Slow:</strong> Must wait for all replicas before write completes</li>
                <li><strong>Lower availability:</strong> If one replica is down, writes fail</li>
                <li><strong>Doesn't scale well:</strong> More replicas = slower writes</li>
                <li><strong>High latency:</strong> Especially in geo-distributed systems</li>
            </ul>
        </div>
        
        <h2>2Ô∏è‚É£ Eventual Consistency</h2>
        
        <div class="definition">
            <h4>What is Eventual Consistency?</h4>
            <p><strong>Weakest consistency model</strong> commonly used.</p>
            <p><strong>Guarantee:</strong> If no new updates are made, <strong>eventually</strong> all replicas will converge to the same value.</p>
            <p><strong>In other words:</strong> Replicas may be inconsistent for a while, but will become consistent given enough time.</p>
        </div>
        
        <div class="visual-example">
            <h4>Timeline: Eventual Consistency</h4>
            <div class="timeline-diagram">
                <div style="text-align: center; margin-bottom: 20px;">
                    <div class="replica">Replica A<div class="data-value">X = 1</div></div>
                    <div class="replica">Replica B<div class="data-value">X = 1</div></div>
                    <div class="replica">Replica C<div class="data-value">X = 1</div></div>
                </div>
                
                <div class="operation">
                    <div class="op-type op-write">WRITE</div>
                    <div style="flex: 1;">Client 1 writes X = 5 to Replica A</div>
                    <div style="color: #4caf50; font-weight: bold;">‚úì Success (immediate!)</div>
                </div>
                
                <div style="text-align: center; margin: 20px 0;">
                    <div class="replica">Replica A<div class="data-value">X = 5 ‚úì</div></div>
                    <div class="replica">Replica B<div class="data-value" style="background: #ffebee;">X = 1 ‚è≥</div></div>
                    <div class="replica">Replica C<div class="data-value" style="background: #ffebee;">X = 1 ‚è≥</div></div>
                </div>
                
                <div class="operation">
                    <div class="op-type op-read">READ</div>
                    <div style="flex: 1;">Client 2 reads X from Replica B</div>
                    <div style="color: #ff9800; font-weight: bold;">Returns: 1 (stale!)</div>
                </div>
                
                <div style="text-align: center; margin: 20px 0; color: #667eea; font-weight: bold;">
                    ‚è∞ Time passes... replication happens in background...
                </div>
                
                <div style="text-align: center; margin: 20px 0;">
                    <div class="replica">Replica A<div class="data-value">X = 5</div></div>
                    <div class="replica">Replica B<div class="data-value">X = 5</div></div>
                    <div class="replica">Replica C<div class="data-value">X = 5</div></div>
                </div>
                
                <div class="operation">
                    <div class="op-type op-read">READ</div>
                    <div style="flex: 1;">Client 2 reads X from Replica B</div>
                    <div style="color: #4caf50; font-weight: bold;">Returns: 5 ‚úì</div>
                </div>
                
                <div style="background: #fff3e0; padding: 15px; border-radius: 8px; margin-top: 20px;">
                    <strong>‚ö†Ô∏è Note:</strong> Reads may see stale data, but eventually all replicas converge!
                </div>
            </div>
        </div>
        
        <div class="example">
            <h4>üì± Real-World Example: Social Media Posts</h4>
            <div class="scenario">
                <strong>Scenario:</strong> You post "Hello World!" on Twitter
                <ol style="margin-left: 20px; margin-top: 10px;">
                    <li>Post is saved to nearest server (US West)</li>
                    <li>You see your post immediately ‚úì</li>
                    <li>Friend in Europe reads timeline ‚Üí Doesn't see your post yet ‚è≥</li>
                    <li>Background replication happens (takes 100ms)</li>
                    <li>Friend refreshes ‚Üí Now sees your post ‚úì</li>
                </ol>
                <div style="background: #e8f5e9; padding: 10px; border-radius: 5px; margin-top: 10px;">
                    <strong>Why it's acceptable:</strong> Seeing posts 100ms late doesn't matter. Speed and availability are more important!
                </div>
            </div>
        </div>
        
        <pre><code>// Eventual Consistency Implementation
class EventuallyConsistentStore {
    constructor(replicas) {
        this.replicas = replicas;
        this.replicationQueue = [];
        this.startReplication();
    }
    
    async write(key, value) {
        // Write to ONE replica (fast!)
        const primaryReplica = this.replicas[0];
        await primaryReplica.write(key, value);
        
        console.log('Write completed on primary');
        
        // Queue replication to other replicas (async)
        this.replicationQueue.push({ key, value });
        
        return true; // Return immediately!
    }
    
    async read(key) {
        // Read from any replica (might be stale!)
        const randomReplica = this.replicas[
            Math.floor(Math.random() * this.replicas.length)
        ];
        return await randomReplica.read(key);
    }
    
    startReplication() {
        // Background process replicates asynchronously
        setInterval(async () => {
            while (this.replicationQueue.length > 0) {
                const { key, value } = this.replicationQueue.shift();
                
                // Replicate to all other replicas
                const promises = this.replicas.slice(1).map(replica =>
                    replica.write(key, value).catch(err => {
                        console.error('Replication failed:', err);
                        // Will retry later
                    })
                );
                
                await Promise.allSettled(promises);
                console.log('Replication completed for', key);
            }
        }, 100); // Replicate every 100ms
    }
}

// Usage
const store = new EventuallyConsistentStore([replica1, replica2, replica3]);

await store.write('post', 'Hello World!');
// Returns immediately, before replication

// Might see old value!
const post1 = await store.read('post'); 

// Wait a bit...
await sleep(200);

// Now all replicas have new value
const post2 = await store.read('post'); // "Hello World!"</code></pre>
        
        <div class="key-point">
            <h4>‚úÖ Advantages:</h4>
            <ul>
                <li><strong>Fast writes:</strong> Return immediately, no waiting</li>
                <li><strong>High availability:</strong> Works even if replicas are down</li>
                <li><strong>Scales well:</strong> Can add replicas without slowing writes</li>
                <li><strong>Low latency:</strong> Especially important for global systems</li>
            </ul>
        </div>
        
        <div class="warning">
            <h4>‚ùå Disadvantages:</h4>
            <ul>
                <li>May read stale data</li>
                <li>Hard to reason about - different users see different values</li>
                <li>Requires conflict resolution (what if two replicas have different values?)</li>
                <li>Not suitable for critical data</li>
            </ul>
        </div>
        
        <h3>üîÑ Common Eventual Consistency Anomalies</h3>
        
        <div class="anomaly-box">
            <h4>Anomaly 1: Stale Reads</h4>
            <p>Reading old value that has been overwritten</p>
            <pre style="background: #fff; color: #333; border-left-color: #f44336;"><code>Write: X = 5
Immediate Read: X = 1 (stale!)
Later Read: X = 5 (updated)</code></pre>
        </div>
        
        <div class="anomaly-box">
            <h4>Anomaly 2: Moving Backwards in Time</h4>
            <p>Reading newer value, then older value</p>
            <pre style="background: #fff; color: #333; border-left-color: #f44336;"><code>Read from Replica A: X = 5
Read from Replica B: X = 3 (went backwards!)</code></pre>
        </div>
        
        <div class="anomaly-box">
            <h4>Anomaly 3: Lost Updates</h4>
            <p>Concurrent updates may overwrite each other</p>
            <pre style="background: #fff; color: #333; border-left-color: #f44336;"><code>Alice writes: X = 5 (to Replica A)
Bob writes: X = 10 (to Replica B)
Result: Depends on which update wins!</code></pre>
        </div>
        
        <h2>3Ô∏è‚É£ Causal Consistency</h2>
        
        <div class="definition">
            <h4>What is Causal Consistency?</h4>
            <p><strong>Guarantee:</strong> Operations that are <span class="highlight">causally related</span> must be seen in the same order by all processes. Concurrent operations may be seen in different orders.</p>
            <p><strong>Uses:</strong> Vector clocks (Chapter 4!) to track causality</p>
            <p><strong>Stronger than:</strong> Eventual consistency<br><strong>Weaker than:</strong> Sequential consistency</p>
        </div>
        
        <div class="example">
            <h4>üí¨ Real-World Example: Comment Thread</h4>
            <div class="visual-example">
                <div style="background: #e3f2fd; padding: 20px; border-radius: 8px; margin: 10px 0;">
                    <strong>Causal Order (Must be preserved):</strong>
                    <div style="margin: 15px 0;">
                        <div style="background: white; padding: 10px; margin: 5px 0; border-radius: 5px;">
                            Alice: "What's the capital of France?" (A)
                        </div>
                        <div style="background: white; padding: 10px; margin: 5px 0; border-radius: 5px;">
                            ‚Üì <em>causes</em> ‚Üì
                        </div>
                        <div style="background: white; padding: 10px; margin: 5px 0; border-radius: 5px;">
                            Bob: "It's Paris!" (B) - <em>Reply to A</em>
                        </div>
                    </div>
                    <strong>‚úÖ Everyone must see A before B</strong> (B causally depends on A)
                </div>
                
                <div style="background: #fff3e0; padding: 20px; border-radius: 8px; margin: 10px 0;">
                    <strong>Concurrent Operations (Order doesn't matter):</strong>
                    <div style="margin: 15px 0;">
                        <div style="background: white; padding: 10px; margin: 5px 0; border-radius: 5px;">
                            Charlie: "Nice weather today!" (C)
                        </div>
                        <div style="background: white; padding: 10px; margin: 5px 0; border-radius: 5px;">
                            ‚ö° <em>concurrent with</em> ‚ö°
                        </div>
                        <div style="background: white; padding: 10px; margin: 5px 0; border-radius: 5px;">
                            David: "I love pizza!" (D)
                        </div>
                    </div>
                    <strong>‚ö†Ô∏è Different users may see C‚ÜíD or D‚ÜíC</strong> (they're independent)
                </div>
                
                <div style="background: #ffebee; padding: 15px; border-radius: 8px; margin-top: 15px;">
                    <strong>‚ùå Violation:</strong> Seeing Bob's "It's Paris!" before Alice's question would be confusing!
                </div>
                
                <div style="background: #e8f5e9; padding: 15px; border-radius: 8px; margin-top: 15px;">
                    <strong>‚úÖ Allowed:</strong> Different people seeing Charlie and David's comments in different orders is fine (they're unrelated)
                </div>
            </div>
        </div>
        
        <pre><code>// Causal Consistency Implementation (using Vector Clocks)
class CausallyConsistentStore {
    constructor(processId, numProcesses) {
        this.processId = processId;
        this.vectorClock = new Array(numProcesses).fill(0);
        this.data = {};
        this.buffer = []; // Buffer for out-of-order writes
    }
    
    write(key, value) {
        // Increment own clock
        this.vectorClock[this.processId]++;
        
        const operation = {
            type: 'write',
            key,
            value,
            vectorClock: [...this.vectorClock]
        };
        
        console.log(`Write ${key}=${value} with VC ${this.vectorClock}`);
        
        // Apply locally
        this.data[key] = value;
        
        // Broadcast to other replicas
        this.broadcast(operation);
        
        return operation;
    }
    
    receiveWrite(operation) {
        // Check if we can apply this write
        if (this.canApply(operation)) {
            this.applyWrite(operation);
            this.checkBuffer(); // Try to apply buffered operations
        } else {
            // Buffer until causal dependencies are satisfied
            console.log('Buffering operation - waiting for dependencies');
            this.buffer.push(operation);
        }
    }
    
    canApply(operation) {
        const opVC = operation.vectorClock;
        const senderId = this.getSenderId(operation);
        
        // Check if all causal dependencies are satisfied
        for (let i = 0; i < this.vectorClock.length; i++) {
            if (i === senderId) {
                // Sender's clock should be exactly one more
                if (opVC[i] !== this.vectorClock[i] + 1) {
                    return false;
                }
            } else {
                // Other clocks should not be ahead
                if (opVC[i] > this.vectorClock[i]) {
                    return false;
                }
            }
        }
        return true;
    }
    
    applyWrite(operation) {
        // Update data
        this.data[operation.key] = operation.value;
        
        // Update vector clock
        for (let i = 0; i < this.vectorClock.length; i++) {
            this.vectorClock[i] = Math.max(
                this.vectorClock[i],
                operation.vectorClock[i]
            );
        }
        
        console.log(`Applied write: ${operation.key}=${operation.value}`);
    }
    
    checkBuffer() {
        let applied = true;
        while (applied) {
            applied = false;
            for (let i = 0; i < this.buffer.length; i++) {
                if (this.canApply(this.buffer[i])) {
                    const op = this.buffer.splice(i, 1)[0];
                    this.applyWrite(op);
                    applied = true;
                    break;
                }
            }
        }
    }
    
    read(key) {
        return this.data[key];
    }
}

// Usage
const replica1 = new CausallyConsistentStore(0, 3);
const replica2 = new CausallyConsistentStore(1, 3);

// Alice posts question
replica1.write('post1', 'What is the capital of France?');

// Bob replies (causally depends on Alice's post)
replica2.write('post2', 'It\'s Paris!');

// Replicas ensure Bob's reply is never seen before Alice's question!</code></pre>
        
        <div class="key-point">
            <h4>‚úÖ Advantages:</h4>
            <ul>
                <li>Preserves causality - no confusing orderings</li>
                <li>More flexible than strong consistency</li>
                <li>Good for collaborative applications</li>
            </ul>
        </div>
        
        <div class="warning">
            <h4>‚ùå Disadvantages:</h4>
            <ul>
                <li>More complex than eventual consistency</li>
                <li>Requires tracking vector clocks (overhead)</li>
                <li>May need to buffer operations</li>
            </ul>
        </div>
        
        <h2>4Ô∏è‚É£ Sequential Consistency</h2>
        
        <div class="definition">
            <h4>What is Sequential Consistency?</h4>
            <p><strong>Guarantee:</strong> All operations appear to execute in some sequential order, and operations from each process appear in program order.</p>
            <p><strong>In other words:</strong> There exists a total ordering of all operations consistent with each process's program order.</p>
            <p><strong>Difference from Linearizability:</strong> Doesn't require real-time ordering - operations can be reordered as long as per-process order is preserved.</p>
        </div>
        
        <div class="example">
            <h4>üìñ Example: Sequential Consistency</h4>
            
            <div class="visual-example">
                <strong>Program Execution:</strong>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                    <div>
                        <strong>Process P1:</strong>
                        <div style="background: #e3f2fd; padding: 10px; margin: 5px 0; border-radius: 5px;">
                            1. Write X = 1
                        </div>
                        <div style="background: #e3f2fd; padding: 10px; margin: 5px 0; border-radius: 5px;">
                            2. Write Y = 2
                        </div>
                    </div>
                    
                    <div>
                        <strong>Process P2:</strong>
                        <div style="background: #fff3e0; padding: 10px; margin: 5px 0; border-radius: 5px;">
                            1. Read Y
                        </div>
                        <div style="background: #fff3e0; padding: 10px; margin: 5px 0; border-radius: 5px;">
                            2. Read X
                        </div>
                    </div>
                </div>
                
                <div style="background: #e8f5e9; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <strong>‚úÖ Valid Sequential Execution:</strong>
                    <ol style="margin-left: 20px; margin-top: 10px;">
                        <li>P1: Write X = 1</li>
                        <li>P1: Write Y = 2</li>
                        <li>P2: Read Y ‚Üí 2</li>
                        <li>P2: Read X ‚Üí 1</li>
                    </ol>
                    <p style="margin-top: 10px;">All operations in one sequence, program order preserved!</p>
                </div>
                
                <div style="background: #e8f5e9; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <strong>‚úÖ Another Valid Sequential Execution:</strong>
                    <ol style="margin-left: 20px; margin-top: 10px;">
                        <li>P2: Read Y ‚Üí 0 (initial value)</li>
                        <li>P1: Write X = 1</li>
                        <li>P1: Write Y = 2</li>
                        <li>P2: Read X ‚Üí 1</li>
                    </ol>
                    <p style="margin-top: 10px;">Different interleaving, but program order still preserved!</p>
                </div>
                
                <div style="background: #ffebee; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <strong>‚ùå Invalid:</strong>
                    <ol style="margin-left: 20px; margin-top: 10px;">
                        <li>P2: Read Y ‚Üí 2</li>
                        <li>P2: Read X ‚Üí 0</li>
                    </ol>
                    <p style="margin-top: 10px;">If Y=2 was seen, X=1 must also be visible! (P1's program order violated)</p>
                </div>
            </div>
        </div>
        
        <div class="key-point">
            <h4>Key Property:</h4>
            <p>Sequential consistency allows reordering operations from <strong>different</strong> processes, but not from the <strong>same</strong> process.</p>
        </div>
        
        <h2>5Ô∏è‚É£ Linearizability (Deep Dive)</h2>
        
        <div class="definition">
            <h4>Linearizability = Strong Consistency + Real-Time Ordering</h4>
            <p><strong>Additional constraint:</strong> If operation A completes before operation B starts (in real time), then A must appear before B in the sequential order.</p>
        </div>
        
        <div class="example">
            <h4>‚è∞ Linearizability vs Sequential Consistency</h4>
            
            <div class="visual-example">
                <strong>Timeline:</strong>
                <div style="margin: 20px 0;">
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0;">
                        <strong>P1:</strong> [Write X=1 starts] ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî [Write X=1 completes]
                    </div>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0;">
                        <strong>P2:</strong> ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî [Read X starts] ‚Äî [Read X completes]
                    </div>
                </div>
                
                <div style="background: #e8f5e9; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <strong>Linearizability:</strong><br>
                    P2's Read X <strong>MUST</strong> return 1<br>
                    (Because Write completed before Read started in real time)
                </div>
                
                <div style="background: #fff3e0; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <strong>Sequential Consistency:</strong><br>
                    P2's Read X <strong>MAY</strong> return 0 or 1<br>
                    (Real-time ordering not required, only per-process order)
                </div>
            </div>
        </div>
        
        <h2>6Ô∏è‚É£ Read Your Writes Consistency</h2>
        
        <div class="definition">
            <h4>What is Read Your Writes Consistency?</h4>
            <p><strong>Guarantee:</strong> After a process writes a value, any subsequent reads by <strong>that same process</strong> will see the written value or a newer one.</p>
            <p><strong>Session guarantee:</strong> Often implemented per user session</p>
        </div>
        
        <div class="example">
            <h4>‚úçÔ∏è Real-World Example: Editing Your Profile</h4>
            
            <div class="scenario">
                <strong>Without Read Your Writes:</strong>
                <ol style="margin-left: 20px; margin-top: 10px;">
                    <li>You update your profile picture</li>
                    <li>Server writes to Replica A</li>
                    <li>You refresh page, browser reads from Replica B</li>
                    <li>You see your OLD profile picture! üò±</li>
                </ol>
                <div style="background: #ffebee; padding: 10px; border-radius: 5px; margin-top: 10px;">
                    <strong>Problem:</strong> Very confusing! "Did my update work?"
                </div>
            </div>
            
            <div class="scenario" style="margin-top: 20px;">
                <strong>With Read Your Writes:</strong>
                <ol style="margin-left: 20px; margin-top: 10px;">
                    <li>You update your profile picture</li>
                    <li>Server writes to Replica A</li>
                    <li>System remembers: "This user wrote to Replica A"</li>
                    <li>You refresh page ‚Üí System reads from Replica A</li>
                    <li>You see your NEW profile picture! ‚úì</li>
                </ol>
                <div style="background: #e8f5e9; padding: 10px; border-radius: 5px; margin-top: 10px;">
                    <strong>Solution:</strong> Route user's reads to replica with their writes!
                </div>
            </div>
        </div>
        
        <pre><code>// Read Your Writes Implementation
class ReadYourWritesStore {
    constructor(replicas) {
        this.replicas = replicas;
        this.userSessions = new Map(); // Track where each user wrote
    }
    
    async write(userId, key, value) {
        // Choose a replica (e.g., based on load)
        const replica = this.selectReplica();
        
        await replica.write(key, value);
        
        // Remember which replica this user wrote to
        if (!this.userSessions.has(userId)) {
            this.userSessions.set(userId, new Set());
        }
        this.userSessions.get(userId).add(replica.id);
        
        console.log(`User ${userId} wrote to replica ${replica.id}`);
    }
    
    async read(userId, key) {
        // Check if user has written recently
        const userReplicas = this.userSessions.get(userId);
        
        if (userReplicas && userReplicas.size > 0) {
            // Read from a replica that has user's writes
            const replicaId = Array.from(userReplicas)[0];
            const replica = this.replicas.find(r => r.id === replicaId);
            
            console.log(`User ${userId} reading from replica ${replicaId} (has their writes)`);
            return await replica.read(key);
        } else {
            // User hasn't written, can read from any replica
            const replica = this.replicas[0];
            return await replica.read(key);
        }
    }
}

// Usage
const store = new ReadYourWritesStore([replica1, replica2, replica3]);

// Alice updates profile
await store.write('alice', 'profile_pic', 'new_photo.jpg');

// Alice reads back immediately
const pic = await store.read('alice', 'profile_pic');
console.log(pic); // Always "new_photo.jpg" ‚úì

// Bob reads (different user)
const bobView = await store.read('bob', 'profile_pic');
// Might see old value (that's okay, different user)</code></pre>
        
        <h2>7Ô∏è‚É£ Monotonic Reads and Writes</h2>
        
        <div class="definition">
            <h4>Monotonic Reads</h4>
            <p><strong>Guarantee:</strong> If a process reads value X, any subsequent reads by that process will return X or a newer value (never an older value).</p>
            <p><strong>In other words:</strong> Time doesn't go backwards for a user</p>
        </div>
        
        <div class="example">
            <h4>üìñ Example: Reading Comments</h4>
            
            <div class="scenario">
                <strong>Without Monotonic Reads:</strong>
                <ol style="margin-left: 20px; margin-top: 10px;">
                    <li>You read comments: "Comment A", "Comment B", "Comment C"</li>
                    <li>Next read from different replica</li>
                    <li>You see: "Comment A", "Comment B" (C disappeared!) üòï</li>
                </ol>
                <div style="background: #ffebee; padding: 10px; border-radius: 5px; margin-top: 10px;">
                    <strong>Problem:</strong> Comments appearing and disappearing is confusing!
                </div>
            </div>
            
            <div class="scenario" style="margin-top: 20px;">
                <strong>With Monotonic Reads:</strong>
                <ol style="margin-left: 20px; margin-top: 10px;">
                    <li>You read: "Comment A", "Comment B", "Comment C"</li>
                    <li>System tracks: "User has seen up to version 3"</li>
                    <li>Next read waits until replica has version ‚â• 3</li>
                    <li>You see: "Comment A", "Comment B", "Comment C", "Comment D" ‚úì</li>
                </ol>
                <div style="background: #e8f5e9; padding: 10px; border-radius: 5px; margin-top: 10px;">
                    <strong>Solution:</strong> Never show older data than previously seen!
                </div>
            </div>
        </div>
        
        <div class="definition" style="margin-top: 40px;">
            <h4>Monotonic Writes</h4>
            <p><strong>Guarantee:</strong> If a process writes value X then writes value Y, all processes see these writes in order (X before Y).</p>
            <p><strong>In other words:</strong> Writes from same process are never reordered</p>
        </div>
        
        <div class="example">
            <h4>üìù Example: Editing Document</h4>
            
            <div class="scenario">
                <strong>Without Monotonic Writes:</strong>
                <ol style="margin-left: 20px; margin-top: 10px;">
                    <li>You type: "Hello " (Write 1 ‚Üí Replica A)</li>
                    <li>You type: "World!" (Write 2 ‚Üí Replica B)</li>
                    <li>Replica C receives: Write 2, then Write 1</li>
                    <li>Result: "World!Hello " üò±</li>
                </ol>
                <div style="background: #ffebee; padding: 10px; border-radius: 5px; margin-top: 10px;">
                    <strong>Problem:</strong> Your edits applied in wrong order!
                </div>
            </div>
            
            <div class="scenario" style="margin-top: 20px;">
                <strong>With Monotonic Writes:</strong>
                <ol style="margin-left: 20px; margin-top: 10px;">
                    <li>You type: "Hello " (Write 1, sequence #1)</li>
                    <li>You type: "World!" (Write 2, sequence #2)</li>
                    <li>Replica C receives Write 2 first</li>
                    <li>But waits for Write 1 before applying Write 2</li>
                    <li>Result: "Hello World!" ‚úì</li>
                </ol>
                <div style="background: #e8f5e9; padding: 10px; border-radius: 5px; margin-top: 10px;">
                    <strong>Solution:</strong> Enforce write ordering per user!
                </div>
            </div>
        </div>
        
        <h2>8Ô∏è‚É£ CAP Theorem</h2>
        
        <div class="definition">
            <h4>The CAP Theorem (Brewer's Theorem)</h4>
            <p style="font-size: 1.2em; color: #e91e63; font-weight: bold;">
                "In the presence of a network partition, you must choose between Consistency and Availability."
            </p>
            <p><strong>Three properties:</strong></p>
            <ul style="margin-top: 10px;">
                <li><strong>Consistency (C):</strong> All nodes see the same data at the same time</li>
                <li><strong>Availability (A):</strong> Every request receives a response (success or failure)</li>
                <li><strong>Partition Tolerance (P):</strong> System continues operating despite network failures</li>
            </ul>
            <p style="margin-top: 15px;"><strong>The theorem:</strong> You can have at most <span class="highlight">TWO</span> of these three properties!</p>
        </div>
        
        <div class="visual-example">
            <h4>CAP Triangle</h4>
            <svg width="500" height="450" style="display: block; margin: 30px auto;">
                <!-- Triangle edges -->
                <line x1="250" y1="50" x2="100" y2="350" stroke="#ccc" stroke-width="3"/>
                <line x1="250" y1="50" x2="400" y2="350" stroke="#ccc" stroke-width="3"/>
                <line x1="100" y1="350" x2="400" y2="350" stroke="#ccc" stroke-width="3"/>
                
                <!-- Vertices -->
                <circle cx="250" cy="50" r="60" fill="#4caf50" opacity="0.9"/>
                <text x="250" y="45" text-anchor="middle" fill="white" font-weight="bold" font-size="20">C</text>
                <text x="250" y="65" text-anchor="middle" fill="white" font-size="14">Consistency</text>
                
                <circle cx="100" cy="350" r="60" fill="#2196f3" opacity="0.9"/>
                <text x="100" y="345" text-anchor="middle" fill="white" font-weight="bold" font-size="20">A</text>
                <text x="100" y="365" text-anchor="middle" fill="white" font-size="14">Availability</text>
                
                <circle cx="400" cy="350" r="60" fill="#ff9800" opacity="0.9"/>
                <text x="400" y="345" text-anchor="middle" fill="white" font-weight="bold" font-size="20">P</text>
                <text x="400" y="365" text-anchor="middle" fill="white" font-size="14">Partition Tol.</text>
                
                <!-- Labels on edges -->
                <text x="170" y="180" fill="#333" font-weight="bold" font-size="16">CP</text>
                <text x="160" y="200" fill="#666" font-size="13">(Consistent + Partition)</text>
                <text x="160" y="215" fill="#666" font-size="12">Examples: MongoDB, HBase</text>
                
                <text x="315" y="180" fill="#333" font-weight="bold" font-size="16">AP</text>
                <text x="305" y="200" fill="#666" font-size="13">(Available + Partition)</text>
                <text x="305" y="215" fill="#666" font-size="12">Examples: Cassandra, DynamoDB</text>
                
                <text x="210" y="390" fill="#333" font-weight="bold" font-size="16">CA</text>
                <text x="165" y="410" fill="#666" font-size="13">(Consistent + Available)</text>
                <text x="170" y="425" fill="#666" font-size="12">Examples: RDBMS (no partitions!)</text>
            </svg>
        </div>
        
        <div class="problem-box">
            <h3>ü§î Why Can't We Have All Three?</h3>
            <p><strong>Network partitions happen!</strong> When they do, you must choose:</p>
        </div>
        
        <div class="example">
            <h4>üåê Scenario: Network Partition</h4>
            
            <div class="visual-example">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                    <div style="text-align: center;">
                        <div class="replica">Node A<div class="data-value">X = 1</div></div>
                        <div style="margin: 10px 0;">üì± Client 1</div>
                    </div>
                    <div style="text-align: center;">
                        <div class="replica">Node B<div class="data-value">X = 1</div></div>
                        <div style="margin: 10px 0;">üì± Client 2</div>
                    </div>
                </div>
                
                <div style="text-align: center; margin: 20px 0; padding: 15px; background: #ffebee; border-radius: 8px; font-weight: bold; color: #f44336;">
                    ‚ö° NETWORK PARTITION! ‚ö°<br>
                    Nodes A and B cannot communicate
                </div>
                
                <div style="margin: 20px 0;">
                    <strong>Client 1 writes X = 5 to Node A</strong><br>
                    <strong>Client 2 writes X = 10 to Node B</strong>
                </div>
                
                <div style="background: #fff3e0; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <strong>Choice 1: Prioritize Consistency (CP)</strong>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li>Node A: "I can't confirm with Node B, so I'll reject the write" ‚ùå</li>
                        <li>Node B: "I can't confirm with Node A, so I'll reject the write" ‚ùå</li>
                        <li><strong>Result:</strong> System unavailable, but consistent</li>
                        <li><strong>Examples:</strong> MongoDB, HBase, traditional SQL databases</li>
                    </ul>
                </div>
                
                <div style="background: #e3f2fd; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <strong>Choice 2: Prioritize Availability (AP)</strong>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li>Node A: "I'll accept X = 5" ‚úì</li>
                        <li>Node B: "I'll accept X = 10" ‚úì</li>
                        <li><strong>Result:</strong> System available, but inconsistent!</li>
                        <li>When partition heals, must resolve conflict (X = 5 or 10?)</li>
                        <li><strong>Examples:</strong> Cassandra, DynamoDB, Riak</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="warning">
            <h4>‚ö†Ô∏è Important Clarifications:</h4>
            <ul>
                <li><strong>Partition Tolerance is NOT optional:</strong> Network failures happen in real world, so P is required</li>
                <li><strong>Real choice is C vs A:</strong> During partition, choose consistency or availability</li>
                <li><strong>Not binary:</strong> Many systems tune the trade-off (e.g., "eventual consistency with tunable consistency levels")</li>
            </ul>
        </div>
        
        <table class="comparison-table">
            <tr>
                <th>System Type</th>
                <th>Choice</th>
                <th>Behavior During Partition</th>
                <th>Examples</th>
            </tr>
            <tr>
                <td><strong>CP Systems</strong></td>
                <td>Consistency over Availability</td>
                <td>Returns error, waits for partition to heal</td>
                <td>MongoDB, HBase, Redis</td>
            </tr>
            <tr>
                <td><strong>AP Systems</strong></td>
                <td>Availability over Consistency</td>
                <td>Accepts writes, may have conflicts</td>
                <td>Cassandra, DynamoDB, Riak</td>
            </tr>
            <tr>
                <td><strong>CA Systems</strong></td>
                <td>No partition tolerance</td>
                <td>Assumes network is reliable (unrealistic!)</td>
                <td>Traditional RDBMS (single node)</td>
            </tr>
        </table>
        
        <div class="interactive-demo">
            <h3>üéÆ Interactive: Consistency Model Simulator</h3>
            <p>See how different consistency models behave:</p>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="demo-button" onclick="demoStrongConsistency()">Strong Consistency</button>
                <button class="demo-button" onclick="demoEventualConsistency()">Eventual Consistency</button>
                <button class="demo-button" onclick="demoReadYourWrites()">Read Your Writes</button>
                <button class="demo-button" onclick="demoCAP()">CAP Theorem</button>
            </div>
            <div id="consistencyDemo" class="demo-output">Click a button to see consistency models in action...</div>
        </div>
        
        <h3>üìä Consistency Model Comparison</h3>
        
        <table class="comparison-table">
            <tr>
                <th>Model</th>
                <th>Guarantee</th>
                <th>Performance</th>
                <th>Use Cases</th>
            </tr>
            <tr>
                <td><strong>Linearizability</strong></td>
                <td>Strongest - appears as single copy</td>
                <td>‚ùå Slowest</td>
                <td>Banking, inventory</td>
            </tr>
            <tr>
                <td><strong>Sequential</strong></td>
                <td>Total order, per-process order</td>
                <td>‚ö†Ô∏è Moderate</td>
                <td>Collaborative editing</td>
            </tr>
            <tr>
                <td><strong>Causal</strong></td>
                <td>Preserves causality</td>
                <td>‚úÖ Good</td>
                <td>Social media feeds</td>
            </tr>
            <tr>
                <td><strong>Read Your Writes</strong></td>
                <td>See own writes</td>
                <td>‚úÖ Good</td>
                <td>User profiles</td>
            </tr>
            <tr>
                <td><strong>Monotonic Reads</strong></td>
                <td>No going backwards</td>
                <td>‚úÖ Good</td>
                <td>Comment threads</td>
            </tr>
            <tr>
                <td><strong>Eventual</strong></td>
                <td>Converges eventually</td>
                <td>‚úÖ Fastest</td>
                <td>DNS, caching</td>
            </tr>
        </table>
        
        <div style="margin-top: 50px; padding: 30px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 12px;">
            <h3>üîë Key Takeaways from Chapter 6</h3>
            <ul style="line-height: 2;">
                <li><strong>Consistency is a spectrum</strong> - from strong (slow, correct) to weak (fast, eventually correct)</li>
                <li><strong>Strong/Linearizability</strong> - behaves like single machine, slowest</li>
                <li><strong>Eventual Consistency</strong> - fastest, but may read stale data</li>
                <li><strong>Causal Consistency</strong> - preserves cause-effect relationships</li>
                <li><strong>Read Your Writes</strong> - critical for good user experience</li>
                <li><strong>Monotonic Reads</strong> - time doesn't go backwards for user</li>
                <li><strong>CAP Theorem</strong> - can't have consistency + availability during partition</li>
                <li><strong>Trade-off:</strong> Stronger consistency = slower, weaker consistency = faster</li>
                <li><strong>Choose based on use case:</strong> Banking needs strong, social media can use eventual</li>
            </ul>
        </div>
        
        <div style="margin-top: 30px; padding: 25px; background: #fff3e0; border-radius: 12px; border-left: 5px solid #ff9800;">
            <h3>üìù Practice Questions</h3>
            <ol style="line-height: 2;">
                <li>Why is strong consistency slower than eventual consistency?</li>
                <li>Give an example where eventual consistency is acceptable and one where it's not.</li>
                <li>How does causal consistency use vector clocks?</li>
                <li>What's the difference between sequential consistency and linearizability?</li>
                <li>Why is Read Your Writes important for user experience?</li>
                <li>During a network partition, why can't you have both consistency and availability?</li>
                <li>Is MongoDB CP or AP? What about Cassandra?</li>
                <li>Design a system: Which consistency model would you choose for a shopping cart? Why?</li>
            </ol>
        </div>
    </div>
    
    <script>
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        async function demoStrongConsistency() {
            const output = document.getElementById('consistencyDemo');
            output.textContent = '=== STRONG CONSISTENCY (LINEARIZABILITY) ===\n\n';
            
            output.textContent += 'Initial: All replicas have X = 0\n';
            output.textContent += 'Replicas: A, B, C\n\n';
            
            await sleep(500);
            output.textContent += 'Client 1: Write X = 100\n';
            output.textContent += '  ‚Üí Writing to Replica A... ‚è≥\n';
            await sleep(300);
            output.textContent += '  ‚Üí Writing to Replica B... ‚è≥\n';
            await sleep(300);
            output.textContent += '  ‚Üí Writing to Replica C... ‚è≥\n';
            await sleep(300);
            output.textContent += '  ‚Üí ALL replicas updated!\n';
            output.textContent += '  ‚Üí Write COMPLETE ‚úì\n\n';
            
            await sleep(500);
            output.textContent += 'Client 2: Read X (immediately after)\n';
            output.textContent += '  ‚Üí Reading from Replica B...\n';
            await sleep(200);
            output.textContent += '  ‚Üí Value: 100 ‚úì\n\n';
            
            output.textContent += 'Client 3: Read X\n';
            output.textContent += '  ‚Üí Reading from Replica C...\n';
            await sleep(200);
            output.textContent += '  ‚Üí Value: 100 ‚úì\n\n';
            
            output.textContent += 'Result: Everyone sees 100 - perfectly consistent!\n';
            output.textContent += 'But slow: write took 900ms (wait for all replicas)';
        }
        
        async function demoEventualConsistency() {
            const output = document.getElementById('consistencyDemo');
            output.textContent = '=== EVENTUAL CONSISTENCY ===\n\n';
            
            output.textContent += 'Initial: All replicas have X = 0\n';
            output.textContent += 'Replicas: A, B, C\n\n';
            
            await sleep(500);
            output.textContent += 'Client 1: Write X = 100\n';
            output.textContent += '  ‚Üí Writing to Replica A... ‚è≥\n';
            await sleep(200);
            output.textContent += '  ‚Üí Write COMPLETE ‚úì (only one replica!)\n';
            output.textContent += '  ‚Üí Replication queued for B and C...\n\n';
            
            await sleep(300);
            output.textContent += 'Client 2: Read X (immediately after)\n';
            output.textContent += '  ‚Üí Reading from Replica B...\n';
            await sleep(200);
            output.textContent += '  ‚Üí Value: 0 (stale! B not updated yet) ‚ö†Ô∏è\n\n';
            
            await sleep(500);
            output.textContent += 'Background: Replicating to B and C...\n';
            await sleep(500);
            output.textContent += '  ‚Üí Replica B updated to 100 ‚úì\n';
            await sleep(300);
            output.textContent += '  ‚Üí Replica C updated to 100 ‚úì\n\n';
            
            output.textContent += 'Client 2: Read X again\n';
            output.textContent += '  ‚Üí Reading from Replica B...\n';
            await sleep(200);
            output.textContent += '  ‚Üí Value: 100 ‚úì\n\n';
            
            output.textContent += 'Result: Eventually consistent!\n';
            output.textContent += 'But fast: write took only 200ms!';
        }
        
        async function demoReadYourWrites() {
            const output = document.getElementById('consistencyDemo');
            output.textContent = '=== READ YOUR WRITES CONSISTENCY ===\n\n';
            
            output.textContent += 'Scenario: User updates profile picture\n\n';
            
            await sleep(500);
            output.textContent += 'Alice: Update profile_pic = "new.jpg"\n';
            output.textContent += '  ‚Üí Written to Replica A\n';
            output.textContent += '  ‚Üí System records: Alice ‚Üí Replica A\n\n';
            
            await sleep(500);
            output.textContent += 'Alice: Read profile_pic (refresh page)\n';
            output.textContent += '  ‚Üí System checks: Alice wrote to Replica A\n';
            output.textContent += '  ‚Üí Routing read to Replica A (has her write)\n';
            await sleep(300);
            output.textContent += '  ‚Üí Value: "new.jpg" ‚úì\n';
            output.textContent += '  ‚Üí Alice sees her update immediately! üòä\n\n';
            
            await sleep(500);
            output.textContent += 'Bob: Read Alice\'s profile_pic\n';
            output.textContent += '  ‚Üí Bob didn\'t write, can read from any replica\n';
            output.textContent += '  ‚Üí Reading from Replica B (not updated yet)\n';
            await sleep(300);
            output.textContent += '  ‚Üí Value: "old.jpg" (stale) ‚ö†Ô∏è\n';
            output.textContent += '  ‚Üí That\'s okay, Bob is a different user\n\n';
            
            output.textContent += 'Result: Users always see their own updates!\n';
            output.textContent += 'Critical for good user experience.';
        }
        
        async function demoCAP() {
            const output = document.getElementById('consistencyDemo');
            output.textContent = '=== CAP THEOREM DEMO ===\n\n';
            
            output.textContent += 'Setup: 2 nodes (A and B), both have X = 1\n\n';
            
            await sleep(500);
            output.textContent += '‚ö° NETWORK PARTITION OCCURS! ‚ö°\n';
            output.textContent += 'Nodes A and B cannot communicate\n\n';
            
            await sleep(500);
            output.textContent += 'Client 1 ‚Üí Node A: Write X = 5\n';
            output.textContent += 'Client 2 ‚Üí Node B: Write X = 10\n\n';
            
            await sleep(500);
            output.textContent += '--- CP System (Choose Consistency) ---\n';
            output.textContent += 'Node A: "I can\'t reach B to sync, REJECT" ‚ùå\n';
            output.textContent += 'Node B: "I can\'t reach A to sync, REJECT" ‚ùå\n';
            output.textContent += 'Result: UNAVAILABLE but CONSISTENT\n';
            output.textContent += 'Data stays at X = 1 on both\n\n';
            
            await sleep(500);
            output.textContent += '--- AP System (Choose Availability) ---\n';
            output.textContent += 'Node A: "Accept write, X = 5" ‚úì\n';
            output.textContent += 'Node B: "Accept write, X = 10" ‚úì\n';
            output.textContent += 'Result: AVAILABLE but INCONSISTENT\n';
            output.textContent += 'Node A has X = 5, Node B has X = 10\n\n';
            
            await sleep(1000);
            output.textContent += '‚úì Partition heals...\n\n';
            
            await sleep(500);
            output.textContent += 'AP System must resolve conflict:\n';
            output.textContent += '  - Last Write Wins? (X = 10)\n';
            output.textContent += '  - Keep both versions? (conflict!)\n';
            output.textContent += '  - Application decides\n\n';
            
            output.textContent += 'CAP Theorem: Can\'t have C + A during partition!\n';
            output.textContent += 'Must choose one.';
        }
    </script>
</body>
</html>