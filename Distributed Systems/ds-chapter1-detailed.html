<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 1: Distributed Systems</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2c3e50;
            border-bottom: 4px solid #3498db;
            padding-bottom: 15px;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        h2 {
            color: #2980b9;
            margin-top: 40px;
            margin-bottom: 20px;
            font-size: 2em;
            border-left: 5px solid #3498db;
            padding-left: 15px;
        }
        
        h3 {
            color: #34495e;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        .definition {
            background: #e8f4f8;
            border-left: 5px solid #3498db;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .example {
            background: #fff9e6;
            border-left: 5px solid #f39c12;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .challenge {
            background: #ffe6e6;
            border-left: 5px solid #e74c3c;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .key-point {
            background: #e8f8f5;
            border-left: 5px solid #27ae60;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .visual-diagram {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 2px solid #dee2e6;
        }
        
        .system-box {
            display: inline-block;
            padding: 15px 25px;
            margin: 10px;
            background: #3498db;
            color: white;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
            min-width: 120px;
        }
        
        .node {
            display: inline-block;
            width: 80px;
            height: 80px;
            background: #2ecc71;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 80px;
            margin: 15px;
            font-weight: bold;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }
        
        .connection {
            display: inline-block;
            width: 60px;
            height: 2px;
            background: #7f8c8d;
            vertical-align: middle;
        }
        
        .diagram-title {
            text-align: center;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .comparison-table th {
            background: #34495e;
            color: white;
            padding: 15px;
            text-align: left;
        }
        
        .comparison-table td {
            padding: 15px;
            border: 1px solid #ddd;
        }
        
        .comparison-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
        }
        
        code {
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
        }
        
        .architecture-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .architecture-card {
            background: white;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .architecture-card h4 {
            color: #2980b9;
            margin-bottom: 10px;
        }
        
        ul {
            margin: 15px 0 15px 30px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        .interactive-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border: 2px dashed #3498db;
        }
        
        strong {
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìö Chapter 1: Introduction to Distributed Systems</h1>
        
        <h2>1Ô∏è‚É£ What is a Distributed System?</h2>
        
        <div class="definition">
            <h3>üìñ Definition</h3>
            <p><strong>A distributed system is a collection of independent computers that appears to its users as a single coherent system.</strong></p>
            <p>In simpler terms: Multiple computers working together, but users interact with them as if they were one machine.</p>
        </div>
        
        <h3>Key Characteristics:</h3>
        <ul>
            <li><strong>Multiple autonomous computers:</strong> Each machine has its own processor, memory, and resources</li>
            <li><strong>Connected through a network:</strong> Machines communicate via message passing (Internet, LAN, etc.)</li>
            <li><strong>Coordination and cooperation:</strong> Computers work together to achieve a common goal</li>
            <li><strong>Transparency:</strong> Users shouldn't need to know the system is distributed</li>
            <li><strong>No shared clock:</strong> Each machine has its own clock (this causes many challenges!)</li>
        </ul>
        
        <div class="visual-diagram">
            <div class="diagram-title">Simple Distributed System Visualization</div>
            <div style="text-align: center;">
                <div class="node">Node 1</div>
                <div class="connection"></div>
                <div class="node">Node 2</div>
                <div class="connection"></div>
                <div class="node">Node 3</div>
                <br>
                <div style="margin-top: 20px;">
                    <div class="connection" style="transform: rotate(90deg); margin: 20px auto;"></div>
                </div>
                <div class="system-box">User sees ONE SYSTEM</div>
            </div>
        </div>
        
        <div class="example">
            <h3>üåü Real-World Example: Google Search</h3>
            <p>When you search on Google:</p>
            <ul>
                <li>Your query goes to thousands of servers across multiple data centers</li>
                <li>Different servers handle: query parsing, index lookup, ranking, ad serving, spell checking</li>
                <li>Results are aggregated and returned in milliseconds</li>
                <li>To you, it appears as one fast, reliable search engine</li>
            </ul>
            <p><strong>But behind the scenes:</strong> Millions of machines in dozens of data centers worldwide are coordinating!</p>
        </div>
        
        <h3>Types of Transparency in Distributed Systems:</h3>
        <table class="comparison-table">
            <tr>
                <th>Type</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
            <tr>
                <td><strong>Access</strong></td>
                <td>Hide differences in data representation and access methods</td>
                <td>Same API whether data is local or remote</td>
            </tr>
            <tr>
                <td><strong>Location</strong></td>
                <td>Hide where resources are located</td>
                <td>URLs hide physical server location</td>
            </tr>
            <tr>
                <td><strong>Migration</strong></td>
                <td>Hide resource movement</td>
                <td>VM migrates between servers, users don't notice</td>
            </tr>
            <tr>
                <td><strong>Replication</strong></td>
                <td>Hide multiple copies of resources</td>
                <td>CDN serves content from nearest server</td>
            </tr>
            <tr>
                <td><strong>Failure</strong></td>
                <td>Hide failures and recovery</td>
                <td>System continues working even when servers fail</td>
            </tr>
            <tr>
                <td><strong>Concurrency</strong></td>
                <td>Hide shared resource access by multiple users</td>
                <td>Multiple people editing Google Docs simultaneously</td>
            </tr>
        </table>
        
        <h2>2Ô∏è‚É£ Why Distributed Systems?</h2>
        
        <h3>üöÄ Scalability</h3>
        <div class="key-point">
            <p><strong>Scalability</strong> is the ability to handle growing amounts of work by adding resources to the system.</p>
        </div>
        
        <p><strong>Three Dimensions of Scalability:</strong></p>
        
        <div class="architecture-grid">
            <div class="architecture-card">
                <h4>üìä Size Scalability</h4>
                <p>Adding more users and resources without performance loss</p>
                <p><em>Example:</em> Facebook grew from thousands to billions of users</p>
            </div>
            
            <div class="architecture-card">
                <h4>üåç Geographical Scalability</h4>
                <p>Users and resources can be far apart</p>
                <p><em>Example:</em> Netflix serves users worldwide from regional data centers</p>
            </div>
            
            <div class="architecture-card">
                <h4>‚öôÔ∏è Administrative Scalability</h4>
                <p>Easy to manage even as system grows</p>
                <p><em>Example:</em> Cloud platforms like AWS manage millions of VMs</p>
            </div>
        </div>
        
        <div class="example">
            <h3>üìà Scalability Example: Instagram</h3>
            <p><strong>Problem:</strong> Single server can handle ~1,000 concurrent users. What if 100 million users want to access Instagram?</p>
            <p><strong>Solution:</strong></p>
            <ul>
                <li><strong>Horizontal Scaling:</strong> Add more servers (not just one bigger server)</li>
                <li>Distribute users across thousands of servers</li>
                <li>Each server handles a portion of users</li>
                <li>Load balancers distribute incoming requests</li>
                <li>Database is sharded (split) across multiple machines</li>
            </ul>
        </div>
        
        <pre><code>// Simplified Load Balancer Concept
class LoadBalancer {
    servers = ['server1.com', 'server2.com', 'server3.com'];
    currentIndex = 0;
    
    getNextServer() {
        // Round-robin: distribute requests evenly
        const server = this.servers[this.currentIndex];
        this.currentIndex = (this.currentIndex + 1) % this.servers.length;
        return server;
    }
}

// When user request comes in:
const lb = new LoadBalancer();
const assignedServer = lb.getNextServer();
console.log(`Routing user to: ${assignedServer}`);</code></pre>
        
        <h3>üõ°Ô∏è Reliability and Fault Tolerance</h3>
        <div class="key-point">
            <p><strong>Reliability:</strong> The system continues to work correctly even when components fail.</p>
            <p><strong>Fault Tolerance:</strong> The system can continue operating properly in the event of failure of some components.</p>
        </div>
        
        <p><strong>How Distributed Systems Achieve Reliability:</strong></p>
        <ul>
            <li><strong>Redundancy:</strong> Keep multiple copies of data and services</li>
            <li><strong>Replication:</strong> If one server fails, others can take over</li>
            <li><strong>No Single Point of Failure (SPOF):</strong> Design so no one component's failure brings down the whole system</li>
        </ul>
        
        <div class="example">
            <h3>üíæ Reliability Example: Amazon S3</h3>
            <p>Amazon S3 (Simple Storage Service) promises 99.999999999% (11 nines) durability:</p>
            <ul>
                <li>Every file is stored in at least 3 different locations</li>
                <li>Copies are in different buildings (availability zones)</li>
                <li>If one data center has fire/flood/power failure, your data is safe</li>
                <li>Automatic checksums verify data hasn't been corrupted</li>
                <li>Failed disks are automatically detected and data is re-replicated</li>
            </ul>
            <p><strong>Result:</strong> If you store 10 million files, you might lose 1 file every 10,000 years!</p>
        </div>
        
        <h3>‚ö° Performance</h3>
        <div class="key-point">
            <p><strong>Performance:</strong> Distributed systems can be faster than centralized systems through parallelism and proximity.</p>
        </div>
        
        <p><strong>Two Ways to Improve Performance:</strong></p>
        
        <div class="architecture-grid">
            <div class="architecture-card">
                <h4>‚ö° Parallel Processing</h4>
                <p>Multiple computers work on different parts of a problem simultaneously</p>
                <p><strong>Example:</strong> MapReduce processes terabytes of data by splitting work across thousands of machines</p>
            </div>
            
            <div class="architecture-card">
                <h4>üìç Data Locality</h4>
                <p>Place data/computation closer to users</p>
                <p><strong>Example:</strong> Content Delivery Networks (CDN) cache Netflix videos near users - video from Mumbai serves users in India faster than from California</p>
            </div>
        </div>
        
        <pre><code>// Simplified MapReduce Concept
// Problem: Count word frequency in billions of documents

// MAP Phase (parallel across 1000s of machines)
function map(document) {
    const words = document.split(' ');
    words.forEach(word => {
        emit(word, 1); // emit(key, value)
    });
}

// REDUCE Phase (parallel across 1000s of machines)
function reduce(word, counts) {
    // counts = [1, 1, 1, 1, ...] (one for each occurrence)
    return sum(counts); // Total count for this word
}

// Each machine processes a subset of documents
// Results are combined automatically
// What would take days on one machine takes minutes on 1000 machines!</code></pre>
        
        <h2>3Ô∏è‚É£ Challenges in Distributed Systems</h2>
        
        <p>Distributed systems solve many problems but introduce new challenges:</p>
        
        <div class="challenge">
            <h3>‚è∞ Challenge 1: No Global Clock</h3>
            <p><strong>Problem:</strong> Each computer has its own clock, and they drift apart</p>
            <p><strong>Why it matters:</strong> Hard to determine order of events</p>
            <p><strong>Example:</strong> Two users edit a document at "the same time" - whose edit happened first?</p>
            <p><strong>Solutions:</strong> Logical clocks (Lamport timestamps), Vector clocks, NTP synchronization</p>
        </div>
        
        <div class="challenge">
            <h3>üì° Challenge 2: Network Failures</h3>
            <p><strong>Problem:</strong> Messages can be lost, delayed, duplicated, or arrive out of order</p>
            <p><strong>Why it matters:</strong> Can't tell if a server is slow or dead</p>
            <p><strong>Example:</strong> You send a payment request - no response. Did it fail or is the network slow?</p>
            <p><strong>Solutions:</strong> Timeouts, retry mechanisms, acknowledgments, idempotent operations</p>
        </div>
        
        <div class="challenge">
            <h3>üí• Challenge 3: Partial Failures</h3>
            <p><strong>Problem:</strong> Some parts of the system fail while others keep working</p>
            <p><strong>Why it matters:</strong> System is in inconsistent state</p>
            <p><strong>Example:</strong> Payment server charges your card but order server crashes before recording it</p>
            <p><strong>Solutions:</strong> Distributed transactions, consensus algorithms, eventual consistency</p>
        </div>
        
        <div class="challenge">
            <h3>üîÑ Challenge 4: Concurrency</h3>
            <p><strong>Problem:</strong> Multiple computers accessing/modifying shared data simultaneously</p>
            <p><strong>Why it matters:</strong> Data can become inconsistent</p>
            <p><strong>Example:</strong> Two people book the last seat on a flight at the same time</p>
            <p><strong>Solutions:</strong> Locks, transactions, version control, optimistic concurrency</p>
        </div>
        
        <div class="challenge">
            <h3>üìä Challenge 5: Consistency vs Availability Trade-off</h3>
            <p><strong>Problem:</strong> Can't have both perfect consistency and 100% availability during network problems</p>
            <p><strong>Why it matters:</strong> Must choose what's more important for your application</p>
            <p><strong>Example:</strong> Bank (needs consistency) vs Social media feed (can tolerate inconsistency)</p>
            <p><strong>Solution:</strong> CAP theorem - choose 2 of 3: Consistency, Availability, Partition tolerance</p>
        </div>
        
        <div class="challenge">
            <h3>üîê Challenge 6: Security</h3>
            <p><strong>Problem:</strong> More components means more attack surface; data travels over networks</p>
            <p><strong>Why it matters:</strong> Vulnerable to eavesdropping, tampering, impersonation</p>
            <p><strong>Example:</strong> Man-in-the-middle attacks, DDoS attacks</p>
            <p><strong>Solutions:</strong> Encryption (TLS/SSL), Authentication, Authorization, Firewalls</p>
        </div>
        
        <h2>4Ô∏è‚É£ Examples of Distributed Systems</h2>
        
        <div class="architecture-grid">
            <div class="architecture-card">
                <h4>üåê Web Services</h4>
                <p><strong>Example:</strong> Amazon.com</p>
                <ul>
                    <li>Frontend servers serve web pages</li>
                    <li>Backend services: product catalog, shopping cart, recommendations, payment</li>
                    <li>Database clusters store product/user data</li>
                    <li>Cache servers (Redis/Memcached) for fast access</li>
                    <li>CDN serves images/videos</li>
                </ul>
            </div>
            
            <div class="architecture-card">
                <h4>‚òÅÔ∏è Cloud Computing</h4>
                <p><strong>Example:</strong> AWS, Google Cloud, Azure</p>
                <ul>
                    <li>Massive data centers worldwide</li>
                    <li>Virtualization: thousands of VMs per physical server</li>
                    <li>Storage: S3, Cloud Storage</li>
                    <li>Compute: EC2, Cloud Functions</li>
                    <li>Managed services: databases, ML, analytics</li>
                </ul>
            </div>
            
            <div class="architecture-card">
                <h4>üîÑ Peer-to-Peer Networks</h4>
                <p><strong>Example:</strong> BitTorrent, Blockchain</p>
                <ul>
                    <li>No central server - all nodes are equal</li>
                    <li>Each node can act as client and server</li>
                    <li>File sharing: pieces from multiple sources</li>
                    <li>Resilient: no single point of failure</li>
                    <li>Scales well: more peers = more capacity</li>
                </ul>
            </div>
            
            <div class="architecture-card">
                <h4>üí¨ Real-time Communication</h4>
                <p><strong>Example:</strong> WhatsApp, Zoom</p>
                <ul>
                    <li>Message routing across servers</li>
                    <li>Presence detection (online/offline)</li>
                    <li>Message delivery guarantees</li>
                    <li>End-to-end encryption</li>
                    <li>Media streaming</li>
                </ul>
            </div>
            
            <div class="architecture-card">
                <h4>üóÑÔ∏è Distributed Databases</h4>
                <p><strong>Example:</strong> Cassandra, MongoDB</p>
                <ul>
                    <li>Data sharded across nodes</li>
                    <li>Replication for reliability</li>
                    <li>Eventual consistency</li>
                    <li>Handles petabytes of data</li>
                    <li>No single point of failure</li>
                </ul>
            </div>
            
            <div class="architecture-card">
                <h4>üéÆ Online Gaming</h4>
                <p><strong>Example:</strong> Fortnite, League of Legends</p>
                <ul>
                    <li>Game servers across regions</li>
                    <li>Matchmaking services</li>
                    <li>State synchronization</li>
                    <li>Anti-cheat systems</li>
                    <li>Leaderboards and statistics</li>
                </ul>
            </div>
        </div>
        
        <h2>5Ô∏è‚É£ Distributed vs Centralized vs Decentralized Systems</h2>
        
        <div class="visual-diagram">
            <div class="diagram-title">Architecture Comparison</div>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-top: 20px;">
                <div style="text-align: center;">
                    <h4 style="color: #e74c3c;">Centralized</h4>
                    <div style="margin: 20px;">
                        <div class="node" style="background: #e74c3c;">Server</div>
                        <div style="margin: 10px;">
                            <div class="connection" style="transform: rotate(45deg); width: 40px;"></div>
                            <div class="connection" style="transform: rotate(-45deg); width: 40px;"></div>
                        </div>
                        <div>
                            <div class="node" style="width: 50px; height: 50px; line-height: 50px; font-size: 0.8em;">C1</div>
                            <div class="node" style="width: 50px; height: 50px; line-height: 50px; font-size: 0.8em;">C2</div>
                            <div class="node" style="width: 50px; height: 50px; line-height: 50px; font-size: 0.8em;">C3</div>
                        </div>
                    </div>
                </div>
                
                <div style="text-align: center;">
                    <h4 style="color: #f39c12;">Decentralized</h4>
                    <div style="margin: 20px;">
                        <div>
                            <div class="node" style="background: #f39c12; width: 60px; height: 60px; line-height: 60px;">S1</div>
                            <div class="node" style="background: #f39c12; width: 60px; height: 60px; line-height: 60px;">S2</div>
                        </div>
                        <div style="margin: 10px;">‚Üì ‚Üì</div>
                        <div>
                            <div class="node" style="width: 40px; height: 40px; line-height: 40px; font-size: 0.7em;">C</div>
                            <div class="node" style="width: 40px; height: 40px; line-height: 40px; font-size: 0.7em;">C</div>
                            <div class="node" style="width: 40px; height: 40px; line-height: 40px; font-size: 0.7em;">C</div>
                        </div>
                    </div>
                </div>
                
                <div style="text-align: center;">
                    <h4 style="color: #3498db;">Distributed (Peer-to-Peer)</h4>
                    <div style="margin: 20px;">
                        <div>
                            <div class="node" style="background: #3498db; width: 50px; height: 50px; line-height: 50px; font-size: 0.8em;">P1</div>
                            <div class="connection" style="width: 30px;"></div>
                            <div class="node" style="background: #3498db; width: 50px; height: 50px; line-height: 50px; font-size: 0.8em;">P2</div>
                        </div>
                        <div style="margin: 5px;">‚Üï ‚Üï</div>
                        <div>
                            <div class="node" style="background: #3498db; width: 50px; height: 50px; line-height: 50px; font-size: 0.8em;">P3</div>
                            <div class="connection" style="width: 30px;"></div>
                            <div class="node" style="background: #3498db; width: 50px; height: 50px; line-height: 50px; font-size: 0.8em;">P4</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <table class="comparison-table">
            <tr>
                <th>Aspect</th>
                <th>Centralized</th>
                <th>Decentralized</th>
                <th>Distributed (P2P)</th>
            </tr>
            <tr>
                <td><strong>Control</strong></td>
                <td>One central authority</td>
                <td>Multiple authorities</td>
                <td>No central authority</td>
            </tr>
            <tr>
                <td><strong>Architecture</strong></td>
                <td>One server, many clients</td>
                <td>Multiple servers, clients connect to nearest</td>
                <td>All nodes are equal (peers)</td>
            </tr>
            <tr>
                <td><strong>Failure Impact</strong></td>
                <td>‚ùå Central server fails ‚Üí entire system down</td>
                <td>‚ö†Ô∏è One server fails ‚Üí some users affected</td>
                <td>‚úÖ Nodes fail ‚Üí system continues</td>
            </tr>
            <tr>
                <td><strong>Scalability</strong></td>
                <td>‚ùå Limited (server bottleneck)</td>
                <td>‚úÖ Good (add more servers)</td>
                <td>‚úÖ Excellent (scales with users)</td>
            </tr>
            <tr>
                <td><strong>Latency</strong></td>
                <td>‚ùå High (server might be far)</td>
                <td>‚úÖ Lower (regional servers)</td>
                <td>‚úÖ Variable (depends on peers)</td>
            </tr>
            <tr>
                <td><strong>Cost</strong></td>
                <td>üí∞ Lower initially</td>
                <td>üí∞üí∞ Higher (multiple data centers)</td>
                <td>üí∞ Lower (users provide resources)</td>
            </tr>
            <tr>
                <td><strong>Examples</strong></td>
                <td>Traditional websites, email servers</td>
                <td>CDNs (Cloudflare), DNS</td>
                <td>BitTorrent, Blockchain, IPFS</td>
            </tr>
            <tr>
                <td><strong>Data Consistency</strong></td>
                <td>‚úÖ Easy (one source of truth)</td>
                <td>‚ö†Ô∏è Moderate (synchronize between servers)</td>
                <td>‚ùå Hard (eventual consistency)</td>
            </tr>
            <tr>
                <td><strong>Security</strong></td>
                <td>‚ö†Ô∏è Single target for attacks</td>
                <td>‚úÖ More resilient</td>
                <td>‚úÖ No single target, but consensus needed</td>
            </tr>
        </table>
        
        <div class="example">
            <h3>üè¶ Real-World Comparison: Banking Systems</h3>
            
            <p><strong>Centralized (Traditional Bank):</strong></p>
            <ul>
                <li>All transactions go through bank's central server</li>
                <li>Bank has complete control and authority</li>
                <li>Easy to track and audit</li>
                <li>Single point of failure (if server down, no transactions)</li>
            </ul>
            
            <p><strong>Decentralized (Bank with Branches):</strong></p>
            <ul>
                <li>Multiple branch servers, synchronized overnight</li>
                <li>Can do some operations locally at branch</li>
                <li>If one branch system fails, others continue</li>
                <li>Need to synchronize data between branches</li>
            </ul>
            
            <p><strong>Distributed (Cryptocurrency like Bitcoin):</strong></p>
            <ul>
                <li>No central bank or authority</li>
                <li>All nodes maintain copy of ledger</li>
                <li>Consensus algorithm determines valid transactions</li>
                <li>Extremely resilient but slower and more complex</li>
            </ul>
        </div>
        
        <h3>üéØ When to Use Each Architecture?</h3>
        
        <div class="key-point">
            <p><strong>Use Centralized when:</strong></p>
            <ul>
                <li>Small scale application</li>
                <li>Strong consistency is critical</li>
                <li>Simpler to implement and maintain</li>
                <li>Example: Small business website, personal blog</li>
            </ul>
        </div>
        
        <div class="key-point">
            <p><strong>Use Decentralized when:</strong></p>
            <ul>
                <li>Need geographic distribution</li>
                <li>Want fault tolerance with central control</li>
                <li>Medium-to-large scale</li>
                <li>Example: Global SaaS applications, CDN</li>
            </ul>
        </div>
        
        <div class="key-point">
            <p><strong>Use Distributed (P2P) when:</strong></p>
            <ul>
                <li>No central authority desired/possible</li>
                <li>Need extreme resilience</li>
                <li>Users can contribute resources</li>
                <li>Example: File sharing, blockchain, distributed storage</li>
            </ul>
        </div>
        
        <div class="interactive-section">
            <h3>üîë Key Takeaways from Chapter 1</h3>
            <ul>
                <li>Distributed systems are multiple computers working together to appear as one</li>
                <li>Main benefits: Scalability, Reliability, Performance</li>
                <li>Main challenges: No global clock, network failures, partial failures, consistency</li>
                <li>Used everywhere: web services, cloud computing, P2P networks, databases</li>
                <li>Three architectures: Centralized (one server), Decentralized (multiple servers), Distributed (all peers equal)</li>
                <li>No perfect architecture - choose based on requirements: consistency vs availability, scale, cost, complexity</li>
            </ul>
        </div>
        
        <div style="margin-top: 40px; padding: 20px; background: #34495e; color: white; border-radius: 8px;">
            <h3>üìù Test Your Understanding</h3>
            <ol>
                <li>Why can't we just use one powerful server instead of distributed systems?</li>
                <li>What's the difference between reliability and fault tolerance?</li>
                <li>Why is "no global clock" such a big problem?</li>
                <li>Can you think of a system that needs strong consistency vs one that can tolerate eventual consistency?</li>
                <li>Is Netflix centralized, decentralized, or distributed? (Hint: it's hybrid!)</li>
            </ol>
        </div>
    </div>
</body>
</html>