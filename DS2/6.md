# Chapter 6: Service Discovery and Load Balancing

> **Goal**: Learn how services find each other and distribute traffic in distributed systems

---

## 6.1 The Service Discovery Problem

### Why It's Hard

```
┌─────────────────────────────────────────────────────────────┐
│              THE SERVICE DISCOVERY PROBLEM                   │
│                                                              │
│  In a monolith:                                             │
│  ──────────────                                             │
│  Everything runs on one server. Easy!                       │
│  Call function directly: user_service.get_user(123)         │
│                                                              │
│                                                              │
│  In distributed systems:                                    │
│  ──────────────────────                                     │
│  Services run on different machines with different IPs.     │
│  IPs change constantly due to:                              │
│                                                              │
│  ├── Auto-scaling (new instances added/removed)             │
│  ├── Deployments (old instances replaced)                   │
│  ├── Failures (crashed instances restarted)                 │
│  ├── Container orchestration (pods rescheduled)             │
│  └── Cloud migrations (different availability zones)        │
│                                                              │
│                                                              │
│  Question: How does Order Service find User Service?        │
│                                                              │
│  ┌─────────────────┐         ┌─────────────────────────┐   │
│  │  Order Service  │ ──?──▶  │     User Service        │   │
│  │                 │         │  IP: ???                │   │
│  │  Needs to call  │         │  Port: ???              │   │
│  │  get_user(123)  │         │  Which instance???      │   │
│  └─────────────────┘         └─────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### The Wrong Way: Hardcoded IPs

```python
# ❌ DON'T DO THIS - Hardcoded configuration
class OrderService:
    USER_SERVICE_URL = "http://192.168.1.10:8080"  # What if this changes?
    
    async def get_user(self, user_id: int):
        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"{self.USER_SERVICE_URL}/users/{user_id}"
            )
            return response.json()

# Problems:
# 1. IP changes? Code change + redeploy needed
# 2. Multiple instances? Can't load balance
# 3. Instance dies? No failover
# 4. Different environments? Different configs
```

---

## 6.2 Service Discovery Patterns

### Pattern 1: Client-Side Discovery

```
┌─────────────────────────────────────────────────────────────┐
│               CLIENT-SIDE DISCOVERY                          │
│                                                              │
│   ┌─────────────────┐                                       │
│   │  Order Service  │                                       │
│   │  (Client)       │                                       │
│   └────────┬────────┘                                       │
│            │                                                 │
│   Step 1:  │ Query "Where is user-service?"                 │
│            ▼                                                 │
│   ┌─────────────────┐                                       │
│   │Service Registry │                                       │
│   │   (Consul,      │                                       │
│   │    etcd,        │                                       │
│   │    ZooKeeper)   │                                       │
│   └────────┬────────┘                                       │
│            │                                                 │
│   Step 2:  │ Returns: [192.168.1.10:8080, 192.168.1.11:8080]│
│            ▼                                                 │
│   ┌─────────────────┐                                       │
│   │  Order Service  │                                       │
│   │  picks one      │                                       │
│   │  (load balance) │                                       │
│   └────────┬────────┘                                       │
│            │                                                 │
│   Step 3:  │ Direct call to chosen instance                 │
│            ▼                                                 │
│   ┌─────────────────┐                                       │
│   │  User Service   │                                       │
│   │  192.168.1.10   │                                       │
│   └─────────────────┘                                       │
│                                                              │
│   Pros:                      Cons:                          │
│   ├── No extra hop           ├── Client complexity          │
│   ├── Client controls LB     ├── Language-specific code     │
│   └── Flexible               └── Tight coupling to registry │
└─────────────────────────────────────────────────────────────┘
```

### Pattern 2: Server-Side Discovery

```
┌─────────────────────────────────────────────────────────────┐
│               SERVER-SIDE DISCOVERY                          │
│                                                              │
│   ┌─────────────────┐                                       │
│   │  Order Service  │                                       │
│   │  (Client)       │                                       │
│   └────────┬────────┘                                       │
│            │                                                 │
│   Step 1:  │ Call user-service (logical name)               │
│            ▼                                                 │
│   ┌─────────────────────────────────────────┐              │
│   │          Load Balancer / Proxy          │              │
│   │   (knows about all service instances)   │              │
│   └────────┬──────────────────────┬─────────┘              │
│            │                      │                         │
│   Step 2:  │ Routes to healthy    │ Queries registry        │
│            │ instance             │ for instances           │
│            ▼                      ▼                         │
│   ┌──────────────┐        ┌─────────────────┐              │
│   │ User Service │        │Service Registry │              │
│   │ Instance 1   │        └─────────────────┘              │
│   └──────────────┘                                         │
│                                                              │
│   Pros:                      Cons:                          │
│   ├── Simple clients         ├── Extra network hop          │
│   ├── Language agnostic      ├── LB can be bottleneck       │
│   └── Centralized logic      └── More infrastructure        │
└─────────────────────────────────────────────────────────────┘
```

### Pattern 3: DNS-Based Discovery

```
┌─────────────────────────────────────────────────────────────┐
│                  DNS-BASED DISCOVERY                         │
│                                                              │
│   ┌─────────────────┐                                       │
│   │  Order Service  │                                       │
│   └────────┬────────┘                                       │
│            │                                                 │
│            │ DNS query: user-service.internal               │
│            ▼                                                 │
│   ┌─────────────────┐                                       │
│   │   DNS Server    │                                       │
│   │ (returns A/SRV  │                                       │
│   │  records)       │                                       │
│   └────────┬────────┘                                       │
│            │                                                 │
│            │ Returns: 192.168.1.10, 192.168.1.11            │
│            ▼                                                 │
│   ┌─────────────────┐                                       │
│   │  Order Service  │                                       │
│   │  connects to IP │                                       │
│   └─────────────────┘                                       │
│                                                              │
│   Simple but limited:                                       │
│   ├── DNS caching causes stale IPs                          │
│   ├── No health checking in basic DNS                       │
│   ├── TTL tradeoff (low = more queries, high = stale)       │
│   └── No metadata (just IPs)                                │
│                                                              │
│   Good for: Simple cases, Kubernetes internal DNS           │
└─────────────────────────────────────────────────────────────┘
```

---

## 6.3 Service Registry Deep Dive

### 6.3.1 Consul

HashiCorp Consul is a popular service mesh with built-in service discovery.

```
┌─────────────────────────────────────────────────────────────┐
│                     CONSUL ARCHITECTURE                      │
│                                                              │
│   ┌─────────────────────────────────────────────────────┐   │
│   │                   Consul Cluster                     │   │
│   │  ┌────────┐   ┌────────┐   ┌────────┐              │   │
│   │  │Server 1│◀─▶│Server 2│◀─▶│Server 3│  (Raft)      │   │
│   │  │(Leader)│   │        │   │        │              │   │
│   │  └────────┘   └────────┘   └────────┘              │   │
│   └─────────────────────────────────────────────────────┘   │
│          ▲              ▲              ▲                     │
│          │              │              │                     │
│   ┌──────┴───┐   ┌──────┴───┐   ┌──────┴───┐               │
│   │  Agent   │   │  Agent   │   │  Agent   │               │
│   │(Service A│   │(Service B│   │(Service C│               │
│   │  Host)   │   │  Host)   │   │  Host)   │               │
│   └──────────┘   └──────────┘   └──────────┘               │
│                                                              │
│   Features:                                                 │
│   ├── Service registration & discovery                      │
│   ├── Health checking (HTTP, TCP, script)                   │
│   ├── Key-value store (config)                              │
│   ├── Multi-datacenter support                              │
│   └── Service mesh (with Envoy)                             │
└─────────────────────────────────────────────────────────────┘
```

```python
# consul_service.py
import consul
import consul.aio
import asyncio
import socket
import uuid
from typing import List, Optional
from dataclasses import dataclass

@dataclass
class ServiceInstance:
    id: str
    name: str
    address: str
    port: int
    tags: List[str]
    meta: dict

class ConsulServiceRegistry:
    def __init__(self, host: str = "localhost", port: int = 8500):
        self.consul = consul.aio.Consul(host=host, port=port)
        self.registered_services: dict[str, str] = {}  # service_name -> service_id
    
    async def register(
        self,
        name: str,
        port: int,
        tags: List[str] = None,
        meta: dict = None,
        health_check_path: str = "/health",
        health_check_interval: str = "10s"
    ) -> str:
        """Register a service with Consul"""
        
        service_id = f"{name}-{uuid.uuid4().hex[:8]}"
        address = socket.gethostbyname(socket.gethostname())
        
        # Define health check
        check = consul.Check.http(
            url=f"http://{address}:{port}{health_check_path}",
            interval=health_check_interval,
            timeout="5s",
            deregister="1m"  # Remove if unhealthy for 1 minute
        )
        
        await self.consul.agent.service.register(
            name=name,
            service_id=service_id,
            address=address,
            port=port,
            tags=tags or [],
            meta=meta or {},
            check=check
        )
        
        self.registered_services[name] = service_id
        print(f"Registered {name} as {service_id} at {address}:{port}")
        return service_id
    
    async def deregister(self, name: str):
        """Deregister a service"""
        if name in self.registered_services:
            service_id = self.registered_services[name]
            await self.consul.agent.service.deregister(service_id)
            del self.registered_services[name]
            print(f"Deregistered {service_id}")
    
    async def discover(
        self, 
        name: str, 
        passing_only: bool = True,
        tag: str = None
    ) -> List[ServiceInstance]:
        """Discover healthy instances of a service"""
        
        _, services = await self.consul.health.service(
            name,
            passing=passing_only,
            tag=tag
        )
        
        instances = []
        for svc in services:
            instance = ServiceInstance(
                id=svc['Service']['ID'],
                name=svc['Service']['Service'],
                address=svc['Service']['Address'],
                port=svc['Service']['Port'],
                tags=svc['Service']['Tags'],
                meta=svc['Service']['Meta']
            )
            instances.append(instance)
        
        return instances
    
    async def watch(self, name: str, callback):
        """Watch for service changes"""
        index = None
        while True:
            index, services = await self.consul.health.service(
                name,
                passing=True,
                index=index,  # Long poll - blocks until change
                wait="5m"
            )
            instances = [
                ServiceInstance(
                    id=s['Service']['ID'],
                    name=s['Service']['Service'],
                    address=s['Service']['Address'],
                    port=s['Service']['Port'],
                    tags=s['Service']['Tags'],
                    meta=s['Service']['Meta']
                )
                for s in services
            ]
            await callback(instances)

# ============== USAGE WITH FASTAPI ==============

from fastapi import FastAPI
from contextlib import asynccontextmanager

registry = ConsulServiceRegistry()

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Register on startup
    await registry.register(
        name="user-service",
        port=8000,
        tags=["api", "users"],
        meta={"version": "1.0.0"}
    )
    
    yield
    
    # Deregister on shutdown
    await registry.deregister("user-service")

app = FastAPI(lifespan=lifespan)

@app.get("/health")
async def health():
    return {"status": "healthy"}

@app.get("/users/{user_id}")
async def get_user(user_id: int):
    return {"id": user_id, "name": "Alice"}

# ============== CLIENT WITH DISCOVERY ==============

import httpx
import random

class ServiceClient:
    def __init__(self, registry: ConsulServiceRegistry):
        self.registry = registry
        self.cache: dict[str, List[ServiceInstance]] = {}
        self.cache_ttl = 30  # seconds
    
    async def call(
        self, 
        service_name: str, 
        method: str,
        path: str,
        **kwargs
    ):
        """Call a service with automatic discovery"""
        
        # Discover instances
        instances = await self.registry.discover(service_name)
        
        if not instances:
            raise Exception(f"No healthy instances of {service_name}")
        
        # Simple random load balancing
        instance = random.choice(instances)
        url = f"http://{instance.address}:{instance.port}{path}"
        
        async with httpx.AsyncClient() as client:
            response = await getattr(client, method.lower())(url, **kwargs)
            return response.json()

# Usage
async def example():
    client = ServiceClient(registry)
    
    # Automatically discovers and calls user-service
    user = await client.call("user-service", "GET", "/users/123")
    print(user)
```

### 6.3.2 etcd

A distributed key-value store (used by Kubernetes).

```python
# etcd_service_registry.py
import etcd3
import json
import asyncio
from typing import List
from dataclasses import dataclass, asdict
import threading

@dataclass
class ServiceInstance:
    id: str
    name: str
    address: str
    port: int
    metadata: dict = None

class EtcdServiceRegistry:
    def __init__(self, host: str = "localhost", port: int = 2379):
        self.client = etcd3.client(host=host, port=port)
        self.lease = None
        self.keepalive_thread = None
    
    def register(
        self, 
        instance: ServiceInstance,
        ttl: int = 30
    ) -> str:
        """Register service with TTL-based lease"""
        
        # Create lease (auto-expires if not renewed)
        self.lease = self.client.lease(ttl)
        
        # Store service info
        key = f"/services/{instance.name}/{instance.id}"
        value = json.dumps(asdict(instance))
        
        self.client.put(key, value, lease=self.lease)
        
        # Start keepalive in background
        self._start_keepalive()
        
        print(f"Registered {instance.name}/{instance.id}")
        return key
    
    def _start_keepalive(self):
        """Keep lease alive in background thread"""
        def keepalive():
            while self.lease:
                try:
                    self.lease.refresh()
                    threading.Event().wait(self.lease.ttl / 2)
                except Exception:
                    break
        
        self.keepalive_thread = threading.Thread(target=keepalive, daemon=True)
        self.keepalive_thread.start()
    
    def deregister(self, instance: ServiceInstance):
        """Deregister service"""
        key = f"/services/{instance.name}/{instance.id}"
        self.client.delete(key)
        
        if self.lease:
            self.lease.revoke()
            self.lease = None
    
    def discover(self, service_name: str) -> List[ServiceInstance]:
        """Discover all instances of a service"""
        prefix = f"/services/{service_name}/"
        instances = []
        
        for value, metadata in self.client.get_prefix(prefix):
            if value:
                data = json.loads(value.decode())
                instances.append(ServiceInstance(**data))
        
        return instances
    
    def watch(self, service_name: str, callback):
        """Watch for changes to service instances"""
        prefix = f"/services/{service_name}/"
        
        events_iterator, cancel = self.client.watch_prefix(prefix)
        
        for event in events_iterator:
            instances = self.discover(service_name)
            callback(instances)

# Usage
registry = EtcdServiceRegistry()

# Register
instance = ServiceInstance(
    id="user-service-1",
    name="user-service",
    address="192.168.1.10",
    port=8080,
    metadata={"version": "1.0"}
)
registry.register(instance)

# Discover
instances = registry.discover("user-service")
for inst in instances:
    print(f"Found: {inst.address}:{inst.port}")
```

### 6.3.3 Kubernetes DNS

In Kubernetes, services are automatically discoverable via DNS.

```
┌─────────────────────────────────────────────────────────────┐
│              KUBERNETES SERVICE DISCOVERY                    │
│                                                              │
│   DNS Pattern:                                              │
│   <service-name>.<namespace>.svc.cluster.local              │
│                                                              │
│   Examples:                                                 │
│   user-service.default.svc.cluster.local                    │
│   order-service.production.svc.cluster.local                │
│                                                              │
│   ┌─────────────────────────────────────────────────────┐   │
│   │                  Kubernetes Cluster                  │   │
│   │                                                      │   │
│   │  ┌──────────────┐      ┌──────────────────────┐    │   │
│   │  │   Service    │      │     Pods              │    │   │
│   │  │ user-service │──────▶ user-service-pod-1   │    │   │
│   │  │ ClusterIP:   │      │ user-service-pod-2   │    │   │
│   │  │ 10.0.0.50    │      │ user-service-pod-3   │    │   │
│   │  └──────────────┘      └──────────────────────┘    │   │
│   │         ▲                                           │   │
│   │         │                                           │   │
│   │  ┌──────┴───────┐                                  │   │
│   │  │   CoreDNS    │                                  │   │
│   │  │ (DNS Server) │                                  │   │
│   │  └──────────────┘                                  │   │
│   │                                                      │   │
│   └─────────────────────────────────────────────────────┘   │
│                                                              │
│   From any pod, just call:                                  │
│   http://user-service:8080/users/123                        │
│   (Kubernetes handles the rest!)                            │
└─────────────────────────────────────────────────────────────┘
```

```python
# kubernetes_client.py
import os
import httpx

class KubernetesServiceClient:
    """
    In Kubernetes, services are discoverable via DNS.
    No explicit service discovery needed!
    """
    
    def __init__(self):
        # Get namespace from environment or mounted file
        self.namespace = os.getenv(
            "NAMESPACE",
            self._read_namespace()
        )
    
    def _read_namespace(self) -> str:
        """Read namespace from Kubernetes mounted file"""
        try:
            with open("/var/run/secrets/kubernetes.io/serviceaccount/namespace") as f:
                return f.read().strip()
        except FileNotFoundError:
            return "default"
    
    def get_service_url(self, service_name: str, port: int = 80) -> str:
        """
        Build URL for a Kubernetes service.
        Kubernetes DNS handles the resolution.
        """
        # Short form (same namespace)
        # return f"http://{service_name}:{port}"
        
        # Full form (cross-namespace)
        return f"http://{service_name}.{self.namespace}.svc.cluster.local:{port}"
    
    async def call_service(
        self, 
        service_name: str, 
        path: str,
        port: int = 80,
        **kwargs
    ):
        """Call a Kubernetes service"""
        url = f"{self.get_service_url(service_name, port)}{path}"
        
        async with httpx.AsyncClient() as client:
            response = await client.get(url, **kwargs)
            return response.json()

# Usage in a Pod
client = KubernetesServiceClient()

# Just call by service name - Kubernetes handles everything!
user = await client.call_service("user-service", "/users/123", port=8080)
```

---

## 6.4 Load Balancing

### 6.4.1 Load Balancing Layers

```
┌─────────────────────────────────────────────────────────────┐
│              LOAD BALANCING LAYERS                           │
│                                                              │
│  LAYER 4 (Transport - TCP/UDP)                              │
│  ──────────────────────────────                             │
│  ├── Works at TCP/UDP level                                 │
│  ├── Doesn't inspect content                                │
│  ├── Very fast (no parsing)                                 │
│  ├── Simple (IP + Port based routing)                       │
│  └── Examples: AWS NLB, HAProxy (TCP mode)                  │
│                                                              │
│  Client ──TCP──▶ [L4 LB] ──TCP──▶ Server                   │
│                    │                                         │
│           Routes based on:                                   │
│           IP, Port, Protocol                                 │
│                                                              │
│                                                              │
│  LAYER 7 (Application - HTTP)                               │
│  ────────────────────────────                               │
│  ├── Inspects HTTP content                                  │
│  ├── Smart routing (URL, headers, cookies)                  │
│  ├── SSL termination                                        │
│  ├── Caching, compression                                   │
│  └── Examples: Nginx, AWS ALB, HAProxy (HTTP mode)          │
│                                                              │
│  Client ──HTTP──▶ [L7 LB] ──HTTP──▶ Server                 │
│                     │                                        │
│           Routes based on:                                   │
│           URL path, Host header, Cookies,                    │
│           HTTP method, Custom headers                        │
│                                                              │
│                                                              │
│  When to use which?                                         │
│  ├── L4: Raw TCP, maximum performance, gRPC (initial)       │
│  └── L7: HTTP APIs, need content-based routing              │
└─────────────────────────────────────────────────────────────┘
```

### 6.4.2 Load Balancing Algorithms

```
┌─────────────────────────────────────────────────────────────┐
│           LOAD BALANCING ALGORITHMS                          │
│                                                              │
│  1. ROUND ROBIN                                             │
│  ─────────────────                                          │
│  Requests distributed sequentially                          │
│                                                              │
│  Request 1 → Server A                                       │
│  Request 2 → Server B                                       │
│  Request 3 → Server C                                       │
│  Request 4 → Server A (back to start)                       │
│                                                              │
│  Pros: Simple, even distribution                            │
│  Cons: Ignores server capacity/load                         │
│                                                              │
│                                                              │
│  2. WEIGHTED ROUND ROBIN                                    │
│  ────────────────────────                                   │
│  More powerful servers get more requests                    │
│                                                              │
│  Server A (weight: 3) → Gets 3 of every 6 requests         │
│  Server B (weight: 2) → Gets 2 of every 6 requests         │
│  Server C (weight: 1) → Gets 1 of every 6 requests         │
│                                                              │
│                                                              │
│  3. LEAST CONNECTIONS                                       │
│  ───────────────────────                                    │
│  Send to server with fewest active connections              │
│                                                              │
│  Server A: 5 connections  ← Next request goes here!        │
│  Server B: 12 connections                                   │
│  Server C: 8 connections                                    │
│                                                              │
│  Pros: Adapts to varying request times                      │
│  Cons: Requires tracking connection counts                  │
│                                                              │
│                                                              │
│  4. IP HASH (Sticky Sessions)                               │
│  ───────────────────────────                                │
│  Same client IP always goes to same server                  │
│                                                              │
│  Client 1.2.3.4 → hash() → Server A (always)               │
│  Client 5.6.7.8 → hash() → Server B (always)               │
│                                                              │
│  Pros: Session affinity without cookies                     │
│  Cons: Uneven distribution if IP distribution skewed        │
│                                                              │
│                                                              │
│  5. LEAST RESPONSE TIME                                     │
│  ─────────────────────────                                  │
│  Send to server with lowest latency                         │
│                                                              │
│  Server A: avg 50ms  ← Preferred!                          │
│  Server B: avg 120ms                                        │
│  Server C: avg 80ms                                         │
│                                                              │
│                                                              │
│  6. RANDOM                                                  │
│  ────────                                                   │
│  Pick a server randomly                                     │
│                                                              │
│  Simple but surprisingly effective with many servers!       │
└─────────────────────────────────────────────────────────────┘
```

### 6.4.3 Python Load Balancer Implementation

```python
# load_balancer.py
import random
import asyncio
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import List, Optional
import time
import httpx

@dataclass
class Server:
    address: str
    port: int
    weight: int = 1
    healthy: bool = True
    active_connections: int = 0
    response_times: List[float] = field(default_factory=list)
    
    @property
    def url(self) -> str:
        return f"http://{self.address}:{self.port}"
    
    @property
    def avg_response_time(self) -> float:
        if not self.response_times:
            return float('inf')
        return sum(self.response_times[-10:]) / len(self.response_times[-10:])

class LoadBalancer(ABC):
    def __init__(self, servers: List[Server]):
        self.servers = servers
    
    @abstractmethod
    def get_server(self) -> Optional[Server]:
        """Select a server based on the algorithm"""
        pass
    
    def get_healthy_servers(self) -> List[Server]:
        return [s for s in self.servers if s.healthy]

# ============== IMPLEMENTATIONS ==============

class RoundRobinBalancer(LoadBalancer):
    def __init__(self, servers: List[Server]):
        super().__init__(servers)
        self.current_index = 0
    
    def get_server(self) -> Optional[Server]:
        healthy = self.get_healthy_servers()
        if not healthy:
            return None
        
        server = healthy[self.current_index % len(healthy)]
        self.current_index += 1
        return server

class WeightedRoundRobinBalancer(LoadBalancer):
    def __init__(self, servers: List[Server]):
        super().__init__(servers)
        self.current_index = 0
        self.current_weight = 0
    
    def get_server(self) -> Optional[Server]:
        healthy = self.get_healthy_servers()
        if not healthy:
            return None
        
        max_weight = max(s.weight for s in healthy)
        gcd_weight = self._gcd_of_weights(healthy)
        
        while True:
            self.current_index = (self.current_index + 1) % len(healthy)
            
            if self.current_index == 0:
                self.current_weight -= gcd_weight
                if self.current_weight <= 0:
                    self.current_weight = max_weight
            
            server = healthy[self.current_index]
            if server.weight >= self.current_weight:
                return server
    
    def _gcd_of_weights(self, servers: List[Server]) -> int:
        from math import gcd
        weights = [s.weight for s in servers]
        result = weights[0]
        for w in weights[1:]:
            result = gcd(result, w)
        return result

class LeastConnectionsBalancer(LoadBalancer):
    def get_server(self) -> Optional[Server]:
        healthy = self.get_healthy_servers()
        if not healthy:
            return None
        
        return min(healthy, key=lambda s: s.active_connections)

class LeastResponseTimeBalancer(LoadBalancer):
    def get_server(self) -> Optional[Server]:
        healthy = self.get_healthy_servers()
        if not healthy:
            return None
        
        return min(healthy, key=lambda s: s.avg_response_time)

class IPHashBalancer(LoadBalancer):
    def get_server(self, client_ip: str) -> Optional[Server]:
        healthy = self.get_healthy_servers()
        if not healthy:
            return None
        
        hash_value = hash(client_ip)
        index = hash_value % len(healthy)
        return healthy[index]

class RandomBalancer(LoadBalancer):
    def get_server(self) -> Optional[Server]:
        healthy = self.get_healthy_servers()
        if not healthy:
            return None
        
        return random.choice(healthy)

# ============== HTTP CLIENT WITH LOAD BALANCING ==============

class LoadBalancedClient:
    def __init__(self, balancer: LoadBalancer):
        self.balancer = balancer
    
    async def request(
        self, 
        method: str, 
        path: str,
        **kwargs
    ) -> httpx.Response:
        """Make a request with automatic load balancing and retries"""
        
        max_retries = 3
        last_error = None
        
        for attempt in range(max_retries):
            server = self.balancer.get_server()
            if not server:
                raise Exception("No healthy servers available")
            
            server.active_connections += 1
            start_time = time.perf_counter()
            
            try:
                async with httpx.AsyncClient() as client:
                    response = await client.request(
                        method,
                        f"{server.url}{path}",
                        timeout=5.0,
                        **kwargs
                    )
                
                # Record response time
                elapsed = time.perf_counter() - start_time
                server.response_times.append(elapsed)
                
                return response
                
            except httpx.RequestError as e:
                last_error = e
                server.healthy = False  # Mark as unhealthy
                print(f"Server {server.url} failed, trying next...")
                continue
                
            finally:
                server.active_connections -= 1
        
        raise Exception(f"All retries failed: {last_error}")

# ============== USAGE ==============

async def main():
    # Create servers
    servers = [
        Server("localhost", 8001, weight=3),
        Server("localhost", 8002, weight=2),
        Server("localhost", 8003, weight=1),
    ]
    
    # Create load balancer
    balancer = LeastConnectionsBalancer(servers)
    client = LoadBalancedClient(balancer)
    
    # Make requests
    for i in range(10):
        try:
            response = await client.request("GET", "/users/123")
            print(f"Request {i}: {response.status_code}")
        except Exception as e:
            print(f"Request {i} failed: {e}")

# asyncio.run(main())
```

---

## 6.5 Health Checks

### Types of Health Checks

```
┌─────────────────────────────────────────────────────────────┐
│                    HEALTH CHECK TYPES                        │
│                                                              │
│  1. LIVENESS PROBE                                          │
│  ─────────────────                                          │
│  "Is the application running?"                              │
│                                                              │
│  Check: Process is alive, can respond to basic requests     │
│  Action on failure: Restart the container/service           │
│                                                              │
│  GET /health/live → 200 OK                                  │
│                                                              │
│                                                              │
│  2. READINESS PROBE                                         │
│  ──────────────────                                         │
│  "Is the application ready to receive traffic?"             │
│                                                              │
│  Check: Dependencies connected, warmup complete             │
│  Action on failure: Remove from load balancer (don't kill)  │
│                                                              │
│  GET /health/ready → 200 OK (if ready)                      │
│                    → 503 Service Unavailable (if not)       │
│                                                              │
│                                                              │
│  3. STARTUP PROBE                                           │
│  ─────────────────                                          │
│  "Has the application finished starting?"                   │
│                                                              │
│  Check: Initial setup complete                              │
│  Action on failure: Keep trying (slow-starting apps)        │
│                                                              │
│                                                              │
│  Why separate liveness and readiness?                       │
│  ─────────────────────────────────────                      │
│  Scenario: Database connection temporarily lost             │
│                                                              │
│  Readiness: FAIL → Stop sending traffic (correct!)          │
│  Liveness: PASS → Don't restart (correct!)                  │
│                                                              │
│  If only liveness: Would restart healthy app unnecessarily  │
└─────────────────────────────────────────────────────────────┘
```

### Implementation

```python
# health_checks.py
from fastapi import FastAPI, HTTPException, Response
from enum import Enum
import asyncio
import redis.asyncio as redis
import asyncpg
from dataclasses import dataclass
from typing import Dict, Optional
import time

class HealthStatus(str, Enum):
    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"
    DEGRADED = "degraded"

@dataclass
class DependencyHealth:
    name: str
    status: HealthStatus
    latency_ms: Optional[float] = None
    error: Optional[str] = None

class HealthChecker:
    def __init__(self):
        self.redis_client: Optional[redis.Redis] = None
        self.db_pool: Optional[asyncpg.Pool] = None
        self.startup_complete = False
        self.startup_time = time.time()
    
    async def initialize(self):
        """Initialize connections (call on startup)"""
        self.redis_client = redis.Redis(host='localhost', port=6379)
        self.db_pool = await asyncpg.create_pool(
            "postgresql://localhost/mydb",
            min_size=1,
            max_size=5
        )
        self.startup_complete = True
    
    async def check_redis(self) -> DependencyHealth:
        """Check Redis connectivity"""
        start = time.perf_counter()
        try:
            await asyncio.wait_for(
                self.redis_client.ping(),
                timeout=2.0
            )
            latency = (time.perf_counter() - start) * 1000
            return DependencyHealth(
                name="redis",
                status=HealthStatus.HEALTHY,
                latency_ms=latency
            )
        except Exception as e:
            return DependencyHealth(
                name="redis",
                status=HealthStatus.UNHEALTHY,
                error=str(e)
            )
    
    async def check_database(self) -> DependencyHealth:
        """Check database connectivity"""
        start = time.perf_counter()
        try:
            async with self.db_pool.acquire() as conn:
                await asyncio.wait_for(
                    conn.fetchval("SELECT 1"),
                    timeout=2.0
                )
            latency = (time.perf_counter() - start) * 1000
            return DependencyHealth(
                name="postgresql",
                status=HealthStatus.HEALTHY,
                latency_ms=latency
            )
        except Exception as e:
            return DependencyHealth(
                name="postgresql",
                status=HealthStatus.UNHEALTHY,
                error=str(e)
            )
    
    async def check_all(self) -> Dict[str, DependencyHealth]:
        """Check all dependencies concurrently"""
        results = await asyncio.gather(
            self.check_redis(),
            self.check_database(),
            return_exceptions=True
        )
        
        return {
            "redis": results[0] if not isinstance(results[0], Exception) 
                     else DependencyHealth("redis", HealthStatus.UNHEALTHY, error=str(results[0])),
            "postgresql": results[1] if not isinstance(results[1], Exception)
                         else DependencyHealth("postgresql", HealthStatus.UNHEALTHY, error=str(results[1]))
        }

# FastAPI integration
app = FastAPI()
health_checker = HealthChecker()

@app.on_event("startup")
async def startup():
    await health_checker.initialize()

# ============== HEALTH ENDPOINTS ==============

@app.get("/health/live")
async def liveness():
    """
    Liveness probe - is the process running?
    Should almost always return 200 unless catastrophically broken.
    """
    return {"status": "alive"}

@app.get("/health/ready")
async def readiness(response: Response):
    """
    Readiness probe - can we handle traffic?
    Checks all critical dependencies.
    """
    if not health_checker.startup_complete:
        response.status_code = 503
        return {
            "status": "not_ready",
            "reason": "startup_incomplete"
        }
    
    checks = await health_checker.check_all()
    
    # All must be healthy for readiness
    all_healthy = all(
        c.status == HealthStatus.HEALTHY 
        for c in checks.values()
    )
    
    if not all_healthy:
        response.status_code = 503
    
    return {
        "status": "ready" if all_healthy else "not_ready",
        "checks": {
            name: {
                "status": check.status.value,
                "latency_ms": check.latency_ms,
                "error": check.error
            }
            for name, check in checks.items()
        }
    }

@app.get("/health/startup")
async def startup_probe(response: Response):
    """
    Startup probe - has initial startup completed?
    Used for slow-starting applications.
    """
    # Allow 60 seconds for startup
    max_startup_time = 60
    elapsed = time.time() - health_checker.startup_time
    
    if not health_checker.startup_complete:
        if elapsed > max_startup_time:
            response.status_code = 503
            return {"status": "startup_timeout"}
        
        response.status_code = 503
        return {"status": "starting", "elapsed_seconds": elapsed}
    
    return {"status": "started", "startup_duration_seconds": elapsed}

@app.get("/health")
async def detailed_health():
    """
    Detailed health check for monitoring/debugging.
    Not used by orchestrators - too slow.
    """
    checks = await health_checker.check_all()
    
    return {
        "service": "user-service",
        "version": "1.0.0",
        "uptime_seconds": time.time() - health_checker.startup_time,
        "dependencies": {
            name: {
                "status": check.status.value,
                "latency_ms": check.latency_ms,
                "error": check.error
            }
            for name, check in checks.items()
        }
    }
```

---

## 6.6 Putting It All Together

### Complete Service with Discovery, Load Balancing, and Health Checks

```python
# complete_service.py
from fastapi import FastAPI, Request, Response
from contextlib import asynccontextmanager
import httpx
import asyncio
from typing import List
import random
import time

# Configuration
SERVICE_NAME = "order-service"
SERVICE_PORT = 8000

# ============== SERVICE REGISTRY ==============

class InMemoryRegistry:
    """Simple registry for demo (use Consul/etcd in production)"""
    _services: dict = {}
    
    @classmethod
    def register(cls, name: str, address: str, port: int):
        if name not in cls._services:
            cls._services[name] = []
        cls._services[name].append({"address": address, "port": port})
    
    @classmethod
    def deregister(cls, name: str, address: str, port: int):
        if name in cls._services:
            cls._services[name] = [
                s for s in cls._services[name]
                if not (s["address"] == address and s["port"] == port)
            ]
    
    @classmethod
    def discover(cls, name: str) -> List[dict]:
        return cls._services.get(name, [])

# ============== LOAD BALANCED CLIENT ==============

class ServiceClient:
    def __init__(self):
        self.client = httpx.AsyncClient(timeout=5.0)
    
    async def call(
        self, 
        service_name: str, 
        method: str, 
        path: str,
        **kwargs
    ):
        instances = InMemoryRegistry.discover(service_name)
        
        if not instances:
            raise Exception(f"No instances of {service_name} found")
        
        # Simple random load balancing
        instance = random.choice(instances)
        url = f"http://{instance['address']}:{instance['port']}{path}"
        
        # Retry logic
        for attempt in range(3):
            try:
                response = await self.client.request(method, url, **kwargs)
                return response.json()
            except httpx.RequestError as e:
                if attempt == 2:
                    raise
                await asyncio.sleep(0.5 * (attempt + 1))
    
    async def close(self):
        await self.client.aclose()

# ============== APPLICATION ==============

service_client = ServiceClient()

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup: Register with service registry
    InMemoryRegistry.register(SERVICE_NAME, "localhost", SERVICE_PORT)
    print(f"Registered {SERVICE_NAME} at localhost:{SERVICE_PORT}")
    
    yield
    
    # Shutdown: Deregister
    InMemoryRegistry.deregister(SERVICE_NAME, "localhost", SERVICE_PORT)
    await service_client.close()
    print(f"Deregistered {SERVICE_NAME}")

app = FastAPI(title=SERVICE_NAME, lifespan=lifespan)

# Health checks
@app.get("/health/live")
async def liveness():
    return {"status": "alive"}

@app.get("/health/ready")
async def readiness():
    return {"status": "ready"}

# Business endpoints
@app.post("/orders")
async def create_order(request: Request):
    order_data = await request.json()
    
    # Call user service (discovered via registry)
    user = await service_client.call(
        "user-service", 
        "GET", 
        f"/users/{order_data['user_id']}"
    )
    
    # Call product service
    product = await service_client.call(
        "product-service",
        "GET",
        f"/products/{order_data['product_id']}"
    )
    
    return {
        "order_id": "ord_123",
        "user": user,
        "product": product,
        "status": "created"
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=SERVICE_PORT)
```

---

## Summary

| Component | Purpose | Tools |
|-----------|---------|-------|
| **Service Discovery** | Find service instances | Consul, etcd, K8s DNS |
| **Load Balancing** | Distribute traffic | Nginx, HAProxy, ALB |
| **Health Checks** | Verify service health | Liveness/Readiness probes |

### Key Takeaways

1. **Never hardcode IPs** - use service discovery
2. **Choose the right LB algorithm** - least connections for varying workloads
3. **Separate liveness from readiness** - they serve different purposes
4. **Health checks should be fast** - don't include heavy operations
5. **Use circuit breakers** - prevent cascade failures

---

## Practice Exercises

1. Set up Consul locally and register/discover services
2. Implement a round-robin load balancer
3. Add comprehensive health checks to your FastAPI app
4. Build a client that handles service discovery and retries
5. Test failure scenarios: What happens when services go down?

**Next Chapter**: Data management in distributed systems - replication, partitioning, and consistency!
