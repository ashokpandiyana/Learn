# Chapter 14: Microservices Architecture

> **Goal**: Understand how to design, build, and operate microservices-based systems

---

## 14.1 Monolith vs Microservices

### The Evolution

```
┌─────────────────────────────────────────────────────────────┐
│          MONOLITH vs MICROSERVICES                           │
│                                                              │
│  MONOLITH                                                   │
│  ─────────                                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                   Single Application                 │   │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌────────┐ │   │
│  │  │  User   │  │  Order  │  │ Payment │  │Shipping│ │   │
│  │  │ Module  │  │ Module  │  │ Module  │  │ Module │ │   │
│  │  └────┬────┘  └────┬────┘  └────┬────┘  └────┬───┘ │   │
│  │       │            │            │            │      │   │
│  │       └────────────┴────────────┴────────────┘      │   │
│  │                         │                            │   │
│  │                    ┌────┴────┐                       │   │
│  │                    │   DB    │                       │   │
│  │                    └─────────┘                       │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                              │
│  Pros: Simple, easy debugging, ACID transactions            │
│  Cons: Scaling is all-or-nothing, one bug crashes all      │
│                                                              │
│                                                              │
│  MICROSERVICES                                              │
│  ─────────────                                              │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │   User   │  │  Order   │  │ Payment  │  │ Shipping │   │
│  │ Service  │  │ Service  │  │ Service  │  │ Service  │   │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘   │
│       │             │             │             │          │
│  ┌────┴────┐   ┌────┴────┐   ┌────┴────┐   ┌────┴────┐   │
│  │User DB  │   │Order DB │   │Payment  │   │Shipping │   │
│  │         │   │         │   │DB       │   │DB       │   │
│  └─────────┘   └─────────┘   └─────────┘   └─────────┘   │
│                                                              │
│  Pros: Independent scaling/deployment, technology freedom   │
│  Cons: Distributed system complexity, eventual consistency  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### When to Use Microservices

```
┌─────────────────────────────────────────────────────────────┐
│         WHEN TO USE MICROSERVICES?                           │
│                                                              │
│  ✅ USE MICROSERVICES WHEN:                                 │
│  ──────────────────────────                                 │
│  ├── Large team (can't all work on one codebase)            │
│  ├── Different scaling needs (some parts need more)         │
│  ├── Different technology needs (ML in Python, API in Go)   │
│  ├── Independent deployment needed (release often)          │
│  ├── Fault isolation needed (one failure ≠ all down)        │
│  └── Clear domain boundaries exist                          │
│                                                              │
│                                                              │
│  ❌ DON'T USE MICROSERVICES WHEN:                           │
│  ────────────────────────────────                           │
│  ├── Small team (< 5-10 engineers)                          │
│  ├── New product (don't know boundaries yet)                │
│  ├── Simple domain (CRUD app)                               │
│  ├── Strong consistency required (transactions)             │
│  └── Limited DevOps capability                              │
│                                                              │
│                                                              │
│  ⚠️ THE MICROSERVICES PREMIUM:                              │
│  ─────────────────────────────                              │
│  Microservices add operational complexity:                  │
│  ├── Service discovery                                      │
│  ├── Load balancing                                         │
│  ├── Distributed tracing                                    │
│  ├── Configuration management                               │
│  ├── Container orchestration                                │
│  └── More infrastructure to maintain                        │
│                                                              │
│  Start with monolith, extract services when needed!         │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 14.2 Service Boundaries

### Domain-Driven Design (DDD)

```
┌─────────────────────────────────────────────────────────────┐
│              DOMAIN-DRIVEN DESIGN                            │
│                                                              │
│  Key Concept: BOUNDED CONTEXT                               │
│  ─────────────────────────────                              │
│                                                              │
│  A bounded context is a boundary within which a domain      │
│  model is defined and applicable.                           │
│                                                              │
│  Example: "Customer" means different things:                │
│                                                              │
│  ┌─────────────────┐    ┌─────────────────┐               │
│  │  Sales Context  │    │ Support Context │               │
│  │                 │    │                 │               │
│  │  Customer:      │    │  Customer:      │               │
│  │  - Name         │    │  - Name         │               │
│  │  - Email        │    │  - Email        │               │
│  │  - CreditLimit  │    │  - TicketCount  │               │
│  │  - SalesRep     │    │  - SupportTier  │               │
│  │                 │    │  - LastContact  │               │
│  └─────────────────┘    └─────────────────┘               │
│                                                              │
│  Same name, different meanings = different bounded contexts │
│  Each bounded context = potential microservice!             │
│                                                              │
│                                                              │
│  Finding Bounded Contexts:                                  │
│  ─────────────────────────                                  │
│  1. Look for different language/terminology                 │
│  2. Look for different rules/behavior                       │
│  3. Look for different data models                          │
│  4. Look for organizational boundaries (Conway's Law)       │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Service Design Principles

```python
# service_design.py
"""
Principles for designing microservice boundaries.
"""

# ============== PRINCIPLE 1: SINGLE RESPONSIBILITY ==============
# Each service should do ONE thing well

# ❌ BAD: Kitchen sink service
class EverythingService:
    def create_user(self): pass
    def process_payment(self): pass
    def send_email(self): pass
    def generate_report(self): pass

# ✅ GOOD: Focused services
class UserService:
    def create_user(self): pass
    def update_user(self): pass
    def delete_user(self): pass

class PaymentService:
    def process_payment(self): pass
    def refund_payment(self): pass


# ============== PRINCIPLE 2: OWN YOUR DATA ==============
# Each service has its own database - no sharing!

# ❌ BAD: Shared database
"""
UserService ─────┐
                 ├────▶ [Shared Database]
OrderService ────┘

Problem: Services are coupled through the database!
Changes to schema affect multiple services.
"""

# ✅ GOOD: Database per service
"""
UserService ────▶ [User DB]
OrderService ───▶ [Order DB]

Communication through APIs only!
"""


# ============== PRINCIPLE 3: SMART ENDPOINTS, DUMB PIPES ==============
# Services are smart; communication is simple

# ❌ BAD: Logic in message broker
"""
Heavy transformation and routing in ESB/message broker.
Services become dumb.
"""

# ✅ GOOD: Simple communication
"""
Services contain all business logic.
Communication is just HTTP/gRPC/messages.
"""

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Order(BaseModel):
    user_id: int
    items: list
    total: float

@app.post("/orders")
async def create_order(order: Order):
    # All logic in the service
    validated = validate_order(order)
    enriched = enrich_with_user_data(validated)
    saved = save_to_database(enriched)
    publish_event("order.created", saved)
    return saved


# ============== PRINCIPLE 4: DESIGN FOR FAILURE ==============
# Assume other services WILL fail

import httpx
from tenacity import retry, stop_after_attempt, wait_exponential

class UserServiceClient:
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.client = httpx.AsyncClient(timeout=5.0)
    
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(min=1, max=10)
    )
    async def get_user(self, user_id: int):
        """Retry on failure with exponential backoff"""
        response = await self.client.get(f"{self.base_url}/users/{user_id}")
        response.raise_for_status()
        return response.json()
    
    async def get_user_with_fallback(self, user_id: int):
        """Return cached/default data if service is down"""
        try:
            return await self.get_user(user_id)
        except Exception:
            # Return cached or default data
            return {"id": user_id, "name": "Unknown", "cached": True}


# ============== PRINCIPLE 5: LOOSE COUPLING ==============
# Services should be independently deployable

# ❌ BAD: Tight coupling (synchronous chain)
async def create_order_bad(order):
    user = await user_service.get_user(order.user_id)  # Sync
    inventory = await inventory_service.reserve(order.items)  # Sync
    payment = await payment_service.charge(order.total)  # Sync
    shipping = await shipping_service.schedule(order)  # Sync
    # If any fails, entire chain fails!

# ✅ GOOD: Loose coupling (event-driven)
async def create_order_good(order):
    # Create order in pending state
    saved_order = await save_order(order, status="pending")
    
    # Publish event - other services react asynchronously
    await publish_event("order.created", {
        "order_id": saved_order.id,
        "user_id": order.user_id,
        "items": order.items,
        "total": order.total
    })
    
    return saved_order
    # Inventory, Payment, Shipping services listen and act independently
```

---

## 14.3 API Gateway Pattern

```
┌─────────────────────────────────────────────────────────────┐
│                  API GATEWAY PATTERN                         │
│                                                              │
│  Problem: Clients need to know about all services           │
│  ──────────────────────────────────────────────            │
│                                                              │
│  Without Gateway:                                           │
│  ┌────────────┐                                            │
│  │   Client   │                                            │
│  └─────┬──────┘                                            │
│        │                                                    │
│        ├────────────▶ User Service (auth)                  │
│        ├────────────▶ Order Service                        │
│        ├────────────▶ Product Service                      │
│        └────────────▶ Payment Service                      │
│                                                              │
│  Client must know ALL service URLs, handle auth everywhere  │
│                                                              │
│                                                              │
│  With Gateway:                                              │
│  ┌────────────┐                                            │
│  │   Client   │                                            │
│  └─────┬──────┘                                            │
│        │                                                    │
│        ▼                                                    │
│  ┌────────────────────────────────────────────────────┐   │
│  │                   API GATEWAY                       │   │
│  │                                                     │   │
│  │  • Authentication/Authorization                     │   │
│  │  • Rate Limiting                                    │   │
│  │  • Request Routing                                  │   │
│  │  • Load Balancing                                   │   │
│  │  • Response Caching                                 │   │
│  │  • Request/Response Transformation                  │   │
│  │  • SSL Termination                                  │   │
│  │  • Logging/Monitoring                               │   │
│  └─────────────────────┬──────────────────────────────┘   │
│                        │                                    │
│        ┌───────────────┼───────────────┐                   │
│        ▼               ▼               ▼                    │
│  ┌──────────┐   ┌──────────┐   ┌──────────┐              │
│  │  User    │   │  Order   │   │ Product  │              │
│  │ Service  │   │ Service  │   │ Service  │              │
│  └──────────┘   └──────────┘   └──────────┘              │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### API Gateway Implementation

```python
# api_gateway.py
from fastapi import FastAPI, Request, HTTPException, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.responses import JSONResponse
import httpx
import asyncio
import time
from typing import Dict, Optional
from dataclasses import dataclass, field
import jwt

app = FastAPI(title="API Gateway")
security = HTTPBearer()

# ============== SERVICE REGISTRY ==============

SERVICES = {
    "users": "http://user-service:8001",
    "orders": "http://order-service:8002",
    "products": "http://product-service:8003",
    "payments": "http://payment-service:8004",
}

# ============== RATE LIMITING ==============

@dataclass
class RateLimiter:
    """Token bucket rate limiter"""
    requests_per_minute: int = 100
    buckets: Dict[str, list] = field(default_factory=dict)
    
    def is_allowed(self, client_id: str) -> bool:
        now = time.time()
        minute_ago = now - 60
        
        if client_id not in self.buckets:
            self.buckets[client_id] = []
        
        # Remove old requests
        self.buckets[client_id] = [
            t for t in self.buckets[client_id] if t > minute_ago
        ]
        
        if len(self.buckets[client_id]) >= self.requests_per_minute:
            return False
        
        self.buckets[client_id].append(now)
        return True

rate_limiter = RateLimiter()

# ============== AUTHENTICATION ==============

SECRET_KEY = "your-secret-key"

async def verify_token(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> dict:
    """Verify JWT token and return payload"""
    try:
        payload = jwt.decode(
            credentials.credentials,
            SECRET_KEY,
            algorithms=["HS256"]
        )
        return payload
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")

# ============== REQUEST ROUTING ==============

async def proxy_request(
    service: str,
    path: str,
    request: Request,
    method: str = "GET",
    body: dict = None
) -> dict:
    """Proxy request to backend service"""
    if service not in SERVICES:
        raise HTTPException(status_code=404, detail=f"Service {service} not found")
    
    url = f"{SERVICES[service]}{path}"
    
    async with httpx.AsyncClient(timeout=30.0) as client:
        # Forward headers (except host)
        headers = {
            k: v for k, v in request.headers.items()
            if k.lower() not in ["host", "content-length"]
        }
        
        try:
            if method == "GET":
                response = await client.get(url, headers=headers)
            elif method == "POST":
                response = await client.post(url, json=body, headers=headers)
            elif method == "PUT":
                response = await client.put(url, json=body, headers=headers)
            elif method == "DELETE":
                response = await client.delete(url, headers=headers)
            else:
                raise HTTPException(status_code=405)
            
            return response.json()
            
        except httpx.TimeoutException:
            raise HTTPException(status_code=504, detail="Service timeout")
        except httpx.RequestError as e:
            raise HTTPException(status_code=503, detail=f"Service unavailable: {e}")

# ============== GATEWAY ENDPOINTS ==============

@app.middleware("http")
async def rate_limit_middleware(request: Request, call_next):
    """Apply rate limiting to all requests"""
    client_ip = request.client.host
    
    if not rate_limiter.is_allowed(client_ip):
        return JSONResponse(
            status_code=429,
            content={"detail": "Rate limit exceeded"}
        )
    
    response = await call_next(request)
    return response

# Users routes
@app.get("/api/users/{user_id}")
async def get_user(user_id: int, request: Request, token: dict = Depends(verify_token)):
    return await proxy_request("users", f"/users/{user_id}", request)

@app.post("/api/users")
async def create_user(request: Request, token: dict = Depends(verify_token)):
    body = await request.json()
    return await proxy_request("users", "/users", request, "POST", body)

# Orders routes
@app.get("/api/orders/{order_id}")
async def get_order(order_id: int, request: Request, token: dict = Depends(verify_token)):
    return await proxy_request("orders", f"/orders/{order_id}", request)

@app.post("/api/orders")
async def create_order(request: Request, token: dict = Depends(verify_token)):
    body = await request.json()
    return await proxy_request("orders", "/orders", request, "POST", body)

# ============== AGGREGATION ENDPOINT ==============
# Combine data from multiple services in one response

@app.get("/api/users/{user_id}/profile")
async def get_user_profile(
    user_id: int, 
    request: Request, 
    token: dict = Depends(verify_token)
):
    """
    Aggregate endpoint - combines user data with their orders.
    Reduces client round-trips.
    """
    # Parallel requests to multiple services
    async with httpx.AsyncClient(timeout=10.0) as client:
        user_task = client.get(f"{SERVICES['users']}/users/{user_id}")
        orders_task = client.get(f"{SERVICES['orders']}/users/{user_id}/orders")
        
        user_response, orders_response = await asyncio.gather(
            user_task, orders_task,
            return_exceptions=True
        )
    
    # Build aggregated response
    result = {"user": None, "orders": []}
    
    if not isinstance(user_response, Exception):
        result["user"] = user_response.json()
    
    if not isinstance(orders_response, Exception):
        result["orders"] = orders_response.json()
    
    return result

# ============== HEALTH CHECK ==============

@app.get("/health")
async def health_check():
    """Check gateway and all backend services"""
    results = {"gateway": "healthy", "services": {}}
    
    async with httpx.AsyncClient(timeout=5.0) as client:
        for name, url in SERVICES.items():
            try:
                response = await client.get(f"{url}/health")
                results["services"][name] = "healthy" if response.status_code == 200 else "unhealthy"
            except Exception:
                results["services"][name] = "unreachable"
    
    return results
```

---

## 14.4 Service Mesh

```
┌─────────────────────────────────────────────────────────────┐
│                    SERVICE MESH                              │
│                                                              │
│  What is it?                                                │
│  ───────────                                                │
│  Infrastructure layer that handles service-to-service       │
│  communication. Offloads networking concerns from services. │
│                                                              │
│                                                              │
│  Without Service Mesh:                                      │
│  ─────────────────────                                      │
│  Each service implements:                                   │
│  ├── Service discovery                                      │
│  ├── Load balancing                                         │
│  ├── Retries/timeouts                                       │
│  ├── Circuit breakers                                       │
│  ├── mTLS                                                   │
│  └── Metrics/tracing                                        │
│                                                              │
│  Duplicated code in every service!                          │
│                                                              │
│                                                              │
│  With Service Mesh:                                         │
│  ──────────────────                                         │
│                                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                   CONTROL PLANE                      │   │
│  │         (Istio, Linkerd, Consul Connect)            │   │
│  │                                                      │   │
│  │  • Configuration                                     │   │
│  │  • Service Discovery                                 │   │
│  │  • Certificate Management                            │   │
│  │  • Policy Enforcement                                │   │
│  └──────────────────────┬──────────────────────────────┘   │
│                         │                                    │
│         ┌───────────────┼───────────────┐                   │
│         ▼               ▼               ▼                    │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │┌───────────┐│ │┌───────────┐│ │┌───────────┐│          │
│  ││  Sidecar  ││ ││  Sidecar  ││ ││  Sidecar  ││          │
│  ││  Proxy    ││ ││  Proxy    ││ ││  Proxy    ││          │
│  │└─────┬─────┘│ │└─────┬─────┘│ │└─────┬─────┘│          │
│  │      │      │ │      │      │ │      │      │          │
│  │┌─────┴─────┐│ │┌─────┴─────┐│ │┌─────┴─────┐│          │
│  ││  Service  ││ ││  Service  ││ ││  Service  ││          │
│  ││     A     ││ ││     B     ││ ││     C     ││          │
│  │└───────────┘│ │└───────────┘│ │└───────────┘│          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
│       Pod            Pod             Pod                    │
│                                                              │
│  Sidecar Proxy (Envoy) handles all networking!             │
│  Service just makes localhost calls.                        │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Service Mesh Features

```
┌─────────────────────────────────────────────────────────────┐
│              SERVICE MESH FEATURES                           │
│                                                              │
│  1. TRAFFIC MANAGEMENT                                      │
│  ─────────────────────                                      │
│  • Load balancing (round-robin, least-conn, etc.)          │
│  • Traffic splitting (canary deployments)                   │
│  • Retries and timeouts                                     │
│  • Circuit breakers                                         │
│  • Rate limiting                                            │
│                                                              │
│  2. SECURITY                                                │
│  ────────────                                               │
│  • Mutual TLS (mTLS) - encrypted service-to-service        │
│  • Authentication (who are you?)                            │
│  • Authorization (what can you do?)                         │
│  • Certificate rotation                                     │
│                                                              │
│  3. OBSERVABILITY                                           │
│  ─────────────────                                          │
│  • Distributed tracing                                      │
│  • Metrics collection                                       │
│  • Access logging                                           │
│  • Health checking                                          │
│                                                              │
│                                                              │
│  Popular Service Meshes:                                    │
│  ├── Istio (most features, complex)                         │
│  ├── Linkerd (simpler, Rust-based)                          │
│  └── Consul Connect (HashiCorp ecosystem)                   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 14.5 Backend for Frontend (BFF)

```
┌─────────────────────────────────────────────────────────────┐
│              BACKEND FOR FRONTEND (BFF)                      │
│                                                              │
│  Problem: Different clients need different data formats     │
│  ────────────────────────────────────────────────          │
│                                                              │
│  Mobile app: Needs minimal data (bandwidth)                 │
│  Web app: Needs rich data (desktop has bandwidth)           │
│  Admin app: Needs detailed data                             │
│                                                              │
│                                                              │
│  Solution: Separate BFF per client type                     │
│  ──────────────────────────────────────                     │
│                                                              │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐                 │
│  │  Mobile  │  │   Web    │  │  Admin   │                 │
│  │   App    │  │   App    │  │   App    │                 │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘                 │
│       │             │             │                         │
│       ▼             ▼             ▼                         │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐                    │
│  │ Mobile  │  │   Web   │  │  Admin  │                    │
│  │   BFF   │  │   BFF   │  │   BFF   │                    │
│  └────┬────┘  └────┬────┘  └────┬────┘                    │
│       │            │            │                          │
│       └────────────┼────────────┘                          │
│                    │                                        │
│       ┌────────────┼────────────┐                          │
│       ▼            ▼            ▼                           │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐                      │
│  │  User   │ │  Order  │ │ Product │                      │
│  │ Service │ │ Service │ │ Service │                      │
│  └─────────┘ └─────────┘ └─────────┘                      │
│                                                              │
│                                                              │
│  Each BFF:                                                  │
│  ├── Optimized for specific client                          │
│  ├── Aggregates data from multiple services                 │
│  ├── Transforms data to client format                       │
│  └── Can be owned by client team                            │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

```python
# bff_mobile.py
"""
Mobile BFF - Optimized for mobile clients
Returns minimal data, handles pagination differently
"""
from fastapi import FastAPI
import httpx

app = FastAPI(title="Mobile BFF")

USER_SERVICE = "http://user-service:8001"
ORDER_SERVICE = "http://order-service:8002"
PRODUCT_SERVICE = "http://product-service:8003"

@app.get("/api/home")
async def get_home_screen():
    """
    Mobile home screen - aggregated, minimal data.
    Single request instead of multiple.
    """
    async with httpx.AsyncClient(timeout=10.0) as client:
        # Fetch only what mobile needs
        user = await client.get(f"{USER_SERVICE}/users/me")
        recent_orders = await client.get(f"{ORDER_SERVICE}/orders?limit=3")
        featured = await client.get(f"{PRODUCT_SERVICE}/products/featured?limit=4")
    
    # Transform for mobile
    return {
        "user": {
            "name": user.json()["name"],
            "avatar_url": user.json()["avatar_url"]  # Just essentials
        },
        "recent_orders": [
            {
                "id": o["id"],
                "status": o["status"],
                "total": o["total"]
                # Omit detailed items for mobile
            }
            for o in recent_orders.json()[:3]
        ],
        "featured_products": [
            {
                "id": p["id"],
                "name": p["name"],
                "price": p["price"],
                "thumbnail": p["images"][0]["thumbnail"]  # Small image
            }
            for p in featured.json()[:4]
        ]
    }

@app.get("/api/products/{product_id}")
async def get_product_mobile(product_id: int):
    """Product detail - mobile optimized"""
    async with httpx.AsyncClient() as client:
        product = await client.get(f"{PRODUCT_SERVICE}/products/{product_id}")
        data = product.json()
    
    # Return mobile-friendly version
    return {
        "id": data["id"],
        "name": data["name"],
        "price": data["price"],
        "description": data["description"][:200],  # Truncated
        "images": [img["mobile"] for img in data["images"][:3]],  # Mobile-sized
        "in_stock": data["inventory"] > 0
    }


# bff_web.py
"""
Web BFF - Optimized for web clients
Returns rich data, includes more details
"""
from fastapi import FastAPI
import httpx

app = FastAPI(title="Web BFF")

@app.get("/api/products/{product_id}")
async def get_product_web(product_id: int):
    """Product detail - web optimized with rich data"""
    async with httpx.AsyncClient() as client:
        # Fetch more data for web
        product = await client.get(f"{PRODUCT_SERVICE}/products/{product_id}")
        reviews = await client.get(f"{PRODUCT_SERVICE}/products/{product_id}/reviews")
        related = await client.get(f"{PRODUCT_SERVICE}/products/{product_id}/related")
        
    data = product.json()
    
    # Return rich web version
    return {
        "id": data["id"],
        "name": data["name"],
        "price": data["price"],
        "description": data["description"],  # Full description
        "specifications": data["specifications"],  # Full specs
        "images": [img["full"] for img in data["images"]],  # Full-sized
        "inventory": data["inventory"],
        "reviews": {
            "average": reviews.json()["average_rating"],
            "count": reviews.json()["total"],
            "recent": reviews.json()["reviews"][:5]
        },
        "related_products": related.json()[:8]
    }
```

---

## 14.6 Communication Patterns

```
┌─────────────────────────────────────────────────────────────┐
│         MICROSERVICE COMMUNICATION PATTERNS                  │
│                                                              │
│  1. SYNCHRONOUS (Request/Response)                          │
│  ──────────────────────────────────                         │
│                                                              │
│  Service A ───HTTP/gRPC───▶ Service B                       │
│            ◀──Response────                                  │
│                                                              │
│  Use for: Queries, real-time needs                          │
│  Risk: Cascading failures, latency chains                   │
│                                                              │
│                                                              │
│  2. ASYNCHRONOUS (Events/Messages)                          │
│  ──────────────────────────────────                         │
│                                                              │
│  Service A ───Event───▶ [Message Broker] ───▶ Service B    │
│                                           ───▶ Service C    │
│                                                              │
│  Use for: Commands, notifications, decoupling               │
│  Benefit: Resilient, scalable                               │
│                                                              │
│                                                              │
│  RECOMMENDATION:                                            │
│  ─────────────────                                          │
│  ├── Queries: Synchronous (need immediate answer)           │
│  ├── Commands: Asynchronous (can be processed later)        │
│  └── Events: Asynchronous (notify about what happened)      │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## Summary

| Pattern | Use When | Trade-offs |
|---------|----------|------------|
| **API Gateway** | Single entry point needed | Can become bottleneck |
| **Service Mesh** | Complex networking needs | Operational complexity |
| **BFF** | Different client needs | More services to maintain |
| **Events** | Loose coupling needed | Eventual consistency |

---

## Practice Exercises

1. Design service boundaries for an e-commerce system
2. Implement an API gateway with rate limiting
3. Create separate BFFs for mobile and web
4. Set up event-driven communication between services
5. Deploy services with a service mesh (Linkerd/Istio)

**Next Chapter**: Reliability Patterns - Circuit Breakers, Retries, and more!
