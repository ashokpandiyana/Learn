# Chapter 11: Time and Ordering

> **Goal**: Understand why time is problematic in distributed systems and how to establish ordering

---

## 11.1 The Problem with Time

```
┌─────────────────────────────────────────────────────────────┐
│              WHY TIME IS HARD                                │
│                                                              │
│  In a single computer:                                      │
│  ─────────────────────                                      │
│  One clock, one timeline. Easy!                             │
│  if (event_a.time < event_b.time) → A happened before B    │
│                                                              │
│                                                              │
│  In distributed systems:                                    │
│  ───────────────────────                                    │
│  Multiple clocks, NO global time!                           │
│                                                              │
│  Server A Clock: 10:00:00.000                               │
│  Server B Clock: 10:00:00.050  (50ms ahead - clock skew)   │
│  Server C Clock: 09:59:59.980  (20ms behind)               │
│                                                              │
│                                                              │
│  The Problem:                                               │
│  ────────────                                               │
│                                                              │
│  Server A (10:00:00.000): "User balance = $100"            │
│  Server B (10:00:00.050): "User balance = $50"             │
│                                                              │
│  Which is the REAL current balance?                        │
│  Server B's clock says it's "later" but that's wrong!      │
│                                                              │
│                                                              │
│  Sources of Clock Problems:                                 │
│  ──────────────────────────                                 │
│  ├── Clock drift: Quartz crystals aren't perfect           │
│  │   (typically 10-200 ppm = 0.8-17 sec/day)              │
│  │                                                          │
│  ├── NTP synchronization: Only accurate to ~100ms          │
│  │   over internet, ~1ms on LAN                            │
│  │                                                          │
│  ├── VM clock issues: VMs can "pause" and resume           │
│  │   with outdated clocks                                  │
│  │                                                          │
│  └── Leap seconds: Time can jump or repeat!                │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Real-World Clock Issues

```python
# time_problems.py
import time
from datetime import datetime
import asyncio

def demonstrate_clock_issues():
    """Show why wall-clock time is unreliable"""
    
    # Problem 1: Time can go backwards (NTP adjustment)
    print("Problem 1: Time can go backwards")
    print("-" * 40)
    
    t1 = time.time()
    # If NTP adjusts clock backwards here...
    t2 = time.time()
    
    # This assertion could FAIL!
    # assert t2 >= t1, "Time went backwards!"
    print(f"t1={t1}, t2={t2}")
    print(f"t2 >= t1? {t2 >= t1} (might be False after NTP sync!)")
    
    
    # Problem 2: Time resolution varies
    print("\nProblem 2: Time resolution varies")
    print("-" * 40)
    
    times = []
    for _ in range(5):
        times.append(time.time())
    
    print("Consecutive time.time() calls:")
    for i, t in enumerate(times):
        print(f"  {i}: {t}")
    
    # Some might be identical! (low resolution)
    
    
    # Problem 3: Monotonic time vs wall clock
    print("\nProblem 3: Monotonic vs Wall Clock")
    print("-" * 40)
    
    # Wall clock: Can jump around (NTP, manual changes)
    wall_time = time.time()
    
    # Monotonic: Always increases, but no absolute meaning
    mono_time = time.monotonic()
    
    print(f"Wall clock: {wall_time} (can change!)")
    print(f"Monotonic:  {mono_time} (only useful for durations)")
    
    # Use monotonic for measuring elapsed time
    start = time.monotonic()
    time.sleep(0.1)
    elapsed = time.monotonic() - start
    print(f"Elapsed (monotonic): {elapsed:.3f}s")

# demonstrate_clock_issues()
```

---

## 11.2 Physical Clocks

### NTP (Network Time Protocol)

```
┌─────────────────────────────────────────────────────────────┐
│              NTP - NETWORK TIME PROTOCOL                     │
│                                                              │
│  How it works:                                              │
│  ──────────────                                             │
│                                                              │
│  Client                          NTP Server                 │
│     │                                │                       │
│     │────── T1: Request sent ──────▶│                       │
│     │                                │                       │
│     │                           T2: Request received        │
│     │                           T3: Response sent           │
│     │                                │                       │
│     │◀───── T4: Response received ──│                       │
│     │                                │                       │
│                                                              │
│  Round-trip delay = (T4 - T1) - (T3 - T2)                  │
│  Clock offset = ((T2 - T1) + (T3 - T4)) / 2                │
│                                                              │
│                                                              │
│  NTP Stratum Levels:                                        │
│  ───────────────────                                        │
│  Stratum 0: Atomic clocks, GPS receivers (reference)       │
│  Stratum 1: Directly connected to Stratum 0 (~1μs)         │
│  Stratum 2: Synced to Stratum 1 (~10ms)                    │
│  Stratum 3+: Each level adds more error                    │
│                                                              │
│                                                              │
│  Accuracy:                                                  │
│  ─────────                                                  │
│  • Internet: ~100ms                                         │
│  • LAN: ~1ms                                                │
│  • Data center with good NTP: ~10ms                        │
│                                                              │
│  NOT GOOD ENOUGH for ordering events!                       │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Google TrueTime

```
┌─────────────────────────────────────────────────────────────┐
│              GOOGLE TRUETIME                                 │
│                                                              │
│  Used by Google Spanner for global consistency.             │
│                                                              │
│  Key Insight:                                               │
│  ────────────                                               │
│  Don't return a point in time.                              │
│  Return an INTERVAL: [earliest, latest]                     │
│                                                              │
│  TT.now() → [earliest, latest]                             │
│                                                              │
│  "The actual time is SOMEWHERE in this range"              │
│                                                              │
│                                                              │
│  Hardware:                                                  │
│  ─────────                                                  │
│  • GPS receivers in each data center                        │
│  • Atomic clocks as backup                                  │
│  • Multiple time sources for redundancy                     │
│                                                              │
│                                                              │
│  Accuracy:                                                  │
│  ─────────                                                  │
│  • Uncertainty typically 1-7ms                              │
│  • Much better than NTP!                                    │
│                                                              │
│                                                              │
│  How Spanner Uses It:                                       │
│  ─────────────────────                                      │
│  Before committing: Wait until uncertainty has passed      │
│                                                              │
│  commit_time = TT.now().latest                             │
│  wait_until(TT.now().earliest > commit_time)               │
│  # Now we KNOW the commit happened before "now"            │
│                                                              │
│  This guarantees external consistency!                      │
│  (But adds latency equal to uncertainty)                   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 11.3 Logical Clocks

### 11.3.1 Lamport Timestamps

```
┌─────────────────────────────────────────────────────────────┐
│              LAMPORT TIMESTAMPS                              │
│                                                              │
│  Invented by Leslie Lamport (1978).                        │
│  Creates a TOTAL ORDER of events without physical time.    │
│                                                              │
│  Rules:                                                     │
│  ──────                                                     │
│  1. Each process has a counter, starting at 0              │
│  2. Increment counter before each event                     │
│  3. When sending: include counter in message               │
│  4. When receiving: counter = max(local, received) + 1     │
│                                                              │
│                                                              │
│  Example:                                                   │
│  ─────────                                                  │
│                                                              │
│  Process A          Process B          Process C            │
│      │                  │                  │                 │
│  (1) │                  │                  │                 │
│      │───── msg ───────▶│                  │                 │
│      │                (2)│                  │                 │
│      │                  │───── msg ───────▶│                 │
│      │                  │                (3)│                 │
│      │                  │                  │                 │
│  (4) │                  │                  │                 │
│      │◀──────────── msg ───────────────────│                 │
│  (5) │                  │                  │                 │
│                                                              │
│  A: 1, 4 (receives msg with 3, so max(4,3)+1 = 5)          │
│  B: 2                                                       │
│  C: 3                                                       │
│                                                              │
│                                                              │
│  Property: If A → B (A happened before B), then L(A) < L(B)│
│                                                              │
│  IMPORTANT: The converse is NOT true!                       │
│  L(A) < L(B) does NOT mean A happened before B             │
│  (They might be concurrent)                                 │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

```python
# lamport_clock.py
from dataclasses import dataclass
from typing import Optional, Any
import threading

class LamportClock:
    """
    Lamport logical clock implementation.
    Provides a total ordering of events.
    """
    
    def __init__(self, node_id: str):
        self.node_id = node_id
        self.counter = 0
        self._lock = threading.Lock()
    
    def tick(self) -> int:
        """Increment clock for local event"""
        with self._lock:
            self.counter += 1
            return self.counter
    
    def send_timestamp(self) -> int:
        """Get timestamp for outgoing message"""
        return self.tick()
    
    def receive_timestamp(self, received_time: int) -> int:
        """Update clock based on received message"""
        with self._lock:
            self.counter = max(self.counter, received_time) + 1
            return self.counter
    
    def current(self) -> int:
        """Get current timestamp without incrementing"""
        return self.counter

@dataclass
class Message:
    sender: str
    content: Any
    timestamp: int  # Lamport timestamp

class Node:
    """A node that uses Lamport clocks for ordering"""
    
    def __init__(self, node_id: str):
        self.node_id = node_id
        self.clock = LamportClock(node_id)
        self.event_log: list[tuple[int, str]] = []
    
    def local_event(self, description: str):
        """Record a local event"""
        ts = self.clock.tick()
        self.event_log.append((ts, description))
        print(f"[{self.node_id}] Event '{description}' at timestamp {ts}")
    
    def send_message(self, content: Any) -> Message:
        """Create a message to send"""
        ts = self.clock.send_timestamp()
        self.event_log.append((ts, f"send: {content}"))
        print(f"[{self.node_id}] Sending '{content}' at timestamp {ts}")
        return Message(sender=self.node_id, content=content, timestamp=ts)
    
    def receive_message(self, msg: Message):
        """Process a received message"""
        ts = self.clock.receive_timestamp(msg.timestamp)
        self.event_log.append((ts, f"receive from {msg.sender}: {msg.content}"))
        print(f"[{self.node_id}] Received '{msg.content}' from {msg.sender}, "
              f"msg_ts={msg.timestamp}, new_ts={ts}")

def demo_lamport_clock():
    """Demonstrate Lamport clock ordering"""
    
    # Create nodes
    alice = Node("Alice")
    bob = Node("Bob")
    carol = Node("Carol")
    
    print("=== Lamport Clock Demo ===\n")
    
    # Alice does something
    alice.local_event("start task")
    
    # Alice sends to Bob
    msg1 = alice.send_message("Hello Bob")
    bob.receive_message(msg1)
    
    # Bob does something
    bob.local_event("process message")
    
    # Bob sends to Carol
    msg2 = bob.send_message("Hello Carol")
    carol.receive_message(msg2)
    
    # Carol sends to Alice (notice clock update)
    msg3 = carol.send_message("Hello Alice")
    alice.receive_message(msg3)
    
    # Alice does another thing
    alice.local_event("finish task")
    
    print("\n=== Event Logs ===")
    for node in [alice, bob, carol]:
        print(f"\n{node.node_id}:")
        for ts, event in sorted(node.event_log):
            print(f"  [{ts}] {event}")
    
    # All events have a total order based on (timestamp, node_id)
    all_events = []
    for node in [alice, bob, carol]:
        for ts, event in node.event_log:
            all_events.append((ts, node.node_id, event))
    
    print("\n=== Global Order (by timestamp, then node_id) ===")
    for ts, node_id, event in sorted(all_events):
        print(f"  [{ts}] {node_id}: {event}")

# demo_lamport_clock()
```

### 11.3.2 Vector Clocks

```
┌─────────────────────────────────────────────────────────────┐
│              VECTOR CLOCKS                                   │
│                                                              │
│  Extension of Lamport clocks that can detect CONCURRENCY.   │
│  Each node maintains a vector of counters (one per node).   │
│                                                              │
│  Structure:                                                 │
│  ──────────                                                 │
│  Vector Clock = {node1: count1, node2: count2, ...}        │
│                                                              │
│  With 3 nodes (A, B, C):                                    │
│  VC = {A: 2, B: 1, C: 3}                                   │
│  Means: "A has had 2 events, B has had 1, C has had 3"     │
│                                                              │
│                                                              │
│  Rules:                                                     │
│  ──────                                                     │
│  1. Increment OWN entry on each event                       │
│  2. Send entire vector with messages                        │
│  3. On receive: merge vectors (take max of each entry)     │
│     then increment own entry                                │
│                                                              │
│                                                              │
│  Comparing Vector Clocks:                                   │
│  ────────────────────────                                   │
│                                                              │
│  VC1 < VC2 (VC1 happened before VC2):                      │
│    All entries in VC1 ≤ VC2, at least one is <             │
│                                                              │
│  VC1 || VC2 (Concurrent):                                  │
│    Some VC1[i] > VC2[i] AND some VC1[j] < VC2[j]          │
│                                                              │
│                                                              │
│  Example:                                                   │
│  ─────────                                                  │
│  {A:2, B:1} < {A:3, B:2}  → First happened before second   │
│  {A:2, B:1} || {A:1, B:2}  → Concurrent (neither before)   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

```python
# vector_clock.py
from dataclasses import dataclass, field
from typing import Dict, Any, Optional
from enum import Enum
import copy

class Ordering(Enum):
    BEFORE = "before"       # VC1 < VC2
    AFTER = "after"         # VC1 > VC2
    CONCURRENT = "concurrent"  # VC1 || VC2
    EQUAL = "equal"         # VC1 == VC2

class VectorClock:
    """
    Vector clock implementation.
    Can determine causality and detect concurrent events.
    """
    
    def __init__(self, node_id: str):
        self.node_id = node_id
        self.clock: Dict[str, int] = {node_id: 0}
    
    def tick(self) -> 'VectorClock':
        """Increment this node's clock"""
        self.clock[self.node_id] = self.clock.get(self.node_id, 0) + 1
        return self
    
    def send(self) -> Dict[str, int]:
        """Get clock to send with message"""
        self.tick()
        return copy.deepcopy(self.clock)
    
    def receive(self, other_clock: Dict[str, int]):
        """Merge received clock and increment"""
        # Merge: take max of each entry
        all_nodes = set(self.clock.keys()) | set(other_clock.keys())
        for node in all_nodes:
            self.clock[node] = max(
                self.clock.get(node, 0),
                other_clock.get(node, 0)
            )
        # Increment own counter
        self.tick()
    
    def copy(self) -> Dict[str, int]:
        """Get a copy of current clock"""
        return copy.deepcopy(self.clock)
    
    @staticmethod
    def compare(vc1: Dict[str, int], vc2: Dict[str, int]) -> Ordering:
        """
        Compare two vector clocks.
        Returns the causal relationship.
        """
        all_nodes = set(vc1.keys()) | set(vc2.keys())
        
        less_than = False
        greater_than = False
        
        for node in all_nodes:
            v1 = vc1.get(node, 0)
            v2 = vc2.get(node, 0)
            
            if v1 < v2:
                less_than = True
            elif v1 > v2:
                greater_than = True
        
        if less_than and greater_than:
            return Ordering.CONCURRENT
        elif less_than:
            return Ordering.BEFORE
        elif greater_than:
            return Ordering.AFTER
        else:
            return Ordering.EQUAL
    
    def __repr__(self):
        return f"VC({dict(sorted(self.clock.items()))})"

@dataclass
class Event:
    node: str
    description: str
    vector_clock: Dict[str, int]

class DistributedSystem:
    """System that tracks events with vector clocks"""
    
    def __init__(self):
        self.nodes: Dict[str, VectorClock] = {}
        self.events: list[Event] = []
    
    def add_node(self, node_id: str):
        self.nodes[node_id] = VectorClock(node_id)
    
    def local_event(self, node_id: str, description: str):
        """Record a local event"""
        vc = self.nodes[node_id]
        vc.tick()
        
        event = Event(node_id, description, vc.copy())
        self.events.append(event)
        
        print(f"[{node_id}] {description} @ {vc}")
        return event
    
    def send_message(self, from_node: str, to_node: str, content: str):
        """Send message from one node to another"""
        sender_vc = self.nodes[from_node]
        receiver_vc = self.nodes[to_node]
        
        # Sender increments and sends
        msg_clock = sender_vc.send()
        send_event = Event(from_node, f"send({content})", sender_vc.copy())
        self.events.append(send_event)
        print(f"[{from_node}] Send '{content}' @ {sender_vc}")
        
        # Receiver merges and increments
        receiver_vc.receive(msg_clock)
        recv_event = Event(to_node, f"recv({content})", receiver_vc.copy())
        self.events.append(recv_event)
        print(f"[{to_node}] Receive '{content}' @ {receiver_vc}")
        
        return send_event, recv_event
    
    def check_causality(self, event1: Event, event2: Event) -> str:
        """Determine causal relationship between events"""
        ordering = VectorClock.compare(event1.vector_clock, event2.vector_clock)
        
        if ordering == Ordering.BEFORE:
            return f"'{event1.description}' happened BEFORE '{event2.description}'"
        elif ordering == Ordering.AFTER:
            return f"'{event1.description}' happened AFTER '{event2.description}'"
        elif ordering == Ordering.CONCURRENT:
            return f"'{event1.description}' and '{event2.description}' are CONCURRENT"
        else:
            return f"'{event1.description}' and '{event2.description}' are the SAME event"

def demo_vector_clock():
    """Demonstrate vector clocks and causality detection"""
    
    system = DistributedSystem()
    system.add_node("A")
    system.add_node("B")
    system.add_node("C")
    
    print("=== Vector Clock Demo ===\n")
    
    # A does something
    e1 = system.local_event("A", "start")
    
    # A sends to B
    e2_send, e2_recv = system.send_message("A", "B", "hello")
    
    # B does something locally
    e3 = system.local_event("B", "process")
    
    # C does something independently (concurrent with B!)
    e4 = system.local_event("C", "independent work")
    
    # B sends to C
    e5_send, e5_recv = system.send_message("B", "C", "data")
    
    print("\n=== Causality Analysis ===\n")
    
    # Check various relationships
    print(system.check_causality(e1, e2_recv))  # e1 → e2_recv
    print(system.check_causality(e3, e4))       # e3 || e4 (concurrent!)
    print(system.check_causality(e4, e5_recv))  # e4 → e5_recv (C merges B's clock)
    print(system.check_causality(e1, e4))       # e1 || e4 (concurrent!)

# demo_vector_clock()
```

### 11.3.3 Hybrid Logical Clocks (HLC)

```
┌─────────────────────────────────────────────────────────────┐
│              HYBRID LOGICAL CLOCKS                           │
│                                                              │
│  Combines physical time with logical counters.              │
│  Best of both worlds!                                       │
│                                                              │
│  Structure:                                                 │
│  ──────────                                                 │
│  HLC = (physical_time, logical_counter)                    │
│                                                              │
│  • physical_time: Wall clock (as accurate as possible)      │
│  • logical_counter: Breaks ties when clocks are equal       │
│                                                              │
│                                                              │
│  Properties:                                                │
│  ───────────                                                │
│  • Always close to physical time (bounded drift)            │
│  • Preserves causality like Lamport clocks                  │
│  • Monotonically increasing                                 │
│  • Works even if physical clocks are skewed                │
│                                                              │
│                                                              │
│  Used by: CockroachDB, MongoDB, TiDB                       │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

```python
# hybrid_logical_clock.py
import time
from dataclasses import dataclass
from typing import Tuple
import threading

@dataclass
class HLCTimestamp:
    """Hybrid Logical Clock timestamp"""
    wall_time: int      # Physical time in milliseconds
    logical: int        # Logical counter for tie-breaking
    
    def __lt__(self, other: 'HLCTimestamp') -> bool:
        if self.wall_time != other.wall_time:
            return self.wall_time < other.wall_time
        return self.logical < other.logical
    
    def __le__(self, other: 'HLCTimestamp') -> bool:
        return self < other or self == other
    
    def __eq__(self, other: 'HLCTimestamp') -> bool:
        return self.wall_time == other.wall_time and self.logical == other.logical
    
    def __repr__(self):
        return f"HLC({self.wall_time}, {self.logical})"

class HybridLogicalClock:
    """
    Hybrid Logical Clock implementation.
    Provides timestamps that are:
    - Monotonically increasing
    - Causally ordered
    - Close to physical time
    """
    
    def __init__(self, max_drift_ms: int = 1000):
        self.last_time = 0
        self.logical = 0
        self.max_drift = max_drift_ms
        self._lock = threading.Lock()
    
    def _physical_time(self) -> int:
        """Get current physical time in milliseconds"""
        return int(time.time() * 1000)
    
    def now(self) -> HLCTimestamp:
        """Get current HLC timestamp for local event"""
        with self._lock:
            pt = self._physical_time()
            
            if pt > self.last_time:
                # Physical time advanced - reset logical
                self.last_time = pt
                self.logical = 0
            else:
                # Physical time hasn't advanced - increment logical
                self.logical += 1
            
            return HLCTimestamp(self.last_time, self.logical)
    
    def send(self) -> HLCTimestamp:
        """Get timestamp to send with message"""
        return self.now()
    
    def receive(self, msg_time: HLCTimestamp) -> HLCTimestamp:
        """Update clock based on received message"""
        with self._lock:
            pt = self._physical_time()
            
            # Check for excessive drift
            if msg_time.wall_time - pt > self.max_drift:
                raise ValueError(
                    f"Message time {msg_time.wall_time} too far in future "
                    f"(current: {pt}, max_drift: {self.max_drift})"
                )
            
            if pt > self.last_time and pt > msg_time.wall_time:
                # Physical time is newest
                self.last_time = pt
                self.logical = 0
            elif self.last_time > msg_time.wall_time:
                # Our last time is newest
                self.logical += 1
            elif msg_time.wall_time > self.last_time:
                # Message time is newest
                self.last_time = msg_time.wall_time
                self.logical = msg_time.logical + 1
            else:
                # Times are equal - take max logical + 1
                self.logical = max(self.logical, msg_time.logical) + 1
            
            return HLCTimestamp(self.last_time, self.logical)
    
    def current(self) -> HLCTimestamp:
        """Get current timestamp without incrementing"""
        return HLCTimestamp(self.last_time, self.logical)

# ============== USAGE EXAMPLE ==============

def demo_hlc():
    """Demonstrate Hybrid Logical Clocks"""
    
    hlc_a = HybridLogicalClock()
    hlc_b = HybridLogicalClock()
    
    print("=== HLC Demo ===\n")
    
    # Events close together (within same ms)
    events = []
    
    # Node A: rapid events
    for i in range(3):
        ts = hlc_a.now()
        events.append(("A", f"event_{i}", ts))
        print(f"A event_{i}: {ts}")
    
    # Node A sends to B
    send_ts = hlc_a.send()
    print(f"\nA sends message: {send_ts}")
    
    # Node B receives
    recv_ts = hlc_b.receive(send_ts)
    print(f"B receives message: {recv_ts}")
    
    # Node B does more events
    for i in range(2):
        ts = hlc_b.now()
        events.append(("B", f"event_{i}", ts))
        print(f"B event_{i}: {ts}")
    
    # All timestamps are correctly ordered despite fast events!

# demo_hlc()
```

---

## 11.4 Ordering Events in Practice

### Total Order Broadcast

```
┌─────────────────────────────────────────────────────────────┐
│              TOTAL ORDER BROADCAST                           │
│                                                              │
│  Guarantee: All nodes deliver messages in the SAME order.  │
│                                                              │
│  Node A sees: [msg1, msg2, msg3]                           │
│  Node B sees: [msg1, msg2, msg3]  (same order!)            │
│  Node C sees: [msg1, msg2, msg3]  (same order!)            │
│                                                              │
│                                                              │
│  Implementation: Use a sequencer (single leader)            │
│  ─────────────────────────────────────────────              │
│                                                              │
│                   ┌───────────┐                             │
│     Producers ───▶│ Sequencer │───▶ All Consumers          │
│                   │  assigns  │                             │
│                   │  numbers  │                             │
│                   └───────────┘                             │
│                                                              │
│  Sequencer assigns sequence numbers:                        │
│  msg_a → seq=1                                              │
│  msg_b → seq=2                                              │
│  msg_c → seq=3                                              │
│                                                              │
│  All consumers process in sequence order.                   │
│                                                              │
│  Used by: Kafka partitions, Raft, Paxos                    │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

```python
# total_order_broadcast.py
import asyncio
from typing import Any, List, Dict, Callable
from dataclasses import dataclass
import uuid

@dataclass
class OrderedMessage:
    sequence: int
    sender: str
    content: Any

class Sequencer:
    """
    Central sequencer for total order broadcast.
    Assigns sequence numbers to ensure global ordering.
    """
    
    def __init__(self):
        self.sequence = 0
        self.subscribers: List['Subscriber'] = []
        self.message_log: List[OrderedMessage] = []
        self._lock = asyncio.Lock()
    
    def add_subscriber(self, subscriber: 'Subscriber'):
        self.subscribers.append(subscriber)
        # Send any missed messages
        for msg in self.message_log:
            asyncio.create_task(subscriber.receive(msg))
    
    async def broadcast(self, sender: str, content: Any) -> int:
        """
        Broadcast message to all subscribers with assigned sequence.
        """
        async with self._lock:
            self.sequence += 1
            msg = OrderedMessage(
                sequence=self.sequence,
                sender=sender,
                content=content
            )
            self.message_log.append(msg)
        
        # Deliver to all subscribers
        await asyncio.gather(*[
            sub.receive(msg) for sub in self.subscribers
        ])
        
        return self.sequence

class Subscriber:
    """
    Subscriber that receives messages in total order.
    """
    
    def __init__(self, name: str):
        self.name = name
        self.next_expected = 1
        self.buffer: Dict[int, OrderedMessage] = {}
        self.delivered: List[OrderedMessage] = []
        self.handler: Callable = None
    
    def on_message(self, handler: Callable):
        """Set message handler"""
        self.handler = handler
    
    async def receive(self, msg: OrderedMessage):
        """
        Receive message and deliver in order.
        Buffers out-of-order messages.
        """
        if msg.sequence < self.next_expected:
            # Already delivered (duplicate)
            return
        
        if msg.sequence > self.next_expected:
            # Out of order - buffer it
            self.buffer[msg.sequence] = msg
            print(f"[{self.name}] Buffered msg {msg.sequence} (waiting for {self.next_expected})")
            return
        
        # This is the next expected message
        await self._deliver(msg)
        
        # Check buffer for subsequent messages
        while self.next_expected in self.buffer:
            buffered = self.buffer.pop(self.next_expected)
            await self._deliver(buffered)
    
    async def _deliver(self, msg: OrderedMessage):
        """Deliver message to application"""
        self.delivered.append(msg)
        self.next_expected = msg.sequence + 1
        
        print(f"[{self.name}] Delivered #{msg.sequence}: {msg.content}")
        
        if self.handler:
            await self.handler(msg)

async def demo_total_order():
    """Demonstrate total order broadcast"""
    
    # Create sequencer
    sequencer = Sequencer()
    
    # Create subscribers
    sub_a = Subscriber("A")
    sub_b = Subscriber("B")
    sub_c = Subscriber("C")
    
    sequencer.add_subscriber(sub_a)
    sequencer.add_subscriber(sub_b)
    sequencer.add_subscriber(sub_c)
    
    print("=== Total Order Broadcast Demo ===\n")
    
    # Multiple producers broadcast concurrently
    await asyncio.gather(
        sequencer.broadcast("Producer1", "Hello"),
        sequencer.broadcast("Producer2", "World"),
        sequencer.broadcast("Producer1", "Foo"),
        sequencer.broadcast("Producer3", "Bar"),
    )
    
    print("\n=== Delivery Order (All Same!) ===")
    for sub in [sub_a, sub_b, sub_c]:
        order = [msg.content for msg in sub.delivered]
        print(f"{sub.name}: {order}")

# asyncio.run(demo_total_order())
```

---

## 11.5 Practical Applications

### Database Timestamps

```python
# practical_timestamps.py
"""
Practical timestamp usage in distributed databases.
"""

from datetime import datetime
from typing import Optional
import uuid

class VersionedRecord:
    """
    Database record with versioning for optimistic concurrency.
    """
    
    def __init__(self, id: str, data: dict):
        self.id = id
        self.data = data
        self.version = 1
        self.created_at = datetime.utcnow()
        self.updated_at = datetime.utcnow()
        # HLC timestamp for cross-node ordering
        self.hlc_timestamp: Optional[tuple] = None
    
    def update(self, new_data: dict, expected_version: int) -> bool:
        """
        Optimistic update - only succeeds if version matches.
        """
        if self.version != expected_version:
            raise OptimisticLockError(
                f"Version mismatch: expected {expected_version}, "
                f"actual {self.version}"
            )
        
        self.data.update(new_data)
        self.version += 1
        self.updated_at = datetime.utcnow()
        return True

class OptimisticLockError(Exception):
    pass

# Snowflake ID Generator (like Twitter)
class SnowflakeGenerator:
    """
    Generates unique, time-ordered IDs.
    Format: timestamp (41 bits) | machine_id (10 bits) | sequence (12 bits)
    """
    
    def __init__(self, machine_id: int):
        if machine_id < 0 or machine_id > 1023:
            raise ValueError("Machine ID must be 0-1023")
        
        self.machine_id = machine_id
        self.sequence = 0
        self.last_timestamp = -1
        
        # Twitter epoch (Nov 04 2010)
        self.epoch = 1288834974657
    
    def _current_millis(self) -> int:
        return int(datetime.utcnow().timestamp() * 1000)
    
    def generate(self) -> int:
        """Generate a new snowflake ID"""
        timestamp = self._current_millis()
        
        if timestamp < self.last_timestamp:
            raise Exception("Clock moved backwards!")
        
        if timestamp == self.last_timestamp:
            self.sequence = (self.sequence + 1) & 0xFFF  # 12 bits
            if self.sequence == 0:
                # Sequence exhausted, wait for next millisecond
                while timestamp <= self.last_timestamp:
                    timestamp = self._current_millis()
        else:
            self.sequence = 0
        
        self.last_timestamp = timestamp
        
        # Compose ID
        id = ((timestamp - self.epoch) << 22) | (self.machine_id << 12) | self.sequence
        
        return id
    
    @staticmethod
    def extract_timestamp(snowflake_id: int, epoch: int = 1288834974657) -> datetime:
        """Extract timestamp from snowflake ID"""
        timestamp_ms = (snowflake_id >> 22) + epoch
        return datetime.fromtimestamp(timestamp_ms / 1000)

# ============== DEMO ==============

def demo_snowflake():
    """Demonstrate Snowflake IDs"""
    
    gen = SnowflakeGenerator(machine_id=1)
    
    print("=== Snowflake ID Demo ===\n")
    
    # Generate some IDs
    ids = [gen.generate() for _ in range(5)]
    
    for id in ids:
        ts = SnowflakeGenerator.extract_timestamp(id)
        print(f"ID: {id}")
        print(f"  Timestamp: {ts}")
        print(f"  Binary: {bin(id)}")
        print()
    
    # IDs are always increasing!
    print("IDs are sorted:", ids == sorted(ids))

# demo_snowflake()
```

---

## Summary

| Clock Type | Accuracy | Use Case |
|------------|----------|----------|
| **Physical (NTP)** | ~100ms | Logging, rough ordering |
| **Lamport** | Logical only | Total ordering |
| **Vector** | Logical only | Causality detection |
| **HLC** | ~1ms + logical | Database timestamps |
| **TrueTime** | ~1-7ms | Global consistency |
| **Snowflake** | Unique + ordered | Distributed IDs |

### Key Takeaways

1. **Never trust wall clocks** for ordering events
2. **Lamport clocks** give total order but can't detect concurrency
3. **Vector clocks** detect concurrency but are expensive
4. **HLC** is the practical choice for most systems
5. **TrueTime** requires special hardware (Google only)

---

## Practice Exercises

1. Implement Lamport clocks for a chat application
2. Build vector clocks that detect conflicts
3. Create an HLC-based timestamp service
4. Implement Snowflake ID generation
5. Build a total order broadcast system

**Next Chapter**: Consensus algorithms (Paxos and Raft)!
