# Chapter 4: Communication Patterns

> **Goal**: Master the different ways services communicate in distributed systems

---

## 4.1 Request-Response (Synchronous)

The most familiar pattern - like how your frontend calls APIs.

### 4.1.1 REST APIs

**REST (Representational State Transfer)** is an architectural style for designing networked applications.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    REST PRINCIPLES                           â”‚
â”‚                                                              â”‚
â”‚  1. STATELESS                                               â”‚
â”‚     Each request contains all information needed            â”‚
â”‚     Server doesn't store client state between requests      â”‚
â”‚                                                              â”‚
â”‚  2. RESOURCE-BASED                                          â”‚
â”‚     Everything is a resource with a unique URL              â”‚
â”‚     /users/123, /orders/456, /products/789                  â”‚
â”‚                                                              â”‚
â”‚  3. UNIFORM INTERFACE                                       â”‚
â”‚     Standard HTTP methods define operations:                â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚     â”‚ Method  â”‚ Operation       â”‚ Idempotent?           â”‚  â”‚
â”‚     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚     â”‚ GET     â”‚ Read resource   â”‚ Yes (safe)            â”‚  â”‚
â”‚     â”‚ POST    â”‚ Create resource â”‚ No (creates new)      â”‚  â”‚
â”‚     â”‚ PUT     â”‚ Replace fully   â”‚ Yes (same result)     â”‚  â”‚
â”‚     â”‚ PATCH   â”‚ Update partial  â”‚ No (depends)          â”‚  â”‚
â”‚     â”‚ DELETE  â”‚ Remove resource â”‚ Yes (stays deleted)   â”‚  â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                              â”‚
â”‚  4. REPRESENTATION                                          â”‚
â”‚     Resources can have multiple representations             â”‚
â”‚     JSON, XML, HTML (negotiated via Accept header)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Complete REST API Example**:

```python
from fastapi import FastAPI, HTTPException, Query, Path, status
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime
from enum import Enum

app = FastAPI(title="E-Commerce API", version="1.0.0")

# ============== MODELS ==============

class OrderStatus(str, Enum):
    PENDING = "pending"
    CONFIRMED = "confirmed"
    SHIPPED = "shipped"
    DELIVERED = "delivered"
    CANCELLED = "cancelled"

class ProductBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    price: float = Field(..., gt=0)
    description: Optional[str] = None

class ProductCreate(ProductBase):
    pass

class Product(ProductBase):
    id: int
    created_at: datetime
    
    class Config:
        from_attributes = True

class OrderItem(BaseModel):
    product_id: int
    quantity: int = Field(..., gt=0)

class OrderCreate(BaseModel):
    items: List[OrderItem]
    shipping_address: str

class Order(BaseModel):
    id: int
    items: List[OrderItem]
    status: OrderStatus
    total: float
    created_at: datetime

# ============== IN-MEMORY DATABASE ==============

products_db: dict[int, Product] = {}
orders_db: dict[int, Order] = {}

# ============== PRODUCTS ENDPOINTS ==============

@app.get(
    "/products",
    response_model=List[Product],
    summary="List all products",
    tags=["Products"]
)
async def list_products(
    skip: int = Query(0, ge=0, description="Number of items to skip"),
    limit: int = Query(20, ge=1, le=100, description="Max items to return"),
    min_price: Optional[float] = Query(None, ge=0),
    max_price: Optional[float] = Query(None, ge=0)
):
    """
    Retrieve products with optional filtering and pagination.
    
    - **skip**: Number of products to skip (for pagination)
    - **limit**: Maximum number of products to return
    - **min_price**: Filter products with price >= min_price
    - **max_price**: Filter products with price <= max_price
    """
    products = list(products_db.values())
    
    # Apply filters
    if min_price is not None:
        products = [p for p in products if p.price >= min_price]
    if max_price is not None:
        products = [p for p in products if p.price <= max_price]
    
    # Apply pagination
    return products[skip:skip + limit]

@app.get(
    "/products/{product_id}",
    response_model=Product,
    tags=["Products"]
)
async def get_product(
    product_id: int = Path(..., gt=0, description="The product ID")
):
    """Retrieve a single product by ID."""
    if product_id not in products_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Product {product_id} not found"
        )
    return products_db[product_id]

@app.post(
    "/products",
    response_model=Product,
    status_code=status.HTTP_201_CREATED,
    tags=["Products"]
)
async def create_product(product: ProductCreate):
    """Create a new product."""
    product_id = len(products_db) + 1
    new_product = Product(
        id=product_id,
        **product.model_dump(),
        created_at=datetime.utcnow()
    )
    products_db[product_id] = new_product
    return new_product

@app.put(
    "/products/{product_id}",
    response_model=Product,
    tags=["Products"]
)
async def replace_product(product_id: int, product: ProductCreate):
    """Replace a product entirely (PUT = full replacement)."""
    if product_id not in products_db:
        raise HTTPException(status_code=404, detail="Product not found")
    
    updated = Product(
        id=product_id,
        **product.model_dump(),
        created_at=products_db[product_id].created_at
    )
    products_db[product_id] = updated
    return updated

@app.patch(
    "/products/{product_id}",
    response_model=Product,
    tags=["Products"]
)
async def update_product(
    product_id: int,
    name: Optional[str] = None,
    price: Optional[float] = None,
    description: Optional[str] = None
):
    """Partially update a product (PATCH = partial update)."""
    if product_id not in products_db:
        raise HTTPException(status_code=404, detail="Product not found")
    
    product = products_db[product_id]
    
    if name is not None:
        product.name = name
    if price is not None:
        product.price = price
    if description is not None:
        product.description = description
    
    return product

@app.delete(
    "/products/{product_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    tags=["Products"]
)
async def delete_product(product_id: int):
    """Delete a product."""
    if product_id not in products_db:
        raise HTTPException(status_code=404, detail="Product not found")
    del products_db[product_id]
    return None  # 204 returns no content

# ============== ORDERS ENDPOINTS ==============

@app.post(
    "/orders",
    response_model=Order,
    status_code=status.HTTP_201_CREATED,
    tags=["Orders"]
)
async def create_order(order: OrderCreate):
    """Create a new order."""
    # Validate products exist and calculate total
    total = 0.0
    for item in order.items:
        if item.product_id not in products_db:
            raise HTTPException(
                status_code=400,
                detail=f"Product {item.product_id} not found"
            )
        total += products_db[item.product_id].price * item.quantity
    
    order_id = len(orders_db) + 1
    new_order = Order(
        id=order_id,
        items=order.items,
        status=OrderStatus.PENDING,
        total=total,
        created_at=datetime.utcnow()
    )
    orders_db[order_id] = new_order
    return new_order

@app.get("/orders/{order_id}", response_model=Order, tags=["Orders"])
async def get_order(order_id: int):
    """Get order by ID."""
    if order_id not in orders_db:
        raise HTTPException(status_code=404, detail="Order not found")
    return orders_db[order_id]

# Nested resource: Order status updates
@app.patch(
    "/orders/{order_id}/status",
    response_model=Order,
    tags=["Orders"]
)
async def update_order_status(order_id: int, new_status: OrderStatus):
    """Update order status (state machine)."""
    if order_id not in orders_db:
        raise HTTPException(status_code=404, detail="Order not found")
    
    order = orders_db[order_id]
    
    # Validate state transitions
    valid_transitions = {
        OrderStatus.PENDING: [OrderStatus.CONFIRMED, OrderStatus.CANCELLED],
        OrderStatus.CONFIRMED: [OrderStatus.SHIPPED, OrderStatus.CANCELLED],
        OrderStatus.SHIPPED: [OrderStatus.DELIVERED],
        OrderStatus.DELIVERED: [],
        OrderStatus.CANCELLED: [],
    }
    
    if new_status not in valid_transitions[order.status]:
        raise HTTPException(
            status_code=400,
            detail=f"Cannot transition from {order.status} to {new_status}"
        )
    
    order.status = new_status
    return order
```

**HTTP Status Codes to Know**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 HTTP STATUS CODES                            â”‚
â”‚                                                              â”‚
â”‚  2xx SUCCESS                                                â”‚
â”‚  â”œâ”€â”€ 200 OK              General success                    â”‚
â”‚  â”œâ”€â”€ 201 Created         Resource created (POST)            â”‚
â”‚  â”œâ”€â”€ 202 Accepted        Request accepted, processing async â”‚
â”‚  â””â”€â”€ 204 No Content      Success but no body (DELETE)       â”‚
â”‚                                                              â”‚
â”‚  3xx REDIRECTION                                            â”‚
â”‚  â”œâ”€â”€ 301 Moved Permanently   Resource moved                 â”‚
â”‚  â”œâ”€â”€ 302 Found               Temporary redirect             â”‚
â”‚  â””â”€â”€ 304 Not Modified        Cached version is valid        â”‚
â”‚                                                              â”‚
â”‚  4xx CLIENT ERROR                                           â”‚
â”‚  â”œâ”€â”€ 400 Bad Request         Invalid input                  â”‚
â”‚  â”œâ”€â”€ 401 Unauthorized        Not authenticated              â”‚
â”‚  â”œâ”€â”€ 403 Forbidden           Not authorized                 â”‚
â”‚  â”œâ”€â”€ 404 Not Found           Resource doesn't exist         â”‚
â”‚  â”œâ”€â”€ 409 Conflict            Conflict (duplicate, etc.)     â”‚
â”‚  â”œâ”€â”€ 422 Unprocessable       Validation failed              â”‚
â”‚  â””â”€â”€ 429 Too Many Requests   Rate limited                   â”‚
â”‚                                                              â”‚
â”‚  5xx SERVER ERROR                                           â”‚
â”‚  â”œâ”€â”€ 500 Internal Error      Server bug                     â”‚
â”‚  â”œâ”€â”€ 502 Bad Gateway         Upstream service failed        â”‚
â”‚  â”œâ”€â”€ 503 Service Unavailable Temporarily down               â”‚
â”‚  â””â”€â”€ 504 Gateway Timeout     Upstream timeout               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.1.2 gRPC (Google Remote Procedure Call)

**gRPC** is a high-performance RPC framework that uses Protocol Buffers.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 REST vs gRPC                                 â”‚
â”‚                                                              â”‚
â”‚  REST                          gRPC                         â”‚
â”‚  â”€â”€â”€â”€                          â”€â”€â”€â”€                         â”‚
â”‚  Text-based (JSON)             Binary (Protocol Buffers)    â”‚
â”‚  HTTP/1.1 (usually)            HTTP/2 (always)              â”‚
â”‚  Unary only                    Streaming support            â”‚
â”‚  Human readable                Not human readable           â”‚
â”‚  Slower serialization          Fast serialization           â”‚
â”‚  Flexible schema               Strict schema (proto files)  â”‚
â”‚  Browser-friendly              Needs proxy for browsers     â”‚
â”‚                                                              â”‚
â”‚  When to use gRPC:                                          â”‚
â”‚  â”œâ”€â”€ Internal service-to-service communication              â”‚
â”‚  â”œâ”€â”€ High performance requirements                          â”‚
â”‚  â”œâ”€â”€ Streaming data (real-time updates)                     â”‚
â”‚  â”œâ”€â”€ Polyglot environments (many languages)                 â”‚
â”‚  â””â”€â”€ Strong typing is important                             â”‚
â”‚                                                              â”‚
â”‚  When to use REST:                                          â”‚
â”‚  â”œâ”€â”€ Public APIs                                            â”‚
â”‚  â”œâ”€â”€ Browser clients                                        â”‚
â”‚  â”œâ”€â”€ Simple CRUD operations                                 â”‚
â”‚  â””â”€â”€ Human debugging/testing needed                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Step 1: Define Protocol Buffer Schema**

```protobuf
// user_service.proto
syntax = "proto3";

package userservice;

// Service definition
service UserService {
    // Unary RPC - single request, single response
    rpc GetUser(GetUserRequest) returns (User);
    rpc CreateUser(CreateUserRequest) returns (User);
    
    // Server streaming - single request, stream of responses
    rpc ListUsers(ListUsersRequest) returns (stream User);
    
    // Client streaming - stream of requests, single response
    rpc BatchCreateUsers(stream CreateUserRequest) returns (BatchCreateResponse);
    
    // Bidirectional streaming - stream both ways
    rpc Chat(stream ChatMessage) returns (stream ChatMessage);
}

// Messages
message GetUserRequest {
    int32 user_id = 1;
}

message CreateUserRequest {
    string username = 1;
    string email = 2;
    optional string bio = 3;
}

message User {
    int32 id = 1;
    string username = 2;
    string email = 3;
    string bio = 4;
    int64 created_at = 5;  // Unix timestamp
}

message ListUsersRequest {
    int32 page_size = 1;
    string page_token = 2;
}

message BatchCreateResponse {
    int32 created_count = 1;
    repeated int32 user_ids = 2;
}

message ChatMessage {
    string sender = 1;
    string content = 2;
    int64 timestamp = 3;
}
```

**Step 2: Generate Python Code**

```bash
# Install dependencies
pip install grpcio grpcio-tools

# Generate Python code from proto file
python -m grpc_tools.protoc \
    -I. \
    --python_out=. \
    --grpc_python_out=. \
    user_service.proto

# This generates:
# - user_service_pb2.py (message classes)
# - user_service_pb2_grpc.py (service stubs)
```

**Step 3: Implement gRPC Server**

```python
# grpc_server.py
import grpc
from concurrent import futures
import time
import user_service_pb2
import user_service_pb2_grpc

class UserServicer(user_service_pb2_grpc.UserServiceServicer):
    def __init__(self):
        self.users = {}
        self.next_id = 1
    
    def GetUser(self, request, context):
        """Unary RPC - single request, single response"""
        user_id = request.user_id
        
        if user_id not in self.users:
            context.set_code(grpc.StatusCode.NOT_FOUND)
            context.set_details(f"User {user_id} not found")
            return user_service_pb2.User()
        
        return self.users[user_id]
    
    def CreateUser(self, request, context):
        """Unary RPC - create new user"""
        user = user_service_pb2.User(
            id=self.next_id,
            username=request.username,
            email=request.email,
            bio=request.bio if request.HasField('bio') else "",
            created_at=int(time.time())
        )
        self.users[self.next_id] = user
        self.next_id += 1
        return user
    
    def ListUsers(self, request, context):
        """Server streaming - sends multiple users"""
        page_size = request.page_size or 10
        
        # Stream users one by one
        for user_id, user in list(self.users.items())[:page_size]:
            yield user  # Streaming response
            time.sleep(0.1)  # Simulate processing
    
    def BatchCreateUsers(self, request_iterator, context):
        """Client streaming - receives multiple create requests"""
        created_ids = []
        
        for request in request_iterator:
            user = user_service_pb2.User(
                id=self.next_id,
                username=request.username,
                email=request.email,
                created_at=int(time.time())
            )
            self.users[self.next_id] = user
            created_ids.append(self.next_id)
            self.next_id += 1
        
        return user_service_pb2.BatchCreateResponse(
            created_count=len(created_ids),
            user_ids=created_ids
        )
    
    def Chat(self, request_iterator, context):
        """Bidirectional streaming - real-time chat"""
        for message in request_iterator:
            # Echo back with server prefix
            response = user_service_pb2.ChatMessage(
                sender="server",
                content=f"Echo: {message.content}",
                timestamp=int(time.time())
            )
            yield response

def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    user_service_pb2_grpc.add_UserServiceServicer_to_server(
        UserServicer(), server
    )
    server.add_insecure_port('[::]:50051')
    server.start()
    print("gRPC server running on port 50051...")
    server.wait_for_termination()

if __name__ == '__main__':
    serve()
```

**Step 4: Implement gRPC Client**

```python
# grpc_client.py
import grpc
import user_service_pb2
import user_service_pb2_grpc
import time

def run():
    # Create channel and stub
    channel = grpc.insecure_channel('localhost:50051')
    stub = user_service_pb2_grpc.UserServiceStub(channel)
    
    # 1. Unary call - Create user
    print("Creating user...")
    user = stub.CreateUser(user_service_pb2.CreateUserRequest(
        username="alice",
        email="alice@example.com",
        bio="Software Engineer"
    ))
    print(f"Created user: {user.id} - {user.username}")
    
    # 2. Unary call - Get user
    print("\nFetching user...")
    user = stub.GetUser(user_service_pb2.GetUserRequest(user_id=1))
    print(f"Got user: {user.username} ({user.email})")
    
    # 3. Server streaming - List users
    print("\nListing users (streaming)...")
    for user in stub.ListUsers(user_service_pb2.ListUsersRequest(page_size=5)):
        print(f"  - {user.username}")
    
    # 4. Client streaming - Batch create
    print("\nBatch creating users...")
    def user_generator():
        for i in range(3):
            yield user_service_pb2.CreateUserRequest(
                username=f"batch_user_{i}",
                email=f"batch{i}@example.com"
            )
    
    response = stub.BatchCreateUsers(user_generator())
    print(f"Created {response.created_count} users: {list(response.user_ids)}")
    
    # 5. Bidirectional streaming - Chat
    print("\nStarting chat...")
    def message_generator():
        messages = ["Hello", "How are you?", "Goodbye"]
        for msg in messages:
            yield user_service_pb2.ChatMessage(
                sender="client",
                content=msg,
                timestamp=int(time.time())
            )
            time.sleep(0.5)
    
    for response in stub.Chat(message_generator()):
        print(f"  Server: {response.content}")

if __name__ == '__main__':
    run()
```

### 4.1.3 GraphQL

**GraphQL** lets clients request exactly the data they need.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 REST vs GraphQL                              â”‚
â”‚                                                              â”‚
â”‚  Problem with REST:                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚                                                              â”‚
â”‚  Need user + orders + shipping address?                     â”‚
â”‚                                                              â”‚
â”‚  REST: 3 separate requests                                  â”‚
â”‚  GET /users/123                                             â”‚
â”‚  GET /users/123/orders                                      â”‚
â”‚  GET /users/123/addresses                                   â”‚
â”‚                                                              â”‚
â”‚  GraphQL: 1 request, get exactly what you need              â”‚
â”‚  query {                                                    â”‚
â”‚    user(id: 123) {                                          â”‚
â”‚      name                                                   â”‚
â”‚      email                                                  â”‚
â”‚      orders {                                               â”‚
â”‚        id                                                   â”‚
â”‚        total                                                â”‚
â”‚      }                                                      â”‚
â”‚      address {                                              â”‚
â”‚        city                                                 â”‚
â”‚      }                                                      â”‚
â”‚    }                                                        â”‚
â”‚  }                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
# graphql_server.py
from fastapi import FastAPI
from strawberry.fastapi import GraphQLRouter
import strawberry
from typing import List, Optional

# Define types
@strawberry.type
class Address:
    street: str
    city: str
    country: str

@strawberry.type
class Order:
    id: int
    product_name: str
    quantity: int
    total: float

@strawberry.type
class User:
    id: int
    username: str
    email: str
    
    @strawberry.field
    def orders(self) -> List[Order]:
        # This is resolved only if client requests it!
        return get_orders_for_user(self.id)
    
    @strawberry.field
    def address(self) -> Optional[Address]:
        return get_address_for_user(self.id)

# Mock data functions
def get_orders_for_user(user_id: int) -> List[Order]:
    return [
        Order(id=1, product_name="Laptop", quantity=1, total=999.99),
        Order(id=2, product_name="Mouse", quantity=2, total=49.99),
    ]

def get_address_for_user(user_id: int) -> Address:
    return Address(street="123 Main St", city="NYC", country="USA")

# Define queries
@strawberry.type
class Query:
    @strawberry.field
    def user(self, id: int) -> User:
        # Fetch from database
        return User(id=id, username="alice", email="alice@example.com")
    
    @strawberry.field
    def users(self, limit: int = 10) -> List[User]:
        return [
            User(id=i, username=f"user_{i}", email=f"user{i}@example.com")
            for i in range(limit)
        ]

# Define mutations
@strawberry.type
class Mutation:
    @strawberry.mutation
    def create_user(self, username: str, email: str) -> User:
        # Save to database
        return User(id=999, username=username, email=email)

# Create schema and app
schema = strawberry.Schema(query=Query, mutation=Mutation)
graphql_app = GraphQLRouter(schema)

app = FastAPI()
app.include_router(graphql_app, prefix="/graphql")

# Client can now query:
# query {
#   user(id: 1) {
#     username
#     orders { total }  # Only fetches orders if requested!
#   }
# }
```

---

## 4.2 Message Queues (Asynchronous)

### The Core Concept

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   MESSAGE QUEUE                              â”‚
â”‚                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚   â”‚ Producer â”‚â”€â”€â”€â”€â”€â–¶â”‚    Queue    â”‚â”€â”€â”€â”€â”€â–¶â”‚ Consumer â”‚      â”‚
â”‚   â”‚          â”‚      â”‚             â”‚      â”‚          â”‚      â”‚
â”‚   â”‚ (sends   â”‚      â”‚ [msg1]      â”‚      â”‚ (receivesâ”‚      â”‚
â”‚   â”‚  message)â”‚      â”‚ [msg2]      â”‚      â”‚  message)â”‚      â”‚
â”‚   â”‚          â”‚      â”‚ [msg3]      â”‚      â”‚          â”‚      â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                              â”‚
â”‚   Benefits:                                                 â”‚
â”‚   â”œâ”€â”€ Decoupling: Producer doesn't know about consumer      â”‚
â”‚   â”œâ”€â”€ Buffering: Handle traffic spikes                      â”‚
â”‚   â”œâ”€â”€ Reliability: Messages persist if consumer is down     â”‚
â”‚   â”œâ”€â”€ Scalability: Add more consumers to process faster     â”‚
â”‚   â””â”€â”€ Async: Producer continues immediately                 â”‚
â”‚                                                              â”‚
â”‚   Use Cases:                                                â”‚
â”‚   â”œâ”€â”€ Email notifications (don't block user request)        â”‚
â”‚   â”œâ”€â”€ Order processing (handle sequentially)                â”‚
â”‚   â”œâ”€â”€ Log aggregation (collect from many sources)           â”‚
â”‚   â”œâ”€â”€ Task scheduling (background jobs)                     â”‚
â”‚   â””â”€â”€ Event broadcasting (notify multiple services)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2.1 Delivery Semantics

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               DELIVERY GUARANTEES                            â”‚
â”‚                                                              â”‚
â”‚   AT-MOST-ONCE                                              â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                             â”‚
â”‚   â€¢ Message sent once, no retries                           â”‚
â”‚   â€¢ May be lost if delivery fails                           â”‚
â”‚   â€¢ Fastest, lowest overhead                                â”‚
â”‚   â€¢ Use for: Analytics, metrics (losing some is OK)         â”‚
â”‚                                                              â”‚
â”‚   Producer â”€â”€[msg]â”€â”€â–¶ Queue â”€â”€[msg]â”€â”€â–¶ Consumer             â”‚
â”‚                            â†“                                 â”‚
â”‚                      (network error)                         â”‚
â”‚                      Message LOST!                           â”‚
â”‚                                                              â”‚
â”‚   AT-LEAST-ONCE                                             â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                             â”‚
â”‚   â€¢ Retry until acknowledged                                â”‚
â”‚   â€¢ May deliver duplicates                                  â”‚
â”‚   â€¢ Consumer must be IDEMPOTENT                             â”‚
â”‚   â€¢ Use for: Order processing, payments (with idempotency)  â”‚
â”‚                                                              â”‚
â”‚   Producer â”€â”€[msg]â”€â”€â–¶ Queue â”€â”€[msg]â”€â”€â–¶ Consumer             â”‚
â”‚                            â”‚              â”‚                  â”‚
â”‚                            â”‚        (ack lost)               â”‚
â”‚                            â”‚              â”‚                  â”‚
â”‚                            â””â”€â”€[msg]â”€â”€â–¶ Consumer (again!)    â”‚
â”‚                                                              â”‚
â”‚   EXACTLY-ONCE (Holy Grail)                                 â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                  â”‚
â”‚   â€¢ Each message processed exactly once                     â”‚
â”‚   â€¢ Very hard to achieve!                                   â”‚
â”‚   â€¢ Usually implemented as at-least-once + deduplication    â”‚
â”‚   â€¢ Use for: Financial transactions, inventory updates      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2.2 Redis as a Simple Queue

```python
# redis_queue.py
import redis.asyncio as redis
import json
import asyncio
from datetime import datetime
from typing import Callable, Any
import uuid

class RedisQueue:
    """Simple but effective message queue using Redis lists"""
    
    def __init__(self, redis_url: str = "redis://localhost"):
        self.redis = redis.from_url(redis_url, decode_responses=True)
    
    async def enqueue(self, queue_name: str, message: dict) -> str:
        """Add message to queue (LPUSH for FIFO with BRPOP)"""
        message_id = str(uuid.uuid4())
        envelope = {
            "id": message_id,
            "payload": message,
            "timestamp": datetime.utcnow().isoformat(),
            "attempts": 0
        }
        await self.redis.lpush(queue_name, json.dumps(envelope))
        return message_id
    
    async def dequeue(self, queue_name: str, timeout: int = 0) -> dict | None:
        """Remove and return message from queue (blocking)"""
        result = await self.redis.brpop(queue_name, timeout=timeout)
        if result:
            _, data = result
            return json.loads(data)
        return None
    
    async def dequeue_with_processing(
        self, 
        queue_name: str,
        processing_queue: str,
        timeout: int = 0
    ) -> dict | None:
        """
        Move message to processing queue atomically.
        If consumer crashes, message isn't lost.
        """
        result = await self.redis.brpoplpush(
            queue_name, 
            processing_queue, 
            timeout=timeout
        )
        if result:
            return json.loads(result)
        return None
    
    async def acknowledge(self, processing_queue: str, message: dict):
        """Remove message from processing queue (it's done)"""
        await self.redis.lrem(processing_queue, 1, json.dumps(message))
    
    async def get_queue_length(self, queue_name: str) -> int:
        return await self.redis.llen(queue_name)

# Producer example
async def producer_example():
    queue = RedisQueue()
    
    # Enqueue some tasks
    for i in range(10):
        message_id = await queue.enqueue("tasks", {
            "task_type": "send_email",
            "user_id": i,
            "email": f"user{i}@example.com"
        })
        print(f"Enqueued task {message_id}")
    
    print(f"Queue length: {await queue.get_queue_length('tasks')}")

# Consumer example
async def consumer_example():
    queue = RedisQueue()
    
    print("Consumer waiting for messages...")
    while True:
        # Get message (blocks until one is available)
        message = await queue.dequeue_with_processing(
            "tasks", 
            "tasks:processing",
            timeout=5
        )
        
        if message is None:
            print("No message received, continuing...")
            continue
        
        try:
            # Process the message
            print(f"Processing: {message['payload']}")
            await asyncio.sleep(0.5)  # Simulate work
            
            # Acknowledge completion
            await queue.acknowledge("tasks:processing", message)
            print(f"Completed: {message['id']}")
            
        except Exception as e:
            print(f"Error processing {message['id']}: {e}")
            # Message stays in processing queue for retry

# Run producer then consumer
# asyncio.run(producer_example())
# asyncio.run(consumer_example())
```

### 4.2.3 RabbitMQ (Advanced Features)

```python
# rabbitmq_example.py
import aio_pika
import json
import asyncio
from datetime import datetime

class RabbitMQClient:
    def __init__(self, url: str = "amqp://guest:guest@localhost/"):
        self.url = url
        self.connection = None
        self.channel = None
    
    async def connect(self):
        self.connection = await aio_pika.connect_robust(self.url)
        self.channel = await self.connection.channel()
        # Limit unacknowledged messages (backpressure)
        await self.channel.set_qos(prefetch_count=10)
    
    async def close(self):
        await self.connection.close()
    
    async def declare_queue(
        self, 
        queue_name: str, 
        durable: bool = True,
        dead_letter_exchange: str = None
    ):
        """Declare a queue with optional dead letter handling"""
        arguments = {}
        if dead_letter_exchange:
            arguments["x-dead-letter-exchange"] = dead_letter_exchange
        
        queue = await self.channel.declare_queue(
            queue_name,
            durable=durable,  # Survives broker restart
            arguments=arguments
        )
        return queue
    
    async def publish(
        self, 
        queue_name: str, 
        message: dict,
        priority: int = 0
    ):
        """Publish message to queue"""
        await self.channel.default_exchange.publish(
            aio_pika.Message(
                body=json.dumps(message).encode(),
                delivery_mode=aio_pika.DeliveryMode.PERSISTENT,  # Survives restart
                priority=priority,
                timestamp=datetime.utcnow(),
            ),
            routing_key=queue_name,
        )
    
    async def consume(
        self, 
        queue_name: str, 
        callback,
        auto_ack: bool = False
    ):
        """Consume messages from queue"""
        queue = await self.declare_queue(queue_name)
        
        async with queue.iterator() as queue_iter:
            async for message in queue_iter:
                async with message.process(requeue=not auto_ack):
                    data = json.loads(message.body.decode())
                    await callback(data, message)

# Advanced Pattern: Work Queue with Multiple Consumers
async def work_queue_example():
    client = RabbitMQClient()
    await client.connect()
    
    # Declare queue with dead letter handling
    await client.declare_queue(
        "work_queue",
        dead_letter_exchange="dead_letters"
    )
    
    # Publish tasks
    for i in range(100):
        await client.publish("work_queue", {
            "task_id": i,
            "data": f"Task {i} data"
        })
    print("Published 100 tasks")

async def worker(worker_id: int):
    """Multiple workers can process the queue in parallel"""
    client = RabbitMQClient()
    await client.connect()
    
    async def process_task(data: dict, message):
        print(f"Worker {worker_id} processing task {data['task_id']}")
        await asyncio.sleep(0.5)  # Simulate work
    
    await client.consume("work_queue", process_task)

# Run multiple workers
async def run_workers():
    # Start 3 workers concurrently
    await asyncio.gather(
        worker(1),
        worker(2),
        worker(3)
    )
```

### 4.2.4 Apache Kafka (High-Throughput Log-Based)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    KAFKA ARCHITECTURE                        â”‚
â”‚                                                              â”‚
â”‚   TOPIC: "orders" (like a category/channel)                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚   â”‚                                                        â”‚ â”‚
â”‚   â”‚  Partition 0    Partition 1    Partition 2            â”‚ â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚ â”‚
â”‚   â”‚  â”‚[0][1][2] â”‚  â”‚[0][1][2] â”‚  â”‚[0][1]    â”‚           â”‚ â”‚
â”‚   â”‚  â”‚[3][4][5] â”‚  â”‚[3][4]    â”‚  â”‚          â”‚           â”‚ â”‚
â”‚   â”‚  â”‚[6]       â”‚  â”‚          â”‚  â”‚          â”‚           â”‚ â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚ â”‚
â”‚   â”‚       â†‘             â†‘             â†‘                   â”‚ â”‚
â”‚   â”‚       â”‚             â”‚             â”‚                   â”‚ â”‚
â”‚   â”‚  Consumer A    Consumer B    Consumer C               â”‚ â”‚
â”‚   â”‚  (Group: X)    (Group: X)    (Group: X)              â”‚ â”‚
â”‚   â”‚                                                        â”‚ â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                              â”‚
â”‚   Key Concepts:                                             â”‚
â”‚   â”œâ”€â”€ Topic: Stream of records (like a table)               â”‚
â”‚   â”œâ”€â”€ Partition: Ordered, immutable log                     â”‚
â”‚   â”œâ”€â”€ Offset: Position in partition                         â”‚
â”‚   â”œâ”€â”€ Consumer Group: Share partitions among consumers      â”‚
â”‚   â””â”€â”€ Retention: Keep messages for X days (not deleted)     â”‚
â”‚                                                              â”‚
â”‚   Why Kafka?                                                â”‚
â”‚   â”œâ”€â”€ Extremely high throughput (millions/sec)              â”‚
â”‚   â”œâ”€â”€ Messages persist (replay from any point)              â”‚
â”‚   â”œâ”€â”€ Ordered within partition                              â”‚
â”‚   â”œâ”€â”€ Horizontal scaling via partitions                     â”‚
â”‚   â””â”€â”€ Multiple consumer groups (each gets all messages)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
# kafka_example.py
from aiokafka import AIOKafkaProducer, AIOKafkaConsumer
import json
import asyncio
from datetime import datetime

class KafkaClient:
    def __init__(self, bootstrap_servers: str = "localhost:9092"):
        self.bootstrap_servers = bootstrap_servers
    
    async def create_producer(self) -> AIOKafkaProducer:
        producer = AIOKafkaProducer(
            bootstrap_servers=self.bootstrap_servers,
            value_serializer=lambda v: json.dumps(v).encode(),
            key_serializer=lambda k: k.encode() if k else None,
            # Enable idempotence for exactly-once semantics
            enable_idempotence=True,
        )
        await producer.start()
        return producer
    
    async def create_consumer(
        self, 
        topic: str, 
        group_id: str
    ) -> AIOKafkaConsumer:
        consumer = AIOKafkaConsumer(
            topic,
            bootstrap_servers=self.bootstrap_servers,
            group_id=group_id,
            value_deserializer=lambda v: json.loads(v.decode()),
            auto_offset_reset='earliest',  # Start from beginning if new
            enable_auto_commit=False,  # Manual commit for control
        )
        await consumer.start()
        return consumer

# Producer with partitioning
async def produce_orders():
    client = KafkaClient()
    producer = await client.create_producer()
    
    try:
        for i in range(100):
            order = {
                "order_id": i,
                "user_id": i % 10,  # 10 different users
                "product": f"Product-{i}",
                "amount": 99.99,
                "timestamp": datetime.utcnow().isoformat()
            }
            
            # Key determines partition (same user -> same partition -> ordered)
            key = f"user-{order['user_id']}"
            
            # Send and wait for acknowledgment
            result = await producer.send_and_wait(
                "orders",
                value=order,
                key=key
            )
            
            print(f"Sent order {i} to partition {result.partition}, offset {result.offset}")
            
    finally:
        await producer.stop()

# Consumer with manual commit
async def consume_orders(consumer_id: int):
    client = KafkaClient()
    consumer = await client.create_consumer("orders", "order-processors")
    
    try:
        async for message in consumer:
            order = message.value
            partition = message.partition
            offset = message.offset
            
            print(f"Consumer {consumer_id}: Processing order {order['order_id']} "
                  f"from partition {partition}, offset {offset}")
            
            # Process the order
            await asyncio.sleep(0.1)  # Simulate processing
            
            # Manually commit offset (at-least-once semantics)
            await consumer.commit()
            
    finally:
        await consumer.stop()

# Parallel consumers in same group (each gets different partitions)
async def run_consumer_group():
    await asyncio.gather(
        consume_orders(1),
        consume_orders(2),
        consume_orders(3),
    )

# Different consumer groups (each group gets ALL messages)
async def consume_for_analytics():
    """Separate consumer group for analytics - gets all messages"""
    client = KafkaClient()
    consumer = await client.create_consumer("orders", "analytics")  # Different group!
    
    async for message in consumer:
        # This consumer also receives all orders
        print(f"Analytics: Recording order {message.value['order_id']}")
        await consumer.commit()
```

---

## 4.3 Publish-Subscribe Pattern

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PUB/SUB PATTERN                           â”‚
â”‚                                                              â”‚
â”‚   Unlike queues (one consumer), pub/sub delivers to ALL     â”‚
â”‚   subscribers.                                               â”‚
â”‚                                                              â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚                    â”‚   Publisher  â”‚                         â”‚
â”‚                    â”‚  (produces)  â”‚                         â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚                           â”‚                                  â”‚
â”‚                           â–¼                                  â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚                    â”‚    Topic     â”‚                         â”‚
â”‚                    â”‚ "user.signup"â”‚                         â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚                           â”‚                                  â”‚
â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚            â”‚              â”‚              â”‚                   â”‚
â”‚            â–¼              â–¼              â–¼                   â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚     â”‚Email Svc  â”‚  â”‚Analytics  â”‚  â”‚Recommend  â”‚           â”‚
â”‚     â”‚(send      â”‚  â”‚(track     â”‚  â”‚(update    â”‚           â”‚
â”‚     â”‚ welcome)  â”‚  â”‚ signups)  â”‚  â”‚ models)   â”‚           â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                              â”‚
â”‚   Each subscriber gets EVERY message!                       â”‚
â”‚   (vs queue where messages are distributed)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
# pubsub_redis.py
import redis.asyncio as redis
import json
import asyncio
from typing import Callable
from dataclasses import dataclass

@dataclass
class Event:
    type: str
    data: dict
    timestamp: str

class EventBus:
    """Simple pub/sub event bus using Redis"""
    
    def __init__(self, redis_url: str = "redis://localhost"):
        self.redis = redis.from_url(redis_url, decode_responses=True)
        self.pubsub = self.redis.pubsub()
        self.handlers: dict[str, list[Callable]] = {}
    
    async def publish(self, event_type: str, data: dict):
        """Publish event to all subscribers"""
        from datetime import datetime
        
        event = {
            "type": event_type,
            "data": data,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        await self.redis.publish(event_type, json.dumps(event))
        print(f"Published: {event_type}")
    
    async def subscribe(self, event_type: str, handler: Callable):
        """Subscribe to an event type"""
        if event_type not in self.handlers:
            self.handlers[event_type] = []
            await self.pubsub.subscribe(event_type)
        
        self.handlers[event_type].append(handler)
        print(f"Subscribed to: {event_type}")
    
    async def listen(self):
        """Listen for events and dispatch to handlers"""
        async for message in self.pubsub.listen():
            if message["type"] == "message":
                event_type = message["channel"]
                event_data = json.loads(message["data"])
                
                # Call all handlers for this event type
                if event_type in self.handlers:
                    for handler in self.handlers[event_type]:
                        try:
                            await handler(Event(**event_data))
                        except Exception as e:
                            print(f"Handler error: {e}")

# Example: User signup triggers multiple actions
async def email_service_handler(event: Event):
    """Send welcome email"""
    print(f"ğŸ“§ Sending welcome email to {event.data['email']}")
    await asyncio.sleep(0.1)

async def analytics_handler(event: Event):
    """Track signup in analytics"""
    print(f"ğŸ“Š Recording signup in analytics: {event.data['user_id']}")

async def recommendation_handler(event: Event):
    """Initialize recommendations for new user"""
    print(f"ğŸ¯ Initializing recommendations for {event.data['user_id']}")

async def main():
    bus = EventBus()
    
    # Subscribe handlers
    await bus.subscribe("user.signup", email_service_handler)
    await bus.subscribe("user.signup", analytics_handler)
    await bus.subscribe("user.signup", recommendation_handler)
    
    # Start listening in background
    listen_task = asyncio.create_task(bus.listen())
    
    # Simulate user signups
    await asyncio.sleep(0.5)  # Wait for subscriptions
    
    await bus.publish("user.signup", {
        "user_id": 123,
        "email": "alice@example.com",
        "username": "alice"
    })
    
    await asyncio.sleep(1)  # Let handlers process
    listen_task.cancel()

# asyncio.run(main())
```

---

## 4.4 Event-Driven Architecture

### 4.4.1 Events as First-Class Citizens

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              EVENT-DRIVEN ARCHITECTURE                       â”‚
â”‚                                                              â”‚
â”‚   Traditional (Command-based):                              â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                â”‚
â”‚   Order Service â”€â”€[CreateOrder]â”€â”€â–¶ Inventory Service        â”‚
â”‚                 â”€â”€[ChargePayment]â”€â”€â–¶ Payment Service        â”‚
â”‚                 â”€â”€[SendNotification]â”€â”€â–¶ Notification Svc    â”‚
â”‚                                                              â”‚
â”‚   Tight coupling! Order service knows about everyone.       â”‚
â”‚                                                              â”‚
â”‚   Event-Driven:                                             â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                             â”‚
â”‚   Order Service â”€â”€[OrderCreated Event]â”€â”€â–¶ Event Bus         â”‚
â”‚                                              â”‚               â”‚
â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚                        â–¼                     â–¼           â–¼  â”‚
â”‚                   Inventory           Payment      Notification
â”‚                   (listens)          (listens)     (listens) â”‚
â”‚                                                              â”‚
â”‚   Loose coupling! Order service just publishes events.      â”‚
â”‚   New services can subscribe without changing Order Svc.    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.4.2 The Saga Pattern for Distributed Transactions

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SAGA PATTERN                              â”‚
â”‚                                                              â”‚
â”‚   Problem: How to handle transactions across services?      â”‚
â”‚                                                              â”‚
â”‚   Order Saga (happy path):                                  â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                  â”‚
â”‚   1. Create Order         âœ“                                 â”‚
â”‚   2. Reserve Inventory    âœ“                                 â”‚
â”‚   3. Process Payment      âœ“                                 â”‚
â”‚   4. Confirm Order        âœ“ Done!                           â”‚
â”‚                                                              â”‚
â”‚   Order Saga (failure with compensation):                   â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                     â”‚
â”‚   1. Create Order         âœ“                                 â”‚
â”‚   2. Reserve Inventory    âœ“                                 â”‚
â”‚   3. Process Payment      âœ— FAILED!                         â”‚
â”‚      â†“                                                       â”‚
â”‚   Compensate:                                               â”‚
â”‚   2'. Release Inventory   âœ“                                 â”‚
â”‚   1'. Cancel Order        âœ“                                 â”‚
â”‚                                                              â”‚
â”‚   Each step has a compensating action!                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
# saga_orchestrator.py
from enum import Enum
from dataclasses import dataclass, field
from typing import Callable, Any
import asyncio
import uuid

class SagaState(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    COMPENSATING = "compensating"
    FAILED = "failed"

@dataclass
class SagaStep:
    name: str
    action: Callable  # The forward action
    compensation: Callable  # The rollback action
    completed: bool = False

@dataclass 
class SagaContext:
    """Shared context passed between steps"""
    saga_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    data: dict = field(default_factory=dict)
    
class SagaOrchestrator:
    """Orchestrates a saga with automatic compensation on failure"""
    
    def __init__(self, name: str):
        self.name = name
        self.steps: list[SagaStep] = []
        self.state = SagaState.PENDING
        self.context = SagaContext()
    
    def add_step(
        self, 
        name: str, 
        action: Callable, 
        compensation: Callable
    ):
        """Add a step with its compensation"""
        self.steps.append(SagaStep(
            name=name,
            action=action,
            compensation=compensation
        ))
        return self
    
    async def execute(self, initial_data: dict = None) -> SagaContext:
        """Execute the saga with automatic rollback on failure"""
        self.state = SagaState.RUNNING
        self.context.data = initial_data or {}
        completed_steps = []
        
        try:
            for step in self.steps:
                print(f"[{self.name}] Executing: {step.name}")
                
                # Execute the step's action
                result = await step.action(self.context)
                
                if result is False:
                    raise Exception(f"Step {step.name} returned False")
                
                step.completed = True
                completed_steps.append(step)
                print(f"[{self.name}] Completed: {step.name}")
            
            self.state = SagaState.COMPLETED
            print(f"[{self.name}] Saga completed successfully!")
            return self.context
            
        except Exception as e:
            print(f"[{self.name}] Step failed: {e}")
            self.state = SagaState.COMPENSATING
            
            # Compensate in reverse order
            for step in reversed(completed_steps):
                try:
                    print(f"[{self.name}] Compensating: {step.name}")
                    await step.compensation(self.context)
                except Exception as comp_error:
                    print(f"[{self.name}] Compensation failed: {comp_error}")
                    # Log for manual intervention
            
            self.state = SagaState.FAILED
            raise

# Example: Order Processing Saga
async def create_order(ctx: SagaContext):
    """Step 1: Create the order"""
    order_id = str(uuid.uuid4())
    ctx.data['order_id'] = order_id
    print(f"  Created order: {order_id}")
    return True

async def cancel_order(ctx: SagaContext):
    """Compensation: Cancel the order"""
    print(f"  Cancelled order: {ctx.data['order_id']}")

async def reserve_inventory(ctx: SagaContext):
    """Step 2: Reserve inventory"""
    # Simulate inventory check
    items = ctx.data.get('items', [])
    ctx.data['reservation_id'] = str(uuid.uuid4())
    print(f"  Reserved {len(items)} items")
    return True

async def release_inventory(ctx: SagaContext):
    """Compensation: Release inventory"""
    print(f"  Released reservation: {ctx.data['reservation_id']}")

async def process_payment(ctx: SagaContext):
    """Step 3: Process payment"""
    amount = ctx.data.get('amount', 0)
    
    # Simulate payment failure for demo
    if amount > 1000:
        raise Exception("Payment declined: amount too high")
    
    ctx.data['payment_id'] = str(uuid.uuid4())
    print(f"  Payment processed: ${amount}")
    return True

async def refund_payment(ctx: SagaContext):
    """Compensation: Refund payment"""
    print(f"  Refunded payment: {ctx.data.get('payment_id', 'N/A')}")

async def confirm_order(ctx: SagaContext):
    """Step 4: Confirm order"""
    print(f"  Order confirmed!")
    return True

async def unconfirm_order(ctx: SagaContext):
    """Compensation: Unconfirm (usually no-op)"""
    pass

async def run_order_saga():
    saga = SagaOrchestrator("OrderSaga")
    
    saga.add_step("create_order", create_order, cancel_order)
    saga.add_step("reserve_inventory", reserve_inventory, release_inventory)
    saga.add_step("process_payment", process_payment, refund_payment)
    saga.add_step("confirm_order", confirm_order, unconfirm_order)
    
    # Success case
    print("\n=== Order $500 (should succeed) ===")
    try:
        await saga.execute({
            'items': [{'product': 'Laptop', 'qty': 1}],
            'amount': 500
        })
    except Exception as e:
        print(f"Saga failed: {e}")
    
    # Failure case - triggers compensation
    print("\n=== Order $1500 (should fail and compensate) ===")
    saga2 = SagaOrchestrator("OrderSaga")
    saga2.add_step("create_order", create_order, cancel_order)
    saga2.add_step("reserve_inventory", reserve_inventory, release_inventory)
    saga2.add_step("process_payment", process_payment, refund_payment)
    saga2.add_step("confirm_order", confirm_order, unconfirm_order)
    
    try:
        await saga2.execute({
            'items': [{'product': 'Server', 'qty': 10}],
            'amount': 1500  # This will fail!
        })
    except Exception as e:
        print(f"Saga failed: {e}")

# asyncio.run(run_order_saga())
```

---

## 4.5 Choosing the Right Pattern

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              COMMUNICATION PATTERN DECISION TREE             â”‚
â”‚                                                              â”‚
â”‚  Start: What does the caller need?                          â”‚
â”‚                        â”‚                                     â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€ Immediate Response â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚         â”‚                                 â”‚                  â”‚
â”‚         â–¼                                 â–¼                  â”‚
â”‚   Need response?                    Can wait?                â”‚
â”‚         â”‚                                 â”‚                  â”‚
â”‚    YES  â”‚  NO                       YES   â”‚  NO              â”‚
â”‚         â”‚                                 â”‚                  â”‚
â”‚         â–¼                                 â–¼                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚   â”‚  REST/  â”‚                      â”‚  Message  â”‚            â”‚
â”‚   â”‚  gRPC   â”‚                      â”‚   Queue   â”‚            â”‚
â”‚   â”‚(sync)   â”‚                      â”‚  (async)  â”‚            â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚         â”‚                                                    â”‚
â”‚         â–¼                                                    â”‚
â”‚   Need streaming?                                           â”‚
â”‚   â”‚           â”‚                                              â”‚
â”‚  YES         NO                                             â”‚
â”‚   â”‚           â”‚                                              â”‚
â”‚   â–¼           â–¼                                              â”‚
â”‚ gRPC       REST                                             â”‚
â”‚ Stream     (simple)                                         â”‚
â”‚                                                              â”‚
â”‚                                                              â”‚
â”‚  Who needs the data?                                        â”‚
â”‚         â”‚                                                    â”‚
â”‚    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                                              â”‚
â”‚    â”‚         â”‚                                               â”‚
â”‚  Single   Multiple                                          â”‚
â”‚  Consumer Consumers                                         â”‚
â”‚    â”‚         â”‚                                               â”‚
â”‚    â–¼         â–¼                                               â”‚
â”‚  Queue    Pub/Sub                                           â”‚
â”‚  (work)   (broadcast)                                       â”‚
â”‚                                                              â”‚
â”‚                                                              â”‚
â”‚  QUICK REFERENCE:                                           â”‚
â”‚  â”œâ”€â”€ REST: Public APIs, CRUD, browser clients               â”‚
â”‚  â”œâ”€â”€ gRPC: Internal services, high performance, streaming   â”‚
â”‚  â”œâ”€â”€ GraphQL: Complex data needs, mobile clients            â”‚
â”‚  â”œâ”€â”€ Message Queue: Background jobs, decoupling             â”‚
â”‚  â”œâ”€â”€ Pub/Sub: Event notification, multiple consumers        â”‚
â”‚  â””â”€â”€ Saga: Distributed transactions                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Summary

| Pattern | Use When | Examples |
|---------|----------|----------|
| **REST** | Public APIs, simple CRUD | User API, Product API |
| **gRPC** | Internal services, need speed | Microservices communication |
| **GraphQL** | Complex queries, mobile apps | Frontend data fetching |
| **Message Queue** | Async processing, decoupling | Email sending, order processing |
| **Pub/Sub** | Event broadcasting | Notifications, real-time updates |
| **Saga** | Distributed transactions | Order workflow, booking systems |

---

## Practice Exercises

1. Build a REST API with proper status codes and pagination
2. Create a gRPC service with streaming
3. Implement a task queue with Redis
4. Build a pub/sub system for notifications
5. Implement an order saga with compensation

**Next Chapter**: Serialization and protocols - how to efficiently encode data!
