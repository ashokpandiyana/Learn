# Chapter 9: Distributed Transactions

> **Goal**: Learn how to maintain data consistency across multiple services and databases

---

## 9.1 The Transaction Problem

### Why Distributed Transactions Are Hard

```
┌─────────────────────────────────────────────────────────────┐
│         THE DISTRIBUTED TRANSACTION PROBLEM                  │
│                                                              │
│  In a Monolith (Easy):                                      │
│  ─────────────────────                                      │
│  BEGIN TRANSACTION                                          │
│    UPDATE accounts SET balance = balance - 100 WHERE id=1   │
│    UPDATE accounts SET balance = balance + 100 WHERE id=2   │
│  COMMIT  ← Single database, ACID guaranteed!                │
│                                                              │
│                                                              │
│  In Microservices (Hard):                                   │
│  ────────────────────────                                   │
│                                                              │
│  Order Service          Payment Service        Inventory    │
│  ┌─────────────┐       ┌─────────────┐       ┌───────────┐ │
│  │ Create      │       │ Charge      │       │ Reserve   │ │
│  │ Order       │──────▶│ Payment     │──────▶│ Stock     │ │
│  └──────┬──────┘       └──────┬──────┘       └─────┬─────┘ │
│         │                     │                     │       │
│         ▼                     ▼                     ▼       │
│    ┌─────────┐          ┌─────────┐          ┌─────────┐   │
│    │Order DB │          │Payment  │          │Inventory│   │
│    │         │          │DB       │          │DB       │   │
│    └─────────┘          └─────────┘          └─────────┘   │
│                                                              │
│  THREE separate databases! No single transaction!           │
│                                                              │
│  What if Payment succeeds but Inventory fails?              │
│  ├── Customer charged but no product reserved               │
│  ├── Data is now INCONSISTENT across services               │
│  └── Need to "undo" the payment somehow                     │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 9.2 ACID Review

```
┌─────────────────────────────────────────────────────────────┐
│                    ACID PROPERTIES                           │
│                                                              │
│  A - ATOMICITY                                              │
│  ─────────────                                              │
│  "All or nothing"                                           │
│                                                              │
│  Either ALL operations succeed, or NONE do.                 │
│  No partial updates.                                        │
│                                                              │
│  ┌─────────────────────────────────────────────────┐       │
│  │ Transfer $100: A→B                               │       │
│  │                                                  │       │
│  │ ✗ A: -$100                                      │       │
│  │   B: +$0   ← System crashes before B update     │       │
│  │                                                  │       │
│  │ With Atomicity: Both rolled back, no money lost │       │
│  └─────────────────────────────────────────────────┘       │
│                                                              │
│                                                              │
│  C - CONSISTENCY                                            │
│  ─────────────────                                          │
│  "Valid state to valid state"                               │
│                                                              │
│  Database constraints are never violated.                   │
│  Invariants (e.g., total money) preserved.                 │
│                                                              │
│                                                              │
│  I - ISOLATION                                              │
│  ─────────────                                              │
│  "Transactions don't interfere"                             │
│                                                              │
│  Concurrent transactions behave as if sequential.           │
│  No dirty reads, phantom reads (at higher levels).         │
│                                                              │
│                                                              │
│  D - DURABILITY                                             │
│  ─────────────                                              │
│  "Committed means permanent"                                │
│                                                              │
│  Once committed, survives crashes, power loss.             │
│  Written to disk, replicated.                              │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 9.3 Two-Phase Commit (2PC)

### The Protocol

```
┌─────────────────────────────────────────────────────────────┐
│              TWO-PHASE COMMIT (2PC)                          │
│                                                              │
│  Classic algorithm for distributed transactions.            │
│  Uses a COORDINATOR to orchestrate participants.            │
│                                                              │
│                                                              │
│  PHASE 1: PREPARE (Voting)                                  │
│  ─────────────────────────                                  │
│                                                              │
│  Coordinator              Participants                      │
│      │                    ┌─────────┐                       │
│      │───"Prepare"───────▶│ Part. A │                       │
│      │                    │ (locks  │                       │
│      │◀──"Yes/No"─────────│ resources│                      │
│      │                    └─────────┘                       │
│      │                    ┌─────────┐                       │
│      │───"Prepare"───────▶│ Part. B │                       │
│      │◀──"Yes/No"─────────│         │                       │
│      │                    └─────────┘                       │
│                                                              │
│  Participants prepare but DON'T commit yet.                 │
│  They promise they CAN commit if asked.                     │
│                                                              │
│                                                              │
│  PHASE 2: COMMIT/ABORT (Decision)                           │
│  ────────────────────────────────                           │
│                                                              │
│  If ALL said "Yes":         If ANY said "No":               │
│      │                          │                            │
│      │───"Commit"──▶ All        │───"Abort"───▶ All         │
│      │                          │                            │
│      │◀──"Ack"──────            │◀──"Ack"──────             │
│                                                              │
│  Participants commit/abort based on coordinator decision.   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 2PC Implementation

```python
# two_phase_commit.py
import asyncio
from enum import Enum
from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional
from datetime import datetime
import uuid

class TransactionState(Enum):
    INIT = "init"
    PREPARING = "preparing"
    PREPARED = "prepared"
    COMMITTING = "committing"
    COMMITTED = "committed"
    ABORTING = "aborting"
    ABORTED = "aborted"

class VoteResult(Enum):
    YES = "yes"
    NO = "no"
    TIMEOUT = "timeout"

@dataclass
class TransactionLog:
    """Write-ahead log for recovery"""
    entries: List[dict] = field(default_factory=list)
    
    def log(self, tx_id: str, state: TransactionState, data: dict = None):
        self.entries.append({
            "tx_id": tx_id,
            "state": state.value,
            "timestamp": datetime.utcnow().isoformat(),
            "data": data
        })
        # In production: sync to disk!

class Participant:
    """A participant in 2PC (e.g., a database or service)"""
    
    def __init__(self, name: str, fail_on_prepare: bool = False):
        self.name = name
        self.fail_on_prepare = fail_on_prepare
        self.data: Dict[str, Any] = {}
        self.pending: Dict[str, dict] = {}  # tx_id -> pending changes
        self.log = TransactionLog()
    
    async def prepare(self, tx_id: str, operations: List[dict]) -> VoteResult:
        """
        Phase 1: Prepare to commit.
        Lock resources and vote yes/no.
        """
        try:
            # Simulate failure
            if self.fail_on_prepare:
                print(f"[{self.name}] Prepare FAILED (simulated)")
                return VoteResult.NO
            
            # Validate operations
            for op in operations:
                if op['type'] == 'SET':
                    # Check if we CAN do this operation
                    pass  # Validation logic here
            
            # Lock resources and store pending changes
            self.pending[tx_id] = {
                'operations': operations,
                'locked_keys': [op['key'] for op in operations]
            }
            
            # Log the prepare
            self.log.log(tx_id, TransactionState.PREPARED, {'operations': operations})
            
            print(f"[{self.name}] Voted YES for {tx_id}")
            return VoteResult.YES
            
        except Exception as e:
            print(f"[{self.name}] Prepare failed: {e}")
            return VoteResult.NO
    
    async def commit(self, tx_id: str) -> bool:
        """Phase 2: Commit the transaction"""
        if tx_id not in self.pending:
            print(f"[{self.name}] Unknown transaction {tx_id}")
            return False
        
        pending = self.pending[tx_id]
        
        # Apply operations
        for op in pending['operations']:
            if op['type'] == 'SET':
                self.data[op['key']] = op['value']
            elif op['type'] == 'DELETE':
                self.data.pop(op['key'], None)
        
        # Log and cleanup
        self.log.log(tx_id, TransactionState.COMMITTED)
        del self.pending[tx_id]
        
        print(f"[{self.name}] COMMITTED {tx_id}")
        return True
    
    async def abort(self, tx_id: str) -> bool:
        """Phase 2: Abort the transaction"""
        if tx_id in self.pending:
            self.log.log(tx_id, TransactionState.ABORTED)
            del self.pending[tx_id]
        
        print(f"[{self.name}] ABORTED {tx_id}")
        return True

class Coordinator:
    """Coordinates 2PC across participants"""
    
    def __init__(self, participants: List[Participant]):
        self.participants = participants
        self.log = TransactionLog()
        self.timeout = 5.0  # seconds
    
    async def execute_transaction(
        self, 
        operations_by_participant: Dict[str, List[dict]]
    ) -> bool:
        """
        Execute a distributed transaction using 2PC.
        """
        tx_id = str(uuid.uuid4())[:8]
        print(f"\n{'='*50}")
        print(f"Starting transaction {tx_id}")
        print(f"{'='*50}")
        
        # Log transaction start
        self.log.log(tx_id, TransactionState.PREPARING)
        
        # ===== PHASE 1: PREPARE =====
        print(f"\n--- Phase 1: Prepare ---")
        
        prepare_tasks = []
        for participant in self.participants:
            ops = operations_by_participant.get(participant.name, [])
            if ops:
                task = self._prepare_with_timeout(participant, tx_id, ops)
                prepare_tasks.append((participant, task))
        
        votes = {}
        for participant, task in prepare_tasks:
            try:
                vote = await task
                votes[participant.name] = vote
            except asyncio.TimeoutError:
                votes[participant.name] = VoteResult.TIMEOUT
        
        # Check if all voted yes
        all_yes = all(v == VoteResult.YES for v in votes.values())
        
        # ===== PHASE 2: COMMIT or ABORT =====
        if all_yes:
            print(f"\n--- Phase 2: Commit (all voted YES) ---")
            self.log.log(tx_id, TransactionState.COMMITTING)
            
            for participant in self.participants:
                await participant.commit(tx_id)
            
            self.log.log(tx_id, TransactionState.COMMITTED)
            print(f"\n✓ Transaction {tx_id} COMMITTED")
            return True
        else:
            print(f"\n--- Phase 2: Abort (not all YES) ---")
            print(f"Votes: {votes}")
            self.log.log(tx_id, TransactionState.ABORTING)
            
            for participant in self.participants:
                await participant.abort(tx_id)
            
            self.log.log(tx_id, TransactionState.ABORTED)
            print(f"\n✗ Transaction {tx_id} ABORTED")
            return False
    
    async def _prepare_with_timeout(
        self, 
        participant: Participant, 
        tx_id: str, 
        operations: List[dict]
    ) -> VoteResult:
        """Prepare with timeout handling"""
        try:
            return await asyncio.wait_for(
                participant.prepare(tx_id, operations),
                timeout=self.timeout
            )
        except asyncio.TimeoutError:
            print(f"[{participant.name}] Prepare TIMEOUT")
            return VoteResult.TIMEOUT

# ============== DEMO ==============

async def demo_2pc():
    # Create participants
    order_db = Participant("OrderDB")
    payment_db = Participant("PaymentDB")
    inventory_db = Participant("InventoryDB")
    
    coordinator = Coordinator([order_db, payment_db, inventory_db])
    
    # Successful transaction
    print("\n" + "="*60)
    print("SCENARIO 1: Successful Transaction")
    print("="*60)
    
    success = await coordinator.execute_transaction({
        "OrderDB": [{"type": "SET", "key": "order:1", "value": {"status": "created"}}],
        "PaymentDB": [{"type": "SET", "key": "payment:1", "value": {"amount": 100}}],
        "InventoryDB": [{"type": "SET", "key": "stock:item1", "value": {"reserved": 1}}]
    })
    
    print(f"\nFinal state:")
    print(f"  OrderDB: {order_db.data}")
    print(f"  PaymentDB: {payment_db.data}")
    print(f"  InventoryDB: {inventory_db.data}")
    
    # Failed transaction
    print("\n" + "="*60)
    print("SCENARIO 2: Failed Transaction (Inventory fails)")
    print("="*60)
    
    # Make inventory fail
    inventory_db_failing = Participant("InventoryDB", fail_on_prepare=True)
    coordinator2 = Coordinator([
        Participant("OrderDB"),
        Participant("PaymentDB"),
        inventory_db_failing
    ])
    
    success = await coordinator2.execute_transaction({
        "OrderDB": [{"type": "SET", "key": "order:2", "value": {"status": "created"}}],
        "PaymentDB": [{"type": "SET", "key": "payment:2", "value": {"amount": 200}}],
        "InventoryDB": [{"type": "SET", "key": "stock:item2", "value": {"reserved": 1}}]
    })

# asyncio.run(demo_2pc())
```

### 2PC Problems

```
┌─────────────────────────────────────────────────────────────┐
│                 2PC PROBLEMS                                 │
│                                                              │
│  1. BLOCKING                                                │
│  ────────────                                               │
│  If coordinator crashes after sending "Prepare"             │
│  but before sending "Commit/Abort":                         │
│                                                              │
│  Participants are STUCK holding locks!                      │
│  They can't commit (don't know decision)                    │
│  They can't abort (might lose data)                         │
│                                                              │
│       ┌─────────────┐                                       │
│       │ Coordinator │ ← CRASHED!                            │
│       │   (dead)    │                                       │
│       └─────────────┘                                       │
│              ?                                               │
│       ┌─────────────┐                                       │
│       │ Participant │ ← "Do I commit or abort??"            │
│       │  (waiting)  │    (holding locks forever)            │
│       └─────────────┘                                       │
│                                                              │
│                                                              │
│  2. NOT PARTITION TOLERANT                                  │
│  ─────────────────────────                                  │
│  Network partition = some participants unreachable          │
│  Can't get all votes = must abort                           │
│                                                              │
│                                                              │
│  3. PERFORMANCE                                             │
│  ─────────────                                              │
│  - Multiple round trips (prepare + commit)                  │
│  - Locks held during entire process                         │
│  - Latency = slowest participant                            │
│                                                              │
│                                                              │
│  Better Alternative: SAGA PATTERN                           │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 9.4 The Saga Pattern

### Saga Overview

```
┌─────────────────────────────────────────────────────────────┐
│                    SAGA PATTERN                              │
│                                                              │
│  A saga is a sequence of LOCAL transactions.                │
│  Each transaction updates one service and publishes events. │
│  If one fails, compensating transactions undo previous.     │
│                                                              │
│                                                              │
│  Order Saga - Happy Path:                                   │
│  ─────────────────────────                                  │
│                                                              │
│  ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐    │
│  │ Create  │──▶│ Reserve │──▶│ Process │──▶│ Confirm │    │
│  │ Order   │   │ Stock   │   │ Payment │   │ Order   │    │
│  │   T1    │   │   T2    │   │   T3    │   │   T4    │    │
│  └─────────┘   └─────────┘   └─────────┘   └─────────┘    │
│       │             │             │             │           │
│       ▼             ▼             ▼             ▼           │
│     [Order       [Inventory    [Payment      [Order        │
│      Created]     Reserved]     Done]         Confirmed]   │
│                                                              │
│                                                              │
│  Order Saga - Failure with Compensation:                    │
│  ────────────────────────────────────────                   │
│                                                              │
│  ┌─────────┐   ┌─────────┐   ┌─────────┐                   │
│  │ Create  │──▶│ Reserve │──▶│ Process │ ✗ FAILED!        │
│  │ Order   │   │ Stock   │   │ Payment │                   │
│  │   T1    │   │   T2    │   │   T3    │                   │
│  └────┬────┘   └────┬────┘   └─────────┘                   │
│       │             │                                        │
│       │   Compensate│                                        │
│       │             ▼                                        │
│       │       ┌─────────┐                                   │
│       │       │ Release │  ← Undo T2                        │
│       │       │ Stock   │                                   │
│       │       │   C2    │                                   │
│       │       └─────────┘                                   │
│       │                                                      │
│       ▼                                                      │
│  ┌─────────┐                                                │
│  │ Cancel  │  ← Undo T1                                     │
│  │ Order   │                                                │
│  │   C1    │                                                │
│  └─────────┘                                                │
│                                                              │
│  Each step has a COMPENSATING TRANSACTION!                  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Saga Orchestration vs Choreography

```
┌─────────────────────────────────────────────────────────────┐
│          SAGA: ORCHESTRATION vs CHOREOGRAPHY                 │
│                                                              │
│  ORCHESTRATION (Centralized)                                │
│  ────────────────────────────                               │
│                                                              │
│  Central orchestrator tells each service what to do.        │
│                                                              │
│                  ┌──────────────┐                           │
│                  │ Orchestrator │                           │
│                  │  (Conductor) │                           │
│                  └──────┬───────┘                           │
│            ┌────────────┼────────────┐                      │
│            ▼            ▼            ▼                       │
│       ┌─────────┐ ┌─────────┐ ┌─────────┐                  │
│       │ Order   │ │ Payment │ │Inventory│                  │
│       │ Service │ │ Service │ │ Service │                  │
│       └─────────┘ └─────────┘ └─────────┘                  │
│                                                              │
│  Pros: Easy to understand, centralized logic                │
│  Cons: Single point of failure, tighter coupling            │
│                                                              │
│                                                              │
│  CHOREOGRAPHY (Decentralized)                               │
│  ─────────────────────────────                              │
│                                                              │
│  Services communicate via events. No central coordinator.   │
│                                                              │
│  ┌─────────┐   Event    ┌─────────┐   Event    ┌─────────┐ │
│  │ Order   │──────────▶│ Payment │──────────▶│Inventory│ │
│  │ Service │  OrderCreated Service │PaymentDone Service │ │
│  └─────────┘           └─────────┘           └─────────┘  │
│       ▲                                           │         │
│       └───────────── StockReserved ───────────────┘         │
│                                                              │
│  Pros: Loosely coupled, no SPOF                             │
│  Cons: Hard to track, complex flow                          │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Complete Saga Implementation (Orchestration)

```python
# saga_orchestrator.py
import asyncio
from enum import Enum
from dataclasses import dataclass, field
from typing import Callable, Any, List, Optional, Dict
from datetime import datetime
import uuid
import traceback

class SagaState(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    COMPENSATING = "compensating"
    COMPENSATED = "compensated"
    FAILED = "failed"

class StepState(Enum):
    PENDING = "pending"
    EXECUTING = "executing"
    COMPLETED = "completed"
    FAILED = "failed"
    COMPENSATING = "compensating"
    COMPENSATED = "compensated"

@dataclass
class SagaStep:
    name: str
    action: Callable  # async function to execute
    compensation: Callable  # async function to undo
    state: StepState = StepState.PENDING
    result: Any = None
    error: Optional[str] = None

@dataclass
class SagaContext:
    """Shared context passed between saga steps"""
    saga_id: str = field(default_factory=lambda: str(uuid.uuid4())[:8])
    data: Dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.utcnow)

class SagaOrchestrator:
    """
    Orchestrates a saga with automatic compensation on failure.
    Implements the Saga pattern for distributed transactions.
    """
    
    def __init__(self, name: str):
        self.name = name
        self.steps: List[SagaStep] = []
        self.state = SagaState.PENDING
        self.context: Optional[SagaContext] = None
        self.completed_steps: List[SagaStep] = []
    
    def add_step(
        self,
        name: str,
        action: Callable,
        compensation: Callable
    ) -> 'SagaOrchestrator':
        """Add a step to the saga (fluent interface)"""
        self.steps.append(SagaStep(
            name=name,
            action=action,
            compensation=compensation
        ))
        return self
    
    async def execute(self, initial_data: Dict[str, Any] = None) -> SagaContext:
        """Execute the saga with automatic compensation on failure"""
        self.context = SagaContext()
        self.context.data = initial_data or {}
        self.state = SagaState.RUNNING
        self.completed_steps = []
        
        print(f"\n{'='*60}")
        print(f"SAGA [{self.name}] Starting (ID: {self.context.saga_id})")
        print(f"{'='*60}")
        
        try:
            # Execute each step in order
            for step in self.steps:
                await self._execute_step(step)
                self.completed_steps.append(step)
            
            self.state = SagaState.COMPLETED
            print(f"\n✓ SAGA [{self.name}] COMPLETED successfully")
            return self.context
            
        except Exception as e:
            print(f"\n✗ SAGA [{self.name}] FAILED: {e}")
            print(f"  Starting compensation...")
            
            await self._compensate()
            raise SagaFailedException(
                saga_name=self.name,
                failed_step=step.name,
                error=str(e),
                context=self.context
            )
    
    async def _execute_step(self, step: SagaStep):
        """Execute a single saga step"""
        print(f"\n→ Step [{step.name}] executing...")
        step.state = StepState.EXECUTING
        
        try:
            result = await step.action(self.context)
            step.result = result
            step.state = StepState.COMPLETED
            print(f"  ✓ Step [{step.name}] completed")
            
        except Exception as e:
            step.state = StepState.FAILED
            step.error = str(e)
            print(f"  ✗ Step [{step.name}] failed: {e}")
            raise
    
    async def _compensate(self):
        """Compensate completed steps in reverse order"""
        self.state = SagaState.COMPENSATING
        
        for step in reversed(self.completed_steps):
            try:
                print(f"\n← Compensating [{step.name}]...")
                step.state = StepState.COMPENSATING
                
                await step.compensation(self.context)
                
                step.state = StepState.COMPENSATED
                print(f"  ✓ Compensation [{step.name}] done")
                
            except Exception as e:
                print(f"  ⚠ Compensation [{step.name}] failed: {e}")
                # Log for manual intervention!
                # In production: alert, retry queue, etc.
        
        self.state = SagaState.COMPENSATED
        print(f"\n↩ SAGA [{self.name}] compensated")

@dataclass
class SagaFailedException(Exception):
    saga_name: str
    failed_step: str
    error: str
    context: SagaContext
    
    def __str__(self):
        return f"Saga '{self.saga_name}' failed at step '{self.failed_step}': {self.error}"

# ============== EXAMPLE: ORDER SAGA ==============

# Simulated services
class OrderService:
    orders = {}
    
    @staticmethod
    async def create_order(ctx: SagaContext) -> str:
        order_id = f"ORD-{ctx.saga_id}"
        OrderService.orders[order_id] = {
            "id": order_id,
            "user_id": ctx.data.get("user_id"),
            "items": ctx.data.get("items"),
            "status": "CREATED",
            "total": ctx.data.get("total", 0)
        }
        ctx.data["order_id"] = order_id
        print(f"    Created order {order_id}")
        return order_id
    
    @staticmethod
    async def cancel_order(ctx: SagaContext):
        order_id = ctx.data.get("order_id")
        if order_id in OrderService.orders:
            OrderService.orders[order_id]["status"] = "CANCELLED"
            print(f"    Cancelled order {order_id}")

class PaymentService:
    payments = {}
    
    @staticmethod
    async def process_payment(ctx: SagaContext) -> str:
        # Simulate payment failure based on amount
        if ctx.data.get("total", 0) > 1000:
            raise Exception("Payment declined: amount exceeds limit")
        
        payment_id = f"PAY-{ctx.saga_id}"
        PaymentService.payments[payment_id] = {
            "id": payment_id,
            "order_id": ctx.data.get("order_id"),
            "amount": ctx.data.get("total"),
            "status": "COMPLETED"
        }
        ctx.data["payment_id"] = payment_id
        print(f"    Processed payment {payment_id} for ${ctx.data.get('total')}")
        return payment_id
    
    @staticmethod
    async def refund_payment(ctx: SagaContext):
        payment_id = ctx.data.get("payment_id")
        if payment_id in PaymentService.payments:
            PaymentService.payments[payment_id]["status"] = "REFUNDED"
            print(f"    Refunded payment {payment_id}")

class InventoryService:
    inventory = {"ITEM-001": 10, "ITEM-002": 5}
    reservations = {}
    
    @staticmethod
    async def reserve_inventory(ctx: SagaContext) -> str:
        items = ctx.data.get("items", [])
        reservation_id = f"RES-{ctx.saga_id}"
        
        # Check availability
        for item in items:
            available = InventoryService.inventory.get(item["sku"], 0)
            if available < item["quantity"]:
                raise Exception(f"Insufficient stock for {item['sku']}")
        
        # Reserve items
        for item in items:
            InventoryService.inventory[item["sku"]] -= item["quantity"]
        
        InventoryService.reservations[reservation_id] = items
        ctx.data["reservation_id"] = reservation_id
        print(f"    Reserved inventory {reservation_id}")
        return reservation_id
    
    @staticmethod
    async def release_inventory(ctx: SagaContext):
        reservation_id = ctx.data.get("reservation_id")
        if reservation_id in InventoryService.reservations:
            items = InventoryService.reservations[reservation_id]
            for item in items:
                InventoryService.inventory[item["sku"]] += item["quantity"]
            del InventoryService.reservations[reservation_id]
            print(f"    Released inventory {reservation_id}")

class ShippingService:
    shipments = {}
    
    @staticmethod
    async def create_shipment(ctx: SagaContext) -> str:
        shipment_id = f"SHIP-{ctx.saga_id}"
        ShippingService.shipments[shipment_id] = {
            "id": shipment_id,
            "order_id": ctx.data.get("order_id"),
            "status": "PENDING"
        }
        ctx.data["shipment_id"] = shipment_id
        print(f"    Created shipment {shipment_id}")
        return shipment_id
    
    @staticmethod
    async def cancel_shipment(ctx: SagaContext):
        shipment_id = ctx.data.get("shipment_id")
        if shipment_id in ShippingService.shipments:
            ShippingService.shipments[shipment_id]["status"] = "CANCELLED"
            print(f"    Cancelled shipment {shipment_id}")

# ============== RUNNING THE SAGA ==============

async def create_order_saga(order_data: dict) -> SagaContext:
    """Create and execute an order saga"""
    saga = SagaOrchestrator("OrderSaga")
    
    saga.add_step(
        name="CreateOrder",
        action=OrderService.create_order,
        compensation=OrderService.cancel_order
    ).add_step(
        name="ReserveInventory", 
        action=InventoryService.reserve_inventory,
        compensation=InventoryService.release_inventory
    ).add_step(
        name="ProcessPayment",
        action=PaymentService.process_payment,
        compensation=PaymentService.refund_payment
    ).add_step(
        name="CreateShipment",
        action=ShippingService.create_shipment,
        compensation=ShippingService.cancel_shipment
    )
    
    return await saga.execute(order_data)

async def demo_saga():
    # Scenario 1: Successful order
    print("\n" + "="*70)
    print("SCENARIO 1: Successful Order ($99)")
    print("="*70)
    
    try:
        ctx = await create_order_saga({
            "user_id": "USER-123",
            "items": [{"sku": "ITEM-001", "quantity": 2}],
            "total": 99
        })
        print(f"\nOrder completed! Order ID: {ctx.data['order_id']}")
    except SagaFailedException as e:
        print(f"\nOrder failed: {e}")
    
    # Scenario 2: Failed order (payment exceeds limit)
    print("\n" + "="*70)
    print("SCENARIO 2: Failed Order ($1500 - exceeds payment limit)")
    print("="*70)
    
    try:
        ctx = await create_order_saga({
            "user_id": "USER-456",
            "items": [{"sku": "ITEM-002", "quantity": 1}],
            "total": 1500  # Will fail payment
        })
    except SagaFailedException as e:
        print(f"\nOrder rolled back: {e}")
    
    # Check final state
    print("\n" + "="*70)
    print("FINAL STATE")
    print("="*70)
    print(f"Orders: {OrderService.orders}")
    print(f"Payments: {PaymentService.payments}")
    print(f"Inventory: {InventoryService.inventory}")
    print(f"Shipments: {ShippingService.shipments}")

# asyncio.run(demo_saga())
```

---

## 9.5 Transactional Outbox Pattern

```
┌─────────────────────────────────────────────────────────────┐
│           TRANSACTIONAL OUTBOX PATTERN                       │
│                                                              │
│  Problem: How to reliably publish events after DB write?    │
│                                                              │
│  Naive approach (WRONG):                                    │
│  ───────────────────────                                    │
│  1. Write to database                                       │
│  2. Publish to message queue                                │
│                                                              │
│  What if publish fails after DB write?                      │
│  → Data saved but event lost!                               │
│                                                              │
│                                                              │
│  Outbox Pattern (CORRECT):                                  │
│  ─────────────────────────                                  │
│                                                              │
│  ┌───────────────────────────────────────────────┐         │
│  │              Same Transaction                  │         │
│  │  ┌─────────────────┐   ┌─────────────────┐   │         │
│  │  │ Business Table  │   │  Outbox Table   │   │         │
│  │  │                 │   │                 │   │         │
│  │  │ INSERT order    │   │ INSERT event    │   │         │
│  │  │                 │   │ (to be sent)    │   │         │
│  │  └─────────────────┘   └─────────────────┘   │         │
│  └───────────────────────────────────────────────┘         │
│                                │                            │
│                                ▼                            │
│                    ┌───────────────────────┐               │
│                    │  Message Relay        │               │
│                    │  (polls outbox,       │               │
│                    │   publishes events,   │               │
│                    │   marks as sent)      │               │
│                    └───────────┬───────────┘               │
│                                │                            │
│                                ▼                            │
│                    ┌───────────────────────┐               │
│                    │    Message Queue      │               │
│                    │    (Kafka, etc.)      │               │
│                    └───────────────────────┘               │
│                                                              │
│  Atomic: Both writes in same DB transaction!                │
│  Reliable: Relay retries until event is published.          │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

```python
# outbox_pattern.py
import asyncio
import asyncpg
import json
from datetime import datetime
from typing import Any, Dict
import uuid

class OutboxService:
    """
    Implements the Transactional Outbox pattern.
    Ensures reliable event publishing after database changes.
    """
    
    def __init__(self, pool: asyncpg.Pool):
        self.pool = pool
    
    async def setup(self):
        """Create outbox table"""
        async with self.pool.acquire() as conn:
            await conn.execute('''
                CREATE TABLE IF NOT EXISTS outbox (
                    id UUID PRIMARY KEY,
                    aggregate_type VARCHAR(255) NOT NULL,
                    aggregate_id VARCHAR(255) NOT NULL,
                    event_type VARCHAR(255) NOT NULL,
                    payload JSONB NOT NULL,
                    created_at TIMESTAMP DEFAULT NOW(),
                    published_at TIMESTAMP NULL
                )
            ''')
            
            await conn.execute('''
                CREATE INDEX IF NOT EXISTS idx_outbox_unpublished 
                ON outbox (created_at) 
                WHERE published_at IS NULL
            ''')
    
    async def execute_with_outbox(
        self,
        business_query: str,
        business_params: tuple,
        event_type: str,
        aggregate_type: str,
        aggregate_id: str,
        event_payload: Dict[str, Any]
    ):
        """
        Execute business logic and add outbox event in same transaction.
        """
        async with self.pool.acquire() as conn:
            async with conn.transaction():
                # Execute business logic
                await conn.execute(business_query, *business_params)
                
                # Add event to outbox (same transaction!)
                event_id = uuid.uuid4()
                await conn.execute('''
                    INSERT INTO outbox (id, aggregate_type, aggregate_id, event_type, payload)
                    VALUES ($1, $2, $3, $4, $5)
                ''', event_id, aggregate_type, aggregate_id, event_type, json.dumps(event_payload))
                
                return event_id

class OutboxRelay:
    """
    Polls outbox table and publishes events to message queue.
    """
    
    def __init__(self, pool: asyncpg.Pool, publisher):
        self.pool = pool
        self.publisher = publisher  # Kafka, RabbitMQ, etc.
        self.batch_size = 100
        self.poll_interval = 1.0  # seconds
        self.running = False
    
    async def start(self):
        """Start the relay process"""
        self.running = True
        print("Outbox relay started")
        
        while self.running:
            try:
                processed = await self._process_batch()
                if processed == 0:
                    await asyncio.sleep(self.poll_interval)
            except Exception as e:
                print(f"Relay error: {e}")
                await asyncio.sleep(self.poll_interval)
    
    async def stop(self):
        self.running = False
    
    async def _process_batch(self) -> int:
        """Process a batch of unpublished events"""
        async with self.pool.acquire() as conn:
            # Get unpublished events
            rows = await conn.fetch('''
                SELECT id, aggregate_type, aggregate_id, event_type, payload
                FROM outbox
                WHERE published_at IS NULL
                ORDER BY created_at
                LIMIT $1
                FOR UPDATE SKIP LOCKED
            ''', self.batch_size)
            
            if not rows:
                return 0
            
            published_ids = []
            
            for row in rows:
                try:
                    # Publish to message queue
                    await self.publisher.publish(
                        topic=f"{row['aggregate_type']}.{row['event_type']}",
                        key=row['aggregate_id'],
                        value={
                            "event_id": str(row['id']),
                            "event_type": row['event_type'],
                            "aggregate_type": row['aggregate_type'],
                            "aggregate_id": row['aggregate_id'],
                            "payload": json.loads(row['payload'])
                        }
                    )
                    published_ids.append(row['id'])
                    
                except Exception as e:
                    print(f"Failed to publish {row['id']}: {e}")
            
            # Mark as published
            if published_ids:
                await conn.execute('''
                    UPDATE outbox 
                    SET published_at = NOW()
                    WHERE id = ANY($1)
                ''', published_ids)
            
            return len(published_ids)

# ============== USAGE EXAMPLE ==============

class OrderRepository:
    def __init__(self, outbox: OutboxService):
        self.outbox = outbox
    
    async def create_order(self, order_data: dict) -> str:
        """Create order and publish event atomically"""
        order_id = str(uuid.uuid4())
        
        await self.outbox.execute_with_outbox(
            # Business logic
            business_query='''
                INSERT INTO orders (id, user_id, total, status)
                VALUES ($1, $2, $3, $4)
            ''',
            business_params=(order_id, order_data['user_id'], 
                           order_data['total'], 'CREATED'),
            
            # Event to publish
            event_type='OrderCreated',
            aggregate_type='Order',
            aggregate_id=order_id,
            event_payload={
                'order_id': order_id,
                'user_id': order_data['user_id'],
                'total': order_data['total'],
                'items': order_data.get('items', [])
            }
        )
        
        return order_id
```

---

## 9.6 Choosing the Right Approach

```
┌─────────────────────────────────────────────────────────────┐
│         DISTRIBUTED TRANSACTION DECISION GUIDE               │
│                                                              │
│  Question 1: Can you use a single database?                 │
│  ─────────────────────────────────────────                  │
│  YES → Use regular ACID transactions                        │
│  NO  → Continue...                                          │
│                                                              │
│                                                              │
│  Question 2: Is strong consistency required?                │
│  ────────────────────────────────────────                   │
│                                                              │
│  YES (financial, inventory) →                               │
│      Use 2PC or Saga with careful design                    │
│      Accept higher latency                                  │
│                                                              │
│  NO (most cases) →                                          │
│      Use Saga with eventual consistency                     │
│      Much simpler and more available                        │
│                                                              │
│                                                              │
│  Question 3: How complex is the workflow?                   │
│  ─────────────────────────────────────────                  │
│                                                              │
│  Simple (2-3 steps) → Choreography                         │
│  Complex (4+ steps) → Orchestration                        │
│  Very complex → Consider workflow engines (Temporal)        │
│                                                              │
│                                                              │
│  SUMMARY:                                                   │
│  ├── Single DB: ACID transactions                           │
│  ├── Multiple DBs, strong consistency: 2PC (rare)          │
│  ├── Multiple services: Saga pattern (most common)         │
│  └── Reliable events: Outbox pattern                        │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## Summary

| Approach | Use When | Trade-offs |
|----------|----------|------------|
| **ACID** | Single database | Best consistency, limited to one DB |
| **2PC** | Need strong consistency | Blocking, slow, complex |
| **Saga** | Microservices | Eventually consistent, must handle compensation |
| **Outbox** | Reliable events | Extra complexity, but guaranteed delivery |

---

## Practice Exercises

1. Implement 2PC with timeout handling
2. Build an order saga with 4 steps and compensations
3. Implement the transactional outbox pattern
4. Create a saga that handles partial failures
5. Compare choreography vs orchestration for your use case

**Next Chapter**: Caching strategies for distributed systems!
