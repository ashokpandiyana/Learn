# Chapter 21: Deep Dive Case Studies

> **Goal**: Walk through complete system designs for common interview problems

---

## 21.1 Design a Rate Limiter

### Requirements

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              RATE LIMITER REQUIREMENTS                       â”‚
â”‚                                                              â”‚
â”‚  Functional:                                                â”‚
â”‚  â”œâ”€â”€ Limit requests per user/IP/API key                     â”‚
â”‚  â”œâ”€â”€ Configurable limits (100 req/min, 1000 req/hour)       â”‚
â”‚  â”œâ”€â”€ Return appropriate error when limit exceeded           â”‚
â”‚  â””â”€â”€ Support multiple rate limiting rules                   â”‚
â”‚                                                              â”‚
â”‚  Non-Functional:                                            â”‚
â”‚  â”œâ”€â”€ Low latency (< 10ms overhead per request)              â”‚
â”‚  â”œâ”€â”€ Distributed (works across multiple servers)            â”‚
â”‚  â”œâ”€â”€ Accurate (no significant over/under counting)          â”‚
â”‚  â””â”€â”€ Fault tolerant (service continues if limiter fails)    â”‚
â”‚                                                              â”‚
â”‚  Scale:                                                     â”‚
â”‚  â”œâ”€â”€ 10 million users                                       â”‚
â”‚  â”œâ”€â”€ 100,000 requests/second                                â”‚
â”‚  â””â”€â”€ Multiple data centers                                  â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### High-Level Design

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              RATE LIMITER ARCHITECTURE                       â”‚
â”‚                                                              â”‚
â”‚    Client Request                                           â”‚
â”‚         â”‚                                                    â”‚
â”‚         â–¼                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                            â”‚
â”‚  â”‚  API Gateway â”‚                                           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                            â”‚
â”‚         â”‚                                                    â”‚
â”‚         â–¼                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚  â”‚    Rate Limiter         â”‚                                â”‚
â”‚  â”‚    Middleware           â”‚                                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚         â”‚                                                    â”‚
â”‚         â–¼                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚  â”‚    Redis Cluster        â”‚ â† Distributed counter storage  â”‚
â”‚  â”‚                         â”‚                                â”‚
â”‚  â”‚  key: user:123:minute   â”‚                                â”‚
â”‚  â”‚  value: 45              â”‚                                â”‚
â”‚  â”‚  TTL: 60 seconds        â”‚                                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚         â”‚                                                    â”‚
â”‚    Allow/Deny                                               â”‚
â”‚         â”‚                                                    â”‚
â”‚         â–¼                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                            â”‚
â”‚  â”‚  Backend    â”‚                                            â”‚
â”‚  â”‚  Services   â”‚                                            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                            â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Algorithms Deep Dive

```python
# rate_limiter_algorithms.py
import time
import asyncio
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, Optional, Tuple
import redis.asyncio as redis

class RateLimiter(ABC):
    """Base class for rate limiters"""
    
    @abstractmethod
    async def is_allowed(self, key: str) -> Tuple[bool, dict]:
        """Check if request is allowed. Returns (allowed, metadata)"""
        pass

# ============== ALGORITHM 1: TOKEN BUCKET ==============

class TokenBucketLimiter(RateLimiter):
    """
    Token Bucket Algorithm
    
    - Bucket holds tokens (max = capacity)
    - Tokens added at fixed rate
    - Request consumes 1 token
    - Request allowed if tokens available
    
    Pros: Allows bursts up to bucket capacity
    Cons: Slightly more complex
    
    Use for: APIs that allow short bursts
    """
    
    def __init__(
        self, 
        redis_client: redis.Redis,
        capacity: int = 100,      # Max tokens in bucket
        refill_rate: float = 10   # Tokens per second
    ):
        self.redis = redis_client
        self.capacity = capacity
        self.refill_rate = refill_rate
    
    async def is_allowed(self, key: str) -> Tuple[bool, dict]:
        now = time.time()
        bucket_key = f"token_bucket:{key}"
        
        # Lua script for atomic token bucket operation
        lua_script = """
        local key = KEYS[1]
        local capacity = tonumber(ARGV[1])
        local refill_rate = tonumber(ARGV[2])
        local now = tonumber(ARGV[3])
        
        -- Get current state
        local bucket = redis.call('HMGET', key, 'tokens', 'last_refill')
        local tokens = tonumber(bucket[1]) or capacity
        local last_refill = tonumber(bucket[2]) or now
        
        -- Calculate tokens to add based on time elapsed
        local elapsed = now - last_refill
        local tokens_to_add = elapsed * refill_rate
        tokens = math.min(capacity, tokens + tokens_to_add)
        
        -- Try to consume a token
        local allowed = 0
        if tokens >= 1 then
            tokens = tokens - 1
            allowed = 1
        end
        
        -- Save state
        redis.call('HMSET', key, 'tokens', tokens, 'last_refill', now)
        redis.call('EXPIRE', key, 3600)  -- Cleanup after 1 hour
        
        return {allowed, tokens}
        """
        
        result = await self.redis.eval(
            lua_script, 1, bucket_key,
            self.capacity, self.refill_rate, now
        )
        
        allowed = result[0] == 1
        remaining = result[1]
        
        return allowed, {
            "remaining_tokens": remaining,
            "capacity": self.capacity,
            "refill_rate": self.refill_rate
        }

# ============== ALGORITHM 2: SLIDING WINDOW LOG ==============

class SlidingWindowLogLimiter(RateLimiter):
    """
    Sliding Window Log Algorithm
    
    - Store timestamp of each request
    - Count requests in current window
    - Most accurate but memory intensive
    
    Pros: Very accurate, no boundary issues
    Cons: High memory usage (stores all timestamps)
    
    Use for: When accuracy is critical
    """
    
    def __init__(
        self,
        redis_client: redis.Redis,
        limit: int = 100,
        window_seconds: int = 60
    ):
        self.redis = redis_client
        self.limit = limit
        self.window_seconds = window_seconds
    
    async def is_allowed(self, key: str) -> Tuple[bool, dict]:
        now = time.time()
        window_start = now - self.window_seconds
        log_key = f"sliding_log:{key}"
        
        # Lua script for atomic sliding window operation
        lua_script = """
        local key = KEYS[1]
        local now = tonumber(ARGV[1])
        local window_start = tonumber(ARGV[2])
        local limit = tonumber(ARGV[3])
        local window_seconds = tonumber(ARGV[4])
        
        -- Remove old entries
        redis.call('ZREMRANGEBYSCORE', key, 0, window_start)
        
        -- Count current entries
        local count = redis.call('ZCARD', key)
        
        local allowed = 0
        if count < limit then
            -- Add current request
            redis.call('ZADD', key, now, now .. '-' .. math.random())
            redis.call('EXPIRE', key, window_seconds)
            count = count + 1
            allowed = 1
        end
        
        return {allowed, count, limit - count}
        """
        
        result = await self.redis.eval(
            lua_script, 1, log_key,
            now, window_start, self.limit, self.window_seconds
        )
        
        return result[0] == 1, {
            "current_count": result[1],
            "remaining": max(0, result[2]),
            "limit": self.limit,
            "window_seconds": self.window_seconds
        }

# ============== ALGORITHM 3: SLIDING WINDOW COUNTER ==============

class SlidingWindowCounterLimiter(RateLimiter):
    """
    Sliding Window Counter Algorithm
    
    - Combines fixed window efficiency with sliding window accuracy
    - Uses weighted average of current and previous window
    
    Pros: Memory efficient, reasonably accurate
    Cons: Not 100% accurate (approximation)
    
    Use for: Best balance of efficiency and accuracy
    """
    
    def __init__(
        self,
        redis_client: redis.Redis,
        limit: int = 100,
        window_seconds: int = 60
    ):
        self.redis = redis_client
        self.limit = limit
        self.window_seconds = window_seconds
    
    async def is_allowed(self, key: str) -> Tuple[bool, dict]:
        now = time.time()
        current_window = int(now // self.window_seconds)
        previous_window = current_window - 1
        
        current_key = f"window:{key}:{current_window}"
        previous_key = f"window:{key}:{previous_window}"
        
        # Get counts from both windows
        pipe = self.redis.pipeline()
        pipe.get(current_key)
        pipe.get(previous_key)
        results = await pipe.execute()
        
        current_count = int(results[0] or 0)
        previous_count = int(results[1] or 0)
        
        # Calculate position in current window (0.0 to 1.0)
        window_position = (now % self.window_seconds) / self.window_seconds
        
        # Weighted count: full current + partial previous
        weighted_count = current_count + previous_count * (1 - window_position)
        
        if weighted_count >= self.limit:
            return False, {
                "current_count": current_count,
                "weighted_count": weighted_count,
                "limit": self.limit
            }
        
        # Increment current window counter
        pipe = self.redis.pipeline()
        pipe.incr(current_key)
        pipe.expire(current_key, self.window_seconds * 2)
        await pipe.execute()
        
        return True, {
            "current_count": current_count + 1,
            "weighted_count": weighted_count,
            "remaining": int(self.limit - weighted_count - 1),
            "limit": self.limit
        }

# ============== ALGORITHM 4: FIXED WINDOW (SIMPLEST) ==============

class FixedWindowLimiter(RateLimiter):
    """
    Fixed Window Algorithm
    
    - Count requests in fixed time windows
    - Simplest but has boundary issues
    
    Pros: Simple, memory efficient
    Cons: Burst at window boundaries
    
    Use for: Simple cases, when boundary burst is acceptable
    """
    
    def __init__(
        self,
        redis_client: redis.Redis,
        limit: int = 100,
        window_seconds: int = 60
    ):
        self.redis = redis_client
        self.limit = limit
        self.window_seconds = window_seconds
    
    async def is_allowed(self, key: str) -> Tuple[bool, dict]:
        now = time.time()
        window = int(now // self.window_seconds)
        window_key = f"fixed:{key}:{window}"
        
        # Increment and check
        current = await self.redis.incr(window_key)
        
        if current == 1:
            # First request in window, set expiry
            await self.redis.expire(window_key, self.window_seconds)
        
        allowed = current <= self.limit
        
        return allowed, {
            "current_count": current,
            "remaining": max(0, self.limit - current),
            "limit": self.limit,
            "reset_at": (window + 1) * self.window_seconds
        }

# ============== DISTRIBUTED RATE LIMITER SERVICE ==============

@dataclass
class RateLimitRule:
    """Configuration for a rate limit rule"""
    name: str
    limit: int
    window_seconds: int
    algorithm: str = "sliding_window_counter"

class DistributedRateLimiter:
    """
    Production-ready distributed rate limiter.
    """
    
    def __init__(self, redis_url: str = "redis://localhost:6379"):
        self.redis = redis.from_url(redis_url, decode_responses=True)
        self.rules: Dict[str, RateLimitRule] = {}
        self._limiters: Dict[str, RateLimiter] = {}
    
    def add_rule(self, rule: RateLimitRule):
        """Add a rate limiting rule"""
        self.rules[rule.name] = rule
        
        # Create appropriate limiter
        if rule.algorithm == "token_bucket":
            self._limiters[rule.name] = TokenBucketLimiter(
                self.redis, rule.limit, rule.limit / rule.window_seconds
            )
        elif rule.algorithm == "sliding_window_log":
            self._limiters[rule.name] = SlidingWindowLogLimiter(
                self.redis, rule.limit, rule.window_seconds
            )
        elif rule.algorithm == "sliding_window_counter":
            self._limiters[rule.name] = SlidingWindowCounterLimiter(
                self.redis, rule.limit, rule.window_seconds
            )
        else:
            self._limiters[rule.name] = FixedWindowLimiter(
                self.redis, rule.limit, rule.window_seconds
            )
    
    async def check(
        self, 
        identifier: str, 
        rule_name: str
    ) -> Tuple[bool, dict]:
        """Check if request should be allowed"""
        if rule_name not in self._limiters:
            raise ValueError(f"Unknown rule: {rule_name}")
        
        key = f"{rule_name}:{identifier}"
        return await self._limiters[rule_name].is_allowed(key)
    
    async def check_all(
        self, 
        identifier: str, 
        rule_names: list
    ) -> Tuple[bool, dict]:
        """Check multiple rules, all must pass"""
        results = {}
        
        for rule_name in rule_names:
            allowed, metadata = await self.check(identifier, rule_name)
            results[rule_name] = {"allowed": allowed, **metadata}
            
            if not allowed:
                return False, results
        
        return True, results

# ============== FASTAPI MIDDLEWARE ==============

from fastapi import FastAPI, Request, HTTPException
from starlette.middleware.base import BaseHTTPMiddleware

app = FastAPI()
rate_limiter = DistributedRateLimiter()

# Configure rules
rate_limiter.add_rule(RateLimitRule(
    name="api_per_minute",
    limit=100,
    window_seconds=60,
    algorithm="sliding_window_counter"
))

rate_limiter.add_rule(RateLimitRule(
    name="api_per_hour",
    limit=1000,
    window_seconds=3600,
    algorithm="fixed_window"
))

class RateLimitMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        # Get identifier (user ID, IP, API key)
        identifier = request.headers.get("X-API-Key") or request.client.host
        
        # Check rate limits
        allowed, metadata = await rate_limiter.check_all(
            identifier,
            ["api_per_minute", "api_per_hour"]
        )
        
        if not allowed:
            raise HTTPException(
                status_code=429,
                detail={
                    "error": "Rate limit exceeded",
                    "limits": metadata
                },
                headers={
                    "X-RateLimit-Remaining": "0",
                    "Retry-After": "60"
                }
            )
        
        response = await call_next(request)
        
        # Add rate limit headers
        minute_info = metadata.get("api_per_minute", {})
        response.headers["X-RateLimit-Limit"] = str(minute_info.get("limit", 100))
        response.headers["X-RateLimit-Remaining"] = str(minute_info.get("remaining", 0))
        
        return response

app.add_middleware(RateLimitMiddleware)
```

---

## 21.2 Design a URL Shortener

### Requirements & Estimation

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              URL SHORTENER REQUIREMENTS                      â”‚
â”‚                                                              â”‚
â”‚  Functional:                                                â”‚
â”‚  â”œâ”€â”€ Shorten long URLs to short URLs                        â”‚
â”‚  â”œâ”€â”€ Redirect short URL to original URL                     â”‚
â”‚  â”œâ”€â”€ Custom short URLs (optional)                           â”‚
â”‚  â”œâ”€â”€ Analytics (click counts, referrers)                    â”‚
â”‚  â””â”€â”€ URL expiration (optional)                              â”‚
â”‚                                                              â”‚
â”‚  Non-Functional:                                            â”‚
â”‚  â”œâ”€â”€ Very low latency redirects (< 50ms)                    â”‚
â”‚  â”œâ”€â”€ High availability (99.99%)                             â”‚
â”‚  â”œâ”€â”€ URLs should not be guessable                           â”‚
â”‚  â””â”€â”€ No URL collisions                                      â”‚
â”‚                                                              â”‚
â”‚                                                              â”‚
â”‚  ESTIMATION:                                                â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                â”‚
â”‚  - 100M URLs created per month                              â”‚
â”‚  - 10B redirects per month                                  â”‚
â”‚  - Read:Write ratio = 100:1 (very read-heavy)              â”‚
â”‚                                                              â”‚
â”‚  Traffic:                                                   â”‚
â”‚  - Writes: 100M / (30*24*3600) â‰ˆ 40 URLs/sec               â”‚
â”‚  - Reads: 10B / (30*24*3600) â‰ˆ 4000 redirects/sec          â”‚
â”‚                                                              â”‚
â”‚  Storage (5 years):                                         â”‚
â”‚  - URLs per year: 100M * 12 = 1.2B                         â”‚
â”‚  - 5 years: 6B URLs                                         â”‚
â”‚  - Per URL: ~500 bytes (short + long + metadata)           â”‚
â”‚  - Total: 6B * 500 = 3TB                                   â”‚
â”‚                                                              â”‚
â”‚  Short URL Length:                                          â”‚
â”‚  - Characters: a-z, A-Z, 0-9 = 62 characters               â”‚
â”‚  - 7 characters: 62^7 = 3.5 trillion combinations          â”‚
â”‚  - More than enough for 6B URLs!                           â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Complete Implementation

```python
# url_shortener.py
import hashlib
import time
import secrets
from dataclasses import dataclass, field
from typing import Optional, Dict
from datetime import datetime, timedelta
import asyncio

# ============== DATA MODELS ==============

@dataclass
class ShortenedURL:
    short_code: str
    original_url: str
    created_at: datetime
    expires_at: Optional[datetime] = None
    user_id: Optional[str] = None
    click_count: int = 0
    
    def is_expired(self) -> bool:
        if self.expires_at is None:
            return False
        return datetime.utcnow() > self.expires_at

# ============== SHORT CODE GENERATION ==============

class ShortCodeGenerator:
    """
    Generate unique short codes for URLs.
    Multiple strategies available.
    """
    
    ALPHABET = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    CODE_LENGTH = 7
    
    @classmethod
    def base62_encode(cls, num: int) -> str:
        """Convert number to base62 string"""
        if num == 0:
            return cls.ALPHABET[0]
        
        result = []
        while num:
            result.append(cls.ALPHABET[num % 62])
            num //= 62
        
        return ''.join(reversed(result))
    
    @classmethod
    def base62_decode(cls, code: str) -> int:
        """Convert base62 string to number"""
        num = 0
        for char in code:
            num = num * 62 + cls.ALPHABET.index(char)
        return num
    
    @classmethod
    def generate_random(cls, length: int = 7) -> str:
        """Generate random short code"""
        return ''.join(secrets.choice(cls.ALPHABET) for _ in range(length))
    
    @classmethod
    def generate_from_hash(cls, url: str, length: int = 7) -> str:
        """Generate short code from URL hash"""
        hash_bytes = hashlib.md5(url.encode()).digest()
        hash_int = int.from_bytes(hash_bytes[:8], 'big')
        code = cls.base62_encode(hash_int)
        return code[:length]

# ============== COUNTER-BASED ID GENERATOR ==============

class DistributedCounter:
    """
    Distributed counter using ranges to avoid coordination.
    Each server gets a range of IDs to use.
    """
    
    def __init__(
        self, 
        server_id: int,
        range_size: int = 1_000_000
    ):
        self.server_id = server_id
        self.range_size = range_size
        self.current_range_start = server_id * range_size
        self.current_id = self.current_range_start
        self.range_end = self.current_range_start + range_size
    
    def next_id(self) -> int:
        """Get next unique ID"""
        if self.current_id >= self.range_end:
            # Need new range - in production, would coordinate with DB
            self.current_range_start += self.range_size * 100  # Skip to avoid collision
            self.current_id = self.current_range_start
            self.range_end = self.current_range_start + self.range_size
        
        result = self.current_id
        self.current_id += 1
        return result
    
    def id_to_code(self, id: int) -> str:
        """Convert numeric ID to short code"""
        return ShortCodeGenerator.base62_encode(id).zfill(7)

# ============== URL SHORTENER SERVICE ==============

class URLShortenerService:
    """
    Complete URL shortening service.
    """
    
    def __init__(self, server_id: int = 0):
        self.counter = DistributedCounter(server_id)
        # In production: use Redis/Database
        self.url_store: Dict[str, ShortenedURL] = {}
        self.reverse_index: Dict[str, str] = {}  # original_url -> short_code
        self.base_url = "https://short.url"
    
    async def create_short_url(
        self,
        original_url: str,
        custom_code: Optional[str] = None,
        user_id: Optional[str] = None,
        expires_in_days: Optional[int] = None
    ) -> ShortenedURL:
        """Create a shortened URL"""
        
        # Validate URL
        if not original_url.startswith(('http://', 'https://')):
            raise ValueError("Invalid URL format")
        
        # Check if URL already shortened (for deduplication)
        if original_url in self.reverse_index:
            return self.url_store[self.reverse_index[original_url]]
        
        # Generate or validate short code
        if custom_code:
            if custom_code in self.url_store:
                raise ValueError("Custom code already in use")
            short_code = custom_code
        else:
            # Use counter-based generation (guaranteed unique)
            unique_id = self.counter.next_id()
            short_code = self.counter.id_to_code(unique_id)
        
        # Calculate expiration
        expires_at = None
        if expires_in_days:
            expires_at = datetime.utcnow() + timedelta(days=expires_in_days)
        
        # Create record
        shortened = ShortenedURL(
            short_code=short_code,
            original_url=original_url,
            created_at=datetime.utcnow(),
            expires_at=expires_at,
            user_id=user_id
        )
        
        # Store
        self.url_store[short_code] = shortened
        self.reverse_index[original_url] = short_code
        
        return shortened
    
    async def get_original_url(
        self, 
        short_code: str,
        track_click: bool = True
    ) -> Optional[str]:
        """Get original URL from short code"""
        
        shortened = self.url_store.get(short_code)
        
        if shortened is None:
            return None
        
        if shortened.is_expired():
            return None
        
        if track_click:
            shortened.click_count += 1
            # In production: async analytics event
        
        return shortened.original_url
    
    async def get_stats(self, short_code: str) -> Optional[dict]:
        """Get statistics for a shortened URL"""
        shortened = self.url_store.get(short_code)
        
        if shortened is None:
            return None
        
        return {
            "short_code": shortened.short_code,
            "original_url": shortened.original_url,
            "created_at": shortened.created_at.isoformat(),
            "click_count": shortened.click_count,
            "expires_at": shortened.expires_at.isoformat() if shortened.expires_at else None
        }

# ============== FASTAPI APPLICATION ==============

from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import RedirectResponse
from pydantic import BaseModel, HttpUrl

app = FastAPI(title="URL Shortener")
service = URLShortenerService(server_id=1)

class CreateURLRequest(BaseModel):
    url: HttpUrl
    custom_code: Optional[str] = None
    expires_in_days: Optional[int] = None

class CreateURLResponse(BaseModel):
    short_url: str
    short_code: str
    original_url: str

@app.post("/api/v1/shorten", response_model=CreateURLResponse)
async def create_short_url(request: CreateURLRequest):
    """Create a shortened URL"""
    try:
        shortened = await service.create_short_url(
            original_url=str(request.url),
            custom_code=request.custom_code,
            expires_in_days=request.expires_in_days
        )
        
        return CreateURLResponse(
            short_url=f"{service.base_url}/{shortened.short_code}",
            short_code=shortened.short_code,
            original_url=shortened.original_url
        )
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/{short_code}")
async def redirect_to_url(short_code: str):
    """Redirect to original URL"""
    original_url = await service.get_original_url(short_code)
    
    if original_url is None:
        raise HTTPException(status_code=404, detail="URL not found or expired")
    
    return RedirectResponse(url=original_url, status_code=301)

@app.get("/api/v1/stats/{short_code}")
async def get_url_stats(short_code: str):
    """Get statistics for a shortened URL"""
    stats = await service.get_stats(short_code)
    
    if stats is None:
        raise HTTPException(status_code=404, detail="URL not found")
    
    return stats
```

---

## 21.3 Design a Notification System

### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           NOTIFICATION SYSTEM ARCHITECTURE                   â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                            â”‚
â”‚  â”‚   Client    â”‚                                            â”‚
â”‚  â”‚  Services   â”‚ (Order Svc, User Svc, etc.)                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                            â”‚
â”‚         â”‚                                                    â”‚
â”‚         â–¼                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚         Notification Service API                 â”‚        â”‚
â”‚  â”‚                                                  â”‚        â”‚
â”‚  â”‚  - Validate request                             â”‚        â”‚
â”‚  â”‚  - Check user preferences                       â”‚        â”‚
â”‚  â”‚  - Rate limit                                   â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                     â”‚                                        â”‚
â”‚                     â–¼                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚              Message Queue (Kafka)               â”‚        â”‚
â”‚  â”‚                                                  â”‚        â”‚
â”‚  â”‚  Topics: email, sms, push, in-app              â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜        â”‚
â”‚       â”‚            â”‚            â”‚            â”‚               â”‚
â”‚       â–¼            â–¼            â–¼            â–¼               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  Email  â”‚ â”‚   SMS   â”‚ â”‚  Push   â”‚ â”‚ In-App  â”‚          â”‚
â”‚  â”‚ Worker  â”‚ â”‚ Worker  â”‚ â”‚ Worker  â”‚ â”‚ Worker  â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜          â”‚
â”‚       â”‚            â”‚            â”‚            â”‚               â”‚
â”‚       â–¼            â–¼            â–¼            â–¼               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚SendGrid â”‚ â”‚ Twilio  â”‚ â”‚  FCM/   â”‚ â”‚WebSocketâ”‚          â”‚
â”‚  â”‚         â”‚ â”‚         â”‚ â”‚  APNS   â”‚ â”‚ Server  â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚              Supporting Services                 â”‚        â”‚
â”‚  â”‚                                                  â”‚        â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚        â”‚
â”‚  â”‚  â”‚ Template â”‚ â”‚ User     â”‚ â”‚ Delivery     â”‚    â”‚        â”‚
â”‚  â”‚  â”‚ Service  â”‚ â”‚ Prefs DB â”‚ â”‚ Tracking DB  â”‚    â”‚        â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Implementation

```python
# notification_system.py
import asyncio
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from enum import Enum
from datetime import datetime
import uuid
import json

# ============== MODELS ==============

class NotificationChannel(str, Enum):
    EMAIL = "email"
    SMS = "sms"
    PUSH = "push"
    IN_APP = "in_app"

class NotificationPriority(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class DeliveryStatus(str, Enum):
    PENDING = "pending"
    SENT = "sent"
    DELIVERED = "delivered"
    FAILED = "failed"
    BOUNCED = "bounced"

@dataclass
class NotificationRequest:
    user_id: str
    template_id: str
    channels: List[NotificationChannel]
    data: Dict[str, Any]  # Template variables
    priority: NotificationPriority = NotificationPriority.MEDIUM
    scheduled_at: Optional[datetime] = None
    idempotency_key: Optional[str] = None

@dataclass
class Notification:
    id: str
    user_id: str
    channel: NotificationChannel
    template_id: str
    content: Dict[str, str]  # subject, body, etc.
    status: DeliveryStatus
    created_at: datetime
    sent_at: Optional[datetime] = None
    delivered_at: Optional[datetime] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class UserPreferences:
    user_id: str
    email_enabled: bool = True
    sms_enabled: bool = True
    push_enabled: bool = True
    quiet_hours_start: Optional[int] = None  # Hour (0-23)
    quiet_hours_end: Optional[int] = None
    unsubscribed_categories: List[str] = field(default_factory=list)

# ============== TEMPLATE SERVICE ==============

class TemplateService:
    """Manages notification templates"""
    
    def __init__(self):
        self.templates = {
            "order_confirmation": {
                "email": {
                    "subject": "Order #{order_id} Confirmed!",
                    "body": "Hi {user_name}, your order for {item_name} has been confirmed."
                },
                "sms": {
                    "body": "Order #{order_id} confirmed. Track at {tracking_url}"
                },
                "push": {
                    "title": "Order Confirmed",
                    "body": "Your order #{order_id} is on its way!"
                }
            },
            "password_reset": {
                "email": {
                    "subject": "Reset Your Password",
                    "body": "Click here to reset: {reset_link}"
                },
                "sms": {
                    "body": "Your password reset code: {code}"
                }
            }
        }
    
    def render(
        self, 
        template_id: str, 
        channel: NotificationChannel,
        data: Dict[str, Any]
    ) -> Dict[str, str]:
        """Render template with data"""
        template = self.templates.get(template_id, {}).get(channel.value, {})
        
        rendered = {}
        for key, value in template.items():
            rendered[key] = value.format(**data)
        
        return rendered

# ============== PREFERENCE SERVICE ==============

class PreferenceService:
    """Manages user notification preferences"""
    
    def __init__(self):
        # In production: database
        self.preferences: Dict[str, UserPreferences] = {}
    
    def get_preferences(self, user_id: str) -> UserPreferences:
        if user_id not in self.preferences:
            self.preferences[user_id] = UserPreferences(user_id=user_id)
        return self.preferences[user_id]
    
    def is_channel_enabled(
        self, 
        user_id: str, 
        channel: NotificationChannel
    ) -> bool:
        prefs = self.get_preferences(user_id)
        
        channel_map = {
            NotificationChannel.EMAIL: prefs.email_enabled,
            NotificationChannel.SMS: prefs.sms_enabled,
            NotificationChannel.PUSH: prefs.push_enabled,
            NotificationChannel.IN_APP: True  # Always enabled
        }
        
        return channel_map.get(channel, True)
    
    def is_quiet_hours(self, user_id: str) -> bool:
        prefs = self.get_preferences(user_id)
        
        if prefs.quiet_hours_start is None or prefs.quiet_hours_end is None:
            return False
        
        current_hour = datetime.utcnow().hour
        
        if prefs.quiet_hours_start <= prefs.quiet_hours_end:
            return prefs.quiet_hours_start <= current_hour < prefs.quiet_hours_end
        else:
            # Overnight quiet hours (e.g., 22:00 to 08:00)
            return current_hour >= prefs.quiet_hours_start or current_hour < prefs.quiet_hours_end

# ============== CHANNEL PROVIDERS ==============

class EmailProvider:
    """Email delivery via SendGrid/SES"""
    
    async def send(
        self, 
        to_email: str, 
        subject: str, 
        body: str,
        **kwargs
    ) -> bool:
        # In production: call SendGrid API
        print(f"ğŸ“§ Sending email to {to_email}: {subject}")
        await asyncio.sleep(0.1)  # Simulate API call
        return True

class SMSProvider:
    """SMS delivery via Twilio"""
    
    async def send(
        self, 
        to_phone: str, 
        body: str,
        **kwargs
    ) -> bool:
        print(f"ğŸ“± Sending SMS to {to_phone}: {body[:50]}...")
        await asyncio.sleep(0.1)
        return True

class PushProvider:
    """Push notifications via FCM/APNS"""
    
    async def send(
        self, 
        device_token: str, 
        title: str, 
        body: str,
        **kwargs
    ) -> bool:
        print(f"ğŸ”” Sending push to {device_token[:20]}...: {title}")
        await asyncio.sleep(0.1)
        return True

# ============== NOTIFICATION SERVICE ==============

class NotificationService:
    """Main notification orchestration service"""
    
    def __init__(self):
        self.template_service = TemplateService()
        self.preference_service = PreferenceService()
        self.email_provider = EmailProvider()
        self.sms_provider = SMSProvider()
        self.push_provider = PushProvider()
        
        # In production: use database
        self.notifications: Dict[str, Notification] = {}
        self.idempotency_cache: Dict[str, str] = {}  # key -> notification_id
        
        # Rate limiting
        self.rate_limits: Dict[str, List[datetime]] = {}
        self.rate_limit_per_hour = 100
    
    async def send(self, request: NotificationRequest) -> List[Notification]:
        """Send notification through requested channels"""
        
        # Idempotency check
        if request.idempotency_key:
            if request.idempotency_key in self.idempotency_cache:
                existing_id = self.idempotency_cache[request.idempotency_key]
                return [self.notifications[existing_id]]
        
        # Rate limiting
        if not self._check_rate_limit(request.user_id):
            raise Exception("Rate limit exceeded")
        
        results = []
        
        for channel in request.channels:
            # Check user preferences
            if not self.preference_service.is_channel_enabled(
                request.user_id, channel
            ):
                continue
            
            # Check quiet hours (skip for critical)
            if (request.priority != NotificationPriority.CRITICAL and 
                self.preference_service.is_quiet_hours(request.user_id)):
                # Queue for later
                continue
            
            # Render template
            content = self.template_service.render(
                request.template_id,
                channel,
                request.data
            )
            
            # Create notification record
            notification = Notification(
                id=str(uuid.uuid4()),
                user_id=request.user_id,
                channel=channel,
                template_id=request.template_id,
                content=content,
                status=DeliveryStatus.PENDING,
                created_at=datetime.utcnow()
            )
            
            # Send via appropriate provider
            success = await self._deliver(notification, request.data)
            
            notification.status = DeliveryStatus.SENT if success else DeliveryStatus.FAILED
            notification.sent_at = datetime.utcnow() if success else None
            
            self.notifications[notification.id] = notification
            results.append(notification)
        
        # Cache for idempotency
        if request.idempotency_key and results:
            self.idempotency_cache[request.idempotency_key] = results[0].id
        
        return results
    
    async def _deliver(
        self, 
        notification: Notification,
        user_data: Dict[str, Any]
    ) -> bool:
        """Deliver notification via appropriate channel"""
        
        try:
            if notification.channel == NotificationChannel.EMAIL:
                return await self.email_provider.send(
                    to_email=user_data.get('email', 'user@example.com'),
                    subject=notification.content.get('subject', ''),
                    body=notification.content.get('body', '')
                )
            
            elif notification.channel == NotificationChannel.SMS:
                return await self.sms_provider.send(
                    to_phone=user_data.get('phone', '+1234567890'),
                    body=notification.content.get('body', '')
                )
            
            elif notification.channel == NotificationChannel.PUSH:
                return await self.push_provider.send(
                    device_token=user_data.get('device_token', 'token'),
                    title=notification.content.get('title', ''),
                    body=notification.content.get('body', '')
                )
            
            return False
            
        except Exception as e:
            print(f"Delivery failed: {e}")
            return False
    
    def _check_rate_limit(self, user_id: str) -> bool:
        """Check if user is within rate limits"""
        now = datetime.utcnow()
        hour_ago = now.replace(minute=0, second=0, microsecond=0)
        
        if user_id not in self.rate_limits:
            self.rate_limits[user_id] = []
        
        # Remove old entries
        self.rate_limits[user_id] = [
            t for t in self.rate_limits[user_id]
            if t > hour_ago
        ]
        
        if len(self.rate_limits[user_id]) >= self.rate_limit_per_hour:
            return False
        
        self.rate_limits[user_id].append(now)
        return True

# ============== USAGE EXAMPLE ==============

async def demo_notification_system():
    service = NotificationService()
    
    # Send order confirmation
    request = NotificationRequest(
        user_id="user_123",
        template_id="order_confirmation",
        channels=[
            NotificationChannel.EMAIL,
            NotificationChannel.SMS,
            NotificationChannel.PUSH
        ],
        data={
            "order_id": "ORD-456",
            "user_name": "Alice",
            "item_name": "Laptop",
            "tracking_url": "https://track.example.com/ORD-456",
            "email": "alice@example.com",
            "phone": "+1234567890",
            "device_token": "fcm_token_abc"
        },
        priority=NotificationPriority.HIGH,
        idempotency_key="order_456_confirmation"
    )
    
    notifications = await service.send(request)
    
    print(f"\nSent {len(notifications)} notifications:")
    for n in notifications:
        print(f"  - {n.channel.value}: {n.status.value}")

# asyncio.run(demo_notification_system())
```

---

## Summary: Case Study Patterns

| System | Key Challenges | Core Solutions |
|--------|---------------|----------------|
| **Rate Limiter** | Distributed counting, accuracy | Redis + Lua scripts, sliding window |
| **URL Shortener** | Unique IDs, fast redirects | Counter-based IDs, heavy caching |
| **Notification** | Multi-channel, preferences | Message queue, worker pools |

---

## Practice Exercises

1. Implement all 4 rate limiting algorithms
2. Design a URL shortener with analytics
3. Build a notification system with retry logic
4. Add A/B testing to the notification system
5. Design a real-time leaderboard

**Next Chapter**: Interview tips and strategies!
