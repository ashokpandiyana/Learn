# Chapter 7: Problem-Solving Strategies - In-Depth Explanation

## 7.1 Recognizing Queue Problems

### Pattern Recognition Framework

**Visual Decision Tree:**
```
Problem Statement
       ‚Üì
Does it involve ORDER?
       ‚Üì
   Yes ‚Üí Continue
       ‚Üì
First-In-First-Out?
       ‚Üì
   Yes ‚Üí Likely QUEUE
       ‚Üì
Check these patterns:
‚îú‚îÄ Level-by-level? ‚Üí BFS/Queue
‚îú‚îÄ Sliding window? ‚Üí Deque/Monotonic Queue
‚îú‚îÄ Task scheduling? ‚Üí Priority Queue
‚îú‚îÄ Stream processing? ‚Üí Queue
‚îî‚îÄ Shortest path? ‚Üí BFS Queue
```

### Keyword Identification System

```python
class QueuePatternRecognizer:
    """
    System to recognize when to use queue based on problem keywords.
    """
    
    def __init__(self):
        self.patterns = {
            'bfs_queue': {
                'keywords': ['level by level', 'layer by layer', 'shortest path',
                           'minimum steps', 'breadth first', 'level order',
                           'explore neighbors', 'nearest', 'closest'],
                'indicators': ['tree traversal', 'graph traversal', 'unweighted graph']
            },
            'sliding_window_queue': {
                'keywords': ['sliding window', 'window of size k', 'subarray of size',
                           'maximum in window', 'minimum in window', 'every k elements'],
                'indicators': ['find maximum', 'find minimum', 'in each window']
            },
            'monotonic_queue': {
                'keywords': ['next greater', 'next smaller', 'maximum in range',
                           'minimum in range', 'sliding window maximum'],
                'indicators': ['maintain order', 'increasing', 'decreasing']
            },
            'priority_queue': {
                'keywords': ['kth largest', 'kth smallest', 'top k', 'priority',
                           'merge k', 'median', 'closest'],
                'indicators': ['sorted', 'order by priority', 'most important']
            },
            'design_queue': {
                'keywords': ['design', 'implement', 'cache', 'buffer', 'stream',
                           'moving average', 'hit counter', 'recent'],
                'indicators': ['first in first out', 'fifo', 'sequential']
            }
        }
    
    def analyze_problem(self, problem_text):
        """Analyze problem text and suggest queue pattern"""
        problem_lower = problem_text.lower()
        suggestions = []
        
        print("=" * 70)
        print("QUEUE PATTERN RECOGNITION ANALYSIS")
        print("=" * 70)
        print(f"\nProblem: {problem_text}\n")
        
        for pattern_name, pattern_info in self.patterns.items():
            score = 0
            matched_keywords = []
            
            # Check keywords
            for keyword in pattern_info['keywords']:
                if keyword in problem_lower:
                    score += 2
                    matched_keywords.append(keyword)
            
            # Check indicators
            for indicator in pattern_info['indicators']:
                if indicator in problem_lower:
                    score += 1
                    matched_keywords.append(indicator)
            
            if score > 0:
                suggestions.append({
                    'pattern': pattern_name,
                    'score': score,
                    'matches': matched_keywords
                })
        
        # Sort by score
        suggestions.sort(key=lambda x: x['score'], reverse=True)
        
        # Display results
        if suggestions:
            print("üéØ DETECTED PATTERNS (Ranked by confidence):\n")
            for i, suggestion in enumerate(suggestions, 1):
                pattern = suggestion['pattern'].replace('_', ' ').title()
                print(f"{i}. {pattern}")
                print(f"   Confidence Score: {suggestion['score']}")
                print(f"   Matched: {', '.join(suggestion['matches'])}")
                print()
        else:
            print("‚ö†Ô∏è No strong queue pattern detected.")
            print("Consider: Array, Hash Map, or other data structures.\n")
        
        return suggestions


# ============ DEMONSTRATION ============

recognizer = QueuePatternRecognizer()

# Test various problem statements
problems = [
    "Find the shortest path from source to destination in an unweighted graph",
    
    "Given an array, find the maximum element in every sliding window of size k",
    
    "Design a data structure that supports getting the moving average from a data stream",
    
    "Find the kth largest element in an unsorted array",
    
    "Perform level order traversal of a binary tree",
    
    "Find the next greater element for each element in the array"
]

for problem in problems:
    recognizer.analyze_problem(problem)
    print("=" * 70)
    print()
```

---

### Detailed Pattern Recognition Examples

```python
print("\n" + "=" * 70)
print("DETAILED PATTERN RECOGNITION EXAMPLES")
print("=" * 70)

examples = [
    {
        'problem': "Given a binary tree, return the level order traversal of its nodes' values",
        'analysis': """
        Keywords detected: 'level order', 'binary tree'
        
        Pattern: BFS with Queue
        
        Reasoning:
        - 'level order' ‚Üí process level by level
        - 'binary tree' ‚Üí tree structure
        - Need FIFO to maintain level ordering
        
        Solution approach:
        1. Use queue initialized with root
        2. Track level size with len(queue)
        3. Process each level completely before next
        
        Time: O(n), Space: O(w) where w = max width
        """,
        'code_template': """
from collections import deque

def levelOrder(root):
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        current_level = []
        
        for i in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(current_level)
    
    return result
        """
    },
    {
        'problem': "You are given an array nums and an integer k. Find the maximum for each sliding window of size k",
        'analysis': """
        Keywords detected: 'sliding window', 'maximum', 'size k'
        
        Pattern: Monotonic Deque
        
        Reasoning:
        - 'sliding window' ‚Üí moving window of fixed size
        - 'maximum' ‚Üí need to track max efficiently
        - Brute force: O(n*k) - too slow
        - Monotonic deque: O(n) - optimal!
        
        Key insight:
        If arr[i] >= arr[j] and i > j, arr[j] can never be max!
        
        Solution approach:
        1. Maintain decreasing deque (indices)
        2. Remove elements outside window
        3. Remove smaller elements from rear
        4. Front = current maximum
        
        Time: O(n), Space: O(k)
        """,
        'code_template': """
from collections import deque

def maxSlidingWindow(nums, k):
    result = []
    dq = deque()  # Store indices
    
    for i in range(len(nums)):
        # Remove outside window
        while dq and dq[0] <= i - k:
            dq.popleft()
        
        # Remove smaller elements
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        
        dq.append(i)
        
        # Add to result when window formed
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result
        """
    },
    {
        'problem': "Find the shortest path in a maze from start to end. You can move up, down, left, right",
        'analysis': """
        Keywords detected: 'shortest path', 'maze'
        
        Pattern: BFS on Grid
        
        Reasoning:
        - 'shortest path' ‚Üí BFS guarantees shortest
        - 'maze' ‚Üí 2D grid representation
        - Unweighted edges (each move = 1 step)
        - Need to explore all directions
        
        Key points:
        - Use queue for BFS
        - Track visited cells
        - Store (row, col, distance)
        - Check 4 directions
        
        Solution approach:
        1. Start BFS from source
        2. For each cell, explore 4 neighbors
        3. Mark visited to avoid cycles
        4. First time reaching target = shortest
        
        Time: O(rows √ó cols), Space: O(rows √ó cols)
        """,
        'code_template': """
from collections import deque

def shortestPath(maze, start, end):
    rows, cols = len(maze), len(maze[0])
    directions = [(0,1), (1,0), (0,-1), (-1,0)]
    
    queue = deque([(start[0], start[1], 0)])
    visited = {(start[0], start[1])}
    
    while queue:
        r, c, dist = queue.popleft()
        
        if (r, c) == end:
            return dist
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            if (0 <= nr < rows and 0 <= nc < cols and
                maze[nr][nc] == 0 and
                (nr, nc) not in visited):
                
                visited.add((nr, nc))
                queue.append((nr, nc, dist + 1))
    
    return -1  # No path found
        """
    }
]

for i, example in enumerate(examples, 1):
    print(f"\n{'='*70}")
    print(f"EXAMPLE {i}")
    print('='*70)
    print(f"\nüìù Problem:")
    print(f"   {example['problem']}")
    print(f"\nüîç Analysis:")
    print(example['analysis'])
    print(f"\nüíª Code Template:")
    print(example['code_template'])
    print()
```

---

## 7.2 Choosing the Right Queue Type

### Decision Framework

```python
class QueueTypeSelector:
    """
    Helper class to choose the right queue type for a problem.
    """
    
    @staticmethod
    def select_queue_type(requirements):
        """
        Select appropriate queue type based on requirements.
        
        requirements: dict with keys like:
        - 'access': 'both_ends', 'front_only', 'rear_only'
        - 'ordering': 'fifo', 'priority', 'monotonic'
        - 'size': 'fixed', 'dynamic'
        - 'operation': 'bfs', 'sliding_window', 'scheduling'
        """
        
        print("\n" + "=" * 70)
        print("QUEUE TYPE SELECTION")
        print("=" * 70)
        
        print("\nRequirements:")
        for key, value in requirements.items():
            print(f"  {key}: {value}")
        
        print("\n" + "-" * 70)
        
        # Decision logic
        if requirements.get('ordering') == 'priority':
            print("\n‚úÖ RECOMMENDED: Priority Queue (Heap)")
            print("\nReasoning:")
            print("  ‚Ä¢ Need elements ordered by priority")
            print("  ‚Ä¢ Always access highest/lowest priority element")
            print("\nImplementation:")
            print("  import heapq")
            print("  pq = []  # min heap by default")
            print("  heapq.heappush(pq, item)")
            print("  heapq.heappop(pq)")
            print("\nComplexity:")
            print("  Insert: O(log n), Extract: O(log n)")
            
        elif requirements.get('operation') == 'sliding_window':
            if 'maximum' in str(requirements) or 'minimum' in str(requirements):
                print("\n‚úÖ RECOMMENDED: Monotonic Deque")
                print("\nReasoning:")
                print("  ‚Ä¢ Need max/min in sliding windows")
                print("  ‚Ä¢ Maintain monotonic order")
                print("  ‚Ä¢ Access both ends efficiently")
                print("\nImplementation:")
                print("  from collections import deque")
                print("  dq = deque()  # store indices")
                print("  # For max: maintain decreasing order")
                print("  # For min: maintain increasing order")
                print("\nComplexity:")
                print("  All operations: O(1) amortized")
            else:
                print("\n‚úÖ RECOMMENDED: Simple Queue/Deque")
                print("\nReasoning:")
                print("  ‚Ä¢ Standard sliding window operations")
                print("  ‚Ä¢ FIFO processing sufficient")
        
        elif requirements.get('access') == 'both_ends':
            print("\n‚úÖ RECOMMENDED: Deque (Double-Ended Queue)")
            print("\nReasoning:")
            print("  ‚Ä¢ Need to add/remove from both ends")
            print("  ‚Ä¢ Can act as both queue and stack")
            print("\nImplementation:")
            print("  from collections import deque")
            print("  dq = deque()")
            print("  dq.append(x)      # add to right")
            print("  dq.appendleft(x)  # add to left")
            print("  dq.pop()          # remove from right")
            print("  dq.popleft()      # remove from left")
            print("\nComplexity:")
            print("  All operations: O(1)")
        
        elif requirements.get('operation') == 'bfs':
            print("\n‚úÖ RECOMMENDED: Standard Queue (collections.deque)")
            print("\nReasoning:")
            print("  ‚Ä¢ BFS requires FIFO order")
            print("  ‚Ä¢ Need efficient enqueue/dequeue")
            print("\nImplementation:")
            print("  from collections import deque")
            print("  queue = deque([start_node])")
            print("  while queue:")
            print("      node = queue.popleft()")
            print("      # process and add neighbors")
            print("\nComplexity:")
            print("  Enqueue/Dequeue: O(1)")
        
        elif requirements.get('size') == 'fixed':
            print("\n‚úÖ RECOMMENDED: Circular Queue")
            print("\nReasoning:")
            print("  ‚Ä¢ Fixed size buffer")
            print("  ‚Ä¢ Efficient space usage")
            print("  ‚Ä¢ No reallocation needed")
            print("\nImplementation:")
            print("  class CircularQueue:")
            print("      def __init__(self, k):")
            print("          self.queue = [None] * k")
            print("          self.front = self.rear = -1")
            print("          self.size = 0")
            print("\nComplexity:")
            print("  All operations: O(1)")
        
        else:
            print("\n‚úÖ RECOMMENDED: Standard Queue (collections.deque)")
            print("\nReasoning:")
            print("  ‚Ä¢ General purpose FIFO operations")
            print("  ‚Ä¢ Most common queue operations")
            print("\nImplementation:")
            print("  from collections import deque")
            print("  q = deque()")
            print("  q.append(x)    # enqueue")
            print("  q.popleft()    # dequeue")
            print("\nComplexity:")
            print("  All operations: O(1)")
        
        print("\n" + "=" * 70)


# ============ DEMONSTRATION ============

selector = QueueTypeSelector()

# Test case 1: BFS problem
print("\n" + "üî∑" * 35)
print("SCENARIO 1: Level-order tree traversal")
selector.select_queue_type({
    'operation': 'bfs',
    'access': 'front_only',
    'ordering': 'fifo'
})

# Test case 2: Sliding window maximum
print("\n" + "üî∑" * 35)
print("SCENARIO 2: Find maximum in sliding windows")
selector.select_queue_type({
    'operation': 'sliding_window',
    'requirement': 'maximum',
    'access': 'both_ends'
})

# Test case 3: Task scheduling
print("\n" + "üî∑" * 35)
print("SCENARIO 3: Process tasks by priority")
selector.select_queue_type({
    'operation': 'scheduling',
    'ordering': 'priority'
})

# Test case 4: Recent calls counter
print("\n" + "üî∑" * 35)
print("SCENARIO 4: Count recent calls in time window")
selector.select_queue_type({
    'operation': 'tracking',
    'size': 'dynamic',
    'ordering': 'fifo'
})
```

---

## 7.3 Common Pitfalls and How to Avoid Them

### Pitfall Encyclopedia

```python
print("\n" + "=" * 70)
print("COMMON PITFALLS IN QUEUE PROBLEMS")
print("=" * 70)

pitfalls = [
    {
        'name': 'Forgetting Visited Set in Graph BFS',
        'severity': 'üî¥ CRITICAL',
        'consequence': 'Infinite loops, stack overflow, wrong answers',
        'wrong_code': """
# ‚ùå WRONG: No visited tracking
def bfs_wrong(graph, start):
    queue = deque([start])
    
    while queue:
        node = queue.popleft()
        print(node)
        
        for neighbor in graph[node]:
            queue.append(neighbor)  # Will revisit nodes!
        """,
        'correct_code': """
# ‚úÖ CORRECT: Track visited nodes
def bfs_correct(graph, start):
    visited = set([start])  # ‚≠ê KEY!
    queue = deque([start])
    
    while queue:
        node = queue.popleft()
        print(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:  # ‚≠ê Check!
                visited.add(neighbor)
                queue.append(neighbor)
        """,
        'tip': "ALWAYS use visited set for graphs. Trees don't need it (no cycles)."
    },
    {
        'name': 'Not Capturing Queue Size for Level Processing',
        'severity': 'üü† HIGH',
        'consequence': 'Cannot separate levels, wrong level counts',
        'wrong_code': """
# ‚ùå WRONG: Cannot distinguish levels
def level_order_wrong(root):
    queue = deque([root])
    result = []
    
    while queue:
        node = queue.popleft()  # No level separation!
        result.append(node.val)
        
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    
    return result  # All nodes in one list
        """,
        'correct_code': """
# ‚úÖ CORRECT: Capture size for level processing
def level_order_correct(root):
    queue = deque([root])
    result = []
    
    while queue:
        level_size = len(queue)  # ‚≠ê KEY!
        current_level = []
        
        for i in range(level_size):  # ‚≠ê Process exact level
            node = queue.popleft()
            current_level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(current_level)
    
    return result  # Separated by levels
        """,
        'tip': "Capture len(queue) BEFORE the loop to process each level separately."
    },
    {
        'name': 'Wrong Monotonic Queue Order',
        'severity': 'üü† HIGH',
        'consequence': 'Wrong maximum/minimum values',
        'wrong_code': """
# ‚ùå WRONG: Increasing deque for maximum
def sliding_max_wrong(arr, k):
    dq = deque()
    result = []
    
    for i in range(len(arr)):
        # Remove larger elements - WRONG!
        while dq and arr[dq[-1]] > arr[i]:
            dq.pop()
        
        dq.append(i)
        
        if i >= k - 1:
            result.append(arr[dq[0]])  # Wrong max!
    
    return result
        """,
        'correct_code': """
# ‚úÖ CORRECT: Decreasing deque for maximum
def sliding_max_correct(arr, k):
    dq = deque()
    result = []
    
    for i in range(len(arr)):
        # Remove SMALLER elements - CORRECT!
        while dq and arr[dq[-1]] < arr[i]:  # ‚≠ê KEY!
            dq.pop()
        
        dq.append(i)
        
        # Remove outside window
        while dq and dq[0] <= i - k:
            dq.popleft()
        
        if i >= k - 1:
            result.append(arr[dq[0]])  # Correct max!
    
    return result
        """,
        'tip': "For MAXIMUM: decreasing deque. For MINIMUM: increasing deque."
    },
    {
        'name': 'Incorrect Circular Queue Full/Empty Detection',
        'severity': 'üü° MEDIUM',
        'consequence': 'False overflow/underflow errors',
        'wrong_code': """
# ‚ùå WRONG: Cannot distinguish full from empty
class CircularQueueWrong:
    def __init__(self, k):
        self.queue = [None] * k
        self.front = self.rear = 0
    
    def is_empty(self):
        return self.front == self.rear  # AMBIGUOUS!
    
    def is_full(self):
        return (self.rear + 1) % len(self.queue) == self.front
        # But this is same as empty when queue is actually full!
        """,
        'correct_code': """
# ‚úÖ CORRECT: Use size counter
class CircularQueueCorrect:
    def __init__(self, k):
        self.queue = [None] * k
        self.front = self.rear = 0
        self.size = 0  # ‚≠ê KEY!
    
    def is_empty(self):
        return self.size == 0  # ‚≠ê Clear!
    
    def is_full(self):
        return self.size == len(self.queue)  # ‚≠ê Clear!
    
    def enqueue(self, val):
        if self.is_full():
            return False
        self.rear = (self.rear + 1) % len(self.queue)
        self.queue[self.rear] = val
        self.size += 1
        return True
        """,
        'tip': "Use a size counter OR sacrifice one slot. Size counter is clearer!"
    },
    {
        'name': 'Not Handling Empty Queue Before Dequeue',
        'severity': 'üü° MEDIUM',
        'consequence': 'Runtime errors, index out of bounds',
        'wrong_code': """
# ‚ùå WRONG: No empty check
def process_queue_wrong(queue):
    while True:
        item = queue.popleft()  # Error if queue empty!
        process(item)
        """,
        'correct_code': """
# ‚úÖ CORRECT: Always check before dequeue
def process_queue_correct(queue):
    while queue:  # ‚≠ê Check not empty
        item = queue.popleft()
        process(item)

# OR with explicit check
def dequeue_safe(queue):
    if not queue:  # ‚≠ê Explicit check
        raise Exception("Queue is empty!")
    return queue.popleft()
        """,
        'tip': "ALWAYS check if queue is empty before dequeue/peek operations."
    },
    {
        'name': 'Using Values Instead of Indices in Monotonic Queue',
        'severity': 'üü° MEDIUM',
        'consequence': 'Cannot track window boundaries correctly',
        'wrong_code': """
# ‚ùå WRONG: Storing values
def sliding_max_wrong(arr, k):
    dq = deque()
    
    for i in range(len(arr)):
        while dq and dq[-1] < arr[i]:
            dq.pop()
        
        dq.append(arr[i])  # Storing VALUE
        
        # How to remove elements outside window? ü§î
        # Cannot identify which element to remove!
        """,
        'correct_code': """
# ‚úÖ CORRECT: Storing indices
def sliding_max_correct(arr, k):
    dq = deque()
    
    for i in range(len(arr)):
        while dq and arr[dq[-1]] < arr[i]:
            dq.pop()
        
        dq.append(i)  # Storing INDEX ‚≠ê
        
        # Easy to check window boundary
        while dq and dq[0] <= i - k:  # ‚≠ê Can check position!
            dq.popleft()
        """,
        'tip': "Store INDICES in monotonic queue, not values. Easier window management!"
    }
]

for i, pitfall in enumerate(pitfalls, 1):
    print(f"\n{'='*70}")
    print(f"PITFALL #{i}: {pitfall['name']}")
    print(f"Severity: {pitfall['severity']}")
    print('='*70)
    
    print(f"\n‚ö†Ô∏è Consequence: {pitfall['consequence']}")
    
    print(f"\n‚ùå WRONG CODE:")
    print(pitfall['wrong_code'])
    
    print(f"\n‚úÖ CORRECT CODE:")
    print(pitfall['correct_code'])
    
    print(f"\nüí° TIP: {pitfall['tip']}")
    print()
```

---

## 7.4 Step-by-Step Problem Solving Methodology

### The QUEUE Framework

```python
print("\n" + "=" * 70)
print("THE QUEUE PROBLEM-SOLVING FRAMEWORK")
print("=" * 70)

framework = """
üéØ Q-U-E-U-E FRAMEWORK:

Q - Question Analysis
  ‚îî‚îÄ What exactly is being asked?
  ‚îî‚îÄ What are the inputs and outputs?
  ‚îî‚îÄ Any constraints or edge cases?

U - Understand the Pattern
  ‚îî‚îÄ Is it BFS, sliding window, design, or other?
  ‚îî‚îÄ What queue type is needed?
  ‚îî‚îÄ What's the key insight?

E - Example Walkthrough
  ‚îî‚îÄ Work through example step-by-step
  ‚îî‚îÄ Track queue state at each step
  ‚îî‚îÄ Verify the approach works

U - Understand Complexity
  ‚îî‚îÄ What's the time complexity?
  ‚îî‚îÄ What's the space complexity?
  ‚îî‚îÄ Can it be optimized?

E - Execute Implementation
  ‚îî‚îÄ Write clean, readable code
  ‚îî‚îÄ Handle edge cases
  ‚îî‚îÄ Test with examples
"""

print(framework)

# Detailed example
print("\n" + "=" * 70)
print("APPLYING THE FRAMEWORK: Rotting Oranges Problem")
print("=" * 70)

example_solution = """
PROBLEM: You are given an m x n grid where each cell can have one of three values:
- 0 representing an empty cell
- 1 representing a fresh orange
- 2 representing a rotten orange

Every minute, fresh oranges adjacent to rotten ones become rotten.
Return minimum minutes until no fresh oranges remain.

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Step 1: QUESTION ANALYSIS
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Q: What exactly is being asked?
A: Find minimum time for all oranges to rot, or -1 if impossible.

Q: What are inputs/outputs?
A: Input: 2D grid (list of lists)
   Output: Integer (minutes)

Q: Constraints?
A: - Grid can be any size
   - Fresh oranges isolated from rotten should return -1
   - No fresh oranges initially ‚Üí return 0

Q: Edge cases?
A: - Empty grid
   - No rotten oranges initially
   - No fresh oranges initially
   - All oranges fresh
   - Isolated fresh oranges

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Step 2: UNDERSTAND THE PATTERN
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Pattern Recognition:
‚úì "minimum time" ‚Üí BFS (shortest path)
‚úì "adjacent cells" ‚Üí grid traversal
‚úì "simultaneously" ‚Üí MULTI-SOURCE BFS! ‚≠ê

Key Insight:
- Start BFS from ALL rotten oranges at once!
- They spread rot simultaneously like a wave
- BFS guarantees minimum time

Queue Type Needed:
- Standard queue (collections.deque)
- Store: (row, col, time)

Data Structures:
- Queue for BFS
- Track fresh orange count
- No visited set needed (modify grid in-place)

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Step 3: EXAMPLE WALKTHROUGH
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Example: [[2,1,1],
          [1,1,0],
          [0,1,1]]

Initial State (time=0):
  2 1 1      Rotten: (0,0)
  1 1 0      Fresh: 6 oranges
  0 1 1      Queue: [(0,0,0)]

After time=1:
  2 2 1      (0,1) becomes rotten
  2 1 0      (1,0) becomes rotten
  0 1 1      Fresh: 4 oranges
             Queue: [(0,1,1), (1,0,1)]

After time=2:
  2 2 2      (0,2), (1,1) become rotten
  2 2 0      
  0 1 1      Fresh: 2 oranges
             Queue: [(0,2,2), (1,1,2)]

After time=3:
  2 2 2      
  2 2 0      
  0 2 1      Fresh: 1 orange
             Queue: [(2,1,3)]

After time=4:
  2 2 2      
  2 2 0      All fresh oranges rotten! ‚úì
  0 2 2      Fresh: 0
             Return: 4

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Step 4: UNDERSTAND COMPLEXITY
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Time Complexity: O(m √ó n)
- Visit each cell at most once
- Each cell processed in O(1)
- Total: O(rows √ó cols)

Space Complexity: O(m √ó n)
- Queue can contain all cells in worst case
- No additional data structures needed
- Modify grid in-place (optional)

Can it be optimized?
- Already optimal for this problem
- Cannot do better than visiting each cell

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Step 5: EXECUTE IMPLEMENTATION
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
"""

print(example_solution)

# Complete implementation
print("\nCOMPLETE IMPLEMENTATION:\n")

implementation = """
from collections import deque

def orangesRotting(grid):
    if not grid:
        return -1
    
    rows, cols = len(grid), len(grid[0])
    queue = deque()
    fresh_count = 0
    
    # Step 1: Initialize - find all rotten oranges and count fresh
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:
                queue.append((r, c, 0))  # (row, col, time)
            elif grid[r][c] == 1:
                fresh_count += 1
    
    # Edge case: no fresh oranges
    if fresh_count == 0:
        return 0
    
    # Step 2: Multi-source BFS
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    max_time = 0
    
    while queue:
        r, c, time = queue.popleft()
        max_time = max(max_time, time)
        
        # Spread rot to adjacent fresh oranges
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            # Check bounds and if fresh
            if (0 <= nr < rows and 0 <= nc < cols and
                grid[nr][nc] == 1):
                
                grid[nr][nc] = 2  # Make rotten
                fresh_count -= 1
                queue.append((nr, nc, time + 1))
    
    # Step 3: Check if all fresh oranges rotten
    return max_time if fresh_count == 0 else -1


# Test cases
test_cases = [
    [[2,1,1],[1,1,0],[0,1,1]],  # Expected: 4
    [[2,1,1],[0,1,1],[1,0,1]],  # Expected: -1 (isolated)
    [[0,2]],                     # Expected: 0 (no fresh)
]

for i, grid in enumerate(test_cases, 1):
    result = orangesRotting([row[:] for row in grid])  # Copy grid
    print(f"Test {i}: {result}")
"""

print(implementation)

print("\n" + "=" * 70)
print("FRAMEWORK APPLICATION COMPLETE!")
print("=" * 70)
```

---

## Summary

```python
print("\n" + "=" * 70)
print("CHAPTER 7 SUMMARY: PROBLEM-SOLVING STRATEGIES")
print("=" * 70)

summary = """
üéØ KEY TAKEAWAYS:

1. PATTERN RECOGNITION:
   ‚úì Look for keywords: "level by level", "shortest path", "sliding window"
   ‚úì Analyze problem structure: tree, graph, array, stream
   ‚úì Identify the queue pattern: BFS, monotonic, priority, design

2. CHOOSING QUEUE TYPE:
   ‚úì BFS ‚Üí Standard queue (deque)
   ‚úì Sliding window max/min ‚Üí Monotonic deque
   ‚úì Priority-based ‚Üí Priority queue (heap)
   ‚úì Both ends access ‚Üí Deque
   ‚úì Fixed size ‚Üí Circular queue

3. COMMON PITFALLS:
   ‚úì Always use visited set for graphs
   ‚úì Capture queue size for level processing
   ‚úì Use correct monotonic order (decreasing for max)
   ‚úì Store indices, not values in monotonic queue
   ‚úì Check empty before dequeue

4. PROBLEM-SOLVING FRAMEWORK (Q-U-E-U-E):
   ‚úì Question Analysis
   ‚úì Understand the Pattern
   ‚úì Example Walkthrough
   ‚úì Understand Complexity
   ‚úì Execute Implementation

5. BEST PRACTICES:
   ‚úì Start with brute force, then optimize
   ‚úì Draw diagrams for visualization
   ‚úì Test edge cases thoroughly
   ‚úì Explain your approach clearly
   ‚úì Write clean, commented code

üí° INTERVIEW TIPS:

‚Üí Always explain your thought process
‚Üí Clarify requirements before coding
‚Üí Discuss time/space complexity
‚Üí Handle edge cases explicitly
‚Üí Test with examples during implementation
"""

print(summary)

print("\n" + "=" * 70)
print("CHAPTER 7 COMPLETE!")
print("Next: Chapter 8 - Interview Problems by Difficulty")
print("=" * 70)
```

This comprehensive chapter covers problem-solving strategies with practical examples and frameworks you can apply in interviews!