# Chapter 4: BFS and Level-Order Traversal - In-Depth Explanation

## 4.1 Tree Level-Order Traversal

### Understanding Level-Order Traversal

**Concept:**
```
Binary Tree:
         1
       /   \
      2     3
     / \   / \
    4   5 6   7

Level-Order (BFS): [1], [2, 3], [4, 5, 6, 7]

Queue at each step:
Step 1: Queue = [1]          ‚Üí Process 1, add 2, 3
Step 2: Queue = [2, 3]       ‚Üí Process 2, add 4, 5
Step 3: Queue = [3, 4, 5]    ‚Üí Process 3, add 6, 7
Step 4: Queue = [4, 5, 6, 7] ‚Üí Process all
```

### Standard BFS Template for Trees

```python
from collections import deque

class TreeNode:
    """Binary Tree Node"""
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
    
    def __repr__(self):
        return f"Node({self.val})"


def level_order_traversal(root):
    """
    Basic level-order traversal.
    Returns list of all values in BFS order.
    
    Time: O(n), Space: O(w) where w is max width
    """
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    print("Level-Order Traversal Process:")
    print("=" * 60)
    
    while queue:
        node = queue.popleft()
        result.append(node.val)
        
        print(f"Processing: {node.val}")
        
        # Add children to queue
        if node.left:
            queue.append(node.left)
            print(f"  Added left child: {node.left.val}")
        if node.right:
            queue.append(node.right)
            print(f"  Added right child: {node.right.val}")
        
        print(f"  Queue now: {[n.val for n in queue]}")
    
    return result


# ============ CREATE SAMPLE TREE ============

def create_sample_tree():
    """
    Create tree:
             1
           /   \
          2     3
         / \   / \
        4   5 6   7
    """
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    root.right.left = TreeNode(6)
    root.right.right = TreeNode(7)
    return root


# ============ DEMONSTRATION ============

print("=" * 60)
print("BASIC LEVEL-ORDER TRAVERSAL")
print("=" * 60)

tree = create_sample_tree()
result = level_order_traversal(tree)

print("\n" + "=" * 60)
print(f"Result: {result}")
print("=" * 60)
```

---

### Level-by-Level Traversal (Most Important Pattern!)

```python
def level_order_by_level(root):
    """
    Level-order traversal returning values level by level.
    
    KEY TECHNIQUE: Track size of queue at each level!
    
    Time: O(n), Space: O(w)
    """
    if not root:
        return []
    
    result = []
    queue = deque([root])
    level = 0
    
    print("Level-by-Level Traversal:")
    print("=" * 60)
    
    while queue:
        level_size = len(queue)  # ‚≠ê KEY: Snapshot of current level size
        current_level = []
        
        print(f"\nLevel {level}: Processing {level_size} nodes")
        print(f"Queue at start: {[n.val for n in queue]}")
        
        # Process all nodes at current level
        for i in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)
            
            print(f"  [{i+1}/{level_size}] Processing: {node.val}")
            
            # Add children for next level
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(current_level)
        print(f"Level {level} complete: {current_level}")
        print(f"Queue for next level: {[n.val for n in queue]}")
        level += 1
    
    return result


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("LEVEL-BY-LEVEL TRAVERSAL (Most Common Pattern)")
print("=" * 60)

tree = create_sample_tree()
result = level_order_by_level(tree)

print("\n" + "=" * 60)
print("Final Result (by levels):")
for i, level in enumerate(result):
    print(f"  Level {i}: {level}")
print("=" * 60)
```

---

### Problem Variations

#### 1. Binary Tree Right Side View

```python
def right_side_view(root):
    """
    Return rightmost node at each level.
    
    Example:
         1         ‚Üê 1
       /   \
      2     3      ‚Üê 3
       \     \
        5     4    ‚Üê 4
    
    Output: [1, 3, 4]
    
    Technique: Last node in each level
    Time: O(n), Space: O(w)
    """
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    print("Right Side View Process:")
    print("=" * 60)
    
    level = 0
    while queue:
        level_size = len(queue)
        
        for i in range(level_size):
            node = queue.popleft()
            
            # Last node in this level ‚Üí visible from right
            if i == level_size - 1:
                result.append(node.val)
                print(f"Level {level}: Rightmost = {node.val} ‚úì")
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        level += 1
    
    return result


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("BINARY TREE RIGHT SIDE VIEW")
print("=" * 60)

# Create tree: 1 -> 2,3 -> 5 (left of 2), 4 (right of 3)
tree2 = TreeNode(1)
tree2.left = TreeNode(2)
tree2.right = TreeNode(3)
tree2.left.right = TreeNode(5)
tree2.right.right = TreeNode(4)

result = right_side_view(tree2)
print(f"\nRight Side View: {result}")
print("=" * 60)
```

#### 2. Binary Tree Zigzag Level Order

```python
def zigzag_level_order(root):
    """
    Level-order but alternate direction at each level.
    
    Example:
         1
       /   \
      2     3
     / \   / \
    4   5 6   7
    
    Output: [[1], [3, 2], [4, 5, 6, 7]]
    
    Technique: Reverse odd levels
    Time: O(n), Space: O(w)
    """
    if not root:
        return []
    
    result = []
    queue = deque([root])
    left_to_right = True
    
    print("Zigzag Level Order:")
    print("=" * 60)
    
    level = 0
    while queue:
        level_size = len(queue)
        current_level = deque()  # Use deque for efficient insertion
        
        for i in range(level_size):
            node = queue.popleft()
            
            # Add to current level based on direction
            if left_to_right:
                current_level.append(node.val)
            else:
                current_level.appendleft(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        direction = "Left‚ÜíRight" if left_to_right else "Right‚ÜíLeft"
        print(f"Level {level} ({direction}): {list(current_level)}")
        
        result.append(list(current_level))
        left_to_right = not left_to_right
        level += 1
    
    return result


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("ZIGZAG LEVEL ORDER TRAVERSAL")
print("=" * 60)

tree = create_sample_tree()
result = zigzag_level_order(tree)

print("\n" + "=" * 60)
print("Final Result:")
for i, level in enumerate(result):
    print(f"  Level {i}: {level}")
print("=" * 60)
```

#### 3. Average of Levels

```python
def average_of_levels(root):
    """
    Calculate average value at each level.
    
    Time: O(n), Space: O(w)
    """
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    print("Average of Levels:")
    print("=" * 60)
    
    level = 0
    while queue:
        level_size = len(queue)
        level_sum = 0
        
        for i in range(level_size):
            node = queue.popleft()
            level_sum += node.val
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        average = level_sum / level_size
        result.append(average)
        print(f"Level {level}: Sum={level_sum}, Count={level_size}, Avg={average:.2f}")
        level += 1
    
    return result


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("AVERAGE OF LEVELS IN BINARY TREE")
print("=" * 60)

tree = create_sample_tree()
result = average_of_levels(tree)

print(f"\nAverages: {[f'{x:.2f}' for x in result]}")
print("=" * 60)
```

#### 4. Minimum Depth of Binary Tree

```python
def min_depth(root):
    """
    Find minimum depth (shortest path from root to leaf).
    
    KEY INSIGHT: BFS finds shortest path!
    Stop as soon as we find first leaf.
    
    Time: O(n) worst case, but can be much faster
    Space: O(w)
    """
    if not root:
        return 0
    
    queue = deque([(root, 1)])  # (node, depth)
    
    print("Finding Minimum Depth:")
    print("=" * 60)
    
    while queue:
        node, depth = queue.popleft()
        
        print(f"Visiting node {node.val} at depth {depth}")
        
        # Check if leaf node
        if not node.left and not node.right:
            print(f"  ‚úì Found leaf! Minimum depth = {depth}")
            return depth
        
        # Add children
        if node.left:
            queue.append((node.left, depth + 1))
        if node.right:
            queue.append((node.right, depth + 1))
    
    return 0


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("MINIMUM DEPTH OF BINARY TREE")
print("=" * 60)

# Create unbalanced tree
#       1
#      / \
#     2   3
#    /
#   4
tree3 = TreeNode(1)
tree3.left = TreeNode(2)
tree3.right = TreeNode(3)
tree3.left.left = TreeNode(4)

result = min_depth(tree3)
print(f"\nMinimum Depth: {result}")
print("=" * 60)
```

---

## 4.2 Graph BFS Traversal

### Understanding Graph BFS

**Concept:**
```
Graph:
    0 --- 1
    |     |
    2 --- 3
    
Adjacency List:
0: [1, 2]
1: [0, 3]
2: [0, 3]
3: [1, 2]

BFS from 0:
Queue: [0]        ‚Üí Visit 0, add neighbors [1, 2]
Queue: [1, 2]     ‚Üí Visit 1, add neighbor 3
Queue: [2, 3]     ‚Üí Visit 2 (3 already visited)
Queue: [3]        ‚Üí Visit 3

Order: 0, 1, 2, 3
```

### Standard BFS Template for Graphs

```python
from collections import deque

def bfs_graph(graph, start):
    """
    BFS traversal of graph.
    
    CRITICAL: Must track visited nodes to avoid cycles!
    
    Time: O(V + E) where V=vertices, E=edges
    Space: O(V) for visited set and queue
    """
    visited = set()
    queue = deque([start])
    visited.add(start)
    result = []
    
    print(f"BFS starting from node {start}:")
    print("=" * 60)
    
    while queue:
        node = queue.popleft()
        result.append(node)
        
        print(f"\nVisiting: {node}")
        print(f"  Neighbors: {graph[node]}")
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
                print(f"  ‚úì Added {neighbor} to queue")
            else:
                print(f"  ‚úó {neighbor} already visited")
        
        print(f"  Queue: {list(queue)}")
        print(f"  Visited: {sorted(visited)}")
    
    return result


# ============ DEMONSTRATION ============

print("=" * 60)
print("GRAPH BFS TRAVERSAL")
print("=" * 60)

# Create graph
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 3],
    3: [1, 2, 4],
    4: [1, 3]
}

print("\nGraph structure:")
for node, neighbors in graph.items():
    print(f"  {node} ‚Üí {neighbors}")

result = bfs_graph(graph, 0)

print("\n" + "=" * 60)
print(f"BFS Order: {result}")
print("=" * 60)
```

---

## 4.3 Shortest Path Problems (Unweighted)

### Why BFS for Shortest Path?

**Key Insight:** In unweighted graphs, BFS guarantees shortest path because:
1. Explores nodes level by level
2. First time we reach a node = shortest path to it
3. All edges have same weight (1)

### Problem 1: Shortest Path in Binary Matrix

```python
def shortest_path_binary_matrix(grid):
    """
    Find shortest path from top-left to bottom-right in binary matrix.
    Can move in 8 directions. 0 = walkable, 1 = blocked.
    
    Example:
    [[0,0,0],
     [1,1,0],
     [1,1,0]]
    
    Output: 4 (path: 0,0 ‚Üí 0,1 ‚Üí 0,2 ‚Üí 1,2 ‚Üí 2,2)
    
    Time: O(n¬≤), Space: O(n¬≤)
    """
    if not grid or grid[0][0] == 1:
        return -1
    
    n = len(grid)
    if grid[n-1][n-1] == 1:
        return -1
    
    # 8 directions: up, down, left, right, and 4 diagonals
    directions = [
        (-1, -1), (-1, 0), (-1, 1),
        (0, -1),           (0, 1),
        (1, -1),  (1, 0),  (1, 1)
    ]
    
    queue = deque([(0, 0, 1)])  # (row, col, distance)
    visited = {(0, 0)}
    
    print("Finding Shortest Path:")
    print("=" * 60)
    
    while queue:
        row, col, dist = queue.popleft()
        
        print(f"\nPosition ({row},{col}), Distance: {dist}")
        
        # Check if reached destination
        if row == n - 1 and col == n - 1:
            print(f"‚úì Reached destination! Shortest path = {dist}")
            return dist
        
        # Explore all 8 directions
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            # Check boundaries and validity
            if (0 <= new_row < n and 
                0 <= new_col < n and
                grid[new_row][new_col] == 0 and
                (new_row, new_col) not in visited):
                
                visited.add((new_row, new_col))
                queue.append((new_row, new_col, dist + 1))
                print(f"  Moved to ({new_row},{new_col})")
    
    print("No path found!")
    return -1


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("SHORTEST PATH IN BINARY MATRIX")
print("=" * 60)

grid1 = [
    [0, 0, 0],
    [1, 1, 0],
    [1, 1, 0]
]

print("Grid:")
for row in grid1:
    print("  ", row)

result = shortest_path_binary_matrix(grid1)
print(f"\nShortest Path Length: {result}")
print("=" * 60)
```

### Problem 2: Word Ladder

```python
def word_ladder(begin_word, end_word, word_list):
    """
    Find shortest transformation sequence from begin_word to end_word.
    Each step changes only one letter.
    
    Example:
    begin = "hit", end = "cog"
    word_list = ["hot","dot","dog","lot","log","cog"]
    
    Output: 5 (hit ‚Üí hot ‚Üí dot ‚Üí dog ‚Üí cog)
    
    Time: O(M¬≤ √ó N) where M=word length, N=word list size
    Space: O(M √ó N)
    """
    if end_word not in word_list:
        return 0
    
    word_set = set(word_list)
    queue = deque([(begin_word, 1)])
    visited = {begin_word}
    
    print(f"Word Ladder: '{begin_word}' ‚Üí '{end_word}'")
    print("=" * 60)
    
    while queue:
        word, steps = queue.popleft()
        
        print(f"\nCurrent: '{word}' (steps: {steps})")
        
        if word == end_word:
            print(f"‚úì Found target in {steps} steps!")
            return steps
        
        # Try changing each character
        for i in range(len(word)):
            for c in 'abcdefghijklmnopqrstuvwxyz':
                next_word = word[:i] + c + word[i+1:]
                
                if next_word in word_set and next_word not in visited:
                    visited.add(next_word)
                    queue.append((next_word, steps + 1))
                    print(f"  Found: '{next_word}'")
    
    print("No transformation sequence exists!")
    return 0


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("WORD LADDER PROBLEM")
print("=" * 60)

begin = "hit"
end = "cog"
word_list = ["hot", "dot", "dog", "lot", "log", "cog"]

print(f"\nWord List: {word_list}")
result = word_ladder(begin, end, word_list)

print(f"\nMinimum Transformations: {result}")
print("=" * 60)
```

---

## 4.4 Multi-Source BFS

### Understanding Multi-Source BFS

**Concept:**
```
Problem: Rotting Oranges

Grid at time=0:
[2, 1, 1]    2 = rotten
[1, 1, 0]    1 = fresh
[0, 1, 1]    0 = empty

Start BFS from ALL rotten oranges simultaneously!

Queue initially: [(0,0,0), ...] ‚Üê all rotten positions
Then spread like a wave...
```

### Problem: Rotting Oranges

```python
def oranges_rotting(grid):
    """
    Every minute, fresh oranges adjacent to rotten become rotten.
    Return minutes until no fresh oranges remain.
    
    KEY: Multi-source BFS - start from all rotten oranges!
    
    Time: O(m√ón), Space: O(m√ón)
    """
    rows, cols = len(grid), len(grid[0])
    queue = deque()
    fresh_count = 0
    
    # Initialize: add all rotten oranges to queue
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:
                queue.append((r, c, 0))  # (row, col, time)
            elif grid[r][c] == 1:
                fresh_count += 1
    
    print("Rotting Oranges Simulation:")
    print("=" * 60)
    print(f"Initial fresh oranges: {fresh_count}")
    print(f"Initial rotten positions: {[(r,c) for r,c,_ in queue]}")
    
    if fresh_count == 0:
        return 0
    
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    max_time = 0
    
    while queue:
        row, col, time = queue.popleft()
        max_time = max(max_time, time)
        
        # Spread rot to adjacent fresh oranges
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            if (0 <= new_row < rows and 
                0 <= new_col < cols and
                grid[new_row][new_col] == 1):
                
                grid[new_row][new_col] = 2
                fresh_count -= 1
                queue.append((new_row, new_col, time + 1))
                print(f"Time {time+1}: Orange at ({new_row},{new_col}) rots")
    
    if fresh_count > 0:
        print(f"\n‚ùå {fresh_count} fresh oranges remain unreachable!")
        return -1
    
    print(f"\n‚úì All oranges rotten at time {max_time}")
    return max_time


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("ROTTING ORANGES - MULTI-SOURCE BFS")
print("=" * 60)

grid = [
    [2, 1, 1],
    [1, 1, 0],
    [0, 1, 1]
]

print("\nInitial Grid:")
for row in grid:
    print("  ", row)

result = oranges_rotting([row[:] for row in grid])  # Copy grid

print(f"\nMinutes Required: {result}")
print("=" * 60)
```

---

## Summary & Templates

```python
print("\n" + "=" * 60)
print("CHAPTER 4: KEY TEMPLATES & PATTERNS")
print("=" * 60)

templates = """
üéØ STANDARD BFS TEMPLATES:

1Ô∏è‚É£ TREE LEVEL-ORDER (Basic):
   queue = deque([root])
   while queue:
       node = queue.popleft()
       process(node)
       add children to queue

2Ô∏è‚É£ TREE LEVEL-BY-LEVEL (Most Important!):
   queue = deque([root])
   while queue:
       level_size = len(queue)  ‚≠ê KEY!
       for i in range(level_size):
           node = queue.popleft()
           process(node)
           add children

3Ô∏è‚É£ GRAPH BFS:
   visited = set([start])
   queue = deque([start])
   while queue:
       node = queue.popleft()
       for neighbor in graph[node]:
           if neighbor not in visited:
               visited.add(neighbor)  ‚≠ê KEY!
               queue.append(neighbor)

4Ô∏è‚É£ SHORTEST PATH (Unweighted):
   queue = deque([(start, 0)])  # (node, distance)
   visited = {start}
   while queue:
       node, dist = queue.popleft()
       if node == target:
           return dist
       explore neighbors...

5Ô∏è‚É£ MULTI-SOURCE BFS:
   queue = deque()
   for all sources:
       queue.append(source)  ‚≠ê Add ALL sources first!
   then standard BFS...

üìä COMPLEXITY ANALYSIS:

Tree BFS:
- Time: O(n) where n = number of nodes
- Space: O(w) where w = maximum width

Graph BFS:
- Time: O(V + E) where V = vertices, E = edges
- Space: O(V) for visited set and queue

Grid BFS:
- Time: O(rows √ó cols)
- Space: O(rows √ó cols)

üí° KEY INSIGHTS:

‚úì BFS explores level by level
‚úì BFS guarantees shortest path in unweighted graphs
‚úì Always use visited set for graphs to avoid cycles
‚úì Queue size at start of iteration = nodes in current level
‚úì Multi-source BFS: Add all sources to queue initially
‚úì For trees: No visited needed (no cycles)
‚úì For graphs: Must track visited (cycles possible)
"""

print(templates)

print("\n" + "=" * 60)
print("CHAPTER 4 COMPLETE!")
print("Next: Chapter 5 - Sliding Window with Queue")
print("=" * 60)
```

---

## Practice Problems for Chapter 4

### Tree BFS Problems:
1. ‚úì Binary Tree Level Order Traversal - LeetCode #102
2. ‚úì Binary Tree Right Side View - LeetCode #199
3. ‚úì Binary Tree Zigzag Level Order - LeetCode #103
4. ‚úì Average of Levels in Binary Tree - LeetCode #637
5. ‚úì Minimum Depth of Binary Tree - LeetCode #111
6. Maximum Depth of Binary Tree - LeetCode #104
7. Populating Next Right Pointers - LeetCode #116
8. Cousins in Binary Tree - LeetCode #993

### Graph BFS Problems:
9. ‚úì Graph BFS Traversal - Basic implementation
10. Number of Islands - LeetCode #200
11. Clone Graph - LeetCode #133

### Shortest Path Problems:
12. ‚úì Shortest Path in Binary Matrix - LeetCode #1091
13. ‚úì Word Ladder - LeetCode #127
14. Open the Lock - LeetCode #752
15. Minimum Knight Moves - LeetCode #1197

### Multi-Source BFS:
16. ‚úì Rotting Oranges - LeetCode #994
17. Walls and Gates - LeetCode #286
18. 01 Matrix - LeetCode #542

**Ready for Chapter 5**: Sliding Window with Queue and Monotonic Queue patterns!