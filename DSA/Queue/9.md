# Chapter 9: Tips and Tricks for Interviews - In-Depth Guide

## 9.1 Code Templates to Memorize

### Template 1: Standard BFS (Graph/Tree)

```python
"""
STANDARD BFS TEMPLATE - MEMORIZE THIS!

Use for: Shortest path, level traversal, connected components
Time: O(V + E) for graphs, O(N) for trees
Space: O(V) for visited set + queue
"""

from collections import deque

def bfs_template(graph, start):
    """
    Standard BFS traversal template.
    Works for both directed and undirected graphs.
    """
    # Step 1: Initialize
    visited = set([start])  # ‚≠ê CRITICAL for graphs
    queue = deque([start])
    result = []
    
    # Step 2: BFS loop
    while queue:
        node = queue.popleft()
        result.append(node)  # Process node
        
        # Step 3: Explore neighbors
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)  # Mark BEFORE adding to queue
                queue.append(neighbor)
    
    return result


# Example usage
graph = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 3],
    3: [1, 2]
}

print("=" * 70)
print("TEMPLATE 1: Standard BFS")
print("=" * 70)
print(f"Graph: {graph}")
print(f"BFS from 0: {bfs_template(graph, 0)}")
print("\nüéØ When to use:")
print("  - Graph traversal")
print("  - Finding connected components")
print("  - Checking if path exists")
print("=" * 70)
```

---

### Template 2: Level-Order BFS (Most Important!)

```python
"""
LEVEL-ORDER BFS TEMPLATE - MOST COMMONLY USED IN INTERVIEWS!

Use for: Level-by-level processing, tree problems
Key insight: Capture len(queue) to process each level separately
"""

from collections import deque

def level_order_template(root):
    """
    Level-order BFS template.
    Process nodes level by level.
    """
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)  # ‚≠ê KEY: Snapshot of current level
        current_level = []
        
        # Process all nodes in current level
        for i in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)
            
            # Add children for next level
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(current_level)
    
    return result


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# Example
print("\n" + "=" * 70)
print("TEMPLATE 2: Level-Order BFS")
print("=" * 70)

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

result = level_order_template(root)
print(f"Level-order result: {result}")
print("\nüéØ When to use:")
print("  - Any problem mentioning 'level'")
print("  - Right/left side view")
print("  - Zigzag traversal")
print("  - Level averages/sums")
print("=" * 70)
```

---

### Template 3: Shortest Path BFS

```python
"""
SHORTEST PATH BFS TEMPLATE

Use for: Finding shortest path in unweighted graph/grid
Key insight: BFS guarantees shortest path in unweighted graphs
"""

from collections import deque

def shortest_path_template(graph, start, target):
    """
    Find shortest path from start to target.
    Returns distance, or -1 if unreachable.
    """
    queue = deque([(start, 0)])  # (node, distance)
    visited = {start}
    
    while queue:
        node, dist = queue.popleft()
        
        # Check if reached target
        if node == target:
            return dist
        
        # Explore neighbors
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, dist + 1))
    
    return -1  # Target not reachable


# Grid version
def shortest_path_grid(grid, start, end):
    """
    Shortest path in 2D grid.
    0 = walkable, 1 = blocked
    """
    rows, cols = len(grid), len(grid[0])
    directions = [(0,1), (1,0), (0,-1), (-1,0)]
    
    queue = deque([(start[0], start[1], 0)])
    visited = {(start[0], start[1])}
    
    while queue:
        r, c, dist = queue.popleft()
        
        if (r, c) == end:
            return dist
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            if (0 <= nr < rows and 0 <= nc < cols and
                grid[nr][nc] == 0 and
                (nr, nc) not in visited):
                
                visited.add((nr, nc))
                queue.append((nr, nc, dist + 1))
    
    return -1


print("\n" + "=" * 70)
print("TEMPLATE 3: Shortest Path BFS")
print("=" * 70)
print("\nüéØ When to use:")
print("  - 'Shortest path' or 'minimum steps'")
print("  - Unweighted graph/grid")
print("  - Word ladder type problems")
print("=" * 70)
```

---

### Template 4: Monotonic Queue

```python
"""
MONOTONIC QUEUE TEMPLATE - CRITICAL FOR SLIDING WINDOW!

Use for: Sliding window maximum/minimum
Time: O(n) - each element added/removed once
"""

from collections import deque

def monotonic_queue_max_template(arr, k):
    """
    Sliding window maximum using monotonic decreasing deque.
    
    For maximum: maintain DECREASING order
    For minimum: maintain INCREASING order
    """
    result = []
    dq = deque()  # Store INDICES not values
    
    for i in range(len(arr)):
        # Step 1: Remove elements outside window
        while dq and dq[0] <= i - k:
            dq.popleft()
        
        # Step 2: Maintain monotonic property
        # For max: remove smaller elements from back
        while dq and arr[dq[-1]] < arr[i]:
            dq.pop()
        
        # Step 3: Add current element
        dq.append(i)
        
        # Step 4: Record result when window is formed
        if i >= k - 1:
            result.append(arr[dq[0]])
    
    return result


# Minimum version
def monotonic_queue_min_template(arr, k):
    """For minimum: maintain INCREASING order"""
    result = []
    dq = deque()
    
    for i in range(len(arr)):
        while dq and dq[0] <= i - k:
            dq.popleft()
        
        # For min: remove LARGER elements
        while dq and arr[dq[-1]] > arr[i]:
            dq.pop()
        
        dq.append(i)
        
        if i >= k - 1:
            result.append(arr[dq[0]])
    
    return result


print("\n" + "=" * 70)
print("TEMPLATE 4: Monotonic Queue")
print("=" * 70)

arr = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3

print(f"Array: {arr}")
print(f"Window size: {k}")
print(f"Maximums: {monotonic_queue_max_template(arr, k)}")
print(f"Minimums: {monotonic_queue_min_template(arr, k)}")

print("\nüéØ When to use:")
print("  - 'Maximum in window'")
print("  - 'Minimum in window'")
print("  - 'Next greater element'")

print("\n‚ö†Ô∏è Remember:")
print("  - For MAX: decreasing deque")
print("  - For MIN: increasing deque")
print("  - Store INDICES, not values!")
print("=" * 70)
```

---

### Template 5: Multi-Source BFS

```python
"""
MULTI-SOURCE BFS TEMPLATE

Use for: Problems with multiple starting points
Key insight: Add ALL sources to queue initially, then standard BFS
"""

from collections import deque

def multi_source_bfs_template(grid):
    """
    Multi-source BFS template.
    Example: Rotting oranges, walls and gates, etc.
    """
    rows, cols = len(grid), len(grid[0])
    queue = deque()
    
    # Step 1: Add ALL sources to queue initially
    for r in range(rows):
        for c in range(cols):
            if is_source(grid[r][c]):  # Your condition
                queue.append((r, c, 0))  # (row, col, distance)
    
    # Step 2: Standard BFS from all sources simultaneously
    directions = [(0,1), (1,0), (0,-1), (-1,0)]
    max_dist = 0
    
    while queue:
        r, c, dist = queue.popleft()
        max_dist = max(max_dist, dist)
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            if is_valid(nr, nc, rows, cols, grid):
                # Mark as visited/processed
                grid[nr][nc] = PROCESSED  # Your marking
                queue.append((nr, nc, dist + 1))
    
    return max_dist


def is_source(cell):
    """Define what makes a cell a source"""
    return cell == SOURCE_VALUE  # Your condition


def is_valid(r, c, rows, cols, grid):
    """Define validity condition"""
    return (0 <= r < rows and 0 <= c < cols and
            grid[r][c] == TARGET_VALUE)  # Your condition


print("\n" + "=" * 70)
print("TEMPLATE 5: Multi-Source BFS")
print("=" * 70)
print("\nüéØ When to use:")
print("  - Multiple starting points")
print("  - 'Spread from all X simultaneously'")
print("  - Rotting oranges, forest fire, etc.")

print("\nüí° Key insight:")
print("  All sources spread like a wave together")
print("  Add ALL to queue first, then standard BFS")
print("=" * 70)
```

---

## 9.2 Time Complexity Quick Reference

```python
print("\n" + "=" * 70)
print("TIME COMPLEXITY QUICK REFERENCE")
print("=" * 70)

complexity_guide = """
üìä QUEUE OPERATIONS:

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë         Operation          ‚ïë      Time     ‚ïë      Space        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë Enqueue/Dequeue            ‚ïë     O(1)      ‚ïë       O(n)        ‚ïë
‚ïë Peek/Front                 ‚ïë     O(1)      ‚ïë       O(1)        ‚ïë
‚ïë Size/IsEmpty               ‚ïë     O(1)      ‚ïë       O(1)        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìä BFS COMPLEXITIES:

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë       Problem Type         ‚ïë      Time     ‚ïë      Space        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë Graph BFS                  ‚ïë   O(V + E)    ‚ïë      O(V)         ‚ïë
‚ïë Tree BFS                   ‚ïë     O(N)      ‚ïë      O(W)         ‚ïë
‚ïë Grid BFS                   ‚ïë   O(R √ó C)    ‚ïë    O(R √ó C)       ‚ïë
‚ïë Multi-source BFS           ‚ïë   O(V + E)    ‚ïë      O(V)         ‚ïë
‚ïë Bidirectional BFS          ‚ïë  O(b^(d/2))   ‚ïë    O(b^(d/2))     ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Where:
- V = vertices, E = edges
- N = tree nodes, W = max width
- R = rows, C = cols in grid
- b = branching factor, d = depth

üìä SPECIAL QUEUE ALGORITHMS:

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë         Algorithm          ‚ïë      Time     ‚ïë      Space        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë Sliding Window Max/Min     ‚ïë     O(n)      ‚ïë      O(k)         ‚ïë
‚ïë Queue using 2 Stacks       ‚ïë O(1) amortized‚ïë      O(n)         ‚ïë
‚ïë Priority Queue Insert      ‚ïë   O(log n)    ‚ïë      O(n)         ‚ïë
‚ïë Priority Queue Extract     ‚ïë   O(log n)    ‚ïë      O(n)         ‚ïë
‚ïë 0-1 BFS                    ‚ïë   O(V + E)    ‚ïë      O(V)         ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üí° AMORTIZED ANALYSIS:

Queue using Stacks:
- Each element pushed to stack1 once: O(1)
- Each element moved to stack2 at most once: O(1)
- Each element popped from stack2 once: O(1)
- Total: 3 operations per element = O(1) amortized

Monotonic Queue:
- Each element added once: O(1)
- Each element removed at most once: O(1)
- Total: 2 operations per element = O(1) amortized

üéØ INTERVIEW TIPS:

‚úì Always mention BOTH time and space complexity
‚úì Explain why it's optimal (or not)
‚úì Consider best, average, and worst cases
‚úì Mention amortized when applicable
"""

print(complexity_guide)
print("=" * 70)
```

---

## 9.3 Space Complexity Considerations

```python
print("\n" + "=" * 70)
print("SPACE COMPLEXITY DETAILED ANALYSIS")
print("=" * 70)

space_guide = """
üéØ COMMON SPACE USAGE PATTERNS:

1Ô∏è‚É£ BFS SPACE = MAX QUEUE SIZE

Tree BFS:
- Queue holds one level at a time
- Max width in complete binary tree: 2^h ‚âà n/2
- Space: O(w) where w = max width
- For complete tree: O(n)

Graph BFS:
- Queue + visited set
- Worst case: all vertices in queue
- Space: O(V) where V = vertices

Grid BFS:
- Queue + visited set (or modify grid)
- Worst case: all cells
- Space: O(rows √ó cols)

2Ô∏è‚É£ VISITED SET SPACE

When needed:
‚úì Graph BFS (always - avoid cycles)
‚úì Grid BFS (unless modifying in-place)
‚úó Tree BFS (never - no cycles)

Optimization:
- Can modify grid in-place to save space
- Use bit manipulation for boolean grids
- Consider if visited array is really needed

3Ô∏è‚É£ MONOTONIC QUEUE SPACE

Maximum size:
- Deque holds at most k elements for window size k
- Space: O(k)
- For entire array: O(n) worst case

4Ô∏è‚É£ PRIORITY QUEUE SPACE

Heap size:
- Holds all elements: O(n)
- For k-way operations: O(k)
- Dijkstra's algorithm: O(V)

5Ô∏è‚É£ AUXILIARY SPACE

Consider:
- Result array: O(output size)
- Recursion stack: O(depth) for DFS
- Hash maps/sets: O(unique elements)
- String/array copies: Often O(n)

‚ö†Ô∏è SPACE OPTIMIZATION TECHNIQUES:

1. In-place modification:
   BAD:  visited = set()  # O(n) extra space
   GOOD: grid[r][c] = '#' # Mark in-place

2. Reuse data structures:
   BAD:  Create new queue each iteration
   GOOD: Clear and reuse single queue

3. Iterative over recursive:
   Recursive: O(depth) call stack
   Iterative: O(1) with queue

4. Bit manipulation for boolean grids:
   Regular: O(rows √ó cols) for visited
   Optimized: Pack into integers

üéØ INTERVIEW COMMUNICATION:

When discussing space complexity:

‚úì "The queue will hold at most one level at a time,
   which in a complete binary tree is O(n/2) = O(n)"

‚úì "We need O(V) space for the visited set to track
   which vertices we've processed"

‚úì "While we use O(k) for the deque, the overall
   space is O(n) including the result array"

‚úó "It uses some extra space"  ‚Üê Too vague!
‚úó Just stating "O(n)" without explanation
"""

print(space_guide)
print("=" * 70)
```

---

## 9.4 Interview Communication Tips

```python
print("\n" + "=" * 70)
print("INTERVIEW COMMUNICATION MASTERCLASS")
print("=" * 70)

communication_guide = """
üéØ THE INTERVIEW CONVERSATION FLOW:

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
PHASE 1: CLARIFICATION (2-3 minutes)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚úì Repeat problem in your own words
‚úì Ask about input constraints
‚úì Clarify edge cases
‚úì Confirm expected output format

EXAMPLE SCRIPT:
"Let me make sure I understand the problem correctly.
We're given a binary tree and need to return the level-order
traversal. The tree can have duplicate values, correct?

Should we handle the case where the tree is empty?
And the output should be a list of lists, where each inner
list represents one level?

What about the size of the tree - any constraints there?"

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
PHASE 2: APPROACH DISCUSSION (3-5 minutes)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚úì Start with brute force
‚úì Explain limitations
‚úì Present optimized solution
‚úì Discuss tradeoffs

EXAMPLE SCRIPT:
"My first thought is to use BFS since we need to process
nodes level by level. The key insight is that we need to
track when one level ends and the next begins.

We can do this by capturing the queue size at the start
of each iteration. This tells us exactly how many nodes
are in the current level.

This approach gives us O(n) time since we visit each node
once, and O(w) space where w is the maximum width of the tree.

Does this approach sound good, or would you like me to
explore alternatives?"

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
PHASE 3: IMPLEMENTATION (15-20 minutes)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚úì Explain as you code
‚úì Use descriptive variable names
‚úì Handle edge cases
‚úì Add helpful comments

EXAMPLE NARRATION:
"First, I'll handle the edge case where root is None...

Now I'll initialize the queue with the root node...

The key step here is capturing the queue size before
processing each level - this is what allows us to
separate the levels...

I'm using a deque from collections for O(1) operations
on both ends..."

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
PHASE 4: TESTING (3-5 minutes)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚úì Walk through example
‚úì Test edge cases
‚úì Trace execution
‚úì Verify correctness

EXAMPLE SCRIPT:
"Let me trace through the example:
Starting with tree [1,2,3,4,5]...

Level 0: Queue has [1], we process it and add [2,3]
Level 1: Queue has [2,3], size is 2, we process both...
Level 2: Queue has [4,5], we process them...

Result: [[1], [2,3], [4,5]] ‚úì

Let me also check the edge cases:
- Empty tree: Returns [] immediately ‚úì
- Single node: Returns [[node.val]] ‚úì
- Skewed tree: Still works, just longer ‚úì"

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
PHASE 5: OPTIMIZATION & FOLLOW-UPS (3-5 minutes)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚úì Discuss complexity
‚úì Mention alternatives
‚úì Consider follow-ups
‚úì Explain tradeoffs

EXAMPLE SCRIPT:
"This solution is optimal for this problem - we can't do
better than O(n) time since we must visit each node.

The space complexity of O(w) is also optimal for BFS.
We could use DFS recursively with level tracking, which
would have O(h) stack space instead, where h is height.

For a balanced tree, w ‚âà n/2 and h ‚âà log n, so DFS would
be more space-efficient. But BFS is more intuitive for
level-order traversal.

Some follow-ups you might ask:
- Zigzag traversal: Alternate direction per level
- Right side view: Return last node of each level
- Vertical order: Group by column instead of level"
"""

print(communication_guide)
print("=" * 70)
```

---

## 9.5 Common Mistakes Checklist

```python
print("\n" + "=" * 70)
print("INTERVIEW MISTAKES CHECKLIST - AVOID THESE!")
print("=" * 70)

checklist = """
‚ö†Ô∏è BEFORE YOU START CODING:

‚ñ° Did you clarify the problem requirements?
‚ñ° Did you ask about edge cases?
‚ñ° Did you discuss your approach first?
‚ñ° Did you confirm input/output format?
‚ñ° Did you agree on time/space constraints?

‚ö†Ô∏è DURING IMPLEMENTATION:

‚ñ° Are you explaining as you code?
‚ñ° Are you using meaningful variable names?
‚ñ° Did you handle the empty input case?
‚ñ° For graphs: Did you add visited set?
‚ñ° For level-order: Did you capture queue size?
‚ñ° For monotonic queue: Are you storing indices?
‚ñ° For sliding window: Are you removing old elements?
‚ñ° Did you check array bounds?
‚ñ° Did you avoid off-by-one errors?

‚ö†Ô∏è COMMON CODING MISTAKES:

‚ùå MISTAKE: No visited set in graph BFS
‚úÖ FIX: visited = set([start]) before BFS

‚ùå MISTAKE: Not capturing queue size for levels
‚úÖ FIX: level_size = len(queue) at start of loop

‚ùå MISTAKE: Wrong monotonic order
‚úÖ FIX: Decreasing for MAX, increasing for MIN

‚ùå MISTAKE: Storing values instead of indices
‚úÖ FIX: deque.append(i) not deque.append(arr[i])

‚ùå MISTAKE: Not removing elements outside window
‚úÖ FIX: while dq and dq[0] <= i - k: dq.popleft()

‚ùå MISTAKE: Forgetting to check empty queue
‚úÖ FIX: if queue: or if not queue: return

‚ùå MISTAKE: Modifying list while iterating
‚úÖ FIX: Use queue/separate list for modifications

‚ùå MISTAKE: Not considering negative indices
‚úÖ FIX: Check both bounds: 0 <= i < n

‚ö†Ô∏è AFTER CODING:

‚ñ° Did you trace through an example?
‚ñ° Did you test edge cases?
‚ñ° Did you state time complexity?
‚ñ° Did you state space complexity?
‚ñ° Did you explain why it's optimal?
‚ñ° Are you ready for follow-up questions?

‚ö†Ô∏è IF YOU GET STUCK:

‚úì Don't panic - think out loud
‚úì Revisit problem constraints
‚úì Draw a diagram
‚úì Try a simple example
‚úì Ask clarifying questions
‚úì Discuss multiple approaches
‚úì It's okay to ask for hints!

üìù FINAL CHECKLIST BEFORE SUBMITTING:

‚ñ° Code compiles/runs
‚ñ° Edge cases handled
‚ñ° No syntax errors
‚ñ° Variable names are clear
‚ñ° Comments where needed
‚ñ° Complexity analysis provided
‚ñ° Test cases verified
"""

print(checklist)
print("=" * 70)
```

---

## Summary

```python
print("\n" + "=" * 70)
print("CHAPTER 9 SUMMARY: INTERVIEW MASTERY")
print("=" * 70)

summary = """
üéØ KEY TAKEAWAYS:

1. MEMORIZE THESE TEMPLATES:
   ‚úì Standard BFS
   ‚úì Level-order BFS (most important!)
   ‚úì Shortest path BFS
   ‚úì Monotonic queue
   ‚úì Multi-source BFS

2. COMPLEXITY ANALYSIS:
   ‚úì Graph BFS: O(V + E) time, O(V) space
   ‚úì Tree BFS: O(N) time, O(W) space
   ‚úì Monotonic queue: O(N) time, O(K) space
   ‚úì Always explain amortized when applicable

3. SPACE OPTIMIZATION:
   ‚úì In-place modification when possible
   ‚úì Reuse data structures
   ‚úì Consider iterative over recursive

4. COMMUNICATION:
   ‚úì Clarify ‚Üí Discuss ‚Üí Code ‚Üí Test ‚Üí Optimize
   ‚úì Explain as you code
   ‚úì Think out loud
   ‚úì Handle edge cases explicitly

5. AVOID COMMON MISTAKES:
   ‚úì No visited set (graphs)
   ‚úì Not capturing queue size (levels)
   ‚úì Wrong monotonic order (max/min)
   ‚úì Values instead of indices
   ‚úì Not checking empty

üí° INTERVIEW SUCCESS FORMULA:

Communication (40%) + Problem Solving (30%) + 
Coding (20%) + Edge Cases (10%) = Success!

Remember: Interviewers want to see your thought process,
not just correct code. Explain everything!
"""

print(summary)

print("\n" + "=" * 70)
print("CHAPTER 9 COMPLETE!")
print("Next: Chapter 10 - Practice Roadmap")
print("=" * 70)
```

This comprehensive chapter provides all the templates, tips, and strategies you need for interview success!