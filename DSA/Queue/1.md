# Chapter 1: Queue Fundamentals - In-Depth Explanation

## 1.1 Introduction to Queue

### What is a Queue?

A **Queue** is a linear data structure that follows the **FIFO (First-In-First-Out)** principle. This means the element that is added first will be the first one to be removed, just like people standing in a line.

### Visual Representation

```
Front                                    Rear
  ↓                                        ↓
[10] → [20] → [30] → [40] → [50]

Dequeue ←                        → Enqueue
(Remove)                         (Add)
```

**Operations Flow:**
```
Initial Queue: [10, 20, 30]

After Enqueue(40): [10, 20, 30, 40]
After Dequeue():   [20, 30, 40]      (10 removed)
After Enqueue(50): [20, 30, 40, 50]
```

### Real-World Examples

1. **Print Queue**: Documents are printed in the order they were sent
2. **CPU Scheduling**: Processes waiting for CPU time
3. **Breadth-First Search**: Nodes are explored level by level
4. **Call Center**: Calls are handled in the order received
5. **Ticket Booking**: First person in line gets served first

---

## 1.2 Basic Operations

### Core Operations

| Operation | Description | Time Complexity |
|-----------|-------------|-----------------|
| `enqueue(x)` | Add element x to rear | O(1) |
| `dequeue()` | Remove and return front element | O(1) |
| `front()`/`peek()` | Return front element without removal | O(1) |
| `isEmpty()` | Check if queue is empty | O(1) |
| `size()` | Return number of elements | O(1) |

### Operation Visualization

```
Starting Queue: [10, 20, 30]
                 ↑front      ↑rear

1. enqueue(40):
   [10, 20, 30, 40]
    ↑front          ↑rear

2. front() returns: 10
   [10, 20, 30, 40]
    ↑

3. dequeue() returns: 10
   [20, 30, 40]
    ↑front     ↑rear

4. isEmpty() returns: False

5. size() returns: 3
```

---

## 1.3 Implementation Methods

### 1.3.1 Array-Based Implementation (Simple)

#### Concept
Use a simple array with two pointers: `front` and `rear`.

**Problem with Simple Array Implementation:**
```
Initial: [ _ _ _ _ _ ]  capacity = 5
         front=0, rear=-1

After 3 enqueues: [10 20 30 _ _]
                   front=0, rear=2

After 2 dequeues: [_ _ 30 _ _]
                      front=2, rear=2

Problem: Space at beginning is wasted!
After more enqueues: [_ _ 30 40 50]
                         front=2, rear=4
Cannot add more even though space exists at front!
```

#### Python Implementation (Simple Array)

```python
class SimpleQueue:
    def __init__(self, capacity):
        self.capacity = capacity
        self.queue = [None] * capacity
        self.front = 0
        self.rear = -1
        self.size = 0
    
    def is_empty(self):
        return self.size == 0
    
    def is_full(self):
        return self.size == self.capacity
    
    def enqueue(self, data):
        if self.is_full():
            raise Exception("Queue Overflow")
        
        self.rear += 1
        self.queue[self.rear] = data
        self.size += 1
        print(f"Enqueued {data}")
    
    def dequeue(self):
        if self.is_empty():
            raise Exception("Queue Underflow")
        
        data = self.queue[self.front]
        self.queue[self.front] = None  # Optional: clear the slot
        self.front += 1
        self.size -= 1
        return data
    
    def peek(self):
        if self.is_empty():
            raise Exception("Queue is empty")
        return self.queue[self.front]
    
    def get_size(self):
        return self.size
    
    def display(self):
        if self.is_empty():
            print("Queue is empty")
            return
        print("Queue:", [self.queue[i] for i in range(self.front, self.rear + 1)])

# Example Usage
q = SimpleQueue(5)
q.enqueue(10)
q.enqueue(20)
q.enqueue(30)
q.display()  # [10, 20, 30]

print("Front element:", q.peek())  # 10
print("Dequeued:", q.dequeue())     # 10
q.display()  # [20, 30]
```

**Output:**
```
Enqueued 10
Enqueued 20
Enqueued 30
Queue: [10, 20, 30]
Front element: 10
Dequeued: 10
Queue: [20, 30]
```

---

### 1.3.2 Circular Queue (Efficient Array Implementation)

#### Concept
Connect the end of the array back to the beginning to reuse space.

**Circular Queue Visualization:**
```
Logical View:
     [0]
  [4]   [1]
  [3]   [2]

Physical Array: [10, 20, 30, _, _]
                 0   1   2  3  4
```

**How Circular Works:**
```
Initial State:
Array: [_ _ _ _ _]  capacity = 5
front = 0, rear = -1, size = 0

After enqueue(10, 20, 30):
Array: [10 20 30 _ _]
        f       r
front = 0, rear = 2, size = 3

After dequeue() twice:
Array: [_ _ 30 _ _]
           f   
           r
front = 2, rear = 2, size = 1

After enqueue(40, 50, 60):
Array: [50 60 30 40 _]
       r      f
front = 2, rear = 1, size = 4
(rear wrapped around using modulo)

Key Formula: next_position = (current_position + 1) % capacity
```

#### Python Implementation (Circular Queue)

```python
class CircularQueue:
    def __init__(self, capacity):
        self.capacity = capacity
        self.queue = [None] * capacity
        self.front = 0
        self.rear = -1
        self.size = 0
    
    def is_empty(self):
        return self.size == 0
    
    def is_full(self):
        return self.size == self.capacity
    
    def enqueue(self, data):
        if self.is_full():
            raise Exception("Queue Overflow")
        
        # Move rear circularly
        self.rear = (self.rear + 1) % self.capacity
        self.queue[self.rear] = data
        self.size += 1
        print(f"Enqueued {data} at position {self.rear}")
    
    def dequeue(self):
        if self.is_empty():
            raise Exception("Queue Underflow")
        
        data = self.queue[self.front]
        self.queue[self.front] = None
        self.front = (self.front + 1) % self.capacity
        self.size -= 1
        return data
    
    def peek(self):
        if self.is_empty():
            raise Exception("Queue is empty")
        return self.queue[self.front]
    
    def display(self):
        if self.is_empty():
            print("Queue is empty")
            return
        
        print(f"Queue (front={self.front}, rear={self.rear}, size={self.size}):")
        elements = []
        i = self.front
        for _ in range(self.size):
            elements.append(self.queue[i])
            i = (i + 1) % self.capacity
        print(elements)

# Example Usage
cq = CircularQueue(5)

# Enqueue elements
cq.enqueue(10)
cq.enqueue(20)
cq.enqueue(30)
cq.display()

# Dequeue some elements
print("Dequeued:", cq.dequeue())
print("Dequeued:", cq.dequeue())
cq.display()

# Enqueue more (demonstrating circular nature)
cq.enqueue(40)
cq.enqueue(50)
cq.enqueue(60)
cq.display()

# Try to enqueue when full
try:
    cq.enqueue(70)
except Exception as e:
    print(f"Error: {e}")
```

**Output:**
```
Enqueued 10 at position 0
Enqueued 20 at position 1
Enqueued 30 at position 2
Queue (front=0, rear=2, size=3):
[10, 20, 30]
Dequeued: 10
Dequeued: 20
Queue (front=2, rear=2, size=1):
[30]
Enqueued 40 at position 3
Enqueued 50 at position 4
Enqueued 60 at position 0
Queue (front=2, rear=0, size=4):
[30, 40, 50, 60]
Error: Queue Overflow
```

---

### 1.3.3 Linked List Implementation

#### Concept
Use nodes with pointers. Each node contains data and a reference to the next node.

**Visual Representation:**
```
Front                                     Rear
  ↓                                         ↓
[10|•]→[20|•]→[30|•]→[40|•]→[50|None]

Enqueue: Add at rear
Dequeue: Remove from front
```

#### Python Implementation (Linked List)

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedListQueue:
    def __init__(self):
        self.front = None
        self.rear = None
        self.size = 0
    
    def is_empty(self):
        return self.front is None
    
    def enqueue(self, data):
        new_node = Node(data)
        
        # If queue is empty
        if self.rear is None:
            self.front = self.rear = new_node
            self.size = 1
            print(f"Enqueued {data} (first element)")
            return
        
        # Add new node at rear
        self.rear.next = new_node
        self.rear = new_node
        self.size += 1
        print(f"Enqueued {data}")
    
    def dequeue(self):
        if self.is_empty():
            raise Exception("Queue Underflow")
        
        data = self.front.data
        self.front = self.front.next
        
        # If queue becomes empty
        if self.front is None:
            self.rear = None
        
        self.size -= 1
        return data
    
    def peek(self):
        if self.is_empty():
            raise Exception("Queue is empty")
        return self.front.data
    
    def get_size(self):
        return self.size
    
    def display(self):
        if self.is_empty():
            print("Queue is empty")
            return
        
        current = self.front
        elements = []
        while current:
            elements.append(current.data)
            current = current.next
        print(f"Queue (size={self.size}):", elements)

# Example Usage
llq = LinkedListQueue()

# Enqueue elements
llq.enqueue(10)
llq.enqueue(20)
llq.enqueue(30)
llq.enqueue(40)
llq.display()

# Peek
print("Front element:", llq.peek())

# Dequeue
print("Dequeued:", llq.dequeue())
print("Dequeued:", llq.dequeue())
llq.display()

# Check size
print("Current size:", llq.get_size())

# Dequeue all
while not llq.is_empty():
    print("Dequeued:", llq.dequeue())

llq.display()
```

**Output:**
```
Enqueued 10 (first element)
Enqueued 20
Enqueued 30
Enqueued 40
Queue (size=4): [10, 20, 30, 40]
Front element: 10
Dequeued: 10
Dequeued: 20
Queue (size=2): [30, 40]
Current size: 2
Dequeued: 30
Dequeued: 40
Queue is empty
```

---

### 1.3.4 Using Built-in Libraries

#### Python: collections.deque

```python
from collections import deque

# Create queue
q = deque()

# Enqueue (append)
q.append(10)
q.append(20)
q.append(30)
print("Queue:", list(q))  # [10, 20, 30]

# Dequeue (popleft)
print("Dequeued:", q.popleft())  # 10

# Peek (access first element)
print("Front:", q[0])  # 20

# Size
print("Size:", len(q))  # 2

# Check if empty
print("Is empty:", len(q) == 0)  # False
```

#### Java Implementation

```java
import java.util.Queue;
import java.util.LinkedList;

public class QueueExample {
    public static void main(String[] args) {
        // Create queue
        Queue<Integer> queue = new LinkedList<>();
        
        // Enqueue (offer or add)
        queue.offer(10);
        queue.offer(20);
        queue.offer(30);
        System.out.println("Queue: " + queue);
        
        // Dequeue (poll or remove)
        System.out.println("Dequeued: " + queue.poll());
        
        // Peek
        System.out.println("Front: " + queue.peek());
        
        // Size
        System.out.println("Size: " + queue.size());
        
        // Is empty
        System.out.println("Is empty: " + queue.isEmpty());
    }
}
```

#### C++ Implementation

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Create queue
    queue<int> q;
    
    // Enqueue (push)
    q.push(10);
    q.push(20);
    q.push(30);
    
    cout << "Queue size: " << q.size() << endl;
    
    // Peek (front)
    cout << "Front: " << q.front() << endl;
    
    // Dequeue (pop)
    q.pop();
    cout << "After dequeue, front: " << q.front() << endl;
    
    // Is empty
    cout << "Is empty: " << (q.empty() ? "Yes" : "No") << endl;
    
    return 0;
}
```

---

## 1.4 Time & Space Complexity Analysis

### Time Complexity

| Implementation | Enqueue | Dequeue | Peek | Space |
|----------------|---------|---------|------|-------|
| Simple Array | O(1) | O(1) | O(1) | O(n) - Wastes space |
| Circular Array | O(1) | O(1) | O(1) | O(n) - Efficient |
| Linked List | O(1) | O(1) | O(1) | O(n) - Extra pointer space |

### Space Complexity Details

**Array Implementation:**
- Fixed space: O(capacity)
- May waste space if not full
- Better cache locality (elements contiguous in memory)

**Linked List Implementation:**
- Dynamic space: O(number of elements)
- Extra space for pointers: O(n) for n pointers
- No wasted space
- Worse cache locality (scattered in memory)

---

## Comparison: Array vs Linked List

| Feature | Array-Based | Linked List |
|---------|-------------|-------------|
| **Memory** | Fixed, contiguous | Dynamic, scattered |
| **Cache Performance** | Better (locality) | Worse |
| **Overflow** | Possible | No (until heap full) |
| **Memory Overhead** | None per element | Pointer per node |
| **Implementation** | Moderate | Easier |
| **Random Access** | Possible | Not possible |

---

## Key Takeaways

1. **Queue = FIFO**: First element added is first removed
2. **All basic operations are O(1)**: Efficient for all operations
3. **Circular Queue**: Solves space wastage in simple array
4. **Use modulo**: Key technique for circular implementation: `(index + 1) % capacity`
5. **Two pointers essential**: Always maintain `front` and `rear`
6. **Linked List advantage**: No overflow, dynamic size
7. **Array advantage**: Better cache performance, less memory overhead

---

## Practice Problems

1. Implement queue using arrays
2. Implement circular queue
3. Implement queue using linked list
4. Design a queue that supports getMin() in O(1)
5. Implement queue using two stacks

**Next Chapter Preview**: We'll explore queue variants including Deque, Priority Queue, and Monotonic Queue!