# Chapter 8: Interview Problems by Difficulty - In-Depth Solutions

## Overview

This chapter provides complete solutions to curated interview problems organized by difficulty level. Each problem includes:
- Problem statement
- Approach explanation
- Complete Python implementation
- Time/Space complexity analysis
- Key insights and variations

---

## 8.1 Easy Level Problems

### Problem 1: Implement Queue using Stacks (LeetCode #232)

```python
"""
PROBLEM: Implement First-In-First-Out (FIFO) queue using only two stacks.

Operations:
- push(x): Push element x to back of queue
- pop(): Remove element from front of queue
- peek(): Get front element
- empty(): Return whether queue is empty

Example:
queue = MyQueue()
queue.push(1)
queue.push(2)
queue.peek()  # returns 1
queue.pop()   # returns 1
queue.empty() # returns False
"""

class MyQueue:
    """
    Implement queue using two stacks.
    
    Strategy: Amortized O(1) operations
    - stack1: for push operations
    - stack2: for pop/peek operations
    
    When pop/peek called and stack2 is empty,
    transfer all elements from stack1 to stack2.
    """
    
    def __init__(self):
        self.stack1 = []  # For push
        self.stack2 = []  # For pop/peek
    
    def push(self, x: int) -> None:
        """
        Push element to queue.
        Time: O(1)
        """
        self.stack1.append(x)
    
    def pop(self) -> int:
        """
        Remove and return front element.
        Time: Amortized O(1)
        """
        self._move_stack1_to_stack2()
        return self.stack2.pop()
    
    def peek(self) -> int:
        """
        Get front element.
        Time: Amortized O(1)
        """
        self._move_stack1_to_stack2()
        return self.stack2[-1]
    
    def empty(self) -> bool:
        """
        Check if queue is empty.
        Time: O(1)
        """
        return not self.stack1 and not self.stack2
    
    def _move_stack1_to_stack2(self):
        """Transfer elements from stack1 to stack2 if needed"""
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())


# ============ TEST ============

print("=" * 70)
print("PROBLEM 1: Implement Queue using Stacks")
print("=" * 70)

queue = MyQueue()
print("\nOperations:")
queue.push(1)
print("push(1)")
queue.push(2)
print("push(2)")
print(f"peek() = {queue.peek()}")  # Returns 1
print(f"pop() = {queue.pop()}")    # Returns 1
print(f"empty() = {queue.empty()}")  # False

print("\n‚úÖ Complexity:")
print("  Time: Amortized O(1) for all operations")
print("  Space: O(n) where n = number of elements")

print("\nüí° Key Insight:")
print("  Each element is moved at most once from stack1 to stack2")
print("  Total cost: 2n operations for n elements = O(1) amortized")
print("=" * 70)
```

---

### Problem 2: Number of Recent Calls (LeetCode #933)

```python
"""
PROBLEM: Design a class to count the number of recent requests
within a certain time frame (3000 milliseconds).

ping(t): Adds new request at time t and returns number of
requests that happened in the past 3000 milliseconds.

Example:
counter = RecentCounter()
counter.ping(1)     # returns 1
counter.ping(100)   # returns 2
counter.ping(3001)  # returns 3
counter.ping(3002)  # returns 3 (request at time 1 is too old)
"""

from collections import deque

class RecentCounter:
    """
    Count recent calls using queue.
    
    Strategy:
    - Store all request timestamps in queue
    - Remove timestamps older than 3000ms
    - Return queue size
    
    Time: O(1) amortized per ping
    Space: O(W) where W = window size (at most 3000 requests)
    """
    
    def __init__(self):
        self.requests = deque()
        self.window = 3000
    
    def ping(self, t: int) -> int:
        """
        Add new request and return count of recent requests.
        Time: O(1) amortized
        """
        # Add new request
        self.requests.append(t)
        
        # Remove old requests outside window
        while self.requests and self.requests[0] < t - self.window:
            self.requests.popleft()
        
        return len(self.requests)


# ============ TEST ============

print("\n" + "=" * 70)
print("PROBLEM 2: Number of Recent Calls")
print("=" * 70)

counter = RecentCounter()
print("\nTest Case:")
print(f"ping(1) = {counter.ping(1)}")       # 1
print(f"ping(100) = {counter.ping(100)}")   # 2
print(f"ping(3001) = {counter.ping(3001)}") # 3
print(f"ping(3002) = {counter.ping(3002)}") # 3

print("\n‚úÖ Complexity:")
print("  Time: O(1) amortized per ping")
print("  Space: O(W) where W = max requests in window")

print("\nüí° Key Insight:")
print("  Queue naturally maintains time-ordered requests")
print("  Remove expired requests from front efficiently")
print("=" * 70)
```

---

### Problem 3: First Unique Character in a String (LeetCode #387)

```python
"""
PROBLEM: Given a string s, find the first non-repeating character
and return its index. If it doesn't exist, return -1.

Example:
s = "leetcode" ‚Üí return 0 (letter 'l')
s = "loveleetcode" ‚Üí return 2 (letter 'v')
s = "aabb" ‚Üí return -1
"""

from collections import Counter

def firstUniqChar(s: str) -> int:
    """
    Find first unique character using hash map.
    
    Time: O(n)
    Space: O(1) - at most 26 lowercase letters
    """
    # Count frequency of each character
    freq = Counter(s)
    
    # Find first character with frequency 1
    for i, char in enumerate(s):
        if freq[char] == 1:
            return i
    
    return -1


# Queue-based approach for streaming version
from collections import deque

class FirstUnique:
    """
    For streaming version: find first unique in stream.
    
    Strategy:
    - Queue stores potentially unique characters
    - Hash map tracks frequencies
    - Remove non-unique from front of queue
    """
    
    def __init__(self):
        self.queue = deque()
        self.freq = {}
    
    def add(self, char):
        """Add character to stream"""
        self.freq[char] = self.freq.get(char, 0) + 1
        
        if self.freq[char] == 1:
            self.queue.append(char)
    
    def getFirstUnique(self):
        """Get first unique character"""
        # Remove non-unique from front
        while self.queue and self.freq[self.queue[0]] > 1:
            self.queue.popleft()
        
        return self.queue[0] if self.queue else None


# ============ TEST ============

print("\n" + "=" * 70)
print("PROBLEM 3: First Unique Character")
print("=" * 70)

# Test static version
test_strings = ["leetcode", "loveleetcode", "aabb"]
print("\nStatic Version:")
for s in test_strings:
    result = firstUniqChar(s)
    print(f"  s = '{s}' ‚Üí index {result}")

# Test streaming version
print("\nStreaming Version:")
stream = FirstUnique()
chars = "aabccbd"
for char in chars:
    stream.add(char)
    unique = stream.getFirstUnique()
    print(f"  After '{char}': first unique = {unique}")

print("\n‚úÖ Complexity:")
print("  Time: O(n) for both versions")
print("  Space: O(1) for static, O(unique chars) for streaming")

print("\nüí° Key Insight:")
print("  Queue maintains order while hash map tracks frequency")
print("  Lazy removal: clean queue only when needed")
print("=" * 70)
```

---

## 8.2 Medium Level Problems

### Problem 1: Binary Tree Level Order Traversal (LeetCode #102) ‚≠ê

```python
"""
PROBLEM: Given root of binary tree, return level order traversal
of its nodes' values (left to right, level by level).

Example:
    3
   / \
  9  20
    /  \
   15   7

Output: [[3], [9, 20], [15, 7]]
"""

from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def levelOrder(root: TreeNode):
    """
    Level-order traversal using BFS.
    
    Time: O(n) where n = number of nodes
    Space: O(w) where w = maximum width
    """
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)  # ‚≠ê KEY: capture size
        current_level = []
        
        for i in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(current_level)
    
    return result


# ============ TEST ============

print("\n" + "=" * 70)
print("PROBLEM 4: Binary Tree Level Order Traversal")
print("=" * 70)

# Create tree: 3 -> 9, 20 -> 15, 7
root = TreeNode(3)
root.left = TreeNode(9)
root.right = TreeNode(20)
root.right.left = TreeNode(15)
root.right.right = TreeNode(7)

result = levelOrder(root)
print(f"\nResult: {result}")

print("\n‚úÖ Complexity:")
print("  Time: O(n) - visit each node once")
print("  Space: O(w) - queue holds one level at a time")

print("\nüí° Key Insight:")
print("  Capture len(queue) before processing level")
print("  This separates levels clearly")

print("\nüîÑ Variations:")
print("  - Zigzag level order")
print("  - Right side view (last node per level)")
print("  - Level averages")
print("=" * 70)
```

---

### Problem 2: Rotting Oranges (LeetCode #994) ‚≠ê

```python
"""
PROBLEM: In a grid, every minute, fresh oranges adjacent (4-directionally)
to rotten oranges become rotten. Return minimum minutes until no cell
has a fresh orange. If impossible, return -1.

Grid values:
- 0: empty cell
- 1: fresh orange
- 2: rotten orange

Example:
[[2,1,1],
 [1,1,0],
 [0,1,1]]

Output: 4
"""

from collections import deque

def orangesRotting(grid):
    """
    Multi-source BFS from all rotten oranges.
    
    Time: O(rows √ó cols)
    Space: O(rows √ó cols)
    """
    if not grid:
        return -1
    
    rows, cols = len(grid), len(grid[0])
    queue = deque()
    fresh_count = 0
    
    # Initialize: find rotten oranges and count fresh
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:
                queue.append((r, c, 0))
            elif grid[r][c] == 1:
                fresh_count += 1
    
    if fresh_count == 0:
        return 0
    
    # Multi-source BFS
    directions = [(0,1), (1,0), (0,-1), (-1,0)]
    max_time = 0
    
    while queue:
        r, c, time = queue.popleft()
        max_time = max(max_time, time)
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            if (0 <= nr < rows and 0 <= nc < cols and
                grid[nr][nc] == 1):
                
                grid[nr][nc] = 2
                fresh_count -= 1
                queue.append((nr, nc, time + 1))
    
    return max_time if fresh_count == 0 else -1


# ============ TEST ============

print("\n" + "=" * 70)
print("PROBLEM 5: Rotting Oranges")
print("=" * 70)

grid1 = [[2,1,1],[1,1,0],[0,1,1]]
grid2 = [[2,1,1],[0,1,1],[1,0,1]]
grid3 = [[0,2]]

print("\nTest Cases:")
print(f"Grid 1: {orangesRotting([row[:] for row in grid1])}")  # 4
print(f"Grid 2: {orangesRotting([row[:] for row in grid2])}")  # -1
print(f"Grid 3: {orangesRotting([row[:] for row in grid3])}")  # 0

print("\n‚úÖ Complexity:")
print("  Time: O(m √ó n) - visit each cell once")
print("  Space: O(m √ó n) - queue size")

print("\nüí° Key Insight:")
print("  Multi-source BFS: start from ALL rotten oranges simultaneously")
print("  They spread like a wave - BFS guarantees minimum time")

print("\nüîÑ Similar Problems:")
print("  - Walls and Gates")
print("  - 01 Matrix")
print("  - Shortest Bridge")
print("=" * 70)
```

---

### Problem 3: Sliding Window Maximum (LeetCode #239) ‚≠ê‚≠ê

```python
"""
PROBLEM: Given array nums and integer k, return max sliding window
of size k.

Example:
nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]

Explanation:
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
"""

from collections import deque

def maxSlidingWindow(nums, k):
    """
    Sliding window maximum using monotonic deque.
    
    Strategy:
    - Maintain decreasing deque (store indices)
    - Front of deque = maximum element
    - Remove smaller elements from back
    - Remove elements outside window from front
    
    Time: O(n) - each element added/removed once
    Space: O(k) - deque size
    """
    if not nums or k == 0:
        return []
    
    result = []
    dq = deque()  # Store indices
    
    for i in range(len(nums)):
        # Remove indices outside window
        while dq and dq[0] <= i - k:
            dq.popleft()
        
        # Remove smaller elements from back
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        
        dq.append(i)
        
        # Add to result when window is formed
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result


# ============ TEST ============

print("\n" + "=" * 70)
print("PROBLEM 6: Sliding Window Maximum")
print("=" * 70)

nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3

result = maxSlidingWindow(nums, k)
print(f"\nnums = {nums}")
print(f"k = {k}")
print(f"Output = {result}")

print("\n‚úÖ Complexity:")
print("  Time: O(n) - each element touched twice at most")
print("  Space: O(k) - deque holds at most k elements")

print("\nüí° Key Insight:")
print("  Monotonic decreasing deque maintains maximum at front")
print("  If nums[i] >= nums[j] and i > j, nums[j] can never be max!")

print("\n‚ö†Ô∏è Common Mistakes:")
print("  ‚ùå Using increasing deque (gives minimum, not maximum)")
print("  ‚ùå Storing values instead of indices")
print("  ‚ùå Not removing elements outside window")

print("\nüîÑ Similar Problems:")
print("  - Sliding Window Minimum (increasing deque)")
print("  - Longest Subarray with Absolute Diff ‚â§ Limit")
print("  - Constrained Subsequence Sum")
print("=" * 70)
```

---

### Problem 4: Perfect Squares (LeetCode #279)

```python
"""
PROBLEM: Given integer n, return least number of perfect square
numbers that sum to n.

Example:
n = 12 ‚Üí output 3 (12 = 4 + 4 + 4)
n = 13 ‚Üí output 2 (13 = 4 + 9)
"""

from collections import deque
import math

def numSquares(n):
    """
    BFS approach: find shortest path to n.
    
    Strategy:
    - Each perfect square is like an "edge"
    - BFS finds minimum steps to reach n
    - Level represents number of perfect squares used
    
    Time: O(n √ó ‚àön)
    Space: O(n)
    """
    # Generate perfect squares up to n
    squares = [i * i for i in range(1, int(math.sqrt(n)) + 1)]
    
    queue = deque([(n, 0)])  # (remaining, steps)
    visited = {n}
    
    while queue:
        remaining, steps = queue.popleft()
        
        # Try subtracting each perfect square
        for square in squares:
            next_remaining = remaining - square
            
            if next_remaining == 0:
                return steps + 1
            
            if next_remaining > 0 and next_remaining not in visited:
                visited.add(next_remaining)
                queue.append((next_remaining, steps + 1))
    
    return steps


# Dynamic Programming approach (for comparison)
def numSquares_DP(n):
    """
    DP approach: build up solution.
    
    Time: O(n √ó ‚àön)
    Space: O(n)
    """
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    
    squares = [i * i for i in range(1, int(math.sqrt(n)) + 1)]
    
    for i in range(1, n + 1):
        for square in squares:
            if i >= square:
                dp[i] = min(dp[i], dp[i - square] + 1)
    
    return dp[n]


# ============ TEST ============

print("\n" + "=" * 70)
print("PROBLEM 7: Perfect Squares")
print("=" * 70)

test_cases = [12, 13, 7, 1]

print("\nBFS Approach:")
for n in test_cases:
    result = numSquares(n)
    print(f"  n = {n:2d} ‚Üí {result} perfect squares")

print("\nDP Approach (verification):")
for n in test_cases:
    result = numSquares_DP(n)
    print(f"  n = {n:2d} ‚Üí {result} perfect squares")

print("\n‚úÖ Complexity:")
print("  Time: O(n √ó ‚àön) for both approaches")
print("  Space: O(n) for visited set/DP array")

print("\nüí° Key Insight:")
print("  BFS treats problem as graph shortest path")
print("  Each number is a node, perfect squares are edges")

print("\nüéØ Why BFS Works:")
print("  Level in BFS = number of perfect squares used")
print("  First time reaching 0 = minimum squares needed")
print("=" * 70)
```

---

## 8.3 Hard Level Problems

### Problem 1: Sliding Window Median (LeetCode #480) ‚≠ê‚≠ê

```python
"""
PROBLEM: Median is middle value in ordered list. If size is even,
no middle value exists, so median is mean of two middle values.

Given array nums and integer k, return median array where each
element is median of sliding window of size k.

Example:
nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [1,-1,-1,3,5,6]
"""

import heapq
from collections import defaultdict

class SlidingWindowMedian:
    """
    Two heaps approach with lazy deletion.
    
    Strategy:
    - Max heap (lower half) and min heap (upper half)
    - Maintain size balance
    - Use lazy deletion for removed elements
    
    Time: O(n log k) where n = array length, k = window size
    Space: O(k)
    """
    
    def __init__(self):
        self.max_heap = []  # Lower half (negated for max heap)
        self.min_heap = []  # Upper half
        self.delayed = defaultdict(int)  # Lazy deletion map
        self.max_heap_size = 0
        self.min_heap_size = 0
    
    def add(self, num):
        """Add number to heaps"""
        if not self.max_heap or num <= -self.max_heap[0]:
            heapq.heappush(self.max_heap, -num)
            self.max_heap_size += 1
        else:
            heapq.heappush(self.min_heap, num)
            self.min_heap_size += 1
        
        self.rebalance()
    
    def remove(self, num):
        """Lazy deletion: mark for removal"""
        self.delayed[num] += 1
        
        if num <= -self.max_heap[0]:
            self.max_heap_size -= 1
        else:
            self.min_heap_size -= 1
        
        self.rebalance()
    
    def rebalance(self):
        """Balance heap sizes"""
        # Move from max_heap to min_heap
        if self.max_heap_size > self.min_heap_size + 1:
            num = -heapq.heappop(self.max_heap)
            heapq.heappush(self.min_heap, num)
            self.max_heap_size -= 1
            self.min_heap_size += 1
        
        # Move from min_heap to max_heap
        elif self.min_heap_size > self.max_heap_size:
            num = heapq.heappop(self.min_heap)
            heapq.heappush(self.max_heap, -num)
            self.min_heap_size += 1
            self.max_heap_size -= 1
        
        # Clean tops
        self.prune(self.max_heap)
        self.prune(self.min_heap)
    
    def prune(self, heap):
        """Remove invalid tops"""
        while heap:
            if heap == self.max_heap:
                num = -heap[0]
            else:
                num = heap[0]
            
            if self.delayed[num] > 0:
                self.delayed[num] -= 1
                heapq.heappop(heap)
            else:
                break
    
    def get_median(self):
        """Get current median"""
        self.prune(self.max_heap)
        self.prune(self.min_heap)
        
        if self.max_heap_size == self.min_heap_size:
            return (-self.max_heap[0] + self.min_heap[0]) / 2
        return -self.max_heap[0]


def medianSlidingWindow(nums, k):
    """Find median in each sliding window"""
    result = []
    swm = SlidingWindowMedian()
    
    for i in range(len(nums)):
        swm.add(nums[i])
        
        if i >= k:
            swm.remove(nums[i - k])
        
        if i >= k - 1:
            result.append(swm.get_median())
    
    return result


# ============ TEST ============

print("\n" + "=" * 70)
print("PROBLEM 8: Sliding Window Median (HARD)")
print("=" * 70)

nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3

result = medianSlidingWindow(nums, k)
print(f"\nnums = {nums}")
print(f"k = {k}")
print(f"Medians = {result}")

print("\n‚úÖ Complexity:")
print("  Time: O(n log k) - heap operations for each element")
print("  Space: O(k) - heaps hold window elements")

print("\nüí° Key Insight:")
print("  Two heaps maintain balance: lower half (max heap) and upper half (min heap)")
print("  Lazy deletion avoids expensive removal from middle of heap")

print("\n‚ö†Ô∏è Challenges:")
print("  - Balancing heaps after additions/removals")
print("  - Efficient removal (lazy deletion)")
print("  - Handling even/odd window sizes")

print("\nüîÑ Related Concepts:")
print("  - Find Median from Data Stream")
print("  - Running median calculation")
print("=" * 70)
```

---

### Problem 2: Word Ladder II (LeetCode #126) ‚≠ê‚≠ê

```python
"""
PROBLEM: Given beginWord, endWord, and wordList, find ALL shortest
transformation sequences from beginWord to endWord.

Rules:
- Only one letter can be changed at a time
- Each transformed word must exist in wordList

Example:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log","cog"]

Output: [["hit","hot","dot","dog","cog"],
         ["hit","hot","lot","log","cog"]]
"""

from collections import deque, defaultdict

def findLadders(beginWord, endWord, wordList):
    """
    BFS to build graph + DFS to find all paths.
    
    Strategy:
    1. BFS to find shortest distance and build level graph
    2. DFS from beginWord to endWord following level graph
    
    Time: O(M¬≤ √ó N) where M = word length, N = word list size
    Space: O(M √ó N)
    """
    word_set = set(wordList)
    if endWord not in word_set:
        return []
    
    # Phase 1: BFS to build level graph
    neighbors = defaultdict(list)
    queue = deque([beginWord])
    visited = {beginWord: 0}
    found = False
    
    while queue and not found:
        size = len(queue)
        current_level = []
        
        for _ in range(size):
            word = queue.popleft()
            current_level.append(word)
            
            # Try all one-letter transformations
            for i in range(len(word)):
                for c in 'abcdefghijklmnopqrstuvwxyz':
                    next_word = word[:i] + c + word[i+1:]
                    
                    if next_word in word_set:
                        neighbors[word].append(next_word)
                        
                        if next_word == endWord:
                            found = True
                        
                        if next_word not in visited:
                            visited[next_word] = visited[word] + 1
                            queue.append(next_word)
    
    if not found:
        return []
    
    # Phase 2: DFS to construct all shortest paths
    result = []
    path = [beginWord]
    
    def dfs(word):
        if word == endWord:
            result.append(path[:])
            return
        
        for next_word in neighbors[word]:
            if visited[next_word] == visited[word] + 1:
                path.append(next_word)
                dfs(next_word)
                path.pop()
    
    dfs(beginWord)
    return result


# ============ TEST ============

print("\n" + "=" * 70)
print("PROBLEM 9: Word Ladder II (HARD)")
print("=" * 70)

beginWord = "hit"
endWord = "cog"
wordList = ["hot", "dot", "dog", "lot", "log", "cog"]

result = findLadders(beginWord, endWord, wordList)

print(f"\nbeginWord = '{beginWord}'")
print(f"endWord = '{endWord}'")
print(f"wordList = {wordList}")
print(f"\nAll shortest paths ({len(result)}):")
for i, path in enumerate(result, 1):
    print(f"  {i}. {' ‚Üí '.join(path)}")

print("\n‚úÖ Complexity:")
print("  Time: O(M¬≤ √ó N) for BFS + O(paths) for DFS")
print("  Space: O(M √ó N) for graph storage")

print("\nüí° Key Insight:")
print("  Separate concerns: BFS for shortest distance, DFS for path construction")
print("  Build level graph during BFS to guide DFS")

print("\nüéØ Why This Approach:")
print("  BFS alone gives ONE shortest path")
print("  We need ALL shortest paths ‚Üí BFS + DFS")
print("  Level graph ensures DFS only follows shortest paths")
print("=" * 70)
```

---

## Summary

```python
print("\n" + "=" * 70)
print("CHAPTER 8 SUMMARY")
print("=" * 70)

summary = """
üìä PROBLEMS COVERED BY DIFFICULTY:

EASY (Fundamentals):
‚úì Queue using Stacks - Amortized analysis
‚úì Recent Calls - Time window tracking
‚úì First Unique Character - Frequency + order

MEDIUM (Core Patterns):
‚úì Level Order Traversal - Standard BFS template
‚úì Rotting Oranges - Multi-source BFS
‚úì Sliding Window Maximum - Monotonic deque (CRITICAL!)
‚úì Perfect Squares - BFS as shortest path

HARD (Advanced Techniques):
‚úì Sliding Window Median - Two heaps + lazy deletion
‚úì Word Ladder II - BFS + DFS hybrid

üéØ KEY PATTERNS DEMONSTRATED:

1. AMORTIZED ANALYSIS:
   - Queue using stacks
   - Each element touched constant times total

2. MULTI-SOURCE BFS:
   - Rotting oranges
   - Start from all sources simultaneously

3. MONOTONIC DEQUE:
   - Sliding window maximum
   - THE most important optimization technique

4. TWO HEAPS:
   - Sliding window median
   - Maintain balance between lower/upper halves

5. BFS + DFS HYBRID:
   - Word ladder II
   - BFS for distance, DFS for paths

üí° INTERVIEW STRATEGY:

‚úì Start with brute force, explain limitations
‚úì Identify the pattern (BFS, sliding window, etc.)
‚úì Choose right data structure (queue type)
‚úì Explain time/space complexity
‚úì Code clearly with edge case handling
‚úì Test with examples

‚ö†Ô∏è COMMON MISTAKES TO AVOID:

‚ùå No visited set in graph BFS
‚ùå Not capturing queue size for levels
‚ùå Wrong monotonic order
‚ùå Values instead of indices in monotonic queue
‚ùå No empty check before dequeue
"""

print(summary)

print("\n" + "=" * 70)
print("CHAPTER 8 COMPLETE!")
print("Next: Chapter 9 - Tips and Tricks for Interviews")
print("=" * 70)
```

This chapter provides complete, interview-ready solutions with detailed explanations and complexity analysis!