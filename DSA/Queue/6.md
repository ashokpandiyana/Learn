# Chapter 6: Advanced Queue Patterns - In-Depth Explanation

## 6.1 Design Problems with Queue

### Problem 1: Moving Average from Data Stream

**Problem:** Calculate the average of the last K elements in a stream.

```python
from collections import deque

class MovingAverage:
    """
    Calculate moving average of last K elements.
    
    Approach: Queue + running sum
    Time: O(1) per operation
    Space: O(k)
    """
    
    def __init__(self, size):
        self.size = size
        self.queue = deque()
        self.window_sum = 0
        self.count = 0
    
    def next(self, val):
        """Add new value and return current average"""
        self.count += 1
        self.queue.append(val)
        self.window_sum += val
        
        # Remove oldest if window exceeds size
        if len(self.queue) > self.size:
            removed = self.queue.popleft()
            self.window_sum -= removed
        
        # Calculate average
        avg = self.window_sum / len(self.queue)
        
        print(f"Step {self.count}: Added {val}")
        print(f"  Window: {list(self.queue)}")
        print(f"  Sum: {self.window_sum}, Average: {avg:.2f}")
        
        return avg


# ============ DEMONSTRATION ============

print("=" * 60)
print("MOVING AVERAGE FROM DATA STREAM")
print("=" * 60)

ma = MovingAverage(3)

values = [1, 10, 3, 5]
print(f"\nProcessing stream: {values}")
print("Window size: 3")
print("=" * 60)

for val in values:
    result = ma.next(val)
    print(f"  ‚Üí Average: {result:.2f}\n")

print("=" * 60)
```

---

### Problem 2: Design Hit Counter

**Problem:** Count hits in the last 5 minutes (300 seconds).

```python
from collections import deque

class HitCounter:
    """
    Design a hit counter for the last 300 seconds.
    
    Approach: Queue with timestamps
    Time: O(1) amortized for hit(), O(1) for getHits()
    Space: O(n) where n = hits in 300 seconds
    """
    
    def __init__(self):
        self.hits = deque()  # Store timestamps
        self.window = 300
    
    def hit(self, timestamp):
        """Record a hit at given timestamp"""
        self.hits.append(timestamp)
        print(f"Hit recorded at timestamp {timestamp}")
    
    def getHits(self, timestamp):
        """
        Get number of hits in last 300 seconds.
        Remove old hits outside window.
        """
        # Remove hits older than (timestamp - 300)
        while self.hits and self.hits[0] <= timestamp - self.window:
            removed = self.hits.popleft()
            print(f"  Removed old hit from timestamp {removed}")
        
        count = len(self.hits)
        print(f"At timestamp {timestamp}: {count} hits in last 300 seconds")
        return count


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("DESIGN HIT COUNTER")
print("=" * 60)

counter = HitCounter()

# Simulate hits
print("\n--- Recording Hits ---")
counter.hit(1)
counter.hit(2)
counter.hit(3)

print("\n--- Query at timestamp 4 ---")
counter.getHits(4)

print("\n--- More hits ---")
counter.hit(300)
counter.hit(301)

print("\n--- Query at timestamp 300 ---")
counter.getHits(300)

print("\n--- Query at timestamp 301 (old hits expire) ---")
counter.getHits(301)

print("\n" + "=" * 60)
```

---

### Problem 3: Design Snake Game

**Problem:** Implement the Snake game logic.

```python
from collections import deque

class SnakeGame:
    """
    Design Snake Game.
    
    Snake represented as queue (head at rear, tail at front)
    Time: O(1) per move
    Space: O(snake length)
    """
    
    def __init__(self, width, height, food):
        self.width = width
        self.height = height
        self.food = deque(food)
        self.snake = deque([(0, 0)])  # Start at (0,0)
        self.snake_set = {(0, 0)}  # For O(1) collision detection
        self.score = 0
        self.directions = {
            'U': (-1, 0),
            'D': (1, 0),
            'L': (0, -1),
            'R': (0, 1)
        }
    
    def move(self, direction):
        """
        Move snake in given direction.
        Return score or -1 if game over.
        """
        # Calculate new head position
        head_row, head_col = self.snake[-1]
        dr, dc = self.directions[direction]
        new_head = (head_row + dr, head_col + dc)
        
        print(f"\nMove {direction}: New head at {new_head}")
        
        # Check boundaries
        if (new_head[0] < 0 or new_head[0] >= self.height or
            new_head[1] < 0 or new_head[1] >= self.width):
            print("  ‚ùå Hit boundary! Game Over")
            return -1
        
        # Check if eating food
        ate_food = False
        if self.food and list(new_head) == self.food[0]:
            self.food.popleft()
            self.score += 1
            ate_food = True
            print(f"  üçé Ate food! Score: {self.score}")
        
        # Add new head
        self.snake.append(new_head)
        self.snake_set.add(new_head)
        
        # Remove tail if didn't eat food
        if not ate_food:
            tail = self.snake.popleft()
            self.snake_set.remove(tail)
        
        # Check self-collision (after removing tail!)
        if len(self.snake_set) != len(self.snake):
            print("  ‚ùå Hit itself! Game Over")
            return -1
        
        print(f"  ‚úì Snake: {list(self.snake)}")
        print(f"  Score: {self.score}")
        return self.score


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("SNAKE GAME SIMULATION")
print("=" * 60)

# 3x3 grid, food at [(1,2), (0,1)]
game = SnakeGame(3, 3, [[1, 2], [0, 1]])

print("\nGrid: 3x3")
print("Starting position: (0,0)")
print("Food locations: [(1,2), (0,1)]")

moves = ['R', 'D', 'R', 'U', 'L', 'U']
print(f"\nExecuting moves: {moves}")
print("=" * 60)

for move in moves:
    score = game.move(move)
    if score == -1:
        break

print("\n" + "=" * 60)
```

---

## 6.2 0-1 BFS Pattern

### Understanding 0-1 BFS

**Concept:**
When graph has edges with weights 0 and 1 only, use deque instead of priority queue!

```
Regular BFS: All edges weight 1
0-1 BFS: Edges weight 0 or 1

Key Technique:
- Add to FRONT for 0-weight edges
- Add to REAR for 1-weight edges

This maintains sorted order in deque!
Time: O(V + E) vs Dijkstra's O(E log V)
```

### Implementation

```python
from collections import deque

def zero_one_bfs(graph, start, end, n):
    """
    Shortest path in 0-1 weighted graph.
    
    graph[u] = [(v, weight), ...] where weight is 0 or 1
    
    Time: O(V + E)
    Space: O(V)
    """
    dist = [float('inf')] * n
    dist[start] = 0
    
    dq = deque([start])
    
    print("0-1 BFS Shortest Path:")
    print("=" * 60)
    print(f"From {start} to {end}")
    
    while dq:
        u = dq.popleft()
        
        print(f"\nProcessing node {u} (distance={dist[u]})")
        
        for v, weight in graph[u]:
            new_dist = dist[u] + weight
            
            if new_dist < dist[v]:
                dist[v] = new_dist
                
                if weight == 0:
                    dq.appendleft(v)  # Add to front
                    print(f"  ‚Üí {v} (weight=0, dist={new_dist}) added to FRONT")
                else:
                    dq.append(v)  # Add to rear
                    print(f"  ‚Üí {v} (weight=1, dist={new_dist}) added to REAR")
                
                print(f"  Deque: {list(dq)}")
    
    return dist[end]


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("0-1 BFS ALGORITHM")
print("=" * 60)

# Create graph: node ‚Üí [(neighbor, weight), ...]
graph = {
    0: [(1, 0), (2, 1)],
    1: [(3, 1)],
    2: [(1, 0), (3, 1)],
    3: []
}

print("\nGraph edges:")
for u in graph:
    for v, w in graph[u]:
        print(f"  {u} ‚Üí {v} (weight={w})")

result = zero_one_bfs(graph, 0, 3, 4)

print("\n" + "=" * 60)
print(f"Shortest distance from 0 to 3: {result}")
print("=" * 60)
```

---

### Problem: Minimum Cost to Make at Least One Valid Path

```python
def min_cost_grid(grid):
    """
    Minimum cost to reach bottom-right from top-left.
    Can move in direction of arrow for free, change direction costs 1.
    
    grid[i][j] = 1 (right), 2 (left), 3 (down), 4 (up)
    
    This is a 0-1 BFS problem!
    Time: O(m √ó n)
    """
    m, n = len(grid), len(grid[0])
    
    # Direction mappings
    directions = {
        1: (0, 1),   # right
        2: (0, -1),  # left
        3: (1, 0),   # down
        4: (-1, 0)   # up
    }
    
    # All possible moves
    all_dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    cost = [[float('inf')] * n for _ in range(m)]
    cost[0][0] = 0
    
    dq = deque([(0, 0)])
    
    print("Minimum Cost Grid Navigation:")
    print("=" * 60)
    
    while dq:
        r, c = dq.popleft()
        
        # Try all 4 directions
        for dr, dc in all_dirs:
            nr, nc = r + dr, c + dc
            
            if 0 <= nr < m and 0 <= nc < n:
                # Cost is 0 if following arrow, 1 otherwise
                arrow_dir = directions[grid[r][c]]
                move_cost = 0 if (dr, dc) == arrow_dir else 1
                
                new_cost = cost[r][c] + move_cost
                
                if new_cost < cost[nr][nc]:
                    cost[nr][nc] = new_cost
                    
                    if move_cost == 0:
                        dq.appendleft((nr, nc))
                    else:
                        dq.append((nr, nc))
    
    result = cost[m-1][n-1]
    print(f"\nMinimum cost to reach ({m-1},{n-1}): {result}")
    return result


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("MINIMUM COST GRID (0-1 BFS APPLICATION)")
print("=" * 60)

grid = [
    [1, 1, 1, 1],
    [2, 2, 2, 2],
    [1, 1, 1, 1],
    [2, 2, 2, 2]
]

print("Grid (1=right, 2=left, 3=down, 4=up):")
for row in grid:
    print(" ", row)

result = min_cost_grid(grid)
print("=" * 60)
```

---

## 6.3 Bidirectional BFS

### Understanding Bidirectional BFS

**Concept:**
Search from both start and end simultaneously!

```
Regular BFS:    Start ‚Üí ‚Üí ‚Üí ‚Üí ‚Üí ‚Üí ‚Üí End
Time: O(b^d) where b=branching factor, d=depth

Bidirectional:  Start ‚Üí ‚Üí ‚Üí ‚Üê ‚Üê ‚Üê End
                        meet
Time: O(b^(d/2)) - Much faster!

When to use:
- Know both start and end
- Problem is finding shortest path
- Forward and backward search are similar
```

### Implementation

```python
from collections import deque

def bidirectional_bfs(graph, start, end):
    """
    Bidirectional BFS to find shortest path.
    
    Search from both ends until they meet.
    Time: O(b^(d/2)) vs O(b^d) for regular BFS
    """
    if start == end:
        return 0
    
    # Forward BFS from start
    visited_start = {start: 0}
    queue_start = deque([start])
    
    # Backward BFS from end
    visited_end = {end: 0}
    queue_end = deque([end])
    
    print("Bidirectional BFS:")
    print("=" * 60)
    
    level = 0
    
    while queue_start and queue_end:
        level += 1
        
        # Expand smaller frontier (optimization)
        if len(queue_start) <= len(queue_end):
            print(f"\nüîµ Level {level}: Expanding from START")
            if expand_level(queue_start, visited_start, visited_end, graph):
                print("‚úì Paths met!")
                return level
        else:
            print(f"\nüî¥ Level {level}: Expanding from END")
            if expand_level(queue_end, visited_end, visited_start, graph):
                print("‚úì Paths met!")
                return level
    
    print("No path found!")
    return -1


def expand_level(queue, visited, visited_other, graph):
    """Expand one level and check for intersection"""
    size = len(queue)
    
    for _ in range(size):
        node = queue.popleft()
        print(f"  Visiting: {node}")
        
        for neighbor in graph.get(node, []):
            if neighbor in visited_other:
                print(f"  ‚ö° Found intersection at {neighbor}!")
                return True
            
            if neighbor not in visited:
                visited[neighbor] = visited[node] + 1
                queue.append(neighbor)
                print(f"    Added neighbor: {neighbor}")
    
    return False


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("BIDIRECTIONAL BFS")
print("=" * 60)

# Create graph
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F', 'G'],
    'F': ['C', 'E'],
    'G': ['E']
}

print("\nGraph:")
for node, neighbors in graph.items():
    print(f"  {node} ‚Üí {neighbors}")

result = bidirectional_bfs(graph, 'A', 'G')

print("\n" + "=" * 60)
print(f"Shortest path length: {result}")
print("=" * 60)
```

---

## 6.4 Multi-Dimensional BFS

### Problem: Word Ladder II (Finding All Shortest Paths)

```python
from collections import deque, defaultdict

def find_ladders(begin_word, end_word, word_list):
    """
    Find ALL shortest transformation sequences.
    
    Approach: BFS to build level map + DFS to construct paths
    Time: O(M¬≤ √ó N) where M=word length, N=word list size
    """
    word_set = set(word_list)
    if end_word not in word_set:
        return []
    
    # BFS to find shortest path length and build graph
    neighbors = defaultdict(list)
    queue = deque([begin_word])
    visited = {begin_word: 0}
    found = False
    
    print("Phase 1: BFS to build level graph")
    print("=" * 60)
    
    while queue and not found:
        size = len(queue)
        current_level = []
        
        for _ in range(size):
            word = queue.popleft()
            current_level.append(word)
            
            # Try all transformations
            for i in range(len(word)):
                for c in 'abcdefghijklmnopqrstuvwxyz':
                    next_word = word[:i] + c + word[i+1:]
                    
                    if next_word in word_set:
                        neighbors[word].append(next_word)
                        
                        if next_word == end_word:
                            found = True
                        
                        if next_word not in visited:
                            visited[next_word] = visited[word] + 1
                            queue.append(next_word)
        
        print(f"Level {len(visited)}: {current_level}")
    
    if not found:
        return []
    
    # DFS to find all paths
    print("\nPhase 2: DFS to construct all shortest paths")
    print("=" * 60)
    
    result = []
    path = [begin_word]
    
    def dfs(word):
        if word == end_word:
            result.append(path[:])
            print(f"Found path: {' ‚Üí '.join(path)}")
            return
        
        for next_word in neighbors[word]:
            if visited[next_word] == visited[word] + 1:
                path.append(next_word)
                dfs(next_word)
                path.pop()
    
    dfs(begin_word)
    return result


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("WORD LADDER II - ALL SHORTEST PATHS")
print("=" * 60)

begin = "hit"
end = "cog"
word_list = ["hot", "dot", "dog", "lot", "log", "cog"]

print(f"Start: '{begin}'")
print(f"End: '{end}'")
print(f"Word List: {word_list}")

result = find_ladders(begin, end, word_list)

print("\n" + "=" * 60)
print(f"Found {len(result)} shortest path(s)")
print("=" * 60)
```

---

## Summary & Advanced Patterns

```python
print("\n" + "=" * 60)
print("CHAPTER 6: ADVANCED PATTERNS SUMMARY")
print("=" * 60)

summary = """
üéØ DESIGN PATTERNS:

1Ô∏è‚É£ MOVING AVERAGE:
   - Queue + running sum
   - O(1) per operation
   - Classic sliding window application

2Ô∏è‚É£ HIT COUNTER:
   - Queue with timestamps
   - Remove expired entries lazily
   - O(1) amortized

3Ô∏è‚É£ SNAKE GAME:
   - Queue for snake body
   - Set for O(1) collision detection
   - Head at rear, tail at front

üìä ADVANCED BFS TECHNIQUES:

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë      Technique         ‚ïë      Time     ‚ïë     When to Use    ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë Standard BFS           ‚ïë   O(V + E)    ‚ïë Unweighted graph   ‚ïë
‚ïë 0-1 BFS               ‚ïë   O(V + E)    ‚ïë Edge weights 0/1   ‚ïë
‚ïë Bidirectional BFS      ‚ïë O(b^(d/2))    ‚ïë Know start & end   ‚ïë
‚ïë Multi-source BFS       ‚ïë   O(V + E)    ‚ïë Multiple starts    ‚ïë
‚ïë BFS + DFS hybrid       ‚ïë   Varies      ‚ïë All shortest paths ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üí° KEY INSIGHTS:

‚úì 0-1 BFS TRICK:
  - Add to FRONT for 0-weight edges
  - Add to REAR for 1-weight edges
  - Maintains sorted order in deque!

‚úì BIDIRECTIONAL BFS:
  - Exponential speedup: O(b^(d/2)) vs O(b^d)
  - Always expand smaller frontier
  - Check for intersection after each level

‚úì DESIGN PROBLEMS:
  - Queue naturally models real-world systems
  - Combine queue with other data structures
  - Consider lazy deletion for efficiency

‚úì MULTI-DIMENSIONAL PROBLEMS:
  - BFS to find shortest distance
  - DFS to enumerate all paths
  - Build graph of valid transitions

üîë PROBLEM RECOGNITION:

"Design system with FIFO" ‚Üí Queue-based design
"Graph with 0/1 weights" ‚Üí 0-1 BFS
"Find shortest path, know both ends" ‚Üí Bidirectional BFS
"Find ALL shortest paths" ‚Üí BFS + DFS
"Multiple starting points spreading" ‚Üí Multi-source BFS

‚ö†Ô∏è COMMON MISTAKES:

‚úó Not using visited set in bidirectional BFS
‚úó Wrong order in 0-1 BFS (front vs rear)
‚úó Forgetting to check intersection in bidirectional
‚úó Not handling edge cases in design problems
‚úó Inefficient data structure choices
"""

print(summary)

print("\n" + "=" * 60)
print("üéâ ALL 6 CHAPTERS COMPLETE! üéâ")
print("=" * 60)

final_notes = """
üìö COMPLETE LEARNING PATH COVERED:

Chapter 1: Queue Fundamentals
  ‚úì Basic operations and implementations
  ‚úì Array, circular, linked list approaches

Chapter 2: Queue Variants  
  ‚úì Circular queue, deque, priority queue
  ‚úì Monotonic queue

Chapter 3: Standard Patterns
  ‚úì Queue using stacks, stack using queues
  ‚úì Reversal patterns, generation patterns

Chapter 4: BFS & Level-Order Traversal
  ‚úì Tree BFS, graph BFS
  ‚úì Shortest path, multi-source BFS

Chapter 5: Sliding Window
  ‚úì Monotonic deque for max/min
  ‚úì Window problems, median finding

Chapter 6: Advanced Patterns
  ‚úì Design problems
  ‚úì 0-1 BFS, bidirectional BFS

üéØ NEXT STEPS:

1. Practice problems from each chapter
2. Focus on pattern recognition
3. Time yourself on mock interviews
4. Review complexity analysis
5. Understand when to use which technique

üí™ YOU'RE NOW READY FOR:
- FAANG-level queue interviews
- Complex BFS problems
- Design questions
- Hard LeetCode problems

Good luck with your interviews! üöÄ
"""

print(final_notes)
```

---

## Complete Practice Problem List

### Easy (Warm-up):
1. Implement Queue using Arrays
2. Implement Queue using Stacks
3. First Unique Character in String

### Medium (Core):
4. Binary Tree Level Order Traversal - #102 ‚≠ê
5. Rotting Oranges - #994 ‚≠ê
6. Word Ladder - #127 ‚≠ê
7. Sliding Window Maximum - #239 ‚≠ê‚≠ê
8. Design Hit Counter - #362
9. Moving Average - #346
10. Number of Islands - #200
11. Course Schedule - #207
12. Open the Lock - #752
13. Perfect Squares - #279
14. Walls and Gates - #286
15. 01 Matrix - #542

### Hard (Mastery):
16. Word Ladder II - #126 ‚≠ê‚≠ê
17. Sliding Window Median - #480 ‚≠ê‚≠ê
18. Shortest Path Visiting All Nodes - #847
19. Minimum Cost Path in Grid - #1263
20. Bus Routes - #815
21. Trapping Rain Water II - #407
22. Cut Off Trees for Golf Event - #675

**Congratulations on completing the comprehensive Queue DSA guide!** üéä