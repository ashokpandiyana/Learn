# Chapter 4: Expression Evaluation

## 4.1 Understanding Expression Notations

Before diving into evaluation, we must understand three ways to write expressions:

### The Three Notations

```
┌────────────────────────────────────────────────────────────────────┐
│                    EXPRESSION NOTATIONS                            │
├──────────────┬─────────────────┬───────────────────────────────────┤
│ Notation     │ Example         │ Operator Position                 │
├──────────────┼─────────────────┼───────────────────────────────────┤
│ INFIX        │ A + B           │ BETWEEN operands (human readable) │
│ PREFIX       │ + A B           │ BEFORE operands (Polish)          │
│ POSTFIX      │ A B +           │ AFTER operands (Reverse Polish)   │
└──────────────┴─────────────────┴───────────────────────────────────┘
```

### Why Different Notations?

```
INFIX: (Human Friendly)
─────────────────────────────────────────────────────────
Expression: 3 + 4 * 2

Problem: Need precedence rules!
- Is it (3 + 4) * 2 = 14?
- Or 3 + (4 * 2) = 11?

We need BODMAS/PEMDAS rules + parentheses handling.
Computers find this HARD to parse!


POSTFIX: (Computer Friendly)
─────────────────────────────────────────────────────────
Expression: 3 4 2 * +

Evaluation (left to right, use stack):
- See 3: push → [3]
- See 4: push → [3, 4]
- See 2: push → [3, 4, 2]
- See *: pop 2,4, compute 4*2=8, push → [3, 8]
- See +: pop 8,3, compute 3+8=11, push → [11]

Result: 11 ✓

NO PRECEDENCE RULES NEEDED! The order is built into notation.
```

### Conversion Examples

```
INFIX → POSTFIX Examples:
─────────────────────────────────────────────────────────
Infix               Postfix             Explanation
─────────────────────────────────────────────────────────
A + B               A B +               Simple
A + B * C           A B C * +           * before + (precedence)
(A + B) * C         A B + C *           Parentheses override
A + B * C - D       A B C * + D -       Left to right for same precedence
A * (B + C * D)     A B C D * + *       Nested precedence
((A + B) * C) - D   A B + C * D -       Multiple parentheses
─────────────────────────────────────────────────────────

INFIX → PREFIX Examples:
─────────────────────────────────────────────────────────
Infix               Prefix
─────────────────────────────────────────────────────────
A + B               + A B
A + B * C           + A * B C
(A + B) * C         * + A B C
─────────────────────────────────────────────────────────
```

---

## 4.2 Operator Precedence and Associativity

### Precedence Table

```
OPERATOR PRECEDENCE (Higher number = Higher precedence):
═══════════════════════════════════════════════════════════════
Priority │ Operators     │ Associativity │ Example
═══════════════════════════════════════════════════════════════
   4     │ ( )           │ -             │ Parentheses first
   3     │ ^             │ Right→Left    │ 2^3^2 = 2^(3^2) = 512
   2     │ * / %         │ Left→Right    │ 6/2*3 = (6/2)*3 = 9
   1     │ + -           │ Left→Right    │ 5-2+1 = (5-2)+1 = 4
   0     │ (             │ -             │ Lowest when in stack
═══════════════════════════════════════════════════════════════

ASSOCIATIVITY MATTERS:
─────────────────────────────────────────────────────────
Left-to-Right: 8 - 3 - 2 = (8 - 3) - 2 = 3
               NOT 8 - (3 - 2) = 7

Right-to-Left: 2 ^ 3 ^ 2 = 2 ^ (3 ^ 2) = 2 ^ 9 = 512
               NOT (2 ^ 3) ^ 2 = 64
```

### Precedence Helper Function

```python
def get_precedence(op):
    """
    Return precedence level of operator
    Higher number = higher precedence
    """
    precedence = {
        '+': 1,
        '-': 1,
        '*': 2,
        '/': 2,
        '%': 2,
        '^': 3
    }
    return precedence.get(op, 0)


def is_right_associative(op):
    """
    Check if operator is right-associative
    Only ^ (exponent) is right-associative among common operators
    """
    return op == '^'


def should_pop_operator(stack_top, current_op):
    """
    Determine if we should pop stack_top before pushing current_op
    
    Pop if:
    - stack_top has HIGHER precedence, OR
    - stack_top has EQUAL precedence AND current_op is LEFT-associative
    """
    if stack_top == '(':
        return False
    
    top_prec = get_precedence(stack_top)
    curr_prec = get_precedence(current_op)
    
    if top_prec > curr_prec:
        return True
    if top_prec == curr_prec and not is_right_associative(current_op):
        return True
    
    return False
```

---

## 4.3 Infix to Postfix Conversion (Shunting Yard Algorithm)

### The Algorithm Visualized

```
SHUNTING YARD ALGORITHM:
═══════════════════════════════════════════════════════════════

Input: Infix expression (tokens from left to right)
Output: Postfix expression
Data Structures: Operator Stack, Output Queue

RULES:
┌─────────────────┬────────────────────────────────────────────┐
│ Token Type      │ Action                                     │
├─────────────────┼────────────────────────────────────────────┤
│ Number/Operand  │ Add directly to output                     │
├─────────────────┼────────────────────────────────────────────┤
│ Operator        │ While stack top has higher/equal precedence│
│                 │   Pop to output                            │
│                 │ Then push current operator                 │
├─────────────────┼────────────────────────────────────────────┤
│ Left Paren (    │ Push to stack                              │
├─────────────────┼────────────────────────────────────────────┤
│ Right Paren )   │ Pop to output until ( found                │
│                 │ Discard the ( and )                        │
├─────────────────┼────────────────────────────────────────────┤
│ End of Input    │ Pop all remaining operators to output      │
└─────────────────┴────────────────────────────────────────────┘
```

### Step-by-Step Example

```
Convert: 3 + 4 * 2 / ( 1 - 5 ) ^ 2

═══════════════════════════════════════════════════════════════════════
Token│ Action                          │ Stack      │ Output
═══════════════════════════════════════════════════════════════════════
  3  │ Operand → output                │ []         │ 3
  +  │ Stack empty, push               │ [+]        │ 3
  4  │ Operand → output                │ [+]        │ 3 4
  *  │ * > +, push                     │ [+,*]      │ 3 4
  2  │ Operand → output                │ [+,*]      │ 3 4 2
  /  │ / = *, pop * to output          │ [+]        │ 3 4 2 *
     │ / > +, push                     │ [+,/]      │ 3 4 2 *
  (  │ Push (                          │ [+,/,(]    │ 3 4 2 *
  1  │ Operand → output                │ [+,/,(]    │ 3 4 2 * 1
  -  │ ( blocks popping, push         │ [+,/,(,-]  │ 3 4 2 * 1
  5  │ Operand → output                │ [+,/,(,-]  │ 3 4 2 * 1 5
  )  │ Pop until (, discard both       │ [+,/]      │ 3 4 2 * 1 5 -
  ^  │ ^ > /, push                     │ [+,/,^]    │ 3 4 2 * 1 5 -
  2  │ Operand → output                │ [+,/,^]    │ 3 4 2 * 1 5 - 2
 END │ Pop all                         │ []         │ 3 4 2 * 1 5 - 2 ^ / +
═══════════════════════════════════════════════════════════════════════

Result: 3 4 2 * 1 5 - 2 ^ / +
```

### Implementation

```python
def infix_to_postfix(expression):
    """
    Convert infix expression to postfix using Shunting Yard Algorithm
    
    Time: O(n), Space: O(n)
    
    Args:
        expression: String like "3 + 4 * 2" (space-separated)
    
    Returns:
        Postfix expression as list of tokens
    """
    def is_operator(token):
        return token in {'+', '-', '*', '/', '^', '%'}
    
    def precedence(op):
        return {'+': 1, '-': 1, '*': 2, '/': 2, '%': 2, '^': 3}.get(op, 0)
    
    def is_right_assoc(op):
        return op == '^'
    
    tokens = expression.split()
    output = []      # Output queue (postfix result)
    op_stack = []    # Operator stack
    
    for token in tokens:
        if token.lstrip('-').isdigit():  # Handle negative numbers
            # Operand: add to output
            output.append(token)
        
        elif token == '(':
            # Left parenthesis: push to stack
            op_stack.append(token)
        
        elif token == ')':
            # Right parenthesis: pop until '('
            while op_stack and op_stack[-1] != '(':
                output.append(op_stack.pop())
            
            if op_stack:
                op_stack.pop()  # Remove '('
            else:
                raise ValueError("Mismatched parentheses")
        
        elif is_operator(token):
            # Operator: pop higher/equal precedence, then push
            while (op_stack and 
                   op_stack[-1] != '(' and
                   (precedence(op_stack[-1]) > precedence(token) or
                    (precedence(op_stack[-1]) == precedence(token) and 
                     not is_right_assoc(token)))):
                output.append(op_stack.pop())
            
            op_stack.append(token)
    
    # Pop remaining operators
    while op_stack:
        op = op_stack.pop()
        if op == '(':
            raise ValueError("Mismatched parentheses")
        output.append(op)
    
    return output


# Test
expr = "3 + 4 * 2 / ( 1 - 5 ) ^ 2"
print(infix_to_postfix(expr))
# Output: ['3', '4', '2', '*', '1', '5', '-', '2', '^', '/', '+']
```

---

## 4.4 Evaluating Postfix Expression

### The Algorithm

```
POSTFIX EVALUATION:
═══════════════════════════════════════════════════════════════

Simple and elegant - just use ONE stack!

For each token (left to right):
┌─────────────────┬────────────────────────────────────────────┐
│ Token Type      │ Action                                     │
├─────────────────┼────────────────────────────────────────────┤
│ Number          │ Push to stack                              │
├─────────────────┼────────────────────────────────────────────┤
│ Operator        │ Pop two operands                           │
│                 │ Apply operator (second_popped OP first)    │
│                 │ Push result                                │
└─────────────────┴────────────────────────────────────────────┘

At end: Stack has exactly one element = answer
```

### Visual Example

```
Evaluate: 3 4 2 * 1 5 - 2 ^ / +

═══════════════════════════════════════════════════════════════════════
Token│ Action                          │ Stack          │ Calculation
═══════════════════════════════════════════════════════════════════════
  3  │ Push                            │ [3]            │
  4  │ Push                            │ [3,4]          │
  2  │ Push                            │ [3,4,2]        │
  *  │ Pop 2,4 → 4*2=8 → Push          │ [3,8]          │ 4 * 2 = 8
  1  │ Push                            │ [3,8,1]        │
  5  │ Push                            │ [3,8,1,5]      │
  -  │ Pop 5,1 → 1-5=-4 → Push         │ [3,8,-4]       │ 1 - 5 = -4
  2  │ Push                            │ [3,8,-4,2]     │
  ^  │ Pop 2,-4 → (-4)^2=16 → Push     │ [3,8,16]       │ (-4)^2 = 16
  /  │ Pop 16,8 → 8/16=0.5 → Push      │ [3,0.5]        │ 8 / 16 = 0.5
  +  │ Pop 0.5,3 → 3+0.5=3.5 → Push    │ [3.5]          │ 3 + 0.5 = 3.5
═══════════════════════════════════════════════════════════════════════

Result: 3.5
```

### Implementation

```python
def evaluate_postfix(postfix):
    """
    Evaluate postfix expression
    
    Time: O(n), Space: O(n)
    
    Args:
        postfix: List of tokens in postfix order
    
    Returns:
        Numeric result
    """
    stack = []
    
    operators = {
        '+': lambda a, b: a + b,
        '-': lambda a, b: a - b,
        '*': lambda a, b: a * b,
        '/': lambda a, b: a / b,  # Use // for integer division
        '^': lambda a, b: a ** b,
        '%': lambda a, b: a % b,
    }
    
    for token in postfix:
        if token in operators:
            # Pop two operands (note the order!)
            b = stack.pop()  # Second operand (top of stack)
            a = stack.pop()  # First operand
            
            # Apply operator and push result
            result = operators[token](a, b)
            stack.append(result)
        else:
            # It's a number, push to stack
            stack.append(float(token))
    
    # Final result is the only element left
    return stack[0]


# Test
postfix = ['3', '4', '2', '*', '1', '5', '-', '2', '^', '/', '+']
print(evaluate_postfix(postfix))  # 3.5


# LeetCode 150: Evaluate Reverse Polish Notation
def evalRPN(tokens):
    """
    LeetCode version - integer division truncates toward zero
    """
    stack = []
    
    for token in tokens:
        if token in {'+', '-', '*', '/'}:
            b, a = stack.pop(), stack.pop()
            
            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            else:  # Division truncates toward zero
                stack.append(int(a / b))
        else:
            stack.append(int(token))
    
    return stack[0]
```

---

## 4.5 Basic Calculator I (LeetCode 224) ⭐⭐

**Problem**: Evaluate expression with `+`, `-`, `(`, `)` and spaces.

```
"1 + 1" → 2
" 2-1 + 2 " → 3
"(1+(4+5+2)-3)+(6+8)" → 23
```

### Key Insight

```
HANDLING PARENTHESES:
═══════════════════════════════════════════════════════════════

When we see '(':
→ SAVE current result and sign
→ START FRESH (result = 0)

When we see ')':
→ APPLY saved sign to current result
→ ADD to saved result
→ RESTORE context

This is exactly what a STACK is for - saving/restoring state!


HANDLING MINUS:
═══════════════════════════════════════════════════════════════

Key trick: Treat expression as sum of signed numbers

"1 - 2 + 3" becomes: (+1) + (-2) + (+3)

Use 'sign' variable: +1 or -1
When we see '+': sign = +1
When we see '-': sign = -1
When we see number: result += sign * number
```

### Visual Walkthrough

```
Evaluate: "(1+(4+5+2)-3)+(6+8)"

═══════════════════════════════════════════════════════════════════════════
Char │ Action                           │ Stack        │ result │ sign
═══════════════════════════════════════════════════════════════════════════
 (   │ Save (result=0, sign=+1), reset  │ [(0,1)]      │ 0      │ +1
 1   │ result += 1 * 1                  │ [(0,1)]      │ 1      │ +1
 +   │ sign = +1                        │ [(0,1)]      │ 1      │ +1
 (   │ Save (result=1, sign=+1), reset  │ [(0,1),(1,1)]│ 0      │ +1
 4   │ result += 1 * 4                  │ [(0,1),(1,1)]│ 4      │ +1
 +   │ sign = +1                        │ [(0,1),(1,1)]│ 4      │ +1
 5   │ result += 1 * 5                  │ [(0,1),(1,1)]│ 9      │ +1
 +   │ sign = +1                        │ [(0,1),(1,1)]│ 9      │ +1
 2   │ result += 1 * 2                  │ [(0,1),(1,1)]│ 11     │ +1
 )   │ Pop (1,1): result = 1 + 1*11=12  │ [(0,1)]      │ 12     │ +1
 -   │ sign = -1                        │ [(0,1)]      │ 12     │ -1
 3   │ result += -1 * 3                 │ [(0,1)]      │ 9      │ -1
 )   │ Pop (0,1): result = 0 + 1*9=9    │ []           │ 9      │ +1
 +   │ sign = +1                        │ []           │ 9      │ +1
 (   │ Save (result=9, sign=+1), reset  │ [(9,1)]      │ 0      │ +1
 6   │ result += 1 * 6                  │ [(9,1)]      │ 6      │ +1
 +   │ sign = +1                        │ [(9,1)]      │ 6      │ +1
 8   │ result += 1 * 8                  │ [(9,1)]      │ 14     │ +1
 )   │ Pop (9,1): result = 9 + 1*14=23  │ []           │ 23     │ +1
═══════════════════════════════════════════════════════════════════════════

Result: 23
```

### Implementation

```python
def calculate_basic(s: str) -> int:
    """
    Basic Calculator I: +, -, (, )
    
    Algorithm:
    1. Use stack to save context before '('
    2. Track current result and sign
    3. Process digit by digit
    
    Time: O(n), Space: O(n)
    """
    stack = []
    result = 0
    sign = 1  # +1 or -1
    num = 0
    
    for char in s:
        if char.isdigit():
            # Build multi-digit number
            num = num * 10 + int(char)
        
        elif char == '+':
            # Add current number with sign, reset
            result += sign * num
            num = 0
            sign = 1
        
        elif char == '-':
            # Add current number with sign, reset
            result += sign * num
            num = 0
            sign = -1
        
        elif char == '(':
            # Save current context (result and sign)
            stack.append(result)
            stack.append(sign)
            # Reset for sub-expression
            result = 0
            sign = 1
        
        elif char == ')':
            # Finalize sub-expression
            result += sign * num
            num = 0
            # Restore context
            result *= stack.pop()  # Sign before '('
            result += stack.pop()  # Result before '('
    
    # Don't forget the last number!
    result += sign * num
    
    return result


# Test
print(calculate_basic("(1+(4+5+2)-3)+(6+8)"))  # 23
print(calculate_basic("1 - (2 + 3)"))          # -4
```

---

## 4.6 Basic Calculator II (LeetCode 227) ⭐⭐

**Problem**: Evaluate expression with `+`, `-`, `*`, `/` (no parentheses).

```
"3+2*2" → 7
" 3/2 " → 1
" 3+5 / 2 " → 5
```

### Key Insight

```
HANDLING PRECEDENCE WITHOUT PARENTHESES:
═══════════════════════════════════════════════════════════════

Since * and / have higher precedence, we process them IMMEDIATELY.
For + and -, we DELAY until we see the next operator.

TRICK: Use stack to store intermediate results

When we see operator:
- If previous operator was + or -: push number to stack (delayed)
- If previous operator was * or /: compute immediately with stack top

At end: Sum all numbers in stack
```

### Visual Example

```
Evaluate: "3 + 2 * 2 - 4 / 2"

═══════════════════════════════════════════════════════════════════════
Char│ num │ prev_op │ Action                    │ Stack
═══════════════════════════════════════════════════════════════════════
 3  │  3  │  +      │ (building number)         │ []
 +  │  3  │  +      │ prev='+': push +3         │ [3]
    │  0  │  +      │ Update prev_op to '+'     │ [3]
 2  │  2  │  +      │ (building number)         │ [3]
 *  │  2  │  +      │ prev='+': push +2         │ [3, 2]
    │  0  │  *      │ Update prev_op to '*'     │ [3, 2]
 2  │  2  │  *      │ (building number)         │ [3, 2]
 -  │  2  │  *      │ prev='*': pop, compute    │ [3]
    │     │         │ 2*2=4, push               │ [3, 4]
    │  0  │  -      │ Update prev_op to '-'     │ [3, 4]
 4  │  4  │  -      │ (building number)         │ [3, 4]
 /  │  4  │  -      │ prev='-': push -4         │ [3, 4, -4]
    │  0  │  /      │ Update prev_op to '/'     │ [3, 4, -4]
 2  │  2  │  /      │ (building number)         │ [3, 4, -4]
END │  2  │  /      │ prev='/': pop, compute    │ [3, 4]
    │     │         │ -4/2=-2, push             │ [3, 4, -2]
═══════════════════════════════════════════════════════════════════════

Final: sum([3, 4, -2]) = 5
```

### Implementation

```python
def calculate_ii(s: str) -> int:
    """
    Basic Calculator II: +, -, *, / (no parentheses)
    
    Algorithm:
    1. For +/-: push number (with sign for -) to stack
    2. For *//: compute immediately with stack top
    3. Sum stack at end
    
    Time: O(n), Space: O(n)
    """
    stack = []
    num = 0
    prev_op = '+'  # Start with '+' (first number is positive)
    
    # Add dummy '+' at end to process last number
    s = s + '+'
    
    for char in s:
        if char.isdigit():
            num = num * 10 + int(char)
        
        elif char in '+-*/':
            # Process previous operator with current number
            if prev_op == '+':
                stack.append(num)
            elif prev_op == '-':
                stack.append(-num)
            elif prev_op == '*':
                stack.append(stack.pop() * num)
            elif prev_op == '/':
                # Integer division truncating toward zero
                top = stack.pop()
                stack.append(int(top / num))
            
            # Reset for next number
            num = 0
            prev_op = char
        
        # Ignore spaces
    
    return sum(stack)


# Test
print(calculate_ii("3+2*2"))      # 7
print(calculate_ii(" 3/2 "))      # 1
print(calculate_ii("3+5 / 2"))    # 5
print(calculate_ii("14-3/2"))     # 13
```

---

## 4.7 Basic Calculator III (LeetCode 772) ⭐⭐⭐

**Problem**: Full expression with `+`, `-`, `*`, `/`, `(`, `)`.

```
"1 + 1" → 2
"6-4 / 2" → 4
"2*(5+5*2)/3+(6/2+8)" → 21
```

### Approach 1: Recursive Descent

```python
def calculate_iii_recursive(s: str) -> int:
    """
    Basic Calculator III using recursive descent
    
    Idea: Treat '(' as start of sub-expression
    Recursively evaluate, return result and position
    
    Time: O(n), Space: O(n) call stack
    """
    def helper(s, idx):
        """
        Evaluate expression starting at idx
        Returns (result, next_index)
        """
        stack = []
        num = 0
        prev_op = '+'
        
        while idx < len(s):
            char = s[idx]
            
            if char.isdigit():
                num = num * 10 + int(char)
            
            elif char == '(':
                # Recursively evaluate sub-expression
                num, idx = helper(s, idx + 1)
            
            elif char == ')':
                # End of sub-expression
                # Process last number and return
                break
            
            elif char in '+-*/':
                # Process previous operator
                if prev_op == '+':
                    stack.append(num)
                elif prev_op == '-':
                    stack.append(-num)
                elif prev_op == '*':
                    stack.append(stack.pop() * num)
                elif prev_op == '/':
                    stack.append(int(stack.pop() / num))
                
                num = 0
                prev_op = char
            
            idx += 1
        
        # Process final number
        if prev_op == '+':
            stack.append(num)
        elif prev_op == '-':
            stack.append(-num)
        elif prev_op == '*':
            stack.append(stack.pop() * num)
        elif prev_op == '/':
            stack.append(int(stack.pop() / num))
        
        return sum(stack), idx
    
    result, _ = helper(s, 0)
    return result


# Test
print(calculate_iii_recursive("2*(5+5*2)/3+(6/2+8)"))  # 21
```

### Approach 2: Two Stacks (Iterative)

```python
def calculate_iii_iterative(s: str) -> int:
    """
    Basic Calculator III using two stacks
    
    - num_stack: operands
    - op_stack: operators
    
    Process based on precedence when pushing operators
    """
    def precedence(op):
        if op in '+-':
            return 1
        if op in '*/':
            return 2
        return 0
    
    def apply_op(num_stack, op):
        """Apply operator to top two numbers"""
        b = num_stack.pop()
        a = num_stack.pop()
        
        if op == '+':
            num_stack.append(a + b)
        elif op == '-':
            num_stack.append(a - b)
        elif op == '*':
            num_stack.append(a * b)
        elif op == '/':
            num_stack.append(int(a / b))
    
    num_stack = []
    op_stack = []
    num = 0
    i = 0
    
    # Handle leading negative: "-2+3" → "0-2+3"
    if s and s[0] == '-':
        num_stack.append(0)
    
    while i < len(s):
        char = s[i]
        
        if char.isdigit():
            # Build number
            num = 0
            while i < len(s) and s[i].isdigit():
                num = num * 10 + int(s[i])
                i += 1
            num_stack.append(num)
            continue  # Don't increment i again
        
        elif char == '(':
            op_stack.append(char)
            # Handle negative after '(': "(-2)" → "(0-2)"
            if i + 1 < len(s) and s[i + 1] == '-':
                num_stack.append(0)
        
        elif char == ')':
            # Process all operators until '('
            while op_stack and op_stack[-1] != '(':
                apply_op(num_stack, op_stack.pop())
            op_stack.pop()  # Remove '('
        
        elif char in '+-*/':
            # Process higher/equal precedence operators
            while (op_stack and 
                   op_stack[-1] != '(' and
                   precedence(op_stack[-1]) >= precedence(char)):
                apply_op(num_stack, op_stack.pop())
            op_stack.append(char)
        
        i += 1
    
    # Process remaining operators
    while op_stack:
        apply_op(num_stack, op_stack.pop())
    
    return num_stack[0]


# Test
print(calculate_iii_iterative("2*(5+5*2)/3+(6/2+8)"))  # 21
print(calculate_iii_iterative("1+2*3"))               # 7
print(calculate_iii_iterative("(2+3)*4"))             # 20
```

---

## 4.8 Expression Evaluation Summary

### Quick Reference

```
┌────────────────────────────────────────────────────────────────────┐
│               EXPRESSION EVALUATION CHEATSHEET                     │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│ POSTFIX EVALUATION: (Simplest)                                     │
│ ─────────────────────────────                                      │
│ • One stack for numbers                                            │
│ • Number → push                                                    │
│ • Operator → pop two, compute, push result                         │
│                                                                    │
│ BASIC CALCULATOR I: (+, -, parentheses)                            │
│ ─────────────────────────────                                      │
│ • Stack saves (result, sign) at '('                                │
│ • Track running result and current sign                            │
│ • ')' restores context                                             │
│                                                                    │
│ BASIC CALCULATOR II: (+, -, *, /, no parentheses)                  │
│ ─────────────────────────────                                      │
│ • Stack stores intermediate values                                 │
│ • +/- : push (delayed computation)                                 │
│ • *// : compute immediately with stack top                         │
│ • Sum stack at end                                                 │
│                                                                    │
│ BASIC CALCULATOR III: (Full expression)                            │
│ ─────────────────────────────                                      │
│ • Option 1: Recursive descent at '('                               │
│ • Option 2: Two stacks (nums + ops) with precedence               │
│                                                                    │
│ INFIX → POSTFIX: (Shunting Yard)                                   │
│ ─────────────────────────────                                      │
│ • Output queue + operator stack                                    │
│ • Pop higher/equal precedence before push                          │
│ • '(' pushed directly, ')' pops until '('                          │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

---

## Practice Problems

| Problem | Difficulty | Key Technique |
|---------|------------|---------------|
| Evaluate Reverse Polish Notation | Medium | Single stack |
| Basic Calculator I | Hard | Stack for parentheses |
| Basic Calculator II | Medium | Delayed computation |
| Basic Calculator III | Hard | Recursion or two stacks |
| Basic Calculator IV | Hard | Symbolic computation |
| Parse Lisp Expression | Hard | Recursive descent |
| Expression Add Operators | Hard | Backtracking + evaluation |
| Different Ways to Add Parentheses | Medium | Divide & conquer |
