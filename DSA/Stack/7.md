# Chapter 7: Recursion and Stack

## 7.1 Understanding the Call Stack

Every program has an implicit stack called the **Call Stack** that manages function calls.

### How the Call Stack Works

```
CALL STACK VISUALIZATION:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    result = foo(5)
    print(result)

def foo(n):
    return bar(n) + 1

def bar(n):
    return n * 2

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Execution Flow:

Step 1: main() called
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   main()    â”‚ â† Stack Frame
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 2: foo(5) called from main
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   foo(5)    â”‚ â† Current
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   main()    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 3: bar(5) called from foo
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   bar(5)    â”‚ â† Current
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   foo(5)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   main()    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 4: bar returns 10
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   foo(5)    â”‚ â† receives 10
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   main()    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 5: foo returns 11
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   main()    â”‚ â† receives 11
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 6: main completes
(empty stack)
```

### Stack Frame Contents

```
EACH STACK FRAME CONTAINS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         STACK FRAME                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Return address (where to go back) â”‚
â”‚ â€¢ Local variables                   â”‚
â”‚ â€¢ Parameters                        â”‚
â”‚ â€¢ Saved registers                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Example for factorial(4):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ factorial(1)            â”‚
â”‚ n = 1, return addr = X  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ factorial(2)            â”‚
â”‚ n = 2, return addr = X  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ factorial(3)            â”‚
â”‚ n = 3, return addr = X  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ factorial(4)            â”‚
â”‚ n = 4, return addr = X  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Stack Overflow

```python
# STACK OVERFLOW EXAMPLE:
def infinite_recursion(n):
    return infinite_recursion(n + 1)  # Never ends!

# This will crash with:
# RecursionError: maximum recursion depth exceeded

# Python default limit: ~1000 frames
import sys
print(sys.getrecursionlimit())  # 1000

# Can be changed (but be careful!):
sys.setrecursionlimit(10000)
```

---

## 7.2 Converting Recursion to Iteration

> ğŸ’¡ **KEY INSIGHT**: Any recursive algorithm can be converted to iterative using an explicit stack!

### Why Convert?

```
REASONS TO CONVERT RECURSION â†’ ITERATION:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. STACK OVERFLOW PREVENTION
   - Recursion depth limited by call stack size
   - Explicit stack limited only by heap memory

2. PERFORMANCE
   - Function calls have overhead
   - Iteration can be faster

3. INTERVIEW REQUIREMENT
   - "Solve without recursion" is common follow-up

4. TAIL CALL OPTIMIZATION
   - Some languages don't optimize tail recursion
   - Manual iteration guarantees efficiency
```

### Conversion Pattern

```
GENERAL CONVERSION TEMPLATE:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

RECURSIVE:
def recursive_function(params):
    if base_case:
        return base_result
    
    # Process current
    process(params)
    
    # Recursive calls
    recursive_function(new_params)


ITERATIVE:
def iterative_function(params):
    stack = [initial_state]
    
    while stack:
        current = stack.pop()
        
        if base_case(current):
            handle_base_case()
            continue
        
        # Process current
        process(current)
        
        # Push next states (reverse order!)
        stack.append(next_state)
```

### Example: Factorial

```python
# RECURSIVE FACTORIAL
def factorial_recursive(n):
    """
    Call stack grows to depth n
    Space: O(n) due to call stack
    """
    if n <= 1:
        return 1
    return n * factorial_recursive(n - 1)


# ITERATIVE FACTORIAL (Simple loop - no stack needed)
def factorial_iterative(n):
    """
    No recursion, O(1) space
    """
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result


# ITERATIVE WITH EXPLICIT STACK (demonstrating the pattern)
def factorial_stack(n):
    """
    Simulating recursion with explicit stack
    """
    if n <= 1:
        return 1
    
    stack = []
    
    # Push all multiplications onto stack
    while n > 1:
        stack.append(n)
        n -= 1
    
    # Pop and multiply
    result = 1
    while stack:
        result *= stack.pop()
    
    return result
```

---

## 7.3 Tree Traversals: Recursive vs Iterative

### Binary Tree Structure

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```

### Visual Tree Reference

```
EXAMPLE TREE:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

         1
        / \
       2   3
      / \   \
     4   5   6

TRAVERSAL ORDERS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Preorder  (Root-Left-Right): 1, 2, 4, 5, 3, 6
Inorder   (Left-Root-Right): 4, 2, 5, 1, 3, 6
Postorder (Left-Right-Root): 4, 5, 2, 6, 3, 1
```

### Preorder Traversal (Root â†’ Left â†’ Right)

```python
# RECURSIVE PREORDER
def preorder_recursive(root):
    """Simple and intuitive"""
    result = []
    
    def dfs(node):
        if not node:
            return
        result.append(node.val)  # Process root
        dfs(node.left)           # Then left
        dfs(node.right)          # Then right
    
    dfs(root)
    return result


# ITERATIVE PREORDER
def preorder_iterative(root):
    """
    Use stack, push RIGHT before LEFT
    (so LEFT is processed first - LIFO)
    
    Time: O(n), Space: O(h) where h = height
    """
    if not root:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        result.append(node.val)  # Process
        
        # Push right first, then left
        # So left is popped first (LIFO)
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    
    return result


# TRACE FOR TREE [1,2,3,4,5,null,6]:
"""
Stack operations:

Initial: stack = [1]

Pop 1, process, push right(3), left(2)
  result = [1], stack = [3, 2]

Pop 2, process, push right(5), left(4)
  result = [1,2], stack = [3, 5, 4]

Pop 4, process (no children)
  result = [1,2,4], stack = [3, 5]

Pop 5, process (no children)
  result = [1,2,4,5], stack = [3]

Pop 3, process, push right(6)
  result = [1,2,4,5,3], stack = [6]

Pop 6, process (no children)
  result = [1,2,4,5,3,6], stack = []

Final: [1, 2, 4, 5, 3, 6] âœ“
"""
```

### Inorder Traversal (Left â†’ Root â†’ Right) â­

```python
# RECURSIVE INORDER
def inorder_recursive(root):
    result = []
    
    def dfs(node):
        if not node:
            return
        dfs(node.left)           # Left first
        result.append(node.val)  # Then root
        dfs(node.right)          # Then right
    
    dfs(root)
    return result


# ITERATIVE INORDER â­ (Important pattern!)
def inorder_iterative(root):
    """
    Key insight: Go left as far as possible first
    
    Pattern:
    1. Push all left nodes
    2. Pop and process
    3. Move to right subtree
    
    Time: O(n), Space: O(h)
    """
    result = []
    stack = []
    current = root
    
    while stack or current:
        # Go left as far as possible
        while current:
            stack.append(current)
            current = current.left
        
        # Process current node
        current = stack.pop()
        result.append(current.val)
        
        # Move to right subtree
        current = current.right
    
    return result


# VISUAL TRACE:
"""
Tree:     1
         / \
        2   3
       / \
      4   5

Step-by-step:

current=1, stack=[]
  Go left: push 1,2,4 â†’ stack=[1,2,4], current=None

Pop 4, process â†’ result=[4], current=4.right=None
  stack=[1,2]

Pop 2, process â†’ result=[4,2], current=2.right=5
  stack=[1]

current=5
  Go left: push 5 â†’ stack=[1,5], current=None

Pop 5, process â†’ result=[4,2,5], current=5.right=None
  stack=[1]

Pop 1, process â†’ result=[4,2,5,1], current=1.right=3
  stack=[]

current=3
  Go left: push 3 â†’ stack=[3], current=None

Pop 3, process â†’ result=[4,2,5,1,3], current=3.right=None
  stack=[]

Done! Result: [4, 2, 5, 1, 3] âœ“
"""
```

### Postorder Traversal (Left â†’ Right â†’ Root) â­â­

```python
# RECURSIVE POSTORDER
def postorder_recursive(root):
    result = []
    
    def dfs(node):
        if not node:
            return
        dfs(node.left)           # Left first
        dfs(node.right)          # Then right
        result.append(node.val)  # Root last
    
    dfs(root)
    return result


# ITERATIVE POSTORDER - Method 1: Two Stacks
def postorder_two_stacks(root):
    """
    Use two stacks:
    Stack1: Process nodes (like preorder but right-left)
    Stack2: Collect results in reverse
    
    Trick: Preorder is Root-Left-Right
           If we do Root-Right-Left and reverse â†’ Left-Right-Root (Postorder!)
    """
    if not root:
        return []
    
    stack1 = [root]
    stack2 = []
    
    while stack1:
        node = stack1.pop()
        stack2.append(node.val)
        
        # Push left first, then right
        # (opposite of preorder)
        if node.left:
            stack1.append(node.left)
        if node.right:
            stack1.append(node.right)
    
    # Reverse stack2 for final result
    return stack2[::-1]


# ITERATIVE POSTORDER - Method 2: Single Stack with Visited Flag â­
def postorder_single_stack(root):
    """
    Single stack with visited tracking
    
    Key insight: Visit node twice
    - First time: push children
    - Second time: process (after children done)
    
    Use (node, visited) pairs
    """
    if not root:
        return []
    
    result = []
    stack = [(root, False)]
    
    while stack:
        node, visited = stack.pop()
        
        if visited:
            # Second visit: process node
            result.append(node.val)
        else:
            # First visit: push node again (to process later)
            # then push children
            stack.append((node, True))  # Process after children
            
            if node.right:
                stack.append((node.right, False))
            if node.left:
                stack.append((node.left, False))
    
    return result


# ITERATIVE POSTORDER - Method 3: Track Previous Node
def postorder_prev_tracking(root):
    """
    Track previously processed node to determine
    if we're coming up from left or right child
    """
    if not root:
        return []
    
    result = []
    stack = []
    current = root
    prev = None
    
    while stack or current:
        # Go left as far as possible
        while current:
            stack.append(current)
            current = current.left
        
        current = stack[-1]  # Peek
        
        # If right child exists and not yet processed
        if current.right and current.right != prev:
            current = current.right
        else:
            # Process current node
            result.append(current.val)
            prev = stack.pop()
            current = None
    
    return result
```

---

## 7.4 Graph DFS: Recursive vs Iterative

### DFS on Adjacency List

```python
# RECURSIVE DFS
def dfs_recursive(graph, start, visited=None):
    """
    graph: adjacency list {node: [neighbors]}
    """
    if visited is None:
        visited = set()
    
    visited.add(start)
    print(start, end=' ')  # Process node
    
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs_recursive(graph, neighbor, visited)
    
    return visited


# ITERATIVE DFS
def dfs_iterative(graph, start):
    """
    Using explicit stack
    Note: Order may differ from recursive due to LIFO
    """
    visited = set()
    stack = [start]
    result = []
    
    while stack:
        node = stack.pop()
        
        if node in visited:
            continue
        
        visited.add(node)
        result.append(node)
        
        # Push neighbors (reverse for same order as recursive)
        for neighbor in reversed(graph[node]):
            if neighbor not in visited:
                stack.append(neighbor)
    
    return result


# EXAMPLE:
"""
Graph:
    1 --- 2
    |     |
    3 --- 4 --- 5

graph = {
    1: [2, 3],
    2: [1, 4],
    3: [1, 4],
    4: [2, 3, 5],
    5: [4]
}

DFS from 1: 1 â†’ 2 â†’ 4 â†’ 3 â†’ 5 (or 1 â†’ 3 â†’ 4 â†’ 2 â†’ 5)
"""
```

### DFS for Pathfinding

```python
def find_path_dfs(graph, start, end):
    """
    Find path from start to end using iterative DFS
    Track path using stack of (node, path) tuples
    """
    stack = [(start, [start])]
    visited = set()
    
    while stack:
        node, path = stack.pop()
        
        if node == end:
            return path
        
        if node in visited:
            continue
        
        visited.add(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                stack.append((neighbor, path + [neighbor]))
    
    return None  # No path found
```

---

## 7.5 Backtracking with Explicit Stack

### Subsets Generation

```python
# RECURSIVE BACKTRACKING
def subsets_recursive(nums):
    """Generate all subsets using recursion"""
    result = []
    
    def backtrack(index, current):
        result.append(current[:])  # Add copy of current subset
        
        for i in range(index, len(nums)):
            current.append(nums[i])
            backtrack(i + 1, current)
            current.pop()  # Backtrack
    
    backtrack(0, [])
    return result


# ITERATIVE WITH STACK
def subsets_iterative(nums):
    """
    Using explicit stack for backtracking
    
    Stack stores: (index, current_subset)
    """
    result = []
    stack = [(0, [])]  # (start_index, current_subset)
    
    while stack:
        index, current = stack.pop()
        
        # Add current subset to result
        result.append(current[:])
        
        # Push next choices in reverse order
        for i in range(len(nums) - 1, index - 1, -1):
            stack.append((i + 1, current + [nums[i]]))
    
    return result


# BIT MANIPULATION (Alternative)
def subsets_bits(nums):
    """
    Each subset represented by binary number
    """
    n = len(nums)
    result = []
    
    for mask in range(1 << n):  # 0 to 2^n - 1
        subset = []
        for i in range(n):
            if mask & (1 << i):
                subset.append(nums[i])
        result.append(subset)
    
    return result
```

### Permutations

```python
# RECURSIVE
def permutations_recursive(nums):
    result = []
    
    def backtrack(current, remaining):
        if not remaining:
            result.append(current[:])
            return
        
        for i in range(len(remaining)):
            current.append(remaining[i])
            backtrack(current, remaining[:i] + remaining[i+1:])
            current.pop()
    
    backtrack([], nums)
    return result


# ITERATIVE WITH STACK
def permutations_iterative(nums):
    """
    Stack stores: (current_perm, remaining_elements)
    """
    result = []
    stack = [([], nums[:])]
    
    while stack:
        current, remaining = stack.pop()
        
        if not remaining:
            result.append(current)
            continue
        
        # Try each remaining element
        for i in range(len(remaining)):
            new_current = current + [remaining[i]]
            new_remaining = remaining[:i] + remaining[i+1:]
            stack.append((new_current, new_remaining))
    
    return result
```

---

## 7.6 N-Queens with Stack

```python
def solve_n_queens(n):
    """
    N-Queens using iterative backtracking with stack
    
    Stack stores: (row, columns_placed, diag1_set, diag2_set)
    """
    result = []
    
    # Stack: (row, queen_cols, diag1, diag2)
    # diag1: row - col (constant for each diagonal)
    # diag2: row + col (constant for each anti-diagonal)
    stack = [(0, [], set(), set())]
    
    while stack:
        row, queens, diag1, diag2 = stack.pop()
        
        if row == n:
            # Found valid solution
            board = []
            for col in queens:
                board.append('.' * col + 'Q' + '.' * (n - col - 1))
            result.append(board)
            continue
        
        # Try each column in current row
        for col in range(n):
            # Check if position is safe
            if col in queens:  # Column conflict
                continue
            if (row - col) in diag1:  # Diagonal conflict
                continue
            if (row + col) in diag2:  # Anti-diagonal conflict
                continue
            
            # Place queen and continue
            new_queens = queens + [col]
            new_diag1 = diag1 | {row - col}
            new_diag2 = diag2 | {row + col}
            stack.append((row + 1, new_queens, new_diag1, new_diag2))
    
    return result


# VISUALIZATION FOR N=4:
"""
Valid solutions:

Solution 1:          Solution 2:
. Q . .              . . Q .
. . . Q              Q . . .
Q . . .              . . . Q
. . Q .              . Q . .

Stack trace (partial):
(0, [], {}, {})
â†’ Try col 0: (1, [0], {0}, {0})
â†’ Try col 1: (1, [1], {-1}, {1})
â†’ Try col 2: (1, [2], {-2}, {2})
â†’ Try col 3: (1, [3], {-3}, {3})

Continue exploring each branch...
"""
```

---

## 7.7 Tail Recursion and Optimization

### What is Tail Recursion?

```
TAIL RECURSION:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

A function is tail recursive if the recursive call is the 
LAST operation performed.

NON-TAIL RECURSIVE:
def factorial(n):
    if n <= 1: return 1
    return n * factorial(n-1)  # Multiplication AFTER recursive call

TAIL RECURSIVE:
def factorial_tail(n, acc=1):
    if n <= 1: return acc
    return factorial_tail(n-1, n*acc)  # Nothing after recursive call

WHY IT MATTERS:
- Tail recursive can be optimized to iteration
- Compiler can reuse stack frame
- Prevents stack overflow
- Python does NOT optimize tail recursion!
```

### Converting to Tail Recursion

```python
# NON-TAIL RECURSIVE FIBONACCI
def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)  # Two calls, addition after


# TAIL RECURSIVE FIBONACCI
def fib_tail(n, a=0, b=1):
    """
    Carry computation in accumulators
    """
    if n == 0:
        return a
    if n == 1:
        return b
    return fib_tail(n-1, b, a+b)  # Tail call


# ITERATIVE (what tail recursion optimizes to)
def fib_iterative(n):
    if n <= 1:
        return n
    
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    
    return b


# GENERAL PATTERN:
"""
To convert to tail recursion:
1. Add accumulator parameter(s)
2. Compute partial result and pass to recursive call
3. Base case returns accumulator

To convert tail recursion to iteration:
1. Replace parameters with variables
2. Replace recursive call with loop
3. Update variables instead of passing new arguments
"""
```

---

## 7.8 Morris Traversal (O(1) Space)

```python
def morris_inorder(root):
    """
    Inorder traversal with O(1) space using Morris Traversal
    
    Key idea: Use right pointers of leaves to create
    temporary links back to ancestors
    
    Time: O(n), Space: O(1)
    """
    result = []
    current = root
    
    while current:
        if not current.left:
            # No left child: process and go right
            result.append(current.val)
            current = current.right
        else:
            # Find inorder predecessor (rightmost in left subtree)
            predecessor = current.left
            while predecessor.right and predecessor.right != current:
                predecessor = predecessor.right
            
            if not predecessor.right:
                # First visit: create thread and go left
                predecessor.right = current
                current = current.left
            else:
                # Second visit: remove thread, process, go right
                predecessor.right = None
                result.append(current.val)
                current = current.right
    
    return result


# VISUALIZATION:
"""
Tree:     1
         / \
        2   3
       / \
      4   5

Morris Inorder Process:

1. current=1, has left
   Find predecessor of 1: go left to 2, then right to 5
   5.right = 1 (create thread)
   Move to 2

2. current=2, has left
   Find predecessor of 2: go left to 4
   4.right = 2 (create thread)
   Move to 4

3. current=4, no left
   Process 4, move right to 2 (via thread)

4. current=2, has left but predecessor.right = current
   Remove thread (4.right = None)
   Process 2, move right to 5

5. current=5, no left
   Process 5, move right to 1 (via thread)

6. current=1, has left but predecessor.right = current
   Remove thread (5.right = None)
   Process 1, move right to 3

7. current=3, no left
   Process 3, move right to None

Done! Result: [4, 2, 5, 1, 3]
"""
```

---

## 7.9 Summary: Recursion â†” Stack

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            RECURSION AND STACK CHEATSHEET                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                    â”‚
â”‚ CONVERSION PRINCIPLE:                                              â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚ Every recursion uses implicit stack (call stack)                   â”‚
â”‚ â†’ Can always convert to explicit stack iteration                   â”‚
â”‚                                                                    â”‚
â”‚ TREE TRAVERSALS:                                                   â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚ Preorder:  Push root, popâ†’processâ†’push rightâ†’push left            â”‚
â”‚ Inorder:   Go left until null, popâ†’processâ†’go right               â”‚
â”‚ Postorder: Two stacks OR (node, visited) pairs                    â”‚
â”‚                                                                    â”‚
â”‚ BACKTRACKING:                                                      â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚ Stack stores: (state, choices_made, remaining_choices)             â”‚
â”‚ Pop â†’ process â†’ push next states                                   â”‚
â”‚                                                                    â”‚
â”‚ TAIL RECURSION:                                                    â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚ â€¢ Last operation is recursive call                                 â”‚
â”‚ â€¢ Can be optimized to O(1) space                                   â”‚
â”‚ â€¢ Use accumulators to carry computation                            â”‚
â”‚ â€¢ Python doesn't optimize - convert manually!                      â”‚
â”‚                                                                    â”‚
â”‚ WHEN TO CONVERT:                                                   â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚ â€¢ Deep recursion risk (>1000 levels)                               â”‚
â”‚ â€¢ Performance critical code                                        â”‚
â”‚ â€¢ Interview asks for iterative solution                            â”‚
â”‚ â€¢ Need more control over traversal                                 â”‚
â”‚                                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Practice Problems

| Problem | Type | Key Technique |
|---------|------|---------------|
| Binary Tree Inorder Traversal | Easy | Stack iteration |
| Binary Tree Preorder Traversal | Easy | Push right first |
| Binary Tree Postorder Traversal | Medium | Two stacks or visited flag |
| Flatten Binary Tree to Linked List | Medium | Preorder with stack |
| Binary Search Tree Iterator | Medium | Controlled inorder |
| N-Queens | Hard | Backtracking with stack |
| Generate Parentheses | Medium | Backtracking |
| Subsets | Medium | Backtracking/Iteration |
| Permutations | Medium | Backtracking |
| Word Search | Medium | DFS with stack |
