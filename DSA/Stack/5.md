# Chapter 5: Stack + Other Data Structures

## 5.1 Stack + Queue Combinations

### Problem 1: Implement Queue using Stacks (LeetCode 232) ⭐

```
QUEUE: FIFO (First In, First Out)
STACK: LIFO (Last In, First Out)

Challenge: Use LIFO to achieve FIFO!

Visual Insight:
═══════════════════════════════════════════════════════════════

If we pour stack into another stack, ORDER REVERSES!

Stack 1: [1,2,3]  (3 on top)
         │ 3 │
         │ 2 │
         │ 1 │

Pour into Stack 2:
         │ 1 │  ← Now 1 is on top!
         │ 2 │
         │ 3 │

Two reversals = Original order = FIFO achieved!
```

### Two-Stack Approach

```
APPROACH: Input Stack + Output Stack
═══════════════════════════════════════════════════════════════

Push: Always to input_stack → O(1)

Pop/Peek: 
- If output_stack empty → pour all from input to output
- Return from output_stack

This is called "LAZY TRANSFER"

Example Trace:
─────────────────────────────────────────────────────────────
Operation │ Input Stack │ Output Stack │ Result
─────────────────────────────────────────────────────────────
push(1)   │ [1]         │ []           │
push(2)   │ [1,2]       │ []           │
peek()    │ []          │ [2,1]        │ 1 (transfer first)
push(3)   │ [3]         │ [2,1]        │
pop()     │ [3]         │ [2]          │ 1
pop()     │ [3]         │ []           │ 2
pop()     │ []          │ []           │ 3 (transfer again)
─────────────────────────────────────────────────────────────
```

### Implementation

```python
class MyQueue:
    """
    Implement Queue using two stacks
    
    Time Complexity:
    - push: O(1)
    - pop: O(1) amortized (each element transferred at most once)
    - peek: O(1) amortized
    - empty: O(1)
    
    Space: O(n)
    """
    
    def __init__(self):
        self.input_stack = []   # For push operations
        self.output_stack = []  # For pop/peek operations
    
    def push(self, x: int) -> None:
        """Add element to back of queue"""
        self.input_stack.append(x)
    
    def pop(self) -> int:
        """Remove and return front element"""
        self._transfer_if_needed()
        return self.output_stack.pop()
    
    def peek(self) -> int:
        """Return front element without removing"""
        self._transfer_if_needed()
        return self.output_stack[-1]
    
    def empty(self) -> bool:
        """Check if queue is empty"""
        return not self.input_stack and not self.output_stack
    
    def _transfer_if_needed(self):
        """Transfer from input to output if output is empty"""
        if not self.output_stack:
            while self.input_stack:
                self.output_stack.append(self.input_stack.pop())


# Amortized Analysis:
"""
WHY IS POP O(1) AMORTIZED?
═══════════════════════════════════════════════════════════════

Each element is:
1. Pushed to input_stack once    → O(1)
2. Popped from input_stack once  → O(1) 
3. Pushed to output_stack once   → O(1)
4. Popped from output_stack once → O(1)

Total: 4 operations per element across its lifetime.

Even though a single pop() might transfer n elements,
those elements won't be transferred again!

Average cost per operation: O(1)
"""
```

---

### Problem 2: Implement Stack using Queues (LeetCode 225)

```
Challenge: Use FIFO to achieve LIFO!

TWO APPROACHES:
═══════════════════════════════════════════════════════════════

Approach 1: Make PUSH expensive O(n)
- Push: Add to queue, then rotate all previous elements behind it
- Pop: O(1)

Approach 2: Make POP expensive O(n)  
- Push: O(1)
- Pop: Move n-1 elements to back, then dequeue

Approach 1 is more commonly asked (keeps pop() fast)
```

### Implementation (Push Expensive)

```python
from collections import deque

class MyStack:
    """
    Implement Stack using single queue
    
    Approach: Make push O(n), pop O(1)
    
    After each push, rotate queue so new element is at front
    """
    
    def __init__(self):
        self.queue = deque()
    
    def push(self, x: int) -> None:
        """
        Add element to top of stack - O(n)
        
        Visual:
        Before: front [1, 2, 3] back
        push(4): [1, 2, 3, 4]
        Rotate 3 times: [4, 1, 2, 3]
        Now 4 is at front (top of stack)!
        """
        self.queue.append(x)
        
        # Rotate: move all previous elements behind the new one
        for _ in range(len(self.queue) - 1):
            self.queue.append(self.queue.popleft())
    
    def pop(self) -> int:
        """Remove and return top element - O(1)"""
        return self.queue.popleft()
    
    def top(self) -> int:
        """Return top element - O(1)"""
        return self.queue[0]
    
    def empty(self) -> bool:
        """Check if empty - O(1)"""
        return len(self.queue) == 0


# Trace Example:
"""
push(1): queue = [1]               → rotate 0 times → [1]
push(2): queue = [1,2]             → rotate 1 time  → [2,1]
push(3): queue = [2,1,3]           → rotate 2 times → [3,2,1]
top():   return queue[0] = 3 ✓
pop():   return popleft() = 3, queue = [2,1]
"""
```

---

## 5.2 Min Stack / Max Stack Pattern ⭐⭐

### Problem: Min Stack (LeetCode 155)

Design a stack that supports O(1) `getMin()`.

```
CHALLENGE:
═══════════════════════════════════════════════════════════════

Normal stack: push, pop, top all O(1)
But finding minimum requires scanning entire stack → O(n)

How to make getMin() O(1)?

KEY INSIGHT: Track minimum AT EACH LEVEL of the stack!
```

### Approach 1: Two Stacks

```
TWO STACKS APPROACH:
═══════════════════════════════════════════════════════════════

Main Stack:     Tracks actual values
Min Stack:      Tracks minimum at each level

Visual:
─────────────────────────────────────────────────────────────
Operation │ Main Stack │ Min Stack  │ Explanation
─────────────────────────────────────────────────────────────
push(5)   │ [5]        │ [5]        │ min so far = 5
push(3)   │ [5,3]      │ [5,3]      │ min so far = 3
push(7)   │ [5,3,7]    │ [5,3,3]    │ min still 3
push(2)   │ [5,3,7,2]  │ [5,3,3,2]  │ min now 2
pop()     │ [5,3,7]    │ [5,3,3]    │ min back to 3
getMin()  │            │            │ return min_stack[-1] = 3
─────────────────────────────────────────────────────────────
```

```python
class MinStack:
    """
    Stack with O(1) getMin using auxiliary stack
    
    Time: O(1) for all operations
    Space: O(n) for auxiliary stack
    """
    
    def __init__(self):
        self.stack = []
        self.min_stack = []
    
    def push(self, val: int) -> None:
        self.stack.append(val)
        
        # Push to min_stack: current value or current min (whichever smaller)
        if self.min_stack:
            self.min_stack.append(min(val, self.min_stack[-1]))
        else:
            self.min_stack.append(val)
    
    def pop(self) -> None:
        self.stack.pop()
        self.min_stack.pop()
    
    def top(self) -> int:
        return self.stack[-1]
    
    def getMin(self) -> int:
        return self.min_stack[-1]
```

### Approach 2: Space Optimized (Single Stack)

```
SPACE OPTIMIZATION:
═══════════════════════════════════════════════════════════════

Only push to min_stack when value ≤ current minimum
On pop, only pop from min_stack if popped value equals min

OR store (value, min_at_this_level) pairs in single stack
```

```python
class MinStackOptimized:
    """
    Space-optimized: Only store min when it changes
    """
    
    def __init__(self):
        self.stack = []
        self.min_stack = []
    
    def push(self, val: int) -> None:
        self.stack.append(val)
        
        # Only push if new min or equal (important for duplicates!)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)
    
    def pop(self) -> None:
        val = self.stack.pop()
        
        # Only pop min if it's the value being removed
        if val == self.min_stack[-1]:
            self.min_stack.pop()
    
    def top(self) -> int:
        return self.stack[-1]
    
    def getMin(self) -> int:
        return self.min_stack[-1]


class MinStackSingleStack:
    """
    Alternative: Store (value, current_min) pairs
    """
    
    def __init__(self):
        self.stack = []  # Each element is (value, min_at_this_point)
    
    def push(self, val: int) -> None:
        current_min = min(val, self.stack[-1][1]) if self.stack else val
        self.stack.append((val, current_min))
    
    def pop(self) -> None:
        self.stack.pop()
    
    def top(self) -> int:
        return self.stack[-1][0]
    
    def getMin(self) -> int:
        return self.stack[-1][1]
```

### Approach 3: Mathematical (O(1) Space for getMin Logic)

```python
class MinStackMath:
    """
    Mathematical approach: Store encoded values
    
    When pushing value smaller than min:
    - Push: 2 * val - old_min (always < val < old_min)
    - Update min to val
    
    When popping and value < min:
    - Real value was min (stored in self.min)
    - Recover old_min: 2 * min - popped_value
    
    Space: O(1) extra (just one variable for min)
    Note: May have overflow issues with large numbers
    """
    
    def __init__(self):
        self.stack = []
        self.min = float('inf')
    
    def push(self, val: int) -> None:
        if not self.stack:
            self.stack.append(val)
            self.min = val
        elif val >= self.min:
            self.stack.append(val)
        else:
            # Push encoded value, update min
            self.stack.append(2 * val - self.min)
            self.min = val
    
    def pop(self) -> None:
        if not self.stack:
            return
        
        top = self.stack.pop()
        
        if top < self.min:
            # This was an encoded value
            # Recover previous min
            self.min = 2 * self.min - top
    
    def top(self) -> int:
        if not self.stack:
            return -1
        
        top = self.stack[-1]
        
        if top < self.min:
            # Encoded value: real value is current min
            return self.min
        return top
    
    def getMin(self) -> int:
        return self.min
```

---

### Max Stack (LeetCode 716) ⭐⭐

Design stack with O(1) `push`, `pop`, `top`, `peekMax`, and O(n) or O(log n) `popMax`.

```
CHALLENGE:
═══════════════════════════════════════════════════════════════

popMax() is harder than getMax():
- Need to remove the maximum element
- It might not be at the top!
- Need to maintain stack property after removal

APPROACHES:
1. Two stacks + lazy deletion → O(n) popMax
2. Doubly linked list + TreeMap → O(log n) popMax
```

```python
class MaxStack:
    """
    Max Stack with O(n) popMax using two stacks
    
    Approach:
    - Maintain max_stack similar to MinStack
    - For popMax: pop until we find max, then push back others
    """
    
    def __init__(self):
        self.stack = []
        self.max_stack = []
    
    def push(self, x: int) -> None:
        self.stack.append(x)
        
        if self.max_stack:
            self.max_stack.append(max(x, self.max_stack[-1]))
        else:
            self.max_stack.append(x)
    
    def pop(self) -> int:
        self.max_stack.pop()
        return self.stack.pop()
    
    def top(self) -> int:
        return self.stack[-1]
    
    def peekMax(self) -> int:
        return self.max_stack[-1]
    
    def popMax(self) -> int:
        """
        Remove and return maximum element - O(n)
        
        Strategy: Pop elements until we find max,
        then push back the others
        """
        max_val = self.max_stack[-1]
        
        # Pop elements until we find the max
        temp = []
        while self.stack[-1] != max_val:
            temp.append(self.pop())
        
        # Remove the max element
        self.pop()
        
        # Push back the other elements
        while temp:
            self.push(temp.pop())
        
        return max_val


# For O(log n) popMax: Use SortedList or TreeMap
from sortedcontainers import SortedList

class MaxStackOptimal:
    """
    Optimal Max Stack using doubly linked list + sorted structure
    
    Time: O(log n) for all operations
    Space: O(n)
    """
    
    def __init__(self):
        self.stack = []  # List of (value, id)
        self.sorted_vals = SortedList()  # (value, id) sorted
        self.id = 0
        self.removed = set()  # Lazy deletion
    
    def push(self, x: int) -> None:
        self.stack.append((x, self.id))
        self.sorted_vals.add((x, self.id))
        self.id += 1
    
    def _clean_top(self):
        """Remove lazily deleted elements from top"""
        while self.stack and self.stack[-1][1] in self.removed:
            self.removed.remove(self.stack[-1][1])
            self.stack.pop()
    
    def pop(self) -> int:
        self._clean_top()
        val, idx = self.stack.pop()
        self.sorted_vals.remove((val, idx))
        return val
    
    def top(self) -> int:
        self._clean_top()
        return self.stack[-1][0]
    
    def peekMax(self) -> int:
        while self.sorted_vals[-1][1] in self.removed:
            self.sorted_vals.pop()
        return self.sorted_vals[-1][0]
    
    def popMax(self) -> int:
        while self.sorted_vals[-1][1] in self.removed:
            self.sorted_vals.pop()
        val, idx = self.sorted_vals.pop()
        self.removed.add(idx)
        return val
```

---

## 5.3 Stack + HashMap

### Problem: Next Greater Element I (LeetCode 496)

```
Two arrays: nums1 is subset of nums2
For each element in nums1, find NGE in nums2

nums1 = [4,1,2], nums2 = [1,3,4,2]

In nums2:
- NGE of 4 is -1 (no greater to right)
- NGE of 1 is 3
- NGE of 2 is -1

Output: [-1, 3, -1]
```

```python
def nextGreaterElement(nums1, nums2):
    """
    Combine monotonic stack with HashMap
    
    1. Find NGE for ALL elements in nums2 (store in HashMap)
    2. Look up results for nums1 elements
    
    Time: O(n + m), Space: O(n)
    """
    # Build NGE map for nums2
    nge_map = {}
    stack = []
    
    for num in nums2:
        while stack and num > stack[-1]:
            nge_map[stack.pop()] = num
        stack.append(num)
    
    # Remaining elements have no NGE
    while stack:
        nge_map[stack.pop()] = -1
    
    # Look up for nums1
    return [nge_map[num] for num in nums1]


# Visual:
"""
nums2 = [1, 3, 4, 2]

Processing:
1: stack = [1]
3: 3 > 1, pop 1 → nge[1]=3, stack = [3]
4: 4 > 3, pop 3 → nge[3]=4, stack = [4]
2: 2 < 4, stack = [4, 2]

Remaining: nge[4]=-1, nge[2]=-1

nge_map = {1: 3, 3: 4, 4: -1, 2: -1}

nums1 = [4, 1, 2] → [-1, 3, -1]
"""
```

---

## 5.4 Maximum Frequency Stack (LeetCode 895) ⭐⭐⭐

Design a stack that pops the most frequent element.

```
OPERATIONS:
═══════════════════════════════════════════════════════════════

push(x): Push x onto stack
pop(): Remove and return most frequent element
       If tie: return most recently pushed among them

Example:
push(5), push(7), push(5), push(7), push(4), push(5)
State: [5, 7, 5, 7, 4, 5]
Frequencies: 5→3, 7→2, 4→1

pop() → 5 (most frequent, most recent of freq 3)
pop() → 7 (now 5→2, 7→2, tie broken by most recent)
pop() → 5
pop() → 4
```

### Key Insight

```
DATA STRUCTURES NEEDED:
═══════════════════════════════════════════════════════════════

1. freq_map: value → count
   Track frequency of each value

2. group_map: frequency → stack of values with that frequency
   When freq=3, which values have been pushed 3 times?
   Store in a STACK so most recent is on top!

3. max_freq: Track current maximum frequency


PUSH(x):
─────────────────────────────────────────────────────────────
1. Increment freq_map[x]
2. Push x to group_map[new_freq]
3. Update max_freq if needed

POP():
─────────────────────────────────────────────────────────────
1. Pop from group_map[max_freq]
2. Decrement freq_map of popped value
3. If group_map[max_freq] is empty, decrement max_freq
```

### Visual Trace

```
Operations: push(5), push(7), push(5), push(7), push(4), push(5)

═══════════════════════════════════════════════════════════════════════════
Op      │ freq_map         │ group_map                    │ max_freq
═══════════════════════════════════════════════════════════════════════════
push(5) │ {5:1}            │ {1:[5]}                      │ 1
push(7) │ {5:1, 7:1}       │ {1:[5,7]}                    │ 1
push(5) │ {5:2, 7:1}       │ {1:[5,7], 2:[5]}             │ 2
push(7) │ {5:2, 7:2}       │ {1:[5,7], 2:[5,7]}           │ 2
push(4) │ {5:2, 7:2, 4:1}  │ {1:[5,7,4], 2:[5,7]}         │ 2
push(5) │ {5:3, 7:2, 4:1}  │ {1:[5,7,4], 2:[5,7], 3:[5]}  │ 3
─────────────────────────────────────────────────────────────────────────
pop()   │ Pop from group[3]→5                              │
        │ {5:2, 7:2, 4:1}  │ {1:[5,7,4], 2:[5,7], 3:[]}   │ 2
pop()   │ Pop from group[2]→7                              │
        │ {5:2, 7:1, 4:1}  │ {1:[5,7,4], 2:[5]}           │ 2
═══════════════════════════════════════════════════════════════════════════
```

### Implementation

```python
from collections import defaultdict

class FreqStack:
    """
    Maximum Frequency Stack
    
    Time: O(1) for both push and pop
    Space: O(n)
    """
    
    def __init__(self):
        # value → current frequency
        self.freq_map = defaultdict(int)
        
        # frequency → stack of values with that frequency
        self.group_map = defaultdict(list)
        
        # Current maximum frequency
        self.max_freq = 0
    
    def push(self, val: int) -> None:
        # Increment frequency
        self.freq_map[val] += 1
        freq = self.freq_map[val]
        
        # Add to frequency group
        # Note: Same value can appear in multiple groups!
        # 5 with freq 3 is in group[1], group[2], AND group[3]
        self.group_map[freq].append(val)
        
        # Update max frequency
        self.max_freq = max(self.max_freq, freq)
    
    def pop(self) -> int:
        # Pop from highest frequency group
        val = self.group_map[self.max_freq].pop()
        
        # Decrement frequency
        self.freq_map[val] -= 1
        
        # If this frequency group is empty, decrement max_freq
        if not self.group_map[self.max_freq]:
            self.max_freq -= 1
        
        return val


# Why does same value appear in multiple groups?
"""
When we push 5 three times:
- First push: freq=1, add to group[1]
- Second push: freq=2, add to group[2]
- Third push: freq=3, add to group[3]

5 is in group[1], group[2], and group[3]!

This is correct because:
- When we pop 5 from group[3], its freq becomes 2
- Next time we need freq=2, 5 is already in group[2]
- We don't need to move it!
"""
```

---

## 5.5 Stack + Heap (Priority Queue)

### Problem: Sliding Window Maximum with Stack

While typically solved with deque, understanding the relationship helps:

```python
from collections import deque

def maxSlidingWindow(nums, k):
    """
    Maximum in each sliding window of size k
    
    Uses MONOTONIC DEQUE (decreasing from front to back)
    - Deque front is always the maximum
    - Remove from back if smaller than current
    - Remove from front if out of window
    
    This is essentially a "double-ended monotonic stack"!
    """
    result = []
    dq = deque()  # Store indices
    
    for i, num in enumerate(nums):
        # Remove elements out of window
        while dq and dq[0] <= i - k:
            dq.popleft()
        
        # Remove smaller elements (monotonic property)
        while dq and nums[dq[-1]] < num:
            dq.pop()
        
        dq.append(i)
        
        # Add to result once window is full
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result
```

---

## 5.6 132 Pattern (LeetCode 456) ⭐⭐

Find if there's an `i < j < k` such that `nums[i] < nums[k] < nums[j]`.

```
Pattern: "132" means first element < third < second
                    (1)         (2)    (3)

Example: [3, 1, 4, 2]
         Found: 1 < 2 < 4 (indices 1, 2, 3)
         Pattern exists!
```

### Key Insight

```
APPROACH: Iterate from RIGHT, track "3" and "2" values
═══════════════════════════════════════════════════════════════

- Use decreasing stack to track potential "3" (largest seen)
- Track "2" as the second largest (popped from stack)
- For each new element, check if it's smaller than "2" (it's our "1")

Stack stores potential "3" candidates (decreasing order)
When we find larger element, pop and update "2"
```

```python
def find132pattern(nums):
    """
    Find 132 pattern using monotonic stack
    
    Approach: Scan right to left
    - Stack maintains potential "3" values (decreasing)
    - second tracks the "2" value (second largest so far)
    - Current element is candidate for "1"
    
    Time: O(n), Space: O(n)
    """
    n = len(nums)
    if n < 3:
        return False
    
    stack = []  # Decreasing stack for "3" candidates
    second = float('-inf')  # The "2" in 132 (second largest)
    
    # Scan from right to left
    for i in range(n - 1, -1, -1):
        # Current could be "1" if less than "second"
        if nums[i] < second:
            return True
        
        # Pop smaller elements - they become "2" candidates
        # The largest popped is our best "2"
        while stack and nums[i] > stack[-1]:
            second = stack.pop()
        
        stack.append(nums[i])
    
    return False


# Trace for [3, 1, 4, 2]:
"""
Scan right to left:

i=3, nums[i]=2:
  stack=[], second=-inf
  2 > -inf? No
  Push → stack=[2]

i=2, nums[i]=4:
  4 < -inf? No  
  4 > 2? Yes → pop, second=2
  Push → stack=[4], second=2

i=1, nums[i]=1:
  1 < 2? YES! Found 132 pattern!
  
  Here: "1"=1, "3"=4 (in stack), "2"=2
  Pattern: 1 < 2 < 4 ✓
"""
```

---

## 5.7 Summary: Combining Data Structures

```
┌────────────────────────────────────────────────────────────────────┐
│          STACK + OTHER DATA STRUCTURES CHEATSHEET                  │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│ STACK + QUEUE:                                                     │
│ ─────────────────────────────                                      │
│ • Queue from 2 stacks: Input + Output with lazy transfer           │
│ • Stack from queue: Rotate after each push                         │
│ • Key: Two LIFOs = FIFO, rotation reverses order                   │
│                                                                    │
│ MIN/MAX STACK:                                                     │
│ ─────────────────────────────                                      │
│ • Auxiliary stack tracking min/max at each level                   │
│ • Space optimization: Only push when min/max changes               │
│ • Mathematical trick: Encode values (2*val - min)                  │
│                                                                    │
│ STACK + HASHMAP:                                                   │
│ ─────────────────────────────                                      │
│ • Pre-compute answers, store in map                                │
│ • Look up for subset of elements                                   │
│ • Example: NGE for subset of array                                 │
│                                                                    │
│ FREQUENCY STACK:                                                   │
│ ─────────────────────────────                                      │
│ • freq_map: value → frequency                                      │
│ • group_map: frequency → stack of values                           │
│ • max_freq: current maximum                                        │
│ • Pop from group[max_freq] for most frequent + most recent         │
│                                                                    │
│ 132 PATTERN:                                                       │
│ ─────────────────────────────                                      │
│ • Scan right to left with decreasing stack                         │
│ • Track "second" as largest popped value                           │
│ • Check if current < second (found pattern!)                       │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

---

## Practice Problems

| Problem | Data Structures | Difficulty |
|---------|-----------------|------------|
| Implement Queue using Stacks | 2 Stacks | Easy |
| Implement Stack using Queues | Queue | Easy |
| Min Stack | Stack + Aux Stack | Medium |
| Max Stack | Stack + SortedList | Hard |
| Next Greater Element I | Stack + HashMap | Easy |
| Maximum Frequency Stack | Stack + 2 HashMaps | Hard |
| 132 Pattern | Monotonic Stack | Medium |
| All O(1) Data Structure | Stack + HashMap + DLL | Hard |
| LRU Cache | HashMap + DLL | Medium |
