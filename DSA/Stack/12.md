# Chapter 12: Common Mistakes & Pro Tips

## 12.1 The 10 Deadly Mistakes

### Mistake #1: Empty Stack Access

```
THE PROBLEM:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Accessing stack[-1] or calling pop() on empty stack crashes!

This is the #1 most common mistake in stack problems.
```

```python
# âŒ WRONG - Will crash on empty stack
def wrong_nge(nums):
    stack = []
    for i, num in enumerate(nums):
        while nums[i] > nums[stack[-1]]:  # IndexError!
            stack.pop()
        stack.append(i)

# âŒ WRONG - Peek without check
def wrong_peek(stack):
    return stack[-1]  # Crashes if empty!

# âŒ WRONG - Pop without check
def wrong_pop(stack):
    return stack.pop()  # Crashes if empty!


# âœ… CORRECT - Always check first
def correct_nge(nums):
    stack = []
    for i, num in enumerate(nums):
        while stack and nums[i] > nums[stack[-1]]:  # Check first!
            stack.pop()
        stack.append(i)

# âœ… CORRECT - Safe peek
def safe_peek(stack):
    return stack[-1] if stack else None

# âœ… CORRECT - Safe pop
def safe_pop(stack):
    return stack.pop() if stack else None


# PRO TIP: Use "stack and" as a guard
# Python short-circuits, so stack[-1] is never accessed if stack is empty
```

---

### Mistake #2: Storing Values Instead of Indices

```
THE PROBLEM:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

When you need to calculate DISTANCES, WIDTHS, or POSITIONS,
storing values makes computation impossible!
```

```python
# âŒ WRONG - Can't calculate width!
def wrong_histogram(heights):
    stack = []
    max_area = 0
    
    for h in heights:
        while stack and h < stack[-1]:
            height = stack.pop()
            # How to calculate width??? We don't know positions!
            width = ???  # IMPOSSIBLE
            max_area = max(max_area, height * width)
        stack.append(h)
    
    return max_area


# âœ… CORRECT - Store indices
def correct_histogram(heights):
    stack = []  # Store INDICES
    max_area = 0
    heights = heights + [0]  # Sentinel
    
    for i, h in enumerate(heights):
        while stack and h < heights[stack[-1]]:
            height = heights[stack.pop()]
            # Now we can calculate width!
            left = stack[-1] if stack else -1
            width = i - left - 1
            max_area = max(max_area, height * width)
        stack.append(i)
    
    return max_area


# RULE OF THUMB:
# - Store VALUES when: You only need the value itself
# - Store INDICES when: You need position, width, distance, or length
# - Store (value, index) when: You need both frequently
```

---

### Mistake #3: Wrong Comparison Direction

```
THE PROBLEM:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Using < when you should use >, or vice versa.
This completely breaks the monotonic property!
```

```python
# For NEXT GREATER Element:

# âŒ WRONG - Using less than
def wrong_nge(nums):
    result = [-1] * len(nums)
    stack = []
    for i in range(len(nums)):
        # This pops when current is SMALLER - wrong!
        while stack and nums[i] < nums[stack[-1]]:
            result[stack.pop()] = nums[i]
        stack.append(i)
    return result

# âœ… CORRECT - Pop when current is GREATER
def correct_nge(nums):
    result = [-1] * len(nums)
    stack = []
    for i in range(len(nums)):
        # Current > top means current is NGE for top
        while stack and nums[i] > nums[stack[-1]]:
            result[stack.pop()] = nums[i]
        stack.append(i)
    return result


# MEMORY AID:
"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                â•‘
â•‘  Finding GREATER â†’ Pop SMALLER elements (current > top)        â•‘
â•‘  Finding SMALLER â†’ Pop LARGER elements (current < top)         â•‘
â•‘                                                                â•‘
â•‘  Think: "I pop you because I'm what you're looking for!"       â•‘
â•‘                                                                â•‘
â•‘  NGE: Current is GREATER, so it's the answer for smaller items â•‘
â•‘  NSE: Current is SMALLER, so it's the answer for larger items  â•‘
â•‘                                                                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
```

---

### Mistake #4: Forgetting Remaining Stack Elements

```
THE PROBLEM:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

After the main loop, elements may remain in the stack.
These need special handling!
```

```python
# âŒ WRONG - Forgets remaining elements
def wrong_nge(nums):
    result = [None] * len(nums)  # None instead of -1!
    stack = []
    
    for i in range(len(nums)):
        while stack and nums[i] > nums[stack[-1]]:
            result[stack.pop()] = nums[i]
        stack.append(i)
    
    return result  # Some elements are still None!


# âœ… SOLUTION 1: Initialize with default value
def correct_nge_v1(nums):
    result = [-1] * len(nums)  # Pre-fill with -1
    stack = []
    
    for i in range(len(nums)):
        while stack and nums[i] > nums[stack[-1]]:
            result[stack.pop()] = nums[i]
        stack.append(i)
    
    # Remaining elements already have -1!
    return result


# âœ… SOLUTION 2: Process remaining explicitly
def correct_nge_v2(nums):
    result = [None] * len(nums)
    stack = []
    
    for i in range(len(nums)):
        while stack and nums[i] > nums[stack[-1]]:
            result[stack.pop()] = nums[i]
        stack.append(i)
    
    # Process remaining
    while stack:
        result[stack.pop()] = -1
    
    return result


# âœ… SOLUTION 3: Use sentinel value
def correct_histogram(heights):
    heights = heights + [0]  # Sentinel forces all pops!
    stack = []
    max_area = 0
    
    for i, h in enumerate(heights):
        while stack and h < heights[stack[-1]]:
            # Process...
            pass
        stack.append(i)
    
    # Stack is now empty (sentinel forced it)
    return max_area
```

---

### Mistake #5: Off-by-One Errors

```
THE PROBLEM:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Width and boundary calculations are tricky.
Getting them wrong by 1 leads to incorrect results.
```

```python
# COMMON OFF-BY-ONE ERRORS:

# âŒ WRONG - Width calculation
width = right - left      # Missing -1!
width = right - left + 1  # Extra +1!

# âœ… CORRECT - Width is BETWEEN boundaries
width = right - left - 1

# âŒ WRONG - Left boundary
left = stack[-1]  # What if stack is empty?

# âœ… CORRECT - Handle empty stack
left = stack[-1] if stack else -1  # -1 as virtual boundary


# VISUAL EXPLANATION:
"""
Index:    0   1   2   3   4   5
Heights:  2   1   5   6   2   3
                  â”‚â”€â”€â”€â”‚
                  left right
                  =2   =4

For bar at index 3 (height 6):
â€¢ Left boundary (PSE) at index 2
â€¢ Right boundary (NSE) at index 4
â€¢ Width = 4 - 2 - 1 = 1  (only index 3)

Bar can extend from index 3 to index 3 (width 1)
NOT from index 2 to 4!

The boundaries are EXCLUSIVE, so we subtract both:
width = right - left - 1
"""


# COMPLETE CORRECT EXAMPLE:
def histogram_correct(heights):
    heights = heights + [0]
    stack = []
    max_area = 0
    
    for i, h in enumerate(heights):
        while stack and h < heights[stack[-1]]:
            height = heights[stack.pop()]
            
            # Left boundary: stack top or -1
            left = stack[-1] if stack else -1
            
            # Right boundary: current index i
            right = i
            
            # Width: between exclusive boundaries
            width = right - left - 1
            
            max_area = max(max_area, height * width)
        
        stack.append(i)
    
    return max_area
```

---

### Mistake #6: Duplicate Handling

```
THE PROBLEM:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

When array has duplicates, using same comparison on both sides
causes double counting or missed elements.
```

```python
# âŒ WRONG - Same comparison both sides causes issues
def wrong_subarray_mins(arr):
    n = len(arr)
    
    # Both use > (strictly greater)
    # This can double-count subarrays!
    left = [0] * n
    stack = []
    for i in range(n):
        while stack and arr[stack[-1]] > arr[i]:
            stack.pop()
        left[i] = i - stack[-1] if stack else i + 1
        stack.append(i)
    
    right = [0] * n
    stack = []
    for i in range(n - 1, -1, -1):
        while stack and arr[stack[-1]] > arr[i]:  # Same comparison!
            stack.pop()
        right[i] = stack[-1] - i if stack else n - i
        stack.append(i)


# âœ… CORRECT - Different comparison on each side
def correct_subarray_mins(arr):
    n = len(arr)
    
    # Left: strictly greater (>)
    left = [0] * n
    stack = []
    for i in range(n):
        while stack and arr[stack[-1]] > arr[i]:
            stack.pop()
        left[i] = i - stack[-1] if stack else i + 1
        stack.append(i)
    
    # Right: greater or equal (>=)
    right = [0] * n
    stack = []
    for i in range(n - 1, -1, -1):
        while stack and arr[stack[-1]] >= arr[i]:  # Different!
            stack.pop()
        right[i] = stack[-1] - i if stack else n - i
        stack.append(i)


# WHY THIS WORKS:
"""
For array [1, 2, 1]:

With > on both sides, middle element's range would overlap
with both 1s' ranges.

With > on left and >= on right:
- Left 1: controls left portion
- Right 1: controls right portion  
- No overlap!

Rule: For duplicates, one side "wins" the boundary.
"""
```

---

### Mistake #7: Modifying Input Array

```
THE PROBLEM:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Accidentally modifying the input can cause issues,
especially when you need to reference original values later.
```

```python
# âŒ WRONG - Modifies input
def wrong_approach(heights):
    heights.append(0)  # Modifies original list!
    # ... process ...
    return result
    # Caller's list is now modified!


# âœ… CORRECT - Create copy or use index
def correct_approach_v1(heights):
    heights = heights + [0]  # Creates new list
    # ... process ...
    return result


def correct_approach_v2(heights):
    heights = heights.copy()
    heights.append(0)
    # ... process ...
    return result


def correct_approach_v3(heights):
    # Use virtual sentinel without modifying
    n = len(heights)
    for i in range(n + 1):
        h = 0 if i == n else heights[i]  # Virtual sentinel
        # ... process ...
```

---

### Mistake #8: Wrong Loop Direction

```
THE PROBLEM:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Some problems require processing from right to left,
but you process left to right (or vice versa).
```

```python
# PREVIOUS Greater/Smaller: Process LEFT to RIGHT
# NEXT Greater/Smaller: Can process either direction
# Some problems specifically need RIGHT to LEFT

# âŒ WRONG - Visible people needs right to left
def wrong_visible_people(heights):
    result = [0] * len(heights)
    stack = []
    
    # Processing left to right doesn't work!
    for i in range(len(heights)):
        # ... wrong logic ...
        pass


# âœ… CORRECT - Right to left
def correct_visible_people(heights):
    n = len(heights)
    result = [0] * n
    stack = []
    
    # Process right to left
    for i in range(n - 1, -1, -1):
        count = 0
        while stack and heights[i] > stack[-1]:
            stack.pop()
            count += 1
        if stack:
            count += 1
        result[i] = count
        stack.append(heights[i])
    
    return result


# WHEN TO USE EACH DIRECTION:
"""
LEFT to RIGHT:
- Next Greater/Smaller Element
- Stock Span (Previous Greater)
- Most parentheses problems

RIGHT to LEFT:
- Number of Visible People
- Buildings with Ocean View
- Some Previous Greater variants
- 132 Pattern
"""
```

---

### Mistake #9: Incorrect Operator Precedence

```
THE PROBLEM:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

In expression evaluation, handling precedence wrong
gives incorrect results.
```

```python
# âŒ WRONG - Treats all operators same
def wrong_calculate(s):
    stack = []
    num = 0
    op = '+'
    
    for char in s + '+':
        if char.isdigit():
            num = num * 10 + int(char)
        elif char in '+-*/':
            # Applying all operators immediately - wrong!
            if op == '+':
                stack.append(num)
            elif op == '-':
                stack.append(-num)
            elif op == '*':
                stack.append(num)  # Should compute with prev!
            elif op == '/':
                stack.append(num)  # Should compute with prev!
            num = 0
            op = char
    
    return sum(stack)  # Wrong for * and /


# âœ… CORRECT - Different handling by precedence
def correct_calculate(s):
    stack = []
    num = 0
    op = '+'
    
    for char in s + '+':
        if char.isdigit():
            num = num * 10 + int(char)
        elif char in '+-*/':
            if op == '+':
                stack.append(num)       # Delay + 
            elif op == '-':
                stack.append(-num)      # Delay -
            elif op == '*':
                stack.append(stack.pop() * num)  # Compute now!
            elif op == '/':
                stack.append(int(stack.pop() / num))  # Compute now!
            num = 0
            op = char
    
    return sum(stack)


# PRECEDENCE RULE:
"""
For Calculator II (no parentheses):
- +/- : Push to stack (delayed computation)
- */ : Compute immediately with stack top

Why? Because */ has higher precedence.
In "3 + 4 * 2":
- Push 3
- See *, so 4 * 2 = 8 happens first
- Then 3 + 8 = 11
"""
```

---

### Mistake #10: Integer Division Issues

```
THE PROBLEM:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Python 3's // operator rounds toward negative infinity,
but some problems want truncation toward zero.
```

```python
# Python division behavior:
print(7 // 3)    # 2 âœ“
print(-7 // 3)   # -3 (rounds toward -âˆ)
print(7 // -3)   # -3 (rounds toward -âˆ)

# But LeetCode expects truncation toward zero:
# -7 / 3 should be -2, not -3


# âŒ WRONG - Using //
def wrong_divide(a, b):
    return a // b  # Wrong for negative numbers!


# âœ… CORRECT - Truncate toward zero
def correct_divide(a, b):
    return int(a / b)  # Truncates toward zero


# In calculator problems:
def calculate(s):
    # ...
    elif prev_op == '/':
        # âŒ Wrong:
        # stack.append(stack.pop() // num)
        
        # âœ… Correct:
        stack.append(int(stack.pop() / num))
```

---

## 12.2 Debugging Strategies

### Strategy 1: Trace Table Method

```python
def debug_with_trace(nums):
    """
    Create a trace table to debug stack problems
    """
    print("=" * 60)
    print(f"{'i':<4} {'num':<6} {'Action':<20} {'Stack':<20}")
    print("=" * 60)
    
    result = [-1] * len(nums)
    stack = []
    
    for i, num in enumerate(nums):
        action = ""
        
        while stack and nums[i] > nums[stack[-1]]:
            popped = stack.pop()
            result[popped] = num
            action += f"Pop {popped}, "
        
        stack.append(i)
        action += f"Push {i}"
        
        # Print trace
        stack_vals = [nums[j] for j in stack]
        print(f"{i:<4} {num:<6} {action:<20} {str(stack_vals):<20}")
    
    print("=" * 60)
    print(f"Result: {result}")
    return result


# Usage:
debug_with_trace([4, 2, 5, 1, 3])

# Output:
# ============================================================
# i    num    Action               Stack               
# ============================================================
# 0    4      Push 0               [4]                 
# 1    2      Push 1               [4, 2]              
# 2    5      Pop 1, Pop 0, Push 2 [5]                 
# 3    1      Push 3               [5, 1]              
# 4    3      Pop 3, Push 4        [5, 3]              
# ============================================================
# Result: [5, 5, -1, 3, -1]
```

### Strategy 2: Visual Stack Drawing

```
DRAW THE STACK AT EACH STEP!

Example: Processing [4, 2, 5, 1, 3] for NGE

Step 0 (num=4):     Step 1 (num=2):     Step 2 (num=5):
    â”Œâ”€â”€â”€â”               â”Œâ”€â”€â”€â”               â”Œâ”€â”€â”€â”
    â”‚ 4 â”‚               â”‚ 2 â”‚               â”‚ 5 â”‚
    â””â”€â”€â”€â”˜               â”œâ”€â”€â”€â”¤               â””â”€â”€â”€â”˜
                        â”‚ 4 â”‚           
                        â””â”€â”€â”€â”˜           Pop 2 (NGE=5)
                                        Pop 4 (NGE=5)

Step 3 (num=1):     Step 4 (num=3):
    â”Œâ”€â”€â”€â”               â”Œâ”€â”€â”€â”
    â”‚ 1 â”‚               â”‚ 3 â”‚
    â”œâ”€â”€â”€â”¤               â”œâ”€â”€â”€â”¤
    â”‚ 5 â”‚               â”‚ 5 â”‚
    â””â”€â”€â”€â”˜               â””â”€â”€â”€â”˜
                    Pop 1 (NGE=3)

Final: Elements 5, 3 in stack have no NGE (-1)
```

### Strategy 3: Test with Edge Cases First

```python
def test_edge_cases(solution_func):
    """
    Test common edge cases
    """
    test_cases = [
        # Empty input
        ([], "Empty array"),
        
        # Single element
        ([5], "Single element"),
        
        # Two elements
        ([1, 2], "Two elements ascending"),
        ([2, 1], "Two elements descending"),
        
        # All same
        ([3, 3, 3, 3], "All same elements"),
        
        # Strictly increasing
        ([1, 2, 3, 4, 5], "Strictly increasing"),
        
        # Strictly decreasing
        ([5, 4, 3, 2, 1], "Strictly decreasing"),
        
        # Valley shape
        ([5, 3, 1, 3, 5], "Valley shape"),
        
        # Peak shape
        ([1, 3, 5, 3, 1], "Peak shape"),
    ]
    
    for test_input, description in test_cases:
        try:
            result = solution_func(test_input)
            print(f"âœ“ {description}: {test_input} â†’ {result}")
        except Exception as e:
            print(f"âœ— {description}: {test_input} â†’ ERROR: {e}")


# Usage:
test_edge_cases(nextGreaterElement)
```

---

## 12.3 Optimization Techniques

### Technique 1: Space Optimization for Min Stack

```python
# STANDARD: O(n) extra space
class MinStackStandard:
    def __init__(self):
        self.stack = []
        self.min_stack = []  # O(n) extra
    
    # ...


# OPTIMIZED: Store only when min changes
class MinStackOptimized:
    def __init__(self):
        self.stack = []
        self.min_stack = []
    
    def push(self, val):
        self.stack.append(val)
        # Only push if new min or equal
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)
    
    def pop(self):
        val = self.stack.pop()
        if val == self.min_stack[-1]:
            self.min_stack.pop()
    
    # Average case: much less space


# MOST OPTIMIZED: O(1) extra space with encoding
class MinStackO1Space:
    def __init__(self):
        self.stack = []
        self.min_val = float('inf')
    
    def push(self, val):
        if not self.stack:
            self.stack.append(val)
            self.min_val = val
        elif val >= self.min_val:
            self.stack.append(val)
        else:
            # Encode: store 2*val - min (always < val)
            self.stack.append(2 * val - self.min_val)
            self.min_val = val
    
    def pop(self):
        top = self.stack.pop()
        if top < self.min_val:
            # Decode: recover previous min
            self.min_val = 2 * self.min_val - top
    
    def top(self):
        top = self.stack[-1]
        return self.min_val if top < self.min_val else top
    
    def getMin(self):
        return self.min_val
```

### Technique 2: Single Pass vs Two Pass

```python
# TWO PASS: Clearer but slower
def histogram_two_pass(heights):
    n = len(heights)
    
    # Pass 1: Find PSE
    left = [-1] * n
    stack = []
    for i in range(n):
        while stack and heights[stack[-1]] >= heights[i]:
            stack.pop()
        left[i] = stack[-1] if stack else -1
        stack.append(i)
    
    # Pass 2: Find NSE
    right = [n] * n
    stack = []
    for i in range(n - 1, -1, -1):
        while stack and heights[stack[-1]] >= heights[i]:
            stack.pop()
        right[i] = stack[-1] if stack else n
        stack.append(i)
    
    # Calculate
    return max(heights[i] * (right[i] - left[i] - 1) for i in range(n))


# SINGLE PASS: More efficient
def histogram_single_pass(heights):
    heights = heights + [0]  # Sentinel
    stack = []
    max_area = 0
    
    for i, h in enumerate(heights):
        while stack and h < heights[stack[-1]]:
            height = heights[stack.pop()]
            width = i - stack[-1] - 1 if stack else i
            max_area = max(max_area, height * width)
        stack.append(i)
    
    return max_area


# WHEN TO USE EACH:
"""
Two Pass:
- Clearer logic, easier to debug
- Need both boundaries separately
- Teaching/learning scenarios

Single Pass:
- Production code
- Performance critical
- When you're confident in the logic
"""
```

### Technique 3: Sentinel Values

```python
# WITHOUT SENTINEL: Need to process remaining stack
def without_sentinel(heights):
    stack = []
    max_area = 0
    
    for i, h in enumerate(heights):
        while stack and h < heights[stack[-1]]:
            # ... process
            pass
        stack.append(i)
    
    # MUST process remaining!
    while stack:
        height = heights[stack.pop()]
        width = len(heights) - stack[-1] - 1 if stack else len(heights)
        max_area = max(max_area, height * width)
    
    return max_area


# WITH SENTINEL: Cleaner code
def with_sentinel(heights):
    heights = heights + [0]  # 0 forces all pops
    stack = []
    max_area = 0
    
    for i, h in enumerate(heights):
        while stack and h < heights[stack[-1]]:
            # ... process
            pass
        stack.append(i)
    
    # No cleanup needed!
    return max_area


# SENTINEL VALUES BY PROBLEM:
"""
â€¢ Histogram: Add 0 at end (forces pop of all bars)
â€¢ NGE: Initialize result with -1 (default for no answer)
â€¢ Parentheses: Add virtual '(' at start with index -1
â€¢ Expression: Add '+' at end (forces final computation)
"""
```

---

## 12.4 Pro Tips from Interview Experience

### Tip 1: Verbalize Your Thought Process

```
WHAT TO SAY DURING INTERVIEWS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. RECOGNIZE THE PATTERN:
   "This looks like a next greater element problem because
    we need to find the first element to the right that..."

2. EXPLAIN WHY STACK:
   "I'll use a stack because we need LIFO behavior - 
    the most recent unprocessed element matters most."

3. CLARIFY WHAT TO STORE:
   "I'll store indices rather than values because
    we need to calculate distances/widths."

4. STATE THE MONOTONIC PROPERTY:
   "I'll maintain a decreasing stack because
    we're looking for greater elements."

5. HANDLE EDGE CASES:
   "Let me consider: empty input, single element,
    all same values, strictly increasing/decreasing..."
```

### Tip 2: Start with Brute Force

```python
# ALWAYS mention brute force first, then optimize

# BRUTE FORCE: O(nÂ²)
def nge_brute(nums):
    """First explain this approach"""
    n = len(nums)
    result = [-1] * n
    
    for i in range(n):
        for j in range(i + 1, n):
            if nums[j] > nums[i]:
                result[i] = nums[j]
                break
    
    return result

# Then say: "This is O(nÂ²). We can optimize to O(n) using a stack..."

# OPTIMIZED: O(n)
def nge_optimal(nums):
    """Then present this"""
    result = [-1] * len(nums)
    stack = []
    
    for i, num in enumerate(nums):
        while stack and num > nums[stack[-1]]:
            result[stack.pop()] = num
        stack.append(i)
    
    return result
```

### Tip 3: Use Meaningful Variable Names

```python
# âŒ BAD - Hard to follow
def solve(a):
    s = []
    r = [-1] * len(a)
    for i in range(len(a)):
        while s and a[i] > a[s[-1]]:
            r[s.pop()] = a[i]
        s.append(i)
    return r


# âœ… GOOD - Self-documenting
def nextGreaterElement(nums):
    result = [-1] * len(nums)
    decreasing_stack = []  # Stores indices of elements awaiting NGE
    
    for current_idx, current_val in enumerate(nums):
        # Pop elements smaller than current (found their NGE)
        while decreasing_stack and current_val > nums[decreasing_stack[-1]]:
            smaller_idx = decreasing_stack.pop()
            result[smaller_idx] = current_val
        
        decreasing_stack.append(current_idx)
    
    return result
```

### Tip 4: Know Multiple Approaches

```python
# TRAPPING RAIN WATER - Three approaches!

# Approach 1: Stack
def trap_stack(height):
    stack = []
    water = 0
    for i, h in enumerate(height):
        while stack and h > height[stack[-1]]:
            bottom = stack.pop()
            if not stack:
                break
            width = i - stack[-1] - 1
            depth = min(h, height[stack[-1]]) - height[bottom]
            water += width * depth
        stack.append(i)
    return water


# Approach 2: Two Pointers (O(1) space!)
def trap_two_pointer(height):
    left, right = 0, len(height) - 1
    left_max = right_max = 0
    water = 0
    
    while left < right:
        if height[left] < height[right]:
            left_max = max(left_max, height[left])
            water += left_max - height[left]
            left += 1
        else:
            right_max = max(right_max, height[right])
            water += right_max - height[right]
            right -= 1
    
    return water


# Approach 3: DP (Precompute left_max and right_max)
def trap_dp(height):
    n = len(height)
    if n == 0:
        return 0
    
    left_max = [0] * n
    right_max = [0] * n
    
    left_max[0] = height[0]
    for i in range(1, n):
        left_max[i] = max(left_max[i-1], height[i])
    
    right_max[-1] = height[-1]
    for i in range(n-2, -1, -1):
        right_max[i] = max(right_max[i+1], height[i])
    
    return sum(min(left_max[i], right_max[i]) - height[i] for i in range(n))


# INTERVIEWER LOVES when you know multiple approaches!
```

### Tip 5: Common Follow-up Questions and Answers

```
Q: "Can you do it in O(1) space?"
A: Consider two-pointer approach or mathematical tricks.
   For Min Stack, there's an encoding technique.

Q: "What if the array has duplicates?"
A: Use strict inequality on one side (< vs <=).
   This ensures each element is counted exactly once.

Q: "Can you handle it as a stream/online?"
A: Design class with methods instead of function.
   See Online Stock Span pattern.

Q: "What if the array is circular?"
A: Process 2n elements (go around twice).
   Use modulo: i % n for actual index.

Q: "Can you do it without extra space?"
A: Sometimes possible by modifying input (ask if allowed)
   or using input array itself as stack.
```

---

## 12.5 Final Checklist Before Submitting

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              PRE-SUBMISSION CHECKLIST                              â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                    â•‘
â•‘  â–¡ Empty stack check before every pop/peek                         â•‘
â•‘                                                                    â•‘
â•‘  â–¡ Correct data stored (values vs indices)                         â•‘
â•‘                                                                    â•‘
â•‘  â–¡ Right comparison direction (< vs > vs <= vs >=)                 â•‘
â•‘                                                                    â•‘
â•‘  â–¡ Remaining stack elements handled                                â•‘
â•‘                                                                    â•‘
â•‘  â–¡ Off-by-one errors in width/boundary calculations                â•‘
â•‘                                                                    â•‘
â•‘  â–¡ Duplicate handling if needed                                    â•‘
â•‘                                                                    â•‘
â•‘  â–¡ Input not accidentally modified                                 â•‘
â•‘                                                                    â•‘
â•‘  â–¡ Correct loop direction (left-to-right vs right-to-left)         â•‘
â•‘                                                                    â•‘
â•‘  â–¡ Integer division handles negatives correctly                    â•‘
â•‘                                                                    â•‘
â•‘  â–¡ Edge cases tested:                                              â•‘
â•‘    â–¡ Empty input                                                   â•‘
â•‘    â–¡ Single element                                                â•‘
â•‘    â–¡ All same elements                                             â•‘
â•‘    â–¡ Strictly increasing                                           â•‘
â•‘    â–¡ Strictly decreasing                                           â•‘
â•‘                                                                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## 12.6 Quick Debug Reference

```
SYMPTOM â†’ LIKELY CAUSE â†’ FIX
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IndexError on stack[-1]
â†’ Empty stack access
â†’ Add "if stack" check

Wrong NGE values
â†’ Wrong comparison direction
â†’ Use > for NGE, < for NSE

Some results are None/-1 when shouldn't be
â†’ Forgot to process remaining stack
â†’ Add sentinel or process remaining

Width off by 1 or 2
â†’ Boundary calculation error
â†’ Use: width = right - left - 1

Double counting with duplicates
â†’ Same comparison both sides
â†’ Use > one side, >= other side

Wrong result for negative numbers
â†’ Integer division issue
â†’ Use int(a/b) instead of a//b

Works for examples but fails edge cases
â†’ Not handling empty/single element
â†’ Add explicit edge case handling
```

---

**Master these mistakes and tips, and you'll ace any stack interview! ğŸš€**
