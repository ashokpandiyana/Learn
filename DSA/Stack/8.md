# Chapter 8: Advanced Problem Patterns

## 8.1 Asteroid Collision Pattern

Problems where elements interact, cancel, or modify each other based on direction and properties.

### Problem: Asteroid Collision (LeetCode 735)

```
PROBLEM:
═══════════════════════════════════════════════════════════════

Asteroids moving in a row. Positive = right, Negative = left.
When two collide: smaller explodes, equal = both explode.
Same direction = no collision.

Example: [5, 10, -5]
- 5 and 10 move right (no collision)
- 10 and -5 collide: |10| > |-5|, so -5 explodes
Result: [5, 10]

Example: [8, -8]
- Both explode
Result: []

Example: [-2, -1, 1, 2]
- -2 and -1 move left, 1 and 2 move right
- No collision (moving apart)
Result: [-2, -1, 1, 2]
```

### Key Insight

```
COLLISION CONDITIONS:
═══════════════════════════════════════════════════════════════

Stack stores surviving asteroids (processed so far)

New asteroid coming in:

COLLISION HAPPENS when:
- Stack top is positive (moving right) →
- New asteroid is negative (moving left) ←
- They're moving toward each other!

NO COLLISION when:
- Stack empty
- Stack top is negative (both moving left)
- New is positive (moving right, away from stack)

Visual:
    Stack: [..., +5]    New: -3
           →            ←
         COLLISION!
    
    Stack: [..., -5]    New: -3
           ←            ←
         No collision (same direction)
```

### Implementation

```python
def asteroidCollision(asteroids):
    """
    Asteroid Collision using stack
    
    Stack stores surviving asteroids.
    Process collisions when positive top meets negative incoming.
    
    Time: O(n), Space: O(n)
    """
    stack = []
    
    for asteroid in asteroids:
        alive = True
        
        # Check for collisions
        # Collision: stack top > 0 (right) and asteroid < 0 (left)
        while stack and stack[-1] > 0 and asteroid < 0:
            # Compare sizes
            if stack[-1] < abs(asteroid):
                # Stack top explodes, continue checking
                stack.pop()
            elif stack[-1] == abs(asteroid):
                # Both explode
                stack.pop()
                alive = False
                break
            else:
                # Incoming asteroid explodes
                alive = False
                break
        
        if alive:
            stack.append(asteroid)
    
    return stack


# TRACE: [5, 10, -5]
"""
asteroid=5:   stack=[], no collision, push → [5]
asteroid=10:  stack=[5], 5>0 but 10>0, no collision → [5,10]
asteroid=-5:  stack=[5,10], 10>0 and -5<0, COLLISION
              |10| > |-5|, -5 explodes, alive=False
              
Result: [5, 10]
"""

# TRACE: [10, 2, -5]
"""
asteroid=10:  push → [10]
asteroid=2:   push → [10, 2]
asteroid=-5:  
  - 2 > 0, -5 < 0: collision, |2| < |-5|, pop 2 → [10]
  - 10 > 0, -5 < 0: collision, |10| > |-5|, -5 dies
  
Result: [10]
"""
```

### Variant: Robot Collisions (LeetCode 2751)

```python
def survivedRobotsHealths(positions, healths, directions):
    """
    Robots have positions, health, and directions ('L' or 'R')
    Collision: lower health robot destroyed, winner loses 1 health
    Equal health: both destroyed
    
    Key: Sort by position, then use stack
    """
    n = len(positions)
    # Create robots with original indices
    robots = [(positions[i], healths[i], directions[i], i) 
              for i in range(n)]
    
    # Sort by position (left to right)
    robots.sort()
    
    stack = []  # Stack of (health, direction, original_index)
    
    for pos, health, direction, idx in robots:
        alive = True
        
        # Collision: stack has 'R', current is 'L'
        while stack and stack[-1][1] == 'R' and direction == 'L' and alive:
            if stack[-1][0] < health:
                # Stack top destroyed
                stack.pop()
                health -= 1
            elif stack[-1][0] > health:
                # Current destroyed, stack top loses health
                h, d, i = stack.pop()
                stack.append((h - 1, d, i))
                alive = False
            else:
                # Both destroyed
                stack.pop()
                alive = False
        
        if alive and health > 0:
            stack.append((health, direction, idx))
    
    # Build result in original order
    result = [0] * n
    for health, _, idx in stack:
        result[idx] = health
    
    return [h for h in result if h > 0]
```

---

## 8.2 Span/Range Problems

### Stock Span Variations

```python
# Online Stock Span (covered in Chapter 3)
class StockSpanner:
    def __init__(self):
        self.stack = []  # (price, span)
    
    def next(self, price):
        span = 1
        while self.stack and self.stack[-1][0] <= price:
            span += self.stack.pop()[1]
        self.stack.append((price, span))
        return span


# Daily Temperatures - Return days until warmer
def dailyTemperatures(temperatures):
    n = len(temperatures)
    result = [0] * n
    stack = []  # indices
    
    for i in range(n):
        while stack and temperatures[i] > temperatures[stack[-1]]:
            prev = stack.pop()
            result[prev] = i - prev
        stack.append(i)
    
    return result
```

### Sum of Subarray Minimums (LeetCode 907) ⭐⭐

```python
def sumSubarrayMins(arr):
    """
    Sum of minimum elements across all subarrays
    
    CONTRIBUTION TECHNIQUE:
    For each element, count subarrays where it's the minimum
    contribution = arr[i] × left_count × right_count
    
    left_count: subarrays ending at i where arr[i] is min
    right_count: subarrays starting at i where arr[i] is min
    """
    MOD = 10**9 + 7
    n = len(arr)
    
    # Previous smaller element distances
    left = [0] * n
    stack = []
    for i in range(n):
        while stack and arr[stack[-1]] > arr[i]:
            stack.pop()
        left[i] = i - stack[-1] if stack else i + 1
        stack.append(i)
    
    # Next smaller or equal element distances
    right = [0] * n
    stack = []
    for i in range(n - 1, -1, -1):
        while stack and arr[stack[-1]] >= arr[i]:
            stack.pop()
        right[i] = stack[-1] - i if stack else n - i
        stack.append(i)
    
    # Calculate sum of contributions
    result = 0
    for i in range(n):
        result = (result + arr[i] * left[i] * right[i]) % MOD
    
    return result


# WHY >= ON ONE SIDE?
"""
To avoid double counting duplicates!

Example: [1, 2, 1]

If both sides use >, middle 2 is counted for:
- Subarrays involving left 1: counted by left 1
- Subarrays involving right 1: counted by right 1
- Some subarrays counted twice!

Solution: Use > on left, >= on right (or vice versa)
Each subarray's minimum is attributed to exactly one element.
"""
```

### Sum of Subarray Ranges (LeetCode 2104) ⭐⭐

```python
def subArrayRanges(nums):
    """
    Sum of (max - min) for all subarrays
    
    = Sum of all subarray maximums - Sum of all subarray minimums
    
    Use contribution technique for both max and min
    """
    n = len(nums)
    
    def sumOfMins():
        left = [0] * n
        right = [0] * n
        stack = []
        
        for i in range(n):
            while stack and nums[stack[-1]] > nums[i]:
                stack.pop()
            left[i] = i - stack[-1] if stack else i + 1
            stack.append(i)
        
        stack = []
        for i in range(n - 1, -1, -1):
            while stack and nums[stack[-1]] >= nums[i]:
                stack.pop()
            right[i] = stack[-1] - i if stack else n - i
            stack.append(i)
        
        return sum(nums[i] * left[i] * right[i] for i in range(n))
    
    def sumOfMaxs():
        left = [0] * n
        right = [0] * n
        stack = []
        
        for i in range(n):
            while stack and nums[stack[-1]] < nums[i]:
                stack.pop()
            left[i] = i - stack[-1] if stack else i + 1
            stack.append(i)
        
        stack = []
        for i in range(n - 1, -1, -1):
            while stack and nums[stack[-1]] <= nums[i]:
                stack.pop()
            right[i] = stack[-1] - i if stack else n - i
            stack.append(i)
        
        return sum(nums[i] * left[i] * right[i] for i in range(n))
    
    return sumOfMaxs() - sumOfMins()
```

---

## 8.3 Maximum Rectangle Pattern

### Maximal Rectangle (LeetCode 85) ⭐⭐⭐

```
PROBLEM:
═══════════════════════════════════════════════════════════════

Find largest rectangle containing only 1s in binary matrix.

Matrix:
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

Answer: 6 (the 2×3 rectangle in rows 2-3, cols 2-4)

KEY INSIGHT: Transform to histogram problem!

For each row, calculate "heights" (consecutive 1s above including current)
Then apply "Largest Rectangle in Histogram" for each row.
```

```python
def maximalRectangle(matrix):
    """
    Maximal Rectangle using histogram per row
    
    For each row, build histogram of heights
    Apply largest rectangle in histogram
    
    Time: O(rows × cols), Space: O(cols)
    """
    if not matrix or not matrix[0]:
        return 0
    
    rows, cols = len(matrix), len(matrix[0])
    heights = [0] * cols
    max_area = 0
    
    for row in range(rows):
        # Update heights
        for col in range(cols):
            if matrix[row][col] == '1':
                heights[col] += 1
            else:
                heights[col] = 0
        
        # Calculate max rectangle for this histogram
        max_area = max(max_area, largestRectangleInHistogram(heights))
    
    return max_area


def largestRectangleInHistogram(heights):
    """Largest rectangle using monotonic stack"""
    heights = heights + [0]  # Sentinel
    stack = []
    max_area = 0
    
    for i, h in enumerate(heights):
        while stack and heights[stack[-1]] > h:
            height = heights[stack.pop()]
            width = i - stack[-1] - 1 if stack else i
            max_area = max(max_area, height * width)
        stack.append(i)
    
    return max_area


# ROW-BY-ROW TRACE:
"""
Matrix:
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

Row 0: heights = [1, 0, 1, 0, 0]
       Max rect = 1

Row 1: heights = [2, 0, 2, 1, 1]
       Max rect = 3 (1×3 at indices 2,3,4)

Row 2: heights = [3, 1, 3, 2, 2]
       Max rect = 6 (2×3 at indices 2,3,4)

Row 3: heights = [4, 0, 0, 3, 0]
       Max rect = 4 (4×1 at index 0)

Overall max = 6
"""
```

### Maximum Binary Tree (LeetCode 654)

```python
def constructMaximumBinaryTree(nums):
    """
    Build tree where root is max element
    Left subtree from left portion, right from right portion
    
    Stack approach: O(n) time
    
    Insight: Use decreasing stack
    When we see larger element, it becomes parent of smaller elements
    """
    stack = []  # Stack of TreeNodes
    
    for num in nums:
        node = TreeNode(num)
        
        # Pop smaller elements, they become left child
        while stack and stack[-1].val < num:
            node.left = stack.pop()
        
        # If stack not empty, current becomes right child of top
        if stack:
            stack[-1].right = node
        
        stack.append(node)
    
    # Root is bottom of stack (first element)
    return stack[0] if stack else None


# TRACE for [3, 2, 1, 6, 0, 5]:
"""
num=3: stack=[3]
num=2: 2 < 3, stack=[3, 2], 3.right = 2
num=1: 1 < 2, stack=[3, 2, 1], 2.right = 1
num=6: 6 > 1, pop 1, 6.left = 1
       6 > 2, pop 2, 6.left = 2 (1 is left of 2)
       6 > 3, pop 3, 6.left = 3
       stack=[6]
num=0: stack=[6, 0], 6.right = 0
num=5: 5 > 0, pop 0, 5.left = 0
       stack=[6, 5], 6.right = 5

Result:
       6
      / \
     3   5
      \  /
      2 0
       \
        1
"""
```

---

## 8.4 Nested Structure Problems

### Number of Atoms (LeetCode 726)

```python
def countOfAtoms(formula):
    """
    Parse chemical formula and count atoms
    
    "Mg(OH)2" → {"Mg": 1, "O": 2, "H": 2}
    "K4(ON(SO3)2)2" → {"K": 4, "O": 14, "N": 2, "S": 4}
    
    Stack stores: dict of counts at each nesting level
    On '(': push new dict
    On ')': pop and multiply, merge with parent
    """
    from collections import defaultdict
    
    stack = [defaultdict(int)]
    i = 0
    n = len(formula)
    
    while i < n:
        if formula[i] == '(':
            # Start new group
            stack.append(defaultdict(int))
            i += 1
        
        elif formula[i] == ')':
            # End group, get multiplier
            i += 1
            
            # Parse number after ')'
            start = i
            while i < n and formula[i].isdigit():
                i += 1
            multiplier = int(formula[start:i]) if start < i else 1
            
            # Pop and merge
            top = stack.pop()
            for atom, count in top.items():
                stack[-1][atom] += count * multiplier
        
        else:
            # Parse atom name (uppercase + lowercase*)
            start = i
            i += 1
            while i < n and formula[i].islower():
                i += 1
            atom = formula[start:i]
            
            # Parse count
            start = i
            while i < n and formula[i].isdigit():
                i += 1
            count = int(formula[start:i]) if start < i else 1
            
            stack[-1][atom] += count
    
    # Format result
    result = stack[0]
    return ''.join(f"{atom}{count if count > 1 else ''}" 
                   for atom, count in sorted(result.items()))


# TRACE for "K4(ON(SO3)2)2":
"""
K4:      stack = [{K:4}]
(:       stack = [{K:4}, {}]
O:       stack = [{K:4}, {O:1}]
N:       stack = [{K:4}, {O:1, N:1}]
(:       stack = [{K:4}, {O:1, N:1}, {}]
S:       stack = [{K:4}, {O:1, N:1}, {S:1}]
O3:      stack = [{K:4}, {O:1, N:1}, {S:1, O:3}]
)2:      pop {S:1, O:3}, multiply by 2, merge
         stack = [{K:4}, {O:1+6=7, N:1, S:2}]
)2:      pop {O:7, N:1, S:2}, multiply by 2, merge
         stack = [{K:4, O:14, N:2, S:4}]

Result: K4N2O14S4
"""
```

### Decode String (LeetCode 394) - Already in Chapter 2

### Parse Lisp Expression (LeetCode 736)

```python
def evaluate(expression):
    """
    Evaluate Lisp-like expression
    
    (let x 2 (mult x (let x 3 y 4 (add x y))))
    
    Operations: add, mult, let
    Stack maintains variable scopes
    """
    def parse_token(expr, i):
        """Parse next token starting at i"""
        if expr[i] == '(':
            return parse_expr(expr, i)
        elif expr[i] == '-' or expr[i].isdigit():
            # Number
            j = i + 1
            while j < len(expr) and expr[j].isdigit():
                j += 1
            return int(expr[i:j]), j
        else:
            # Variable
            j = i
            while j < len(expr) and expr[j] not in ' )':
                j += 1
            return expr[i:j], j
    
    def parse_expr(expr, i):
        """Parse expression starting with '(' at i"""
        i += 1  # Skip '('
        
        if expr[i:i+3] == 'add':
            i += 4
            a, i = parse_token(expr, i)
            i += 1  # Skip space
            b, i = parse_token(expr, i)
            return evaluate_value(a) + evaluate_value(b), i + 1
        
        elif expr[i:i+4] == 'mult':
            i += 5
            a, i = parse_token(expr, i)
            i += 1
            b, i = parse_token(expr, i)
            return evaluate_value(a) * evaluate_value(b), i + 1
        
        else:  # let
            i += 4
            scope.append({})
            
            while True:
                var, i = parse_token(expr, i)
                if expr[i] == ')':
                    # Last expression - evaluate and return
                    result = evaluate_value(var)
                    scope.pop()
                    return result, i + 1
                i += 1  # Skip space
                val, i = parse_token(expr, i)
                scope[-1][var] = evaluate_value(val)
                if i < len(expr) and expr[i] == ' ':
                    i += 1
    
    def evaluate_value(v):
        if isinstance(v, int):
            return v
        # Look up variable in scopes (innermost first)
        for s in reversed(scope):
            if v in s:
                return s[v]
        return v
    
    scope = [{}]  # Stack of variable scopes
    result, _ = parse_token(expression, 0)
    return evaluate_value(result)
```

---

## 8.5 Validation Problems

### Valid Parenthesis String (LeetCode 678)

```python
def checkValidString(s):
    """
    Parentheses with '*' that can be '(', ')' or empty
    
    Two-stack approach: Track possible positions
    
    Time: O(n), Space: O(n)
    """
    left_stack = []   # Indices of '('
    star_stack = []   # Indices of '*'
    
    for i, char in enumerate(s):
        if char == '(':
            left_stack.append(i)
        elif char == '*':
            star_stack.append(i)
        else:  # char == ')'
            if left_stack:
                left_stack.pop()
            elif star_stack:
                star_stack.pop()  # Use '*' as '('
            else:
                return False
    
    # Match remaining '(' with '*' that comes AFTER
    while left_stack and star_stack:
        if left_stack[-1] > star_stack[-1]:
            return False  # '(' after '*', can't match
        left_stack.pop()
        star_stack.pop()
    
    return len(left_stack) == 0


# Alternative: Greedy O(1) space
def checkValidString_greedy(s):
    """
    Track range of possible open count [low, high]
    
    '(' increases both by 1
    ')' decreases both by 1
    '*' decreases low by 1, increases high by 1
    
    Valid if 0 is within range at end
    """
    low = high = 0
    
    for char in s:
        if char == '(':
            low += 1
            high += 1
        elif char == ')':
            low -= 1
            high -= 1
        else:  # '*'
            low -= 1   # '*' as ')'
            high += 1  # '*' as '('
        
        if high < 0:
            return False  # Too many ')'
        
        low = max(low, 0)  # Can't have negative open count
    
    return low == 0
```

### Minimum Insertions to Balance (LeetCode 1541)

```python
def minInsertions(s):
    """
    Each '(' needs TWO ')' to match
    
    Return minimum insertions to balance
    """
    insertions = 0
    open_count = 0  # Unmatched '(' count
    i = 0
    
    while i < len(s):
        if s[i] == '(':
            open_count += 1
            i += 1
        else:  # s[i] == ')'
            if i + 1 < len(s) and s[i + 1] == ')':
                # Found "))"
                if open_count > 0:
                    open_count -= 1
                else:
                    insertions += 1  # Need '(' before "))"
                i += 2
            else:
                # Single ')', need another ')'
                insertions += 1
                if open_count > 0:
                    open_count -= 1
                else:
                    insertions += 1  # Also need '('
                i += 1
    
    # Each remaining '(' needs two ')'
    insertions += open_count * 2
    
    return insertions
```

---

## 8.6 Car Fleet Pattern

### Car Fleet (LeetCode 853)

```python
def carFleet(target, position, speed):
    """
    Cars on road, catch up and form fleet at slower speed
    
    Key: Cars that arrive later cannot pass cars arriving earlier
    Process from closest to target
    
    Stack stores: arrival times of fleets
    """
    # Pair positions with times to reach target
    cars = sorted(zip(position, speed), reverse=True)
    
    stack = []  # Arrival times of fleets
    
    for pos, spd in cars:
        time = (target - pos) / spd
        
        if not stack or time > stack[-1]:
            # This car arrives later, forms new fleet
            stack.append(time)
        # Else: car catches up to fleet ahead, merges
    
    return len(stack)


# VISUALIZATION:
"""
target = 12, position = [10, 8, 0, 5, 3], speed = [2, 4, 1, 1, 3]

Sorted by position (descending):
pos=10, speed=2: time = (12-10)/2 = 1
pos=8,  speed=4: time = (12-8)/4 = 1
pos=5,  speed=1: time = (12-5)/1 = 7
pos=3,  speed=3: time = (12-3)/3 = 3
pos=0,  speed=1: time = (12-0)/1 = 12

Process:
time=1:  stack = [1]
time=1:  1 <= 1, catches up, stack = [1]
time=7:  7 > 1, new fleet, stack = [1, 7]
time=3:  3 <= 7, catches up, stack = [1, 7]
time=12: 12 > 7, new fleet, stack = [1, 7, 12]

Answer: 3 fleets
"""
```

### Car Fleet II (LeetCode 1776) ⭐⭐⭐

```python
def getCollisionTimes(cars):
    """
    Return time each car collides with car ahead
    
    Reverse process: car can only collide with car ahead
    Stack: cars that haven't been "caught up to" yet
    """
    n = len(cars)
    result = [-1.0] * n
    stack = []  # Indices of cars ahead
    
    # Process from rightmost car
    for i in range(n - 1, -1, -1):
        pos, speed = cars[i]
        
        while stack:
            j = stack[-1]
            pos_j, speed_j = cars[j]
            
            # If current car is slower or same speed, can't catch up
            if speed <= speed_j:
                stack.pop()
                continue
            
            # Time to catch up to car j
            time = (pos_j - pos) / (speed - speed_j)
            
            # If car j collides with another car before we reach it
            if result[j] > 0 and time > result[j]:
                stack.pop()
                continue
            
            # Valid collision
            result[i] = time
            break
        
        stack.append(i)
    
    return result
```

---

## 8.7 Summary: Advanced Patterns

```
┌────────────────────────────────────────────────────────────────────┐
│           ADVANCED STACK PATTERNS CHEATSHEET                       │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│ COLLISION PATTERN:                                                 │
│ ─────────────────────────────                                      │
│ • Stack stores "survivors"                                         │
│ • Check collision conditions on push                               │
│ • Pop losers, modify winners                                       │
│ • Direction matters (left vs right)                                │
│                                                                    │
│ CONTRIBUTION TECHNIQUE:                                            │
│ ─────────────────────────────                                      │
│ • For sum of subarray min/max/ranges                               │
│ • contribution = value × left_count × right_count                  │
│ • Use > on one side, >= on other for duplicates                    │
│                                                                    │
│ HISTOGRAM EXTENSION:                                               │
│ ─────────────────────────────                                      │
│ • Binary matrix → Build histogram per row                          │
│ • Apply largest rectangle in histogram                             │
│ • Maximum Binary Tree uses similar idea                            │
│                                                                    │
│ NESTED PARSING:                                                    │
│ ─────────────────────────────                                      │
│ • Stack of scopes/contexts                                         │
│ • Push on '(' or '[', pop on ')' or ']'                           │
│ • Multiply/merge on closing                                        │
│                                                                    │
│ VALIDATION:                                                        │
│ ─────────────────────────────                                      │
│ • Track ranges [low, high] for wildcards                          │
│ • Two stacks for position-dependent matching                       │
│                                                                    │
│ CAR FLEET:                                                         │
│ ─────────────────────────────                                      │
│ • Sort by position, process from target                            │
│ • Slower car ahead blocks faster cars behind                       │
│ • Stack stores fleet arrival times                                 │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

---

## Practice Problems

| Problem | Pattern | Difficulty |
|---------|---------|------------|
| Asteroid Collision | Collision | Medium |
| Robot Collisions | Collision | Hard |
| Sum of Subarray Minimums | Contribution | Medium |
| Sum of Subarray Ranges | Contribution | Medium |
| Sum of Total Strength of Wizards | Contribution | Hard |
| Maximal Rectangle | Histogram | Hard |
| Maximum Binary Tree | Decreasing Stack | Medium |
| Number of Atoms | Nested Parsing | Hard |
| Valid Parenthesis String | Validation | Medium |
| Car Fleet | Merge Pattern | Medium |
| Car Fleet II | Collision Times | Hard |
| Number of Visible People | Monotonic | Hard |
