# Complete Stack Data Structure Mastery Guide
## From Fundamentals to Hard Interview Patterns

---

# PART 1: FOUNDATIONS

## Chapter 1: Stack Fundamentals

### 1.1 What is a Stack?
- **Definition**: A linear data structure following **LIFO** (Last In, First Out) principle
- **Real-world analogy**: Stack of plates, undo operations, browser back button
- **Abstract Data Type (ADT)** with restricted access points

### 1.2 Core Operations
| Operation | Description | Time Complexity |
|-----------|-------------|-----------------|
| `push(x)` | Add element to top | O(1) |
| `pop()` | Remove & return top element | O(1) |
| `peek()/top()` | View top element without removal | O(1) |
| `isEmpty()` | Check if stack is empty | O(1) |
| `size()` | Return number of elements | O(1) |

### 1.3 Implementation Approaches

#### Array-Based Implementation
```
Pros: Cache-friendly, simple indexing
Cons: Fixed size (unless dynamic), potential overflow
Space: O(n)
```

#### Linked List-Based Implementation
```
Pros: Dynamic size, no overflow
Cons: Extra memory for pointers, not cache-friendly
Space: O(n) + pointer overhead
```

> âš ï¸ **IMPORTANT**: In interviews, clarify which implementation is expected. Array-based is more common.

---

## Chapter 2: Basic Stack Problems

### 2.1 Parentheses Matching Family

#### Problem Types:
1. **Valid Parentheses** - Single type `()`
2. **Valid Parentheses** - Multiple types `(){}[]`
3. **Minimum Add to Make Valid**
4. **Minimum Remove to Make Valid**
5. **Longest Valid Parentheses** â­ (Hard)
6. **Score of Parentheses**

#### Core Pattern:
```
For opening bracket â†’ PUSH
For closing bracket â†’ Check TOP, then POP if match
```

> ğŸ’¡ **KEY INSIGHT**: For longest valid parentheses, use stack to store INDICES, not characters!

### 2.2 Basic Expression Problems
1. Reverse a string using stack
2. Check palindrome
3. Remove adjacent duplicates
4. Decode strings (nested patterns)

---

# PART 2: INTERMEDIATE PATTERNS

## Chapter 3: Monotonic Stack Pattern â­â­â­

> ğŸ”¥ **CRITICAL**: This is the MOST IMPORTANT stack pattern for hard interviews!

### 3.1 What is Monotonic Stack?
A stack that maintains elements in **sorted order** (increasing or decreasing)

### 3.2 Types of Monotonic Stack

#### Monotonically Increasing Stack
- Elements from bottom to top are in **increasing** order
- Used to find: **Next Smaller Element**, **Previous Smaller Element**

#### Monotonically Decreasing Stack
- Elements from bottom to top are in **decreasing** order  
- Used to find: **Next Greater Element**, **Previous Greater Element**

### 3.3 The Four Fundamental Queries

| Query | Stack Type | Traverse Direction |
|-------|------------|-------------------|
| Next Greater Element (NGE) | Decreasing | Left to Right |
| Next Smaller Element (NSE) | Increasing | Left to Right |
| Previous Greater Element (PGE) | Decreasing | Left to Right |
| Previous Smaller Element (PSE) | Increasing | Left to Right |

### 3.4 Template Code Pattern
```
Initialize empty stack
For each element (index i):
    While stack not empty AND current breaks monotonic property:
        Pop and process (this is where the "answer" is found)
    Push current element/index
```

### 3.5 Classic Monotonic Stack Problems

#### Tier 1 - Must Know:
1. **Next Greater Element I, II, III**
2. **Daily Temperatures**
3. **Stock Span Problem**
4. **Largest Rectangle in Histogram** â­â­â­ (VERY IMPORTANT)
5. **Maximal Rectangle in Binary Matrix**
6. **Trapping Rain Water**

#### Tier 2 - Important:
7. **Remove K Digits**
8. **Remove Duplicate Letters**
9. **Create Maximum Number**
10. **Sum of Subarray Minimums**
11. **Sum of Subarray Ranges**
12. **Maximum Width Ramp**

> ğŸ’¡ **PRO TIP**: When you see "next/previous greater/smaller" â†’ Think Monotonic Stack immediately!

### 3.6 Histogram Pattern Deep Dive

**Problem**: Largest Rectangle in Histogram

**Key Insight**: For each bar, find:
- Left boundary (previous smaller element)
- Right boundary (next smaller element)
- Width = right_boundary - left_boundary - 1
- Area = height Ã— width

**Why it matters**: This pattern extends to:
- Maximal Rectangle in Matrix
- Maximum Binary Tree
- Many DP optimization problems

---

## Chapter 4: Expression Evaluation

### 4.1 Notation Types
| Type | Example | Stack Usage |
|------|---------|-------------|
| Infix | `A + B * C` | Need operator precedence |
| Prefix (Polish) | `+ A * B C` | Single stack, Râ†’L |
| Postfix (RPN) | `A B C * +` | Single stack, Lâ†’R |

### 4.2 Conversion Problems
1. Infix â†’ Postfix (Shunting Yard Algorithm)
2. Infix â†’ Prefix
3. Postfix â†’ Infix
4. Prefix â†’ Infix

### 4.3 Evaluation Problems
1. **Basic Calculator I** - `+`, `-`, `(`, `)`
2. **Basic Calculator II** - `+`, `-`, `*`, `/`
3. **Basic Calculator III** - All operators + parentheses â­â­
4. **Evaluate Reverse Polish Notation**

### 4.4 Operator Precedence Table
```
Highest:  ( )
          * /
Lowest:   + -
```

> âš ï¸ **TRICKY**: Handle negative numbers! `-3 + 2` vs `3 - 2`

### 4.5 Two-Stack Approach for Calculator
```
Stack 1: Numbers/Operands
Stack 2: Operators

On '(' â†’ Push to operator stack
On ')' â†’ Process until '(' found
On operator â†’ Process higher/equal precedence first, then push
On number â†’ Push to number stack
```

---

## Chapter 5: Stack in String Manipulation

### 5.1 Problem Categories

#### Decoding/Parsing:
1. **Decode String** - `3[a2[c]]` â†’ `accaccacc`
2. **Number of Atoms** - `Mg(OH)2` â†’ `{Mg:1, O:2, H:2}`
3. **Brace Expansion**
4. **Parse Lisp Expression**

#### Simplification:
1. **Remove All Adjacent Duplicates**
2. **Remove All Adjacent Duplicates II** (k consecutive)
3. **Simplify Path** - Unix path simplification
4. **Remove Outermost Parentheses**
5. **Minimum String After Removing Substrings**

#### Construction:
1. **Build Smallest Lexicographic String**
2. **Remove Duplicate Letters** (smallest subsequence)
3. **Construct Smallest Number from DI String**

### 5.2 Pattern Recognition

> ğŸ’¡ When you see **nested structures** or **matching pairs** â†’ Think Stack!

---

# PART 3: ADVANCED PATTERNS

## Chapter 6: Stack + Other Data Structures

### 6.1 Stack + Queue
- **Implement Queue using Stacks** (2 stacks)
- **Implement Stack using Queues**

> ğŸ”¥ **AMORTIZED ANALYSIS**: Push O(1), Pop O(1) amortized with lazy transfer!

### 6.2 Stack + Heap/Priority Queue
- **Maximum Frequency Stack** â­â­ (Hard)
- **Stock Price Fluctuation**

### 6.3 Min/Max Stack Pattern â­â­

**Problem**: Design stack with O(1) getMin/getMax

**Approaches**:
1. **Two Stack Method**: Auxiliary stack for min values
2. **Single Stack + Math**: Store `2*x - min` when x < min
3. **Stack of Pairs**: `(value, current_min)`

**Space Optimization Trick**:
```
Push: if x <= min, push old min first, update min
Pop: if popped value == min, pop again to get new min
```

### 6.4 Stack + HashMap
- **Next Greater Element I** (two arrays)
- **Maximum Frequency Stack**
- **LRU Cache variations**

---

## Chapter 7: Design Problems

### 7.1 Must-Know Stack Designs

1. **Min Stack** - getMin() in O(1)
2. **Max Stack** - getMax() + popMax() in O(1)
3. **Frequency Stack** - Pop most frequent element
4. **Browser History** - Back/Forward navigation
5. **Text Editor with Undo/Redo**
6. **Custom Stack with Increment Operation**

### 7.2 Design Pattern Template
```
Consider:
- What operations are needed?
- What time complexity is required?
- What auxiliary data structures help?
- How to handle edge cases?
```

---

## Chapter 8: Recursion and Stack

### 8.1 Call Stack Understanding
- Every recursive call uses implicit stack
- Stack overflow = too deep recursion
- **Tail recursion optimization**

### 8.2 Converting Recursion to Iteration
> ğŸ’¡ Any recursive algorithm can be converted to iterative using explicit stack

**Applications**:
1. Tree traversals (Inorder, Preorder, Postorder)
2. Graph DFS
3. Backtracking problems
4. Divide and conquer

### 8.3 Tree Traversal Patterns

#### Iterative Inorder (Important!)
```
While stack not empty OR node not null:
    Go left as far as possible (push all)
    Pop and process
    Move to right
```

#### Iterative Preorder
```
Push root
While stack not empty:
    Pop and process
    Push right child first
    Push left child
```

#### Iterative Postorder (Tricky!)
**Method 1**: Two stacks
**Method 2**: Single stack with visited flag
**Method 3**: Reverse of modified preorder

> âš ï¸ **INTERVIEW FAVORITE**: Iterative postorder with single stack!

---

## Chapter 9: Advanced Problem Patterns

### 9.1 Asteroid Collision Pattern
**Concept**: Elements interact/cancel based on direction and magnitude
**Problems**:
1. Asteroid Collision
2. Robot Collisions
3. Backspace String Compare

### 9.2 Span/Range Problems
**Concept**: Find extent of influence for each element
**Problems**:
1. Stock Span
2. Online Stock Span
3. Sum of Subarray Minimums
4. Sum of Total Strength of Wizards â­â­â­ (Very Hard)

### 9.3 Nested Structure Problems
**Problems**:
1. Flatten Nested List Iterator
2. Nested Integer Weighted Sum
3. Mini Parser
4. Exclusive Time of Functions

### 9.4 Validation Problems
1. Valid Parenthesis String (with `*`)
2. Check if Word is Valid After Substitutions
3. Minimum Insertions to Balance

---

## Chapter 10: Hard Interview Problems â­â­â­

### 10.1 Top Hard Stack Problems

| Problem | Key Insight | Difficulty |
|---------|-------------|------------|
| Largest Rectangle in Histogram | Monotonic + boundaries | Hard |
| Maximal Rectangle | Histogram per row | Hard |
| Trapping Rain Water | Two pointer OR stack | Hard |
| Basic Calculator III | Recursion OR two stacks | Hard |
| Remove K Digits | Monotonic increasing | Hard |
| Create Maximum Number | Merge + monotonic | Hard |
| Sum of Subarray Minimums | Contribution technique | Hard |
| Number of Visible People in Queue | Monotonic decreasing | Hard |
| Maximum Width Ramp | Monotonic + binary search | Hard |
| Longest Valid Parentheses | DP OR stack with indices | Hard |
| 132 Pattern | Monotonic + track max | Hard |
| Car Fleet | Sort + stack | Medium-Hard |
| Online Stock Span | Monotonic + aggregation | Medium-Hard |

### 10.2 The "Contribution" Technique

**Used in**: Sum of Subarray Minimums, Sum of Subarray Ranges

**Concept**: Instead of iterating all subarrays, calculate each element's contribution

**Formula**: `contribution[i] = arr[i] Ã— left_count Ã— right_count`

Where:
- `left_count` = distance to previous smaller/greater
- `right_count` = distance to next smaller/greater

> ğŸ”¥ This technique reduces O(nÂ²) â†’ O(n)!

### 10.3 Handling Duplicates

**Problem**: What if array has duplicates?

**Solution**: Use **strict inequality on one side**
- Left boundary: `<` (strictly smaller)
- Right boundary: `<=` (smaller or equal)

This ensures each element is counted exactly once!

---

# PART 4: INTERVIEW PREPARATION

## Chapter 11: Pattern Recognition Cheatsheet

### When to Use Stack:

| Clue in Problem | Stack Pattern |
|-----------------|---------------|
| "Next greater/smaller" | Monotonic Stack |
| "Previous greater/smaller" | Monotonic Stack |
| "Matching pairs" | Basic Stack |
| "Nested structures" | Stack with recursion |
| "Undo operation" | Stack for history |
| "Evaluate expression" | Two-stack or recursion |
| "Histogram/Rectangle" | Monotonic Stack |
| "Valid parentheses" | Basic Stack |
| "Decode/Parse string" | Stack for nesting |

### Problem-Solving Framework:
```
1. Identify: Is there LIFO pattern?
2. Decide: What to store? (value/index/pair)
3. Choose: Monotonic increasing or decreasing?
4. Handle: Edge cases (empty stack, duplicates)
5. Optimize: Space if possible
```

---

## Chapter 12: Common Mistakes & Tips

### 12.1 Common Mistakes

âŒ **Forgetting empty stack check before pop/peek**
âŒ **Storing values when indices are needed**
âŒ **Wrong inequality direction in monotonic stack**
âŒ **Not handling duplicates properly**
âŒ **Off-by-one errors in boundary calculation**
âŒ **Forgetting to process remaining stack elements**

### 12.2 Pro Tips

âœ… **Always ask**: What should I store? Value or Index?
âœ… **For boundaries**: Store indices, not values
âœ… **For duplicates**: Careful with `<` vs `<=`
âœ… **Debug**: Trace through small example manually
âœ… **Edge cases**: Empty input, single element, all same elements

### 12.3 Time-Space Complexity Summary

| Pattern | Time | Space |
|---------|------|-------|
| Basic stack operations | O(1) each | O(n) |
| Monotonic stack (single pass) | O(n) | O(n) |
| Expression evaluation | O(n) | O(n) |
| Histogram problems | O(n) | O(n) |
| Tree traversal (iterative) | O(n) | O(h) |

---

## Chapter 13: Practice Roadmap

### Week 1-2: Foundations
- [ ] Implement stack from scratch (array + linked list)
- [ ] Valid Parentheses (LC 20)
- [ ] Min Stack (LC 155)
- [ ] Implement Queue using Stacks (LC 232)
- [ ] Daily Temperatures (LC 739)

### Week 3-4: Monotonic Stack Mastery
- [ ] Next Greater Element I, II (LC 496, 503)
- [ ] Stock Span Problem (LC 901)
- [ ] Largest Rectangle in Histogram (LC 84) â­
- [ ] Maximal Rectangle (LC 85) â­
- [ ] Trapping Rain Water (LC 42) â­

### Week 5-6: Expression & String
- [ ] Basic Calculator I, II, III (LC 224, 227, 772)
- [ ] Decode String (LC 394)
- [ ] Remove K Digits (LC 402)
- [ ] Remove Duplicate Letters (LC 316)

### Week 7-8: Advanced Problems
- [ ] Sum of Subarray Minimums (LC 907)
- [ ] 132 Pattern (LC 456)
- [ ] Maximum Frequency Stack (LC 895)
- [ ] Longest Valid Parentheses (LC 32)
- [ ] Number of Visible People in Queue (LC 1944)

---

## Quick Reference Card

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           STACK INTERVIEW QUICK REFERENCE           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ LIFO: Last In, First Out                            â”‚
â”‚                                                     â”‚
â”‚ OPERATIONS: push, pop, peek, isEmpty - all O(1)    â”‚
â”‚                                                     â”‚
â”‚ MONOTONIC STACK:                                    â”‚
â”‚   â€¢ Decreasing â†’ Next/Prev Greater                  â”‚
â”‚   â€¢ Increasing â†’ Next/Prev Smaller                  â”‚
â”‚                                                     â”‚
â”‚ KEY PROBLEMS:                                       â”‚
â”‚   â€¢ Histogram â†’ Monotonic + boundaries              â”‚
â”‚   â€¢ Calculator â†’ Two stacks (nums + ops)            â”‚
â”‚   â€¢ Parentheses â†’ Match or store indices            â”‚
â”‚                                                     â”‚
â”‚ REMEMBER:                                           â”‚
â”‚   â€¢ Store INDEX when boundaries matter              â”‚
â”‚   â€¢ Handle duplicates with strict one-side          â”‚
â”‚   â€¢ Process remaining stack at the end              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

**Good luck with your interviews! ğŸš€**
