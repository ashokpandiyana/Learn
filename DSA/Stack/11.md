# Chapter 11: Pattern Recognition Cheatsheet

## 11.1 The Master Decision Tree

The most critical skill for stack problems is **recognizing which pattern applies**. Here's a comprehensive decision tree:

```
                         ┌─────────────────────────┐
                         │   READ THE PROBLEM      │
                         │   CAREFULLY             │
                         └───────────┬─────────────┘
                                     │
                                     ▼
                    ┌────────────────────────────────────┐
                    │  Does the problem involve LIFO    │
                    │  (Last In, First Out) behavior?   │
                    └────────────────┬───────────────────┘
                                     │
                    ┌────────────────┴────────────────┐
                    │                                 │
                    ▼                                 ▼
                   YES                               NO
                    │                                 │
                    ▼                                 ▼
            ┌───────────────┐                Consider other
            │  USE STACK!   │                data structures
            └───────┬───────┘
                    │
        ┌───────────┼───────────┬───────────────┐
        │           │           │               │
        ▼           ▼           ▼               ▼
   ┌─────────┐ ┌─────────┐ ┌─────────┐   ┌──────────┐
   │ Matching│ │Monotonic│ │Expression│   │  Design  │
   │  Pairs  │ │  Stack  │ │   Eval   │   │ Problem  │
   └────┬────┘ └────┬────┘ └────┬────┘   └────┬─────┘
        │           │           │              │
        ▼           ▼           ▼              ▼
   Parentheses  Next/Prev   Calculator    Min/Max Stack
   Nested       Greater/    Postfix       Freq Stack
   Decode       Smaller     Infix→Post    Browser Hist
```

---

## 11.2 Pattern Categories Deep Dive

### Category 1: Matching Pairs Pattern

```
WHEN TO USE:
═══════════════════════════════════════════════════════════════

Keywords: "valid", "balanced", "matching", "pairs", "nested"

Examples:
• Valid Parentheses → matching ()[]{}
• HTML Tag Matching → matching <tag></tag>
• Remove Invalid Parentheses → fix mismatched pairs

VISUAL RECOGNITION:
─────────────────────────────────────────────────────────────

Input has OPENING and CLOSING elements that must match:
  ( with )
  [ with ]
  { with }
  <tag> with </tag>

The MOST RECENT opening must match the next closing!
This is LIFO → Stack!

TEMPLATE:
─────────────────────────────────────────────────────────────
stack = []
for char in s:
    if is_opening(char):
        stack.append(char)
    elif is_closing(char):
        if not stack or not matches(stack[-1], char):
            return False
        stack.pop()
return len(stack) == 0
```

#### Pattern Variations

```python
# VARIATION 1: Simple Valid Check
def isValid(s):
    """Check if parentheses are valid"""
    stack = []
    pairs = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in pairs.values():  # Opening
            stack.append(char)
        elif char in pairs:  # Closing
            if not stack or stack[-1] != pairs[char]:
                return False
            stack.pop()
    
    return len(stack) == 0


# VARIATION 2: Count Minimum Operations
def minOperations(s):
    """Count minimum insertions/deletions to make valid"""
    stack = []
    deletions = 0
    
    for char in s:
        if char == '(':
            stack.append(char)
        else:
            if stack:
                stack.pop()
            else:
                deletions += 1  # Extra ')'
    
    # Remaining '(' need matching ')'
    return deletions + len(stack)


# VARIATION 3: Get Valid String
def getValidString(s):
    """Remove minimum chars to make valid, return result"""
    s = list(s)
    stack = []  # Store INDICES of '('
    
    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)
        elif char == ')':
            if stack:
                stack.pop()
            else:
                s[i] = ''  # Mark for removal
    
    # Remove unmatched '('
    for i in stack:
        s[i] = ''
    
    return ''.join(s)


# VARIATION 4: Longest Valid Substring
def longestValid(s):
    """Find length of longest valid substring"""
    stack = [-1]  # Base index
    max_len = 0
    
    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)  # New base
            else:
                max_len = max(max_len, i - stack[-1])
    
    return max_len
```

---

### Category 2: Monotonic Stack Pattern

```
WHEN TO USE:
═══════════════════════════════════════════════════════════════

Keywords: "next greater", "next smaller", "previous greater", 
          "previous smaller", "span", "days until", "visible"

THE FOUR FUNDAMENTAL QUERIES:
─────────────────────────────────────────────────────────────

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│   NEXT GREATER ELEMENT (NGE)                                │
│   • Stack: DECREASING (big at bottom)                       │
│   • Pop when: current > stack top                           │
│   • Answer: current element is NGE for popped element       │
│                                                             │
│   NEXT SMALLER ELEMENT (NSE)                                │
│   • Stack: INCREASING (small at bottom)                     │
│   • Pop when: current < stack top                           │
│   • Answer: current element is NSE for popped element       │
│                                                             │
│   PREVIOUS GREATER ELEMENT (PGE)                            │
│   • Stack: DECREASING                                       │
│   • Pop when: current >= stack top                          │
│   • Answer: stack top (after popping) is PGE for current    │
│                                                             │
│   PREVIOUS SMALLER ELEMENT (PSE)                            │
│   • Stack: INCREASING                                       │
│   • Pop when: current <= stack top                          │
│   • Answer: stack top (after popping) is PSE for current    │
│                                                             │
└─────────────────────────────────────────────────────────────┘

VISUAL MEMORY AID:
─────────────────────────────────────────────────────────────

DECREASING Stack:        INCREASING Stack:
    ┌───┐                    ┌───┐
    │ 2 │ small              │ 8 │ big
    ├───┤                    ├───┤
    │ 5 │                    │ 5 │
    ├───┤                    ├───┤
    │ 8 │ big                │ 2 │ small
    └───┘                    └───┘
    
For GREATER queries       For SMALLER queries
```

#### All Four Queries Implementation

```python
def allFourQueries(nums):
    """
    Compute all four queries in one pass each
    Returns: (nge, nse, pge, pse) arrays
    """
    n = len(nums)
    
    # Next Greater Element
    nge = [-1] * n
    stack = []
    for i in range(n):
        while stack and nums[i] > nums[stack[-1]]:
            nge[stack.pop()] = nums[i]
        stack.append(i)
    
    # Next Smaller Element
    nse = [-1] * n
    stack = []
    for i in range(n):
        while stack and nums[i] < nums[stack[-1]]:
            nse[stack.pop()] = nums[i]
        stack.append(i)
    
    # Previous Greater Element
    pge = [-1] * n
    stack = []
    for i in range(n):
        while stack and nums[stack[-1]] <= nums[i]:
            stack.pop()
        if stack:
            pge[i] = nums[stack[-1]]
        stack.append(i)
    
    # Previous Smaller Element
    pse = [-1] * n
    stack = []
    for i in range(n):
        while stack and nums[stack[-1]] >= nums[i]:
            stack.pop()
        if stack:
            pse[i] = nums[stack[-1]]
        stack.append(i)
    
    return nge, nse, pge, pse


# Example:
nums = [4, 2, 5, 1, 3]
nge, nse, pge, pse = allFourQueries(nums)
# nge = [5, 5, -1, 3, -1]  (next greater)
# nse = [2, 1, 1, -1, -1]  (next smaller)
# pge = [-1, 4, -1, 5, 5]  (previous greater)
# pse = [-1, -1, 2, -1, 1] (previous smaller)
```

#### When to Use Each Query

```
PROBLEM → QUERY MAPPING:
═══════════════════════════════════════════════════════════════

┌─────────────────────────────┬────────────────────────────┐
│ Problem Type                │ Query Needed               │
├─────────────────────────────┼────────────────────────────┤
│ Daily Temperatures          │ NGE (index difference)     │
│ Stock Span                  │ PGE (count days)           │
│ Largest Rectangle           │ PSE + NSE (boundaries)     │
│ Trapping Rain Water         │ PGE + NGE or Two Pointers  │
│ Sum of Subarray Mins        │ PSE + NSE (contribution)   │
│ Number of Visible People    │ NGE (process right to left)│
│ Buildings With Ocean View   │ PGE (process right to left)│
│ Remove K Digits             │ NSE variant (increasing)   │
└─────────────────────────────┴────────────────────────────┘
```

---

### Category 3: Histogram/Rectangle Pattern

```
WHEN TO USE:
═══════════════════════════════════════════════════════════════

Keywords: "largest rectangle", "maximal area", "histogram",
          "matrix of 1s", "container", "water"

RECOGNITION:
─────────────────────────────────────────────────────────────

• Given heights/bars
• Need to find maximum rectangular area
• Each bar can extend left/right until blocked by shorter bar

THIS IS PSE + NSE PROBLEM!
─────────────────────────────────────────────────────────────

For each bar:
• Left boundary = Previous Smaller Element (or -1)
• Right boundary = Next Smaller Element (or n)
• Width = right - left - 1
• Area = height × width
```

```python
def largestRectangle(heights):
    """
    Master template for histogram problems
    """
    n = len(heights)
    
    # Find Previous Smaller Element indices
    left = [-1] * n
    stack = []
    for i in range(n):
        while stack and heights[stack[-1]] >= heights[i]:
            stack.pop()
        left[i] = stack[-1] if stack else -1
        stack.append(i)
    
    # Find Next Smaller Element indices
    right = [n] * n
    stack = []
    for i in range(n - 1, -1, -1):
        while stack and heights[stack[-1]] >= heights[i]:
            stack.pop()
        right[i] = stack[-1] if stack else n
        stack.append(i)
    
    # Calculate maximum area
    max_area = 0
    for i in range(n):
        width = right[i] - left[i] - 1
        area = heights[i] * width
        max_area = max(max_area, area)
    
    return max_area


# SINGLE PASS VERSION (more efficient)
def largestRectangleSinglePass(heights):
    """
    Single pass using sentinel
    """
    heights = heights + [0]  # Sentinel forces final processing
    stack = []
    max_area = 0
    
    for i, h in enumerate(heights):
        while stack and h < heights[stack[-1]]:
            height = heights[stack.pop()]
            width = i - stack[-1] - 1 if stack else i
            max_area = max(max_area, height * width)
        stack.append(i)
    
    return max_area


# EXTENSION: 2D Matrix (Maximal Rectangle)
def maximalRectangle(matrix):
    """
    Build histogram for each row, apply largest rectangle
    """
    if not matrix:
        return 0
    
    rows, cols = len(matrix), len(matrix[0])
    heights = [0] * cols
    max_area = 0
    
    for row in range(rows):
        # Update heights
        for col in range(cols):
            if matrix[row][col] == '1':
                heights[col] += 1
            else:
                heights[col] = 0
        
        # Apply histogram algorithm
        max_area = max(max_area, largestRectangleSinglePass(heights[:]))
    
    return max_area
```

---

### Category 4: Expression Evaluation Pattern

```
WHEN TO USE:
═══════════════════════════════════════════════════════════════

Keywords: "evaluate", "calculate", "expression", "infix",
          "postfix", "RPN", "operators", "precedence"

SUBCATEGORIES:
─────────────────────────────────────────────────────────────

1. POSTFIX EVALUATION (Simplest)
   • Single stack for operands
   • Number → push
   • Operator → pop two, compute, push result

2. INFIX WITH + - ONLY
   • Track running result and sign
   • Stack saves context at '('

3. INFIX WITH + - * /
   • Stack for delayed computation
   • +/- : push to stack
   • */ : compute immediately

4. FULL EXPRESSION
   • Two stacks (nums + ops) OR
   • Recursive descent at '('
```

```python
# PATTERN 1: Postfix (RPN)
def evalRPN(tokens):
    stack = []
    ops = {
        '+': lambda a, b: a + b,
        '-': lambda a, b: a - b,
        '*': lambda a, b: a * b,
        '/': lambda a, b: int(a / b)
    }
    
    for token in tokens:
        if token in ops:
            b, a = stack.pop(), stack.pop()
            stack.append(ops[token](a, b))
        else:
            stack.append(int(token))
    
    return stack[0]


# PATTERN 2: Basic Calculator I (+ - and parentheses)
def calculate1(s):
    stack = []
    result = 0
    sign = 1
    num = 0
    
    for char in s:
        if char.isdigit():
            num = num * 10 + int(char)
        elif char in '+-':
            result += sign * num
            num = 0
            sign = 1 if char == '+' else -1
        elif char == '(':
            stack.append(result)
            stack.append(sign)
            result = 0
            sign = 1
        elif char == ')':
            result += sign * num
            num = 0
            result *= stack.pop()  # sign
            result += stack.pop()  # previous result
    
    return result + sign * num


# PATTERN 3: Calculator II (+ - * / no parentheses)
def calculate2(s):
    stack = []
    num = 0
    prev_op = '+'
    s += '+'  # Sentinel
    
    for char in s:
        if char.isdigit():
            num = num * 10 + int(char)
        elif char in '+-*/':
            if prev_op == '+':
                stack.append(num)
            elif prev_op == '-':
                stack.append(-num)
            elif prev_op == '*':
                stack.append(stack.pop() * num)
            elif prev_op == '/':
                stack.append(int(stack.pop() / num))
            num = 0
            prev_op = char
    
    return sum(stack)


# PATTERN 4: Full Calculator III (all operators + parentheses)
def calculate3(s):
    def helper(idx):
        stack = []
        num = 0
        prev_op = '+'
        
        while idx < len(s):
            char = s[idx]
            
            if char.isdigit():
                num = num * 10 + int(char)
            elif char == '(':
                num, idx = helper(idx + 1)
            elif char in '+-*/)':
                if prev_op == '+':
                    stack.append(num)
                elif prev_op == '-':
                    stack.append(-num)
                elif prev_op == '*':
                    stack.append(stack.pop() * num)
                elif prev_op == '/':
                    stack.append(int(stack.pop() / num))
                
                if char == ')':
                    return sum(stack), idx
                
                num = 0
                prev_op = char
            
            idx += 1
        
        return sum(stack), idx
    
    return helper(0)[0]
```

---

### Category 5: Design Pattern

```
WHEN TO USE:
═══════════════════════════════════════════════════════════════

Keywords: "design", "implement", "O(1)", "getMin", "getMax",
          "undo", "redo", "browser", "history"

COMMON DESIGN PROBLEMS:
─────────────────────────────────────────────────────────────

┌─────────────────────┬─────────────────────────────────────┐
│ Problem             │ Key Technique                       │
├─────────────────────┼─────────────────────────────────────┤
│ Min Stack           │ Auxiliary stack for min values      │
│ Max Stack           │ Aux stack + lazy deletion           │
│ Frequency Stack     │ freq_map + group_map                │
│ Browser History     │ Two stacks (back + forward)         │
│ Text Editor         │ Undo stack + Redo stack             │
│ Custom Increment    │ Lazy propagation array              │
└─────────────────────┴─────────────────────────────────────┘
```

```python
# DESIGN PATTERN TEMPLATES:

# Template 1: Auxiliary Stack (Min/Max Stack)
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []
    
    def push(self, val):
        self.stack.append(val)
        min_val = min(val, self.min_stack[-1] if self.min_stack else val)
        self.min_stack.append(min_val)
    
    def pop(self):
        self.stack.pop()
        self.min_stack.pop()
    
    def top(self):
        return self.stack[-1]
    
    def getMin(self):
        return self.min_stack[-1]


# Template 2: Two Stacks (Undo/Redo)
class UndoRedo:
    def __init__(self):
        self.state = ""
        self.undo_stack = []
        self.redo_stack = []
    
    def execute(self, new_state):
        self.undo_stack.append(self.state)
        self.state = new_state
        self.redo_stack = []  # Clear redo on new action
    
    def undo(self):
        if self.undo_stack:
            self.redo_stack.append(self.state)
            self.state = self.undo_stack.pop()
    
    def redo(self):
        if self.redo_stack:
            self.undo_stack.append(self.state)
            self.state = self.redo_stack.pop()


# Template 3: Lazy Propagation
class CustomStack:
    def __init__(self, maxSize):
        self.stack = []
        self.inc = []  # Lazy increment values
        self.max_size = maxSize
    
    def push(self, x):
        if len(self.stack) < self.max_size:
            self.stack.append(x)
            self.inc.append(0)
    
    def pop(self):
        if not self.stack:
            return -1
        
        idx = len(self.stack) - 1
        increment = self.inc.pop()
        
        if self.inc:
            self.inc[-1] += increment  # Propagate down
        
        return self.stack.pop() + increment
    
    def increment(self, k, val):
        if self.inc:
            idx = min(k, len(self.inc)) - 1
            self.inc[idx] += val
```

---

## 11.3 Quick Pattern Lookup Table

```
╔════════════════════════════════════════════════════════════════════╗
║                    INSTANT PATTERN LOOKUP                          ║
╠════════════════════════════════════════════════════════════════════╣
║                                                                    ║
║  SEE THIS                    →  USE THIS PATTERN                   ║
║  ────────────────────────────────────────────────────────────────  ║
║                                                                    ║
║  "valid parentheses"         →  Basic stack + matching             ║
║  "balanced brackets"         →  Basic stack + matching             ║
║  "next greater element"      →  Monotonic DECREASING               ║
║  "next smaller element"      →  Monotonic INCREASING               ║
║  "days until warmer"         →  NGE with index difference          ║
║  "stock span"                →  PGE with count                     ║
║  "histogram rectangle"       →  PSE + NSE boundaries               ║
║  "trapping water"            →  Decreasing stack OR two pointers   ║
║  "decode string 3[ab]"       →  Stack of (string, count)           ║
║  "evaluate expression"       →  Two stacks OR recursive            ║
║  "postfix/RPN"               →  Single operand stack               ║
║  "remove k digits"           →  Monotonic INCREASING               ║
║  "asteroid collision"        →  Direction-based comparison         ║
║  "O(1) getMin"               →  Auxiliary min stack                ║
║  "most frequent pop"         →  freq_map + group_map               ║
║  "undo/redo"                 →  Two stacks                         ║
║  "iterative DFS"             →  Explicit stack                     ║
║  "iterative tree traversal"  →  Stack replaces call stack          ║
║                                                                    ║
╚════════════════════════════════════════════════════════════════════╝
```

---

## 11.4 Problem Classification by Technique

### By Stack Type

```
BASIC STACK PROBLEMS:
─────────────────────────────────────────────────────────────
• Valid Parentheses (LC 20)
• Remove Outermost Parentheses (LC 1021)
• Remove All Adjacent Duplicates (LC 1047)
• Backspace String Compare (LC 844)
• Crawler Log Folder (LC 1598)
• Baseball Game (LC 682)

MONOTONIC DECREASING STACK:
─────────────────────────────────────────────────────────────
• Next Greater Element I, II (LC 496, 503)
• Daily Temperatures (LC 739)
• Online Stock Span (LC 901)
• Number of Visible People (LC 1944)
• 132 Pattern (LC 456)

MONOTONIC INCREASING STACK:
─────────────────────────────────────────────────────────────
• Largest Rectangle in Histogram (LC 84)
• Maximal Rectangle (LC 85)
• Trapping Rain Water (LC 42)
• Remove K Digits (LC 402)
• Remove Duplicate Letters (LC 316)
• Sum of Subarray Minimums (LC 907)

TWO STACKS:
─────────────────────────────────────────────────────────────
• Implement Queue using Stacks (LC 232)
• Basic Calculator (LC 224)
• Min Stack (LC 155)
• Max Stack (LC 716)

DESIGN PROBLEMS:
─────────────────────────────────────────────────────────────
• Min Stack (LC 155)
• Max Stack (LC 716)
• Maximum Frequency Stack (LC 895)
• Design Browser History (LC 1472)
• Dinner Plate Stacks (LC 1172)
```

---

## 11.5 Visual Pattern Recognition

```
VISUAL CUES IN PROBLEM DESCRIPTION:
═══════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  "For each element, find the first element to the RIGHT     │
│   that is GREATER than it"                                  │
│              │              │                 │              │
│              └──────────────┼─────────────────┘              │
│                     NEXT    │    GREATER                     │
│                             ▼                                │
│                   Monotonic DECREASING Stack                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  "Given heights representing bars in histogram,             │
│   find the LARGEST RECTANGLE"                               │
│        │                        │                           │
│        └────────────────────────┘                           │
│                    │                                        │
│                    ▼                                        │
│        Need boundaries for each bar                         │
│        → PSE + NSE → Monotonic INCREASING Stack             │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  "Decode the encoded string: 3[a2[bc]]"                     │
│         │     │  │                                          │
│         │     │  └── Nested structure                       │
│         │     └───── Must track current state               │
│         └─────────── Multiplier before bracket              │
│                      │                                      │
│                      ▼                                      │
│         Stack of (current_string, multiplier)               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 11.6 Interview Quick Reference

```python
# COPY-PASTE TEMPLATES FOR INTERVIEWS:

# Template 1: Next Greater Element
def nextGreater(nums):
    n = len(nums)
    result = [-1] * n
    stack = []
    for i in range(n):
        while stack and nums[i] > nums[stack[-1]]:
            result[stack.pop()] = nums[i]
        stack.append(i)
    return result


# Template 2: Histogram Max Rectangle
def maxRectangle(heights):
    heights = heights + [0]
    stack = []
    max_area = 0
    for i, h in enumerate(heights):
        while stack and h < heights[stack[-1]]:
            H = heights[stack.pop()]
            W = i - stack[-1] - 1 if stack else i
            max_area = max(max_area, H * W)
        stack.append(i)
    return max_area


# Template 3: Valid Parentheses
def isValid(s):
    stack = []
    pairs = {')': '(', '}': '{', ']': '['}
    for c in s:
        if c in pairs.values():
            stack.append(c)
        elif c in pairs:
            if not stack or stack[-1] != pairs[c]:
                return False
            stack.pop()
    return len(stack) == 0


# Template 4: Decode String
def decodeString(s):
    stack = []  # (current_string, num)
    curr_str = ""
    curr_num = 0
    for c in s:
        if c.isdigit():
            curr_num = curr_num * 10 + int(c)
        elif c == '[':
            stack.append((curr_str, curr_num))
            curr_str, curr_num = "", 0
        elif c == ']':
            prev_str, num = stack.pop()
            curr_str = prev_str + curr_str * num
        else:
            curr_str += c
    return curr_str
```

---

## 11.7 Pattern Practice Matrix

```
PRACTICE MATRIX: Check off as you master each pattern
═══════════════════════════════════════════════════════════════

┌──────────────────────┬─────┬────────┬────────┬─────────────┐
│ Pattern              │Easy │ Medium │  Hard  │ Mastered?   │
├──────────────────────┼─────┼────────┼────────┼─────────────┤
│ Basic Stack          │ □□□ │  □□□   │  □□    │    □        │
│ Valid Parentheses    │ □□□ │  □□□   │  □□    │    □        │
│ Monotonic Decreasing │ □□  │  □□□   │  □□□   │    □        │
│ Monotonic Increasing │ □□  │  □□□   │  □□□   │    □        │
│ Histogram Pattern    │ □   │  □□    │  □□□   │    □        │
│ Expression Eval      │ □   │  □□□   │  □□□   │    □        │
│ Two Stacks           │ □□  │  □□□   │  □□    │    □        │
│ Design Problems      │ □□  │  □□□   │  □□    │    □        │
│ Contribution Tech    │     │  □□    │  □□□   │    □        │
│ Collision Pattern    │     │  □□    │  □□    │    □        │
└──────────────────────┴─────┴────────┴────────┴─────────────┘

Aim: At least 2-3 problems per cell before interviews!
```
