# Chapter 6: Stack Design Problems

## 6.1 Design Principles for Stack Problems

### Key Questions to Ask

```
DESIGN INTERVIEW FRAMEWORK:
═══════════════════════════════════════════════════════════════

1. OPERATIONS: What operations are needed?
   - Standard: push, pop, top, isEmpty
   - Special: getMin, popMax, increment, etc.

2. TIME COMPLEXITY: What's required for each operation?
   - Usually O(1) is expected
   - Sometimes O(log n) is acceptable

3. SPACE COMPLEXITY: Any constraints?
   - Single stack? Multiple allowed?
   - Additional data structures?

4. EDGE CASES: What could go wrong?
   - Empty stack operations
   - Overflow/underflow
   - Duplicate values
```

---

## 6.2 Custom Stack with Increment (LeetCode 1381)

Design stack with `increment(k, val)` that adds `val` to bottom k elements.

```
OPERATIONS:
═══════════════════════════════════════════════════════════════

push(x): Push x if size < maxSize
pop(): Pop and return top (or -1 if empty)
increment(k, val): Add val to bottom min(k, stack.size) elements

NAIVE: increment is O(k) - can we do O(1)?

KEY INSIGHT: Lazy propagation!
- Don't actually increment, just RECORD what to add
- Apply increment when element is popped
```

### Implementation

```python
class CustomStack:
    """
    Custom Stack with O(1) increment using lazy propagation
    
    Idea: Store increment values separately
    - inc[i] = value to add to elements 0..i when popped
    - When popping index i, add inc[i] to result
    - Pass inc[i] down to inc[i-1] (propagate)
    
    Time: O(1) for all operations
    Space: O(maxSize)
    """
    
    def __init__(self, maxSize: int):
        self.max_size = maxSize
        self.stack = []
        self.inc = []  # inc[i] = increment for indices 0..i
    
    def push(self, x: int) -> None:
        if len(self.stack) < self.max_size:
            self.stack.append(x)
            self.inc.append(0)
    
    def pop(self) -> int:
        if not self.stack:
            return -1
        
        idx = len(self.stack) - 1
        
        # Get increment for this index
        increment = self.inc.pop()
        
        # Propagate increment to lower index
        if self.inc:
            self.inc[-1] += increment
        
        # Return value + increment
        return self.stack.pop() + increment
    
    def increment(self, k: int, val: int) -> None:
        # Add val to bottom min(k, size) elements
        # Just mark at the highest affected index
        if self.inc:
            idx = min(k, len(self.inc)) - 1
            self.inc[idx] += val


# Visual Trace:
"""
CustomStack(3)

push(1): stack=[1], inc=[0]
push(2): stack=[1,2], inc=[0,0]
increment(2, 100): inc=[0,100]  ← mark at index 1
push(3): stack=[1,2,3], inc=[0,100,0]

pop(): 
  - idx=2, increment=0
  - return 3+0=3
  - stack=[1,2], inc=[0,100]

pop():
  - idx=1, increment=100
  - propagate: inc[0] += 100 → inc=[100]
  - return 2+100=102
  - stack=[1], inc=[100]

pop():
  - idx=0, increment=100
  - return 1+100=101
"""
```

---

## 6.3 Browser History (LeetCode 1472)

Design browser with `visit`, `back`, `forward` operations.

```
BROWSER NAVIGATION:
═══════════════════════════════════════════════════════════════

visit(url): Go to url, clear forward history
back(steps): Go back min(steps, available) pages
forward(steps): Go forward min(steps, available) pages

Example:
visit("google.com")   → history: [google.com]
visit("fb.com")       → history: [google.com, fb.com]
visit("youtube.com")  → history: [google.com, fb.com, youtube.com]
back(1)               → at fb.com
forward(1)            → at youtube.com
visit("linkedin.com") → history: [google.com, fb.com, linkedin.com]
                        (youtube.com cleared!)
```

### Implementation

```python
class BrowserHistory:
    """
    Browser History using two stacks (or single list with pointer)
    
    Approach 1: Two Stacks
    - back_stack: pages behind current
    - forward_stack: pages ahead of current
    - current: current page
    
    Approach 2: Single List with Pointer (shown below)
    - More efficient for this use case
    """
    
    def __init__(self, homepage: str):
        self.history = [homepage]
        self.current = 0
    
    def visit(self, url: str) -> None:
        # Clear forward history
        self.history = self.history[:self.current + 1]
        # Add new page
        self.history.append(url)
        self.current += 1
    
    def back(self, steps: int) -> str:
        # Go back, but not before index 0
        self.current = max(0, self.current - steps)
        return self.history[self.current]
    
    def forward(self, steps: int) -> str:
        # Go forward, but not past last index
        self.current = min(len(self.history) - 1, self.current + steps)
        return self.history[self.current]


# Two-Stack Approach (Alternative):
class BrowserHistoryTwoStacks:
    """
    Using explicit back and forward stacks
    """
    
    def __init__(self, homepage: str):
        self.back_stack = []
        self.forward_stack = []
        self.current = homepage
    
    def visit(self, url: str) -> None:
        self.back_stack.append(self.current)
        self.current = url
        self.forward_stack = []  # Clear forward history
    
    def back(self, steps: int) -> str:
        while steps > 0 and self.back_stack:
            self.forward_stack.append(self.current)
            self.current = self.back_stack.pop()
            steps -= 1
        return self.current
    
    def forward(self, steps: int) -> str:
        while steps > 0 and self.forward_stack:
            self.back_stack.append(self.current)
            self.current = self.forward_stack.pop()
            steps -= 1
        return self.current
```

---

## 6.4 Text Editor with Undo/Redo

Classic design problem demonstrating command pattern with stacks.

```
OPERATIONS:
═══════════════════════════════════════════════════════════════

write(text): Insert text at cursor
delete(k): Delete k characters before cursor
undo(): Undo last operation
redo(): Redo last undone operation

KEY INSIGHT: Command Pattern
- Each operation is stored as a "command"
- Undo stack stores commands to undo
- Redo stack stores undone commands
```

```python
class TextEditor:
    """
    Text Editor with Undo/Redo using Command Pattern
    
    Each command stores:
    - Type: 'write' or 'delete'
    - Data: text written or deleted
    
    Undo: Pop from undo_stack, reverse operation, push to redo_stack
    Redo: Pop from redo_stack, apply operation, push to undo_stack
    """
    
    def __init__(self):
        self.text = []  # Current text as list of chars
        self.cursor = 0
        self.undo_stack = []  # (operation, data, cursor_before)
        self.redo_stack = []
    
    def write(self, s: str) -> None:
        """Insert text at cursor"""
        # Save for undo
        self.undo_stack.append(('write', s, self.cursor))
        self.redo_stack = []  # Clear redo on new operation
        
        # Insert text
        self.text = self.text[:self.cursor] + list(s) + self.text[self.cursor:]
        self.cursor += len(s)
    
    def delete(self, k: int) -> str:
        """Delete k characters before cursor"""
        # Calculate actual characters to delete
        k = min(k, self.cursor)
        
        if k == 0:
            return ""
        
        # Text being deleted
        deleted = ''.join(self.text[self.cursor - k:self.cursor])
        
        # Save for undo
        self.undo_stack.append(('delete', deleted, self.cursor))
        self.redo_stack = []
        
        # Perform delete
        self.text = self.text[:self.cursor - k] + self.text[self.cursor:]
        self.cursor -= k
        
        return deleted
    
    def undo(self) -> None:
        """Undo last operation"""
        if not self.undo_stack:
            return
        
        op, data, prev_cursor = self.undo_stack.pop()
        
        if op == 'write':
            # Undo write: delete the written text
            self.text = self.text[:prev_cursor] + self.text[prev_cursor + len(data):]
            self.cursor = prev_cursor
        else:  # op == 'delete'
            # Undo delete: insert the deleted text back
            self.text = self.text[:prev_cursor - len(data)] + list(data) + self.text[prev_cursor - len(data):]
            self.cursor = prev_cursor
        
        # Push to redo stack
        self.redo_stack.append((op, data, prev_cursor))
    
    def redo(self) -> None:
        """Redo last undone operation"""
        if not self.redo_stack:
            return
        
        op, data, cursor_after = self.redo_stack.pop()
        
        if op == 'write':
            # Redo write
            cursor_before = cursor_after
            self.text = self.text[:cursor_before] + list(data) + self.text[cursor_before:]
            self.cursor = cursor_before + len(data)
        else:  # op == 'delete'
            # Redo delete
            cursor_before = cursor_after - len(data)
            self.text = self.text[:cursor_before] + self.text[cursor_after:]
            self.cursor = cursor_before
        
        self.undo_stack.append((op, data, cursor_after))
    
    def get_text(self) -> str:
        """Return current text"""
        return ''.join(self.text)
    
    def left(self, k: int) -> str:
        """Move cursor left and return last min(10, chars_to_left) chars"""
        self.cursor = max(0, self.cursor - k)
        return ''.join(self.text[max(0, self.cursor - 10):self.cursor])
    
    def right(self, k: int) -> str:
        """Move cursor right and return last min(10, chars_to_left) chars"""
        self.cursor = min(len(self.text), self.cursor + k)
        return ''.join(self.text[max(0, self.cursor - 10):self.cursor])
```

---

## 6.5 Dinner Plate Stacks (LeetCode 1172) ⭐⭐⭐

Design data structure with multiple stacks, each with capacity.

```
OPERATIONS:
═══════════════════════════════════════════════════════════════

push(val): Push to leftmost non-full stack (create if needed)
pop(): Pop from rightmost non-empty stack
popAtStack(index): Pop from specific stack

Challenge: Efficiently track:
- Leftmost non-full stack (for push)
- Rightmost non-empty stack (for pop)
```

```python
import heapq

class DinnerPlates:
    """
    Dinner Plates using min-heap to track available positions
    
    Key insights:
    1. Use min-heap to find leftmost non-full stack quickly
    2. Track stacks in a list
    3. For pop(), iterate from right to find non-empty
    
    Time:
    - push: O(log n)
    - pop: O(n) worst case (many empty stacks at end)
    - popAtStack: O(log n)
    
    Space: O(n)
    """
    
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.stacks = []  # List of stacks
        self.available = []  # Min-heap of indices with space
    
    def push(self, val: int) -> None:
        # Remove invalid indices from heap (stacks that got full or don't exist)
        while self.available and (
            self.available[0] >= len(self.stacks) or 
            len(self.stacks[self.available[0]]) >= self.capacity
        ):
            heapq.heappop(self.available)
        
        if not self.available:
            # No available stack, create new one
            self.stacks.append([])
            heapq.heappush(self.available, len(self.stacks) - 1)
        
        # Push to leftmost available stack
        idx = self.available[0]
        self.stacks[idx].append(val)
        
        # If stack became full, remove from available
        if len(self.stacks[idx]) >= self.capacity:
            heapq.heappop(self.available)
    
    def pop(self) -> int:
        # Pop from rightmost non-empty stack
        while self.stacks and not self.stacks[-1]:
            self.stacks.pop()
        
        if not self.stacks:
            return -1
        
        return self.popAtStack(len(self.stacks) - 1)
    
    def popAtStack(self, index: int) -> int:
        # Validate index
        if index < 0 or index >= len(self.stacks) or not self.stacks[index]:
            return -1
        
        # Pop from specified stack
        val = self.stacks[index].pop()
        
        # This stack now has space, add to available
        heapq.heappush(self.available, index)
        
        return val


# Visual Example:
"""
DinnerPlates(2)  # capacity = 2

push(1): stacks=[[1]]
push(2): stacks=[[1,2]]         ← stack 0 full
push(3): stacks=[[1,2],[3]]     ← new stack created
push(4): stacks=[[1,2],[3,4]]   ← stack 1 full
push(5): stacks=[[1,2],[3,4],[5]]

popAtStack(0): returns 2
  stacks=[[1],[3,4],[5]]
  available=[0]  ← stack 0 has space now

push(6): goes to stack 0 (leftmost non-full)
  stacks=[[1,6],[3,4],[5]]

pop(): from rightmost non-empty → returns 5
  stacks=[[1,6],[3,4],[]]  

pop(): rightmost non-empty is stack 1 → returns 4
"""
```

---

## 6.6 Flatten Nested List Iterator (LeetCode 341) ⭐⭐

Iterate through a nested list of integers.

```
NESTED STRUCTURE:
═══════════════════════════════════════════════════════════════

Input: [[1,1],2,[1,1]]

Structure:
        root
       / | \
     [1,1] 2 [1,1]
     / \     / \
    1   1   1   1

Flatten to: 1, 1, 2, 1, 1

Challenge: Lazy iteration (don't flatten everything upfront)
```

```python
class NestedIterator:
    """
    Nested List Iterator using Stack
    
    Approach: Stack-based DFS
    - Push elements to stack in reverse order
    - When hasNext() called, ensure top is an integer
    
    Key: Stack stores NestedInteger objects, not raw values
    """
    
    def __init__(self, nestedList):
        """
        Initialize with nested list
        Push all elements in reverse order (so first element is on top)
        """
        self.stack = []
        # Push in reverse order
        for i in range(len(nestedList) - 1, -1, -1):
            self.stack.append(nestedList[i])
    
    def next(self) -> int:
        """
        Return next integer
        Assumes hasNext() was called and returned True
        """
        return self.stack.pop().getInteger()
    
    def hasNext(self) -> bool:
        """
        Check if there's a next integer
        Keep flattening until top is an integer or stack is empty
        """
        while self.stack:
            top = self.stack[-1]
            
            if top.isInteger():
                return True
            
            # Top is a list, flatten it
            self.stack.pop()
            nested_list = top.getList()
            
            # Push in reverse order
            for i in range(len(nested_list) - 1, -1, -1):
                self.stack.append(nested_list[i])
        
        return False


# Alternative: Generator-based (Pythonic)
class NestedIteratorGenerator:
    """
    Using Python generator for elegant solution
    """
    
    def __init__(self, nestedList):
        def flatten(nested):
            for item in nested:
                if item.isInteger():
                    yield item.getInteger()
                else:
                    yield from flatten(item.getList())
        
        self.gen = flatten(nestedList)
        self.next_val = None
        self._advance()
    
    def _advance(self):
        try:
            self.next_val = next(self.gen)
        except StopIteration:
            self.next_val = None
    
    def next(self) -> int:
        result = self.next_val
        self._advance()
        return result
    
    def hasNext(self) -> bool:
        return self.next_val is not None


# Trace for [[1,1],2,[1,1]]:
"""
Stack-based approach:

Initial: stack = [[1,1], 2, [1,1]] (reversed: [[1,1], 2, [1,1]])

hasNext():
  top = [1,1] (list)
  pop and flatten: stack = [1, 1, 2, [1,1]]

hasNext():
  top = 1 (integer) → return True

next(): return 1, stack = [1, 2, [1,1]]

hasNext(): top = 1 → return True
next(): return 1, stack = [2, [1,1]]

hasNext(): top = 2 → return True
next(): return 2, stack = [[1,1]]

hasNext():
  top = [1,1] (list)
  pop and flatten: stack = [1, 1]
  top = 1 → return True

... continues
"""
```

---

## 6.7 Exclusive Time of Functions (LeetCode 636) ⭐⭐

Calculate exclusive execution time for each function.

```
FUNCTION CALLS:
═══════════════════════════════════════════════════════════════

Logs: ["0:start:0","1:start:2","1:end:5","0:end:6"]

Timeline:
0    1    2    3    4    5    6
|----|----|----|----|----|----|
[  func0  [  func1  ]         ]
     ↑              ↑    ↑
   start:0      end:5  end:6

Exclusive times:
- func0: 0-1 + 6-6 = 3 units (1 before func1, 1 after)
- func1: 2-5 = 4 units

Output: [3, 4]

KEY: When a function starts, pause the current one
     When a function ends, resume the previous one
```

```python
def exclusiveTime(n: int, logs: list) -> list:
    """
    Calculate exclusive time using stack
    
    Stack stores: function ids of running functions
    Track: previous timestamp to calculate duration
    
    Time: O(m) where m = number of logs
    Space: O(n) for stack and result
    """
    result = [0] * n
    stack = []  # Stack of function ids
    prev_time = 0
    
    for log in logs:
        parts = log.split(':')
        func_id = int(parts[0])
        action = parts[1]
        timestamp = int(parts[2])
        
        if action == 'start':
            # If there's a running function, add its time
            if stack:
                result[stack[-1]] += timestamp - prev_time
            
            # Push new function
            stack.append(func_id)
            prev_time = timestamp
        
        else:  # action == 'end'
            # Add time for ending function (inclusive, so +1)
            result[stack[-1]] += timestamp - prev_time + 1
            
            # Pop the ended function
            stack.pop()
            
            # Next interval starts at timestamp + 1
            prev_time = timestamp + 1
    
    return result


# Detailed Trace:
"""
Logs: ["0:start:0", "1:start:2", "1:end:5", "0:end:6"]
n = 2

Initial: result=[0,0], stack=[], prev=0

Log "0:start:0":
  action=start, func=0, time=0
  stack empty, no time to add
  Push 0: stack=[0]
  prev = 0

Log "1:start:2":
  action=start, func=1, time=2
  Add to stack[-1]=0: result[0] += 2-0 = 2
  Push 1: stack=[0,1]
  prev = 2
  result = [2, 0]

Log "1:end:5":
  action=end, func=1, time=5
  Add to stack[-1]=1: result[1] += 5-2+1 = 4
  Pop: stack=[0]
  prev = 6
  result = [2, 4]

Log "0:end:6":
  action=end, func=0, time=6
  Add to stack[-1]=0: result[0] += 6-6+1 = 1
  Pop: stack=[]
  result = [3, 4]

Final: [3, 4] ✓
"""
```

---

## 6.8 Online Stock Span (LeetCode 901)

Already covered in Chapter 3, but here's the design perspective:

```python
class StockSpanner:
    """
    Online Stock Span - Design Perspective
    
    Requirements:
    1. Process one price at a time (online)
    2. Return span efficiently
    
    Design Decision: Monotonic Stack storing (price, span)
    - Aggregate spans when popping
    - O(1) amortized per query
    """
    
    def __init__(self):
        # Stack of (price, span) tuples
        self.stack = []
    
    def next(self, price: int) -> int:
        span = 1  # At least count today
        
        # Pop and aggregate smaller/equal prices
        while self.stack and self.stack[-1][0] <= price:
            span += self.stack.pop()[1]
        
        self.stack.append((price, span))
        return span
```

---

## 6.9 Implement N Stacks in One Array

Classic interview question for array manipulation.

```
CHALLENGE:
═══════════════════════════════════════════════════════════════

Implement k stacks using a single array of size n

Naive: Divide array into k parts → wastes space

Better: Use linked list within array!
- next[i]: next element's index in same stack, or next free slot
- top[k]: index of top element for stack k
- free: index of next free slot
```

```python
class KStacks:
    """
    K Stacks in One Array using internal linked list
    
    Data Structures:
    - arr[]: Actual values
    - next[]: Links (within stack or to next free)
    - top[]: Top index for each stack (-1 if empty)
    - free: Head of free list
    
    Time: O(1) for all operations
    Space: O(n) total for n elements across k stacks
    """
    
    def __init__(self, k: int, n: int):
        """
        k: number of stacks
        n: total capacity
        """
        self.k = k
        self.n = n
        
        self.arr = [0] * n      # Values
        self.next = list(range(1, n)) + [-1]  # Free list initially
        self.top = [-1] * k     # All stacks empty
        self.free = 0           # First free index
    
    def push(self, stack_num: int, val: int) -> bool:
        """Push val to stack_num"""
        # Check if full
        if self.free == -1:
            return False
        
        # Get free slot
        slot = self.free
        self.free = self.next[slot]  # Update free list head
        
        # Store value
        self.arr[slot] = val
        
        # Link to previous top
        self.next[slot] = self.top[stack_num]
        
        # Update top
        self.top[stack_num] = slot
        
        return True
    
    def pop(self, stack_num: int) -> int:
        """Pop from stack_num"""
        # Check if empty
        if self.top[stack_num] == -1:
            return -1
        
        # Get top index
        slot = self.top[stack_num]
        
        # Update top to previous element
        self.top[stack_num] = self.next[slot]
        
        # Add slot back to free list
        self.next[slot] = self.free
        self.free = slot
        
        return self.arr[slot]
    
    def peek(self, stack_num: int) -> int:
        """Peek stack_num"""
        if self.top[stack_num] == -1:
            return -1
        return self.arr[self.top[stack_num]]
    
    def is_empty(self, stack_num: int) -> bool:
        """Check if stack_num is empty"""
        return self.top[stack_num] == -1


# Visual Example with k=3, n=6:
"""
Initial State:
arr:  [_, _, _, _, _, _]
next: [1, 2, 3, 4, 5, -1]  ← free list: 0→1→2→3→4→5→end
top:  [-1, -1, -1]          ← all stacks empty
free: 0

push(0, 10):  # Push 10 to stack 0
arr:  [10, _, _, _, _, _]
next: [-1, 2, 3, 4, 5, -1]  ← slot 0 now points to old top (-1)
top:  [0, -1, -1]           ← stack 0's top is index 0
free: 1

push(1, 20):  # Push 20 to stack 1
arr:  [10, 20, _, _, _, _]
next: [-1, -1, 3, 4, 5, -1]
top:  [0, 1, -1]
free: 2

push(0, 30):  # Push 30 to stack 0
arr:  [10, 20, 30, _, _, _]
next: [-1, -1, 0, 4, 5, -1]  ← slot 2 points to old top (0)
top:  [2, 1, -1]              ← stack 0's top is now 2
free: 3

Stack 0: 30 → 10 (indices 2 → 0)
Stack 1: 20 (index 1)

pop(0):  # Returns 30
arr:  [10, 20, _, _, _, _]   ← value at 2 available for reuse
next: [-1, -1, 3, 4, 5, -1]  ← slot 2 rejoins free list
top:  [0, 1, -1]              ← stack 0's top back to 0
free: 2
"""
```

---

## 6.10 Design Summary

```
┌────────────────────────────────────────────────────────────────────┐
│              STACK DESIGN PROBLEMS CHEATSHEET                      │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│ LAZY PROPAGATION:                                                  │
│ ─────────────────────────────                                      │
│ • Don't update immediately, store deltas                           │
│ • Apply when element is accessed/popped                            │
│ • Example: CustomStack increment operation                         │
│                                                                    │
│ COMMAND PATTERN (Undo/Redo):                                       │
│ ─────────────────────────────                                      │
│ • Store operations as commands                                     │
│ • Undo stack: commands to reverse                                  │
│ • Redo stack: reversed commands                                    │
│ • Clear redo on new operation                                      │
│                                                                    │
│ NESTED STRUCTURES:                                                 │
│ ─────────────────────────────                                      │
│ • Stack-based DFS                                                  │
│ • Push in reverse order (first on top)                             │
│ • Flatten lazily in hasNext()                                      │
│                                                                    │
│ FUNCTION CALL TRACKING:                                            │
│ ─────────────────────────────                                      │
│ • Stack of active function IDs                                     │
│ • Track previous timestamp                                         │
│ • Update times on start/end events                                 │
│                                                                    │
│ MULTIPLE STACKS IN ARRAY:                                          │
│ ─────────────────────────────                                      │
│ • Internal linked list using index array                           │
│ • Free list for available slots                                    │
│ • Top array for each stack's head                                  │
│                                                                    │
│ DESIGN INTERVIEW TIPS:                                             │
│ ─────────────────────────────                                      │
│ 1. Clarify operations and complexity requirements                  │
│ 2. Consider edge cases (empty, full, duplicates)                   │
│ 3. Think about auxiliary data structures                           │
│ 4. Draw examples and trace through operations                      │
│ 5. Discuss trade-offs between approaches                           │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

---

## Practice Problems

| Problem | Key Design Pattern | Difficulty |
|---------|-------------------|------------|
| Min Stack | Auxiliary stack | Easy |
| Max Stack | Aux stack + Sorted structure | Hard |
| Custom Stack with Increment | Lazy propagation | Medium |
| Browser History | Two stacks / List + pointer | Medium |
| Design Text Editor | Command pattern | Hard |
| Dinner Plate Stacks | Heap + Multiple stacks | Hard |
| Flatten Nested List Iterator | Stack-based DFS | Medium |
| Exclusive Time of Functions | Stack + timestamps | Medium |
| Online Stock Span | Monotonic stack | Medium |
| Implement N Stacks in Array | Internal linked list | Medium |
| LRU Cache | HashMap + Doubly Linked List | Medium |
| LFU Cache | HashMap + Frequency buckets | Hard |
| Maximum Frequency Stack | freq_map + group_map | Hard |
