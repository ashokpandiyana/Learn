# Chapter 2: Types of LinkedLists - Deep Dive

## 2.1 Singly LinkedList

### Structure and Characteristics

A **Singly LinkedList** is the most basic form where each node points only to the next node in the sequence.

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```

### Visual Representation

```
HEAD
 ↓
[10|•]→[20|•]→[30|•]→[40|•]→[50|NULL]

Each box: [data|pointer]
• = points to next node
NULL = end of list
```

### Complete Implementation

```python
class SinglyLinkedList:
    def __init__(self):
        self.head = None
        self.size = 0
    
    def is_empty(self):
        """Check if list is empty"""
        return self.head is None
    
    def get_size(self):
        """Return size of list"""
        return self.size
    
    def insert_at_head(self, val):
        """Insert at beginning - O(1)"""
        new_node = ListNode(val)
        new_node.next = self.head
        self.head = new_node
        self.size += 1
    
    def insert_at_tail(self, val):
        """Insert at end - O(n)"""
        new_node = ListNode(val)
        
        if not self.head:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node
        
        self.size += 1
    
    def delete_at_head(self):
        """Delete first node - O(1)"""
        if not self.head:
            return None
        
        deleted_val = self.head.val
        self.head = self.head.next
        self.size -= 1
        return deleted_val
    
    def display(self):
        """Print the list"""
        current = self.head
        elements = []
        while current:
            elements.append(str(current.val))
            current = current.next
        print(" → ".join(elements) + " → None")
    
    def search(self, target):
        """Search for a value - O(n)"""
        current = self.head
        position = 0
        
        while current:
            if current.val == target:
                return position
            current = current.next
            position += 1
        
        return -1

# Usage Example
sll = SinglyLinkedList()
sll.insert_at_head(10)
sll.insert_at_head(20)
sll.insert_at_tail(5)
sll.display()  # Output: 20 → 10 → 5 → None
```

### Advantages of Singly LinkedList

1. **Simple structure**: Easy to implement and understand
2. **Memory efficient**: Only one pointer per node
3. **Fast head operations**: O(1) insert/delete at beginning
4. **Dynamic size**: No pre-allocation needed

### Disadvantages

1. **One-way traversal**: Can't go backwards
2. **No direct access to previous node**: Need to track it manually
3. **Delete operation**: Need previous node reference
4. **Tail operations**: O(n) without tail pointer

### Common Operations Complexity

```python
"""
Operation               | Time Complexity
------------------------|------------------
Access by index         | O(n)
Search                  | O(n)
Insert at head          | O(1)
Insert at tail          | O(n)
Insert at position      | O(n)
Delete at head          | O(1)
Delete at tail          | O(n)
Delete by value         | O(n)
Reverse                 | O(n)
"""
```

---

## 2.2 Doubly LinkedList

### Structure and Characteristics

A **Doubly LinkedList** has nodes with two pointers: one to the next node and one to the previous node. This allows bidirectional traversal.

```python
class DoublyListNode:
    def __init__(self, val=0, prev=None, next=None):
        self.val = val
        self.prev = prev  # Pointer to previous node
        self.next = next  # Pointer to next node
```

### Visual Representation

```
     HEAD
       ↓
NULL←[•|10|•]⇄[•|20|•]⇄[•|30|•]⇄[•|40|•]→NULL
      ↑                                ↑
   [prev|data|next]                  TAIL

⇄ = bidirectional link
```

### Complete Implementation

```python
class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0
    
    def is_empty(self):
        return self.head is None
    
    def insert_at_head(self, val):
        """Insert at beginning - O(1)"""
        new_node = DoublyListNode(val)
        
        if not self.head:
            # Empty list
            self.head = self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node
        
        self.size += 1
    
    def insert_at_tail(self, val):
        """Insert at end - O(1) with tail pointer!"""
        new_node = DoublyListNode(val)
        
        if not self.tail:
            # Empty list
            self.head = self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node
        
        self.size += 1
    
    def insert_after_node(self, node, val):
        """Insert after a given node - O(1)"""
        if not node:
            return
        
        new_node = DoublyListNode(val)
        new_node.prev = node
        new_node.next = node.next
        
        if node.next:
            node.next.prev = new_node
        else:
            # Inserting after tail
            self.tail = new_node
        
        node.next = new_node
        self.size += 1
    
    def delete_node(self, node):
        """Delete a given node - O(1)"""
        if not node:
            return
        
        # Update previous node
        if node.prev:
            node.prev.next = node.next
        else:
            # Deleting head
            self.head = node.next
        
        # Update next node
        if node.next:
            node.next.prev = node.prev
        else:
            # Deleting tail
            self.tail = node.prev
        
        self.size -= 1
    
    def delete_at_head(self):
        """Delete first node - O(1)"""
        if not self.head:
            return None
        
        deleted_val = self.head.val
        
        if self.head == self.tail:
            # Only one node
            self.head = self.tail = None
        else:
            self.head = self.head.next
            self.head.prev = None
        
        self.size -= 1
        return deleted_val
    
    def delete_at_tail(self):
        """Delete last node - O(1) with tail pointer!"""
        if not self.tail:
            return None
        
        deleted_val = self.tail.val
        
        if self.head == self.tail:
            # Only one node
            self.head = self.tail = None
        else:
            self.tail = self.tail.prev
            self.tail.next = None
        
        self.size -= 1
        return deleted_val
    
    def display_forward(self):
        """Print list from head to tail"""
        current = self.head
        elements = []
        while current:
            elements.append(str(current.val))
            current = current.next
        print(" ⇄ ".join(elements) + " → None")
    
    def display_backward(self):
        """Print list from tail to head"""
        current = self.tail
        elements = []
        while current:
            elements.append(str(current.val))
            current = current.prev
        print(" ⇄ ".join(elements) + " → None")
    
    def reverse(self):
        """Reverse the doubly linked list - O(n)"""
        current = self.head
        self.head, self.tail = self.tail, self.head
        
        while current:
            # Swap prev and next pointers
            current.prev, current.next = current.next, current.prev
            current = current.prev  # Move to next (which is now prev)

# Usage Example
dll = DoublyLinkedList()
dll.insert_at_head(10)
dll.insert_at_tail(20)
dll.insert_at_tail(30)
dll.display_forward()   # 10 ⇄ 20 ⇄ 30 → None
dll.display_backward()  # 30 ⇄ 20 ⇄ 10 → None

dll.delete_at_tail()
dll.display_forward()   # 10 ⇄ 20 → None
```

### Advantages of Doubly LinkedList

1. **Bidirectional traversal**: Can move forward and backward
2. **O(1) deletion**: When node reference is given (no need to find prev)
3. **O(1) tail operations**: With tail pointer maintained
4. **Easier reversal**: Just swap prev and next pointers
5. **Better for certain algorithms**: Like LRU cache

### Disadvantages

1. **Extra memory**: Additional pointer per node (prev)
2. **More complex**: More pointers to maintain during operations
3. **Slower insertion**: More pointer updates needed

### Memory Comparison

```python
"""
For n elements:

Singly LinkedList:
- n nodes × (data + 1 pointer) = n × (data_size + pointer_size)
- Example: 5 nodes × (8 bytes + 8 bytes) = 80 bytes

Doubly LinkedList:
- n nodes × (data + 2 pointers) = n × (data_size + 2×pointer_size)
- Example: 5 nodes × (8 bytes + 16 bytes) = 120 bytes

50% more memory for pointers!
"""
```

### When to Use Doubly LinkedList

✅ **Use when:**
- Need bidirectional traversal
- Implementing browser history (back/forward)
- LRU Cache implementation
- Music player (prev/next song)
- Undo/Redo functionality
- Need O(1) deletion with node reference

❌ **Don't use when:**
- Memory is constrained
- Only forward traversal needed
- Simple stack/queue operations

---

## 2.3 Circular LinkedList

### Structure and Characteristics

A **Circular LinkedList** has its last node pointing back to the first node instead of NULL, forming a circle.

```python
# Can be singly or doubly circular
class CircularListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```

### Visual Representation

```
Singly Circular:
        ┌──────────────────────┐
        ↓                      │
HEAD→[10|•]→[20|•]→[30|•]→[40|•]
                                ↑
                        Last points back to first!

Doubly Circular:
        ┌─────────────────────────────┐
        ↓                             │
    ┌→[•|10|•]⇄[•|20|•]⇄[•|30|•]⇄[•|40|•]┐
    │                                     │
    └─────────────────────────────────────┘
```

### Complete Implementation

```python
class CircularLinkedList:
    def __init__(self):
        self.head = None
        self.size = 0
    
    def is_empty(self):
        return self.head is None
    
    def insert_at_head(self, val):
        """Insert at beginning"""
        new_node = ListNode(val)
        
        if not self.head:
            # First node points to itself
            new_node.next = new_node
            self.head = new_node
        else:
            # Find last node
            current = self.head
            while current.next != self.head:
                current = current.next
            
            new_node.next = self.head
            current.next = new_node
            self.head = new_node
        
        self.size += 1
    
    def insert_at_tail(self, val):
        """Insert at end"""
        new_node = ListNode(val)
        
        if not self.head:
            new_node.next = new_node
            self.head = new_node
        else:
            current = self.head
            while current.next != self.head:
                current = current.next
            
            current.next = new_node
            new_node.next = self.head
        
        self.size += 1
    
    def delete_at_head(self):
        """Delete first node"""
        if not self.head:
            return None
        
        deleted_val = self.head.val
        
        if self.head.next == self.head:
            # Only one node
            self.head = None
        else:
            # Find last node
            current = self.head
            while current.next != self.head:
                current = current.next
            
            current.next = self.head.next
            self.head = self.head.next
        
        self.size -= 1
        return deleted_val
    
    def display(self, max_nodes=None):
        """Print circular list (limit iterations to avoid infinite loop)"""
        if not self.head:
            print("Empty list")
            return
        
        current = self.head
        elements = []
        count = 0
        limit = max_nodes if max_nodes else self.size
        
        while count < limit:
            elements.append(str(current.val))
            current = current.next
            count += 1
            
            if current == self.head and count < limit:
                elements.append("(循环)")
                break
        
        print(" → ".join(elements) + " → [back to head]")
    
    def split_list(self):
        """Split circular list into two halves"""
        if not self.head or self.head.next == self.head:
            return self.head, None
        
        # Find middle using slow-fast pointers
        slow = fast = self.head
        
        while fast.next != self.head and fast.next.next != self.head:
            slow = slow.next
            fast = fast.next.next
        
        # Split into two circular lists
        head1 = self.head
        head2 = slow.next
        slow.next = head1
        
        # Make second half circular
        current = head2
        while current.next != self.head:
            current = current.next
        current.next = head2
        
        return head1, head2

# Usage Example
cll = CircularLinkedList()
cll.insert_at_tail(10)
cll.insert_at_tail(20)
cll.insert_at_tail(30)
cll.insert_at_tail(40)
cll.display()  # 10 → 20 → 30 → 40 → [back to head]
```

### Practical Example: Round Robin Scheduling

```python
class RoundRobinScheduler:
    """Simulate task scheduling using circular linked list"""
    
    def __init__(self):
        self.head = None
        self.current = None
    
    def add_task(self, task_name):
        """Add a new task to scheduler"""
        new_node = ListNode(task_name)
        
        if not self.head:
            new_node.next = new_node
            self.head = self.current = new_node
        else:
            # Insert at end
            temp = self.head
            while temp.next != self.head:
                temp = temp.next
            
            temp.next = new_node
            new_node.next = self.head
    
    def get_next_task(self):
        """Get next task in round-robin fashion"""
        if not self.current:
            return None
        
        task = self.current.val
        self.current = self.current.next
        return task
    
    def remove_current_task(self):
        """Remove current task and move to next"""
        if not self.current:
            return
        
        if self.current.next == self.current:
            # Last task
            self.head = self.current = None
            return
        
        # Find previous node
        prev = self.current
        while prev.next != self.current:
            prev = prev.next
        
        prev.next = self.current.next
        if self.current == self.head:
            self.head = self.current.next
        
        self.current = self.current.next

# Usage
scheduler = RoundRobinScheduler()
scheduler.add_task("Task A")
scheduler.add_task("Task B")
scheduler.add_task("Task C")

print(scheduler.get_next_task())  # Task A
print(scheduler.get_next_task())  # Task B
print(scheduler.get_next_task())  # Task C
print(scheduler.get_next_task())  # Task A (circular!)
```

### Advantages of Circular LinkedList

1. **No NULL checks**: Last node points to first
2. **Round-robin implementations**: Natural circular structure
3. **Efficient queue**: Can implement queue with single pointer
4. **Visit all nodes**: From any starting point

### Disadvantages

1. **Infinite loop risk**: Must track when to stop
2. **More complex**: Insertion/deletion logic more intricate
3. **Termination condition**: No natural NULL to check

### Use Cases

✅ **Perfect for:**
- Round-robin scheduling (CPU, task scheduling)
- Multiplayer games (turn-based)
- Music/video playlists on repeat
- Circular buffers
- Josephus problem
- Resource allocation in operating systems

---

## Comparison Summary

### Performance Comparison Table

| Operation | Singly | Doubly | Circular (Singly) |
|-----------|--------|--------|-------------------|
| Insert at head | O(1) | O(1) | O(1) |
| Insert at tail | O(n)* | O(1)** | O(n)* |
| Delete at head | O(1) | O(1) | O(1) |
| Delete at tail | O(n) | O(1)** | O(n) |
| Delete given node | O(n)*** | O(1) | O(n)*** |
| Traverse forward | O(n) | O(n) | O(n) |
| Traverse backward | ❌ | O(n) | ❌ |
| Memory per node | 1 pointer | 2 pointers | 1 pointer |

\* O(1) with tail pointer  
\*\* Assuming tail pointer maintained  
\*\*\* Need previous node

### Memory Usage Visualization

```python
"""
For a list with 5 elements [10, 20, 30, 40, 50]:

Singly LinkedList: 5 nodes × (data + 1 next pointer)
Memory: ~200 bytes

Doubly LinkedList: 5 nodes × (data + 1 prev + 1 next pointer)
Memory: ~280 bytes

Circular Singly: 5 nodes × (data + 1 next pointer)
Memory: ~200 bytes (same as singly, but last.next = head)

Python adds overhead for objects, so actual memory is higher.
"""
```

### Choosing the Right Type

```python
def choose_linkedlist_type(requirements):
    """Decision helper"""
    
    if "bidirectional_traversal" in requirements:
        return "Doubly LinkedList"
    
    if "O(1)_tail_operations" in requirements:
        return "Doubly LinkedList (with tail pointer)"
    
    if "circular_iteration" in requirements:
        return "Circular LinkedList"
    
    if "minimal_memory" in requirements:
        return "Singly LinkedList"
    
    if "LRU_cache" in requirements:
        return "Doubly LinkedList"
    
    if "simple_stack_queue" in requirements:
        return "Singly LinkedList"
    
    return "Singly LinkedList (default - simplest)"

# Examples
print(choose_linkedlist_type(["simple_stack_queue"]))
# Output: Singly LinkedList

print(choose_linkedlist_type(["bidirectional_traversal", "O(1)_tail_operations"]))
# Output: Doubly LinkedList
```

---

## Practice Problems

### Easy
1. Convert a singly linked list to doubly linked list
2. Check if a linked list is circular
3. Convert singly linked list to circular

### Medium
4. Implement a browser history using doubly linked list
5. Clone a doubly linked list with random pointers
6. Split a circular linked list into two equal halves

### Hard
7. Flatten a multilevel doubly linked list
8. Design LRU cache using doubly linked list
9. Implement a music player with next/prev using doubly circular list

```python
# Solution: Convert Singly to Doubly
def singly_to_doubly(head):
    """Convert singly linked list to doubly"""
    if not head:
        return None
    
    # Create new doubly linked list
    new_head = DoublyListNode(head.val)
    prev = new_head
    current = head.next
    
    while current:
        new_node = DoublyListNode(current.val)
        new_node.prev = prev
        prev.next = new_node
        prev = new_node
        current = current.next
    
    return new_head

# Solution: Check if Circular
def is_circular(head):
    """Check if linked list is circular"""
    if not head:
        return False
    
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        
        if slow == fast:
            # Check if we're back at head
            temp = head
            while temp.next != head and temp.next:
                temp = temp.next
            return temp.next == head
    
    return False
```

Understanding these three types prepares you for 90% of LinkedList interview problems!