# Chapter 9: Coding Templates - Deep Dive

## Introduction to Templates

Templates are **proven, reusable code patterns** that solve common LinkedList problems. Mastering these templates allows you to:
- ✅ Solve problems faster in interviews
- ✅ Write bug-free code on first attempt
- ✅ Recognize patterns quickly
- ✅ Adapt templates to variations

**Interview Tip:** Top candidates recognize patterns and apply templates, rather than solving from scratch each time.

---

## Template 1: Basic Traversal

### Standard Forward Traversal

```python
def traverse(head):
    """
    Template: Basic iteration through LinkedList
    
    Use when: Need to visit each node once
    Time: O(n)
    Space: O(1)
    
    Pattern recognition:
    - "Visit all nodes"
    - "Process each element"
    - "Find/count/sum elements"
    """
    current = head
    
    while current:
        # ===== PROCESS CURRENT NODE =====
        # Your logic here (print, count, modify, etc.)
        print(current.val)
        # ================================
        
        current = current.next
    
    # Optional: return result after traversal

# Variations:

# 1. With index tracking
def traverse_with_index(head):
    """Track position while traversing"""
    current = head
    index = 0
    
    while current:
        print(f"Index {index}: {current.val}")
        current = current.next
        index += 1

# 2. With condition checking
def traverse_until_condition(head, target):
    """Stop when condition met"""
    current = head
    
    while current:
        if current.val == target:
            return current  # Found!
        current = current.next
    
    return None  # Not found

# 3. Process and collect results
def traverse_collect(head):
    """Collect results during traversal"""
    current = head
    results = []
    
    while current:
        results.append(current.val * 2)  # Example: double values
        current = current.next
    
    return results

# 4. With early termination
def traverse_with_limit(head, max_nodes):
    """Limit traversal to max_nodes"""
    current = head
    count = 0
    
    while current and count < max_nodes:
        print(current.val)
        current = current.next
        count += 1
```

### Recursive Traversal

```python
def traverse_recursive(node):
    """
    Template: Recursive traversal
    
    Use when: Need to process nodes in reverse or use call stack
    Time: O(n)
    Space: O(n) - Call stack
    
    Pattern recognition:
    - "Process in reverse order"
    - "Need to access nodes from end"
    - "Recursive solution required"
    """
    # ===== BASE CASE =====
    if not node:
        return
    # =====================
    
    # ===== RECURSIVE CASE =====
    # Process current node (pre-order)
    print(f"Forward: {node.val}")
    
    # Recurse to next node
    traverse_recursive(node.next)
    
    # Process current node (post-order)
    print(f"Backward: {node.val}")
    # ==========================

# Applications:

# 1. Reverse print
def print_reverse(node):
    """Print list in reverse without reversing structure"""
    if not node:
        return
    print_reverse(node.next)
    print(node.val)

# 2. Calculate depth
def calculate_depth(node, depth=0):
    """Calculate depth recursively"""
    if not node:
        return depth
    return calculate_depth(node.next, depth + 1)

# 3. Find nth from end (recursive)
def find_nth_from_end_recursive(node, n, counter=[0]):
    """Find nth from end using recursion"""
    if not node:
        return None
    
    result = find_nth_from_end_recursive(node.next, n, counter)
    counter[0] += 1
    
    if counter[0] == n:
        return node
    
    return result
```

---

## Template 2: Two Pointer Technique

### Fast-Slow Pointer (Floyd's)

```python
def two_pointer_fast_slow(head):
    """
    Template: Fast-slow pointer pattern
    
    Use when:
    - Finding middle
    - Detecting cycles
    - Finding nth from end (with variations)
    
    Time: O(n)
    Space: O(1)
    
    Pattern recognition:
    - "Find middle"
    - "Detect cycle"
    - "One pointer moves 2x speed"
    """
    # ===== INITIALIZATION =====
    slow = head
    fast = head
    # ==========================
    
    # ===== TRAVERSAL PATTERN =====
    while fast and fast.next:
        slow = slow.next          # Move 1 step
        fast = fast.next.next     # Move 2 steps
        
        # ===== YOUR LOGIC HERE =====
        # Check conditions, compare, etc.
        # ===========================
    # =============================
    
    # ===== RETURN RESULT =====
    return slow  # Usually slow is the answer
    # =========================

# Applications:

# 1. Find Middle
def find_middle(head):
    """Returns middle node"""
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow

# 2. Detect Cycle
def has_cycle(head):
    """Returns True if cycle exists"""
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False

# 3. Find Cycle Start
def find_cycle_start(head):
    """Returns node where cycle begins"""
    # Phase 1: Detect cycle
    slow = fast = head
    has_cycle = False
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            has_cycle = True
            break
    
    if not has_cycle:
        return None
    
    # Phase 2: Find start
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next
    
    return slow

# 4. Check Palindrome
def is_palindrome(head):
    """Check if list is palindrome"""
    # Find middle
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    # Reverse second half
    prev = None
    while slow:
        temp = slow.next
        slow.next = prev
        prev = slow
        slow = temp
    
    # Compare
    left, right = head, prev
    while right:
        if left.val != right.val:
            return False
        left = left.next
        right = right.next
    
    return True
```

### Two Pointers with Gap

```python
def two_pointer_with_gap(head, k):
    """
    Template: Two pointers with fixed gap
    
    Use when:
    - Remove nth from end
    - Find kth from end
    - Rotate by k
    
    Time: O(n)
    Space: O(1)
    
    Pattern recognition:
    - "Nth from end"
    - "Maintain distance k"
    - "Two pointers move together"
    """
    # ===== DUMMY NODE (OFTEN NEEDED) =====
    dummy = ListNode(0)
    dummy.next = head
    # =====================================
    
    # ===== INITIALIZATION =====
    first = dummy
    second = dummy
    # ==========================
    
    # ===== CREATE GAP =====
    # Move first pointer k+1 steps ahead
    for _ in range(k + 1):
        if not first:
            return None  # Invalid k
        first = first.next
    # ======================
    
    # ===== MOVE TOGETHER =====
    while first:
        first = first.next
        second = second.next
    # =========================
    
    # ===== PROCESS =====
    # second is now at (n-k)th position
    # Your logic here
    # ===================
    
    return dummy.next

# Applications:

# 1. Remove Nth From End
def remove_nth_from_end(head, n):
    """Remove nth node from end"""
    dummy = ListNode(0)
    dummy.next = head
    first = second = dummy
    
    # Create gap of n+1
    for _ in range(n + 1):
        first = first.next
    
    # Move together
    while first:
        first = first.next
        second = second.next
    
    # Remove node
    second.next = second.next.next
    return dummy.next

# 2. Find Kth From End
def find_kth_from_end(head, k):
    """Returns kth node from end"""
    first = second = head
    
    # Create gap of k
    for _ in range(k):
        if not first:
            return None
        first = first.next
    
    # Move together
    while first:
        first = first.next
        second = second.next
    
    return second

# 3. Rotate Right by K
def rotate_right_template(head, k):
    """Rotate list to the right by k places"""
    if not head or k == 0:
        return head
    
    # Find length
    length = 1
    tail = head
    while tail.next:
        tail = tail.next
        length += 1
    
    k = k % length
    if k == 0:
        return head
    
    # Find new tail (length - k - 1 from head)
    first = second = head
    for _ in range(k):
        first = first.next
    
    while first.next:
        first = first.next
        second = second.next
    
    # Rearrange
    new_head = second.next
    second.next = None
    first.next = head
    
    return new_head
```

---

## Template 3: Dummy Node Pattern

```python
def dummy_node_template(head):
    """
    Template: Dummy node pattern
    
    Use when:
    - Head might change
    - Merging lists
    - Removing nodes
    - Building new list
    
    Time: Usually O(n)
    Space: O(1)
    
    Pattern recognition:
    - "Head might be modified"
    - "Need to return new head"
    - "Simplify edge cases"
    """
    # ===== CREATE DUMMY =====
    dummy = ListNode(0)
    dummy.next = head
    # ========================
    
    # ===== WORKING POINTER =====
    current = dummy  # or head, depending on logic
    # ===========================
    
    # ===== YOUR LOGIC =====
    while current and current.next:
        # Process nodes
        # Modify current.next as needed
        current = current.next
    # ======================
    
    # ===== RETURN NEW HEAD =====
    return dummy.next
    # ===========================

# Applications:

# 1. Merge Two Sorted Lists
def merge_two_lists(l1, l2):
    """Merge using dummy node"""
    dummy = ListNode(0)
    tail = dummy
    
    while l1 and l2:
        if l1.val <= l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next
    
    tail.next = l1 or l2
    return dummy.next

# 2. Remove Elements
def remove_elements(head, val):
    """Remove all nodes with value val"""
    dummy = ListNode(0)
    dummy.next = head
    current = dummy
    
    while current.next:
        if current.next.val == val:
            current.next = current.next.next
        else:
            current = current.next
    
    return dummy.next

# 3. Partition List
def partition(head, x):
    """Partition list around value x"""
    # Two dummy nodes for two partitions
    less_dummy = ListNode(0)
    greater_dummy = ListNode(0)
    
    less = less_dummy
    greater = greater_dummy
    
    current = head
    while current:
        if current.val < x:
            less.next = current
            less = less.next
        else:
            greater.next = current
            greater = greater.next
        current = current.next
    
    # Connect partitions
    greater.next = None
    less.next = greater_dummy.next
    
    return less_dummy.next

# 4. Insertion Sort
def insertion_sort_list(head):
    """Sort list using insertion sort"""
    dummy = ListNode(0)
    current = head
    
    while current:
        # Save next before inserting
        next_temp = current.next
        
        # Find insertion position
        prev = dummy
        while prev.next and prev.next.val < current.val:
            prev = prev.next
        
        # Insert current
        current.next = prev.next
        prev.next = current
        
        current = next_temp
    
    return dummy.next
```

---

## Template 4: Reversal Pattern

```python
def reverse_iterative(head):
    """
    Template: Iterative reversal
    
    Use when:
    - Reverse entire list
    - Reverse portion of list
    - Reverse in groups
    
    Time: O(n)
    Space: O(1)
    
    Pattern recognition:
    - "Reverse list"
    - "Flip pointers"
    - "Change direction"
    """
    # ===== INITIALIZATION =====
    prev = None
    current = head
    # ==========================
    
    # ===== REVERSAL LOOP =====
    while current:
        # Save next
        next_temp = current.next
        
        # Reverse link
        current.next = prev
        
        # Move pointers
        prev = current
        current = next_temp
    # =========================
    
    # ===== RETURN NEW HEAD =====
    return prev
    # ===========================

# Applications:

# 1. Reverse Entire List
def reverse_list(head):
    """Standard reversal"""
    prev = None
    current = head
    
    while current:
        next_temp = current.next
        current.next = prev
        prev = current
        current = next_temp
    
    return prev

# 2. Reverse Between Positions
def reverse_between(head, left, right):
    """Reverse nodes from position left to right"""
    if not head or left == right:
        return head
    
    dummy = ListNode(0)
    dummy.next = head
    prev = dummy
    
    # Move to left-1 position
    for _ in range(left - 1):
        prev = prev.next
    
    # Reverse from left to right
    current = prev.next
    for _ in range(right - left):
        next_temp = current.next
        current.next = next_temp.next
        next_temp.next = prev.next
        prev.next = next_temp
    
    return dummy.next

# 3. Reverse in K Groups
def reverse_k_group(head, k):
    """Reverse nodes in groups of k"""
    def reverse_segment(start, k):
        prev = None
        current = start
        for _ in range(k):
            next_temp = current.next
            current.next = prev
            prev = current
            current = next_temp
        return prev, start, current
    
    # Count nodes
    count = 0
    node = head
    while node:
        count += 1
        node = node.next
    
    dummy = ListNode(0)
    dummy.next = head
    prev_tail = dummy
    
    while count >= k:
        group_start = prev_tail.next
        new_head, new_tail, next_start = reverse_segment(group_start, k)
        
        prev_tail.next = new_head
        new_tail.next = next_start
        prev_tail = new_tail
        
        count -= k
    
    return dummy.next

# 4. Reverse Recursive
def reverse_recursive(head):
    """Recursive reversal template"""
    # Base case
    if not head or not head.next:
        return head
    
    # Recurse
    new_head = reverse_recursive(head.next)
    
    # Reverse link
    head.next.next = head
    head.next = None
    
    return new_head
```

---

## Template 5: Merge Pattern

```python
def merge_template(l1, l2):
    """
    Template: Merging two lists
    
    Use when:
    - Merge two sorted lists
    - Merge alternately
    - Combine lists with condition
    
    Time: O(n + m)
    Space: O(1)
    
    Pattern recognition:
    - "Merge two lists"
    - "Combine sorted lists"
    - "Interleave lists"
    """
    # ===== DUMMY NODE =====
    dummy = ListNode(0)
    tail = dummy
    # ======================
    
    # ===== MERGE LOOP =====
    while l1 and l2:
        # Compare and choose
        if l1.val <= l2.val:  # Your condition here
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next
    # ======================
    
    # ===== ATTACH REMAINING =====
    tail.next = l1 or l2
    # ============================
    
    return dummy.next

# Applications:

# 1. Merge Sorted Lists
def merge_sorted(l1, l2):
    """Standard merge"""
    dummy = ListNode(0)
    tail = dummy
    
    while l1 and l2:
        if l1.val <= l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next
    
    tail.next = l1 or l2
    return dummy.next

# 2. Merge Alternately
def merge_alternately(l1, l2):
    """Merge nodes alternately"""
    dummy = ListNode(0)
    tail = dummy
    
    while l1 and l2:
        # Take from l1
        tail.next = l1
        l1 = l1.next
        tail = tail.next
        
        # Take from l2
        tail.next = l2
        l2 = l2.next
        tail = tail.next
    
    tail.next = l1 or l2
    return dummy.next

# 3. Merge K Lists (Divide & Conquer)
def merge_k_lists(lists):
    """Merge k sorted lists"""
    if not lists:
        return None
    
    def merge_two(l1, l2):
        dummy = ListNode(0)
        tail = dummy
        
        while l1 and l2:
            if l1.val <= l2.val:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next
        
        tail.next = l1 or l2
        return dummy.next
    
    while len(lists) > 1:
        merged = []
        for i in range(0, len(lists), 2):
            l1 = lists[i]
            l2 = lists[i + 1] if i + 1 < len(lists) else None
            merged.append(merge_two(l1, l2))
        lists = merged
    
    return lists[0]
```

---

## Template 6: Split/Find Pattern

```python
def split_find_template(head):
    """
    Template: Split or find in list
    
    Use when:
    - Split at middle
    - Find specific node
    - Partition list
    
    Time: O(n)
    Space: O(1)
    
    Pattern recognition:
    - "Split into halves"
    - "Find middle"
    - "Partition around value"
    """
    # ===== FIND MIDDLE/SPLIT POINT =====
    slow = fast = head
    prev = None
    
    while fast and fast.next:
        prev = slow
        slow = slow.next
        fast = fast.next.next
    # ===================================
    
    # ===== SPLIT IF NEEDED =====
    if prev:
        prev.next = None  # Split into two lists
    # ===========================
    
    # ===== RETURN RESULT =====
    return head, slow  # First half, second half
    # =========================

# Applications:

# 1. Merge Sort
def merge_sort(head):
    """Sort using merge sort"""
    if not head or not head.next:
        return head
    
    # Split
    slow = fast = head
    prev = None
    while fast and fast.next:
        prev = slow
        slow = slow.next
        fast = fast.next.next
    
    prev.next = None
    
    # Recursively sort
    left = merge_sort(head)
    right = merge_sort(slow)
    
    # Merge
    return merge_sorted(left, right)

# 2. Palindrome Check
def is_palindrome_split(head):
    """Check palindrome by splitting"""
    # Find middle
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    # Reverse second half
    prev = None
    while slow:
        temp = slow.next
        slow.next = prev
        prev = slow
        slow = temp
    
    # Compare
    left, right = head, prev
    while right:
        if left.val != right.val:
            return False
        left = left.next
        right = right.next
    
    return True

# 3. Partition Around Value
def partition_around_x(head, x):
    """Partition list around value x"""
    less_head = less_tail = ListNode(0)
    greater_head = greater_tail = ListNode(0)
    
    current = head
    while current:
        if current.val < x:
            less_tail.next = current
            less_tail = less_tail.next
        else:
            greater_tail.next = current
            greater_tail = greater_tail.next
        current = current.next
    
    greater_tail.next = None
    less_tail.next = greater_head.next
    
    return less_head.next
```

---

## Template Usage Guide

### Quick Decision Tree

```
Problem involves...

1. "Reverse" → Use Reversal Template
2. "Merge two" → Use Merge Template
3. "Find middle" → Use Fast-Slow Template
4. "Remove/modify head" → Use Dummy Node Template
5. "Nth from end" → Use Two Pointers with Gap
6. "Cycle" → Use Fast-Slow Template
7. "Sort" → Use Split + Merge Templates
8. "Basic iteration" → Use Traversal Template
```

### Template Combinations

Many problems require **combining templates**:

```python
# Example: Reorder List
def reorder_list(head):
    """
    Combines:
    1. Split Template (find middle)
    2. Reversal Template (reverse second half)
    3. Merge Template (merge alternately)
    """
    if not head or not head.next:
        return
    
    # Template 1: Find middle (Split)
    slow = fast = head
    while fast.next and fast.next.next:
        slow = slow.next
        fast = fast.next.next
    
    # Split
    second = slow.next
    slow.next = None
    
    # Template 2: Reverse second half
    prev = None
    current = second
    while current:
        temp = current.next
        current.next = prev
        prev = current
        current = temp
    second = prev
    
    # Template 3: Merge alternately
    first = head
    while second:
        temp1 = first.next
        temp2 = second.next
        
        first.next = second
        second.next = temp1
        
        first = temp1
        second = temp2
```

---

## Practice: Template Application

### Exercise 1
**Problem:** Delete duplicate nodes (keep first occurrence)
**Templates needed:** Traversal + modification

### Exercise 2
**Problem:** Add two numbers (reverse order)
**Templates needed:** Traversal + dummy node

### Exercise 3
**Problem:** Split circular list into two halves
**Templates needed:** Fast-slow + split

### Exercise 4
**Problem:** Check if list is sorted
**Templates needed:** Traversal

**Solutions available - try implementing using templates first!**

---

## Key Takeaways

1. **Recognize patterns** before coding
2. **Templates save time** in interviews
3. **Practice variations** of each template
4. **Combine templates** for complex problems
5. **Master the basics** - they appear everywhere

**Pro Tip:** Keep a cheat sheet of these templates for quick reference during practice!