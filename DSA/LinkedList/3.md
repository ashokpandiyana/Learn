# Chapter 3: Basic Operations & Implementation - Deep Dive

## 3.1 Creating a LinkedList

### Basic LinkedList Class Structure

```python
class LinkedList:
    """A complete LinkedList implementation"""
    
    def __init__(self):
        self.head = None
        self.tail = None  # Optional but useful
        self.size = 0
    
    def __len__(self):
        """Allow len(linkedlist)"""
        return self.size
    
    def __str__(self):
        """String representation"""
        if not self.head:
            return "Empty List"
        
        elements = []
        current = self.head
        while current:
            elements.append(str(current.val))
            current = current.next
        return " → ".join(elements)
    
    def __iter__(self):
        """Make it iterable"""
        current = self.head
        while current:
            yield current.val
            current = current.next
    
    def __getitem__(self, index):
        """Allow indexing: linkedlist[2]"""
        if index < 0 or index >= self.size:
            raise IndexError("Index out of range")
        
        current = self.head
        for _ in range(index):
            current = current.next
        return current.val

# Usage examples
ll = LinkedList()
print(len(ll))          # 0
print(ll)               # Empty List

# After adding elements:
# for val in ll:        # Iterate like a list
#     print(val)
# print(ll[0])          # Access by index
```

### Creating from Different Sources

```python
def create_from_list(values):
    """Create LinkedList from Python list"""
    ll = LinkedList()
    for val in values:
        ll.insert_at_tail(val)
    return ll

def create_from_range(start, end, step=1):
    """Create LinkedList from range"""
    ll = LinkedList()
    for val in range(start, end, step):
        ll.insert_at_tail(val)
    return ll

def create_from_input():
    """Create LinkedList from user input"""
    ll = LinkedList()
    n = int(input("Enter number of elements: "))
    for i in range(n):
        val = int(input(f"Enter element {i+1}: "))
        ll.insert_at_tail(val)
    return ll

# Usage
ll1 = create_from_list([1, 2, 3, 4, 5])
ll2 = create_from_range(0, 10, 2)  # [0, 2, 4, 6, 8]
```

---

## 3.2 Insertion Operations

### Insert at Beginning (Head) - O(1)

```python
def insert_at_head(self, val):
    """
    Insert new node at the beginning
    Time: O(1) - Constant time regardless of list size
    Space: O(1) - Only one new node created
    """
    new_node = ListNode(val)
    
    # Step 1: Point new node to current head
    new_node.next = self.head
    
    # Step 2: Update head to new node
    self.head = new_node
    
    # Step 3: If list was empty, update tail too
    if self.tail is None:
        self.tail = new_node
    
    self.size += 1
    return True

# Visual walkthrough:
"""
Before: HEAD → [10] → [20] → [30] → None
Insert 5:
    
Step 1: Create new_node(5)
        [5] → ?

Step 2: new_node.next = head
        [5] → [10] → [20] → [30] → None

Step 3: head = new_node
HEAD → [5] → [10] → [20] → [30] → None
"""

# Usage
ll = LinkedList()
ll.insert_at_head(10)  # [10]
ll.insert_at_head(20)  # [20 → 10]
ll.insert_at_head(30)  # [30 → 20 → 10]
print(ll)  # 30 → 20 → 10
```

### Insert at End (Tail) - O(n) without tail, O(1) with tail

```python
# Version 1: Without tail pointer - O(n)
def insert_at_tail_slow(self, val):
    """
    Insert at end by traversing entire list
    Time: O(n) - Must traverse to last node
    Space: O(1)
    """
    new_node = ListNode(val)
    
    # Special case: empty list
    if not self.head:
        self.head = new_node
        self.size += 1
        return True
    
    # Traverse to last node
    current = self.head
    while current.next:  # O(n) traversal
        current = current.next
    
    # Attach new node
    current.next = new_node
    self.size += 1
    return True

# Version 2: With tail pointer - O(1)
def insert_at_tail(self, val):
    """
    Insert at end using tail pointer
    Time: O(1) - Direct access to tail
    Space: O(1)
    """
    new_node = ListNode(val)
    
    if not self.head:
        # Empty list
        self.head = self.tail = new_node
    else:
        # Attach to current tail
        self.tail.next = new_node
        self.tail = new_node
    
    self.size += 1
    return True

# Visual walkthrough with tail pointer:
"""
Before: HEAD → [10] → [20] → [30] ← TAIL
                               ↑
Insert 40:

Step 1: Create new_node(40)
        [40] → None

Step 2: tail.next = new_node
HEAD → [10] → [20] → [30] → [40]
                      ↑       ↑
                    old tail  new node

Step 3: tail = new_node
HEAD → [10] → [20] → [30] → [40] ← TAIL
"""
```

### Insert at Position - O(n)

```python
def insert_at_position(self, val, position):
    """
    Insert at specific position (0-indexed)
    Time: O(n) - May need to traverse to position
    Space: O(1)
    """
    # Validate position
    if position < 0 or position > self.size:
        raise IndexError(f"Position {position} out of range [0, {self.size}]")
    
    # Special cases
    if position == 0:
        return self.insert_at_head(val)
    
    if position == self.size:
        return self.insert_at_tail(val)
    
    # General case: insert in middle
    new_node = ListNode(val)
    current = self.head
    
    # Traverse to position - 1
    for _ in range(position - 1):
        current = current.next
    
    # Insert new node
    new_node.next = current.next
    current.next = new_node
    
    self.size += 1
    return True

# Visual example:
"""
Insert 25 at position 2 in [10 → 20 → 30 → 40]

Step 1: Traverse to position 1 (index 2 - 1)
HEAD → [10] → [20] → [30] → [40]
               ↑
            current

Step 2: Create new_node and link
new_node.next = current.next
[25] → [30]

Step 3: current.next = new_node
HEAD → [10] → [20] → [25] → [30] → [40]
               ↑       ↑
           current  new_node
"""

# Usage with error handling
ll = LinkedList()
ll.insert_at_tail(10)
ll.insert_at_tail(20)
ll.insert_at_tail(30)

try:
    ll.insert_at_position(25, 2)  # [10 → 20 → 25 → 30]
    ll.insert_at_position(5, 0)   # [5 → 10 → 20 → 25 → 30]
    ll.insert_at_position(35, 10) # Error!
except IndexError as e:
    print(f"Error: {e}")
```

### Insert in Sorted Order - O(n)

```python
def insert_sorted(self, val):
    """
    Insert value in sorted order (ascending)
    Time: O(n) - May need to traverse entire list
    Space: O(1)
    
    Assumes list is already sorted!
    """
    new_node = ListNode(val)
    
    # Case 1: Empty list or insert at head
    if not self.head or val <= self.head.val:
        new_node.next = self.head
        self.head = new_node
        if not self.tail:
            self.tail = new_node
        self.size += 1
        return True
    
    # Case 2: Find correct position
    current = self.head
    while current.next and current.next.val < val:
        current = current.next
    
    # Insert new node
    new_node.next = current.next
    current.next = new_node
    
    # Update tail if inserted at end
    if not new_node.next:
        self.tail = new_node
    
    self.size += 1
    return True

# Example usage:
ll = LinkedList()
for val in [10, 30, 50, 70]:
    ll.insert_at_tail(val)

print(ll)  # 10 → 30 → 50 → 70

ll.insert_sorted(40)
print(ll)  # 10 → 30 → 40 → 50 → 70

ll.insert_sorted(5)
print(ll)  # 5 → 10 → 30 → 40 → 50 → 70

ll.insert_sorted(100)
print(ll)  # 5 → 10 → 30 → 40 → 50 → 70 → 100
```

---

## 3.3 Deletion Operations

### Delete Head - O(1)

```python
def delete_at_head(self):
    """
    Delete first node
    Time: O(1)
    Space: O(1)
    Returns: Value of deleted node or None if empty
    """
    # Case 1: Empty list
    if not self.head:
        return None
    
    # Case 2: Store value to return
    deleted_val = self.head.val
    
    # Case 3: Only one node
    if self.head == self.tail:
        self.head = self.tail = None
    else:
        # Case 4: Multiple nodes
        self.head = self.head.next
    
    self.size -= 1
    return deleted_val

# Visual walkthrough:
"""
Before: HEAD → [10] → [20] → [30] → None

Step 1: Store deleted_val = 10
Step 2: HEAD = HEAD.next

After:  HEAD → [20] → [30] → None

The [10] node becomes unreachable (garbage collected in Python)
"""

# Usage
ll = create_from_list([10, 20, 30])
print(ll.delete_at_head())  # Returns 10, list is now [20 → 30]
print(ll.delete_at_head())  # Returns 20, list is now [30]
print(ll.delete_at_head())  # Returns 30, list is empty
print(ll.delete_at_head())  # Returns None
```

### Delete Tail - O(n)

```python
def delete_at_tail(self):
    """
    Delete last node
    Time: O(n) - Must find second-to-last node
    Space: O(1)
    Returns: Value of deleted node or None if empty
    """
    # Case 1: Empty list
    if not self.head:
        return None
    
    # Case 2: Only one node
    if self.head == self.tail:
        deleted_val = self.head.val
        self.head = self.tail = None
        self.size -= 1
        return deleted_val
    
    # Case 3: Multiple nodes - find second-to-last
    current = self.head
    while current.next.next:  # Stop at second-to-last
        current = current.next
    
    deleted_val = current.next.val
    current.next = None
    self.tail = current
    self.size -= 1
    
    return deleted_val

# Visual walkthrough:
"""
Before: HEAD → [10] → [20] → [30] → [40] ← TAIL

Step 1: Traverse to second-to-last
HEAD → [10] → [20] → [30] → [40]
                      ↑
                   current

Step 2: current.next = None
HEAD → [10] → [20] → [30] → None
                      ↑
                    TAIL

Step 3: Update tail
[40] becomes unreachable
"""

# Note: For doubly linked list, this would be O(1)!
```

### Delete at Position - O(n)

```python
def delete_at_position(self, position):
    """
    Delete node at specific position (0-indexed)
    Time: O(n) - May need to traverse to position
    Space: O(1)
    Returns: Value of deleted node
    """
    # Validate position
    if position < 0 or position >= self.size:
        raise IndexError(f"Position {position} out of range")
    
    # Special case: delete head
    if position == 0:
        return self.delete_at_head()
    
    # Special case: delete tail
    if position == self.size - 1:
        return self.delete_at_tail()
    
    # General case: delete from middle
    current = self.head
    
    # Traverse to position - 1
    for _ in range(position - 1):
        current = current.next
    
    # Delete node
    deleted_val = current.next.val
    current.next = current.next.next
    
    self.size -= 1
    return deleted_val

# Visual example:
"""
Delete position 2 from [10 → 20 → 30 → 40 → 50]

Step 1: Traverse to position 1
HEAD → [10] → [20] → [30] → [40] → [50]
               ↑       ↑
           current  to_delete

Step 2: current.next = current.next.next
HEAD → [10] → [20] → [40] → [50]
               ↑       ↑
           current  (30 removed)
"""
```

### Delete by Value - O(n)

```python
def delete_value(self, target):
    """
    Delete first occurrence of value
    Time: O(n) - May need to search entire list
    Space: O(1)
    Returns: True if deleted, False if not found
    """
    # Case 1: Empty list
    if not self.head:
        return False
    
    # Case 2: Target is at head
    if self.head.val == target:
        self.delete_at_head()
        return True
    
    # Case 3: Search for target
    current = self.head
    while current.next:
        if current.next.val == target:
            # Found it! Delete
            deleted_node = current.next
            current.next = current.next.next
            
            # Update tail if we deleted last node
            if deleted_node == self.tail:
                self.tail = current
            
            self.size -= 1
            return True
        
        current = current.next
    
    # Not found
    return False

def delete_all_occurrences(self, target):
    """
    Delete ALL occurrences of value
    Time: O(n)
    Space: O(1)
    Returns: Count of nodes deleted
    """
    count = 0
    
    # Remove from head while it matches
    while self.head and self.head.val == target:
        self.delete_at_head()
        count += 1
    
    if not self.head:
        return count
    
    # Remove from rest of list
    current = self.head
    while current.next:
        if current.next.val == target:
            current.next = current.next.next
            self.size -= 1
            count += 1
            # Don't move current - check again
        else:
            current = current.next
    
    # Update tail if needed
    self.tail = current
    
    return count

# Example usage:
ll = create_from_list([10, 20, 30, 20, 40, 20])
print(ll)  # 10 → 20 → 30 → 20 → 40 → 20

ll.delete_value(20)
print(ll)  # 10 → 30 → 20 → 40 → 20 (first 20 removed)

ll2 = create_from_list([10, 20, 30, 20, 40, 20])
count = ll2.delete_all_occurrences(20)
print(f"Deleted {count} nodes")  # 3
print(ll2)  # 10 → 30 → 40
```

### Delete Given Node (Special Case) - O(1)

```python
def delete_node_reference(node):
    """
    Delete a node when given only the node reference
    (Not the head of the list!)
    
    Constraint: node is NOT the tail
    
    Time: O(1)
    Space: O(1)
    
    Trick: Copy next node's data and delete next node instead!
    """
    if not node or not node.next:
        # Cannot delete tail this way
        raise ValueError("Cannot delete tail node without list reference")
    
    # Copy next node's value
    node.val = node.next.val
    
    # Delete next node
    node.next = node.next.next

# Visual walkthrough:
"""
Given: Delete node [20] from [10] → [20] → [30] → [40]
                                      ↑
                                    node

Step 1: Copy next node's value
[10] → [30] → [30] → [40]
        ↑
      node (now has value 30!)

Step 2: Skip next node
[10] → [30] → [40]
        ↑
      node

Result: Appears like [20] was deleted!
"""

# Example:
ll = create_from_list([10, 20, 30, 40])
second_node = ll.head.next  # Reference to node with value 20
delete_node_reference(second_node)
print(ll)  # 10 → 30 → 40
```

---

## 3.4 Traversal & Search Operations

### Basic Traversal

```python
def traverse(self):
    """
    Basic forward traversal
    Time: O(n)
    Space: O(1)
    """
    current = self.head
    while current:
        print(current.val, end=" → ")
        current = current.next
    print("None")

def traverse_with_callback(self, callback):
    """
    Traverse and apply function to each node
    Time: O(n)
    Space: O(1)
    """
    current = self.head
    while current:
        callback(current.val)
        current = current.next

# Usage:
ll = create_from_list([1, 2, 3, 4, 5])
ll.traverse()  # 1 → 2 → 3 → 4 → 5 → None

# With callback
ll.traverse_with_callback(lambda x: print(x * 2, end=" "))
# Output: 2 4 6 8 10
```

### Recursive Traversal

```python
def traverse_recursive(node):
    """
    Recursive traversal
    Time: O(n)
    Space: O(n) - Call stack
    """
    if not node:
        return
    
    print(node.val, end=" → ")
    traverse_recursive(node.next)

def traverse_reverse_recursive(node):
    """
    Print in reverse order using recursion
    Time: O(n)
    Space: O(n) - Call stack
    """
    if not node:
        return
    
    traverse_reverse_recursive(node.next)
    print(node.val, end=" ← ")

# Example:
ll = create_from_list([1, 2, 3, 4, 5])
traverse_recursive(ll.head)          # 1 → 2 → 3 → 4 → 5
print()
traverse_reverse_recursive(ll.head)  # 5 ← 4 ← 3 ← 2 ← 1
```

### Search Operations

```python
def search(self, target):
    """
    Search for value and return position
    Time: O(n)
    Space: O(1)
    Returns: Index if found, -1 otherwise
    """
    current = self.head
    position = 0
    
    while current:
        if current.val == target:
            return position
        current = current.next
        position += 1
    
    return -1

def search_node(self, target):
    """
    Search and return node reference
    Time: O(n)
    Space: O(1)
    """
    current = self.head
    
    while current:
        if current.val == target:
            return current
        current = current.next
    
    return None

def contains(self, target):
    """
    Check if value exists
    Time: O(n)
    Space: O(1)
    """
    return self.search(target) != -1

def find_nth_node(self, n):
    """
    Find nth node from beginning (0-indexed)
    Time: O(n)
    Space: O(1)
    """
    current = self.head
    
    for _ in range(n):
        if not current:
            return None
        current = current.next
    
    return current

# Example usage:
ll = create_from_list([10, 20, 30, 40, 50])

print(ll.search(30))           # 2
print(ll.contains(35))         # False
print(ll.search_node(40).val)  # 40
print(ll.find_nth_node(2).val) # 30
```

---

## Edge Cases and Error Handling

### Comprehensive Edge Case Handling

```python
class RobustLinkedList:
    """LinkedList with comprehensive edge case handling"""
    
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0
    
    def _validate_not_empty(self):
        """Check if list is empty"""
        if not self.head:
            raise ValueError("Operation on empty list")
    
    def _validate_index(self, index):
        """Validate index range"""
        if index < 0 or index >= self.size:
            raise IndexError(f"Index {index} out of range [0, {self.size})")
    
    def safe_get(self, index, default=None):
        """Get value at index with default"""
        try:
            self._validate_index(index)
            return self[index]
        except IndexError:
            return default
    
    def safe_delete(self, index):
        """Delete with error handling"""
        try:
            return self.delete_at_position(index)
        except IndexError as e:
            print(f"Error: {e}")
            return None

# Test edge cases:
ll = RobustLinkedList()

# Edge case 1: Operations on empty list
try:
    ll.delete_at_head()  # Should handle gracefully
except ValueError as e:
    print(f"Caught: {e}")

# Edge case 2: Single node operations
ll.insert_at_head(10)
ll.delete_at_head()  # Should work correctly

# Edge case 3: Index validation
ll = create_from_list([1, 2, 3])
print(ll.safe_get(5))       # Returns None instead of crashing
print(ll.safe_get(1))       # Returns 2
```

---

## Complete LinkedList Implementation

```python
class CompleteLinkedList:
    """Production-ready LinkedList implementation"""
    
    class Node:
        def __init__(self, val=0, next=None):
            self.val = val
            self.next = next
    
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0
    
    # ===== Creation Methods =====
    @classmethod
    def from_list(cls, values):
        """Create from Python list"""
        ll = cls()
        for val in values:
            ll.insert_at_tail(val)
        return ll
    
    # ===== Insertion Methods =====
    def insert_at_head(self, val):
        """O(1)"""
        new_node = self.Node(val, self.head)
        self.head = new_node
        if self.tail is None:
            self.tail = new_node
        self.size += 1
    
    def insert_at_tail(self, val):
        """O(1) with tail pointer"""
        new_node = self.Node(val)
        if not self.head:
            self.head = self.tail = new_node
        else:
            self.tail.next = new_node
            self.tail = new_node
        self.size += 1
    
    def insert_at_position(self, val, pos):
        """O(n)"""
        if pos < 0 or pos > self.size:
            raise IndexError(f"Position out of range")
        
        if pos == 0:
            self.insert_at_head(val)
        elif pos == self.size:
            self.insert_at_tail(val)
        else:
            new_node = self.Node(val)
            current = self.head
            for _ in range(pos - 1):
                current = current.next
            new_node.next = current.next
            current.next = new_node
            self.size += 1
    
    # ===== Deletion Methods =====
    def delete_at_head(self):
        """O(1)"""
        if not self.head:
            return None
        val = self.head.val
        self.head = self.head.next
        if not self.head:
            self.tail = None
        self.size -= 1
        return val
    
    def delete_at_tail(self):
        """O(n)"""
        if not self.head:
            return None
        if self.head == self.tail:
            val = self.head.val
            self.head = self.tail = None
            self.size -= 1
            return val
        
        current = self.head
        while current.next != self.tail:
            current = current.next
        val = self.tail.val
        current.next = None
        self.tail = current
        self.size -= 1
        return val
    
    def delete_value(self, target):
        """O(n)"""
        if not self.head:
            return False
        
        if self.head.val == target:
            self.delete_at_head()
            return True
        
        current = self.head
        while current.next:
            if current.next.val == target:
                if current.next == self.tail:
                    self.tail = current
                current.next = current.next.next
                self.size -= 1
                return True
            current = current.next
        return False
    
    # ===== Search Methods =====
    def search(self, target):
        """O(n)"""
        current = self.head
        pos = 0
        while current:
            if current.val == target:
                return pos
            current = current.next
            pos += 1
        return -1
    
    # ===== Utility Methods =====
    def __len__(self):
        return self.size
    
    def __str__(self):
        if not self.head:
            return "[]"
        vals = []
        current = self.head
        while current:
            vals.append(str(current.val))
            current = current.next
        return " → ".join(vals)
    
    def __iter__(self):
        current = self.head
        while current:
            yield current.val
            current = current.next
    
    def clear(self):
        """Clear entire list"""
        self.head = self.tail = None
        self.size = 0
    
    def reverse(self):
        """Reverse the list in-place"""
        prev = None
        current = self.head
        self.tail = self.head
        
        while current:
            next_temp = current.next
            current.next = prev
            prev = current
            current = next_temp
        
        self.head = prev

# Example usage of complete implementation:
ll = CompleteLinkedList.from_list([1, 2, 3, 4, 5])
print(f"List: {ll}")
print(f"Length: {len(ll)}")
print(f"Contains 3: {ll.search(3) != -1}")

ll.insert_at_position(10, 2)
print(f"After insert at pos 2: {ll}")

ll.delete_value(10)
print(f"After delete 10: {ll}")

ll.reverse()
print(f"After reverse: {ll}")
```

---

## Summary and Best Practices

### Key Points
1. **Always maintain size**: Helps with validation and efficiency
2. **Use tail pointer**: Makes tail operations O(1)
3. **Handle edge cases**: Empty list, single node, head/tail changes
4. **Validate inputs**: Check indices and null references
5. **Return meaningful values**: Help caller understand what happened

### Common Mistakes to Avoid
- ❌ Forgetting to update tail pointer
- ❌ Not handling empty list
- ❌ Losing reference to head
- ❌ Off-by-one errors in position calculations
- ❌ Not checking for null before accessing .next

### Practice Problems
1. Implement a method to remove duplicates from unsorted list
2. Partition list around value x
3. Check if list is palindrome
4. Add two numbers represented as linked lists
5. Find intersection point of two lists

These fundamentals form the foundation for all advanced LinkedList operations!