# Chapter 4: Essential Patterns & Techniques - Deep Dive

## 4.1 Two Pointer Technique ⭐⭐⭐

### Introduction

The **Two Pointer Technique** is the most important pattern in LinkedList problems. It appears in approximately 40% of interview questions!

**Core Idea**: Use two pointers traversing the list at different speeds or with different starting positions.

### Pattern 1: Slow-Fast Pointers (Floyd's Tortoise and Hare)

#### Concept
- **Slow pointer**: Moves 1 step at a time
- **Fast pointer**: Moves 2 steps at a time
- When fast reaches end, slow is at middle!

```python
def slow_fast_template(head):
    """
    Basic slow-fast pointer template
    Time: O(n)
    Space: O(1)
    """
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next          # Move 1 step
        fast = fast.next.next     # Move 2 steps
        
        # Do something with slow and fast
    
    return slow  # Usually at middle or meeting point
```

#### Visual Representation

```
Initial: S,F → [1] → [2] → [3] → [4] → [5] → None

Step 1:  [1] → S[2] → [3] → F[4] → [5] → None

Step 2:  [1] → [2] → S[3] → [4] → [5] → F None

Step 3:  [1] → [2] → [3] → S[4] → [5] → None
         Fast reached end, Slow at middle!
```

#### Problem 1: Find Middle of LinkedList

```python
def find_middle(head):
    """
    Find the middle node of a LinkedList
    If even number of nodes, return second middle
    
    Time: O(n)
    Space: O(1)
    
    Example:
    [1→2→3→4→5] → returns 3
    [1→2→3→4] → returns 3
    """
    if not head:
        return None
    
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow

# Visual walkthrough for [1→2→3→4→5]:
"""
Start: S,F at [1]
Step 1: S at [2], F at [3]
Step 2: S at [3], F at [5]
Step 3: F.next is None, stop
Result: S at [3] ✓
"""

# For even length [1→2→3→4]:
"""
Start: S,F at [1]
Step 1: S at [2], F at [3]
Step 2: S at [3], F at None
Result: S at [3] (second middle)
"""

def find_first_middle(head):
    """Return first middle for even-length lists"""
    if not head or not head.next:
        return head
    
    slow = head
    fast = head.next
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow

# Test
ll = create_from_list([1, 2, 3, 4, 5])
print(find_middle(ll.head).val)  # 3

ll2 = create_from_list([1, 2, 3, 4])
print(find_middle(ll2.head).val)  # 3
print(find_first_middle(ll2.head).val)  # 2
```

#### Problem 2: Detect Cycle in LinkedList

```python
def has_cycle(head):
    """
    Detect if LinkedList has a cycle
    
    Time: O(n)
    Space: O(1)
    
    Key insight: If there's a cycle, fast will eventually
    catch up to slow inside the cycle!
    """
    if not head or not head.next:
        return False
    
    slow = head
    fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        
        if slow == fast:
            return True  # Cycle detected!
    
    return False  # Reached end, no cycle

# Visual with cycle:
"""
[1] → [2] → [3] → [4] → [5]
            ↑             ↓
            └─────────────┘

Step 1: S at [2], F at [4]
Step 2: S at [3], F at [2] (wrapped around)
Step 3: S at [4], F at [4] → MATCH! Cycle found!
"""

# Create a list with cycle for testing
def create_cycle_list():
    head = ListNode(1)
    head.next = ListNode(2)
    head.next.next = ListNode(3)
    head.next.next.next = ListNode(4)
    head.next.next.next.next = head.next  # Create cycle
    return head

cyclic = create_cycle_list()
print(has_cycle(cyclic))  # True

normal = create_from_list([1, 2, 3, 4])
print(has_cycle(normal))  # False
```

#### Problem 3: Find Cycle Start Node (Advanced!)

```python
def detect_cycle_start(head):
    """
    Find the node where cycle begins
    
    Time: O(n)
    Space: O(1)
    
    Mathematical proof:
    - Let x = distance from head to cycle start
    - Let y = distance from cycle start to meeting point
    - Let c = cycle length
    
    When they meet:
    - Slow traveled: x + y
    - Fast traveled: x + y + nc (n full cycles)
    - Since fast is 2x speed: 2(x + y) = x + y + nc
    - Simplifying: x + y = nc
    - Therefore: x = nc - y = (n-1)c + (c - y)
    
    This means: distance from head to start = 
                distance from meeting point to start!
    """
    if not head or not head.next:
        return None
    
    # Phase 1: Detect if cycle exists
    slow = fast = head
    has_cycle = False
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            has_cycle = True
            break
    
    if not has_cycle:
        return None
    
    # Phase 2: Find cycle start
    # Reset slow to head, keep fast at meeting point
    slow = head
    
    # Move both at same speed
    while slow != fast:
        slow = slow.next
        fast = fast.next
    
    return slow  # This is the cycle start!

# Visual explanation:
"""
[1] → [2] → [3] → [4] → [5]
            ↑             ↓
            └─────────────┘
            Cycle starts at [3]

Meeting point calculation:
x = 2 (distance to cycle start)
y = 2 (distance to meeting in cycle)
c = 3 (cycle length)

After meeting, reset slow to head:
Slow at [1], Fast at meeting point
Both move 1 step: will meet at [3] (cycle start)!
"""

# Test
cyclic = create_cycle_list()
start = detect_cycle_start(cyclic)
print(start.val)  # Should print value of cycle start node
```

#### Problem 4: Check if LinkedList is Palindrome

```python
def is_palindrome(head):
    """
    Check if LinkedList is a palindrome
    
    Approach:
    1. Find middle using slow-fast
    2. Reverse second half
    3. Compare both halves
    
    Time: O(n)
    Space: O(1)
    """
    if not head or not head.next:
        return True
    
    # Step 1: Find middle
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    # Step 2: Reverse second half
    second_half = reverse_list(slow)
    
    # Step 3: Compare both halves
    first_half = head
    while second_half:
        if first_half.val != second_half.val:
            return False
        first_half = first_half.next
        second_half = second_half.next
    
    return True

def reverse_list(head):
    """Helper: Reverse a LinkedList"""
    prev = None
    curr = head
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    return prev

# Visual walkthrough for [1→2→3→2→1]:
"""
Step 1: Find middle
[1] → [2] → [3] → [2] → [1]
              ↑
           middle

Step 2: Reverse from middle
First:  [1] → [2] → [3]
Second: [1] → [2] ← [3]

Step 3: Compare
[1]==[1] ✓, [2]==[2] ✓, [3] done
Result: Palindrome!
"""

# Test
ll1 = create_from_list([1, 2, 3, 2, 1])
print(is_palindrome(ll1))  # True

ll2 = create_from_list([1, 2, 3, 4, 5])
print(is_palindrome(ll2))  # False
```

### Pattern 2: Two Separate Pointers (Gap/Window)

#### Concept
Two pointers move at the same speed but with an offset (gap) between them.

```python
def two_pointer_gap_template(head, k):
    """
    Template with k-gap between pointers
    
    Common uses:
    - Remove Nth from end
    - Find kth from end
    - Window operations
    """
    first = second = head
    
    # Move first pointer k steps ahead
    for _ in range(k):
        if not first:
            return None
        first = first.next
    
    # Move both together
    while first:
        first = first.next
        second = second.next
    
    return second  # Second is k nodes behind first
```

#### Problem 5: Remove Nth Node from End

```python
def remove_nth_from_end(head, n):
    """
    Remove the nth node from the end of list
    
    Approach: Use dummy node + two pointers with gap
    
    Time: O(L) where L is length
    Space: O(1)
    
    Example: Remove 2nd from end in [1→2→3→4→5]
    Result: [1→2→3→5]
    """
    # Use dummy to handle edge case of removing head
    dummy = ListNode(0)
    dummy.next = head
    
    first = second = dummy
    
    # Move first n+1 steps ahead
    for _ in range(n + 1):
        if not first:
            return head  # n is larger than length
        first = first.next
    
    # Move both until first reaches end
    while first:
        first = first.next
        second = second.next
    
    # Remove the nth node
    second.next = second.next.next
    
    return dummy.next

# Visual walkthrough for n=2, list=[1→2→3→4→5]:
"""
Step 1: Create dummy and move first 3 steps ahead
D → [1] → [2] → [3] → [4] → [5]
↑                      ↑
second                first

Step 2: Move both until first reaches end
D → [1] → [2] → [3] → [4] → [5] → None
              ↑                    ↑
           second               first

Step 3: Remove node after second
D → [1] → [2] → [3] → [5]
              ↑
         second.next = second.next.next

Result: [1→2→3→5]
"""

# Test
ll = create_from_list([1, 2, 3, 4, 5])
result = remove_nth_from_end(ll, 2)
print_list(result)  # 1 → 2 → 3 → 5
```

#### Problem 6: Find Kth Node from End

```python
def find_kth_from_end(head, k):
    """
    Find the kth node from the end
    
    Time: O(n)
    Space: O(1)
    """
    first = second = head
    
    # Move first k steps ahead
    for _ in range(k):
        if not first:
            return None  # k > length
        first = first.next
    
    # Move both together
    while first:
        first = first.next
        second = second.next
    
    return second

# Example: k=2 in [1→2→3→4→5]
"""
After moving first 2 steps: first at [3], second at [1]
After moving both together: first at None, second at [4]
Result: [4] (2nd from end) ✓
"""

# Test
ll = create_from_list([1, 2, 3, 4, 5])
node = find_kth_from_end(ll, 2)
print(node.val)  # 4
```

---

## 4.2 Dummy Node Technique ⭐⭐⭐

### Introduction

A **Dummy Node** (or sentinel node) is a placeholder node that simplifies edge cases, especially when the head might change.

**Key Benefit**: Eliminates special handling for head modifications!

### When to Use Dummy Node

✅ **Use when:**
- Head might be deleted
- Need to build a new list
- Merging lists
- Partitioning lists
- Head could change during operation

### Template

```python
def dummy_node_template(head):
    """
    Standard dummy node pattern
    """
    # Create dummy node pointing to head
    dummy = ListNode(0)
    dummy.next = head
    
    # Work with dummy.next (the actual list)
    current = dummy
    
    # ... perform operations ...
    
    # Return dummy.next (actual head)
    return dummy.next
```

### Problem 7: Remove Elements by Value

```python
def remove_elements(head, val):
    """
    Remove all nodes with value = val
    
    Without dummy: Need special handling for head
    With dummy: Uniform logic for all nodes!
    
    Time: O(n)
    Space: O(1)
    """
    dummy = ListNode(0)
    dummy.next = head
    
    current = dummy
    
    while current.next:
        if current.next.val == val:
            # Remove next node
            current.next = current.next.next
        else:
            current = current.next
    
    return dummy.next

# Visual example: Remove 2 from [2→1→2→3→2]
"""
Step 1: Create dummy
D → [2] → [1] → [2] → [3] → [2]
↑
current

Step 2: Remove first 2
D → [1] → [2] → [3] → [2]
    ↑
  current moved to next valid node

Step 3: Skip [1], remove [2]
D → [1] → [3] → [2]

Step 4: Skip [3], remove [2]
D → [1] → [3]

Result: [1→3]
"""

# Without dummy (more complex):
def remove_elements_no_dummy(head, val):
    """Without dummy - need special head handling"""
    # Remove from head
    while head and head.val == val:
        head = head.next
    
    if not head:
        return None
    
    # Remove from rest
    current = head
    while current.next:
        if current.next.val == val:
            current.next = current.next.next
        else:
            current = current.next
    
    return head

# Test
ll = create_from_list([2, 1, 2, 3, 2])
result = remove_elements(ll, 2)
print_list(result)  # 1 → 3
```

### Problem 8: Merge Two Sorted Lists

```python
def merge_two_lists(l1, l2):
    """
    Merge two sorted linked lists
    
    Dummy node makes this elegant!
    
    Time: O(n + m)
    Space: O(1) - reusing existing nodes
    """
    # Dummy node to build result
    dummy = ListNode(0)
    tail = dummy  # Tail pointer for building
    
    while l1 and l2:
        if l1.val <= l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next
    
    # Attach remaining nodes
    tail.next = l1 if l1 else l2
    
    return dummy.next

# Visual walkthrough:
"""
l1: [1→3→5]
l2: [2→4→6]

Step 1: dummy → [1] (l1.val < l2.val)
Step 2: dummy → [1] → [2] (l2.val < l1.val)
Step 3: dummy → [1] → [2] → [3]
Step 4: dummy → [1] → [2] → [3] → [4]
Step 5: dummy → [1] → [2] → [3] → [4] → [5]
Step 6: dummy → [1] → [2] → [3] → [4] → [5] → [6]

Result: [1→2→3→4→5→6]
"""

# Test
l1 = create_from_list([1, 3, 5])
l2 = create_from_list([2, 4, 6])
result = merge_two_lists(l1, l2)
print_list(result)  # 1 → 2 → 3 → 4 → 5 → 6
```

### Problem 9: Partition List Around Value

```python
def partition(head, x):
    """
    Partition list around value x
    All nodes < x come before nodes >= x
    
    Approach: Two dummy nodes for two sublists!
    
    Time: O(n)
    Space: O(1)
    """
    # Two dummy nodes
    less_dummy = ListNode(0)
    greater_dummy = ListNode(0)
    
    less = less_dummy
    greater = greater_dummy
    
    current = head
    
    while current:
        if current.val < x:
            less.next = current
            less = less.next
        else:
            greater.next = current
            greater = greater.next
        current = current.next
    
    # Prevent cycle
    greater.next = None
    
    # Connect two lists
    less.next = greater_dummy.next
    
    return less_dummy.next

# Visual example: Partition [1→4→3→2→5→2] around x=3
"""
less_dummy →
greater_dummy →

Process [1]: val < 3
less_dummy → [1]

Process [4]: val >= 3
greater_dummy → [4]

Process [3]: val >= 3
greater_dummy → [4] → [3]

Process [2]: val < 3
less_dummy → [1] → [2]

Process [5]: val >= 3
greater_dummy → [4] → [3] → [5]

Process [2]: val < 3
less_dummy → [1] → [2] → [2]

Connect: [1] → [2] → [2] → [4] → [3] → [5]
Result: All < 3 before all >= 3
"""

# Test
ll = create_from_list([1, 4, 3, 2, 5, 2])
result = partition(ll, 3)
print_list(result)  # 1 → 2 → 2 → 4 → 3 → 5
```

---

## 4.3 Recursion Patterns ⭐⭐

### Understanding Recursion in LinkedLists

**Key Insight**: LinkedList is naturally recursive!
- A list is either empty OR a node followed by a list

```python
# Recursive structure
class ListNode:
    val: int
    next: ListNode  # Another list!
```

### Recursion Template

```python
def recursive_template(node):
    """
    Basic recursion pattern
    """
    # Base case
    if not node or not node.next:
        return node
    
    # Recursive case: solve for rest of list
    result = recursive_template(node.next)
    
    # Post-processing: use result to solve current
    # ... process node with result ...
    
    return node  # or result, depending on problem
```

### Problem 10: Reverse LinkedList (Recursive)

```python
def reverse_recursive(head):
    """
    Reverse LinkedList using recursion
    
    Time: O(n)
    Space: O(n) - call stack
    
    Intuition:
    - Reverse everything after head
    - Make head the tail
    """
    # Base case: empty or single node
    if not head or not head.next:
        return head
    
    # Reverse rest of the list
    new_head = reverse_recursive(head.next)
    
    # Make current node the tail
    head.next.next = head
    head.next = None
    
    return new_head

# Visual execution for [1→2→3→4]:
"""
Call Stack:
reverse(1): 
  └→ reverse(2):
       └→ reverse(3):
            └→ reverse(4):
                 └→ return [4]
            [3].next.next = [3]
            [3].next = None
            return [4]
       [2].next.next = [2]
       [2].next = None
       return [4]
  [1].next.next = [1]
  [1].next = None
  return [4]

Result: [4→3→2→1]
"""

# Detailed trace:
"""
Original: [1] → [2] → [3] → [4] → None

At recursion depth 4: reverse([4])
  Return [4] (base case)

At depth 3: reverse([3])
  new_head = [4]
  [3].next.next = [3] → creates [4] → [3]
  [3].next = None
  Return [4] (head of reversed)

At depth 2: reverse([2])
  new_head = [4] (returned from previous)
  Current state: [4] → [3] → None
  [2].next.next = [2] → creates [4] → [3] → [2]
  [2].next = None
  Return [4]

At depth 1: reverse([1])
  new_head = [4]
  Current state: [4] → [3] → [2] → None
  [1].next.next = [1] → creates [4] → [3] → [2] → [1]
  [1].next = None
  Return [4]

Final: [4] → [3] → [2] → [1] → None
"""

# Test
ll = create_from_list([1, 2, 3, 4])
result = reverse_recursive(ll)
print_list(result)  # 4 → 3 → 2 → 1
```

### Problem 11: Swap Nodes in Pairs

```python
def swap_pairs(head):
    """
    Swap every two adjacent nodes
    
    Example: [1→2→3→4] → [2→1→4→3]
    
    Time: O(n)
    Space: O(n) - recursion stack
    """
    # Base case: less than 2 nodes
    if not head or not head.next:
        return head
    
    # Nodes to swap
    first = head
    second = head.next
    
    # Recursively swap rest
    first.next = swap_pairs(second.next)
    
    # Perform swap
    second.next = first
    
    return second  # New head of this pair

# Visual execution for [1→2→3→4]:
"""
swap_pairs([1]):
  first = [1], second = [2]
  
  first.next = swap_pairs([3]):
    first = [3], second = [4]
    first.next = swap_pairs(None) = None
    second.next = first
    return [4→3→None]
  
  Now: [1] → [4→3→None]
  second.next = first: [2] → [1] → [4→3]
  return [2]

Result: [2→1→4→3]
"""

# Test
ll = create_from_list([1, 2, 3, 4])
result = swap_pairs(ll)
print_list(result)  # 2 → 1 → 4 → 3
```

---

## 4.4 Reversal Patterns ⭐⭐⭐

### Iterative Reversal (Must Master!)

```python
def reverse_iterative(head):
    """
    Reverse LinkedList iteratively
    
    This is THE most important pattern to memorize!
    
    Time: O(n)
    Space: O(1)
    
    Maintain three pointers:
    - prev: points to previous node
    - curr: current node being processed
    - next: temporary storage for next node
    """
    prev = None
    curr = head
    
    while curr:
        # Save next node
        next_temp = curr.next
        
        # Reverse the link
        curr.next = prev
        
        # Move pointers forward
        prev = curr
        curr = next_temp
    
    return prev  # New head

# Detailed step-by-step for [1→2→3→4]:
"""
Initial: prev=None, curr=[1]
[1] → [2] → [3] → [4] → None

Step 1: next_temp=[2], curr.next=None, prev=[1], curr=[2]
None ← [1]  [2] → [3] → [4] → None

Step 2: next_temp=[3], curr.next=[1], prev=[2], curr=[3]
None ← [1] ← [2]  [3] → [4] → None

Step 3: next_temp=[4], curr.next=[2], prev=[3], curr=[4]
None ← [1] ← [2] ← [3]  [4] → None

Step 4: next_temp=None, curr.next=[3], prev=[4], curr=None
None ← [1] ← [2] ← [3] ← [4]

Return prev=[4]
Result: [4→3→2→1]
"""
```

### Problem 12: Reverse Between Positions

```python
def reverse_between(head, left, right):
    """
    Reverse nodes from position left to right
    
    Example: [1→2→3→4→5], left=2, right=4
    Result:  [1→4→3→2→5]
    
    Time: O(n)
    Space: O(1)
    """
    if not head or left == right:
        return head
    
    dummy = ListNode(0)
    dummy.next = head
    
    # Step 1: Move to node before left
    prev = dummy
    for _ in range(left - 1):
        prev = prev.next
    
    # Step 2: Reverse from left to right
    reverse_start = prev.next
    curr = reverse_start.next
    
    for _ in range(right - left):
        # Move curr to after prev
        reverse_start.next = curr.next
        curr.next = prev.next
        prev.next = curr
        curr = reverse_start.next
    
    return dummy.next

# Visual for [1→2→3→4→5], left=2, right=4:
"""
Initial: D → [1] → [2] → [3] → [4] → [5]
                   ↑
                 left=2

Step 1: Move to position before left
D → [1] → [2] → [3] → [4] → [5]
    ↑
  prev

Step 2: Reverse between left and right
Iteration 1: Move [3] after prev
D → [1] → [3] → [2] → [4] → [5]

Iteration 2: Move [4] after prev
D → [1] → [4] → [3] → [2] → [5]

Result: [1→4→3→2→5]
"""
```

### Problem 13: Reverse in K-Groups

```python
def reverse_k_group(head, k):
    """
    Reverse nodes in groups of k
    
    Example: [1→2→3→4→5→6], k=3
    Result:  [3→2→1→6→5→4]
    
    Time: O(n)
    Space: O(1)
    """
    # Check if we have k nodes remaining
    count = 0
    curr = head
    while curr and count < k:
        curr = curr.next
        count += 1
    
    if count < k:
        return head  # Not enough nodes to reverse
    
    # Reverse first k nodes
    prev = None
    curr = head
    for _ in range(k):
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    
    # Recursively reverse remaining
    if curr:
        head.next = reverse_k_group(curr, k)
    
    return prev

# Visual for [1→2→3→4→5→6], k=3:
"""
First group:
[1→2→3] → reverse → [3→2→1]

Second group:
[4→5→6] → reverse → [6→5→4]

Connect:
[3→2→1] → [6→5→4]

Result: [3→2→1→6→5→4]
"""
```

---

## 4.5 Runner Technique (K-ahead Pattern) ⭐⭐

Already covered extensively in Two Pointer section. Key problems:
- Remove Nth from end ✓
- Find Kth from end ✓
- Reorder list (see advanced patterns)

---

## 4.6 In-place Modification ⭐⭐

### Key Principle
**Reuse existing nodes** - don't create new ones!

### Problem 14: Odd-Even LinkedList

```python
def odd_even_list(head):
    """
    Group odd-indexed nodes together, then even-indexed
    
    Example: [1→2→3→4→5] → [1→3→5→2→4]
    
    Time: O(n)
    Space: O(1) - in-place
    """
    if not head or not head.next:
        return head
    
    odd = head
    even = head.next
    even_head = even
    
    while even and even.next:
        odd.next = even.next
        odd = odd.next
        even.next = odd.next
        even = even.next
    
    odd.next = even_head
    return head

# Visual for [1→2→3→4→5]:
"""
Initial:
odd=[1], even=[2], even_head=[2]

Iteration 1:
odd.next = [3]: [1] → [3]
odd = [3]
even.next = [4]: [2] → [4]
even = [4]

Iteration 2:
odd.next = [5]: [1] → [3] → [5]
odd = [5]
even.next = None: [2] → [4] → None
even = None

Connect: [1] → [3] → [5] → [2] → [4]
"""
```

---

## Summary: Pattern Recognition Guide

| If You Need To... | Use Pattern... | Key Technique |
|-------------------|----------------|---------------|
| Find middle | Two Pointer | Slow-fast |
| Detect cycle | Two Pointer | Slow-fast |
| Remove Nth from end | Two Pointer | Gap of N |
| Modify head | Dummy Node | dummy.next = head |
| Merge lists | Dummy Node | Build with tail pointer |
| Reverse | Iterative | prev-curr-next |
| Swap pairs | Recursion | Recursive swap |
| Group/partition | Dummy Node | Multiple dummies |

---

## Practice Problems by Pattern

### Two Pointer
1. ✅ Middle of LinkedList
2. ✅ Detect Cycle
3. ✅ Palindrome LinkedList
4. Happy Number (cycle in numbers)
5. Delete middle node

### Dummy Node
6. ✅ Remove elements by value
7. ✅ Merge two sorted lists
8. ✅ Partition list
9. Add two numbers as lists
10. Insertion sort list

### Reversal
11. ✅ Reverse LinkedList
12. ✅ Reverse between positions
13. ✅ Reverse K-groups
14. Reverse alternate K nodes
15. Reverse nodes in pairs

These patterns form the foundation for solving 80% of LinkedList problems!