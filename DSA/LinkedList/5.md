# Chapter 5: Advanced Patterns - Deep Dive

## 5.1 List Merging & Splitting ⭐⭐⭐

### Merge Two Sorted Lists (Review)

We covered this in Chapter 4 with dummy node. Let's build on it!

### Problem 1: Merge K Sorted Lists ⭐⭐⭐

This is a **VERY COMMON** interview question at top companies!

#### Approach 1: Using MinHeap (Priority Queue)

```python
import heapq

def merge_k_lists_heap(lists):
    """
    Merge k sorted linked lists using a min heap
    
    Time: O(N log k) where N = total nodes, k = number of lists
    Space: O(k) for the heap
    
    Strategy:
    1. Put first node of each list in min heap
    2. Extract min, add to result
    3. Add next node from same list to heap
    4. Repeat until heap is empty
    """
    # Create min heap with (value, list_index, node)
    heap = []
    
    # Add first node from each list
    for i, lst in enumerate(lists):
        if lst:
            heapq.heappush(heap, (lst.val, i, lst))
    
    dummy = ListNode(0)
    current = dummy
    
    while heap:
        val, i, node = heapq.heappop(heap)
        current.next = node
        current = current.next
        
        # Add next node from same list
        if node.next:
            heapq.heappush(heap, (node.next.val, i, node.next))
    
    return dummy.next

# Visual example with 3 lists:
"""
lists = [
    [1→4→5],
    [1→3→4],
    [2→6]
]

Heap operations:
Initial heap: [(1,0,node1), (1,1,node1), (2,2,node2)]

Step 1: Pop (1,0,node1), add to result
        Push (4,0,node4)
        Heap: [(1,1,node1), (2,2,node2), (4,0,node4)]
        Result: [1]

Step 2: Pop (1,1,node1), add to result
        Push (3,1,node3)
        Heap: [(2,2,node2), (3,1,node3), (4,0,node4)]
        Result: [1→1]

Continue until heap empty...
Final: [1→1→2→3→4→4→5→6]
"""

# Test
l1 = create_from_list([1, 4, 5])
l2 = create_from_list([1, 3, 4])
l3 = create_from_list([2, 6])
result = merge_k_lists_heap([l1, l2, l3])
print_list(result)  # 1 → 1 → 2 → 3 → 4 → 4 → 5 → 6
```

#### Approach 2: Divide and Conquer

```python
def merge_k_lists_divide_conquer(lists):
    """
    Merge k sorted lists using divide and conquer
    
    Time: O(N log k)
    Space: O(log k) for recursion stack
    
    Strategy: Merge pairs of lists recursively
    """
    if not lists:
        return None
    
    if len(lists) == 1:
        return lists[0]
    
    def merge_two(l1, l2):
        """Helper: merge two sorted lists"""
        dummy = ListNode(0)
        tail = dummy
        
        while l1 and l2:
            if l1.val <= l2.val:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next
        
        tail.next = l1 or l2
        return dummy.next
    
    # Divide and conquer
    def merge_range(lists, left, right):
        if left == right:
            return lists[left]
        
        if left < right:
            mid = (left + right) // 2
            l1 = merge_range(lists, left, mid)
            l2 = merge_range(lists, mid + 1, right)
            return merge_two(l1, l2)
    
    return merge_range(lists, 0, len(lists) - 1)

# Visual tree for 4 lists:
"""
                [All 4 lists merged]
                /                \
        [Lists 0,1 merged]    [Lists 2,3 merged]
         /          \          /          \
    [List 0]   [List 1]   [List 2]   [List 3]

Height of tree = log k
At each level, process N total nodes
Total: O(N log k)
"""
```

#### Approach 3: Sequential Merging (Less Optimal)

```python
def merge_k_lists_sequential(lists):
    """
    Merge lists one by one
    
    Time: O(kN) - worse than other approaches!
    Space: O(1)
    
    Not recommended but simple to understand
    """
    if not lists:
        return None
    
    result = lists[0]
    
    for i in range(1, len(lists)):
        result = merge_two(result, lists[i])
    
    return result

# Why is this O(kN)?
"""
Merge 1st and 2nd: N1 + N2
Merge result and 3rd: (N1+N2) + N3
Merge result and 4th: (N1+N2+N3) + N4
...
Total comparisons ≈ k*N
"""
```

### Problem 2: Split LinkedList into K Parts

```python
def split_list_to_parts(head, k):
    """
    Split linked list into k consecutive parts
    
    Example: [1→2→3→4→5→6→7], k=3
    Result: [[1→2→3], [4→5], [6→7]]
    
    Time: O(n)
    Space: O(1) excluding output
    """
    # Step 1: Count total nodes
    length = 0
    current = head
    while current:
        length += 1
        current = current.next
    
    # Step 2: Calculate part sizes
    part_size = length // k
    extra = length % k  # First 'extra' parts get one extra node
    
    # Step 3: Split into parts
    result = []
    current = head
    
    for i in range(k):
        part_head = current
        current_size = part_size + (1 if i < extra else 0)
        
        # Move to end of current part
        for j in range(current_size - 1):
            if current:
                current = current.next
        
        # Disconnect this part
        if current:
            next_part = current.next
            current.next = None
            current = next_part
        
        result.append(part_head)
    
    return result

# Visual for [1→2→3→4→5→6→7], k=3:
"""
length = 7, k = 3
part_size = 7 // 3 = 2
extra = 7 % 3 = 1

Part 1: size = 2 + 1 = 3 → [1→2→3]
Part 2: size = 2 + 0 = 2 → [4→5]
Part 3: size = 2 + 0 = 2 → [6→7]
"""

# Test
ll = create_from_list([1, 2, 3, 4, 5, 6, 7])
parts = split_list_to_parts(ll, 3)
for i, part in enumerate(parts):
    print(f"Part {i+1}:", end=" ")
    print_list(part)
```

---

## 5.2 Cycle Detection & Handling ⭐⭐⭐

### Complete Cycle Detection Suite

```python
class CycleDetector:
    """Complete toolkit for cycle detection"""
    
    @staticmethod
    def has_cycle(head):
        """Detect if cycle exists"""
        if not head or not head.next:
            return False
        
        slow = fast = head
        
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        
        return False
    
    @staticmethod
    def detect_cycle_start(head):
        """Find where cycle begins"""
        if not head or not head.next:
            return None
        
        # Phase 1: Detect cycle
        slow = fast = head
        has_cycle = False
        
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                has_cycle = True
                break
        
        if not has_cycle:
            return None
        
        # Phase 2: Find start
        slow = head
        while slow != fast:
            slow = slow.next
            fast = fast.next
        
        return slow
    
    @staticmethod
    def cycle_length(head):
        """Find length of cycle"""
        if not head or not head.next:
            return 0
        
        slow = fast = head
        
        # Detect cycle
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break
        else:
            return 0  # No cycle
        
        # Count cycle length
        count = 1
        current = slow.next
        while current != slow:
            count += 1
            current = current.next
        
        return count
    
    @staticmethod
    def remove_cycle(head):
        """Remove cycle from list"""
        cycle_start = CycleDetector.detect_cycle_start(head)
        
        if not cycle_start:
            return  # No cycle
        
        # Find node before cycle start
        current = cycle_start
        while current.next != cycle_start:
            current = current.next
        
        # Break the cycle
        current.next = None

# Comprehensive test
def create_cycle_at_position(values, pos):
    """Create list with cycle at position pos"""
    if not values:
        return None
    
    nodes = [ListNode(val) for val in values]
    
    for i in range(len(nodes) - 1):
        nodes[i].next = nodes[i + 1]
    
    if pos >= 0:
        nodes[-1].next = nodes[pos]
    
    return nodes[0]

# Test all cycle operations
head = create_cycle_at_position([1, 2, 3, 4, 5], 2)
print("Has cycle:", CycleDetector.has_cycle(head))
print("Cycle length:", CycleDetector.cycle_length(head))

start = CycleDetector.detect_cycle_start(head)
print("Cycle starts at:", start.val if start else None)

CycleDetector.remove_cycle(head)
print("After removing cycle:", CycleDetector.has_cycle(head))
```

### Problem 3: Happy Number (Cycle in Sequence)

```python
def is_happy(n):
    """
    A happy number reaches 1 through sum of squares
    Uses cycle detection!
    
    Example: 19 → 1²+9² = 82 → 8²+2² = 68 → ... → 1 ✓
    
    Time: O(log n)
    Space: O(1)
    """
    def get_next(num):
        """Get sum of squares of digits"""
        total = 0
        while num > 0:
            digit = num % 10
            total += digit * digit
            num //= 10
        return total
    
    # Use slow-fast pointers to detect cycle
    slow = n
    fast = n
    
    while True:
        slow = get_next(slow)
        fast = get_next(get_next(fast))
        
        if fast == 1:
            return True
        
        if slow == fast:
            return False  # Cycle detected, not happy

# Visual for n=19:
"""
slow: 19 → 82 → 68 → 100 → 1
fast: 19 → 68 → 1

fast reaches 1 → Happy number!
"""

# Test
print(is_happy(19))  # True
print(is_happy(2))   # False
```

---

## 5.3 Intersection Problems ⭐⭐

### Problem 4: Find Intersection Point

```python
def get_intersection_node(headA, headB):
    """
    Find node where two lists intersect
    
    Time: O(m + n)
    Space: O(1)
    
    Beautiful solution: Length difference elimination!
    """
    if not headA or not headB:
        return None
    
    pA, pB = headA, headB
    
    # Traverse both lists
    # When one ends, continue from other list's head
    # They'll meet at intersection (or both reach None)
    while pA != pB:
        pA = pA.next if pA else headB
        pB = pB.next if pB else headA
    
    return pA  # Intersection node or None

# Why this works:
"""
List A: a1 → a2 → c1 → c2 → c3
List B: b1 → b2 → b3 → c1 → c2 → c3
                        ↑
                   intersection

Length of A = 2 + 3 = 5
Length of B = 3 + 3 = 6

Path 1: A + B = a1→a2→c1→c2→c3→b1→b2→b3→c1 (meets at c1)
Path 2: B + A = b1→b2→b3→c1→c2→c3→a1→a2→c1 (meets at c1)

Both paths have same total length and meet at intersection!
"""

# Alternative: Using length difference
def get_intersection_node_v2(headA, headB):
    """Using explicit length calculation"""
    def get_length(head):
        length = 0
        while head:
            length += 1
            head = head.next
        return length
    
    lenA = get_length(headA)
    lenB = get_length(headB)
    
    # Align starting points
    while lenA > lenB:
        headA = headA.next
        lenA -= 1
    
    while lenB > lenA:
        headB = headB.next
        lenB -= 1
    
    # Find intersection
    while headA and headB:
        if headA == headB:
            return headA
        headA = headA.next
        headB = headB.next
    
    return None

# Create intersecting lists for testing
def create_intersecting_lists():
    # Common part
    c1 = ListNode(8)
    c2 = ListNode(4)
    c3 = ListNode(5)
    c1.next = c2
    c2.next = c3
    
    # List A: 4 → 1 → 8 → 4 → 5
    headA = ListNode(4)
    headA.next = ListNode(1)
    headA.next.next = c1
    
    # List B: 5 → 6 → 1 → 8 → 4 → 5
    headB = ListNode(5)
    headB.next = ListNode(6)
    headB.next.next = ListNode(1)
    headB.next.next.next = c1
    
    return headA, headB

# Test
headA, headB = create_intersecting_lists()
intersection = get_intersection_node(headA, headB)
print("Intersection at:", intersection.val if intersection else None)
```

---

## 5.4 Sorting LinkedLists ⭐⭐

### Problem 5: Merge Sort on LinkedList

```python
def merge_sort_list(head):
    """
    Sort LinkedList using merge sort
    
    Time: O(n log n)
    Space: O(log n) for recursion stack
    
    Best sorting algorithm for LinkedLists!
    """
    # Base case
    if not head or not head.next:
        return head
    
    # Step 1: Find middle and split
    def find_middle(head):
        slow = fast = head
        prev = None
        
        while fast and fast.next:
            prev = slow
            slow = slow.next
            fast = fast.next.next
        
        if prev:
            prev.next = None  # Split the list
        
        return slow
    
    # Step 2: Merge two sorted lists
    def merge(l1, l2):
        dummy = ListNode(0)
        tail = dummy
        
        while l1 and l2:
            if l1.val <= l2.val:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next
        
        tail.next = l1 or l2
        return dummy.next
    
    # Split
    mid = find_middle(head)
    
    # Recursively sort both halves
    left = merge_sort_list(head)
    right = merge_sort_list(mid)
    
    # Merge sorted halves
    return merge(left, right)

# Visual for [4→2→1→3]:
"""
                [4→2→1→3]
                /        \
            [4→2]        [1→3]
            /    \       /    \
          [4]    [2]   [1]    [3]
            \    /       \    /
            [2→4]        [1→3]
                \        /
                [1→2→3→4]

Each split: O(n) to find middle
Merge: O(n)
Levels: O(log n)
Total: O(n log n)
"""

# Test
ll = create_from_list([4, 2, 1, 3, 5])
sorted_ll = merge_sort_list(ll)
print_list(sorted_ll)  # 1 → 2 → 3 → 4 → 5
```

### Problem 6: Insertion Sort on LinkedList

```python
def insertion_sort_list(head):
    """
    Sort using insertion sort
    
    Time: O(n²) - but good for nearly sorted lists
    Space: O(1)
    """
    dummy = ListNode(0)
    current = head
    
    while current:
        # Save next before insertion
        next_temp = current.next
        
        # Find position to insert
        prev = dummy
        while prev.next and prev.next.val < current.val:
            prev = prev.next
        
        # Insert current
        current.next = prev.next
        prev.next = current
        
        current = next_temp
    
    return dummy.next

# Visual for [4→2→1→3]:
"""
Start: dummy → None

Insert 4: dummy → [4]

Insert 2: dummy → [2] → [4]

Insert 1: dummy → [1] → [2] → [4]

Insert 3: dummy → [1] → [2] → [3] → [4]
"""

# Test
ll = create_from_list([4, 2, 1, 3])
sorted_ll = insertion_sort_list(ll)
print_list(sorted_ll)  # 1 → 2 → 3 → 4
```

---

## 5.5 Flattening Problems ⭐⭐

### Problem 7: Flatten Multi-level Doubly LinkedList

```python
class MultiLevelNode:
    def __init__(self, val=0, prev=None, next=None, child=None):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child  # Points to sublevel

def flatten(head):
    """
    Flatten a multilevel doubly linked list
    
    Example:
    1 → 2 → 3 → 4 → 5 → 6
            ↓
            7 → 8 → 9 → 10
                ↓
                11 → 12
    
    Result: 1→2→3→7→8→11→12→9→10→4→5→6
    
    Time: O(n)
    Space: O(1) iterative, O(d) recursive (d = depth)
    """
    if not head:
        return None
    
    # Use stack for DFS traversal
    stack = [head]
    prev = None
    
    while stack:
        curr = stack.pop()
        
        # Connect with previous
        if prev:
            prev.next = curr
            curr.prev = prev
        
        # Push next before child (so child is processed first)
        if curr.next:
            stack.append(curr.next)
        
        if curr.child:
            stack.append(curr.child)
            curr.child = None  # Remove child pointer
        
        prev = curr
    
    return head

# Recursive approach (cleaner!)
def flatten_recursive(head):
    """Recursive DFS approach"""
    def flatten_helper(node):
        """Returns tail of flattened list"""
        if not node:
            return None
        
        # No child, just recurse on next
        if not node.child:
            if not node.next:
                return node
            return flatten_helper(node.next)
        
        # Has child
        child = node.child
        next_node = node.next
        
        # Connect node to child
        node.next = child
        child.prev = node
        node.child = None
        
        # Flatten child level
        child_tail = flatten_helper(child)
        
        # Connect child tail to next
        if next_node:
            child_tail.next = next_node
            next_node.prev = child_tail
            return flatten_helper(next_node)
        
        return child_tail
    
    flatten_helper(head)
    return head
```

---

## 5.6 Clone/Copy Complex Lists ⭐⭐

### Problem 8: Copy List with Random Pointer

```python
class NodeWithRandom:
    def __init__(self, val=0, next=None, random=None):
        self.val = val
        self.next = next
        self.random = random  # Can point to any node or None

# Approach 1: HashMap (Most intuitive)
def copy_random_list_hashmap(head):
    """
    Deep copy list with random pointers using HashMap
    
    Time: O(n)
    Space: O(n) for hashmap
    """
    if not head:
        return None
    
    # Step 1: Create all nodes and store mapping
    old_to_new = {}
    current = head
    
    while current:
        old_to_new[current] = NodeWithRandom(current.val)
        current = current.next
    
    # Step 2: Connect next and random pointers
    current = head
    while current:
        if current.next:
            old_to_new[current].next = old_to_new[current.next]
        if current.random:
            old_to_new[current].random = old_to_new[current.random]
        current = current.next
    
    return old_to_new[head]

# Approach 2: Interweaving Nodes (O(1) space!)
def copy_random_list_interweave(head):
    """
    Clever O(1) space solution using interweaving
    
    Time: O(n)
    Space: O(1) - no extra data structures!
    
    Idea: Insert copy after each original node
    """
    if not head:
        return None
    
    # Step 1: Create copy nodes and interweave
    current = head
    while current:
        copy = NodeWithRandom(current.val)
        copy.next = current.next
        current.next = copy
        current = copy.next
    
    # Now: A → A' → B → B' → C → C'
    
    # Step 2: Set random pointers for copies
    current = head
    while current:
        if current.random:
            current.next.random = current.random.next
        current = current.next.next
    
    # Step 3: Separate lists
    dummy = NodeWithRandom(0)
    copy_tail = dummy
    current = head
    
    while current:
        copy = current.next
        copy_tail.next = copy
        copy_tail = copy
        
        current.next = copy.next
        current = current.next
    
    return dummy.next

# Visual for interweaving approach:
"""
Original: A → B → C

Step 1: Interweave
A → A' → B → B' → C → C'

Step 2: Set random pointers
If A.random = C, then A'.random = C'

Step 3: Separate
A → B → C (restore original)
A' → B' → C' (return copy)
"""
```

---

## 5.7 Reordering Patterns ⭐⭐

### Problem 9: Reorder List

```python
def reorder_list(head):
    """
    Reorder list: L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → ...
    
    Example: [1→2→3→4→5] → [1→5→2→4→3]
    
    Strategy:
    1. Find middle
    2. Reverse second half
    3. Merge alternately
    
    Time: O(n)
    Space: O(1)
    """
    if not head or not head.next:
        return
    
    # Step 1: Find middle
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    # Step 2: Reverse second half
    second = slow.next
    slow.next = None  # Split list
    
    prev = None
    while second:
        next_temp = second.next
        second.next = prev
        prev = second
        second = next_temp
    
    second = prev  # Head of reversed second half
    
    # Step 3: Merge alternately
    first = head
    while second:
        # Save next pointers
        first_next = first.next
        second_next = second.next
        
        # Interweave
        first.next = second
        second.next = first_next
        
        # Move forward
        first = first_next
        second = second_next

# Visual for [1→2→3→4→5]:
"""
Step 1: Find middle
[1→2→3] | [4→5]
        mid

Step 2: Reverse second half
[1→2→3] | [5→4]

Step 3: Merge alternately
1 → 5 → 2 → 4 → 3
"""

# Test
ll = create_from_list([1, 2, 3, 4, 5])
reorder_list(ll)
print_list(ll)  # 1 → 5 → 2 → 4 → 3
```

### Problem 10: Swap Alternate Nodes

```python
def swap_alternate(head):
    """
    Swap values of alternate nodes
    
    Example: [1→2→3→4→5] → [2→1→4→3→5]
    
    Time: O(n)
    Space: O(1)
    """
    current = head
    
    while current and current.next:
        # Swap values
        current.val, current.next.val = current.next.val, current.val
        
        # Move to next pair
        current = current.next.next

# Test
ll = create_from_list([1, 2, 3, 4, 5])
swap_alternate(ll)
print_list(ll)  # 2 → 1 → 4 → 3 → 5
```

---

## Summary: Advanced Pattern Selection

| Problem Type | Best Approach | Time | Space |
|--------------|---------------|------|-------|
| Merge K lists | MinHeap or Divide-Conquer | O(N log k) | O(k) or O(log k) |
| Cycle detection | Floyd's algorithm | O(n) | O(1) |
| Intersection | Length elimination | O(m+n) | O(1) |
| Sorting | Merge sort | O(n log n) | O(log n) |
| Flatten | DFS (recursive/iterative) | O(n) | O(1) or O(d) |
| Copy with random | Interweaving or HashMap | O(n) | O(1) or O(n) |
| Reorder | Find mid + Reverse + Merge | O(n) | O(1) |

---

## Practice Problems

### Easy-Medium
1. ✅ Merge K sorted lists
2. ✅ Find intersection of two lists
3. ✅ Sort LinkedList
4. Split into parts
5. Remove duplicates from sorted list

### Medium-Hard
6. ✅ Flatten multilevel list
7. ✅ Copy list with random pointer
8. ✅ Reorder list
9. Add two numbers as lists
10. Convert sorted list to BST

### Hard
11. Merge K lists (all 3 approaches)
12. LRU Cache implementation
13. Design skip list
14. Reverse alternate K nodes
15. Find all cycles in graph using LinkedList

Master these patterns and you'll handle any LinkedList interview!