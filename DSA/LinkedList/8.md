# Chapter 8: Practice Problem Categories - Deep Dive

## 8.1 Easy Problems (Foundation Building) ğŸ“—

### Problem 1: Reverse LinkedList â­â­â­

**Problem Statement:** Reverse a singly linked list.

```
Input:  1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ None
Output: 5 â†’ 4 â†’ 3 â†’ 2 â†’ 1 â†’ None
```

**Approach 1: Iterative (Most Common)**

```python
def reverse_list(head):
    """
    Time: O(n) - Visit each node once
    Space: O(1) - Only 3 pointers used
    
    Strategy: Reverse pointers while traversing
    """
    prev = None
    current = head
    
    while current:
        # Save next node before breaking link
        next_temp = current.next
        
        # Reverse the link
        current.next = prev
        
        # Move pointers forward
        prev = current
        current = next_temp
    
    return prev  # New head

# Visual walkthrough:
"""
Initial: None â† 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
         prev  curr

Step 1: None â† 1   2 â†’ 3 â†’ 4 â†’ 5
              prev curr

Step 2: None â† 1 â† 2   3 â†’ 4 â†’ 5
                   prev curr

Step 3: None â† 1 â† 2 â† 3   4 â†’ 5
                        prev curr

... continues until curr = None
Final: None â† 1 â† 2 â† 3 â† 4 â† 5
                               prev (new head)
"""
```

**Approach 2: Recursive**

```python
def reverse_list_recursive(head):
    """
    Time: O(n)
    Space: O(n) - Call stack
    
    Strategy: Recurse to end, reverse on way back
    """
    # Base case: empty or single node
    if not head or not head.next:
        return head
    
    # Recurse to end
    new_head = reverse_list_recursive(head.next)
    
    # Reverse link
    head.next.next = head
    head.next = None
    
    return new_head

# Visual understanding:
"""
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5

Recursion reaches: 5 (base case)
Returns: 5 as new_head

On way back:
4.next.next = 4  =>  4 â† 5
4.next = None

3.next.next = 3  =>  3 â† 4 â† 5
3.next = None

... continues
Final: 5 â† 4 â† 3 â† 2 â† 1
"""
```

---

### Problem 2: Merge Two Sorted Lists â­â­â­

**Problem Statement:** Merge two sorted linked lists.

```
Input:  l1 = 1 â†’ 3 â†’ 5
        l2 = 2 â†’ 4 â†’ 6
Output:      1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6
```

**Solution:**

```python
def merge_two_lists(l1, l2):
    """
    Time: O(n + m) - n and m are lengths of l1 and l2
    Space: O(1) - Only pointers used
    
    Strategy: Dummy node + two pointers
    """
    # Dummy node simplifies edge cases
    dummy = ListNode(0)
    tail = dummy
    
    # Compare and merge
    while l1 and l2:
        if l1.val <= l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next
    
    # Attach remaining nodes
    tail.next = l1 if l1 else l2
    
    return dummy.next

# Step-by-step example:
"""
l1: 1 â†’ 3 â†’ 5
l2: 2 â†’ 4 â†’ 6

dummy â†’ ?
tail = dummy

Step 1: Compare 1 vs 2, attach 1
dummy â†’ 1
l1 = 3 â†’ 5

Step 2: Compare 3 vs 2, attach 2
dummy â†’ 1 â†’ 2
l2 = 4 â†’ 6

Step 3: Compare 3 vs 4, attach 3
dummy â†’ 1 â†’ 2 â†’ 3
l1 = 5

Step 4: Compare 5 vs 4, attach 4
dummy â†’ 1 â†’ 2 â†’ 3 â†’ 4
l2 = 6

Step 5: Compare 5 vs 6, attach 5
dummy â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
l1 = None

Step 6: Attach remaining (6)
dummy â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6
"""
```

---

### Problem 3: Linked List Cycle â­â­â­

**Problem Statement:** Detect if a linked list has a cycle.

```
Input:  3 â†’ 2 â†’ 0 â†’ -4
            â†‘__________|
Output: true
```

**Solution: Floyd's Cycle Detection**

```python
def has_cycle(head):
    """
    Time: O(n) - At most 2n steps
    Space: O(1) - Only two pointers
    
    Strategy: Fast and slow pointers
    If there's a cycle, they'll eventually meet
    """
    if not head or not head.next:
        return False
    
    slow = head
    fast = head
    
    while fast and fast.next:
        slow = slow.next          # Move 1 step
        fast = fast.next.next     # Move 2 steps
        
        if slow == fast:
            return True           # They met - cycle exists!
    
    return False

# Why this works:
"""
Without cycle:
Fast pointer reaches end first â†’ return False

With cycle:
Once both pointers enter the cycle, fast gains on slow
by 1 position each iteration. Eventually they meet!

Example with cycle:
Step 0: slow=1, fast=1
Step 1: slow=2, fast=3
Step 2: slow=3, fast=2 (in cycle)
Step 3: slow=4, fast=4 (met!)
"""

# Follow-up: Find cycle start
def detect_cycle_start(head):
    """Find where cycle begins"""
    if not head:
        return None
    
    # Phase 1: Detect cycle
    slow = fast = head
    has_cycle = False
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            has_cycle = True
            break
    
    if not has_cycle:
        return None
    
    # Phase 2: Find cycle start
    # Reset slow to head, move both at same speed
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next
    
    return slow  # Cycle start

# Mathematical proof:
"""
Let: x = distance from head to cycle start
     y = distance from cycle start to meeting point
     C = cycle length

When they meet:
- Slow traveled: x + y
- Fast traveled: x + y + nC (n complete cycles)
- Fast speed = 2 Ã— Slow speed

Therefore: 2(x + y) = x + y + nC
          2x + 2y = x + y + nC
          x + y = nC
          x = nC - y

So distance from head to start = distance from meeting to start!
"""
```

---

### Problem 4: Remove Duplicates from Sorted List â­â­

**Problem Statement:** Remove duplicates from a sorted linked list.

```
Input:  1 â†’ 1 â†’ 2 â†’ 3 â†’ 3 â†’ 3 â†’ 4
Output: 1 â†’ 2 â†’ 3 â†’ 4
```

**Solution:**

```python
def delete_duplicates(head):
    """
    Time: O(n) - Single pass
    Space: O(1) - In-place
    
    Strategy: Compare current with next
    """
    if not head:
        return head
    
    current = head
    
    while current and current.next:
        if current.val == current.next.val:
            # Skip duplicate
            current.next = current.next.next
        else:
            # Move to next unique value
            current = current.next
    
    return head

# Example walkthrough:
"""
1 â†’ 1 â†’ 2 â†’ 3 â†’ 3
â†‘
current

Step 1: 1 == 1, skip
1 â†’ 2 â†’ 3 â†’ 3
â†‘
current

Step 2: 1 != 2, move
1 â†’ 2 â†’ 3 â†’ 3
    â†‘
    current

Step 3: 2 != 3, move
1 â†’ 2 â†’ 3 â†’ 3
        â†‘
        current

Step 4: 3 == 3, skip
1 â†’ 2 â†’ 3
        â†‘
        current (current.next = None, stop)
"""
```

---

### Problem 5: Middle of Linked List â­â­â­

**Problem Statement:** Find the middle node of a linked list.

```
Input:  1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
Output: 3 (return node with value 3)

Input:  1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6
Output: 4 (return second middle node)
```

**Solution:**

```python
def middle_node(head):
    """
    Time: O(n) - Single pass
    Space: O(1)
    
    Strategy: Slow-fast pointers
    When fast reaches end, slow is at middle
    """
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow

# Visualization for odd length:
"""
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5

Initial: slow=1, fast=1

Step 1:  slow=2, fast=3
         â†“       â†“
         1 â†’ 2 â†’ 3 â†’ 4 â†’ 5

Step 2:  slow=3, fast=5
             â†“           â†“
         1 â†’ 2 â†’ 3 â†’ 4 â†’ 5

Step 3: fast.next=None, stop
        slow=3 (middle!)
"""

# Visualization for even length:
"""
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6

Initial: slow=1, fast=1

Step 1:  slow=2, fast=3
         â†“       â†“
         1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6

Step 2:  slow=3, fast=5
             â†“           â†“
         1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6

Step 3:  slow=4, fast=None
                 â†“
         1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6

Stop, slow=4 (second middle!)
"""
```

---

## 8.2 Medium Problems (Pattern Mastery) ğŸ“˜

### Problem 1: Add Two Numbers â­â­â­

**Problem Statement:** Add two numbers represented as linked lists (digits in reverse order).

```
Input:  l1 = 2 â†’ 4 â†’ 3  (represents 342)
        l2 = 5 â†’ 6 â†’ 4  (represents 465)
Output:      7 â†’ 0 â†’ 8  (represents 807)
```

**Solution:**

```python
def add_two_numbers(l1, l2):
    """
    Time: O(max(n, m))
    Space: O(max(n, m)) - Result list
    
    Strategy: Elementary addition with carry
    """
    dummy = ListNode(0)
    current = dummy
    carry = 0
    
    while l1 or l2 or carry:
        # Get values (0 if node is None)
        val1 = l1.val if l1 else 0
        val2 = l2.val if l2 else 0
        
        # Calculate sum and carry
        total = val1 + val2 + carry
        carry = total // 10
        digit = total % 10
        
        # Create new node
        current.next = ListNode(digit)
        current = current.next
        
        # Move to next nodes
        l1 = l1.next if l1 else None
        l2 = l2.next if l2 else None
    
    return dummy.next

# Detailed example:
"""
l1: 2 â†’ 4 â†’ 3  (342)
l2: 5 â†’ 6 â†’ 4  (465)

Step 1: 2 + 5 + 0 = 7, carry=0, digit=7
Result: 7

Step 2: 4 + 6 + 0 = 10, carry=1, digit=0
Result: 7 â†’ 0

Step 3: 3 + 4 + 1 = 8, carry=0, digit=8
Result: 7 â†’ 0 â†’ 8

Step 4: No more nodes, but carry=0, so done
Final: 7 â†’ 0 â†’ 8 (represents 807)
"""

# Edge cases to handle:
"""
1. Different lengths:
   l1 = 9 â†’ 9
   l2 = 1
   Result: 0 â†’ 0 â†’ 1 (100)

2. Final carry:
   l1 = 9 â†’ 9 â†’ 9
   l2 = 1
   Result: 0 â†’ 0 â†’ 0 â†’ 1 (1000)

3. Empty lists:
   l1 = None, l2 = None
   Result: None or 0
"""
```

---

### Problem 2: Remove Nth Node From End â­â­â­

**Problem Statement:** Remove the nth node from the end of a linked list.

```
Input:  1 â†’ 2 â†’ 3 â†’ 4 â†’ 5, n = 2
Output: 1 â†’ 2 â†’ 3 â†’ 5
```

**Solution:**

```python
def remove_nth_from_end(head, n):
    """
    Time: O(L) - L is length of list
    Space: O(1)
    
    Strategy: Two pointers with gap of n
    """
    dummy = ListNode(0)
    dummy.next = head
    
    first = second = dummy
    
    # Move first pointer n+1 steps ahead
    for _ in range(n + 1):
        if not first:
            return head  # n is invalid
        first = first.next
    
    # Move both until first reaches end
    while first:
        first = first.next
        second = second.next
    
    # Remove nth node
    second.next = second.next.next
    
    return dummy.next

# Visual walkthrough (n=2):
"""
dummy â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ None
â†‘
first, second

Step 1: Move first n+1 (3) steps ahead
dummy â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ None
â†‘               â†‘
second          first

Step 2: Move both until first reaches None
dummy â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ None
        â†‘               â†‘
        second          first

Step 3: Keep moving...
dummy â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ None
                â†‘               â†‘
                second          first (None)

Step 4: Remove second.next (which is 4)
dummy â†’ 1 â†’ 2 â†’ 3 â†’ 5 â†’ None
                â†‘
                second.next = second.next.next

Result: 1 â†’ 2 â†’ 3 â†’ 5
"""

# Why dummy node?
"""
Edge case: Remove first node (n = length)
Without dummy:
  head = 1 â†’ 2 â†’ 3, n = 3
  Need to return head.next
  
With dummy:
  dummy â†’ 1 â†’ 2 â†’ 3, n = 3
  second ends at dummy
  dummy.next = dummy.next.next works!
"""
```

---

### Problem 3: Reorder List â­â­â­

**Problem Statement:** Reorder list in pattern: Lâ‚€ â†’ Lâ‚™ â†’ Lâ‚ â†’ Lâ‚™â‚‹â‚ â†’ Lâ‚‚ â†’ Lâ‚™â‚‹â‚‚ â†’ ...

```
Input:  1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
Output: 1 â†’ 5 â†’ 2 â†’ 4 â†’ 3
```

**Solution:**

```python
def reorder_list(head):
    """
    Time: O(n)
    Space: O(1)
    
    Strategy: Three steps
    1. Find middle
    2. Reverse second half
    3. Merge two halves
    """
    if not head or not head.next:
        return
    
    # Step 1: Find middle
    slow = fast = head
    while fast.next and fast.next.next:
        slow = slow.next
        fast = fast.next.next
    
    # Step 2: Reverse second half
    second = slow.next
    slow.next = None  # Split list
    
    prev = None
    while second:
        temp = second.next
        second.next = prev
        prev = second
        second = temp
    second = prev  # Head of reversed second half
    
    # Step 3: Merge alternately
    first = head
    while second:
        temp1 = first.next
        temp2 = second.next
        
        first.next = second
        second.next = temp1
        
        first = temp1
        second = temp2

# Detailed walkthrough:
"""
Input: 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5

Step 1: Find middle
        1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
                â†‘
              middle

Split: first = 1 â†’ 2 â†’ 3
       second = 4 â†’ 5

Step 2: Reverse second half
       second = 5 â†’ 4

Step 3: Merge
       1 â†’ 2 â†’ 3
       5 â†’ 4

Iteration 1: 1 â†’ 5 â†’ 2 â†’ 3
                      4

Iteration 2: 1 â†’ 5 â†’ 2 â†’ 4 â†’ 3

Final: 1 â†’ 5 â†’ 2 â†’ 4 â†’ 3
"""
```

---

### Problem 4: Copy List with Random Pointer â­â­â­

**Problem Statement:** Deep copy a linked list where each node has a next and random pointer.

```
Node structure:
class Node:
    def __init__(self, val, next=None, random=None):
        self.val = val
        self.next = next
        self.random = random
```

**Approach 1: HashMap**

```python
def copy_random_list(head):
    """
    Time: O(n) - Two passes
    Space: O(n) - HashMap storage
    
    Strategy: Map original nodes to copied nodes
    """
    if not head:
        return None
    
    # First pass: Create all nodes
    old_to_new = {}
    current = head
    
    while current:
        old_to_new[current] = Node(current.val)
        current = current.next
    
    # Second pass: Link next and random pointers
    current = head
    while current:
        new_node = old_to_new[current]
        new_node.next = old_to_new.get(current.next)
        new_node.random = old_to_new.get(current.random)
        current = current.next
    
    return old_to_new[head]
```

**Approach 2: Interweaving (O(1) space)**

```python
def copy_random_list_interweave(head):
    """
    Time: O(n)
    Space: O(1) - No extra space except result
    
    Strategy: Interweave copied nodes with originals
    """
    if not head:
        return None
    
    # Step 1: Create copied nodes interweaved
    current = head
    while current:
        copy = Node(current.val)
        copy.next = current.next
        current.next = copy
        current = copy.next
    
    # Now: A â†’ A' â†’ B â†’ B' â†’ C â†’ C'
    
    # Step 2: Set random pointers for copied nodes
    current = head
    while current:
        if current.random:
            current.next.random = current.random.next
        current = current.next.next
    
    # Step 3: Separate the two lists
    current = head
    copy_head = head.next
    
    while current:
        copy = current.next
        current.next = copy.next
        copy.next = copy.next.next if copy.next else None
        current = current.next
    
    return copy_head

# Visual representation:
"""
Original: A â†’ B â†’ C
Random:   A.random = C
          B.random = A
          C.random = B

Step 1: Interweave
A â†’ A' â†’ B â†’ B' â†’ C â†’ C'

Step 2: Set random pointers
A.random = C â†’ A'.random = C' (C.next)
B.random = A â†’ B'.random = A' (A.next)
C.random = B â†’ C'.random = B' (B.next)

Step 3: Separate
Original: A â†’ B â†’ C
Copy:     A' â†’ B' â†’ C'
"""
```

---

### Problem 5: Rotate List â­â­

**Problem Statement:** Rotate list to the right by k places.

```
Input:  1 â†’ 2 â†’ 3 â†’ 4 â†’ 5, k = 2
Output: 4 â†’ 5 â†’ 1 â†’ 2 â†’ 3
```

**Solution:**

```python
def rotate_right(head, k):
    """
    Time: O(n)
    Space: O(1)
    
    Strategy:
    1. Make list circular
    2. Find new tail (length - k % length - 1)
    3. Break circle at new tail
    """
    if not head or not head.next or k == 0:
        return head
    
    # Find length and make circular
    length = 1
    tail = head
    while tail.next:
        tail = tail.next
        length += 1
    
    tail.next = head  # Make circular
    
    # Find new tail position
    k = k % length
    steps_to_new_tail = length - k - 1
    
    new_tail = head
    for _ in range(steps_to_new_tail):
        new_tail = new_tail.next
    
    # Break circle
    new_head = new_tail.next
    new_tail.next = None
    
    return new_head

# Example: k=2
"""
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5

Step 1: Make circular and find length=5
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
â†‘_______________|

Step 2: k = 2 % 5 = 2
        steps_to_new_tail = 5 - 2 - 1 = 2

Step 3: Find new_tail (2 steps from head)
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
        â†‘
      new_tail

Step 4: new_head = new_tail.next = 4
        Break: new_tail.next = None

Result: 4 â†’ 5 â†’ 1 â†’ 2 â†’ 3
"""
```

---

## 8.3 Hard Problems (Interview Ready) ğŸ“•

### Problem 1: Merge K Sorted Lists â­â­â­

**Problem Statement:** Merge k sorted linked lists into one sorted list.

```
Input: [
  1 â†’ 4 â†’ 5,
  1 â†’ 3 â†’ 4,
  2 â†’ 6
]
Output: 1 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 4 â†’ 5 â†’ 6
```

**Approach 1: Min Heap**

```python
import heapq

def merge_k_lists(lists):
    """
    Time: O(N log k) - N total nodes, k lists
    Space: O(k) - Heap size
    
    Strategy: Use min heap to track smallest element
    """
    # Filter out empty lists
    lists = [l for l in lists if l]
    if not lists:
        return None
    
    # Min heap: (value, list_index, node)
    min_heap = []
    
    # Add first node from each list
    for i, node in enumerate(lists):
        heapq.heappush(min_heap, (node.val, i, node))
    
    dummy = ListNode(0)
    current = dummy
    
    while min_heap:
        val, i, node = heapq.heappop(min_heap)
        
        # Add to result
        current.next = node
        current = current.next
        
        # Add next node from same list
        if node.next:
            heapq.heappush(min_heap, (node.next.val, i, node.next))
    
    return dummy.next
```

**Approach 2: Divide and Conquer (More efficient)**

```python
def merge_k_lists_divide_conquer(lists):
    """
    Time: O(N log k) - N total nodes, k lists
    Space: O(log k) - Recursion depth
    
    Strategy: Merge pairs recursively
    """
    if not lists:
        return None
    
    def merge_two(l1, l2):
        """Helper: Merge two sorted lists"""
        dummy = ListNode(0)
        tail = dummy
        
        while l1 and l2:
            if l1.val <= l2.val:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next
        
        tail.next = l1 or l2
        return dummy.next
    
    def merge_lists(lists, left, right):
        """Divide and conquer"""
        if left == right:
            return lists[left]
        if left > right:
            return None
        
        mid = (left + right) // 2
        left_merged = merge_lists(lists, left, mid)
        right_merged = merge_lists(lists, mid + 1, right)
        
        return merge_two(left_merged, right_merged)
    
    return merge_lists(lists, 0, len(lists) - 1)

# Visualization of divide and conquer:
"""
Input: [L1, L2, L3, L4]

Level 1:      [L1, L2, L3, L4]
                /         \
Level 2:   [L1, L2]     [L3, L4]
            /    \        /    \
Level 3:   L1    L2     L3    L4
            \    /        \    /
Level 2:   Merge12      Merge34
              \            /
Level 1:       Final Merge

Total merges: log k levels Ã— N nodes = O(N log k)
"""
```

---

### Problem 2: Reverse Nodes in K-Group â­â­â­

**Problem Statement:** Reverse nodes in groups of k.

```
Input:  1 â†’ 2 â†’ 3 â†’ 4 â†’ 5, k = 2
Output: 2 â†’ 1 â†’ 4 â†’ 3 â†’ 5

Input:  1 â†’ 2 â†’ 3 â†’ 4 â†’ 5, k = 3
Output: 3 â†’ 2 â†’ 1 â†’ 4 â†’ 5
```

**Solution:**

```python
def reverse_k_group(head, k):
    """
    Time: O(n)
    Space: O(1)
    
    Strategy: Reverse each k-group in place
    """
    def has_k_nodes(node, k):
        """Check if at least k nodes remaining"""
        count = 0
        while node and count < k:
            node = node.next
            count += 1
        return count == k
    
    def reverse_segment(start, k):
        """Reverse k nodes starting from start"""
        prev = None
        current = start
        
        for _ in range(k):
            next_temp = current.next
            current.next = prev
            prev = current
            current = next_temp
        
        return prev, start, current  # new_head, new_tail, next_start
    
    dummy = ListNode(0)
    dummy.next = head
    prev_group_tail = dummy
    
    while has_k_nodes(prev_group_tail.next, k):
        # Get group boundaries
        group_start = prev_group_tail.next
        
        # Reverse this group
        new_head, new_tail, next_start = reverse_segment(group_start, k)
        
        # Connect with previous group
        prev_group_tail.next = new_head
        new_tail.next = next_start
        
        # Move to next group
        prev_group_tail = new_tail
    
    return dummy.next

# Visual example (k=2):
"""
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5

Group 1: [1, 2]
After reverse: 2 â†’ 1 â†’ 3 â†’ 4 â†’ 5

Group 2: [3, 4]
After reverse: 2 â†’ 1 â†’ 4 â†’ 3 â†’ 5

Group 3: [5] (less than k, skip)
Final: 2 â†’ 1 â†’ 4 â†’ 3 â†’ 5
"""
```

---

## Summary and Patterns

### Pattern Recognition Guide

| Pattern | Problems |
|---------|----------|
| Two Pointers | Middle, Cycle, Remove Nth |
| Dummy Node | Merge, Remove, Reverse |
| Slow-Fast | Cycle, Middle, Palindrome |
| HashMap | Copy with Random, Intersection |
| Recursion | Reverse, Merge K Lists |
| Three Steps | Reorder, Palindrome |

### Complexity Quick Reference

| Problem Category | Typical Time | Typical Space |
|-----------------|--------------|---------------|
| Single Pass | O(n) | O(1) |
| Two Pass | O(n) | O(1) |
| Divide & Conquer | O(n log n) | O(log n) |
| With HashMap | O(n) | O(n) |
| Sorting | O(n log n) | O(1) or O(log n) |

### Interview Strategy

1. **Clarify** - Ask about edge cases, constraints
2. **Draw** - Sketch first 3-4 nodes
3. **Pattern** - Identify which pattern applies
4. **Code** - Implement with clear variable names
5. **Test** - Walk through with example
6. **Optimize** - Discuss trade-offs

Practice these problems in order: Easy â†’ Medium â†’ Hard. Master the patterns, not just memorize solutions!