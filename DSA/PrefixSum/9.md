# Chapter 9: Practice Problem Categories - Deep Dive

## 9.1 Learning Path Overview

### The Progressive Mastery System

```
Level 1: Beginner (Week 1-2)
  ‚Üí Master basic pattern
  ‚Üí Build confidence
  ‚Üí 5-8 problems

Level 2: Intermediate (Week 3-4)
  ‚Üí Add variations
  ‚Üí Handle edge cases
  ‚Üí 8-12 problems

Level 3: Advanced (Week 5-6)
  ‚Üí Complex transformations
  ‚Üí Multiple conditions
  ‚Üí 10-15 problems

Level 4: Expert (Week 7-8)
  ‚Üí Combined techniques
  ‚Üí Optimization challenges
  ‚Üí 8-10 problems
```

---

## 9.2 Beginner Level Problems

### Problem 1: Subarray Sum Equals K (LeetCode 560) ‚≠ê START HERE

**Difficulty:** Medium (but perfect for learning!)

**Problem:**
Given an array of integers and an integer k, return the total number of subarrays whose sum equals k.

**Example:**
```
Input: nums = [1,1,1], k = 2
Output: 2
Explanation: [1,1] appears twice
```

**Why Start Here:**
- Pure prefix sum + HashMap pattern
- No transformations needed
- Works with negatives
- Foundation for everything else

**Solution:**
```python
def subarraySum(nums, k):
    """
    Count subarrays with sum equal to k.
    Time: O(n), Space: O(n)
    """
    hashmap = {0: 1}
    prefix_sum = 0
    count = 0
    
    for num in nums:
        prefix_sum += num
        if prefix_sum - k in hashmap:
            count += hashmap[prefix_sum - k]
        hashmap[prefix_sum] = hashmap.get(prefix_sum, 0) + 1
    
    return count
```

**Key Learnings:**
- ‚úì Basic template
- ‚úì {0: 1} initialization
- ‚úì Check before update
- ‚úì Handles negatives

---

### Problem 2: Find Pivot Index (LeetCode 724)

**Difficulty:** Easy

**Problem:**
Find the index where sum of left elements equals sum of right elements.

**Example:**
```
Input: nums = [1,7,3,6,5,6]
Output: 3
Explanation: Left sum = 1+7+3 = 11, Right sum = 5+6 = 11
```

**Key Insight:**
```
At pivot index i:
  left_sum = prefix[i-1]
  right_sum = total_sum - prefix[i]
  
If equal: prefix[i-1] = total_sum - prefix[i]
```

**Solution:**
```python
def pivotIndex(nums):
    """
    Find pivot where left sum equals right sum.
    Time: O(n), Space: O(1)
    """
    total = sum(nums)
    left_sum = 0
    
    for i, num in enumerate(nums):
        right_sum = total - left_sum - num
        if left_sum == right_sum:
            return i
        left_sum += num
    
    return -1
```

**Key Learnings:**
- ‚úì Prefix sum without HashMap
- ‚úì Two-sided comparison
- ‚úì Space optimization O(1)

---

### Problem 3: Contiguous Array (LeetCode 525)

**Difficulty:** Medium

**Problem:**
Find the maximum length of a contiguous subarray with equal number of 0s and 1s.

**Example:**
```
Input: nums = [0,1,0,1,1,0]
Output: 6
Explanation: Entire array has equal 0s and 1s
```

**Key Insight:**
```
Transform: 0 ‚Üí -1, 1 ‚Üí 1
Then find: longest subarray with sum = 0
```

**Solution:**
```python
def findMaxLength(nums):
    """
    Find longest subarray with equal 0s and 1s.
    Time: O(n), Space: O(n)
    """
    hashmap = {0: -1}
    balance = 0
    max_len = 0
    
    for i, num in enumerate(nums):
        balance += 1 if num == 1 else -1
        
        if balance in hashmap:
            max_len = max(max_len, i - hashmap[balance])
        else:
            hashmap[balance] = i
    
    return max_len
```

**Key Learnings:**
- ‚úì Problem transformation
- ‚úì Finding length, not count
- ‚úì {0: -1} for length
- ‚úì Store first occurrence

---

### Problem 4: Subarray Sums Divisible by K (LeetCode 974)

**Difficulty:** Medium

**Problem:**
Count number of subarrays where sum is divisible by k.

**Example:**
```
Input: nums = [4,5,0,-2,-3,1], k = 5
Output: 7
```

**Key Insight:**
```
If (prefix[j] - prefix[i]) % k == 0
Then: prefix[j] % k == prefix[i] % k

Store remainders instead of sums!
```

**Solution:**
```python
def subarraysDivByK(nums, k):
    """
    Count subarrays divisible by k.
    Time: O(n), Space: O(k)
    """
    hashmap = {0: 1}
    prefix_sum = 0
    count = 0
    
    for num in nums:
        prefix_sum += num
        remainder = (prefix_sum % k + k) % k
        
        if remainder in hashmap:
            count += hashmap[remainder]
        
        hashmap[remainder] = hashmap.get(remainder, 0) + 1
    
    return count
```

**Key Learnings:**
- ‚úì Working with remainders
- ‚úì Handling negative remainders
- ‚úì Space optimization: O(k)

---

### Problem 5: Range Sum Query - Immutable (LeetCode 303)

**Difficulty:** Easy

**Problem:**
Given an array, handle multiple range sum queries efficiently.

**Example:**
```
Input: ["NumArray", "sumRange", "sumRange"]
       [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5]]
Output: [null, 1, -1]
```

**Solution:**
```python
class NumArray:
    def __init__(self, nums):
        """Build prefix sum array."""
        n = len(nums)
        self.prefix = [0] * (n + 1)
        for i in range(n):
            self.prefix[i + 1] = self.prefix[i] + nums[i]
    
    def sumRange(self, left, right):
        """Return sum from left to right."""
        return self.prefix[right + 1] - self.prefix[left]
```

**Key Learnings:**
- ‚úì Build once, query many
- ‚úì O(n) build, O(1) query
- ‚úì Padding technique

---

## 9.3 Intermediate Level Problems

### Problem 6: Maximum Size Subarray Sum Equals K (LeetCode 325) üîí

**Difficulty:** Medium

**Problem:**
Find the length of the longest subarray that sums to k.

**Example:**
```
Input: nums = [1,-1,5,-2,3], k = 3
Output: 4
Explanation: [1,-1,5,-2] or [-2,3] both equal 3, first is longer
```

**Solution:**
```python
def maxSubArrayLen(nums, k):
    """
    Find longest subarray with sum k.
    Time: O(n), Space: O(n)
    """
    hashmap = {0: -1}
    prefix_sum = 0
    max_len = 0
    
    for i, num in enumerate(nums):
        prefix_sum += num
        
        if prefix_sum - k in hashmap:
            max_len = max(max_len, i - hashmap[prefix_sum - k])
        
        if prefix_sum not in hashmap:
            hashmap[prefix_sum] = i
    
    return max_len
```

**Key Learnings:**
- ‚úì Maximizing length
- ‚úì First occurrence storage
- ‚úì When NOT to update

---

### Problem 7: Continuous Subarray Sum (LeetCode 523)

**Difficulty:** Medium

**Problem:**
Check if there's a subarray of size at least 2 whose sum is a multiple of k.

**Example:**
```
Input: nums = [23,2,4,6,7], k = 6
Output: true
Explanation: [2,4] sums to 6, which is divisible by 6
```

**Key Twist:**
Must be at least 2 elements!

**Solution:**
```python
def checkSubarraySum(nums, k):
    """
    Check if subarray (size ‚â• 2) divisible by k exists.
    Time: O(n), Space: O(k)
    """
    hashmap = {0: -1}
    prefix_sum = 0
    
    for i, num in enumerate(nums):
        prefix_sum += num
        remainder = prefix_sum % k
        
        if remainder in hashmap:
            # Check if at least 2 elements
            if i - hashmap[remainder] >= 2:
                return True
        else:
            hashmap[remainder] = i
    
    return False
```

**Key Learnings:**
- ‚úì Length constraint
- ‚úì Existence check (early return)
- ‚úì Store first occurrence

---

### Problem 8: Count Number of Nice Subarrays (LeetCode 1248)

**Difficulty:** Medium

**Problem:**
A subarray is "nice" if it contains exactly k odd numbers. Count nice subarrays.

**Example:**
```
Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: [1,2,1,1] and [1,1,2,1] both have 3 odd numbers
```

**Key Insight:**
```
Transform: odd ‚Üí 1, even ‚Üí 0
Then: count subarrays with sum = k
```

**Solution:**
```python
def numberOfSubarrays(nums, k):
    """
    Count subarrays with exactly k odd numbers.
    Time: O(n), Space: O(n)
    """
    hashmap = {0: 1}
    odd_count = 0
    result = 0
    
    for num in nums:
        odd_count += num % 2  # 1 if odd, 0 if even
        
        if odd_count - k in hashmap:
            result += hashmap[odd_count - k]
        
        hashmap[odd_count] = hashmap.get(odd_count, 0) + 1
    
    return result
```

**Key Learnings:**
- ‚úì Custom transformation
- ‚úì Counting specific property
- ‚úì Same pattern works!

---

### Problem 9: Binary Subarrays With Sum (LeetCode 1074)

**Difficulty:** Medium

**Problem:**
Count subarrays in a binary array with sum equal to goal.

**Example:**
```
Input: nums = [1,0,1,0,1], goal = 2
Output: 4
```

**Solution:**
```python
def numSubarraysWithSum(nums, goal):
    """
    Count binary subarrays with sum = goal.
    Time: O(n), Space: O(n)
    """
    hashmap = {0: 1}
    prefix_sum = 0
    count = 0
    
    for num in nums:
        prefix_sum += num
        if prefix_sum - goal in hashmap:
            count += hashmap[prefix_sum - goal]
        hashmap[prefix_sum] = hashmap.get(prefix_sum, 0) + 1
    
    return count
```

**Key Learnings:**
- ‚úì Binary array (but no transformation needed!)
- ‚úì Direct application

---

### Problem 10: Make Sum Divisible by P (LeetCode 1590)

**Difficulty:** Medium

**Problem:**
Remove the smallest subarray to make sum divisible by p.

**Example:**
```
Input: nums = [3,1,4,2], p = 6
Output: 1
Explanation: Remove [4] to get sum = 6
```

**Key Insight:**
```
Total sum = S
Need to remove subarray with sum = S % p
To make (S - subarray_sum) % p == 0
```

**Solution:**
```python
def minSubarray(nums, p):
    """
    Find smallest subarray to remove.
    Time: O(n), Space: O(n)
    """
    total = sum(nums)
    target = total % p
    
    if target == 0:
        return 0
    
    hashmap = {0: -1}
    prefix_sum = 0
    min_len = len(nums)
    
    for i, num in enumerate(nums):
        prefix_sum += num
        current_mod = prefix_sum % p
        needed = (current_mod - target + p) % p
        
        if needed in hashmap:
            min_len = min(min_len, i - hashmap[needed])
        
        hashmap[current_mod] = i
    
    return min_len if min_len < len(nums) else -1
```

**Key Learnings:**
- ‚úì Finding minimum length
- ‚úì Complex modulo arithmetic
- ‚úì Update last occurrence (for minimum)

---

## 9.4 Advanced Level Problems

### Problem 11: Subarray Product Less Than K (LeetCode 713)

**Difficulty:** Medium

**Problem:**
Count subarrays where product is less than k.

**Key Insight:**
This needs sliding window, NOT prefix sum!
(Product grows too large, and we have "less than")

**Solution:**
```python
def numSubarrayProductLessThanK(nums, k):
    """
    Count subarrays with product < k.
    Time: O(n), Space: O(1)
    """
    if k <= 1:
        return 0
    
    product = 1
    count = 0
    left = 0
    
    for right in range(len(nums)):
        product *= nums[right]
        
        while product >= k:
            product //= nums[left]
            left += 1
        
        count += right - left + 1
    
    return count
```

**Key Learnings:**
- ‚úì When NOT to use prefix sum
- ‚úì Sliding window alternative
- ‚úì "At most" problems

---

### Problem 12: Count Subarrays With Score Less Than K (LeetCode 2302)

**Difficulty:** Hard

**Problem:**
Score of subarray = sum √ó length. Count subarrays with score < k.

**Example:**
```
Input: nums = [2,1,4,3,5], k = 10
Output: 6
```

**Key Insight:**
Use sliding window with prefix sum!

**Solution:**
```python
def countSubarrays(nums, k):
    """
    Count subarrays where sum * length < k.
    Time: O(n), Space: O(1)
    """
    count = 0
    left = 0
    window_sum = 0
    
    for right in range(len(nums)):
        window_sum += nums[right]
        
        # Shrink while score >= k
        while left <= right and window_sum * (right - left + 1) >= k:
            window_sum -= nums[left]
            left += 1
        
        # All subarrays ending at right
        count += right - left + 1
    
    return count
```

**Key Learnings:**
- ‚úì Combined conditions
- ‚úì Dynamic calculation
- ‚úì Sliding window variation

---

### Problem 13: Count Vowel Strings in Ranges (LeetCode 2559)

**Difficulty:** Medium

**Problem:**
Count words in ranges that start and end with vowels.

**Key Insight:**
Prefix sum of count!

**Solution:**
```python
def vowelStrings(words, queries):
    """
    Count vowel strings in ranges.
    Time: O(n + q), Space: O(n)
    """
    def is_vowel_string(word):
        vowels = set('aeiou')
        return word[0] in vowels and word[-1] in vowels
    
    n = len(words)
    prefix = [0] * (n + 1)
    
    for i in range(n):
        prefix[i + 1] = prefix[i] + (1 if is_vowel_string(words[i]) else 0)
    
    result = []
    for left, right in queries:
        result.append(prefix[right + 1] - prefix[left])
    
    return result
```

**Key Learnings:**
- ‚úì Prefix sum of properties
- ‚úì Multiple queries
- ‚úì O(1) per query

---

## 9.5 Expert Level Problems

### Problem 14: Number of Submatrices That Sum to Target (LeetCode 1074)

**Difficulty:** Hard

**Problem:**
Count submatrices with sum equal to target.

**Solution:**
```python
def numSubmatrixSumTarget(matrix, target):
    """
    Count 2D submatrices with sum = target.
    Time: O(rows¬≤ √ó cols), Space: O(cols)
    """
    if not matrix:
        return 0
    
    rows, cols = len(matrix), len(matrix[0])
    count = 0
    
    for top in range(rows):
        col_sum = [0] * cols
        
        for bottom in range(top, rows):
            # Update column sums
            for c in range(cols):
                col_sum[c] += matrix[bottom][c]
            
            # Apply 1D subarray sum
            count += count_sum_k(col_sum, target)
    
    return count

def count_sum_k(arr, k):
    hashmap = {0: 1}
    prefix = 0
    count = 0
    for num in arr:
        prefix += num
        if prefix - k in hashmap:
            count += hashmap[prefix - k]
        hashmap[prefix] = hashmap.get(prefix, 0) + 1
    return count
```

**Key Learnings:**
- ‚úì 2D to 1D reduction
- ‚úì Nested loops pattern
- ‚úì Reusing 1D solution

---

### Problem 15: XOR Queries of a Subarray (LeetCode 1310)

**Difficulty:** Medium

**Problem:**
Answer multiple queries about XOR of subarrays.

**Solution:**
```python
def xorQueries(arr, queries):
    """
    Answer XOR queries efficiently.
    Time: O(n + q), Space: O(n)
    """
    n = len(arr)
    prefix_xor = [0] * (n + 1)
    
    for i in range(n):
        prefix_xor[i + 1] = prefix_xor[i] ^ arr[i]
    
    result = []
    for left, right in queries:
        result.append(prefix_xor[right + 1] ^ prefix_xor[left])
    
    return result
```

**Key Learnings:**
- ‚úì XOR prefix sum
- ‚úì Range XOR in O(1)
- ‚úì XOR cancellation property

---

## 9.6 Problem-Solving Strategy

### How to Approach Each Problem

```
1. Read carefully
   - What's the input?
   - What's the output?
   - Any constraints?

2. Identify pattern
   - Subarray/substring?
   - Cumulative property?
   - What are we finding?

3. Choose template
   - Count ‚Üí {0: 1}, frequency
   - Length ‚Üí {0: -1}, first index
   - Divisible ‚Üí remainders

4. Handle edge cases
   - Empty array
   - Single element
   - All same
   - Negatives

5. Test and debug
   - Small examples
   - Edge cases
   - Performance
```

---

## 9.7 Practice Schedule

### Week-by-Week Plan

**Week 1-2: Beginner (Foundation)**
```
Day 1-2: Problem 1 (Subarray Sum K) - Master it!
Day 3: Problem 2 (Pivot Index)
Day 4: Problem 3 (Contiguous Array)
Day 5: Problem 4 (Divisible by K)
Day 6: Problem 5 (Range Sum Query)
Day 7: Review all, solve variants
```

**Week 3-4: Intermediate (Variations)**
```
Day 1-2: Problem 6 (Max Length)
Day 3: Problem 7 (Continuous Sum)
Day 4: Problem 8 (Nice Subarrays)
Day 5: Problem 9 (Binary Subarrays)
Day 6: Problem 10 (Make Divisible)
Day 7: Review patterns, compare solutions
```

**Week 5-6: Advanced (Complex)**
```
Day 1-2: Problem 11-12 (Products, Scores)
Day 3: Problem 13 (Vowel Strings)
Day 4-5: Custom problems, variations
Day 6: Speed practice
Day 7: Review all patterns
```

**Week 7-8: Expert (Mastery)**
```
Day 1-2: Problem 14 (2D Matrix)
Day 3: Problem 15 (XOR Queries)
Day 4-5: Hard problems from LeetCode
Day 6: Mock interviews
Day 7: Final review
```

---

## 9.8 Key Takeaways

üéØ **Start Simple:**
- Master Problem 1 first
- Build confidence
- Understand template deeply

üîë **Progress Gradually:**
- Don't skip levels
- Solve variations
- Compare different approaches

üí° **Active Learning:**
- Code without looking
- Explain to yourself
- Teach others

‚ö†Ô∏è **Common Traps:**
- Rushing to hard problems
- Not understanding "why"
- Skipping edge cases

üöÄ **Success Metrics:**
- Recognize pattern in 30 seconds
- Code solution in 5 minutes
- Handle edge cases naturally