# Chapter 3: Combining Prefix Sum + HashMap - Deep Dive

## 3.1 The Core Pattern

### The Breakthrough Insight

When we combine **prefix sum** with **HashMap**, we unlock a powerful pattern to solve subarray problems in O(n) time!

### The Problem Class

Given an array, find subarrays that satisfy some condition:
- Sum equals K
- Sum divisible by K  
- Equal number of 0s and 1s
- XOR equals K
- And many more...

### Why This Combination Works

**Prefix Sum** tells us cumulative values efficiently.
**HashMap** remembers states we've seen before.

Together, they let us answer: **"Have I seen a state that makes the current subarray valid?"**

---

## 3.2 The Fundamental Equation

### The Math Behind It

```
If we want: sum(i+1 to j) = K
Then:       prefix[j] - prefix[i] = K
Rearrange:  prefix[i] = prefix[j] - K
```

**This is the KEY insight!**

Instead of checking all possible subarrays (O(n¬≤)), we:
1. Calculate current prefix sum
2. Check if `(current_prefix - K)` exists in HashMap
3. If yes, we found valid subarray(s)!

### Visual Explanation

```
Array: [1, 2, 3, 4, 5]  Target K = 7

Index:        0  1  2  3  4
Array:        1  2  3  4  5
Prefix:       1  3  6  10 15

Find subarrays with sum = 7

At index 3 (prefix = 10):
  We need: prefix[i] = 10 - 7 = 3
  Is 3 in our HashMap? YES! At index 1
  
  This means: sum(2 to 3) = 3 + 4 = 7 ‚úì
  
Because: prefix[3] - prefix[1] = 10 - 3 = 7
```

---

## 3.3 Standard Template

### The Universal Pattern

```python
def subarray_pattern(arr, k):
    """
    Standard template for prefix sum + HashMap problems
    """
    # Step 1: Initialize HashMap with base case
    hashmap = {0: 1}  # Why? We'll explain!
    
    # Step 2: Initialize tracking variables
    prefix_sum = 0
    result = 0
    
    # Step 3: Iterate through array
    for num in arr:
        # Update prefix sum
        prefix_sum += num
        
        # Calculate what we need to find
        target = prefix_sum - k
        
        # Check if target exists in HashMap
        if target in hashmap:
            result += hashmap[target]
        
        # Store current prefix sum
        hashmap[prefix_sum] = hashmap.get(prefix_sum, 0) + 1
    
    return result
```

---

## 3.4 Complete Example: Subarray Sum Equals K

### Problem Statement

Given an array of integers and an integer k, find the **total number** of continuous subarrays whose sum equals k.

### Example Walkthrough

```
Array: [1, 2, 3, 4, 5]
Target: k = 5

Expected subarrays:
- [2, 3] ‚Üí sum = 5
- [5] ‚Üí sum = 5
Answer: 2
```

### Code with Detailed Comments

```python
def subarray_sum_equals_k(arr, k):
    """
    Count subarrays with sum equal to k.
    Time: O(n), Space: O(n)
    """
    hashmap = {0: 1}  # prefix_sum -> count
    prefix_sum = 0
    count = 0
    
    for i, num in enumerate(arr):
        prefix_sum += num
        target = prefix_sum - k
        
        if target in hashmap:
            count += hashmap[target]
        
        hashmap[prefix_sum] = hashmap.get(prefix_sum, 0) + 1
        
        # Debug print
        print(f"i={i}, num={num}, prefix={prefix_sum}, "
              f"target={target}, map={hashmap}, count={count}")
    
    return count

# Example
arr = [1, 2, 3, 4, 5]
k = 5
result = subarray_sum_equals_k(arr, k)
print(f"\nTotal count: {result}")
```

### Step-by-Step Execution

```
Initial: hashmap = {0: 1}, prefix_sum = 0, count = 0

i=0, num=1:
  prefix_sum = 0 + 1 = 1
  target = 1 - 5 = -4
  Is -4 in map? NO
  hashmap = {0: 1, 1: 1}
  count = 0

i=1, num=2:
  prefix_sum = 1 + 2 = 3
  target = 3 - 5 = -2
  Is -2 in map? NO
  hashmap = {0: 1, 1: 1, 3: 1}
  count = 0

i=2, num=3:
  prefix_sum = 3 + 3 = 6
  target = 6 - 5 = 1
  Is 1 in map? YES! (count = 1)
  Found: subarray [2, 3] with sum 5 ‚úì
  hashmap = {0: 1, 1: 1, 3: 1, 6: 1}
  count = 1

i=3, num=4:
  prefix_sum = 6 + 4 = 10
  target = 10 - 5 = 5
  Is 5 in map? NO
  hashmap = {0: 1, 1: 1, 3: 1, 6: 1, 10: 1}
  count = 1

i=4, num=5:
  prefix_sum = 10 + 5 = 15
  target = 15 - 5 = 10
  Is 10 in map? YES! (count = 1)
  Found: subarray [5] with sum 5 ‚úì
  hashmap = {0: 1, 1: 1, 3: 1, 6: 1, 10: 1, 15: 1}
  count = 2

Final answer: 2
```

---

## 3.5 Why Initialize HashMap with {0: 1}?

### The Critical Question

This is the most confusing part for beginners! Let's understand it deeply.

### Scenario: Subarray Starting from Index 0

```
Array: [3, 4, 7, 2]
Target: k = 7

What if the answer includes elements from the start?

At index 1:
  prefix_sum = 3 + 4 = 7
  target = 7 - 7 = 0
  
We need to check: "Is there a prefix_sum of 0?"
YES! Before we started, prefix_sum was 0
This represents: sum(0 to 1) = 7 ‚úì
```

### Visual Explanation

```
Imagine a "virtual index" before the array:

Index:      -1   0   1   2   3
Prefix:      0   3   7  14  16
             ‚Üë
        This is why we need {0: 1}!
        
When we're at index 1 with prefix=7:
  We want sum = 7
  We need prefix[i] = 7 - 7 = 0
  The "0" exists at this virtual position!
```

### What if We Don't Initialize?

```python
# WITHOUT {0: 1}
arr = [3, 4, -3]
k = 7

At index 1: prefix = 7, target = 0
  0 NOT in hashmap ‚Üí MISS the answer [3, 4]!
```

### The Rule

**For counting problems:** Initialize with `{0: 1}`
- The "1" means we've seen prefix_sum of 0 once (before array starts)

---

## 3.6 Check Before Update vs Update Before Check

### The Order Matters!

```python
# Order 1: CHECK then UPDATE (Correct for counting)
if target in hashmap:
    count += hashmap[target]
hashmap[prefix_sum] = hashmap.get(prefix_sum, 0) + 1

# Order 2: UPDATE then CHECK (Usually wrong!)
hashmap[prefix_sum] = hashmap.get(prefix_sum, 0) + 1
if target in hashmap:
    count += hashmap[target]
```

### Why Check First?

**Example that shows the problem:**

```
Array: [0, 0], k = 0

Correct (check first):
  i=0, num=0:
    prefix = 0, target = 0
    Check: 0 in map? YES (count = 1) ‚úì
    Update: map = {0: 2}
    
  i=1, num=0:
    prefix = 0, target = 0
    Check: 0 in map? YES (count = 2) ‚úì
    Update: map = {0: 3}
    
  Answer: 2 ‚úì

Wrong (update first):
  i=0, num=0:
    Update: map = {0: 2}
    Check: 0 in map? YES (count = 2) ‚úó WRONG!
    
  We counted the element with itself!
```

### The Rule

**For counting problems:**
- Check HashMap first
- Then update HashMap
- This prevents counting the same element as part of its own subarray

---

## 3.7 Multiple Subarrays with Same Sum

### When Multiple Valid Subarrays Exist

```python
def subarray_sum_with_details(arr, k):
    """
    Find ALL subarrays (return starting indices)
    """
    hashmap = {0: [-1]}  # Store list of indices
    prefix_sum = 0
    result = []
    
    for i, num in enumerate(arr):
        prefix_sum += num
        target = prefix_sum - k
        
        if target in hashmap:
            # Found multiple valid starting points
            for start_idx in hashmap[target]:
                result.append((start_idx + 1, i))
        
        if prefix_sum not in hashmap:
            hashmap[prefix_sum] = []
        hashmap[prefix_sum].append(i)
    
    return result

# Example
arr = [1, 1, 1]
k = 2

result = subarray_sum_with_details(arr, k)
print(result)
# Output: [(0, 1), (1, 2)]
# Meaning: arr[0:2] = [1,1] and arr[1:3] = [1,1]
```

### Visualization

```
Array: [1, 1, 1], k = 2

Prefix: [0, 1, 2, 3]
         ‚Üë  ‚Üë  ‚Üë  ‚Üë
Index:  -1  0  1  2

To get sum=2:
  prefix[1] - prefix[-1] = 2 - 0 = 2 ‚úì ‚Üí subarray [1,1]
  prefix[2] - prefix[0]  = 3 - 1 = 2 ‚úì ‚Üí subarray [1,1]
  
Both are valid!
```

---

## 3.8 Finding Longest Subarray

### Different Objective: Length Instead of Count

When finding the **longest** subarray (not counting them), we only want to keep the **first occurrence** of each prefix sum.

```python
def longest_subarray_sum_k(arr, k):
    """
    Find LENGTH of longest subarray with sum = k.
    Time: O(n), Space: O(n)
    """
    hashmap = {0: -1}  # prefix_sum -> first_index
    prefix_sum = 0
    max_length = 0
    
    for i, num in enumerate(arr):
        prefix_sum += num
        target = prefix_sum - k
        
        if target in hashmap:
            length = i - hashmap[target]
            max_length = max(max_length, length)
        
        # Only store first occurrence!
        if prefix_sum not in hashmap:
            hashmap[prefix_sum] = i
    
    return max_length

# Example
arr = [1, -1, 5, -2, 3]
k = 3

result = longest_subarray_sum_k(arr, k)
print(result)  # 4 (subarray [1, -1, 5, -2])
```

### Key Differences from Counting Version

| Aspect | Count Version | Length Version |
|--------|--------------|----------------|
| HashMap value | Count of occurrences | First index only |
| HashMap init | `{0: 1}` | `{0: -1}` |
| Update logic | Always update | Update only if new |
| Check order | Check then update | Check then conditionally update |

### Why `{0: -1}` for Length?

```
For subarray starting at index 0:

Array: [1, 2, 3]
If we want sum of entire array starting at 0:

At index 2: prefix = 6
If target = 0:
  Length = 2 - (-1) = 3 ‚úì
  
The -1 makes the math work!
```

---

## 3.9 Complete Real Example: LeetCode Problem

### Problem: Subarray Sum Equals K (LeetCode 560)

```python
def subarraySum(nums, k):
    """
    Given an array and target k, return count of subarrays
    with sum equal to k.
    
    Example:
    Input: nums = [1,1,1], k = 2
    Output: 2
    
    Example 2:
    Input: nums = [1,2,3], k = 3
    Output: 2 (subarrays [1,2] and [3])
    """
    hashmap = {0: 1}
    prefix_sum = 0
    count = 0
    
    for num in nums:
        prefix_sum += num
        target = prefix_sum - k
        
        if target in hashmap:
            count += hashmap[target]
        
        hashmap[prefix_sum] = hashmap.get(prefix_sum, 0) + 1
    
    return count

# Test cases
print(subarraySum([1,1,1], 2))           # 2
print(subarraySum([1,2,3], 3))           # 2
print(subarraySum([1], 0))               # 0
print(subarraySum([1,-1,0], 0))          # 3
print(subarraySum([3,4,7,2,-3,1,4,2], 7)) # 4
```

---

## 3.10 Common Mistakes and How to Avoid Them

### ‚ùå Mistake 1: Wrong Initialization

```python
# Wrong
hashmap = {}  # Missing base case!

# Correct
hashmap = {0: 1}  # For counting problems
# OR
hashmap = {0: -1}  # For length problems
```

### ‚ùå Mistake 2: Calculating Target Wrong

```python
# Wrong
target = k - prefix_sum  # Backwards!

# Correct
target = prefix_sum - k
```

### ‚ùå Mistake 3: Updating Before Checking

```python
# Wrong (counts same element)
hashmap[prefix_sum] += 1
if target in hashmap:
    count += hashmap[target]

# Correct
if target in hashmap:
    count += hashmap[target]
hashmap[prefix_sum] += 1
```

### ‚ùå Mistake 4: Not Handling Negative Numbers

```python
# This pattern works with negative numbers!
# No special handling needed (unlike sliding window)
arr = [1, -1, 5, -2, 3]
k = 3
# Works perfectly! ‚úì
```

---

## 3.11 Time and Space Complexity

### Time Complexity: O(n)
- Single pass through array: O(n)
- HashMap operations (insert/lookup): O(1) each
- Total: O(n)

### Space Complexity: O(n)
- HashMap can store up to n different prefix sums
- In worst case: all prefix sums are unique

### When is Space Less?
- If many elements are same value
- If prefix sums repeat often
- Actual space: O(min(n, range_of_sums))

---

## 3.12 Practice Problems

### Master These!

1. **Subarray Sum Equals K** (LeetCode 560) - Start here!
2. **Contiguous Array** (LeetCode 525) - Transform to sum=0
3. **Subarray Sum Divisible by K** (LeetCode 974) - Use modulo
4. **Find Pivot Index** (LeetCode 724) - Prefix variation

---

## 3.13 Key Takeaways

üéØ **Core Equation:** `prefix[i] = prefix[j] - k`

üîë **Why HashMap:** Stores which prefix sums we've seen (and how many times)

üí° **Initialization:**
- Counting: `{0: 1}`
- Length: `{0: -1}`

‚ö†Ô∏è **Order Matters:**
- Check HashMap FIRST
- Update HashMap SECOND

üöÄ **Power:** Converts O(n¬≤) brute force to O(n) optimal!

**Next:** We'll apply this pattern to specific problem types and variations!