# Chapter 2: HashMap Fundamentals - Deep Dive

## 2.1 What is a HashMap?

A **HashMap** (also called Hash Table or Dictionary) is a data structure that stores key-value pairs and provides O(1) average-case lookup, insertion, and deletion.

### Core Properties
- **Key-Value Storage:** Each key maps to exactly one value
- **Fast Lookup:** O(1) average time to find a value by its key
- **Unique Keys:** Each key can appear only once (values can repeat)
- **Unordered:** Keys are not stored in any particular order (in most implementations)

### Visual Representation

```
HashMap: {key â†’ value}

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Key      â”‚  Value  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     5       â”‚    2    â”‚ â† Store frequency of 5
â”‚     3       â”‚    1    â”‚ â† Store frequency of 3
â”‚    -1       â”‚    3    â”‚ â† Store frequency of -1
â”‚     0       â”‚    4    â”‚ â† Store frequency of 0
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2.2 HashMap Basics in Python

### Creating and Using HashMaps

```python
# Different ways to create a HashMap (dict in Python)

# Method 1: Empty dictionary
hashmap = {}

# Method 2: Initialize with values
hashmap = {1: 'one', 2: 'two', 3: 'three'}

# Method 3: Using dict() constructor
hashmap = dict()

# Method 4: Dictionary comprehension
hashmap = {i: i**2 for i in range(5)}
print(hashmap)  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
```

### Basic Operations

```python
# INSERT or UPDATE
hashmap = {}
hashmap['apple'] = 5      # Insert
hashmap['apple'] = 10     # Update
print(hashmap)            # {'apple': 10}

# GET (retrieve value)
value = hashmap['apple']           # Returns 10
value = hashmap.get('orange')      # Returns None (safe)
value = hashmap.get('orange', 0)   # Returns 0 (default)

# CHECK existence
if 'apple' in hashmap:
    print("Found!")

# DELETE
del hashmap['apple']              # Remove key-value pair
value = hashmap.pop('banana', 0)  # Remove and return (with default)

# SIZE
size = len(hashmap)
```

---

## 2.3 Pattern 1: Frequency Counting

### Problem: Count Occurrences of Each Element

```python
def count_frequencies(arr):
    """
    Count how many times each element appears.
    Time: O(n), Space: O(n)
    """
    freq_map = {}
    
    for num in arr:
        # Method 1: Manual check
        if num in freq_map:
            freq_map[num] += 1
        else:
            freq_map[num] = 1
    
    return freq_map

# Example
arr = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
freq = count_frequencies(arr)
print(freq)
# Output: {1: 1, 2: 2, 3: 3, 4: 4}
```

### Cleaner Implementation Using get()

```python
def count_frequencies_clean(arr):
    """
    Using get() with default value.
    """
    freq_map = {}
    
    for num in arr:
        freq_map[num] = freq_map.get(num, 0) + 1
    
    return freq_map
```

### Using defaultdict (Python)

```python
from collections import defaultdict

def count_frequencies_defaultdict(arr):
    """
    defaultdict automatically initializes missing keys.
    """
    freq_map = defaultdict(int)  # default value is 0
    
    for num in arr:
        freq_map[num] += 1  # No need to check existence!
    
    return dict(freq_map)
```

### Using Counter (Python - Most Pythonic)

```python
from collections import Counter

def count_frequencies_counter(arr):
    """
    Counter is built specifically for counting.
    """
    return Counter(arr)

# Example
arr = [1, 2, 2, 3, 3, 3]
freq = count_frequencies_counter(arr)
print(freq)  # Counter({3: 3, 2: 2, 1: 1})
print(freq[3])  # 3
print(freq[99])  # 0 (returns 0 for missing keys)
```

---

## 2.4 Pattern 2: Index Mapping

### Problem: Store First or Last Occurrence Index

```python
def first_occurrence(arr):
    """
    Store the first index where each element appears.
    """
    index_map = {}
    
    for i, num in enumerate(arr):
        if num not in index_map:  # Only store first occurrence
            index_map[num] = i
    
    return index_map

# Example
arr = [5, 2, 3, 2, 5, 7]
first = first_occurrence(arr)
print(first)  # {5: 0, 2: 1, 3: 2, 7: 5}
```

```python
def last_occurrence(arr):
    """
    Store the last index where each element appears.
    """
    index_map = {}
    
    for i, num in enumerate(arr):
        index_map[num] = i  # Always update (keeps last)
    
    return index_map

# Example
arr = [5, 2, 3, 2, 5, 7]
last = last_occurrence(arr)
print(last)  # {5: 4, 2: 3, 3: 2, 7: 5}
```

### Storing All Occurrences

```python
from collections import defaultdict

def all_occurrences(arr):
    """
    Store all indices where each element appears.
    """
    index_map = defaultdict(list)
    
    for i, num in enumerate(arr):
        index_map[num].append(i)
    
    return dict(index_map)

# Example
arr = [5, 2, 3, 2, 5, 7]
all_idx = all_occurrences(arr)
print(all_idx)
# Output: {5: [0, 4], 2: [1, 3], 3: [2], 7: [5]}
```

---

## 2.5 Pattern 3: Two Sum Problem - Classic HashMap Usage

### Problem Statement
Given an array of integers and a target, find two numbers that add up to the target.

### Naive Approach - O(nÂ²)
```python
def two_sum_naive(arr, target):
    """
    Check every pair of numbers.
    Time: O(nÂ²), Space: O(1)
    """
    n = len(arr)
    for i in range(n):
        for j in range(i+1, n):
            if arr[i] + arr[j] == target:
                return [i, j]
    return None
```

### Optimized with HashMap - O(n)

```python
def two_sum(arr, target):
    """
    Use HashMap to store seen numbers.
    Time: O(n), Space: O(n)
    """
    seen = {}  # num -> index
    
    for i, num in enumerate(arr):
        complement = target - num
        
        # Check if complement exists
        if complement in seen:
            return [seen[complement], i]
        
        # Store current number
        seen[num] = i
    
    return None

# Example
arr = [2, 7, 11, 15]
target = 9
result = two_sum(arr, target)
print(result)  # [0, 1] because arr[0] + arr[1] = 2 + 7 = 9
```

### Step-by-Step Visualization

```
Array: [2, 7, 11, 15], Target: 9

Step 1: i=0, num=2
  complement = 9 - 2 = 7
  seen = {} (empty)
  7 not in seen, so add 2
  seen = {2: 0}

Step 2: i=1, num=7
  complement = 9 - 7 = 2
  seen = {2: 0}
  2 IS in seen! âœ“
  Return [0, 1]
```

### Why HashMap?

**The key insight:** Instead of checking every pair, we ask:
"Have I seen the complement of this number before?"

```
For each number x, we need (target - x)
We store each number as we see it
When we find target - x in our HashMap, we found the pair!
```

---

## 2.6 Pattern 4: State Tracking

### Problem: Checking for Duplicates Within K Distance

```python
def contains_nearby_duplicate(arr, k):
    """
    Return True if there are two duplicate numbers
    within k indices of each other.
    """
    index_map = {}
    
    for i, num in enumerate(arr):
        # Check if we've seen this number recently
        if num in index_map:
            if i - index_map[num] <= k:
                return True
        
        # Update/store current index
        index_map[num] = i
    
    return False

# Example
arr = [1, 2, 3, 1, 2, 3]
print(contains_nearby_duplicate(arr, 2))  # False
print(contains_nearby_duplicate(arr, 3))  # True (1 appears at 0 and 3)
```

### Visualization

```
Array: [1, 2, 3, 1, 2, 3], k = 3

i=0, num=1: map = {1: 0}
i=1, num=2: map = {1: 0, 2: 1}
i=2, num=3: map = {1: 0, 2: 1, 3: 2}
i=3, num=1: 
  Found 1 at index 0
  Distance = 3 - 0 = 3
  Is 3 <= 3? YES! Return True âœ“
```

---

## 2.7 Advanced: Composite Keys

### Problem: Track Multiple Properties

Sometimes we need to track combinations of properties:

```python
def track_student_scores():
    """
    Store scores with composite key: (subject, student_name)
    """
    scores = {}
    
    # Store: key = (subject, name), value = score
    scores[('Math', 'Alice')] = 95
    scores[('Math', 'Bob')] = 87
    scores[('Science', 'Alice')] = 92
    
    # Query
    alice_math = scores.get(('Math', 'Alice'))
    print(f"Alice's Math score: {alice_math}")
    
    return scores

# Can use tuples as keys since they're immutable
```

### Nested HashMaps

```python
def track_scores_nested():
    """
    Alternative: nested dictionaries
    """
    scores = {
        'Math': {'Alice': 95, 'Bob': 87},
        'Science': {'Alice': 92, 'Bob': 89}
    }
    
    # Query
    alice_math = scores['Math']['Alice']
    print(f"Alice's Math score: {alice_math}")
    
    return scores
```

---

## 2.8 HashMap for Prefix Sum Problems

### The Setup for Next Chapter

In prefix sum problems, HashMap stores **states** we've seen before:

```python
def basic_pattern():
    """
    Template for prefix sum + HashMap problems
    """
    hashmap = {}
    hashmap[0] = 1  # Important initialization!
    
    prefix_sum = 0
    result = 0
    
    for num in arr:
        prefix_sum += num
        
        # Check if we've seen this state
        target = prefix_sum - k
        if target in hashmap:
            result += hashmap[target]
        
        # Store current state
        hashmap[prefix_sum] = hashmap.get(prefix_sum, 0) + 1
    
    return result
```

**Why `hashmap[0] = 1`?**
This handles subarrays that start from index 0. We'll explore this deeply in Chapter 3!

---

## 2.9 Common HashMap Patterns Summary

### Pattern Summary Table

| Pattern | Key | Value | Use Case |
|---------|-----|-------|----------|
| Frequency | Element | Count | Count occurrences |
| Index Map | Element | Index | Find first/last position |
| Complement | Number | Index | Two Sum problems |
| State | Prefix Sum | Count/Index | Subarray problems |
| Seen Set | Element | Boolean/None | Check existence |

---

## 2.10 Time and Space Complexity

### HashMap Operations

| Operation | Average | Worst Case |
|-----------|---------|------------|
| Insert | O(1) | O(n) |
| Delete | O(1) | O(n) |
| Search | O(1) | O(n) |

**Note:** Worst case O(n) happens with hash collisions (very rare with good hash functions)

### Space Complexity

For n elements stored: **O(n)** space

---

## 2.11 Common Pitfalls

### âŒ Pitfall 1: Checking Before Initializing

```python
# Wrong: May cause KeyError
count = hashmap[key] + 1

# Right: Use get() with default
count = hashmap.get(key, 0) + 1

# Or: Check existence first
if key in hashmap:
    hashmap[key] += 1
else:
    hashmap[key] = 1
```

### âŒ Pitfall 2: Using Mutable Objects as Keys

```python
# Wrong: Lists are mutable and can't be keys
hashmap[[1, 2, 3]] = "value"  # ERROR!

# Right: Use tuples (immutable)
hashmap[(1, 2, 3)] = "value"  # Works!
```

### âŒ Pitfall 3: Modifying While Iterating

```python
# Dangerous: Size changes during iteration
for key in hashmap:
    if some_condition:
        del hashmap[key]  # Can cause errors!

# Safe: Iterate over a copy
for key in list(hashmap.keys()):
    if some_condition:
        del hashmap[key]
```

---

## 2.12 Practice Problems

### Beginner
1. **Two Sum** (LeetCode 1) - Classic HashMap
2. **Contains Duplicate** (LeetCode 217) - Existence check
3. **Valid Anagram** (LeetCode 242) - Frequency counting

### Intermediate
4. **Group Anagrams** (LeetCode 49) - HashMap with sorted keys
5. **Top K Frequent Elements** (LeetCode 347) - HashMap + sorting
6. **First Unique Character** (LeetCode 387) - Frequency + index

---

## 2.13 Key Takeaways

ðŸŽ¯ **Core Concept:** HashMap provides O(1) lookup for stored keys

ðŸ”‘ **Key Patterns:**
- Frequency counting: `map[element] = count`
- Index tracking: `map[element] = index`
- State checking: `map[state] = seen/count`

ðŸ’¡ **Pro Tips:**
- Use `get()` with default to avoid KeyError
- Use `defaultdict` for automatic initialization
- Use `Counter` for frequency problems

âš ï¸ **Watch Out:**
- Don't use mutable objects as keys
- Be careful with missing keys
- Consider hash collisions in worst case

ðŸš€ **Next Step:** Learn how HashMap combines with prefix sum for powerful subarray pattern matching!