# Chapter 7: Common Pitfalls and Debugging - Deep Dive

## 7.1 The Top 10 Most Common Mistakes

### Overview

Even experienced programmers make these mistakes! Let's understand each one deeply and learn how to avoid them.

---

## 7.2 Mistake #1: Wrong HashMap Initialization

### The Problem

```python
# ‚ùå WRONG - Missing base case
def count_sum(arr, k):
    hashmap = {}  # Empty initialization
    prefix = 0
    count = 0
    
    for num in arr:
        prefix += num
        if prefix - k in hashmap:
            count += hashmap[prefix - k]
        hashmap[prefix] = hashmap.get(prefix, 0) + 1
    
    return count

# Example that fails:
arr = [3, 4]
k = 7
# Expected: 1 (subarray [3,4])
# Got: 0 (misses it!)
```

### Why It Fails

```
At index 1:
  prefix = 7
  target = 7 - 7 = 0
  Is 0 in hashmap? NO!
  
We need {0: 1} to represent "sum of 0 before array starts"
```

### The Fix

```python
# ‚úÖ CORRECT
def count_sum(arr, k):
    hashmap = {0: 1}  # Initialize with base case!
    prefix = 0
    count = 0
    
    for num in arr:
        prefix += num
        if prefix - k in hashmap:
            count += hashmap[prefix - k]
        hashmap[prefix] = hashmap.get(prefix, 0) + 1
    
    return count
```

### Initialization Guide

```python
# For COUNTING problems
hashmap = {0: 1}  # "We've seen sum=0 once"

# For LENGTH problems  
hashmap = {0: -1}  # "Virtual index before array"

# For EXISTS problems
hashmap = {0}  # Just a set is enough
```

---

## 7.3 Mistake #2: Calculating Target Incorrectly

### The Problem

```python
# ‚ùå WRONG - Target calculation backwards
def count_sum(arr, k):
    hashmap = {0: 1}
    prefix = 0
    count = 0
    
    for num in arr:
        prefix += num
        target = k - prefix  # WRONG ORDER!
        if target in hashmap:
            count += hashmap[target]
        hashmap[prefix] = hashmap.get(prefix, 0) + 1
    
    return count
```

### Why It's Wrong

```
Math:
  We want: prefix[j] - prefix[i] = k
  Rearrange: prefix[i] = prefix[j] - k
  
Current prefix is prefix[j]
We need to find prefix[i]

prefix[i] = prefix[j] - k
target = prefix - k  ‚úì

NOT: target = k - prefix  ‚úó
```

### Visual Proof

```
arr = [1, 2, 3]
k = 3

At i=1: prefix=3

Correct: target = 3 - 3 = 0
  Find prefix[i] = 0
  Subarray: [1, 2] has sum = 3 ‚úì

Wrong: target = 3 - 3 = 0 (coincidentally same!)

At i=2: prefix=6

Correct: target = 6 - 3 = 3
  Find prefix[i] = 3
  Subarray: [3] has sum = 3 ‚úì

Wrong: target = 3 - 6 = -3
  Find prefix[i] = -3
  Not in map! Misses answer ‚úó
```

### The Fix

```python
# ‚úÖ CORRECT
target = prefix - k  # Always: current prefix minus k
```

### Target Formulas Reference

```python
# Sum equals K
target = prefix_sum - k

# XOR equals K
target = prefix_xor ^ k

# Product equals K (positive numbers only)
target = log(prefix_product) - log(k)

# Divisible by K (no "target", check same remainder)
remainder = (prefix_sum % k + k) % k
```

---

## 7.4 Mistake #3: Wrong Update Order

### The Problem

```python
# ‚ùå WRONG - Update before check
def count_sum(arr, k):
    hashmap = {0: 1}
    prefix = 0
    count = 0
    
    for num in arr:
        prefix += num
        
        # WRONG ORDER!
        hashmap[prefix] = hashmap.get(prefix, 0) + 1
        
        if prefix - k in hashmap:
            count += hashmap[prefix - k]
    
    return count
```

### Why It Fails

```python
arr = [0, 0]
k = 0

Expected: 3 subarrays ([0], [0], [0,0])

With wrong order:
i=0, num=0:
  prefix = 0
  Update: hashmap[0] = 2  # {0: 2} now
  Check: 0-0=0 in map? YES
  count += 2  ‚úó (should be 1!)

We counted the element with itself!
```

### Detailed Trace

```
Correct order (check first):
Initial: map = {0: 1}

i=0, num=0:
  prefix = 0, target = 0
  Check: 0 in map? count += 1 ‚Üí count = 1 ‚úì
  Update: map = {0: 2}

i=1, num=0:
  prefix = 0, target = 0
  Check: 0 in map? count += 2 ‚Üí count = 3 ‚úì
  Update: map = {0: 3}

Result: 3 ‚úì

Wrong order (update first):
Initial: map = {0: 1}

i=0, num=0:
  prefix = 0
  Update: map = {0: 2}
  Check: 0 in map? count += 2 ‚Üí count = 2 ‚úó

Already wrong at first element!
```

### The Fix

```python
# ‚úÖ CORRECT - Check then update
for num in arr:
    prefix += num
    
    # 1. CHECK first
    if prefix - k in hashmap:
        count += hashmap[prefix - k]
    
    # 2. UPDATE second
    hashmap[prefix] = hashmap.get(prefix, 0) + 1
```

### When Order Doesn't Matter

```python
# For LENGTH problems, order matters less
# because we only store first occurrence

for i, num in enumerate(arr):
    prefix += num
    
    if prefix - k in hashmap:
        max_len = max(max_len, i - hashmap[prefix - k])
    
    # Store only if NEW
    if prefix not in hashmap:
        hashmap[prefix] = i
    # Order doesn't matter here because we check existence
```

---

## 7.5 Mistake #4: Not Handling Negative Remainders

### The Problem

```python
# ‚ùå WRONG - Direct modulo with negatives
def count_divisible(arr, k):
    hashmap = {0: 1}
    prefix = 0
    count = 0
    
    for num in arr:
        prefix += num
        remainder = prefix % k  # Problem with negatives!
        if remainder in hashmap:
            count += hashmap[remainder]
        hashmap[remainder] = hashmap.get(remainder, 0) + 1
    
    return count
```

### Why It Fails (Language-Dependent)

```python
# In Python: Actually works fine!
print(-5 % 3)  # Output: 1 (positive)

# In Java/C++/JavaScript:
# -5 % 3 = -2 (negative!)

# This causes issues:
# Remainder -2 and remainder 1 are treated differently
# But -2 ‚â° 1 (mod 3), they should be the same!
```

### Real Example

```python
arr = [5, -3, 2]
k = 3

Without fix:
i=0: prefix=5, rem=5%3=2, map={0:1, 2:1}
i=1: prefix=2, rem=2%3=2, found! count=1 ‚úì
i=2: prefix=4, rem=4%3=1, map={0:1, 2:2, 1:1}

With negatives:
arr = [-5, 3, 2]
k = 3

Without fix (in C++/Java):
i=0: prefix=-5, rem=-5%3=-2, map={0:1, -2:1}
i=1: prefix=-2, rem=-2%3=-2, found! count=1
i=2: prefix=0, rem=0%3=0, found! count=2

With fix:
i=0: prefix=-5, rem=(-5%3+3)%3=1, map={0:1, 1:1}
i=1: prefix=-2, rem=(-2%3+3)%3=1, found! count=1
i=2: prefix=0, rem=0, found! count=2

Still 2, but uses consistent remainders!
```

### The Fix

```python
# ‚úÖ CORRECT - Universal fix
remainder = (prefix % k + k) % k

# This works in ALL languages!
```

### Why The Fix Works

```
For any integer n and positive k:
  (n % k + k) % k gives a value in [0, k-1]

Examples:
  n = 7, k = 3
  (7 % 3 + 3) % 3 = (1 + 3) % 3 = 4 % 3 = 1 ‚úì

  n = -5, k = 3
  (-5 % 3 + 3) % 3 = (-2 + 3) % 3 = 1 % 3 = 1 ‚úì
  
Both give positive remainder in [0, k-1]!
```

---

## 7.6 Mistake #5: Off-by-One in Length Calculation

### The Problem

```python
# ‚ùå WRONG - Length calculation
def longest_sum(arr, k):
    hashmap = {0: -1}
    prefix = 0
    max_len = 0
    
    for i, num in enumerate(arr):
        prefix += num
        if prefix - k in hashmap:
            length = i - hashmap[prefix - k] - 1  # WRONG!
            max_len = max(max_len, length)
        if prefix not in hashmap:
            hashmap[prefix] = i
    
    return max_len
```

### Why It's Wrong

```
arr = [1, 2, 3]
k = 6

Trace:
i=0: prefix=1, map={0:-1, 1:0}
i=1: prefix=3, map={0:-1, 1:0, 3:1}
i=2: prefix=6, target=0
  0 in map at -1
  length = 2 - (-1) - 1 = 2  ‚úó
  
Correct: length should be 3 (entire array)
```

### The Correct Formula

```python
# ‚úÖ CORRECT
length = i - hashmap[prefix - k]

# NOT: i - hashmap[prefix - k] - 1
# NOT: i - hashmap[prefix - k] + 1
```

### Visual Proof

```
Index:    -1   0   1   2   3
Prefix:    0   1   3   6  10
Array:         [1   2   3   4]

To get sum = 6 (from index 0 to 2):
  Current: i = 2, prefix = 6
  Target: prefix - k = 0
  Found at: index = -1
  
  Length = 2 - (-1) = 3 ‚úì
  
This counts indices: 0, 1, 2 (three elements)
```

### Why {0: -1} Initialization

```
The -1 serves as a "virtual index before the array"

When subarray starts at index 0:
  length = current_index - (-1)
         = current_index + 1 ‚úì
  
This correctly gives length from 0 to current_index!
```

---

## 7.7 Mistake #6: Storing Wrong Value in HashMap

### The Problem

```python
# ‚ùå WRONG - Storing last occurrence for length problem
def longest_sum(arr, k):
    hashmap = {0: -1}
    prefix = 0
    max_len = 0
    
    for i, num in enumerate(arr):
        prefix += num
        if prefix - k in hashmap:
            max_len = max(max_len, i - hashmap[prefix - k])
        
        # WRONG - Always updates!
        hashmap[prefix] = i  # Overwrites earlier occurrence
    
    return max_len
```

### Why It Fails

```python
arr = [1, 0, 1]
k = 1

With wrong code:
i=0: prefix=1, map={0:-1, 1:0}
i=1: prefix=1, map={0:-1, 1:1}  # Overwrote!
i=2: prefix=2, target=1
     Found at index 1
     length = 2 - 1 = 1  ‚úó

Correct answer: 2 (subarray [1, 0])
```

### The Fix

```python
# ‚úÖ CORRECT - Store first occurrence only
for i, num in enumerate(arr):
    prefix += num
    
    if prefix - k in hashmap:
        max_len = max(max_len, i - hashmap[prefix - k])
    
    # Only store if NEW
    if prefix not in hashmap:
        hashmap[prefix] = i
```

### Value Storage Guide

| Problem Type | Store What | How |
|-------------|------------|-----|
| Count | Frequency | Always update |
| Longest | First index | Only if new |
| Shortest | Last index | Always update |
| All subarrays | List of indices | Append |
| Exists | Any (or True) | Once |

---

## 7.8 Mistake #7: Using Mutable Keys

### The Problem

```python
# ‚ùå WRONG - List as key
def track_state(s):
    hashmap = {}
    state = [0, 0, 0]  # List for character counts
    
    for char in s:
        state[ord(char) - ord('a')] += 1
        hashmap[state] = 1  # ERROR: unhashable type: 'list'
```

### Why It Fails

```
TypeError: unhashable type: 'list'

Lists are mutable ‚Üí can't be used as dictionary keys!
```

### The Fix

```python
# ‚úÖ CORRECT - Tuple as key
def track_state(s):
    hashmap = {}
    state = [0] * 26  # Mutable for easy updates
    
    for i, char in s:
        state[ord(char) - ord('a')] += 1
        
        # Convert to immutable tuple
        key = tuple(state)
        hashmap[key] = i
```

### Hashable vs Non-Hashable

```python
# ‚úÖ HASHABLE (can be keys)
hashmap[5] = "int"
hashmap[3.14] = "float"
hashmap["hello"] = "string"
hashmap[(1, 2, 3)] = "tuple"
hashmap[frozenset([1, 2])] = "frozenset"

# ‚ùå NON-HASHABLE (can't be keys)
hashmap[[1, 2, 3]] = "list"  # Error!
hashmap[{1, 2, 3}] = "set"  # Error!
hashmap[{"a": 1}] = "dict"  # Error!
```

---

## 7.9 Mistake #8: Not Considering All Elements

### The Problem

```python
# ‚ùå WRONG - Skipping elements
def count_sum(arr, k):
    hashmap = {0: 1}
    prefix = 0
    count = 0
    
    for num in arr:
        if num != 0:  # WRONG - Why skip zeros?
            prefix += num
            if prefix - k in hashmap:
                count += hashmap[prefix - k]
            hashmap[prefix] = hashmap.get(prefix, 0) + 1
    
    return count
```

### Why It's Wrong

```python
arr = [0, 5, 0, 5]
k = 5

Skipping zeros misses valid subarrays!
- [5] at index 1
- [5] at index 3
- [0, 5] at indices 0-1
- [5, 0] at indices 1-2
- [0, 5, 0] at indices 0-2
- etc.
```

### The Fix

```python
# ‚úÖ CORRECT - Process ALL elements
for num in arr:
    # No conditions - process everything
    prefix += num
    # ... rest of logic
```

---

## 7.10 Mistake #9: Modifying While Iterating

### The Problem

```python
# ‚ùå WRONG - Deleting while iterating
def clean_map(hashmap):
    for key in hashmap:
        if hashmap[key] == 0:
            del hashmap[key]  # RuntimeError!
```

### Why It Fails

```
RuntimeError: dictionary changed size during iteration

Can't modify dictionary while iterating over it!
```

### The Fix

```python
# ‚úÖ CORRECT - Iterate over copy
def clean_map(hashmap):
    for key in list(hashmap.keys()):
        if hashmap[key] == 0:
            del hashmap[key]

# Or: List comprehension
hashmap = {k: v for k, v in hashmap.items() if v != 0}
```

---

## 7.11 Mistake #10: Not Handling Empty Array

### The Problem

```python
# ‚ùå WRONG - No empty check
def count_sum(arr, k):
    hashmap = {0: 1}
    prefix = 0
    count = 0
    
    # What if arr is empty?
    for num in arr:  # Loop never executes
        prefix += num
        if prefix - k in hashmap:
            count += hashmap[prefix - k]
        hashmap[prefix] = hashmap.get(prefix, 0) + 1
    
    return count  # Returns 0, which is correct!
```

### Actually OK!

```python
# This actually works fine!
arr = []
result = count_sum(arr, 5)
print(result)  # 0 - correct!

# Empty loop ‚Üí count stays 0 ‚Üí correct answer
```

### When Edge Case Matters

```python
# Can add explicit check for clarity
def count_sum(arr, k):
    if not arr:  # Explicit empty check
        return 0
    
    # ... rest of code
```

---

## 7.12 Debugging Techniques

### Technique 1: Add Print Statements

```python
def debug_version(arr, k):
    hashmap = {0: 1}
    prefix = 0
    count = 0
    
    print(f"Input: arr={arr}, k={k}\n")
    print(f"Initial: map={hashmap}\n")
    
    for i, num in enumerate(arr):
        prefix += num
        target = prefix - k
        
        print(f"i={i}, num={num}")
        print(f"  prefix={prefix}, target={target}")
        
        if target in hashmap:
            print(f"  ‚úì Found! Adding {hashmap[target]}")
            count += hashmap[target]
        else:
            print(f"  ‚úó Not found")
        
        hashmap[prefix] = hashmap.get(prefix, 0) + 1
        print(f"  count={count}, map={dict(hashmap)}")
        print()
    
    return count
```

### Technique 2: Assert Invariants

```python
def with_assertions(arr, k):
    hashmap = {0: 1}
    prefix = 0
    count = 0
    
    for num in arr:
        prefix += num
        
        # Invariant: count should never decrease
        old_count = count
        
        if prefix - k in hashmap:
            count += hashmap[prefix - k]
        
        assert count >= old_count, "Count decreased!"
        
        hashmap[prefix] = hashmap.get(prefix, 0) + 1
        
        # Invariant: all values should be positive
        assert all(v > 0 for v in hashmap.values())
    
    return count
```

### Technique 3: Test Edge Cases

```python
def test_all_cases():
    test_cases = [
        # (arr, k, expected)
        ([], 0, 0),                    # Empty
        ([5], 5, 1),                   # Single match
        ([5], 3, 0),                   # Single no-match
        ([1, 1, 1], 2, 2),            # Multiple
        ([1, -1, 0], 0, 3),           # Negatives
        ([0, 0, 0], 0, 6),            # All zeros
        ([1, 2, 3], 10, 0),           # No match
    ]
    
    for arr, k, expected in test_cases:
        result = count_sum(arr, k)
        status = "‚úì" if result == expected else "‚úó"
        print(f"{status} arr={arr}, k={k}: {result} (expected {expected})")
```

---

## 7.13 Common Error Messages and Fixes

### KeyError: 0

```
KeyError: 0

Problem: Forgot to initialize hashmap
Fix: hashmap = {0: 1}  # or {0: -1}
```

### TypeError: unhashable type: 'list'

```
TypeError: unhashable type: 'list'

Problem: Using list as dictionary key
Fix: Convert to tuple: key = tuple(state)
```

### RuntimeError: dictionary changed size

```
RuntimeError: dictionary changed size during iteration

Problem: Modifying dict while iterating
Fix: Iterate over list(dict.keys())
```

---

## 7.14 Prevention Checklist

Before submitting your solution:

```
‚ñ° Initialized HashMap correctly? ({0: 1} or {0: -1})
‚ñ° Target formula correct? (prefix - k)
‚ñ° Correct order? (check before update for counting)
‚ñ° Handled negatives? ((x % k + k) % k)
‚ñ° Length calculation? (i - hashmap[target], no ¬±1)
‚ñ° Storing correct value? (frequency vs first index)
‚ñ° Immutable keys? (tuples, not lists)
‚ñ° All elements considered? (no skipping)
‚ñ° Tested edge cases? (empty, single, zeros, negatives)
‚ñ° No modifications during iteration?
```

---

## 7.15 Key Takeaways

üéØ **Top Mistakes:**
1. Wrong initialization
2. Backwards target calculation
3. Wrong update order
4. Negative remainders
5. Off-by-one in length

üîë **Quick Fixes:**
- Always: `hashmap = {0: 1}` or `{0: -1}`
- Always: `target = prefix - k`
- Count: check before update
- Length: store first only
- Modulo: `(x % k + k) % k`

üí° **Debug Strategy:**
1. Add print statements
2. Test edge cases
3. Check invariants
4. Trace small example

‚ö†Ô∏è **Watch Out:**
- Mutable keys (use tuples!)
- Modifying during iteration
- Language-specific modulo behavior

üöÄ **Practice:** Make these mistakes once, learn from them forever!