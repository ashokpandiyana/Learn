# Prefix Sum + HashMap: Complete Mastery Guide

## Chapter 1: Foundations

### 1.1 Prefix Sum Basics

#### What is a Prefix Sum?
A prefix sum (or cumulative sum) is the running total of elements from the start of an array up to a given index.

**Formula:** `prefix[i] = arr[0] + arr[1] + ... + arr[i]`

#### Key Properties
- **Range Sum in O(1):** `sum(i, j) = prefix[j] - prefix[i-1]`
- **Space Complexity:** O(n) for storing prefix array
- **Time Complexity:** O(n) to build, O(1) to query

#### Important Notes
âš ï¸ **Index Management:** Always be careful with 0-indexing vs 1-indexing
âš ï¸ **Off-by-One Errors:** Common when calculating `prefix[j] - prefix[i-1]`
ğŸ’¡ **Tip:** Consider using `prefix[0] = 0` to avoid edge cases

---

## Chapter 2: HashMap Fundamentals

### 2.1 HashMap for Frequency Counting

#### Core Concept
Store value-to-frequency or value-to-index mappings for O(1) lookups.

#### Common Patterns
- **Frequency Map:** `map[value] = count`
- **Index Map:** `map[value] = index`
- **State Map:** `map[state] = count/index`

#### Important Notes
ğŸ’¡ **Initialization:** Consider initializing with `map[0] = 1` or `map[0] = -1` for prefix sum problems
âš ï¸ **Key Selection:** The key should represent the state you want to look up later

---

## Chapter 3: Combining Prefix Sum + HashMap

### 3.1 The Core Pattern

#### Problem Template
Find subarrays/substrings that satisfy a condition based on cumulative properties.

#### Standard Approach
```
1. Calculate running prefix sum
2. Store prefix sum in hashmap
3. Check if (current_prefix - target) exists in map
4. Update result and hashmap
```

#### Why This Works
If `prefix[j] - prefix[i] = target`, then subarray from `i+1` to `j` sums to target.

#### Important Notes
ğŸ”‘ **Key Insight:** We're looking for `prefix[i] = prefix[j] - target`
âš ï¸ **Order Matters:** Always check map before updating it (for count problems)
ğŸ’¡ **Initial State:** Initialize `map[0] = 1` for count problems, `map[0] = -1` for length problems

---

## Chapter 4: Pattern Categories

### 4.1 Subarray Sum Equals K

#### Problem Type
Count/find subarrays with sum equal to a target value.

#### Solution Pattern
```
hashmap[0] = 1  # Base case
prefix_sum = 0
result = 0

for each element:
    prefix_sum += element
    if (prefix_sum - k) in hashmap:
        result += hashmap[prefix_sum - k]
    hashmap[prefix_sum] += 1
```

#### Variations
- Find count of subarrays
- Find longest subarray
- Find if such subarray exists

#### Important Notes
âš ï¸ **Why map[0]=1?** Handles subarrays starting from index 0
ğŸ”‘ **Order:** Check before update to avoid counting same element twice

---

### 4.2 Subarray Sum Divisible by K

#### Problem Type
Count subarrays where sum is divisible by K (sum % K == 0).

#### Key Insight
If `(prefix[j] - prefix[i]) % K == 0`, then `prefix[j] % K == prefix[i] % K`

#### Solution Pattern
```
hashmap[0] = 1  # Remainder 0
prefix_sum = 0
result = 0

for each element:
    prefix_sum += element
    remainder = prefix_sum % k
    
    # Handle negative remainders
    remainder = (remainder + k) % k
    
    if remainder in hashmap:
        result += hashmap[remainder]
    hashmap[remainder] += 1
```

#### Important Notes
âš ï¸ **Negative Remainders:** In many languages, `-5 % 3 = -2`, not `1`. Use `(remainder + k) % k`
ğŸ”‘ **Same Remainder:** Two positions with same remainder difference is divisible by K
ğŸ’¡ **Alternative:** Store `prefix_sum % k` directly as key

---

### 4.3 Binary Array Problems (0s and 1s)

#### Problem Type
Find longest subarray with equal 0s and 1s.

#### Transformation
Treat 0 as -1, problem becomes "longest subarray with sum 0".

#### Solution Pattern
```
hashmap[0] = -1  # For subarrays starting at index 0
prefix_sum = 0
max_length = 0

for i, element in enumerate(array):
    prefix_sum += (1 if element == 1 else -1)
    
    if prefix_sum in hashmap:
        max_length = max(max_length, i - hashmap[prefix_sum])
    else:
        hashmap[prefix_sum] = i  # Store first occurrence
```

#### Important Notes
ğŸ”‘ **Key Transformation:** Convert binary to +1/-1 problem
âš ï¸ **First Occurrence:** For longest subarray, store first occurrence only
ğŸ’¡ **Why map[0]=-1?** So subarray from index 0 to i has length `i - (-1) = i + 1`

---

### 4.4 Multi-Dimensional Prefix Sum

#### Problem Type
2D matrix range sum queries or counting.

#### Approach
Build 2D prefix sum, use hashmap for state tracking in one dimension.

#### Important Notes
ğŸ’¡ **Reduce Dimensions:** Often reduce 2D to 1D using column/row iteration
âš ï¸ **Space:** 2D prefix requires O(mÃ—n) space
ğŸ”‘ **Pattern:** Fix two rows, use 1D prefix sum + hashmap on columns

---

### 4.5 String/Character Array Problems

#### Problem Type
Subarrays with equal character counts, anagram matching.

#### Key Insight
Use character frequency difference as state.

#### Solution Pattern
```
hashmap[tuple of counts] = index/count
state = [0] * 26  # For lowercase letters

for i, char:
    state[char - 'a'] += 1
    state_key = tuple(state)
    
    # Use state_key for lookups
```

#### Important Notes
ğŸ’¡ **Relative Counts:** Store difference counts, not absolute
ğŸ”‘ **Hash Key:** Use tuple or string representation of state
âš ï¸ **Space:** State size depends on character set (26 for lowercase)

---

## Chapter 5: Advanced Techniques

### 5.1 Multiple Conditions

#### Technique
Combine multiple constraints using composite keys or multiple passes.

#### Pattern
```
state = (prefix_sum % k1, prefix_sum % k2, custom_condition)
hashmap[state] = count/index
```

#### Important Notes
ğŸ’¡ **Composite Keys:** Tuple or concatenated string keys
âš ï¸ **Complexity:** More dimensions = more space

---

### 5.2 Sliding Window + Prefix + HashMap

#### When to Use
Variable-size windows with cumulative property constraints.

#### Pattern
```
Use hashmap to track valid states within sliding window
Remove old states as window slides
```

#### Important Notes
ğŸ”‘ **Combination:** Sliding window for optimization, hashmap for state tracking
ğŸ’¡ **When:** Problems with "at most K" or "minimum length" constraints

---

### 5.3 Handling Negative Numbers

#### Challenges
- Negative prefix sums
- Negative remainders
- Order-dependent results

#### Important Notes
âš ï¸ **Modulo:** Always normalize: `(x % k + k) % k`
ğŸ’¡ **Careful:** Check if greedy optimizations still work with negatives

---

### 5.4 XOR Prefix Sum

#### Problem Type
Subarrays with XOR equal to K.

#### Key Property
`a ^ a = 0`, so `prefix_xor[j] ^ prefix_xor[i] = k` means `prefix_xor[i] = prefix_xor[j] ^ k`

#### Solution Pattern
```
hashmap[0] = 1
prefix_xor = 0

for element:
    prefix_xor ^= element
    target = prefix_xor ^ k
    result += hashmap.get(target, 0)
    hashmap[prefix_xor] += 1
```

#### Important Notes
ğŸ”‘ **XOR Property:** Self-inverse operation
ğŸ’¡ **Similar Pattern:** Same structure as sum problems

---

## Chapter 6: Problem-Solving Framework

### 6.1 Identification Checklist

âœ… **Use Prefix + HashMap when:**
- Need to find subarrays/substrings satisfying conditions
- Condition involves cumulative property (sum, XOR, product)
- Need O(n) time complexity
- Counting or finding specific ranges

âŒ **Don't use when:**
- Need to maintain actual elements (use sliding window)
- Problem requires sorting subarrays
- Need to minimize/maximize with greedy approach

---

### 6.2 Step-by-Step Approach

#### Step 1: Identify the Pattern
- Is it about subarrays/substrings?
- Is there a cumulative property?
- What are we counting/finding?

#### Step 2: Define State
- What should prefix sum represent?
- What should hashmap key be?
- What should hashmap value be?

#### Step 3: Handle Edge Cases
- Empty subarray (map[0])
- Single element
- All elements satisfy/don't satisfy

#### Step 4: Determine Order
- Count problems: check then update
- Length problems: update only first occurrence
- Existence problems: check existence

#### Step 5: Code Pattern
```python
# Template
hashmap = {0: initial_value}
prefix = 0
result = 0/[]

for i, element in enumerate(array):
    # Update prefix
    prefix += transform(element)
    
    # Calculate target to look for
    target = prefix - k  # or other formula
    
    # Check hashmap
    if target in hashmap:
        # Update result
        result += hashmap[target]
    
    # Update hashmap
    hashmap[prefix] = value
```

---

## Chapter 7: Common Pitfalls and Debugging

### 7.1 Index Confusion

âŒ **Wrong:** `length = j - i`  
âœ… **Right:** `length = j - i + 1` (for inclusive range)

âŒ **Wrong:** `map[0] = 0` for length problems  
âœ… **Right:** `map[0] = -1` for length problems

---

### 7.2 Update Order

âŒ **Wrong:** Update map before checking (in count problems)  
âœ… **Right:** Check map first, then update

#### Why?
Prevents counting the same element as part of its own subarray.

---

### 7.3 Modulo Handling

âŒ **Wrong:** `prefix_sum % k` (with negative numbers)  
âœ… **Right:** `(prefix_sum % k + k) % k`

---

### 7.4 HashMap Value Selection

- **Count problems:** Store frequency
- **Length problems:** Store first index only
- **Multiple subarrays:** Store list of indices

---

## Chapter 8: Complexity Analysis

### 8.1 Time Complexity

**Standard:** O(n)
- One pass through array: O(n)
- HashMap operations: O(1) average
- Total: O(n)

**With sorting:** O(n log n)

---

### 8.2 Space Complexity

**Worst Case:** O(n)
- Hashmap can store up to n entries
- Prefix array (if stored): O(n)

**Optimization:** O(min(n, k)) for modulo problems

---

## Chapter 9: Practice Problem Categories

### 9.1 Beginner Level
- [ ] Subarray Sum Equals K
- [ ] Contiguous Array (equal 0s and 1s)
- [ ] Find Pivot Index
- [ ] Subarray Sum Divisible by K

### 9.2 Intermediate Level
- [ ] Longest Subarray with Sum K
- [ ] Count Subarrays with Score Less Than K
- [ ] Maximum Size Subarray Sum Equals K
- [ ] Subarray Sums Divisible by K (with negatives)

### 9.3 Advanced Level
- [ ] Subarray with Elements Greater Than Varying Threshold
- [ ] Count Subarrays with XOR K
- [ ] Count Nice Subarrays (at most K odd numbers)
- [ ] Subarrays with K Different Integers

### 9.4 Expert Level
- [ ] Count Submatrices with Sum Target (2D)
- [ ] Make Sum Divisible by P (with deletions)
- [ ] Number of Subarrays with Bounded Maximum
- [ ] Count Vowel Strings in Ranges (with constraints)

---

## Chapter 10: Optimization Techniques

### 10.1 Space Optimization

ğŸ’¡ **Rolling Hash:** For string problems, use rolling hash to avoid storing entire state
ğŸ’¡ **Bit Manipulation:** For boolean states, use bitmask instead of tuples
ğŸ’¡ **Array Instead of Hash:** If range is small (â‰¤ 10^4), use array for O(1) guaranteed

---

### 10.2 Time Optimization

ğŸ’¡ **Early Termination:** Return immediately when condition is met
ğŸ’¡ **Avoid Recomputation:** Cache intermediate results
ğŸ’¡ **Choose Right Data Structure:** Consider sorted containers when range matters

---

## Chapter 11: Key Takeaways

### ğŸ¯ Core Principles

1. **Prefix sum converts range problems to point problems**
2. **HashMap enables O(1) lookup of previous states**
3. **The key insight: `prefix[j] - prefix[i] = target` becomes `prefix[i] = prefix[j] - target`**
4. **Order matters: check before update for counting**
5. **Edge cases: always handle map[0] initialization**

### ğŸ”‘ Pattern Recognition

- Subarray/substring â†’ Prefix Sum
- "Equal to K" â†’ HashMap lookup
- "Divisible by K" â†’ Store remainders
- "Equal 0s and 1s" â†’ Transform to sum = 0
- "XOR = K" â†’ XOR prefix sum

### âš ï¸ Common Mistakes to Avoid

1. Forgetting to handle negative remainders
2. Wrong map initialization
3. Off-by-one errors in length calculation
4. Updating map before checking
5. Not considering empty subarray case

---

## Appendix: Quick Reference

### Problem Type Decision Tree

```
Is it about subarrays/substrings? 
â”œâ”€ Yes: Does it involve cumulative property?
â”‚  â”œâ”€ Yes: Can you check in O(1)?
â”‚  â”‚  â”œâ”€ Yes: Use Prefix Sum + HashMap âœ“
â”‚  â”‚  â””â”€ No: Consider other approaches
â”‚  â””â”€ No: Consider sliding window
â””â”€ No: Different pattern needed
```

### Common Transformations

| Problem Type | Key Transformation |
|--------------|-------------------|
| Sum = K | `target = prefix - k` |
| Sum divisible by K | `key = prefix % k` |
| Equal 0s and 1s | Treat 0 as -1 |
| XOR = K | `target = prefix ^ k` |
| Product = K | Use log sums |

---

**Remember:** Master the basics, recognize the patterns, practice extensively! ğŸš€