# Chapter 5: Advanced Techniques - Deep Dive

## 5.1 Multiple Conditions with Composite Keys

### The Challenge

Sometimes we need to track multiple properties simultaneously:
- Sum divisible by Kâ‚ AND Kâ‚‚
- Character count AND vowel count
- Multiple independent constraints

### Solution: Composite Keys

Use tuples or combined states as HashMap keys.

### Example: Divisible by Multiple Numbers

```python
def count_divisible_by_both(arr, k1, k2):
    """
    Count subarrays where sum is divisible by BOTH k1 and k2.
    
    Key insight: Store (remainder1, remainder2) as composite key.
    Time: O(n), Space: O(k1 Ã— k2)
    """
    hashmap = {(0, 0): 1}  # (rem1, rem2) -> count
    prefix_sum = 0
    count = 0
    
    for num in arr:
        prefix_sum += num
        
        # Calculate both remainders
        rem1 = (prefix_sum % k1 + k1) % k1
        rem2 = (prefix_sum % k2 + k2) % k2
        
        # Composite key
        state = (rem1, rem2)
        
        if state in hashmap:
            count += hashmap[state]
        
        hashmap[state] = hashmap.get(state, 0) + 1
    
    return count

# Example: divisible by both 3 and 5 (i.e., divisible by 15)
arr = [15, 3, 5, 15, 0]
print(count_divisible_by_both(arr, 3, 5))  # Should match divisible by 15
```

### Detailed Example

```
Array: [6, 3, 9], k1=3, k2=2
Find subarrays divisible by both 3 and 2 (i.e., divisible by 6)

Initial: map = {(0,0): 1}, prefix = 0, count = 0

i=0, num=6:
  prefix = 6
  rem1 = 6 % 3 = 0
  rem2 = 6 % 2 = 0
  state = (0, 0)
  (0,0) in map! count = 1 âœ“ (subarray [6])
  map = {(0,0): 2}

i=1, num=3:
  prefix = 9
  rem1 = 9 % 3 = 0
  rem2 = 9 % 2 = 1
  state = (0, 1)
  (0,1) not in map
  map = {(0,0): 2, (0,1): 1}

i=2, num=9:
  prefix = 18
  rem1 = 18 % 3 = 0
  rem2 = 18 % 2 = 0
  state = (0, 0)
  (0,0) in map! count += 2 (found [6,3,9] and [9])
  count = 3

Answer: 3 subarrays with sum divisible by 6
```

### Multi-Property Character Counting

```python
def longest_balanced_substring(s):
    """
    Find longest substring where:
    - Number of vowels = number of consonants
    - Each vowel appears even times
    
    Uses composite state tracking.
    """
    # State: (vowel_consonant_diff, vowel_counts_tuple)
    hashmap = {(0, tuple([0]*5)): -1}  # For 'aeiou'
    
    vowel_map = {'a': 0, 'e': 1, 'i': 2, 'o': 3, 'u': 4}
    vowel_counts = [0] * 5
    diff = 0  # vowels - consonants
    max_len = 0
    
    for i, char in enumerate(s):
        if char in vowel_map:
            vowel_counts[vowel_map[char]] += 1
            diff += 1
        else:
            diff -= 1
        
        # Create composite state
        state = (diff, tuple(c % 2 for c in vowel_counts))
        
        if state in hashmap:
            max_len = max(max_len, i - hashmap[state])
        else:
            hashmap[state] = i
    
    return max_len

# Example
print(longest_balanced_substring("aabbccdd"))
```

---

## 5.2 Sliding Window + Prefix Sum + HashMap

### When to Combine These Techniques

**Sliding Window:** For "at most K" or variable-size windows
**Prefix Sum + HashMap:** For tracking cumulative properties
**Combined:** Complex constraints with both aspects

### Example: Subarrays with Sum â‰¤ K

```python
def count_subarrays_sum_at_most_k(arr, k):
    """
    Count subarrays where sum â‰¤ k.
    
    Can't use standard prefix+HashMap directly!
    Use sliding window approach instead.
    """
    count = 0
    current_sum = 0
    left = 0
    
    for right in range(len(arr)):
        current_sum += arr[right]
        
        # Shrink window while sum > k
        while left <= right and current_sum > k:
            current_sum -= arr[left]
            left += 1
        
        # All subarrays ending at right with start in [left, right]
        count += right - left + 1
    
    return count

# Example
print(count_subarrays_sum_at_most_k([1, 2, 3], 3))  # 4
# Subarrays: [1], [2], [3], [1,2]
```

### Advanced: "At Most K" - "At Most K-1"

For "exactly K" problems when dealing with "at most":

```python
def count_subarrays_sum_exactly_k_non_negative(arr, k):
    """
    For arrays with non-negative numbers only.
    Count subarrays with sum exactly k.
    
    Trick: exactly_k = at_most_k - at_most_(k-1)
    """
    def at_most(target):
        if target < 0:
            return 0
        count = 0
        current_sum = 0
        left = 0
        for right in range(len(arr)):
            current_sum += arr[right]
            while current_sum > target:
                current_sum -= arr[left]
                left += 1
            count += right - left + 1
        return count
    
    return at_most(k) - at_most(k - 1)

# Only works with non-negative numbers!
print(count_subarrays_sum_exactly_k_non_negative([1, 2, 3], 3))
```

---

## 5.3 Handling Negative Numbers

### The Good News

Prefix Sum + HashMap naturally handles negative numbers!

### Why Other Techniques Fail

```python
# Sliding Window FAILS with negatives
arr = [1, -1, 5, -2, 3]
k = 3

# Window [1, -1, 5] has sum = 5
# Adding next element: [1, -1, 5, -2] has sum = 3
# But we can't assume sum only increases!
```

### Prefix Sum + HashMap Still Works

```python
def works_with_negatives(arr, k):
    """
    Standard prefix sum + HashMap works perfectly!
    """
    hashmap = {0: 1}
    prefix = 0
    count = 0
    
    for num in arr:
        prefix += num
        if prefix - k in hashmap:
            count += hashmap[prefix - k]
        hashmap[prefix] = hashmap.get(prefix, 0) + 1
    
    return count

# Works perfectly
arr = [1, -1, 5, -2, 3]
k = 3
print(works_with_negatives(arr, k))  # Counts correctly!
```

### Important Notes

âš ï¸ **Sliding window** doesn't work with negatives (sum can decrease)
âœ… **Prefix sum + HashMap** works with any integers
âœ… **Modulo problems** need careful handling: `(x % k + k) % k`

---

## 5.4 XOR Prefix Sum - Advanced

### XOR Prefix with Range Queries

```python
class XORQueries:
    """
    Handle multiple XOR range queries efficiently.
    """
    def __init__(self, arr):
        n = len(arr)
        self.prefix_xor = [0] * (n + 1)
        
        # Build prefix XOR
        for i in range(n):
            self.prefix_xor[i + 1] = self.prefix_xor[i] ^ arr[i]
    
    def query(self, left, right):
        """Get XOR of elements from left to right (inclusive)."""
        return self.prefix_xor[right + 1] ^ self.prefix_xor[left]

# Example
arr = [1, 3, 4, 8]
xor_q = XORQueries(arr)
print(xor_q.query(0, 1))  # 1 ^ 3 = 2
print(xor_q.query(1, 3))  # 3 ^ 4 ^ 8 = 15
```

### Maximum XOR Subarray

```python
def max_xor_subarray(arr):
    """
    Find maximum XOR of any subarray.
    
    Uses Trie for efficient XOR maximization.
    Time: O(n Ã— 32) for 32-bit integers
    """
    class TrieNode:
        def __init__(self):
            self.children = {}
    
    def insert(root, num):
        node = root
        for i in range(31, -1, -1):
            bit = (num >> i) & 1
            if bit not in node.children:
                node.children[bit] = TrieNode()
            node = node.children[bit]
    
    def max_xor(root, num):
        node = root
        result = 0
        for i in range(31, -1, -1):
            bit = (num >> i) & 1
            # Try to go opposite direction for max XOR
            toggle = 1 - bit
            if toggle in node.children:
                result |= (1 << i)
                node = node.children[toggle]
            else:
                node = node.children[bit]
        return result
    
    root = TrieNode()
    insert(root, 0)
    
    max_xor_value = 0
    prefix_xor = 0
    
    for num in arr:
        prefix_xor ^= num
        insert(root, prefix_xor)
        max_xor_value = max(max_xor_value, max_xor(root, prefix_xor))
    
    return max_xor_value

# Example
print(max_xor_subarray([8, 1, 2, 12]))  # 15
```

---

## 5.5 Optimization: Space Reduction

### When HashMap Size Can Be Reduced

For modulo problems, HashMap size is at most K (number of possible remainders).

```python
def optimized_divisible_k(arr, k):
    """
    Space: O(min(n, k)) instead of O(n)
    """
    remainder_count = {}
    remainder_count[0] = 1
    prefix_sum = 0
    count = 0
    
    for num in arr:
        prefix_sum += num
        remainder = (prefix_sum % k + k) % k
        
        if remainder in remainder_count:
            count += remainder_count[remainder]
        
        remainder_count[remainder] = remainder_count.get(remainder, 0) + 1
    
    return count
```

### Using Array Instead of HashMap

When keys are small integers (0 to K):

```python
def optimized_with_array(arr, k):
    """
    Use array instead of HashMap for better performance.
    Only works when remainders are 0 to k-1.
    """
    remainder_count = [0] * k
    remainder_count[0] = 1
    prefix_sum = 0
    count = 0
    
    for num in arr:
        prefix_sum += num
        remainder = (prefix_sum % k + k) % k
        count += remainder_count[remainder]
        remainder_count[remainder] += 1
    
    return count

# Faster for small k!
```

---

## 5.6 Advanced Problem: Maximum Sum with Conditions

### Problem: Maximum Subarray Sum with Sum Divisible by K

```python
def max_sum_divisible_k(arr, k):
    """
    Find maximum subarray sum that is divisible by k.
    
    Track: remainder -> maximum prefix sum with that remainder
    Time: O(n), Space: O(k)
    """
    # remainder -> max prefix sum
    max_prefix_with_remainder = {0: 0}
    prefix_sum = 0
    max_sum = float('-inf')
    
    for num in arr:
        prefix_sum += num
        remainder = (prefix_sum % k + k) % k
        
        # Check all possible previous remainders
        target_remainder = remainder
        if target_remainder in max_prefix_with_remainder:
            subarray_sum = prefix_sum - max_prefix_with_remainder[target_remainder]
            if subarray_sum % k == 0:
                max_sum = max(max_sum, subarray_sum)
        
        # Update max prefix for this remainder
        if remainder not in max_prefix_with_remainder:
            max_prefix_with_remainder[remainder] = prefix_sum
        else:
            max_prefix_with_remainder[remainder] = min(
                max_prefix_with_remainder[remainder], 
                prefix_sum
            )
    
    return max_sum if max_sum != float('-inf') else 0

# Example
arr = [3, -2, 1, 4]
k = 3
print(max_sum_divisible_k(arr, k))  # 6: [3, -2, 1, 4] sum = 6
```

---

## 5.7 Combining with Other Data Structures

### Using TreeMap/Sorted Dict for Range Queries

```python
from sortedcontainers import SortedDict

def count_subarrays_sum_in_range(arr, min_sum, max_sum):
    """
    Count subarrays where min_sum <= sum <= max_sum.
    
    Uses sorted dictionary to find range of prefix sums.
    Time: O(n log n)
    """
    sorted_prefix = SortedDict({0: 1})
    prefix_sum = 0
    count = 0
    
    for num in arr:
        prefix_sum += num
        
        # Find prefix sums in range [prefix-max, prefix-min]
        lower = prefix_sum - max_sum
        upper = prefix_sum - min_sum
        
        # Count prefixes in range
        for key in sorted_prefix.irange(lower, upper):
            count += sorted_prefix[key]
        
        sorted_prefix[prefix_sum] = sorted_prefix.get(prefix_sum, 0) + 1
    
    return count

# Requires: pip install sortedcontainers
```

---

## 5.8 Pattern: Prefix Product with HashMap

### Handling Products

```python
def subarray_product_equals_k(arr, k):
    """
    Count subarrays with product equal to k.
    
    Challenge: Products grow very large!
    Solution: Use logarithms or handle carefully.
    
    Note: This only works for positive numbers!
    """
    if k == 0:
        # Special case: count subarrays containing 0
        return count_subarrays_with_zero(arr)
    
    import math
    hashmap = {0.0: 1}  # log_product -> count
    log_k = math.log(k)
    log_product = 0.0
    count = 0
    epsilon = 1e-9
    
    for num in arr:
        if num <= 0:
            # Can't use log with non-positive
            continue
        
        log_product += math.log(num)
        target = log_product - log_k
        
        # Check with tolerance for floating point
        for key in hashmap:
            if abs(key - target) < epsilon:
                count += hashmap[key]
                break
        
        # Round for storage
        key = round(log_product, 9)
        hashmap[key] = hashmap.get(key, 0) + 1
    
    return count
```

**Note:** Product problems are tricky! Prefer using logs or alternative approaches.

---

## 5.9 Advanced: Persistent HashMap States

### Problem: Queries on Prefix Sum at Different Points

```python
class PrefixSumQueries:
    """
    Handle queries about subarrays efficiently.
    Build complete prefix structure once.
    """
    def __init__(self, arr):
        self.arr = arr
        n = len(arr)
        
        # Build prefix sum
        self.prefix = [0] * (n + 1)
        for i in range(n):
            self.prefix[i + 1] = self.prefix[i] + arr[i]
        
        # Build prefix HashMap states at each position
        self.states = []
        hashmap = {0: 1}
        prefix_sum = 0
        
        for i, num in enumerate(arr):
            prefix_sum += num
            hashmap[prefix_sum] = hashmap.get(prefix_sum, 0) + 1
            self.states.append(dict(hashmap))  # Save state
    
    def count_subarrays_up_to_index(self, end_index, k):
        """Count subarrays ending at or before end_index with sum k."""
        if end_index < 0:
            return 0
        
        state = self.states[end_index]
        count = 0
        
        for prefix_sum, freq in state.items():
            if prefix_sum - k in state:
                # This is simplified; actual implementation more complex
                pass
        
        return count

# More complex implementation needed for real use
```

---

## 5.10 Practical Optimization Tips

### Tip 1: Use defaultdict for Cleaner Code

```python
from collections import defaultdict

def clean_code(arr, k):
    hashmap = defaultdict(int)
    hashmap[0] = 1
    prefix = 0
    count = 0
    
    for num in arr:
        prefix += num
        count += hashmap[prefix - k]
        hashmap[prefix] += 1  # No need for get()!
    
    return count
```

### Tip 2: Early Termination

```python
def exists_subarray_sum_k(arr, k):
    """
    Stop as soon as we find one.
    """
    hashmap = {0: 1}
    prefix = 0
    
    for num in arr:
        prefix += num
        if prefix - k in hashmap:
            return True  # Early exit!
        hashmap[prefix] = 1
    
    return False
```

### Tip 3: Avoid Unnecessary Copies

```python
# Bad: Creates new dict every time
for i in range(n):
    new_map = dict(hashmap)  # Expensive!

# Good: Modify in place
for i in range(n):
    hashmap[key] = value
```

---

## 5.11 Debugging Complex Cases

### Debug Template

```python
def debug_version(arr, k):
    """
    Add extensive logging for debugging.
    """
    hashmap = {0: 1}
    prefix = 0
    count = 0
    
    print(f"Array: {arr}, Target: {k}\n")
    
    for i, num in enumerate(arr):
        prefix += num
        target = prefix - k
        
        found = hashmap.get(target, 0)
        count += found
        
        hashmap[prefix] = hashmap.get(prefix, 0) + 1
        
        print(f"i={i}, num={num}")
        print(f"  prefix={prefix}, target={target}")
        print(f"  found={found}, count={count}")
        print(f"  map={dict(hashmap)}")
        print()
    
    return count
```

---

## 5.12 Key Takeaways

ðŸŽ¯ **Composite Keys:** Use tuples for multiple conditions

ðŸ’¡ **Optimization:** Array instead of HashMap for small key ranges

âš ï¸ **Negatives:** Prefix+HashMap works, sliding window doesn't

ðŸ”‘ **XOR Advanced:** Consider Trie for maximum XOR problems

ðŸš€ **Space:** O(min(n, k)) for modulo problems

ðŸ“Š **Products:** Use logarithms carefully (positive numbers only)

**Practice these advanced patterns to master hard interview questions!**