# Chapter 4: Pattern Categories - Deep Dive

## 4.1 Pattern Category: Subarray Sum Equals K

### Problem Variations

1. **Count** subarrays with sum = K
2. **Find length** of longest subarray with sum = K
3. **Check existence** of subarray with sum = K
4. **Find all** subarrays with sum = K

### Complete Implementation: Count Version

```python
def count_subarrays_sum_k(arr, k):
    """
    Count number of subarrays with sum equal to k.
    Works with positive, negative, and zero values!
    
    Time: O(n), Space: O(n)
    """
    hashmap = {0: 1}  # Base case
    prefix_sum = 0
    count = 0
    
    for num in arr:
        prefix_sum += num
        
        # Looking for: prefix[i] = prefix[j] - k
        target = prefix_sum - k
        
        if target in hashmap:
            count += hashmap[target]
        
        hashmap[prefix_sum] = hashmap.get(prefix_sum, 0) + 1
    
    return count

# Test cases
print(count_subarrays_sum_k([1, 1, 1], 2))        # 2
print(count_subarrays_sum_k([1, 2, 3], 3))        # 2
print(count_subarrays_sum_k([1, -1, 0], 0))       # 3
print(count_subarrays_sum_k([3, 4, 7, 2, -3, 1, 4, 2], 7))  # 4
```

### Detailed Example Walkthrough

```
Array: [3, 4, 7, 2, -3, 1, 4, 2]
Target: k = 7

Step-by-step execution:

Initial: map = {0: 1}, prefix = 0, count = 0

i=0, num=3:
  prefix = 3, target = 3-7 = -4
  -4 not in map
  map = {0:1, 3:1}, count = 0

i=1, num=4:
  prefix = 7, target = 7-7 = 0
  0 in map! count += 1 (found [3,4])
  map = {0:1, 3:1, 7:1}, count = 1

i=2, num=7:
  prefix = 14, target = 14-7 = 7
  7 in map! count += 1 (found [7])
  map = {0:1, 3:1, 7:1, 14:1}, count = 2

i=3, num=2:
  prefix = 16, target = 16-7 = 9
  9 not in map
  map = {0:1, 3:1, 7:1, 14:1, 16:1}, count = 2

i=4, num=-3:
  prefix = 13, target = 13-7 = 6
  6 not in map
  map = {..., 13:1}, count = 2

i=5, num=1:
  prefix = 14, target = 14-7 = 7
  7 in map! count += 1 (found [2,-3,1])
  map = {..., 14:2}, count = 3
  Note: 14 appears twice now!

i=6, num=4:
  prefix = 18, target = 18-7 = 11
  11 not in map
  map = {..., 18:1}, count = 3

i=7, num=2:
  prefix = 20, target = 20-7 = 13
  13 in map! count += 1 (found [1,4,2])
  count = 4

Answer: 4 subarrays with sum 7
```

### Variation: Longest Subarray

```python
def longest_subarray_sum_k(arr, k):
    """
    Find LENGTH of longest subarray with sum = k.
    """
    hashmap = {0: -1}  # prefix_sum -> first_index
    prefix_sum = 0
    max_len = 0
    
    for i, num in enumerate(arr):
        prefix_sum += num
        target = prefix_sum - k
        
        if target in hashmap:
            length = i - hashmap[target]
            max_len = max(max_len, length)
        
        # Only store FIRST occurrence
        if prefix_sum not in hashmap:
            hashmap[prefix_sum] = i
    
    return max_len

# Example
arr = [1, -1, 5, -2, 3]
k = 3
print(longest_subarray_sum_k(arr, k))  # 4: [1,-1,5,-2]
```

---

## 4.2 Pattern Category: Subarray Sum Divisible by K

### The Key Insight

If `(prefix[j] - prefix[i]) % K == 0`, then `prefix[j] % K == prefix[i] % K`

**Translation:** Two positions with the same remainder have a difference divisible by K!

### Why This Works

```
Example: K = 3
prefix[5] = 11  â†’ 11 % 3 = 2
prefix[2] = 5   â†’ 5 % 3 = 2

Same remainder!

Difference: 11 - 5 = 6
Is 6 divisible by 3? YES! 6 % 3 = 0 âœ“
```

### Complete Implementation

```python
def count_subarrays_divisible_k(arr, k):
    """
    Count subarrays with sum divisible by k.
    
    Key insight: Store remainders instead of actual sums!
    Time: O(n), Space: O(k) - at most k different remainders
    """
    hashmap = {0: 1}  # remainder -> count
    prefix_sum = 0
    count = 0
    
    for num in arr:
        prefix_sum += num
        
        # Calculate remainder
        remainder = prefix_sum % k
        
        # CRITICAL: Handle negative remainders
        # In Python: -5 % 3 = 1 (already positive)
        # In Java/C++: -5 % 3 = -2 (need to fix)
        remainder = (remainder + k) % k
        
        # Check if we've seen this remainder before
        if remainder in hashmap:
            count += hashmap[remainder]
        
        hashmap[remainder] = hashmap.get(remainder, 0) + 1
    
    return count

# Test cases
print(count_subarrays_divisible_k([4, 5, 0, -2, -3, 1], 5))  # 7
print(count_subarrays_divisible_k([5], 9))                   # 0
```

### Detailed Example

```
Array: [4, 5, 0, -2, -3, 1]
K = 5

We want subarrays where sum % 5 = 0

Initial: map = {0: 1}, prefix = 0, count = 0

i=0, num=4:
  prefix = 4
  remainder = 4 % 5 = 4
  4 not in map yet
  map = {0:1, 4:1}, count = 0

i=1, num=5:
  prefix = 9
  remainder = 9 % 5 = 4
  4 in map! count += 1 (found [5])
  map = {0:1, 4:2}, count = 1

i=2, num=0:
  prefix = 9
  remainder = 9 % 5 = 4
  4 in map! count += 2 (found [5,0] and [0])
  map = {0:1, 4:3}, count = 3

i=3, num=-2:
  prefix = 7
  remainder = 7 % 5 = 2
  2 not in map
  map = {0:1, 4:3, 2:1}, count = 3

i=4, num=-3:
  prefix = 4
  remainder = 4 % 5 = 4
  4 in map! count += 3
  map = {0:1, 4:4, 2:1}, count = 6

i=5, num=1:
  prefix = 5
  remainder = 5 % 5 = 0
  0 in map! count += 1
  map = {0:2, 4:4, 2:1}, count = 7

Answer: 7
```

### Handling Negative Remainders

```python
def demonstrate_negative_remainder():
    """
    In some languages, negative % gives negative remainder.
    Python handles it correctly, but good to be safe!
    """
    # Example
    k = 5
    prefix_sum = -7
    
    # Direct modulo (works in Python)
    remainder1 = prefix_sum % k  # 3 in Python
    
    # Safe method (works everywhere)
    remainder2 = (prefix_sum % k + k) % k  # Always 3
    
    print(f"Direct: {remainder1}")
    print(f"Safe: {remainder2}")
    
    # Why safe method: (-7 % 5 + 5) % 5 = (-2 + 5) % 5 = 3

demonstrate_negative_remainder()
```

---

## 4.3 Pattern Category: Binary Array (Equal 0s and 1s)

### The Transformation Trick

**Problem:** Find longest subarray with equal number of 0s and 1s.

**Key Insight:** Convert 0 â†’ -1, then find longest subarray with sum = 0!

### Why This Works

```
Original: [1, 0, 1, 1, 0, 0, 1]
Transform:[1,-1, 1, 1,-1,-1, 1]

If we have equal 0s and 1s:
  Number of 1s = Number of (-1)s
  Sum = 1s + (-1)s = 0 âœ“
```

### Complete Implementation

```python
def longest_equal_zeros_ones(arr):
    """
    Find length of longest subarray with equal 0s and 1s.
    
    Strategy:
    1. Treat 0 as -1
    2. Find longest subarray with sum = 0
    
    Time: O(n), Space: O(n)
    """
    hashmap = {0: -1}  # sum -> first_index
    current_sum = 0
    max_length = 0
    
    for i, num in enumerate(arr):
        # Transform: 0 -> -1, 1 -> 1
        current_sum += 1 if num == 1 else -1
        
        if current_sum in hashmap:
            length = i - hashmap[current_sum]
            max_length = max(max_length, length)
        else:
            hashmap[current_sum] = i
    
    return max_length

# Test cases
print(longest_equal_zeros_ones([0, 1]))           # 2
print(longest_equal_zeros_ones([0, 1, 0]))        # 2
print(longest_equal_zeros_ones([0, 0, 1, 0, 0, 0, 1, 1]))  # 6
```

### Detailed Walkthrough

```
Array: [0, 1, 0, 1, 1, 0]
Transform: [-1, 1, -1, 1, 1, -1]

Initial: map = {0: -1}, sum = 0, max_len = 0

i=0, val=0 (-1):
  sum = -1
  -1 not in map
  map = {0:-1, -1:0}, max_len = 0

i=1, val=1 (1):
  sum = 0
  0 in map at -1!
  len = 1 - (-1) = 2 âœ“ (subarray [0,1])
  map = {0:-1, -1:0}, max_len = 2

i=2, val=0 (-1):
  sum = -1
  -1 in map at 0!
  len = 2 - 0 = 2
  map unchanged, max_len = 2

i=3, val=1 (1):
  sum = 0
  0 in map at -1!
  len = 3 - (-1) = 4 âœ“ (subarray [0,1,0,1])
  max_len = 4

i=4, val=1 (1):
  sum = 1
  1 not in map
  map = {..., 1:4}, max_len = 4

i=5, val=0 (-1):
  sum = 0
  0 in map at -1!
  len = 5 - (-1) = 6 âœ“ (entire array)
  max_len = 6

Answer: 6
```

### Variation: Count Subarrays

```python
def count_equal_zeros_ones(arr):
    """
    Count number of subarrays with equal 0s and 1s.
    """
    hashmap = {0: 1}  # sum -> count
    current_sum = 0
    count = 0
    
    for num in arr:
        current_sum += 1 if num == 1 else -1
        
        if current_sum in hashmap:
            count += hashmap[current_sum]
        
        hashmap[current_sum] = hashmap.get(current_sum, 0) + 1
    
    return count

# Example
print(count_equal_zeros_ones([0, 1, 0, 1]))  # 4
```

---

## 4.4 Pattern Category: XOR Prefix Sum

### XOR Properties

```
Key properties of XOR:
1. a ^ a = 0
2. a ^ 0 = a
3. XOR is associative: (a ^ b) ^ c = a ^ (b ^ c)
4. XOR is commutative: a ^ b = b ^ a
```

### The Pattern

If `prefix_xor[j] ^ prefix_xor[i] = k`, then `prefix_xor[i] = prefix_xor[j] ^ k`

### Why This Works

```
prefix_xor[j] = arr[0] ^ arr[1] ^ ... ^ arr[j]
prefix_xor[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]

prefix_xor[j] ^ prefix_xor[i] = arr[i+1] ^ ... ^ arr[j]
(because arr[0]^...^arr[i] cancels out!)

If we want this to equal k:
  prefix_xor[j] ^ prefix_xor[i] = k
  prefix_xor[i] = prefix_xor[j] ^ k
```

### Complete Implementation

```python
def count_subarrays_xor_k(arr, k):
    """
    Count subarrays with XOR equal to k.
    
    Time: O(n), Space: O(n)
    """
    hashmap = {0: 1}  # xor_value -> count
    prefix_xor = 0
    count = 0
    
    for num in arr:
        prefix_xor ^= num
        
        # We need: prefix_xor[i] = prefix_xor[j] ^ k
        target = prefix_xor ^ k
        
        if target in hashmap:
            count += hashmap[target]
        
        hashmap[prefix_xor] = hashmap.get(prefix_xor, 0) + 1
    
    return count

# Test cases
print(count_subarrays_xor_k([4, 2, 2, 6, 4], 6))  # 4
print(count_subarrays_xor_k([5, 6, 7, 8, 9], 5))  # 2
```

### Detailed Example

```
Array: [4, 2, 2, 6, 4]
Target XOR: k = 6

Binary representation:
4 = 100
2 = 010
6 = 110

Initial: map = {0: 1}, xor = 0, count = 0

i=0, num=4:
  xor = 0 ^ 4 = 4
  target = 4 ^ 6 = 2
  2 not in map
  map = {0:1, 4:1}, count = 0

i=1, num=2:
  xor = 4 ^ 2 = 6
  target = 6 ^ 6 = 0
  0 in map! count += 1 (found [4,2])
  map = {0:1, 4:1, 6:1}, count = 1

i=2, num=2:
  xor = 6 ^ 2 = 4
  target = 4 ^ 6 = 2
  2 not in map
  map = {0:1, 4:2, 6:1}, count = 1

i=3, num=6:
  xor = 4 ^ 6 = 2
  target = 2 ^ 6 = 4
  4 in map! count += 2 (found [2,6] and [4,2,2,6])
  map = {0:1, 4:2, 6:1, 2:1}, count = 3

i=4, num=4:
  xor = 2 ^ 4 = 6
  target = 6 ^ 6 = 0
  0 in map! count += 1 (found [2,2,6,4])
  map = {0:1, 4:2, 6:2, 2:1}, count = 4

Answer: 4
```

---

## 4.5 Pattern Category: Multi-Dimensional Prefix (2D Matrix)

### Problem: Submatrix Sum Equals K

Given a 2D matrix, count submatrices with sum equal to K.

### Strategy: Reduce 2D to 1D

1. Fix two rows (top and bottom)
2. Calculate column sums between these rows
3. Apply 1D prefix sum + HashMap on the column sums

### Visualization

```
Matrix:
    C0  C1  C2  C3
R0  [1   2   3   4]
R1  [5   6   7   8]
R2  [9  10  11  12]

Fix rows 0-1, get column sums:
[6, 8, 10, 12] â† Now treat as 1D array!

Apply prefix sum + HashMap on this 1D array
```

### Complete Implementation

```python
def num_submatrix_sum_target(matrix, target):
    """
    Count submatrices with sum equal to target.
    
    Time: O(rowsÂ² Ã— cols), Space: O(cols)
    """
    if not matrix or not matrix[0]:
        return 0
    
    rows, cols = len(matrix), len(matrix[0])
    count = 0
    
    # Fix top row
    for top in range(rows):
        # Column sums between top and bottom
        col_sum = [0] * cols
        
        # Expand bottom row
        for bottom in range(top, rows):
            # Update column sums
            for c in range(cols):
                col_sum[c] += matrix[bottom][c]
            
            # Apply 1D subarray sum on col_sum
            count += count_subarrays_sum_k(col_sum, target)
    
    return count

# Helper function (from earlier)
def count_subarrays_sum_k(arr, k):
    hashmap = {0: 1}
    prefix = 0
    count = 0
    for num in arr:
        prefix += num
        if prefix - k in hashmap:
            count += hashmap[prefix - k]
        hashmap[prefix] = hashmap.get(prefix, 0) + 1
    return count

# Test
matrix = [
    [0, 1, 0],
    [1, 1, 1],
    [0, 1, 0]
]
print(num_submatrix_sum_target(matrix, 0))  # 4
```

### Step-by-Step for Small Example

```
Matrix:     Target: 4
[1  2]
[3  4]

Top=0, Bottom=0: col_sum = [1, 2]
  Apply 1D: no subarrays sum to 4

Top=0, Bottom=1: col_sum = [1+3, 2+4] = [4, 6]
  Apply 1D: [4] sums to 4 â†’ count = 1

Top=1, Bottom=1: col_sum = [3, 4]
  Apply 1D: [4] sums to 4 â†’ count = 2

Total: 2 submatrices with sum 4
```

---

## 4.6 Pattern Category: String/Character Problems

### Problem: Longest Substring with At Most K Distinct

**Variation:** Find longest substring where character frequency difference â‰¤ K

### Using State as HashMap Key

```python
def longest_substring_k_distinct(s, k):
    """
    Find longest substring with at most k distinct characters.
    Using sliding window + HashMap for character counts.
    """
    char_count = {}
    left = 0
    max_len = 0
    
    for right in range(len(s)):
        # Add character
        char = s[right]
        char_count[char] = char_count.get(char, 0) + 1
        
        # Shrink window if too many distinct
        while len(char_count) > k:
            left_char = s[left]
            char_count[left_char] -= 1
            if char_count[left_char] == 0:
                del char_count[left_char]
            left += 1
        
        max_len = max(max_len, right - left + 1)
    
    return max_len

# Example
print(longest_substring_k_distinct("eceba", 2))  # 3: "ece"
```

---

## 4.7 Pattern Comparison Table

| Pattern | HashMap Key | HashMap Value | Target Formula |
|---------|------------|---------------|----------------|
| Sum = K | prefix_sum | count/index | prefix - k |
| Divisible by K | prefix % k | count/index | same remainder |
| Equal 0s/1s | cumulative_sum | first_index | same sum |
| XOR = K | prefix_xor | count/index | prefix ^ k |
| 2D Matrix | prefix_sum | count | prefix - k |

---

## 4.8 Key Takeaways for Each Pattern

### Subarray Sum = K
ğŸ¯ Direct prefix sum application
âš ï¸ Works with negatives!

### Divisible by K
ğŸ¯ Use remainders as keys
âš ï¸ Handle negative remainders: `(x % k + k) % k`

### Binary Array
ğŸ¯ Transform problem: 0 â†’ -1
ğŸ¯ Find sum = 0

### XOR Problems
ğŸ¯ Use XOR properties: `a ^ a = 0`
ğŸ¯ Formula: `target = prefix_xor ^ k`

### 2D Matrix
ğŸ¯ Fix rows, reduce to 1D
âš ï¸ Time: O(rowsÂ² Ã— cols)

ğŸš€ **Master these patterns and you can solve 80% of prefix + HashMap problems!**