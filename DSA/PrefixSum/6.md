# Chapter 6: Problem-Solving Framework - Deep Dive

## 6.1 The 5-Step Problem-Solving Process

### Overview

When faced with a new problem, follow this systematic approach:

```
Step 1: Identify the Pattern
Step 2: Define the State
Step 3: Handle Edge Cases
Step 4: Determine Order
Step 5: Implement and Test
```

Let's explore each step in detail with examples.

---

## 6.2 Step 1: Identify the Pattern

### Recognition Checklist

Ask yourself these questions:

#### Question 1: Is it about subarrays/substrings?
```
‚úÖ YES ‚Üí Potential for prefix sum + HashMap
‚ùå NO ‚Üí Consider other patterns
```

#### Question 2: Is there a cumulative property?
```
Sum, XOR, Product, Count, etc.
‚úÖ YES ‚Üí Prefix sum applicable
‚ùå NO ‚Üí Maybe sliding window or DP
```

#### Question 3: What are we finding?
```
- Count of subarrays ‚Üí Use HashMap with frequencies
- Longest subarray ‚Üí Use HashMap with first indices
- Existence ‚Üí Early termination possible
- All subarrays ‚Üí Store lists of indices
```

#### Question 4: What's the constraint?
```
- "equals K" ‚Üí Direct prefix sum + HashMap
- "divisible by K" ‚Üí Store remainders
- "at most K" ‚Üí Might need sliding window
- "between L and R" ‚Üí Range query approach
```

### Pattern Recognition Examples

#### Example 1: Immediate Recognition
```
Problem: "Find the number of subarrays with sum equal to 7"

Analysis:
‚úì Subarrays? YES
‚úì Cumulative (sum)? YES
‚úì Finding count? YES
‚úì Equals K? YES

Conclusion: Classic prefix sum + HashMap pattern!
Template: {0: 1}, check then update
```

#### Example 2: Needs Transformation
```
Problem: "Find longest subarray with equal 0s and 1s"

Analysis:
‚úì Subarrays? YES
‚úì Equal counts ‚Üí Can be transformed to sum = 0
‚úì Finding length? YES

Conclusion: Transform 0‚Üí-1, find longest with sum=0
Template: {0: -1}, store first occurrence only
```

#### Example 3: Multiple Conditions
```
Problem: "Count subarrays where sum is divisible by both 3 and 5"

Analysis:
‚úì Subarrays? YES
‚úì Cumulative (sum)? YES
‚úì Multiple divisibility? YES

Conclusion: Composite key pattern (rem3, rem5)
Template: {(0,0): 1}, composite state
```

### Decision Tree

```
Is it about subarrays?
‚îú‚îÄ YES
‚îÇ  ‚îú‚îÄ Cumulative property?
‚îÇ  ‚îÇ  ‚îú‚îÄ YES
‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ Equals K ‚Üí Prefix + HashMap
‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ Divisible by K ‚Üí Remainders
‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ At most K ‚Üí Sliding Window
‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ XOR ‚Üí XOR prefix
‚îÇ  ‚îÇ  ‚îî‚îÄ NO ‚Üí Try other approaches
‚îÇ  ‚îî‚îÄ NO cumulative ‚Üí Try sliding window
‚îî‚îÄ NO ‚Üí Different pattern (DP, Greedy, etc.)
```

---

## 6.3 Step 2: Define the State

### State Components

You need to decide three things:

1. **What should the prefix represent?**
2. **What should the HashMap key be?**
3. **What should the HashMap value be?**

### State Definition Table

| Problem Type | Prefix | HashMap Key | HashMap Value |
|-------------|--------|-------------|---------------|
| Sum = K | Running sum | prefix_sum | count/first_index |
| Divisible by K | Running sum | remainder | count/first_index |
| Equal 0s/1s | +1/-1 sum | cumulative_sum | first_index |
| XOR = K | Running XOR | prefix_xor | count/first_index |
| Character count | Freq array | tuple(freqs) | first_index |
| Multiple conditions | Varies | tuple of states | count/index |

### Detailed Examples

#### Example 1: Sum Equals K
```python
# State definition
prefix_sum = 0           # Tracks cumulative sum
hashmap_key = prefix_sum # Key is the sum itself
hashmap_value = count    # Value is frequency (for counting)

# For finding length:
hashmap_value = first_index  # Value is first occurrence
```

#### Example 2: Divisible by K
```python
# State definition
prefix_sum = 0                    # Tracks cumulative sum
hashmap_key = prefix_sum % k      # Key is REMAINDER
hashmap_value = count             # Value is frequency

# Why remainder? 
# If two positions have same remainder,
# their difference is divisible by k!
```

#### Example 3: Character Frequency
```python
# State definition for "equal a's and b's"
count_a = 0                       # Count of 'a'
count_b = 0                       # Count of 'b'
hashmap_key = count_a - count_b   # Key is DIFFERENCE
hashmap_value = first_index       # For longest substring

# If difference is same at two positions,
# substring between has equal a's and b's!
```

### Choosing the Right Value Type

```python
# For COUNTING problems
hashmap[key] = frequency  # int

# For FINDING LENGTH
hashmap[key] = first_index  # int (store first only)

# For FINDING ALL
hashmap[key] = [indices]  # list

# For CHECKING EXISTS
hashmap[key] = True  # boolean (or just check 'in')
```

---

## 6.4 Step 3: Handle Edge Cases

### Critical Edge Cases Checklist

#### Edge Case 1: Empty Subarray
```python
# The {0: 1} or {0: -1} initialization handles this!

Example:
arr = [5, 3, -2]
k = 5

At index 0:
  prefix = 5
  target = 5 - 5 = 0
  0 in hashmap? YES (from initialization)
  This finds subarray [5] starting at index 0 ‚úì
```

#### Edge Case 2: Single Element
```python
arr = [5]
k = 5

Should return 1 (the single element itself)

Initial: hashmap = {0: 1}
i=0: prefix=5, target=0, found! count=1 ‚úì
```

#### Edge Case 3: All Elements Satisfy
```python
arr = [1, 1, 1]
k = 1

Each single element equals k
Should return 3

Trace:
i=0: prefix=1, target=0, found! count=1
i=1: prefix=2, target=1, found! count=2
i=2: prefix=3, target=2, found! count=3 ‚úì
```

#### Edge Case 4: No Elements Satisfy
```python
arr = [1, 2, 3]
k = 10

No subarray sums to 10
Should return 0

Trace shows no targets found in hashmap ‚úì
```

#### Edge Case 5: Negative Numbers
```python
arr = [1, -1, 1, -1]
k = 0

Multiple subarrays sum to 0:
[1, -1], [1, -1] (second pair), [-1, 1], entire array

Pattern still works perfectly! ‚úì
```

#### Edge Case 6: Zero in Array
```python
arr = [0, 0, 0]
k = 0

Each element and all combinations sum to 0
Total: 6 subarrays

0-indexed: [0], [0], [0], [0,0], [0,0], [0,0,0]
```

### Edge Case Template

```python
def handle_edge_cases(arr, k):
    """
    Complete edge case handling.
    """
    # Edge case: empty array
    if not arr:
        return 0
    
    # Edge case: single element
    if len(arr) == 1:
        return 1 if arr[0] == k else 0
    
    # Standard algorithm handles other cases
    hashmap = {0: 1}
    prefix = 0
    count = 0
    
    for num in arr:
        prefix += num
        if prefix - k in hashmap:
            count += hashmap[prefix - k]
        hashmap[prefix] = hashmap.get(prefix, 0) + 1
    
    return count
```

---

## 6.5 Step 4: Determine Order

### The Order Decision Matrix

| Objective | Check Before Update? | Store What? | Why? |
|-----------|---------------------|-------------|------|
| Count subarrays | YES | Frequency | Avoid counting same element |
| Find longest | Check then conditionally update | First index only | Want earliest occurrence |
| Find all | YES | List of indices | Need all positions |
| Check exists | Can check/update either | Boolean | Just need to know |

### Order Example 1: Counting (Must Check First)

```python
def count_subarrays(arr, k):
    hashmap = {0: 1}
    prefix = 0
    count = 0
    
    for num in arr:
        prefix += num
        
        # MUST check first!
        if prefix - k in hashmap:
            count += hashmap[prefix - k]
        
        # THEN update
        hashmap[prefix] = hashmap.get(prefix, 0) + 1
    
    return count

# Why? Example:
arr = [5]
k = 5

If we update first:
  prefix = 5
  hashmap[5] = 1
  Check: 5-5=0 in map? YES
  count += 1
  But we also need to add for {0:1}, so count += 1 again
  WRONG! count = 2 instead of 1

If we check first:
  prefix = 5
  Check: 5-5=0 in map? YES, count += 1
  Update: hashmap[5] = 1
  CORRECT! count = 1
```

### Order Example 2: Finding Length (Store First Only)

```python
def longest_subarray(arr, k):
    hashmap = {0: -1}
    prefix = 0
    max_len = 0
    
    for i, num in enumerate(arr):
        prefix += num
        
        # Check if target exists
        if prefix - k in hashmap:
            length = i - hashmap[prefix - k]
            max_len = max(max_len, length)
        
        # ONLY store first occurrence
        if prefix not in hashmap:
            hashmap[prefix] = i
    
    return max_len

# Why store first only?
arr = [1, 0, 1]
k = 1

At i=0: prefix=1, store {0:-1, 1:0}
At i=1: prefix=1, already in map, DON'T update
At i=2: prefix=2, check if 2-1=1 in map
        YES at index 0
        length = 2 - 0 = 2 ‚úì

If we stored last:
  At i=1: would update {1:1}
  At i=2: length = 2 - 1 = 1 ‚úó (wrong!)
```

---

## 6.6 Step 5: Code Template Selection

### Template Library

#### Template 1: Count Subarrays with Sum = K
```python
def count_sum_equals_k(arr, k):
    hashmap = {0: 1}
    prefix = 0
    count = 0
    
    for num in arr:
        prefix += num
        if prefix - k in hashmap:
            count += hashmap[prefix - k]
        hashmap[prefix] = hashmap.get(prefix, 0) + 1
    
    return count
```

#### Template 2: Longest Subarray with Sum = K
```python
def longest_sum_equals_k(arr, k):
    hashmap = {0: -1}
    prefix = 0
    max_len = 0
    
    for i, num in enumerate(arr):
        prefix += num
        if prefix - k in hashmap:
            max_len = max(max_len, i - hashmap[prefix - k])
        if prefix not in hashmap:
            hashmap[prefix] = i
    
    return max_len
```

#### Template 3: Count Divisible by K
```python
def count_divisible_k(arr, k):
    hashmap = {0: 1}
    prefix = 0
    count = 0
    
    for num in arr:
        prefix += num
        remainder = (prefix % k + k) % k
        if remainder in hashmap:
            count += hashmap[remainder]
        hashmap[remainder] = hashmap.get(remainder, 0) + 1
    
    return count
```

#### Template 4: XOR = K
```python
def count_xor_equals_k(arr, k):
    hashmap = {0: 1}
    prefix_xor = 0
    count = 0
    
    for num in arr:
        prefix_xor ^= num
        target = prefix_xor ^ k
        if target in hashmap:
            count += hashmap[target]
        hashmap[prefix_xor] = hashmap.get(prefix_xor, 0) + 1
    
    return count
```

#### Template 5: Binary Transformation
```python
def longest_equal_01(arr):
    hashmap = {0: -1}
    balance = 0
    max_len = 0
    
    for i, num in enumerate(arr):
        balance += 1 if num == 1 else -1
        if balance in hashmap:
            max_len = max(max_len, i - hashmap[balance])
        else:
            hashmap[balance] = i
    
    return max_len
```

---

## 6.7 Complete Problem-Solving Example

### Problem: Maximum Size Subarray Sum Equals K

**Given:** Array of integers and target k  
**Find:** Length of longest subarray with sum = k  
**Constraints:** Array can have positive, negative, and zero  

#### Step 1: Identify Pattern
```
‚úì Subarrays ‚Üí YES
‚úì Sum (cumulative) ‚Üí YES
‚úì Finding length ‚Üí YES
‚úì Equals K ‚Üí YES

Pattern: Prefix Sum + HashMap (length variant)
```

#### Step 2: Define State
```
Prefix: Running sum
HashMap Key: prefix_sum
HashMap Value: First index with this sum
Initial: {0: -1}
```

#### Step 3: Edge Cases
```
- Empty array ‚Üí return 0
- Single element = k ‚Üí return 1
- No subarray sums to k ‚Üí return 0
- Multiple valid subarrays ‚Üí return max length
- Negatives ‚Üí handled automatically
```

#### Step 4: Determine Order
```
Finding length ‚Üí Store first occurrence only
Check if target exists
If yes, calculate length
Only update if prefix not seen before
```

#### Step 5: Implementation
```python
def max_subarray_length(arr, k):
    """
    Find length of longest subarray with sum equal to k.
    
    Time: O(n)
    Space: O(n)
    """
    if not arr:
        return 0
    
    hashmap = {0: -1}  # sum -> first_index
    prefix_sum = 0
    max_length = 0
    
    for i, num in enumerate(arr):
        prefix_sum += num
        
        # Check if we can form sum = k
        target = prefix_sum - k
        if target in hashmap:
            length = i - hashmap[target]
            max_length = max(max_length, length)
        
        # Store first occurrence only
        if prefix_sum not in hashmap:
            hashmap[prefix_sum] = i
    
    return max_length

# Test cases
print(max_subarray_length([1, -1, 5, -2, 3], 3))     # 4
print(max_subarray_length([1, 2, 3], 3))             # 2
print(max_subarray_length([-2, -1, 2, 1], 1))        # 2
print(max_subarray_length([1, 1, 1, 1, 1], 3))       # 3
```

---

## 6.8 Problem Variation Strategies

### Variation 1: From "Count" to "Length"

```python
# Count version
def count_version(arr, k):
    hashmap = {0: 1}
    # ... store frequency

# Length version - Changes:
def length_version(arr, k):
    hashmap = {0: -1}        # Change 1: -1 instead of 1
    # ... store first index   # Change 2: only first occurrence
    # ... track max_length    # Change 3: maximize length
```

### Variation 2: From "Equals" to "Divisible"

```python
# Equals K
target = prefix - k

# Divisible by K
remainder = (prefix % k + k) % k
# Check if remainder seen before
```

### Variation 3: From "Sum" to "XOR"

```python
# Sum
prefix += num
target = prefix - k

# XOR
prefix ^= num
target = prefix ^ k
```

---

## 6.9 Debugging Checklist

When your solution doesn't work, check:

### Checklist
```
‚ñ° Initialization correct? ({0: 1} or {0: -1}?)
‚ñ° Target calculation correct? (prefix - k or prefix ^ k?)
‚ñ° Check before update? (for counting problems)
‚ñ° Storing first occurrence only? (for length problems)
‚ñ° Handling negatives? ((x % k + k) % k for remainders)
‚ñ° Edge cases covered? (empty, single element, all satisfy)
‚ñ° Using correct HashMap value? (count vs index)
```

### Debug Template

```python
def debug_solution(arr, k):
    hashmap = {0: 1}
    prefix = 0
    count = 0
    
    print(f"Input: arr={arr}, k={k}\n")
    
    for i, num in enumerate(arr):
        old_prefix = prefix
        prefix += num
        target = prefix - k
        
        found = hashmap.get(target, 0)
        count += found
        
        hashmap[prefix] = hashmap.get(prefix, 0) + 1
        
        print(f"Step {i}:")
        print(f"  num={num}, prefix: {old_prefix}‚Üí{prefix}")
        print(f"  target={target}, found={found}")
        print(f"  count={count}, map={dict(hashmap)}")
        print()
    
    return count
```

---

## 6.10 Practice Problem Walkthrough

### Problem: Contiguous Array (LeetCode 525)

**Given:** Binary array (0s and 1s)  
**Find:** Length of longest subarray with equal 0s and 1s

#### Solution Process

**Step 1: Identify**
```
Equal 0s and 1s ‚Üí Transform to sum = 0 problem
0 ‚Üí -1, 1 ‚Üí 1
```

**Step 2: Define State**
```
Prefix: Balance (count of 1s - count of 0s)
Key: balance
Value: First index
```

**Step 3: Edge Cases**
```
All 0s ‚Üí return 0
All 1s ‚Üí return 0
Alternating [0,1,0,1] ‚Üí return 4
```

**Step 4: Order**
```
Length problem ‚Üí store first occurrence
Check then conditionally update
```

**Step 5: Code**
```python
def findMaxLength(nums):
    hashmap = {0: -1}
    balance = 0
    max_len = 0
    
    for i, num in enumerate(nums):
        balance += 1 if num == 1 else -1
        
        if balance in hashmap:
            max_len = max(max_len, i - hashmap[balance])
        else:
            hashmap[balance] = i
    
    return max_len
```

---

## 6.11 Key Takeaways

üéØ **5-Step Process:**
1. Identify pattern type
2. Define state components
3. Handle edge cases
4. Determine update order
5. Select correct template

üîë **Quick Decisions:**
- Count ‚Üí `{0: 1}`, check first, store frequency
- Length ‚Üí `{0: -1}`, store first only
- Divisible ‚Üí store remainders
- XOR ‚Üí use `^` operator

üí° **Common Transforms:**
- Equal 0s/1s ‚Üí 0 becomes -1
- Divisible by K ‚Üí work with remainders
- Product ‚Üí consider logarithms

‚ö†Ô∏è **Always Verify:**
- Initialization value
- Target calculation
- Update order
- Edge cases

üöÄ **Practice:** Apply this framework to every new problem!