# Chapter 1: Foundations of Heap
## Deep Dive into Heap Fundamentals

---

# 1.1 What is a Heap?

A **Heap** is a specialized tree-based data structure that satisfies two key properties:

1. **Complete Binary Tree Property**: All levels are fully filled except possibly the last level, which is filled from left to right.

2. **Heap Property**: A specific ordering relationship between parent and child nodes.

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  HEAP = Complete Binary Tree + Heap Property                      â•‘
â•‘                                                                   â•‘
â•‘  â€¢ NOT a sorted data structure                                    â•‘
â•‘  â€¢ Only guarantees: root is min (min-heap) or max (max-heap)      â•‘
â•‘  â€¢ No guaranteed ordering between siblings or cousins             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### Why "Heap"?
The name comes from the concept of a "pile" where the most important item is always on top, similar to how the min/max element is always at the root.

> âš ï¸ **Important**: Don't confuse with "memory heap" used in programming for dynamic memory allocation - completely different concept!

---

# 1.2 Types of Heaps

## 1.2.1 Max-Heap

In a Max-Heap, the parent node is **always greater than or equal to** its children.

```
                    MAX-HEAP EXAMPLE
                    
                         100        â† Maximum at root
                        /   \
                      50     70
                     /  \   /  \
                   30   40 60   65
                   /\
                 10  20

    Property: Parent â‰¥ Children (at every node)
    
    Verification:
    â€¢ 100 â‰¥ 50, 100 â‰¥ 70  âœ“
    â€¢ 50 â‰¥ 30, 50 â‰¥ 40    âœ“
    â€¢ 70 â‰¥ 60, 70 â‰¥ 65    âœ“
    â€¢ 30 â‰¥ 10, 30 â‰¥ 20    âœ“
```

**Use Cases for Max-Heap:**
- Finding maximum element in O(1)
- Priority queues where higher value = higher priority
- Heap sort (descending order)
- Kth smallest element problems

## 1.2.2 Min-Heap

In a Min-Heap, the parent node is **always less than or equal to** its children.

```
                    MIN-HEAP EXAMPLE
                    
                          5         â† Minimum at root
                        /   \
                      10     15
                     /  \   /  \
                   20   25 30   35
                   /\
                 40  50

    Property: Parent â‰¤ Children (at every node)
    
    Verification:
    â€¢ 5 â‰¤ 10, 5 â‰¤ 15      âœ“
    â€¢ 10 â‰¤ 20, 10 â‰¤ 25    âœ“
    â€¢ 15 â‰¤ 30, 15 â‰¤ 35    âœ“
    â€¢ 20 â‰¤ 40, 20 â‰¤ 50    âœ“
```

**Use Cases for Min-Heap:**
- Finding minimum element in O(1)
- Priority queues where lower value = higher priority
- Dijkstra's shortest path algorithm
- Kth largest element problems
- Merge K sorted lists

## 1.2.3 Visual Comparison

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     MAX-HEAP vs MIN-HEAP                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚      MAX-HEAP                         MIN-HEAP                  â”‚
â”‚                                                                 â”‚
â”‚         90                               10                     â”‚
â”‚        /  \                             /  \                    â”‚
â”‚      80    70                         20    30                  â”‚
â”‚     / \   / \                        / \   / \                  â”‚
â”‚   60  50 40  30                    40  50 60  70                â”‚
â”‚                                                                 â”‚
â”‚   Root = MAXIMUM                    Root = MINIMUM              â”‚
â”‚   Parent â‰¥ Children                 Parent â‰¤ Children           â”‚
â”‚                                                                 â”‚
â”‚   Elements decrease                 Elements increase           â”‚
â”‚   as we go down                     as we go down               â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# 1.3 Complete Binary Tree Property

A heap must be a **Complete Binary Tree**. Understanding this is crucial!

## What is a Complete Binary Tree?

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  COMPLETE BINARY TREE RULES:                                      â•‘
â•‘                                                                   â•‘
â•‘  1. All levels except the last are COMPLETELY filled              â•‘
â•‘  2. Last level is filled from LEFT to RIGHT (no gaps)             â•‘
â•‘  3. This guarantees O(log n) height                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### Valid Complete Binary Trees (Can be Heaps):

```
Example 1: Full           Example 2: Last level     Example 3: Single
                          partially filled          node
       A                        A                        A
      / \                      / \                    
     B   C                    B   C               
    / \ / \                  / \                  
   D  E F  G                D   E                 

Example 4: Two levels,    Example 5: Last level
left-filled               left-filled
       A                        A
      / \                      / \
     B   C                    B   C
    /                        / \ /
   D                        D  E F
```

### INVALID Complete Binary Trees (Cannot be Heaps):

```
INVALID Example 1:        INVALID Example 2:        INVALID Example 3:
Gap in last level         Right child without       Unbalanced
                          left sibling
       A                        A                        A
      / \                      / \                      /
     B   C                    B   C                    B
    / \   \                      /                    /
   D  E    G                    D                    C
       â†‘                        â†‘                    â†‘
   Missing F!              Missing left!         Not complete!
```

### Why Complete Binary Tree?

1. **Predictable Structure**: Enables array storage without gaps
2. **Balanced Height**: Always O(log n) height for n nodes
3. **Efficient Operations**: All operations stay O(log n)

```
Height Analysis:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Level 0:  1 node       (2â°)                         â”‚
â”‚  Level 1:  2 nodes      (2Â¹)                         â”‚
â”‚  Level 2:  4 nodes      (2Â²)                         â”‚
â”‚  Level 3:  8 nodes      (2Â³)                         â”‚
â”‚  ...                                                 â”‚
â”‚  Level h:  up to 2^h nodes                          â”‚
â”‚                                                      â”‚
â”‚  Total nodes n = 2^(h+1) - 1 (for full tree)        â”‚
â”‚  Therefore: h = O(log n)                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# 1.4 Array Representation of Heap

The most powerful aspect of heaps: **storing a tree in an array without pointers!**

## 1.4.1 Why Array Storage?

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ADVANTAGES OF ARRAY REPRESENTATION:                              â•‘
â•‘                                                                   â•‘
â•‘  âœ“ No pointer overhead (saves memory)                             â•‘
â•‘  âœ“ Better cache locality (elements are contiguous)                â•‘
â•‘  âœ“ Simple parent-child navigation using math                      â•‘
â•‘  âœ“ No need for node allocation/deallocation                       â•‘
â•‘  âœ“ Easy to implement                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

## 1.4.2 Tree-to-Array Mapping

The tree is stored **level by level, left to right**:

```
           TREE VIEW                      ARRAY VIEW
           
              50                    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
             /  \                   â”‚50 â”‚30 â”‚40 â”‚10 â”‚20 â”‚35 â”‚38 â”‚
           30    40                 â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
          / \   / \                   0   1   2   3   4   5   6
        10  20 35  38               
                                    Level 0: index 0
    Level 0:  50                    Level 1: indices 1-2
    Level 1:  30, 40                Level 2: indices 3-6
    Level 2:  10, 20, 35, 38
```

## 1.4.3 Index Formulas (0-based indexing)

```python
# For a node at index i:

def parent(i):
    return (i - 1) // 2

def left_child(i):
    return 2 * i + 1

def right_child(i):
    return 2 * i + 2

def has_left_child(i, heap_size):
    return left_child(i) < heap_size

def has_right_child(i, heap_size):
    return right_child(i) < heap_size

def is_leaf(i, heap_size):
    return left_child(i) >= heap_size
```

### Visual Index Mapping:

```
                TREE WITH INDICES
                
                    [0]
                     50
                   /    \
                [1]      [2]
                30        40
               /  \      /  \
            [3]  [4]  [5]  [6]
            10    20   35   38


    FORMULA VERIFICATION:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Node   â”‚ Parent â”‚ L-Child  â”‚  R-Child  â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ i=0(50) â”‚   -    â”‚ 1 (30)   â”‚  2 (40)   â”‚
    â”‚ i=1(30) â”‚ 0 (50) â”‚ 3 (10)   â”‚  4 (20)   â”‚
    â”‚ i=2(40) â”‚ 0 (50) â”‚ 5 (35)   â”‚  6 (38)   â”‚
    â”‚ i=3(10) â”‚ 1 (30) â”‚   -      â”‚    -      â”‚
    â”‚ i=4(20) â”‚ 1 (30) â”‚   -      â”‚    -      â”‚
    â”‚ i=5(35) â”‚ 2 (40) â”‚   -      â”‚    -      â”‚
    â”‚ i=6(38) â”‚ 2 (40) â”‚   -      â”‚    -      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    Verify i=4:
    â€¢ Parent = (4-1)//2 = 1 âœ“ (which is 30)
    â€¢ Left child = 2*4+1 = 9 (doesn't exist) âœ“
    â€¢ Right child = 2*4+2 = 10 (doesn't exist) âœ“
```

## 1.4.4 Index Formulas (1-based indexing)

Some implementations use 1-based indexing (index 0 unused):

```python
# For a node at index i (1-based):

def parent(i):
    return i // 2

def left_child(i):
    return 2 * i

def right_child(i):
    return 2 * i + 1
```

```
    1-BASED INDEXING (Index 0 unused)
    
    Array: [_, 50, 30, 40, 10, 20, 35, 38]
    Index:  0   1   2   3   4   5   6   7
               â†‘
            Root at index 1
    
    For node at i=2 (value 30):
    â€¢ Parent = 2//2 = 1 (value 50) âœ“
    â€¢ Left = 2*2 = 4 (value 10) âœ“
    â€¢ Right = 2*2+1 = 5 (value 20) âœ“
```

> ğŸ’¡ **Interview Tip**: Always clarify which indexing you're using! 0-based is more common in interviews.

## 1.4.5 Key Properties from Array View

```python
# Important derived properties:

def last_non_leaf_index(heap_size):
    """Index of the last node that has at least one child"""
    return (heap_size // 2) - 1  # 0-based

def first_leaf_index(heap_size):
    """Index of the first leaf node"""
    return heap_size // 2  # 0-based

# Example: heap_size = 7
# Last non-leaf: (7//2) - 1 = 2 (index 2)
# First leaf: 7//2 = 3 (index 3)
```

```
    For heap of size 7:
    
              [0]          
               50          Non-leaf nodes: indices 0, 1, 2
             /    \        Leaf nodes: indices 3, 4, 5, 6
          [1]      [2]     
          30        40     Last non-leaf: index 2 (40)
         /  \      /  \    First leaf: index 3 (10)
      [3]  [4]  [5]  [6]
      10    20   35   38   â† All leaves
```

---

# 1.5 Heap vs Other Data Structures

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COMPARISON TABLE                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Operation     â”‚   Heap   â”‚  Sorted  â”‚ Unsorted â”‚   BST    â”‚    AVL     â”‚
â”‚                  â”‚          â”‚  Array   â”‚  Array   â”‚ (Avg)    â”‚   Tree     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Find Min/Max     â”‚   O(1)   â”‚   O(1)   â”‚   O(n)   â”‚  O(n)*   â”‚   O(log n) â”‚
â”‚ Insert           â”‚ O(log n) â”‚   O(n)   â”‚   O(1)   â”‚ O(log n) â”‚  O(log n)  â”‚
â”‚ Delete Min/Max   â”‚ O(log n) â”‚   O(1)** â”‚   O(n)   â”‚ O(log n) â”‚  O(log n)  â”‚
â”‚ Search           â”‚   O(n)   â”‚ O(log n) â”‚   O(n)   â”‚ O(log n) â”‚  O(log n)  â”‚
â”‚ Build            â”‚   O(n)   â”‚ O(nlogn) â”‚   O(n)   â”‚ O(nlogn) â”‚  O(nlogn)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ * BST can be O(log n) if augmented to track min/max                       â”‚
â”‚ ** O(1) only if deleting from the correct end                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### When to Use Heap?

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  USE HEAP WHEN:                                                   â•‘
â•‘                                                                   â•‘
â•‘  âœ“ Need quick access to min OR max (not both)                     â•‘
â•‘  âœ“ Frequent insertions and deletions                              â•‘
â•‘  âœ“ Don't need to search for arbitrary elements                    â•‘
â•‘  âœ“ Processing elements in priority order                          â•‘
â•‘                                                                   â•‘
â•‘  DON'T USE HEAP WHEN:                                             â•‘
â•‘                                                                   â•‘
â•‘  âœ— Need to search for specific values                             â•‘
â•‘  âœ— Need both min AND max efficiently (use Min-Max heap)           â•‘
â•‘  âœ— Need sorted traversal                                          â•‘
â•‘  âœ— Need predecessor/successor queries                             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

# 1.6 Complete Implementation: Basic Heap Class

```python
class MinHeap:
    """
    A complete Min-Heap implementation from scratch.
    Demonstrates all foundational concepts.
    """
    
    def __init__(self):
        self.heap = []
    
    # ============== INDEX HELPERS ==============
    
    def _parent(self, i):
        """Get parent index of node at index i"""
        return (i - 1) // 2
    
    def _left_child(self, i):
        """Get left child index of node at index i"""
        return 2 * i + 1
    
    def _right_child(self, i):
        """Get right child index of node at index i"""
        return 2 * i + 2
    
    def _has_left_child(self, i):
        """Check if node at index i has a left child"""
        return self._left_child(i) < len(self.heap)
    
    def _has_right_child(self, i):
        """Check if node at index i has a right child"""
        return self._right_child(i) < len(self.heap)
    
    def _has_parent(self, i):
        """Check if node at index i has a parent"""
        return i > 0
    
    # ============== VALUE HELPERS ==============
    
    def _left_child_value(self, i):
        return self.heap[self._left_child(i)]
    
    def _right_child_value(self, i):
        return self.heap[self._right_child(i)]
    
    def _parent_value(self, i):
        return self.heap[self._parent(i)]
    
    # ============== SWAP HELPER ==============
    
    def _swap(self, i, j):
        """Swap elements at indices i and j"""
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
    
    # ============== MAIN OPERATIONS ==============
    
    def peek(self):
        """Return minimum element without removing it - O(1)"""
        if not self.heap:
            raise IndexError("Heap is empty")
        return self.heap[0]
    
    def size(self):
        """Return number of elements in heap"""
        return len(self.heap)
    
    def is_empty(self):
        """Check if heap is empty"""
        return len(self.heap) == 0
    
    def __str__(self):
        """String representation for debugging"""
        return f"MinHeap({self.heap})"
    
    def __len__(self):
        return len(self.heap)


# Example Usage:
if __name__ == "__main__":
    heap = MinHeap()
    print(f"Empty heap: {heap}")
    print(f"Is empty: {heap.is_empty()}")
    print(f"Size: {heap.size()}")
```

---

# 1.7 Key Takeaways

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CHAPTER 1 SUMMARY                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  1. DEFINITION                                                      â”‚
â”‚     â€¢ Heap = Complete Binary Tree + Heap Property                   â”‚
â”‚     â€¢ NOT fully sorted, only root guaranteed min/max                â”‚
â”‚                                                                     â”‚
â”‚  2. TWO TYPES                                                       â”‚
â”‚     â€¢ Max-Heap: Parent â‰¥ Children                                   â”‚
â”‚     â€¢ Min-Heap: Parent â‰¤ Children                                   â”‚
â”‚                                                                     â”‚
â”‚  3. COMPLETE BINARY TREE                                            â”‚
â”‚     â€¢ All levels full except last                                   â”‚
â”‚     â€¢ Last level filled left to right                               â”‚
â”‚     â€¢ Guarantees O(log n) height                                    â”‚
â”‚                                                                     â”‚
â”‚  4. ARRAY REPRESENTATION                                            â”‚
â”‚     â€¢ Store level by level, left to right                           â”‚
â”‚     â€¢ Parent(i) = (i-1)//2                                          â”‚
â”‚     â€¢ Left(i) = 2i+1, Right(i) = 2i+2                               â”‚
â”‚                                                                     â”‚
â”‚  5. USE CASES                                                       â”‚
â”‚     â€¢ Priority queues                                               â”‚
â”‚     â€¢ Top K problems                                                â”‚
â”‚     â€¢ Graph algorithms (Dijkstra, Prim)                             â”‚
â”‚     â€¢ Median finding                                                â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

**Next: Chapter 2 - Core Heap Operations** â†’
