# Chapter 4: Priority Queue Patterns
## Mastering the Abstract Data Type and Its Patterns

---

# 4.1 Priority Queue: The Abstract Data Type

## 4.1.1 What is a Priority Queue?

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    PRIORITY QUEUE (ADT)                                   ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  Definition: A collection where each element has a "priority"             ║
║              Elements are served based on priority, not insertion order   ║
║                                                                           ║
║  Core Operations:                                                         ║
║  ┌─────────────────┬────────────────────────────────────────────────┐    ║
║  │ insert(e, p)    │ Add element e with priority p                  │    ║
║  │ extractMin/Max()│ Remove and return highest priority element     │    ║
║  │ peek()          │ View highest priority element                  │    ║
║  │ isEmpty()       │ Check if queue is empty                        │    ║
║  │ size()          │ Return number of elements                      │    ║
║  └─────────────────┴────────────────────────────────────────────────┘    ║
║                                                                           ║
║  Optional Operations (for advanced implementations):                      ║
║  • decreaseKey(e, p) - Decrease priority of element                       ║
║  • increaseKey(e, p) - Increase priority of element                       ║
║  • remove(e)         - Remove arbitrary element                           ║
║  • contains(e)       - Check if element exists                            ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 4.1.2 Priority Queue vs Heap

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│     PRIORITY QUEUE                              HEAP                        │
│     ════════════════                            ════                        │
│                                                                             │
│     Abstract Data Type (ADT)                    Concrete Data Structure     │
│     - Defines WHAT operations                   - Defines HOW to implement  │
│     - Interface/Contract                        - One possible implementation│
│                                                                             │
│     ┌─────────────────┐                        ┌─────────────────┐         │
│     │ Priority Queue  │                        │     Heap        │         │
│     │    (ADT)        │ ◄── implemented by ─── │  (Binary Tree   │         │
│     │                 │                        │   in Array)     │         │
│     └─────────────────┘                        └─────────────────┘         │
│                                                                             │
│     Other implementations:                                                  │
│     • Sorted Array        O(n) insert, O(1) extract                        │
│     • Unsorted Array      O(1) insert, O(n) extract                        │
│     • Binary Search Tree  O(log n) all operations                          │
│     • Fibonacci Heap      O(1) insert, O(1) decrease-key amortized         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 4.1.3 Implementation Comparison

```
╔═════════════════════════════════════════════════════════════════════════════╗
║                 PRIORITY QUEUE IMPLEMENTATIONS COMPARED                     ║
╠══════════════════╦═════════╦═════════╦════════════╦═════════╦══════════════╣
║    Operation     ║ Unsorted║ Sorted  ║   Binary   ║Fibonacci║    Notes     ║
║                  ║  Array  ║ Array   ║    Heap    ║  Heap   ║              ║
╠══════════════════╬═════════╬═════════╬════════════╬═════════╬══════════════╣
║ insert           ║   O(1)  ║  O(n)   ║  O(log n)  ║  O(1)*  ║ *amortized   ║
║ extractMin/Max   ║   O(n)  ║  O(1)** ║  O(log n)  ║O(log n)*║ **from end   ║
║ peek             ║   O(n)  ║  O(1)   ║    O(1)    ║  O(1)   ║              ║
║ decreaseKey      ║   O(1)  ║  O(n)   ║  O(log n)  ║  O(1)*  ║ Key for      ║
║                  ║         ║         ║            ║         ║ Dijkstra     ║
║ delete           ║   O(1)  ║  O(n)   ║  O(log n)  ║O(log n)*║              ║
║ build            ║   O(n)  ║O(nlogn) ║    O(n)    ║  O(n)   ║              ║
╠══════════════════╬═════════╩═════════╩════════════╩═════════╩══════════════╣
║                                                                             ║
║  WHEN TO USE EACH:                                                          ║
║  • Unsorted Array: Few extracts, many inserts                               ║
║  • Sorted Array: Few inserts, many extracts                                 ║
║  • Binary Heap: Balanced insert/extract (MOST COMMON)                       ║
║  • Fibonacci Heap: Many decrease-key operations (graph algorithms)          ║
║                                                                             ║
╚═════════════════════════════════════════════════════════════════════════════╝
```

---

# 4.2 Basic Priority Queue Implementation

```python
import heapq
from dataclasses import dataclass, field
from typing import Any, Optional

# ═══════════════════════════════════════════════════════════════════════════
# BASIC PRIORITY QUEUE USING HEAP
# ═══════════════════════════════════════════════════════════════════════════

class PriorityQueue:
    """
    A min-priority queue implementation using heap.
    Lower priority value = higher priority (served first)
    """
    
    def __init__(self):
        self._heap = []
        self._index = 0  # Tiebreaker for equal priorities
    
    def push(self, item: Any, priority: int) -> None:
        """Add item with given priority - O(log n)"""
        # Tuple: (priority, index, item)
        # Index ensures FIFO order for equal priorities
        entry = (priority, self._index, item)
        heapq.heappush(self._heap, entry)
        self._index += 1
    
    def pop(self) -> Any:
        """Remove and return lowest priority item - O(log n)"""
        if not self._heap:
            raise IndexError("Priority queue is empty")
        priority, index, item = heapq.heappop(self._heap)
        return item
    
    def peek(self) -> Any:
        """Return lowest priority item without removing - O(1)"""
        if not self._heap:
            raise IndexError("Priority queue is empty")
        return self._heap[0][2]
    
    def __len__(self) -> int:
        return len(self._heap)
    
    def __bool__(self) -> bool:
        return bool(self._heap)


# ═══════════════════════════════════════════════════════════════════════════
# USAGE EXAMPLE
# ═══════════════════════════════════════════════════════════════════════════

pq = PriorityQueue()

# Hospital emergency room simulation
pq.push("Headache", priority=3)        # Low priority
pq.push("Heart Attack", priority=1)    # Highest priority!
pq.push("Broken Arm", priority=2)      # Medium priority
pq.push("Fever", priority=3)           # Low priority (after Headache due to FIFO)

print("Treatment order:")
while pq:
    print(f"  → {pq.pop()}")

# Output:
# Treatment order:
#   → Heart Attack
#   → Broken Arm
#   → Headache
#   → Fever
```

---

# 4.3 Lazy Deletion Pattern

## 4.3.1 The Problem

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    THE DELETION PROBLEM                                   ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  Standard heap does NOT efficiently support:                              ║
║                                                                           ║
║  1. Delete arbitrary element by value                                     ║
║     - Need O(n) to find the element first!                               ║
║                                                                           ║
║  2. Update element's priority                                             ║
║     - Need to find it first, then restructure                            ║
║                                                                           ║
║  3. Invalidate elements that become "stale"                               ║
║     - Common in sliding window problems                                   ║
║                                                                           ║
║  SOLUTION: LAZY DELETION                                                  ║
║  ═══════════════════════════                                              ║
║  Instead of removing immediately:                                         ║
║  • Mark elements as "deleted"                                             ║
║  • Skip marked elements during pop/peek                                   ║
║  • Actual removal happens lazily when element reaches top                 ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 4.3.2 Visual Explanation

```
SCENARIO: Sliding window - need to remove element '3' from middle of heap

EAGER DELETION (Standard approach):
═══════════════════════════════════

Step 1: Find '3'         Step 2: Remove & Fix
        ↓ O(n) search!
       [1]                      [1]
      /   \                    /   \
    [3]   [2]     →          [4]   [2]    Need to heapify!
   /   \                     /
  [5]  [4]                 [5]

Time: O(n) find + O(log n) restructure = O(n)


LAZY DELETION (Our pattern):
════════════════════════════

Step 1: Mark '3' as deleted    Step 2: Continue normally
        (Just add to set)
                                       [1]
deleted = {3}                         /   \
                                    [3]   [2]   ← '3' still in heap!
       [1]                          /   \       but marked deleted
      /   \                       [5]  [4]
    [3]   [2]
   /   \
  [5]  [4]

Time: O(1)!

Step 3: When '3' becomes root during pop()

pop() called:
  while heap[0] in deleted:     # '1' not deleted, return it
      heappop()                 
  return heappop()              # returns 1

Later, when 1 and 2 are gone:

       [3] ← Now at root, but deleted!
      /   \
    [5]   [4]

pop() called:
  while heap[0] in deleted:     # '3' IS deleted!
      heappop()                 # Remove '3' NOW
  return heappop()              # Return '4'

       [4] ← Actual result
      /
    [5]
```

## 4.3.3 Complete Lazy Deletion Implementation

```python
import heapq
from collections import Counter

# ═══════════════════════════════════════════════════════════════════════════
# LAZY DELETION MIN-HEAP
# ═══════════════════════════════════════════════════════════════════════════

class LazyMinHeap:
    """
    Min-heap supporting O(1) lazy deletion of arbitrary elements.
    
    Key insight: We don't remove elements immediately. Instead:
    1. Mark them as deleted in a counter
    2. Skip them when they bubble to the top
    
    Trade-off: 
    - Deletion becomes O(1) instead of O(n)
    - But heap may contain "ghost" elements using extra space
    - pop/peek may need to clean multiple deleted elements
    
    Use cases:
    - Sliding window maximum/minimum
    - Dynamic median with removals
    - Any scenario where elements become invalid
    """
    
    def __init__(self):
        self._heap = []
        self._deleted = Counter()  # {value: count of pending deletions}
        self._size = 0             # Actual size (excluding deleted)
    
    def push(self, val):
        """Add element to heap - O(log n)"""
        heapq.heappush(self._heap, val)
        self._size += 1
    
    def pop(self):
        """Remove and return minimum - O(log n) amortized"""
        self._clean_top()
        if not self._heap:
            raise IndexError("Heap is empty")
        self._size -= 1
        return heapq.heappop(self._heap)
    
    def peek(self):
        """Return minimum without removing - O(1) amortized"""
        self._clean_top()
        if not self._heap:
            raise IndexError("Heap is empty")
        return self._heap[0]
    
    def remove(self, val):
        """
        Mark element for lazy deletion - O(1)
        
        Note: Assumes val exists in heap. 
        For safety, track valid elements separately.
        """
        self._deleted[val] += 1
        self._size -= 1
    
    def _clean_top(self):
        """Remove all deleted elements from the top of heap"""
        while self._heap and self._deleted[self._heap[0]] > 0:
            self._deleted[self._heap[0]] -= 1
            if self._deleted[self._heap[0]] == 0:
                del self._deleted[self._heap[0]]
            heapq.heappop(self._heap)
    
    def __len__(self):
        return self._size
    
    def __bool__(self):
        return self._size > 0


# ═══════════════════════════════════════════════════════════════════════════
# LAZY DELETION MAX-HEAP
# ═══════════════════════════════════════════════════════════════════════════

class LazyMaxHeap:
    """Max-heap with lazy deletion using negation"""
    
    def __init__(self):
        self._heap = []
        self._deleted = Counter()
        self._size = 0
    
    def push(self, val):
        heapq.heappush(self._heap, -val)  # Negate for max-heap
        self._size += 1
    
    def pop(self):
        self._clean_top()
        if not self._heap:
            raise IndexError("Heap is empty")
        self._size -= 1
        return -heapq.heappop(self._heap)  # Negate back
    
    def peek(self):
        self._clean_top()
        if not self._heap:
            raise IndexError("Heap is empty")
        return -self._heap[0]
    
    def remove(self, val):
        self._deleted[-val] += 1  # Store negated
        self._size -= 1
    
    def _clean_top(self):
        while self._heap and self._deleted[self._heap[0]] > 0:
            self._deleted[self._heap[0]] -= 1
            if self._deleted[self._heap[0]] == 0:
                del self._deleted[self._heap[0]]
            heapq.heappop(self._heap)
    
    def __len__(self):
        return self._size
    
    def __bool__(self):
        return self._size > 0
```

## 4.3.4 Real-World Example: Sliding Window Median

```python
# ═══════════════════════════════════════════════════════════════════════════
# SLIDING WINDOW MEDIAN USING LAZY DELETION
# ═══════════════════════════════════════════════════════════════════════════

def sliding_window_median(nums, k):
    """
    Find median of each sliding window of size k.
    
    Uses two heaps with lazy deletion:
    - max_heap: stores smaller half
    - min_heap: stores larger half
    
    Time: O(n log k) 
    Space: O(k) for heaps + O(k) for deleted markers
    """
    from collections import Counter
    
    result = []
    
    # Two heaps
    small = []  # max-heap (negated) - smaller half
    large = []  # min-heap - larger half
    
    # Track deleted elements
    deleted = Counter()
    
    def get_median():
        """Get median from the two heaps"""
        if len(small) > len(large):
            return -small[0]
        return (-small[0] + large[0]) / 2
    
    def clean_heap(heap, is_max_heap):
        """Remove deleted elements from top of heap"""
        while heap:
            val = -heap[0] if is_max_heap else heap[0]
            if deleted[val] > 0:
                deleted[val] -= 1
                heapq.heappop(heap)
            else:
                break
    
    def balance():
        """Ensure size property: len(small) == len(large) or len(large)+1"""
        # Clean tops first
        clean_heap(small, True)
        clean_heap(large, False)
        
        if len(small) > len(large) + 1:
            heapq.heappush(large, -heapq.heappop(small))
        elif len(large) > len(small):
            heapq.heappush(small, -heapq.heappop(large))
    
    # Process first window
    for i in range(k):
        heapq.heappush(small, -nums[i])
    
    # Balance: move half to large
    for _ in range(k // 2):
        heapq.heappush(large, -heapq.heappop(small))
    
    result.append(get_median())
    
    # Slide the window
    for i in range(k, len(nums)):
        outgoing = nums[i - k]  # Element leaving window
        incoming = nums[i]       # Element entering window
        
        # Mark outgoing for lazy deletion
        deleted[outgoing] += 1
        
        # Add incoming to appropriate heap
        if incoming <= -small[0]:
            heapq.heappush(small, -incoming)
        else:
            heapq.heappush(large, incoming)
        
        # Balance heaps
        balance()
        
        result.append(get_median())
    
    return result


# Example:
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(sliding_window_median(nums, k))
# Output: [1, -1, -1, 3, 5, 6]
```

---

# 4.4 Indexed Priority Queue (IPQ)

## 4.4.1 Motivation

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    WHY INDEXED PRIORITY QUEUE?                            ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  Standard heap cannot efficiently:                                        ║
║  • Check if element exists: O(n)                                         ║
║  • Update element's priority: O(n) find + O(log n) fix                   ║
║  • Delete by key: O(n)                                                   ║
║                                                                           ║
║  INDEXED PRIORITY QUEUE adds:                                             ║
║  • contains(key): O(1)                                                   ║
║  • decreaseKey(key, priority): O(log n)                                  ║
║  • increaseKey(key, priority): O(log n)                                  ║
║  • delete(key): O(log n)                                                 ║
║                                                                           ║
║  CRITICAL FOR:                                                            ║
║  • Dijkstra's Algorithm (shortest path)                                   ║
║  • Prim's Algorithm (minimum spanning tree)                               ║
║  • A* Search Algorithm                                                    ║
║  • Huffman Coding                                                         ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 4.4.2 How IPQ Works

```
INDEXED PRIORITY QUEUE STRUCTURE
════════════════════════════════

We maintain 3 synchronized data structures:

1. HEAP ARRAY (stores keys in heap order)
   ┌───┬───┬───┬───┬───┐
   │ C │ A │ D │ B │ E │  ← Keys arranged by priority
   └───┴───┴───┴───┴───┘
     0   1   2   3   4    ← Heap indices

2. KEY → INDEX MAP (find position of any key)
   ┌───────────────────┐
   │ A → 1             │
   │ B → 3             │
   │ C → 0             │  ← O(1) lookup!
   │ D → 2             │
   │ E → 4             │
   └───────────────────┘

3. KEY → PRIORITY MAP (store actual priorities)
   ┌───────────────────┐
   │ A → 5             │
   │ B → 15            │
   │ C → 3  ← minimum  │
   │ D → 10            │
   │ E → 20            │
   └───────────────────┘

AS A TREE (visualizing the heap):

            C(3)         ← Minimum priority at root
           /    \
        A(5)    D(10)
        /  \
     B(15) E(20)


DECREASE KEY OPERATION: decreaseKey("B", 1)
═══════════════════════════════════════════

Step 1: Find B's position using KEY→INDEX map
        B is at index 3

Step 2: Update B's priority
        KEY→PRIORITY["B"] = 1

Step 3: Heapify UP from index 3 (priority decreased!)

Before:                     After:
        C(3)                       B(1)  ← New minimum!
       /    \                     /    \
    A(5)    D(10)    →        C(3)    D(10)
    /  \                      /  \
 B(15) E(20)               A(5) E(20)
    ↑
 Now B(1)

Step 4: Update KEY→INDEX map during swaps
        B → 0, C → 1, A → 3
```

## 4.4.3 Complete IPQ Implementation

```python
# ═══════════════════════════════════════════════════════════════════════════
# INDEXED MIN PRIORITY QUEUE - FULL IMPLEMENTATION
# ═══════════════════════════════════════════════════════════════════════════

class IndexedMinPQ:
    """
    Indexed Min Priority Queue supporting:
    - O(1) contains
    - O(log n) insert, delete, decrease_key, increase_key
    - O(1) peek_key, peek_priority
    
    Keys must be hashable. Priorities must be comparable.
    """
    
    def __init__(self):
        self._heap = []           # List of keys in heap order
        self._key_to_idx = {}     # key → index in heap
        self._key_to_pri = {}     # key → priority
    
    # ══════════════ HELPER METHODS ══════════════
    
    def _parent(self, i):
        return (i - 1) // 2
    
    def _left(self, i):
        return 2 * i + 1
    
    def _right(self, i):
        return 2 * i + 2
    
    def _swap(self, i, j):
        """Swap elements and update index mapping"""
        # Update key → index mapping
        self._key_to_idx[self._heap[i]] = j
        self._key_to_idx[self._heap[j]] = i
        # Swap in heap
        self._heap[i], self._heap[j] = self._heap[j], self._heap[i]
    
    def _priority_at(self, i):
        """Get priority of element at heap index i"""
        return self._key_to_pri[self._heap[i]]
    
    def _heapify_up(self, i):
        """Bubble up element at index i"""
        while i > 0:
            parent = self._parent(i)
            if self._priority_at(i) < self._priority_at(parent):
                self._swap(i, parent)
                i = parent
            else:
                break
    
    def _heapify_down(self, i):
        """Bubble down element at index i"""
        n = len(self._heap)
        while True:
            smallest = i
            left, right = self._left(i), self._right(i)
            
            if left < n and self._priority_at(left) < self._priority_at(smallest):
                smallest = left
            if right < n and self._priority_at(right) < self._priority_at(smallest):
                smallest = right
            
            if smallest == i:
                break
            
            self._swap(i, smallest)
            i = smallest
    
    # ══════════════ PUBLIC API ══════════════
    
    def insert(self, key, priority):
        """Insert key with priority - O(log n)"""
        if key in self._key_to_idx:
            raise KeyError(f"Key '{key}' already exists. Use update() instead.")
        
        # Add to end of heap
        idx = len(self._heap)
        self._heap.append(key)
        self._key_to_idx[key] = idx
        self._key_to_pri[key] = priority
        
        # Restore heap property
        self._heapify_up(idx)
    
    def pop(self):
        """Remove and return (key, priority) with minimum priority - O(log n)"""
        if not self._heap:
            raise IndexError("Priority queue is empty")
        
        # Get minimum
        min_key = self._heap[0]
        min_priority = self._key_to_pri[min_key]
        
        # Move last to root
        last_key = self._heap.pop()
        if self._heap:
            self._heap[0] = last_key
            self._key_to_idx[last_key] = 0
            self._heapify_down(0)
        
        # Clean up removed key
        del self._key_to_idx[min_key]
        del self._key_to_pri[min_key]
        
        return min_key, min_priority
    
    def peek(self):
        """Return (key, priority) of minimum without removing - O(1)"""
        if not self._heap:
            raise IndexError("Priority queue is empty")
        key = self._heap[0]
        return key, self._key_to_pri[key]
    
    def contains(self, key):
        """Check if key exists - O(1)"""
        return key in self._key_to_idx
    
    def get_priority(self, key):
        """Get current priority of key - O(1)"""
        if key not in self._key_to_pri:
            raise KeyError(f"Key '{key}' not found")
        return self._key_to_pri[key]
    
    def decrease_key(self, key, new_priority):
        """Decrease priority of key - O(log n)"""
        if key not in self._key_to_idx:
            raise KeyError(f"Key '{key}' not found")
        
        old_priority = self._key_to_pri[key]
        if new_priority >= old_priority:
            raise ValueError(f"New priority {new_priority} must be less than {old_priority}")
        
        self._key_to_pri[key] = new_priority
        self._heapify_up(self._key_to_idx[key])
    
    def increase_key(self, key, new_priority):
        """Increase priority of key - O(log n)"""
        if key not in self._key_to_idx:
            raise KeyError(f"Key '{key}' not found")
        
        old_priority = self._key_to_pri[key]
        if new_priority <= old_priority:
            raise ValueError(f"New priority {new_priority} must be greater than {old_priority}")
        
        self._key_to_pri[key] = new_priority
        self._heapify_down(self._key_to_idx[key])
    
    def update(self, key, new_priority):
        """Update priority (decrease or increase) - O(log n)"""
        if key not in self._key_to_idx:
            raise KeyError(f"Key '{key}' not found")
        
        old_priority = self._key_to_pri[key]
        self._key_to_pri[key] = new_priority
        idx = self._key_to_idx[key]
        
        if new_priority < old_priority:
            self._heapify_up(idx)
        elif new_priority > old_priority:
            self._heapify_down(idx)
    
    def delete(self, key):
        """Delete key from queue - O(log n)"""
        if key not in self._key_to_idx:
            raise KeyError(f"Key '{key}' not found")
        
        idx = self._key_to_idx[key]
        
        # Swap with last element
        last_key = self._heap[-1]
        self._swap(idx, len(self._heap) - 1)
        
        # Remove last element
        self._heap.pop()
        del self._key_to_idx[key]
        del self._key_to_pri[key]
        
        # Restore heap property if we didn't delete the last element
        if idx < len(self._heap):
            # Could need up or down depending on relative priorities
            old_priority = self._key_to_pri[last_key]
            self._heapify_up(idx)
            self._heapify_down(idx)
    
    def __len__(self):
        return len(self._heap)
    
    def __bool__(self):
        return bool(self._heap)
    
    def __contains__(self, key):
        return self.contains(key)


# ═══════════════════════════════════════════════════════════════════════════
# USAGE EXAMPLE: DIJKSTRA'S ALGORITHM
# ═══════════════════════════════════════════════════════════════════════════

def dijkstra_with_ipq(graph, start):
    """
    Dijkstra's shortest path using Indexed Priority Queue.
    
    graph: dict of {node: [(neighbor, weight), ...]}
    
    Time: O((V + E) log V) with IPQ
    """
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    
    pq = IndexedMinPQ()
    pq.insert(start, 0)
    
    while pq:
        u, d = pq.pop()
        
        # Skip if we've found better path
        if d > dist[u]:
            continue
        
        for v, weight in graph[u]:
            new_dist = dist[u] + weight
            
            if new_dist < dist[v]:
                dist[v] = new_dist
                
                if v in pq:
                    pq.decrease_key(v, new_dist)  # O(log V)!
                else:
                    pq.insert(v, new_dist)
    
    return dist


# Example graph:
graph = {
    'A': [('B', 4), ('C', 2)],
    'B': [('C', 1), ('D', 5)],
    'C': [('D', 8), ('E', 10)],
    'D': [('E', 2)],
    'E': []
}

print(dijkstra_with_ipq(graph, 'A'))
# Output: {'A': 0, 'B': 4, 'C': 2, 'D': 9, 'E': 11}
```

---

# 4.5 Summary

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         CHAPTER 4 SUMMARY                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  PRIORITY QUEUE                                                             │
│  • Abstract Data Type (ADT) - interface, not implementation                 │
│  • Heap is most common implementation                                       │
│  • Elements served by priority, not insertion order                         │
│                                                                             │
│  LAZY DELETION PATTERN                                                      │
│  • Mark deleted instead of removing - O(1)                                  │
│  • Clean during pop/peek operations                                         │
│  • Use Counter to handle duplicates                                         │
│  • Perfect for: sliding window, dynamic median                              │
│                                                                             │
│  INDEXED PRIORITY QUEUE                                                     │
│  • Adds: contains O(1), decrease_key O(log n), delete O(log n)             │
│  • Maintains: heap array + key→index map + key→priority map                │
│  • Critical for: Dijkstra, Prim, A* algorithms                             │
│                                                                             │
│  WHEN TO USE WHAT                                                           │
│  • Simple priority queue → Standard heap                                    │
│  • Need to invalidate elements → Lazy deletion                              │
│  • Need decrease_key/contains → Indexed PQ                                  │
│  • Many decrease_key ops → Consider Fibonacci heap                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

**Next: Chapter 5 - Classic Heap Patterns** →
