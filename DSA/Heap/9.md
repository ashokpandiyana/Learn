# Chapter 9: Interview Questions Bank
## Comprehensive Problem Collection with Solutions

---

# 9.1 Question Categorization

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    INTERVIEW QUESTIONS BY PATTERN                         ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  PATTERN              │ DIFFICULTY │ FREQUENCY │ EXAMPLE PROBLEMS         ║
║  ─────────────────────┼────────────┼───────────┼────────────────────────  ║
║  Top K Elements       │  Easy-Med  │   ★★★★★   │ LC 215, 347, 692        ║
║  Two Heaps (Median)   │   Medium   │   ★★★★☆   │ LC 295, 480             ║
║  Merge K Sorted       │   Medium   │   ★★★★☆   │ LC 23, 378, 373         ║
║  Scheduling           │  Med-Hard  │   ★★★☆☆   │ LC 253, 621, 767        ║
║  Graph + Heap         │   Medium   │   ★★★★☆   │ LC 743, 787, 1631       ║
║  Greedy + Heap        │    Hard    │   ★★★☆☆   │ LC 502, 857, 1383       ║
║  Simulation           │   Medium   │   ★★☆☆☆   │ LC 1046, 703            ║
║  ─────────────────────┼────────────┼───────────┼────────────────────────  ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

---

# 9.2 Easy Problems

## 9.2.1 Last Stone Weight (LC 1046)

```python
"""
PROBLEM: Last Stone Weight
═══════════════════════════════════════════════════════════════════════════

We have a collection of stones, each stone has a positive integer weight.
Each turn, we choose the two heaviest stones and smash them together.
If x == y, both stones are destroyed.
If x != y, the stone of weight x is destroyed, and the stone of weight y 
has new weight y - x.
Return the weight of the last remaining stone (or 0 if none).

Example: stones = [2,7,4,1,8,1]
Output: 1

Explanation:
- Smash 7 and 8, get 8-7=1 → [2,4,1,1,1]
- Smash 2 and 4, get 4-2=2 → [2,1,1,1]
- Smash 2 and 1, get 2-1=1 → [1,1,1]
- Smash 1 and 1, both destroyed → [1]
- Return 1
"""

import heapq

def lastStoneWeight(stones):
    """
    Time: O(n log n)
    Space: O(n)
    
    Pattern: Simulation with Max-Heap
    """
    # Convert to max-heap (negate values)
    heap = [-s for s in stones]
    heapq.heapify(heap)
    
    while len(heap) > 1:
        # Get two heaviest
        first = -heapq.heappop(heap)
        second = -heapq.heappop(heap)
        
        # If different, push the remainder
        if first != second:
            heapq.heappush(heap, -(first - second))
    
    return -heap[0] if heap else 0


# Test
print(lastStoneWeight([2,7,4,1,8,1]))  # 1
```

## 9.2.2 Kth Largest Element in Stream (LC 703)

```python
"""
PROBLEM: Kth Largest Element in a Stream
═══════════════════════════════════════════════════════════════════════════

Design a class to find the kth largest element in a stream.

Note that it is the kth largest element in sorted order, not the kth 
distinct element.

Example:
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // returns 4
kthLargest.add(5);   // returns 5
kthLargest.add(10);  // returns 5
kthLargest.add(9);   // returns 8
kthLargest.add(4);   // returns 8
"""

import heapq

class KthLargest:
    """
    Time: 
      - __init__: O(n log k)
      - add: O(log k)
    Space: O(k)
    
    Pattern: Min-Heap of size K
    
    Key Insight: Kth largest = smallest in top-k = root of min-heap of size k
    """
    
    def __init__(self, k, nums):
        self.k = k
        self.heap = []
        
        for num in nums:
            self._add_to_heap(num)
    
    def _add_to_heap(self, val):
        if len(self.heap) < self.k:
            heapq.heappush(self.heap, val)
        elif val > self.heap[0]:
            heapq.heapreplace(self.heap, val)
    
    def add(self, val):
        self._add_to_heap(val)
        return self.heap[0]


# Test
kl = KthLargest(3, [4, 5, 8, 2])
print(kl.add(3))   # 4
print(kl.add(5))   # 5
print(kl.add(10))  # 5
print(kl.add(9))   # 8
```

## 9.2.3 Relative Ranks (LC 506)

```python
"""
PROBLEM: Relative Ranks
═══════════════════════════════════════════════════════════════════════════

Given an integer array score of size n where score[i] is the score of 
the ith athlete. Return an array answer of size n where answer[i] is 
the rank of the ith athlete.

The top 3 get "Gold Medal", "Silver Medal", "Bronze Medal".
Others get their placement number as a string.

Example: score = [5,4,3,2,1]
Output: ["Gold Medal","Silver Medal","Bronze Medal","4","5"]
"""

import heapq

def findRelativeRanks(score):
    """
    Time: O(n log n)
    Space: O(n)
    
    Pattern: Max-Heap with index tracking
    """
    n = len(score)
    
    # Max-heap: (-score, index)
    heap = [(-s, i) for i, s in enumerate(score)]
    heapq.heapify(heap)
    
    result = [""] * n
    medals = ["Gold Medal", "Silver Medal", "Bronze Medal"]
    rank = 0
    
    while heap:
        _, idx = heapq.heappop(heap)
        
        if rank < 3:
            result[idx] = medals[rank]
        else:
            result[idx] = str(rank + 1)
        
        rank += 1
    
    return result


# Test
print(findRelativeRanks([5,4,3,2,1]))
# ["Gold Medal","Silver Medal","Bronze Medal","4","5"]
```

---

# 9.3 Medium Problems

## 9.3.1 Kth Largest Element in Array (LC 215)

```python
"""
PROBLEM: Kth Largest Element in an Array
═══════════════════════════════════════════════════════════════════════════

Given an integer array nums and an integer k, return the kth largest 
element in the array.

Example 1: nums = [3,2,1,5,6,4], k = 2
Output: 5

Example 2: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
"""

import heapq

def findKthLargest(nums, k):
    """
    Approach 1: Min-Heap of size k
    
    Time: O(n log k)
    Space: O(k)
    """
    heap = []
    
    for num in nums:
        heapq.heappush(heap, num)
        if len(heap) > k:
            heapq.heappop(heap)
    
    return heap[0]


def findKthLargest_v2(nums, k):
    """
    Approach 2: Use heapq.nlargest
    
    Time: O(n log k)
    Space: O(k)
    """
    return heapq.nlargest(k, nums)[-1]


def findKthLargest_v3(nums, k):
    """
    Approach 3: Max-heap, extract k times
    
    Time: O(n + k log n)
    Space: O(n)
    """
    heap = [-x for x in nums]
    heapq.heapify(heap)  # O(n)
    
    for _ in range(k - 1):
        heapq.heappop(heap)
    
    return -heap[0]


# Test
print(findKthLargest([3,2,1,5,6,4], 2))  # 5
```

## 9.3.2 Top K Frequent Elements (LC 347)

```python
"""
PROBLEM: Top K Frequent Elements
═══════════════════════════════════════════════════════════════════════════

Given an integer array nums and an integer k, return the k most frequent 
elements. You may return the answer in any order.

Example: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
"""

import heapq
from collections import Counter

def topKFrequent(nums, k):
    """
    Approach 1: Min-Heap of size k
    
    Time: O(n log k)
    Space: O(n)
    """
    freq = Counter(nums)
    
    # Min-heap: (frequency, element)
    heap = []
    
    for num, count in freq.items():
        heapq.heappush(heap, (count, num))
        if len(heap) > k:
            heapq.heappop(heap)
    
    return [num for count, num in heap]


def topKFrequent_v2(nums, k):
    """
    Approach 2: Bucket Sort (O(n) time!)
    
    Time: O(n)
    Space: O(n)
    """
    freq = Counter(nums)
    
    # Bucket: index = frequency, value = list of numbers with that frequency
    buckets = [[] for _ in range(len(nums) + 1)]
    
    for num, count in freq.items():
        buckets[count].append(num)
    
    result = []
    for i in range(len(buckets) - 1, -1, -1):
        for num in buckets[i]:
            result.append(num)
            if len(result) == k:
                return result
    
    return result


# Test
print(topKFrequent([1,1,1,2,2,3], 2))  # [1, 2]
```

## 9.3.3 Find Median from Data Stream (LC 295)

```python
"""
PROBLEM: Find Median from Data Stream
═══════════════════════════════════════════════════════════════════════════

The median is the middle value in an ordered integer list.
If the size is even, there is no middle value, so the median is the 
mean of the two middle values.

Implement MedianFinder class:
- MedianFinder() initializes the MedianFinder object.
- void addNum(int num) adds the integer num to the data structure.
- double findMedian() returns the median of all elements so far.
"""

import heapq

class MedianFinder:
    """
    Time: 
      - addNum: O(log n)
      - findMedian: O(1)
    Space: O(n)
    
    Pattern: Two Heaps
    - small (max-heap): smaller half of numbers
    - large (min-heap): larger half of numbers
    
    Invariants:
    - All elements in small ≤ all elements in large
    - |len(small) - len(large)| ≤ 1
    """
    
    def __init__(self):
        self.small = []  # Max-heap (negated)
        self.large = []  # Min-heap
    
    def addNum(self, num: int) -> None:
        # Decide which heap to add to
        if not self.large or num >= self.large[0]:
            heapq.heappush(self.large, num)
        else:
            heapq.heappush(self.small, -num)
        
        # Rebalance
        if len(self.large) > len(self.small) + 1:
            heapq.heappush(self.small, -heapq.heappop(self.large))
        elif len(self.small) > len(self.large) + 1:
            heapq.heappush(self.large, -heapq.heappop(self.small))
    
    def findMedian(self) -> float:
        if len(self.small) > len(self.large):
            return -self.small[0]
        elif len(self.large) > len(self.small):
            return self.large[0]
        else:
            return (-self.small[0] + self.large[0]) / 2.0


# Test
mf = MedianFinder()
mf.addNum(1)
mf.addNum(2)
print(mf.findMedian())  # 1.5
mf.addNum(3)
print(mf.findMedian())  # 2.0
```

## 9.3.4 Merge K Sorted Lists (LC 23)

```python
"""
PROBLEM: Merge K Sorted Lists
═══════════════════════════════════════════════════════════════════════════

You are given an array of k linked-lists lists, each linked-list is 
sorted in ascending order.

Merge all the linked-lists into one sorted linked-list and return it.

Example: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
"""

import heapq

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists):
    """
    Time: O(N log k) where N = total nodes, k = number of lists
    Space: O(k) for heap
    
    Pattern: K-way Merge with Min-Heap
    """
    # Heap: (value, list_index, node)
    # list_index is tiebreaker (nodes aren't comparable)
    heap = []
    
    for i, lst in enumerate(lists):
        if lst:
            heapq.heappush(heap, (lst.val, i, lst))
    
    dummy = ListNode(0)
    current = dummy
    
    while heap:
        val, i, node = heapq.heappop(heap)
        current.next = node
        current = current.next
        
        if node.next:
            heapq.heappush(heap, (node.next.val, i, node.next))
    
    return dummy.next


# Helper to create and print linked lists
def create_list(arr):
    dummy = ListNode(0)
    curr = dummy
    for val in arr:
        curr.next = ListNode(val)
        curr = curr.next
    return dummy.next

def print_list(head):
    result = []
    while head:
        result.append(head.val)
        head = head.next
    return result

# Test
lists = [create_list([1,4,5]), create_list([1,3,4]), create_list([2,6])]
result = mergeKLists(lists)
print(print_list(result))  # [1, 1, 2, 3, 4, 4, 5, 6]
```

## 9.3.5 Task Scheduler (LC 621)

```python
"""
PROBLEM: Task Scheduler
═══════════════════════════════════════════════════════════════════════════

Given a characters array tasks representing CPU tasks, and an integer n 
representing the cooldown period between two same tasks.

Return the minimum number of intervals the CPU needs to complete all tasks.

Example: tasks = ["A","A","A","B","B","B"], n = 2
Output: 8
Explanation: A -> B -> idle -> A -> B -> idle -> A -> B
"""

import heapq
from collections import Counter, deque

def leastInterval(tasks, n):
    """
    Approach 1: Simulation with Heap
    
    Time: O(total_tasks * n)
    Space: O(26) = O(1)
    """
    freq = Counter(tasks)
    
    # Max-heap of frequencies
    heap = [-count for count in freq.values()]
    heapq.heapify(heap)
    
    time = 0
    cooldown = deque()  # (available_time, count)
    
    while heap or cooldown:
        time += 1
        
        if heap:
            count = heapq.heappop(heap) + 1  # Process task (count += 1 bc negated)
            if count < 0:
                cooldown.append((time + n, count))
        
        if cooldown and cooldown[0][0] == time:
            heapq.heappush(heap, cooldown.popleft()[1])
    
    return time


def leastInterval_math(tasks, n):
    """
    Approach 2: Mathematical (Optimal)
    
    Time: O(n)
    Space: O(26) = O(1)
    
    The most frequent task determines the structure.
    """
    freq = Counter(tasks)
    max_freq = max(freq.values())
    count_max = sum(1 for f in freq.values() if f == max_freq)
    
    # Formula: (max_freq - 1) * (n + 1) + count_max
    # But we need at least len(tasks) if no idle needed
    return max((max_freq - 1) * (n + 1) + count_max, len(tasks))


# Test
print(leastInterval(["A","A","A","B","B","B"], 2))  # 8
print(leastInterval_math(["A","A","A","B","B","B"], 2))  # 8
```

## 9.3.6 Reorganize String (LC 767)

```python
"""
PROBLEM: Reorganize String
═══════════════════════════════════════════════════════════════════════════

Given a string s, rearrange the characters of s so that any two adjacent 
characters are not the same.

Return any possible rearrangement or "" if not possible.

Example 1: s = "aab"
Output: "aba"

Example 2: s = "aaab"
Output: ""
"""

import heapq
from collections import Counter

def reorganizeString(s):
    """
    Time: O(n log k) where k = unique characters (≤ 26)
    Space: O(k)
    
    Pattern: Greedy with Max-Heap
    - Always place the most frequent character that isn't the previous one
    """
    freq = Counter(s)
    
    # Check if possible: max frequency can't exceed (n+1)/2
    max_freq = max(freq.values())
    if max_freq > (len(s) + 1) // 2:
        return ""
    
    # Max-heap: (-count, char)
    heap = [(-count, char) for char, count in freq.items()]
    heapq.heapify(heap)
    
    result = []
    prev_count, prev_char = 0, ''
    
    while heap:
        count, char = heapq.heappop(heap)
        result.append(char)
        
        # Push previous character back if it still has remaining count
        if prev_count < 0:
            heapq.heappush(heap, (prev_count, prev_char))
        
        # Update previous (decrement count)
        prev_count, prev_char = count + 1, char
    
    return ''.join(result)


# Test
print(reorganizeString("aab"))   # "aba"
print(reorganizeString("aaab"))  # ""
```

---

# 9.4 Hard Problems

## 9.4.1 Sliding Window Median (LC 480)

```python
"""
PROBLEM: Sliding Window Median
═══════════════════════════════════════════════════════════════════════════

Given an array of n integers, and a sliding window of size k which is 
moving from the very left of the array to the very right.

Return the median array for each window position.

Example: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [1.0,-1.0,-1.0,3.0,5.0,6.0]
"""

import heapq
from collections import defaultdict

def medianSlidingWindow(nums, k):
    """
    Time: O(n log k)
    Space: O(k)
    
    Pattern: Two Heaps with Lazy Deletion
    """
    small = []  # max-heap (negated)
    large = []  # min-heap
    deleted = defaultdict(int)
    small_size = large_size = 0
    
    def get_median():
        if k % 2:
            return float(-small[0])
        return (-small[0] + large[0]) / 2.0
    
    def clean(heap, is_small):
        while heap:
            val = -heap[0] if is_small else heap[0]
            if deleted[val]:
                deleted[val] -= 1
                heapq.heappop(heap)
            else:
                break
    
    def balance():
        nonlocal small_size, large_size
        clean(small, True)
        clean(large, False)
        
        while small_size > large_size + 1:
            val = -heapq.heappop(small)
            small_size -= 1
            heapq.heappush(large, val)
            large_size += 1
            clean(small, True)
        
        while large_size > small_size:
            val = heapq.heappop(large)
            large_size -= 1
            heapq.heappush(small, -val)
            small_size += 1
            clean(large, False)
    
    def add(val):
        nonlocal small_size, large_size
        if not large or val >= large[0]:
            heapq.heappush(large, val)
            large_size += 1
        else:
            heapq.heappush(small, -val)
            small_size += 1
        balance()
    
    def remove(val):
        nonlocal small_size, large_size
        deleted[val] += 1
        if val >= large[0]:
            large_size -= 1
        else:
            small_size -= 1
        balance()
    
    result = []
    
    for i in range(len(nums)):
        add(nums[i])
        
        if i >= k:
            remove(nums[i - k])
        
        if i >= k - 1:
            result.append(get_median())
    
    return result


# Test
print(medianSlidingWindow([1,3,-1,-3,5,3,6,7], 3))
# [1.0, -1.0, -1.0, 3.0, 5.0, 6.0]
```

## 9.4.2 IPO (LC 502)

```python
"""
PROBLEM: IPO
═══════════════════════════════════════════════════════════════════════════

You are given n projects where the ith project has profit profits[i] 
and a minimum capital of capital[i] is needed to start it.

Initially, you have w capital. When you finish a project, you will obtain 
its profit and the profit will be added to your total capital.

Pick a list of at most k distinct projects to maximize your final capital.

Example:
k = 2, w = 0
profits = [1,2,3], capital = [0,1,1]
Output: 4

Explanation: Start with project 0 (capital 0, profit 1) → w = 1
             Then project 2 (capital 1, profit 3) → w = 4
"""

import heapq

def findMaximizedCapital(k, w, profits, capital):
    """
    Time: O(n log n)
    Space: O(n)
    
    Pattern: Greedy with Two Data Structures
    - Sort projects by capital needed
    - Max-heap for profits of affordable projects
    """
    # Pair and sort by capital
    projects = sorted(zip(capital, profits))
    
    available = []  # Max-heap of profits
    i = 0
    n = len(profits)
    
    for _ in range(k):
        # Add all newly affordable projects
        while i < n and projects[i][0] <= w:
            heapq.heappush(available, -projects[i][1])
            i += 1
        
        if not available:
            break
        
        # Pick most profitable
        w += -heapq.heappop(available)
    
    return w


# Test
print(findMaximizedCapital(2, 0, [1,2,3], [0,1,1]))  # 4
```

## 9.4.3 Trapping Rain Water II (LC 407)

```python
"""
PROBLEM: Trapping Rain Water II
═══════════════════════════════════════════════════════════════════════════

Given an m x n integer matrix heightMap representing the height of each 
unit cell in a 2D elevation map, return the volume of water it can trap.

Example:
heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
Output: 4
"""

import heapq

def trapRainWater(heightMap):
    """
    Time: O(mn log(mn))
    Space: O(mn)
    
    Pattern: Multi-source BFS with Min-Heap
    """
    if not heightMap or not heightMap[0]:
        return 0
    
    m, n = len(heightMap), len(heightMap[0])
    if m < 3 or n < 3:
        return 0
    
    heap = []
    visited = [[False] * n for _ in range(m)]
    
    # Add boundary cells
    for i in range(m):
        for j in range(n):
            if i == 0 or i == m-1 or j == 0 or j == n-1:
                heapq.heappush(heap, (heightMap[i][j], i, j))
                visited[i][j] = True
    
    water = 0
    directions = [(0,1), (0,-1), (1,0), (-1,0)]
    
    while heap:
        h, r, c = heapq.heappop(heap)
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc]:
                visited[nr][nc] = True
                water += max(0, h - heightMap[nr][nc])
                heapq.heappush(heap, (max(h, heightMap[nr][nc]), nr, nc))
    
    return water


# Test
heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
print(trapRainWater(heightMap))  # 4
```

## 9.4.4 The Skyline Problem (LC 218)

```python
"""
PROBLEM: The Skyline Problem
═══════════════════════════════════════════════════════════════════════════

Given an array of buildings where buildings[i] = [left, right, height],
return the skyline formed by these buildings collectively.

Example:
buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]
Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
"""

import heapq

def getSkyline(buildings):
    """
    Time: O(n log n)
    Space: O(n)
    
    Pattern: Event Processing with Max-Heap
    """
    # Events: (x, type, height) or (x, -height, right) for start
    events = []
    
    for left, right, height in buildings:
        events.append((left, -height, right))  # Start: negative height
        events.append((right, 0, 0))           # End: height = 0
    
    events.sort()
    
    # Max-heap: (-height, right_edge)
    heap = [(0, float('inf'))]  # Ground level
    result = []
    
    for x, neg_h, right in events:
        # Remove buildings that have ended
        while heap[0][1] <= x:
            heapq.heappop(heap)
        
        # If start event, add building
        if neg_h != 0:
            heapq.heappush(heap, (neg_h, right))
        
        # Current max height
        max_height = -heap[0][0]
        
        # Record if height changed
        if not result or result[-1][1] != max_height:
            result.append([x, max_height])
    
    return result


# Test
buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]
print(getSkyline(buildings))
# [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
```

---

# 9.5 Problem-Pattern Quick Reference

```
╔═══════════════════════════════════════════════════════════════════════════════════╗
║                         PROBLEM-PATTERN QUICK REFERENCE                           ║
╠═══════════════════════════════════════════════════════════════════════════════════╣
║                                                                                   ║
║  LEETCODE #  │  PROBLEM NAME                    │  PATTERN            │ DIFFICULTY║
║  ────────────┼──────────────────────────────────┼─────────────────────┼───────────║
║     215      │  Kth Largest Element             │  Top K (Min-heap K) │   Medium  ║
║     347      │  Top K Frequent Elements         │  Top K              │   Medium  ║
║     295      │  Find Median from Stream         │  Two Heaps          │   Hard    ║
║     480      │  Sliding Window Median           │  Two Heaps + Lazy   │   Hard    ║
║      23      │  Merge K Sorted Lists            │  K-way Merge        │   Hard    ║
║     378      │  Kth Smallest in Matrix          │  K-way Merge        │   Medium  ║
║     373      │  K Pairs Smallest Sums           │  K-way Merge        │   Medium  ║
║     621      │  Task Scheduler                  │  Greedy + Heap      │   Medium  ║
║     767      │  Reorganize String               │  Greedy + Heap      │   Medium  ║
║     253      │  Meeting Rooms II                │  Interval + Heap    │   Medium  ║
║     502      │  IPO                             │  Two Structures     │   Hard    ║
║     857      │  Min Cost to Hire K Workers      │  Two Structures     │   Hard    ║
║    1383      │  Maximum Performance of Team     │  Two Structures     │   Hard    ║
║     743      │  Network Delay Time              │  Dijkstra           │   Medium  ║
║    1631      │  Path With Minimum Effort        │  Modified Dijkstra  │   Medium  ║
║     407      │  Trapping Rain Water II          │  Multi-source BFS   │   Hard    ║
║     218      │  The Skyline Problem             │  Event + Heap       │   Hard    ║
║     703      │  Kth Largest in Stream           │  Min-heap K         │   Easy    ║
║    1046      │  Last Stone Weight               │  Simulation         │   Easy    ║
║     692      │  Top K Frequent Words            │  Top K + Custom Cmp │   Medium  ║
║     973      │  K Closest Points to Origin      │  Top K              │   Medium  ║
║    1167      │  Min Cost to Connect Sticks      │  Greedy + Heap      │   Medium  ║
║     632      │  Smallest Range from K Lists     │  K-way Merge        │   Hard    ║
║     778      │  Swim in Rising Water            │  Modified Dijkstra  │   Hard    ║
║     786      │  Kth Smallest Prime Fraction     │  K-way Merge        │   Medium  ║
║  ────────────┼──────────────────────────────────┼─────────────────────┼───────────║
║                                                                                   ║
╚═══════════════════════════════════════════════════════════════════════════════════╝
```

---

**Next: Chapter 10 - Tips, Tricks & Common Mistakes** →
