# Chapter 5: Classic Heap Patterns
## Essential Patterns for Coding Interviews

---

# 5.1 Pattern Overview

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    CLASSIC HEAP PATTERNS                                  ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  1. TOP K ELEMENTS          → Heap of size K (opposite type)              ║
║  2. KTH LARGEST/SMALLEST    → Heap of size K                              ║
║  3. TWO HEAPS (MEDIAN)      → Max-heap + Min-heap                         ║
║  4. MERGE K SORTED          → Min-heap of K elements                      ║
║  5. TASK SCHEDULER          → Max-heap + cooldown queue                   ║
║  6. MEETING ROOMS           → Min-heap of end times                       ║
║                                                                           ║
║  Pattern Recognition Tips:                                                ║
║  • "Top K" / "K largest" / "K smallest" → Pattern 1 or 2                 ║
║  • "Median" / "Middle element" → Pattern 3                               ║
║  • "Merge sorted" / "K sorted lists" → Pattern 4                         ║
║  • "Schedule" / "Cooldown" / "Rearrange" → Pattern 5                     ║
║  • "Minimum rooms" / "Overlapping intervals" → Pattern 6                 ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

---

# 5.2 Pattern 1: Top K Elements

## 5.2.1 The Core Insight

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    TOP K PATTERN - KEY INSIGHT                            ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  To find K LARGEST elements  → Use MIN-HEAP of size K                     ║
║  To find K SMALLEST elements → Use MAX-HEAP of size K                     ║
║                                                                           ║
║  WHY OPPOSITE HEAP?                                                       ║
║                                                                           ║
║  K Largest with MIN-heap:                                                 ║
║  ┌─────────────────────────────────────────────────────────────────────┐ ║
║  │  • Min-heap root = smallest among top-K                             │ ║
║  │  • If new element > root: it belongs in top-K, pop root             │ ║
║  │  • If new element < root: it's not in top-K, ignore                 │ ║
║  │  • Root acts as "gatekeeper" for top-K club!                        │ ║
║  └─────────────────────────────────────────────────────────────────────┘ ║
║                                                                           ║
║  Time: O(n log k) instead of O(n log n)                                  ║
║  Space: O(k) instead of O(n)                                             ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 5.2.2 Visual Walkthrough: Top 3 Largest

```
Find Top 3 Largest from: [3, 1, 5, 12, 2, 11, 9]

STEP BY STEP (Min-heap of size 3):
══════════════════════════════════

Process 3:  heap = [3]           Size < 3, just add
            
Process 1:  heap = [1, 3]        Size < 3, just add
                 1
                /
               3

Process 5:  heap = [1, 3, 5]     Size = 3 now!
                 1
                / \
               3   5

Process 12: 12 > heap[0] (1)?    YES! Pop 1, Push 12
            heap = [3, 5, 12]    
                 3                ← New gatekeeper
                / \
               5  12

Process 2:  2 > heap[0] (3)?     NO! Ignore 2
            heap = [3, 5, 12]    (2 can't make top-3)

Process 11: 11 > heap[0] (3)?    YES! Pop 3, Push 11
            heap = [5, 11, 12]
                 5                ← New gatekeeper
                / \
              11  12

Process 9:  9 > heap[0] (5)?     YES! Pop 5, Push 9
            heap = [9, 11, 12]
                 9                ← Final gatekeeper
                / \
              11  12

RESULT: [9, 11, 12] are the top 3 largest! ✓
```

## 5.2.3 Implementation

```python
import heapq

# ═══════════════════════════════════════════════════════════════════════════
# TOP K LARGEST ELEMENTS
# ═══════════════════════════════════════════════════════════════════════════

def top_k_largest(nums, k):
    """
    Find k largest elements using min-heap of size k.
    
    Time: O(n log k)
    Space: O(k)
    
    Returns: List of k largest elements (unordered)
    """
    if k <= 0:
        return []
    if k >= len(nums):
        return nums[:]
    
    # Use min-heap
    heap = []
    
    for num in nums:
        if len(heap) < k:
            heapq.heappush(heap, num)
        elif num > heap[0]:
            heapq.heapreplace(heap, num)  # Pop smallest, push new
    
    return heap

# More concise using heapq.nlargest:
def top_k_largest_builtin(nums, k):
    return heapq.nlargest(k, nums)


# ═══════════════════════════════════════════════════════════════════════════
# TOP K SMALLEST ELEMENTS
# ═══════════════════════════════════════════════════════════════════════════

def top_k_smallest(nums, k):
    """
    Find k smallest elements using max-heap of size k.
    
    Time: O(n log k)
    Space: O(k)
    """
    if k <= 0:
        return []
    if k >= len(nums):
        return nums[:]
    
    # Use max-heap (negate values)
    heap = []
    
    for num in nums:
        if len(heap) < k:
            heapq.heappush(heap, -num)
        elif num < -heap[0]:  # num smaller than largest in heap
            heapq.heapreplace(heap, -num)
    
    return [-x for x in heap]


# ═══════════════════════════════════════════════════════════════════════════
# TOP K FREQUENT ELEMENTS (LeetCode 347)
# ═══════════════════════════════════════════════════════════════════════════

def top_k_frequent(nums, k):
    """
    Find k most frequent elements.
    
    Time: O(n log k)
    Space: O(n) for counter + O(k) for heap
    """
    from collections import Counter
    
    # Count frequencies
    freq = Counter(nums)
    
    # Use min-heap of size k based on frequency
    # Tuple: (frequency, element)
    heap = []
    
    for element, count in freq.items():
        if len(heap) < k:
            heapq.heappush(heap, (count, element))
        elif count > heap[0][0]:
            heapq.heapreplace(heap, (count, element))
    
    return [item[1] for item in heap]


# Example:
print(top_k_frequent([1,1,1,2,2,3], 2))  # [1, 2]
```

---

# 5.3 Pattern 2: Kth Largest/Smallest Element

## 5.3.1 Relationship to Top K

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    KTH ELEMENT PATTERN                                    ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  Kth LARGEST = smallest element in the set of K largest elements          ║
║              = ROOT of min-heap of size K                                 ║
║                                                                           ║
║  Kth SMALLEST = largest element in the set of K smallest elements         ║
║               = ROOT of max-heap of size K                                ║
║                                                                           ║
║  Example: [3, 2, 1, 5, 6, 4], K = 2                                      ║
║                                                                           ║
║  2nd Largest:                                                             ║
║    Top 2 largest = {6, 5}                                                 ║
║    2nd largest = min(6, 5) = 5 ✓                                         ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 5.3.2 Implementation

```python
import heapq

# ═══════════════════════════════════════════════════════════════════════════
# KTH LARGEST ELEMENT (LeetCode 215)
# ═══════════════════════════════════════════════════════════════════════════

def find_kth_largest(nums, k):
    """
    Find the kth largest element.
    
    Time: O(n log k)
    Space: O(k)
    """
    heap = []
    
    for num in nums:
        heapq.heappush(heap, num)
        if len(heap) > k:
            heapq.heappop(heap)  # Remove smallest
    
    return heap[0]  # Kth largest = smallest in top-k


# ═══════════════════════════════════════════════════════════════════════════
# KTH LARGEST IN STREAM (LeetCode 703)
# ═══════════════════════════════════════════════════════════════════════════

class KthLargest:
    """
    Design a class to find the kth largest element in a stream.
    
    Operations:
    - __init__: O(n log k) to build initial heap
    - add: O(log k) per addition
    """
    
    def __init__(self, k, nums):
        self.k = k
        self.heap = []
        
        for num in nums:
            self.add(num)
    
    def add(self, val):
        """Add value and return kth largest"""
        if len(self.heap) < self.k:
            heapq.heappush(self.heap, val)
        elif val > self.heap[0]:
            heapq.heapreplace(self.heap, val)
        
        return self.heap[0] if len(self.heap) == self.k else None


# Example:
kl = KthLargest(3, [4, 5, 8, 2])
print(kl.add(3))   # 4 (heap: [4, 5, 8])
print(kl.add(5))   # 5 (heap: [5, 5, 8])
print(kl.add(10))  # 5 (heap: [5, 8, 10])
print(kl.add(9))   # 8 (heap: [8, 9, 10])
print(kl.add(4))   # 8 (heap: [8, 9, 10], 4 rejected)
```

## 5.3.3 Comparison: Heap vs QuickSelect

```
╔═══════════════════════════════════════════════════════════════════════════╗
║              HEAP VS QUICKSELECT FOR KTH ELEMENT                          ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║                    │    HEAP         │   QUICKSELECT                      ║
║  ──────────────────┼─────────────────┼────────────────────                ║
║  Time (Average)    │   O(n log k)    │   O(n)                             ║
║  Time (Worst)      │   O(n log k)    │   O(n²)                            ║
║  Space             │   O(k)          │   O(1) or O(log n)                 ║
║  Modifies Input?   │   No            │   Yes (partitions)                 ║
║  Streaming?        │   Yes!          │   No                               ║
║  ──────────────────┼─────────────────┼────────────────────                ║
║                                                                           ║
║  USE HEAP WHEN:                                                           ║
║  • Data is streaming (continuous additions)                               ║
║  • k is much smaller than n                                               ║
║  • Cannot modify original array                                           ║
║  • Need consistent O(n log k) guarantee                                   ║
║                                                                           ║
║  USE QUICKSELECT WHEN:                                                    ║
║  • One-time query on static data                                          ║
║  • k is close to n/2                                                      ║
║  • Can modify array                                                       ║
║  • Average case O(n) is acceptable                                        ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

---

# 5.4 Pattern 3: Two Heaps (Median Finding)

## 5.4.1 The Core Insight

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    TWO HEAPS PATTERN                                      ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  Split elements into two halves using two heaps:                          ║
║                                                                           ║
║     ┌─────────────────┐    ┌─────────────────┐                           ║
║     │    MAX-HEAP     │    │    MIN-HEAP     │                           ║
║     │  (smaller half) │    │  (larger half)  │                           ║
║     │                 │    │                 │                           ║
║     │   ┌───┐         │    │         ┌───┐   │                           ║
║     │   │MAX│←────────│────│────────→│MIN│   │                           ║
║     │   └───┘         │    │         └───┘   │                           ║
║     │    ↑            │    │            ↑    │                           ║
║     │  Largest of     │    │    Smallest of  │                           ║
║     │  smaller half   │    │    larger half  │                           ║
║     └─────────────────┘    └─────────────────┘                           ║
║                                                                           ║
║  INVARIANTS:                                                              ║
║  1. max_heap.top() ≤ min_heap.top()                                      ║
║  2. Size difference ≤ 1                                                   ║
║                                                                           ║
║  MEDIAN:                                                                  ║
║  • If sizes equal: (max_heap.top() + min_heap.top()) / 2                 ║
║  • If sizes differ: top of larger heap                                    ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 5.4.2 Visual Walkthrough

```
FIND MEDIAN FROM DATA STREAM: [5, 2, 3, 4, 1]

═══════════════════════════════════════════════════════════════════════════
Add 5:
═══════════════════════════════════════════════════════════════════════════

   MAX-HEAP (small)     MIN-HEAP (large)
        [5]                  []
        
   Sizes: 1 vs 0 → max_heap larger
   Median = 5

═══════════════════════════════════════════════════════════════════════════
Add 2:
═══════════════════════════════════════════════════════════════════════════

Step 1: Add to max_heap first
        max_heap = [5, 2] → top is 5

Step 2: Balance - move max to min_heap
        max_heap = [2], min_heap = [5]

   MAX-HEAP (small)     MIN-HEAP (large)
        [2]                  [5]
        
   Sizes: 1 vs 1 → equal
   Median = (2 + 5) / 2 = 3.5

═══════════════════════════════════════════════════════════════════════════
Add 3:
═══════════════════════════════════════════════════════════════════════════

Step 1: 3 ≤ min_heap.top (5)? 3 ≤ 5 → Add to max_heap
        max_heap = [3, 2] → top is 3

Step 2: Size check - max_heap has 2, min_heap has 1
        Difference is 1, that's OK!

   MAX-HEAP (small)     MIN-HEAP (large)
       [3]                   [5]
       / 
      2
        
   Sizes: 2 vs 1 → max_heap larger
   Median = 3

═══════════════════════════════════════════════════════════════════════════
Add 4:
═══════════════════════════════════════════════════════════════════════════

Step 1: 4 ≤ max_heap.top (3)? NO! → Add to min_heap
        min_heap = [4, 5]

Step 2: Size check - max_heap=2, min_heap=2 → balanced!

   MAX-HEAP (small)     MIN-HEAP (large)
       [3]                   [4]
       /                      \
      2                        5
        
   Median = (3 + 4) / 2 = 3.5

═══════════════════════════════════════════════════════════════════════════
Add 1:
═══════════════════════════════════════════════════════════════════════════

Step 1: 1 ≤ max_heap.top (3)? YES → Add to max_heap
        max_heap = [3, 2, 1]

Step 2: Size check - max_heap=3, min_heap=2
        Difference is 1, OK!

   MAX-HEAP (small)     MIN-HEAP (large)
       [3]                   [4]
       / \                    \
      2   1                    5
        
   Sorted: [1, 2, 3, 4, 5]
            ↑ small ↑  ↑ large ↑
                    ↑
                 Median = 3 ✓
```

## 5.4.3 Implementation

```python
import heapq

# ═══════════════════════════════════════════════════════════════════════════
# FIND MEDIAN FROM DATA STREAM (LeetCode 295)
# ═══════════════════════════════════════════════════════════════════════════

class MedianFinder:
    """
    Find median from a data stream.
    
    Approach: Two heaps
    - max_heap (small): stores smaller half, gives quick access to max
    - min_heap (large): stores larger half, gives quick access to min
    
    Time:
    - addNum: O(log n)
    - findMedian: O(1)
    
    Space: O(n)
    """
    
    def __init__(self):
        # Max-heap for smaller half (negate values)
        self.small = []
        # Min-heap for larger half
        self.large = []
    
    def addNum(self, num: int) -> None:
        # Step 1: Add to appropriate heap
        if not self.large or num > self.large[0]:
            heapq.heappush(self.large, num)
        else:
            heapq.heappush(self.small, -num)
        
        # Step 2: Balance heaps (size difference ≤ 1)
        if len(self.small) > len(self.large) + 1:
            # Move from small to large
            val = -heapq.heappop(self.small)
            heapq.heappush(self.large, val)
        elif len(self.large) > len(self.small) + 1:
            # Move from large to small
            val = heapq.heappop(self.large)
            heapq.heappush(self.small, -val)
    
    def findMedian(self) -> float:
        if len(self.small) > len(self.large):
            return -self.small[0]
        elif len(self.large) > len(self.small):
            return self.large[0]
        else:
            return (-self.small[0] + self.large[0]) / 2.0


# Example:
mf = MedianFinder()
mf.addNum(1)
mf.addNum(2)
print(mf.findMedian())  # 1.5
mf.addNum(3)
print(mf.findMedian())  # 2.0


# ═══════════════════════════════════════════════════════════════════════════
# SLIDING WINDOW MEDIAN (LeetCode 480)
# ═══════════════════════════════════════════════════════════════════════════

class SlidingWindowMedian:
    """
    Median of sliding window using two heaps with lazy deletion.
    """
    
    def __init__(self):
        self.small = []  # max-heap (negated)
        self.large = []  # min-heap
        self.deleted = {}  # lazy deletion tracking
        self.small_size = 0
        self.large_size = 0
    
    def _clean_top(self, heap, is_max_heap):
        """Remove invalid (deleted) elements from top"""
        while heap:
            val = -heap[0] if is_max_heap else heap[0]
            if self.deleted.get(val, 0) > 0:
                self.deleted[val] -= 1
                heapq.heappop(heap)
            else:
                break
    
    def _balance(self):
        """Ensure size difference ≤ 1"""
        self._clean_top(self.small, True)
        self._clean_top(self.large, False)
        
        while self.small_size > self.large_size + 1:
            val = -heapq.heappop(self.small)
            heapq.heappush(self.large, val)
            self.small_size -= 1
            self.large_size += 1
            self._clean_top(self.small, True)
        
        while self.large_size > self.small_size:
            val = heapq.heappop(self.large)
            heapq.heappush(self.small, -val)
            self.large_size -= 1
            self.small_size += 1
            self._clean_top(self.large, False)
    
    def add(self, num):
        if not self.large or num >= self.large[0]:
            heapq.heappush(self.large, num)
            self.large_size += 1
        else:
            heapq.heappush(self.small, -num)
            self.small_size += 1
        self._balance()
    
    def remove(self, num):
        self.deleted[num] = self.deleted.get(num, 0) + 1
        if num >= self.large[0]:
            self.large_size -= 1
        else:
            self.small_size -= 1
        self._balance()
    
    def get_median(self):
        self._clean_top(self.small, True)
        self._clean_top(self.large, False)
        
        if self.small_size > self.large_size:
            return float(-self.small[0])
        return (-self.small[0] + self.large[0]) / 2.0


def medianSlidingWindow(nums, k):
    sw = SlidingWindowMedian()
    result = []
    
    for i, num in enumerate(nums):
        sw.add(num)
        
        if i >= k:
            sw.remove(nums[i - k])
        
        if i >= k - 1:
            result.append(sw.get_median())
    
    return result


# Example:
print(medianSlidingWindow([1,3,-1,-3,5,3,6,7], 3))
# Output: [1.0, -1.0, -1.0, 3.0, 5.0, 6.0]
```

---

# 5.5 Pattern 4: Merge K Sorted Lists/Arrays

## 5.5.1 The Core Insight

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    MERGE K SORTED PATTERN                                 ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  PROBLEM: Merge K sorted lists/arrays into one sorted output              ║
║                                                                           ║
║  APPROACH: Min-heap of size K                                             ║
║  - Heap contains one element from each list (the current minimum)         ║
║  - Pop minimum, add to result, push next element from same list           ║
║                                                                           ║
║                                                                           ║
║      List 0: [1, 4, 7]         MIN-HEAP (size K=3)                        ║
║      List 1: [2, 5, 8]               ┌───┐                               ║
║      List 2: [3, 6, 9]               │ 1 │ ← from list 0                 ║
║                                      └───┘                                ║
║                                     /     \                               ║
║                                  ┌───┐   ┌───┐                           ║
║                                  │ 2 │   │ 3 │                           ║
║                                  └───┘   └───┘                           ║
║                                list 1    list 2                           ║
║                                                                           ║
║  Time: O(N log K) where N = total elements, K = number of lists           ║
║  Space: O(K) for heap                                                     ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 5.5.2 Visual Walkthrough

```
MERGE 3 SORTED LISTS:
List 0: [1, 4, 7]
List 1: [2, 5, 8]  
List 2: [3, 6, 9]

STEP-BY-STEP:
═════════════

Initial heap: [(1, 0, 0), (2, 1, 0), (3, 2, 0)]
              (value, list_idx, element_idx)
Result: []

─────────────────────────────────────────────────────────────────
Pop (1, 0, 0): value=1 from list 0
Result: [1]
Push next from list 0: (4, 0, 1)
Heap: [(2, 1, 0), (3, 2, 0), (4, 0, 1)]

         2
        / \
       3   4

─────────────────────────────────────────────────────────────────
Pop (2, 1, 0): value=2 from list 1
Result: [1, 2]
Push next from list 1: (5, 1, 1)
Heap: [(3, 2, 0), (4, 0, 1), (5, 1, 1)]

         3
        / \
       4   5

─────────────────────────────────────────────────────────────────
Pop (3, 2, 0): value=3 from list 2
Result: [1, 2, 3]
Push next from list 2: (6, 2, 1)
Heap: [(4, 0, 1), (5, 1, 1), (6, 2, 1)]

... continue until all lists exhausted ...

─────────────────────────────────────────────────────────────────
FINAL RESULT: [1, 2, 3, 4, 5, 6, 7, 8, 9] ✓
```

## 5.5.3 Implementation

```python
import heapq
from typing import List, Optional

# ═══════════════════════════════════════════════════════════════════════════
# MERGE K SORTED ARRAYS
# ═══════════════════════════════════════════════════════════════════════════

def merge_k_sorted_arrays(arrays: List[List[int]]) -> List[int]:
    """
    Merge k sorted arrays into one sorted array.
    
    Time: O(N log K) where N = total elements
    Space: O(K) for heap + O(N) for result
    """
    result = []
    
    # Initialize heap with first element from each array
    # Tuple: (value, array_index, element_index)
    heap = []
    
    for i, arr in enumerate(arrays):
        if arr:  # Skip empty arrays
            heapq.heappush(heap, (arr[0], i, 0))
    
    while heap:
        val, arr_idx, elem_idx = heapq.heappop(heap)
        result.append(val)
        
        # Push next element from same array
        next_idx = elem_idx + 1
        if next_idx < len(arrays[arr_idx]):
            next_val = arrays[arr_idx][next_idx]
            heapq.heappush(heap, (next_val, arr_idx, next_idx))
    
    return result


# ═══════════════════════════════════════════════════════════════════════════
# MERGE K SORTED LINKED LISTS (LeetCode 23)
# ═══════════════════════════════════════════════════════════════════════════

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]:
    """
    Merge k sorted linked lists.
    
    Time: O(N log K)
    Space: O(K)
    
    Note: We use index as tiebreaker since ListNode isn't comparable!
    """
    # Heap: (value, index, node)
    # Index prevents comparison of ListNode objects
    heap = []
    
    for i, node in enumerate(lists):
        if node:
            heapq.heappush(heap, (node.val, i, node))
    
    dummy = ListNode(0)
    current = dummy
    
    while heap:
        val, i, node = heapq.heappop(heap)
        current.next = node
        current = current.next
        
        if node.next:
            heapq.heappush(heap, (node.next.val, i, node.next))
    
    return dummy.next


# ═══════════════════════════════════════════════════════════════════════════
# SMALLEST RANGE COVERING ELEMENTS FROM K LISTS (LeetCode 632)
# ═══════════════════════════════════════════════════════════════════════════

def smallestRange(nums: List[List[int]]) -> List[int]:
    """
    Find the smallest range that includes at least one number from each list.
    
    Approach:
    - Use min-heap to track minimum across all lists
    - Track maximum separately
    - Range = [min, max] where we have one element from each list
    
    Time: O(N log K)
    Space: O(K)
    """
    # (value, list_index, element_index)
    heap = []
    current_max = float('-inf')
    
    # Initialize with first element from each list
    for i, arr in enumerate(nums):
        heapq.heappush(heap, (arr[0], i, 0))
        current_max = max(current_max, arr[0])
    
    result = [float('-inf'), float('inf')]
    
    while True:
        current_min, list_idx, elem_idx = heapq.heappop(heap)
        
        # Update result if current range is smaller
        if current_max - current_min < result[1] - result[0]:
            result = [current_min, current_max]
        
        # Move to next element in the same list
        next_idx = elem_idx + 1
        if next_idx >= len(nums[list_idx]):
            # One list exhausted - can't include all lists anymore
            break
        
        next_val = nums[list_idx][next_idx]
        heapq.heappush(heap, (next_val, list_idx, next_idx))
        current_max = max(current_max, next_val)
    
    return result


# Example:
nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
print(smallestRange(nums))  # [20, 24]
```

---

# 5.6 Pattern 5: Task Scheduler / Reorganize String

## 5.6.1 The Core Insight

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    TASK SCHEDULER PATTERN                                 ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  PROBLEM: Schedule tasks with cooldown between same task                  ║
║           OR rearrange string so same chars aren't adjacent               ║
║                                                                           ║
║  KEY INSIGHT: Process most frequent first!                                ║
║                                                                           ║
║  APPROACH:                                                                ║
║  1. Use MAX-HEAP ordered by frequency                                     ║
║  2. Pop most frequent, process it                                         ║
║  3. Hold it in "cooldown" for required time                               ║
║  4. After cooldown, push back to heap if remaining count > 0              ║
║                                                                           ║
║  Example: "aaabbc", no adjacent same chars                                ║
║                                                                           ║
║  MAX-HEAP by freq:    Process:    Hold:    Result:                        ║
║       a(3)            a           a(2)     "a"                            ║
║      /   \                                                                ║
║    b(2)  c(1)         b           b(1)     "ab"                           ║
║                       Push a(2) back                                      ║
║       a(2)            a           a(1)     "aba"                          ║
║      /                                                                    ║
║    c(1)               Push b(1) back                                      ║
║   ... continue ...                         "ababac" ✓                     ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 5.6.2 Implementation

```python
import heapq
from collections import Counter, deque

# ═══════════════════════════════════════════════════════════════════════════
# REORGANIZE STRING (LeetCode 767)
# ═══════════════════════════════════════════════════════════════════════════

def reorganizeString(s: str) -> str:
    """
    Rearrange string so no two adjacent characters are the same.
    
    Time: O(n log k) where k = unique characters (at most 26)
    Space: O(k)
    """
    freq = Counter(s)
    
    # Check if possible: most frequent can't exceed (n+1)/2
    max_freq = max(freq.values())
    if max_freq > (len(s) + 1) // 2:
        return ""
    
    # Max-heap: (-frequency, character)
    heap = [(-count, char) for char, count in freq.items()]
    heapq.heapify(heap)
    
    result = []
    prev_count, prev_char = 0, ''
    
    while heap:
        count, char = heapq.heappop(heap)
        result.append(char)
        
        # Push previous back if it has remaining count
        if prev_count < 0:
            heapq.heappush(heap, (prev_count, prev_char))
        
        # Current becomes previous (cooldown of 1)
        prev_count, prev_char = count + 1, char  # +1 because negated
    
    return ''.join(result)


# ═══════════════════════════════════════════════════════════════════════════
# TASK SCHEDULER (LeetCode 621)
# ═══════════════════════════════════════════════════════════════════════════

def leastInterval(tasks: List[str], n: int) -> int:
    """
    Find minimum time to complete all tasks with cooldown n between same tasks.
    
    Time: O(T * n) where T = total tasks in worst case
    Space: O(26) = O(1)
    """
    freq = Counter(tasks)
    
    # Max-heap of frequencies
    heap = [-count for count in freq.values()]
    heapq.heapify(heap)
    
    time = 0
    cooldown = deque()  # (available_time, remaining_count)
    
    while heap or cooldown:
        time += 1
        
        if heap:
            # Process most frequent task
            count = heapq.heappop(heap) + 1  # +1 because negated
            if count < 0:  # Still has remaining
                cooldown.append((time + n, count))
        
        # Check if any task is ready to be scheduled again
        if cooldown and cooldown[0][0] == time:
            _, count = cooldown.popleft()
            heapq.heappush(heap, count)
    
    return time


# ═══════════════════════════════════════════════════════════════════════════
# TASK SCHEDULER - MATHEMATICAL APPROACH (Optimal)
# ═══════════════════════════════════════════════════════════════════════════

def leastIntervalMath(tasks: List[str], n: int) -> int:
    """
    Mathematical O(n) solution.
    
    Insight: The most frequent task determines the structure.
    
    Example: tasks = [A,A,A,B,B,B,C,D], n = 2
    
    A _ _ A _ _ A       (A appears 3 times, needs 2 gaps)
    A B _ A B _ A B     (Fill B)
    A B C A B D A B     (Fill C, D)
    
    Formula:
    - max_freq = frequency of most common task
    - count_max = how many tasks have max_freq
    - min_length = (max_freq - 1) * (n + 1) + count_max
    - But actual length could be longer if many tasks
    
    Answer = max(min_length, total_tasks)
    """
    freq = Counter(tasks)
    max_freq = max(freq.values())
    count_max = sum(1 for f in freq.values() if f == max_freq)
    
    # Minimum based on most frequent task
    min_length = (max_freq - 1) * (n + 1) + count_max
    
    # If we have many tasks, no idle time needed
    return max(min_length, len(tasks))


# Example:
tasks = ["A","A","A","B","B","B"]
n = 2
print(leastInterval(tasks, n))  # 8: A->B->idle->A->B->idle->A->B
```

---

# 5.7 Pattern 6: Meeting Rooms / Intervals

## 5.7.1 The Core Insight

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    MEETING ROOMS PATTERN                                  ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  PROBLEM: Find minimum meeting rooms needed for all meetings              ║
║                                                                           ║
║  KEY INSIGHT:                                                             ║
║  - Sort by start time                                                     ║
║  - Use min-heap to track end times of ongoing meetings                    ║
║  - If new meeting starts after earliest end → reuse that room             ║
║  - Otherwise → need new room                                              ║
║                                                                           ║
║  Visual:                                                                  ║
║                                                                           ║
║  Meetings: [(0,30), (5,10), (15,20)]                                     ║
║                                                                           ║
║  Time:  0----5----10----15----20----25----30                             ║
║  Room1: [=============================]     (0-30)                        ║
║  Room2:      [====]                         (5-10)                        ║
║         (Can't reuse Room2 for 15-20? Check heap!)                       ║
║                                                                           ║
║  Heap tracks: earliest ending meeting                                     ║
║  At time 15: heap.top = 10 (Room2 free!) → reuse                         ║
║                                                                           ║
║  Room1: [=============================]                                   ║
║  Room2:      [====]     [====]                                           ║
║                                                                           ║
║  Max heap size = 2 rooms needed                                           ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 5.7.2 Implementation

```python
import heapq
from typing import List

# ═══════════════════════════════════════════════════════════════════════════
# MEETING ROOMS II (LeetCode 253)
# ═══════════════════════════════════════════════════════════════════════════

def minMeetingRooms(intervals: List[List[int]]) -> int:
    """
    Find minimum number of conference rooms required.
    
    Time: O(n log n) for sorting + O(n log n) for heap operations
    Space: O(n) for heap
    """
    if not intervals:
        return 0
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    # Min-heap of end times (rooms in use)
    rooms = []
    
    for start, end in intervals:
        # If earliest ending meeting is done, reuse that room
        if rooms and rooms[0] <= start:
            heapq.heappop(rooms)
        
        # Add current meeting's end time
        heapq.heappush(rooms, end)
    
    # Number of rooms = size of heap
    return len(rooms)


# ═══════════════════════════════════════════════════════════════════════════
# MEETING ROOMS II - DETAILED VERSION
# ═══════════════════════════════════════════════════════════════════════════

def minMeetingRoomsDetailed(intervals: List[List[int]]) -> int:
    """Version with step-by-step tracking for understanding"""
    if not intervals:
        return 0
    
    intervals.sort(key=lambda x: x[0])
    rooms = []  # min-heap of end times
    
    print("Processing meetings in order of start time:")
    print("-" * 50)
    
    for i, (start, end) in enumerate(intervals):
        print(f"\nMeeting {i+1}: [{start}, {end}]")
        print(f"  Current rooms (end times): {sorted(rooms)}")
        
        if rooms and rooms[0] <= start:
            freed_room = heapq.heappop(rooms)
            print(f"  Room with end time {freed_room} is free - reusing!")
        else:
            print(f"  No room available - allocating new room")
        
        heapq.heappush(rooms, end)
        print(f"  Rooms now: {sorted(rooms)} ({len(rooms)} rooms)")
    
    print(f"\nMinimum rooms needed: {len(rooms)}")
    return len(rooms)


# ═══════════════════════════════════════════════════════════════════════════
# CAR POOLING (LeetCode 1094)
# ═══════════════════════════════════════════════════════════════════════════

def carPooling(trips: List[List[int]], capacity: int) -> bool:
    """
    Can a car with given capacity complete all trips?
    
    trips[i] = [passengers, from, to]
    
    Similar to meeting rooms - track passengers at each point.
    
    Time: O(n log n)
    Space: O(n)
    """
    # Sort by pickup location
    trips.sort(key=lambda x: x[1])
    
    # Min-heap: (dropoff_location, passengers)
    heap = []
    current_passengers = 0
    
    for passengers, start, end in trips:
        # Drop off passengers whose destination <= current start
        while heap and heap[0][0] <= start:
            _, dropped = heapq.heappop(heap)
            current_passengers -= dropped
        
        # Pick up new passengers
        current_passengers += passengers
        if current_passengers > capacity:
            return False
        
        heapq.heappush(heap, (end, passengers))
    
    return True


# Example:
intervals = [[0,30], [5,10], [15,20]]
print(minMeetingRoomsDetailed(intervals))
# Output: 2
```

---

# 5.8 Summary

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         CHAPTER 5 SUMMARY                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  PATTERN 1: TOP K ELEMENTS                                                  │
│  • K largest → Min-heap of size K                                          │
│  • K smallest → Max-heap of size K                                         │
│  • Time: O(n log k)                                                        │
│                                                                             │
│  PATTERN 2: KTH ELEMENT                                                     │
│  • Kth largest = root of min-heap of size K                                │
│  • Good for streaming data                                                  │
│                                                                             │
│  PATTERN 3: TWO HEAPS (MEDIAN)                                              │
│  • Max-heap for smaller half, Min-heap for larger half                     │
│  • Maintain size balance (differ by at most 1)                             │
│  • Use lazy deletion for sliding window variant                            │
│                                                                             │
│  PATTERN 4: MERGE K SORTED                                                  │
│  • Min-heap of size K (one element per list)                               │
│  • Pop min, push next from same list                                       │
│  • Time: O(N log K)                                                        │
│                                                                             │
│  PATTERN 5: TASK SCHEDULER                                                  │
│  • Max-heap by frequency                                                   │
│  • Process most frequent first                                             │
│  • Use cooldown queue for waiting tasks                                    │
│                                                                             │
│  PATTERN 6: MEETING ROOMS                                                   │
│  • Sort by start time                                                      │
│  • Min-heap of end times                                                   │
│  • Heap size = rooms needed                                                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

**Next: Chapter 6 - Advanced Heap Patterns** →
