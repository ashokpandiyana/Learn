# Chapter 7: Specialized Heap Variants
## Beyond the Binary Heap

---

# 7.1 Overview of Heap Variants

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                       HEAP VARIANTS OVERVIEW                              ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  BINARY HEAP        - Standard, most common                               ║
║  D-ARY HEAP         - D children per node (generalized)                   ║
║  MIN-MAX HEAP       - O(1) find-min AND find-max                         ║
║  BINOMIAL HEAP      - Efficient merge operation                           ║
║  FIBONACCI HEAP     - O(1) amortized decrease-key                        ║
║  PAIRING HEAP       - Simpler alternative to Fibonacci                    ║
║  LEFTIST HEAP       - Mergeable heap with leftist property                ║
║  SKEW HEAP          - Self-adjusting leftist heap                         ║
║                                                                           ║
║  ┌────────────────────────────────────────────────────────────────────┐  ║
║  │ Interview Focus: Understand concepts of all, implement Binary      │  ║
║  │ Know when to use each variant and their trade-offs                 │  ║
║  └────────────────────────────────────────────────────────────────────┘  ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

---

# 7.2 D-ary Heap

## 7.2.1 Concept

A **D-ary heap** generalizes the binary heap by allowing each node to have **D children** instead of 2.

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                         D-ARY HEAP STRUCTURE                              ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  BINARY (D=2):              TERNARY (D=3):           4-ARY (D=4):         ║
║                                                                           ║
║        1                          1                       1               ║
║       / \                       / | \                  / | | \            ║
║      3   5                     3  5  7               3  5  7  9           ║
║     /\   /\                   /|\                   /|                    ║
║    7  9 11 13               9 11 13               11 13                   ║
║                                                                           ║
║  Height: log₂(n)            log₃(n)                log₄(n)               ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 7.2.2 Index Formulas

```python
# For D-ary heap (0-indexed):

def parent(i, d):
    """Parent of node at index i"""
    return (i - 1) // d

def kth_child(i, k, d):
    """k-th child (0-indexed) of node at index i"""
    return d * i + k + 1

def children_range(i, d, n):
    """Range of children indices for node at index i"""
    first_child = d * i + 1
    last_child = min(d * i + d, n - 1)
    return range(first_child, last_child + 1)
```

```
EXAMPLE: 3-ARY HEAP

Array: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
Index:  0  1  2  3  4   5   6   7   8   9

Tree Structure:
                    1 [0]
                 /  |  \
              3[1] 5[2] 7[3]
             /|\   /|\   |
           9 11 13 15 17 19
          [4][5][6][7][8][9]

Index Calculations (d=3):
• Parent of index 5: (5-1)//3 = 1 ✓ (value 3)
• Children of index 1: 3*1+1=4, 3*1+2=5, 3*1+3=6 → [4,5,6] ✓
• Parent of index 8: (8-1)//3 = 2 ✓ (value 5)
```

## 7.2.3 Trade-offs Analysis

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                      D-ARY HEAP TRADE-OFFS                                ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  As D increases:                                                          ║
║  ┌─────────────────────────────────────────────────────────────────────┐ ║
║  │  ↓ Tree height decreases: O(log_d n)                                │ ║
║  │  ↓ Fewer swaps during heapify-up (good for insert)                  │ ║
║  │  ↑ More comparisons per level in heapify-down                       │ ║
║  │  ↑ Cache performance may improve (shallower tree)                   │ ║
║  └─────────────────────────────────────────────────────────────────────┘ ║
║                                                                           ║
║  COMPLEXITY COMPARISON:                                                   ║
║  ┌───────────────┬─────────────────┬─────────────────────────────────┐  ║
║  │   Operation   │   Binary (d=2)  │        D-ary (d>2)              │  ║
║  ├───────────────┼─────────────────┼─────────────────────────────────┤  ║
║  │   Insert      │   O(log₂ n)     │   O(log_d n) - FASTER           │  ║
║  │   Extract     │   O(log₂ n)     │   O(d · log_d n) - SLOWER       │  ║
║  │   Decrease-key│   O(log₂ n)     │   O(log_d n) - FASTER           │  ║
║  └───────────────┴─────────────────┴─────────────────────────────────┘  ║
║                                                                           ║
║  OPTIMAL D:                                                               ║
║  • For Dijkstra (many decrease-key): d = E/V (edges per vertex)          ║
║  • For cache efficiency: d = 4 often works well                          ║
║  • For general use: d = 2 (binary) is usually fine                       ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 7.2.4 Implementation

```python
class DaryMinHeap:
    """
    D-ary Min Heap implementation.
    
    Useful when:
    - Many decrease-key operations (use larger d)
    - Memory hierarchy optimization (d=4 often good for cache)
    """
    
    def __init__(self, d=2):
        self.d = d
        self.heap = []
    
    def _parent(self, i):
        return (i - 1) // self.d
    
    def _children(self, i):
        """Return indices of all children of node i"""
        first = self.d * i + 1
        last = min(first + self.d, len(self.heap))
        return range(first, last)
    
    def _heapify_up(self, i):
        while i > 0:
            parent = self._parent(i)
            if self.heap[i] < self.heap[parent]:
                self.heap[i], self.heap[parent] = self.heap[parent], self.heap[i]
                i = parent
            else:
                break
    
    def _heapify_down(self, i):
        while True:
            smallest = i
            
            # Find smallest among node and all its children
            for child in self._children(i):
                if self.heap[child] < self.heap[smallest]:
                    smallest = child
            
            if smallest == i:
                break
            
            self.heap[i], self.heap[smallest] = self.heap[smallest], self.heap[i]
            i = smallest
    
    def push(self, val):
        """Insert element - O(log_d n)"""
        self.heap.append(val)
        self._heapify_up(len(self.heap) - 1)
    
    def pop(self):
        """Extract minimum - O(d · log_d n)"""
        if not self.heap:
            raise IndexError("Heap is empty")
        
        result = self.heap[0]
        last = self.heap.pop()
        
        if self.heap:
            self.heap[0] = last
            self._heapify_down(0)
        
        return result
    
    def peek(self):
        """Get minimum - O(1)"""
        if not self.heap:
            raise IndexError("Heap is empty")
        return self.heap[0]
    
    def __len__(self):
        return len(self.heap)


# Performance comparison
def compare_heaps():
    """Compare binary vs 4-ary heap performance"""
    import time
    import random
    
    data = [random.randint(1, 100000) for _ in range(100000)]
    
    # Binary heap
    binary = DaryMinHeap(d=2)
    start = time.time()
    for x in data:
        binary.push(x)
    while binary:
        binary.pop()
    binary_time = time.time() - start
    
    # 4-ary heap
    quaternary = DaryMinHeap(d=4)
    start = time.time()
    for x in data:
        quaternary.push(x)
    while quaternary:
        quaternary.pop()
    quaternary_time = time.time() - start
    
    print(f"Binary (d=2): {binary_time:.3f}s")
    print(f"4-ary (d=4):  {quaternary_time:.3f}s")
```

---

# 7.3 Min-Max Heap

## 7.3.1 Concept

A **Min-Max Heap** supports both **find-min** and **find-max** in O(1) time!

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                      MIN-MAX HEAP STRUCTURE                               ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  Alternating min and max levels:                                          ║
║                                                                           ║
║  Level 0 (MIN):           5         ← MINIMUM of entire heap             ║
║                         /   \                                             ║
║  Level 1 (MAX):       45     25     ← One of these is MAXIMUM            ║
║                      / \    / \                                           ║
║  Level 2 (MIN):    10  15  20  22   ← Each ≤ grandparent                 ║
║                    /\  /\                                                 ║
║  Level 3 (MAX):  40 35 30 28        ← Each ≥ grandparent                 ║
║                                                                           ║
║  PROPERTIES:                                                              ║
║  • Min levels: 0, 2, 4, ... (even)                                       ║
║  • Max levels: 1, 3, 5, ... (odd)                                        ║
║  • Node at min level: smaller than all descendants                        ║
║  • Node at max level: larger than all descendants                         ║
║                                                                           ║
║  OPERATIONS:                                                              ║
║  • find-min: O(1) - root                                                 ║
║  • find-max: O(1) - max of children of root                              ║
║  • insert: O(log n)                                                      ║
║  • delete-min: O(log n)                                                  ║
║  • delete-max: O(log n)                                                  ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 7.3.2 Level Determination

```python
def get_level(index):
    """
    Determine level of node at given index.
    Level = floor(log2(index + 1))
    """
    import math
    return int(math.log2(index + 1))

def is_min_level(index):
    """Check if index is at a min level (even level)"""
    return get_level(index) % 2 == 0

def is_max_level(index):
    """Check if index is at a max level (odd level)"""
    return get_level(index) % 2 == 1
```

```
INDEX TO LEVEL MAPPING:

Index:  0  1  2  3  4  5  6  7  8  9  10 11 12 13 14
Level:  0  1  1  2  2  2  2  3  3  3  3  3  3  3  3
Type:  MIN MAX MAX MIN MIN MIN MIN MAX MAX MAX MAX MAX MAX MAX MAX

Visual:
                          0
                        /   \
                       1     2
                     / \   / \
                    3   4 5   6
                   /\ /\ /\ /\
                  7 8 9...    14
```

## 7.3.3 Implementation

```python
class MinMaxHeap:
    """
    Min-Max Heap: O(1) find-min AND find-max
    
    Use cases:
    - Double-ended priority queue
    - Sliding window min AND max
    - Median maintenance (alternative to two heaps)
    """
    
    def __init__(self):
        self.heap = []
    
    def _parent(self, i):
        return (i - 1) // 2
    
    def _grandparent(self, i):
        return (i - 3) // 4
    
    def _left_child(self, i):
        return 2 * i + 1
    
    def _right_child(self, i):
        return 2 * i + 2
    
    def _has_parent(self, i):
        return i > 0
    
    def _has_grandparent(self, i):
        return i > 2
    
    def _is_min_level(self, i):
        """Even levels (0, 2, 4, ...) are min levels"""
        level = 0
        idx = i + 1
        while idx > 1:
            idx //= 2
            level += 1
        return level % 2 == 0
    
    def _swap(self, i, j):
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
    
    def _push_up(self, i):
        """Bubble up maintaining min-max property"""
        if not self._has_parent(i):
            return
        
        parent = self._parent(i)
        
        if self._is_min_level(i):
            # At min level
            if self.heap[i] > self.heap[parent]:
                # Larger than parent (max level) - swap and push up max
                self._swap(i, parent)
                self._push_up_max(parent)
            else:
                self._push_up_min(i)
        else:
            # At max level
            if self.heap[i] < self.heap[parent]:
                # Smaller than parent (min level) - swap and push up min
                self._swap(i, parent)
                self._push_up_min(parent)
            else:
                self._push_up_max(i)
    
    def _push_up_min(self, i):
        """Push up on min levels (compare with grandparent)"""
        while self._has_grandparent(i):
            gp = self._grandparent(i)
            if self.heap[i] < self.heap[gp]:
                self._swap(i, gp)
                i = gp
            else:
                break
    
    def _push_up_max(self, i):
        """Push up on max levels (compare with grandparent)"""
        while self._has_grandparent(i):
            gp = self._grandparent(i)
            if self.heap[i] > self.heap[gp]:
                self._swap(i, gp)
                i = gp
            else:
                break
    
    def _get_children_and_grandchildren(self, i):
        """Get all children and grandchildren indices"""
        result = []
        n = len(self.heap)
        
        # Children
        for child in [self._left_child(i), self._right_child(i)]:
            if child < n:
                result.append(child)
                # Grandchildren
                for gc in [self._left_child(child), self._right_child(child)]:
                    if gc < n:
                        result.append(gc)
        
        return result
    
    def _push_down(self, i):
        """Push down maintaining min-max property"""
        if self._is_min_level(i):
            self._push_down_min(i)
        else:
            self._push_down_max(i)
    
    def _push_down_min(self, i):
        """Push down on min level"""
        while True:
            descendants = self._get_children_and_grandchildren(i)
            if not descendants:
                break
            
            # Find minimum among descendants
            min_idx = min(descendants, key=lambda x: self.heap[x])
            
            if self.heap[min_idx] >= self.heap[i]:
                break
            
            # Is min_idx a grandchild?
            is_grandchild = min_idx > self._right_child(i)
            
            self._swap(i, min_idx)
            
            if is_grandchild:
                # Check against new parent
                parent = self._parent(min_idx)
                if self.heap[min_idx] > self.heap[parent]:
                    self._swap(min_idx, parent)
                i = min_idx
            else:
                break
    
    def _push_down_max(self, i):
        """Push down on max level"""
        while True:
            descendants = self._get_children_and_grandchildren(i)
            if not descendants:
                break
            
            # Find maximum among descendants
            max_idx = max(descendants, key=lambda x: self.heap[x])
            
            if self.heap[max_idx] <= self.heap[i]:
                break
            
            is_grandchild = max_idx > self._right_child(i)
            
            self._swap(i, max_idx)
            
            if is_grandchild:
                parent = self._parent(max_idx)
                if self.heap[max_idx] < self.heap[parent]:
                    self._swap(max_idx, parent)
                i = max_idx
            else:
                break
    
    # ═══════════════ PUBLIC API ═══════════════
    
    def push(self, val):
        """Insert element - O(log n)"""
        self.heap.append(val)
        self._push_up(len(self.heap) - 1)
    
    def find_min(self):
        """Get minimum - O(1)"""
        if not self.heap:
            raise IndexError("Heap is empty")
        return self.heap[0]
    
    def find_max(self):
        """Get maximum - O(1)"""
        if not self.heap:
            raise IndexError("Heap is empty")
        if len(self.heap) == 1:
            return self.heap[0]
        if len(self.heap) == 2:
            return self.heap[1]
        return max(self.heap[1], self.heap[2])
    
    def pop_min(self):
        """Remove and return minimum - O(log n)"""
        if not self.heap:
            raise IndexError("Heap is empty")
        
        result = self.heap[0]
        last = self.heap.pop()
        
        if self.heap:
            self.heap[0] = last
            self._push_down(0)
        
        return result
    
    def pop_max(self):
        """Remove and return maximum - O(log n)"""
        if not self.heap:
            raise IndexError("Heap is empty")
        if len(self.heap) <= 2:
            return self.heap.pop()
        
        # Find max among children of root
        max_idx = 1 if self.heap[1] >= self.heap[2] else 2
        result = self.heap[max_idx]
        
        last = self.heap.pop()
        if max_idx < len(self.heap):
            self.heap[max_idx] = last
            self._push_down(max_idx)
        
        return result
    
    def __len__(self):
        return len(self.heap)


# Example usage:
mmh = MinMaxHeap()
for x in [10, 5, 20, 3, 15, 25, 8]:
    mmh.push(x)

print(f"Min: {mmh.find_min()}")  # 3
print(f"Max: {mmh.find_max()}")  # 25
print(f"Pop min: {mmh.pop_min()}")  # 3
print(f"Pop max: {mmh.pop_max()}")  # 25
```

---

# 7.4 Binomial Heap

## 7.4.1 Concept

A **Binomial Heap** is a collection of **Binomial Trees** that supports efficient **merge** operations.

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                      BINOMIAL TREE STRUCTURE                              ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  Binomial Tree Bₖ:                                                        ║
║  • Has 2^k nodes                                                          ║
║  • Height is k                                                            ║
║  • Root has k children: B_{k-1}, B_{k-2}, ..., B_0                       ║
║                                                                           ║
║  B₀        B₁         B₂              B₃                                  ║
║                                                                           ║
║   ○        ○          ○               ○                                   ║
║            |         /|              /|\                                  ║
║            ○        ○ ○             ○ ○ ○                                 ║
║                     |              /|  |                                  ║
║                     ○             ○ ○  ○                                  ║
║                                   |                                       ║
║                                   ○                                       ║
║                                                                           ║
║  Nodes:   1         2          4               8                          ║
║  Height:  0         1          2               3                          ║
║                                                                           ║
║  BINOMIAL HEAP = Collection of binomial trees with:                       ║
║  • At most one tree of each order (like binary number!)                   ║
║  • Min-heap property within each tree                                     ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 7.4.2 Binary Representation Insight

```
EXAMPLE: Binomial Heap with 13 nodes

13 in binary = 1101 = 8 + 4 + 1 = 2³ + 2² + 2⁰

So we have: B₃ (8 nodes) + B₂ (4 nodes) + B₀ (1 node)

   B₀        B₂                    B₃
                                    
    3        1                      0
            / \                   / | \
           4   2                 5  7  6
           |                    /|  |
           8                   9 10 11
                               |
                              12

Heap roots linked: B₀ → B₂ → B₃
                    3 → 1  → 0

Minimum is among roots: min(3, 1, 0) = 0
```

## 7.4.3 Operations Complexity

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                  BINOMIAL HEAP COMPLEXITY                                 ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  Operation      │ Binary Heap │ Binomial Heap │ Notes                     ║
║  ───────────────┼─────────────┼───────────────┼─────────────────────────  ║
║  find-min       │    O(1)     │    O(log n)   │ Or O(1) with pointer      ║
║  insert         │  O(log n)   │  O(1) amort.  │ O(log n) worst            ║
║  delete-min     │  O(log n)   │    O(log n)   │                           ║
║  decrease-key   │  O(log n)   │    O(log n)   │                           ║
║  MERGE          │    O(n)     │    O(log n)   │ ← KEY ADVANTAGE!          ║
║  ───────────────┼─────────────┼───────────────┼─────────────────────────  ║
║                                                                           ║
║  Use Binomial Heap when: Frequent merge operations needed                 ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 7.4.4 Implementation (Simplified)

```python
class BinomialNode:
    """Node in a binomial tree"""
    def __init__(self, key):
        self.key = key
        self.degree = 0
        self.parent = None
        self.child = None    # Leftmost child
        self.sibling = None  # Right sibling


class BinomialHeap:
    """
    Binomial Heap with efficient merge.
    
    Key insight: Merging is like binary addition!
    """
    
    def __init__(self):
        self.head = None  # Pointer to first root
        self.min_node = None
    
    def _link(self, y, z):
        """Make y a child of z (both same degree)"""
        y.parent = z
        y.sibling = z.child
        z.child = y
        z.degree += 1
    
    def _merge_root_lists(self, h1, h2):
        """Merge two root lists by degree (like merge sort)"""
        if not h1:
            return h2
        if not h2:
            return h1
        
        # Start with smaller degree
        if h1.degree <= h2.degree:
            head = h1
            h1 = h1.sibling
        else:
            head = h2
            h2 = h2.sibling
        
        tail = head
        
        while h1 and h2:
            if h1.degree <= h2.degree:
                tail.sibling = h1
                h1 = h1.sibling
            else:
                tail.sibling = h2
                h2 = h2.sibling
            tail = tail.sibling
        
        tail.sibling = h1 if h1 else h2
        return head
    
    def _union(self, other):
        """Merge two binomial heaps"""
        # Merge root lists
        new_head = self._merge_root_lists(self.head, other.head)
        
        if not new_head:
            return
        
        # Consolidate trees of same degree
        prev = None
        curr = new_head
        next_node = curr.sibling
        
        while next_node:
            # Case 1 & 2: Different degrees or three same degrees
            if (curr.degree != next_node.degree or
                (next_node.sibling and next_node.sibling.degree == curr.degree)):
                prev = curr
                curr = next_node
            # Case 3 & 4: Two same degrees - link them
            elif curr.key <= next_node.key:
                curr.sibling = next_node.sibling
                self._link(next_node, curr)
            else:
                if not prev:
                    new_head = next_node
                else:
                    prev.sibling = next_node
                self._link(curr, next_node)
                curr = next_node
            
            next_node = curr.sibling
        
        self.head = new_head
        self._update_min()
    
    def _update_min(self):
        """Update pointer to minimum root"""
        self.min_node = None
        curr = self.head
        while curr:
            if not self.min_node or curr.key < self.min_node.key:
                self.min_node = curr
            curr = curr.sibling
    
    def insert(self, key):
        """Insert key - O(log n) worst, O(1) amortized"""
        new_heap = BinomialHeap()
        new_heap.head = BinomialNode(key)
        self._union(new_heap)
    
    def find_min(self):
        """Find minimum - O(1) with min pointer"""
        if not self.min_node:
            raise IndexError("Heap is empty")
        return self.min_node.key
    
    def extract_min(self):
        """Remove and return minimum - O(log n)"""
        if not self.head:
            raise IndexError("Heap is empty")
        
        # Find and remove min root
        min_node = self.min_node
        min_key = min_node.key
        
        # Remove min from root list
        if self.head == min_node:
            self.head = min_node.sibling
        else:
            curr = self.head
            while curr.sibling != min_node:
                curr = curr.sibling
            curr.sibling = min_node.sibling
        
        # Reverse children of min (they become a new heap)
        child_heap = BinomialHeap()
        child = min_node.child
        prev = None
        while child:
            child.parent = None
            next_child = child.sibling
            child.sibling = prev
            prev = child
            child = next_child
        child_heap.head = prev
        
        # Merge children back
        self._union(child_heap)
        
        return min_key
    
    def merge(self, other):
        """Merge with another heap - O(log n)"""
        self._union(other)


# Example:
bh = BinomialHeap()
for x in [10, 5, 20, 3, 15]:
    bh.insert(x)

print(f"Min: {bh.find_min()}")  # 3
print(f"Extract: {bh.extract_min()}")  # 3
print(f"New min: {bh.find_min()}")  # 5
```

---

# 7.5 Fibonacci Heap

## 7.5.1 Concept

**Fibonacci Heap** achieves **O(1) amortized** decrease-key, making it optimal for graph algorithms.

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                      FIBONACCI HEAP                                       ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  STRUCTURE:                                                               ║
║  • Collection of min-heap ordered trees (not necessarily binomial)        ║
║  • Roots form a circular doubly-linked list                               ║
║  • Pointer to minimum root                                                ║
║  • "Marked" nodes for cascading cuts                                      ║
║                                                                           ║
║        min                                                                ║
║         ↓                                                                 ║
║     ┌─→ 3 ←→ 7 ←→ 21 ←→ 52 ←─┐                                          ║
║     │         ↓       ↓      │                                          ║
║     │        18      38     │    (circular linked list of roots)        ║
║     │         ↓              │                                          ║
║     │        39              │                                          ║
║     └────────────────────────┘                                          ║
║                                                                           ║
║  KEY OPERATIONS COMPLEXITY:                                               ║
║  ┌────────────────┬──────────────────┬──────────────────────────────┐   ║
║  │   Operation    │    Amortized     │    Why                       │   ║
║  ├────────────────┼──────────────────┼──────────────────────────────┤   ║
║  │   insert       │      O(1)        │ Just add to root list        │   ║
║  │   find-min     │      O(1)        │ Min pointer maintained       │   ║
║  │   merge        │      O(1)        │ Concatenate root lists       │   ║
║  │   decrease-key │      O(1) ★      │ Cut and add to root list    │   ║
║  │   delete-min   │    O(log n)      │ Consolidation needed         │   ║
║  │   delete       │    O(log n)      │ decrease-key + delete-min    │   ║
║  └────────────────┴──────────────────┴──────────────────────────────┘   ║
║                                                                           ║
║  ★ This O(1) decrease-key is what makes Fibonacci heap special!          ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 7.5.2 Why "Fibonacci"?

```
The name comes from a key property:

THEOREM: In a Fibonacci heap, a node of degree k has at least F_{k+2} 
         descendants, where F_k is the k-th Fibonacci number.

This ensures maximum degree is O(log n), keeping operations efficient.

Fibonacci numbers: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...

Degree k:     0  1  2  3   4   5   6   7   8
Min size:     1  2  3  5   8  13  21  34  55  (F_{k+2})

This exponential growth of minimum size guarantees logarithmic height!
```

## 7.5.3 Decrease-Key with Cascading Cuts

```
DECREASE-KEY VISUALIZATION:

Before: Node 46 is child of 24, we decrease 46 to 15

         7                                7
        /|\                              /|\
      24 ...                           24 ...
      /\                               /
    26  46 ← decrease to 15          26
        /\
       35 ...

Step 1: Cut 15 from its parent, add to root list

         7 ←→ 15                        
        /|\    /\                       
      24 ... 35 ...                    
      /                                
    26                                 

Step 2: Mark parent 24 (lost a child)
        If 24 was already marked → cascading cut!

CASCADING CUT:
If a non-root node loses TWO children, it gets cut too.
This prevents trees from becoming too unbalanced.

Before cascading cut:       After:
       7                       7 ←→ 24 ←→ 15
      /|\                     /|     |    /\
    24* ...                 18 ...  26  35 ...
    /|\
  18 26 (15 cut)

* = marked (already lost one child before)
```

## 7.5.4 Practical Considerations

```python
"""
Fibonacci Heap - Conceptual Implementation Notes

IMPORTANT FOR INTERVIEWS:
═══════════════════════════════════════════════════════════════════════════

1. Full implementation is complex (100+ lines) - know the concepts!

2. When to use Fibonacci Heap:
   - Dijkstra's algorithm: O(E + V log V) instead of O((E + V) log V)
   - Prim's algorithm: Same improvement
   - When decrease-key is called MANY times (E >> V)

3. When NOT to use:
   - Simple priority queue usage
   - When decrease-key is rare
   - High constant factors make it slower for small inputs

4. Interview expectations:
   - Explain WHY O(1) decrease-key helps graph algorithms
   - Describe cascading cuts concept
   - Compare with binary heap
   - Know it's rarely implemented in practice (use binary heap)

5. Real-world alternatives:
   - Pairing Heap: Simpler, similar amortized bounds, often faster
   - Binary Heap: Simple, good cache performance
"""

# Complexity comparison for Dijkstra:
#
# With Binary Heap:
#   - Each vertex extracted once: O(V log V)
#   - Each edge may trigger decrease-key: O(E log V)
#   - Total: O((V + E) log V)
#
# With Fibonacci Heap:
#   - Each vertex extracted once: O(V log V)
#   - Each edge triggers O(1) decrease-key: O(E)
#   - Total: O(V log V + E)
#
# For dense graphs (E ≈ V²): 
#   Binary: O(V² log V)
#   Fibonacci: O(V² + V log V) = O(V²)  ← Significant improvement!
```

---

# 7.6 Comparison Summary

```
╔═══════════════════════════════════════════════════════════════════════════════════╗
║                        HEAP VARIANTS COMPARISON                                   ║
╠═══════════════════════════════════════════════════════════════════════════════════╣
║                                                                                   ║
║  Operation     │ Binary │ D-ary  │ Binomial │Fibonacci│ Min-Max │ Use Case       ║
║  ──────────────┼────────┼────────┼──────────┼─────────┼─────────┼────────────────║
║  find-min      │  O(1)  │  O(1)  │ O(log n) │  O(1)   │  O(1)   │                ║
║  find-max      │  O(n)  │  O(n)  │   O(n)   │  O(n)   │  O(1)   │ Min-Max wins!  ║
║  insert        │O(log n)│O(log_d)│  O(1)*   │  O(1)*  │O(log n) │                ║
║  delete-min    │O(log n)│O(dlog_d)│O(log n) │O(log n)*│O(log n) │                ║
║  delete-max    │  O(n)  │  O(n)  │   O(n)   │  O(n)   │O(log n) │ Min-Max wins!  ║
║  decrease-key  │O(log n)│O(log_d)│ O(log n) │  O(1)*  │O(log n) │ Fibonacci wins!║
║  merge         │  O(n)  │  O(n)  │ O(log n) │  O(1)*  │  O(n)   │ Fib/Binomial!  ║
║  ──────────────┼────────┼────────┼──────────┼─────────┼─────────┼────────────────║
║  * = amortized                                                                    ║
║                                                                                   ║
║  RECOMMENDATIONS:                                                                 ║
║  ┌─────────────────────────────────────────────────────────────────────────────┐║
║  │ General purpose:           Binary Heap (simple, good cache performance)     │║
║  │ Need min AND max:          Min-Max Heap                                     │║
║  │ Many merges:               Binomial Heap                                    │║
║  │ Dense graph algorithms:    Fibonacci Heap (theoretically)                   │║
║  │ Practice/interviews:       Binary Heap + understand others conceptually     │║
║  └─────────────────────────────────────────────────────────────────────────────┘║
║                                                                                   ║
╚═══════════════════════════════════════════════════════════════════════════════════╝
```

---

# 7.7 Summary

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         CHAPTER 7 SUMMARY                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  D-ARY HEAP                                                                 │
│  • Generalization with D children per node                                  │
│  • Faster insert/decrease-key, slower extract                               │
│  • d=4 often optimal for cache performance                                  │
│                                                                             │
│  MIN-MAX HEAP                                                               │
│  • Alternating min/max levels                                               │
│  • O(1) find-min AND find-max                                              │
│  • Great for double-ended priority queue                                    │
│                                                                             │
│  BINOMIAL HEAP                                                              │
│  • Collection of binomial trees                                             │
│  • O(log n) merge operation                                                │
│  • Structure mirrors binary representation                                  │
│                                                                             │
│  FIBONACCI HEAP                                                             │
│  • O(1) amortized decrease-key                                             │
│  • Optimal for Dijkstra/Prim on dense graphs                               │
│  • Complex, high constants - rarely used in practice                        │
│                                                                             │
│  INTERVIEW TIPS                                                             │
│  • Know binary heap implementation cold                                     │
│  • Understand trade-offs of each variant                                    │
│  • Know when each variant is theoretically optimal                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

**Next: Chapter 8 - Heap Sort** →
