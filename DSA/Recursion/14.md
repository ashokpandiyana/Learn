# Chapter 14: Advanced Recursion Patterns

## 14.1 Multi-Dimensional Recursion

### Understanding Multi-Dimensional State

Many complex problems require tracking multiple dimensions of state simultaneously:
- 3D grids (x, y, z coordinates)
- Multiple parameters (position, time, resources)
- Complex state combinations

### Pattern 1: 3D Grid Problems

**Problem:** Count paths in 3D space.

```python
def count_paths_3d(x, y, z, memo=None):
    """
    Count paths to reach (x, y, z) from (0, 0, 0)
    Can only move right, down, or forward
    
    Time: O(x√óy√óz), Space: O(x√óy√óz)
    """
    if memo is None:
        memo = {}
    
    # Check memo
    if (x, y, z) in memo:
        return memo[(x, y, z)]
    
    # BASE CASE: Origin
    if x == 0 and y == 0 and z == 0:
        return 1
    
    # BASE CASE: Out of bounds
    if x < 0 or y < 0 or z < 0:
        return 0
    
    # Recursive case: sum of paths from three directions
    paths = (count_paths_3d(x - 1, y, z, memo) +
            count_paths_3d(x, y - 1, z, memo) +
            count_paths_3d(x, y, z - 1, memo))
    
    memo[(x, y, z)] = paths
    return paths

# Test
print(f"Paths to (2, 2, 2): {count_paths_3d(2, 2, 2)}")  # 90
```

**Visualization:**
```
3D Grid (simplified 2√ó2√ó2):

Level z=0:        Level z=1:        Level z=2:
[S] [.]           [.] [.]           [.] [.]
[.] [.]           [.] [.]           [.] [E]

S = Start (0,0,0)
E = End (2,2,2)

Can move:
‚Üí right (x+1)
‚Üì down (y+1)
‚äï forward (z+1)
```

---

### Pattern 2: Multi-Parameter State Problems

**Problem:** Knapsack with multiple constraints.

```python
def bounded_knapsack(weights, values, capacity, max_items, index=0, memo=None):
    """
    Knapsack with weight capacity AND item count limit
    
    State: (index, remaining_capacity, items_left)
    
    Time: O(n √ó capacity √ó max_items)
    Space: O(n √ó capacity √ó max_items)
    """
    if memo is None:
        memo = {}
    
    # Create state key
    state = (index, capacity, max_items)
    if state in memo:
        return memo[state]
    
    # BASE CASES
    if index >= len(weights) or capacity == 0 or max_items == 0:
        return 0
    
    # Option 1: Skip current item
    skip = bounded_knapsack(weights, values, capacity, max_items, index + 1, memo)
    
    # Option 2: Take current item (if possible)
    take = 0
    if weights[index] <= capacity:
        take = values[index] + bounded_knapsack(
            weights, values, 
            capacity - weights[index], 
            max_items - 1, 
            index + 1, 
            memo
        )
    
    result = max(skip, take)
    memo[state] = result
    return result

# Test
weights = [2, 3, 4, 5]
values = [3, 4, 5, 6]
capacity = 10
max_items = 3
result = bounded_knapsack(weights, values, capacity, max_items)
print(f"Max value: {result}")  # With constraints
```

---

### Pattern 3: Time-Based State

**Problem:** Stock trading with cooldown.

```python
def stock_trading_cooldown(prices, day=0, holding=False, cooldown=False, memo=None):
    """
    Stock trading with cooldown period
    
    State: (day, holding_stock, in_cooldown)
    
    Time: O(n), Space: O(n)
    """
    if memo is None:
        memo = {}
    
    state = (day, holding, cooldown)
    if state in memo:
        return memo[state]
    
    # BASE CASE: No more days
    if day >= len(prices):
        return 0
    
    # If in cooldown, can only wait
    if cooldown:
        result = stock_trading_cooldown(prices, day + 1, holding, False, memo)
    
    # If holding stock
    elif holding:
        # Option 1: Sell (enter cooldown)
        sell = prices[day] + stock_trading_cooldown(prices, day + 1, False, True, memo)
        # Option 2: Hold
        hold = stock_trading_cooldown(prices, day + 1, True, False, memo)
        result = max(sell, hold)
    
    # If not holding stock and not in cooldown
    else:
        # Option 1: Buy
        buy = -prices[day] + stock_trading_cooldown(prices, day + 1, True, False, memo)
        # Option 2: Wait
        wait = stock_trading_cooldown(prices, day + 1, False, False, memo)
        result = max(buy, wait)
    
    memo[state] = result
    return result

# Test
prices = [1, 2, 3, 0, 2]
profit = stock_trading_cooldown(prices)
print(f"Max profit with cooldown: {profit}")  # 3
```

**State Transitions:**
```
States:
1. Not holding, no cooldown: Can BUY or WAIT
2. Holding stock: Can SELL or HOLD
3. Not holding, in cooldown: Can only WAIT

Transitions:
    BUY
(1) -----> (2)
 ‚Üë          |
 |    SELL  |
 +----------+
      ‚Üì
     (3) WAIT
      |
      +-----> (1)
```

---

## 14.2 Expression Evaluation

### Pattern 1: Evaluate All Ways to Add Parentheses

**Problem:** Generate all possible results by adding parentheses.

```python
def diff_ways_to_compute(expression, memo=None):
    """
    Compute all possible results from different parenthesizations
    
    Example: "2-1-1"
    - ((2-1)-1) = 0
    - (2-(1-1)) = 2
    
    Time: O(Catalan number), Space: O(n)
    """
    if memo is None:
        memo = {}
    
    if expression in memo:
        return memo[expression]
    
    results = []
    
    # Try each operator as the last operation
    for i, char in enumerate(expression):
        if char in '+-*':
            # Split into left and right parts
            left_results = diff_ways_to_compute(expression[:i], memo)
            right_results = diff_ways_to_compute(expression[i+1:], memo)
            
            # Combine results
            for left in left_results:
                for right in right_results:
                    if char == '+':
                        results.append(left + right)
                    elif char == '-':
                        results.append(left - right)
                    elif char == '*':
                        results.append(left * right)
    
    # BASE CASE: No operators (just a number)
    if not results:
        results.append(int(expression))
    
    memo[expression] = results
    return results

# Test
expr = "2-1-1"
results = diff_ways_to_compute(expr)
print(f"All results for '{expr}': {results}")  # [0, 2]

expr = "2*3-4*5"
results = diff_ways_to_compute(expr)
print(f"All results for '{expr}': {sorted(results)}")  # [-34, -14, -10, -10, 10]
```

**Recursion Tree:**
```
Expression: "2-1-1"

Split at first '-':
  Left: "2" ‚Üí [2]
  Right: "1-1"
    Split at '-':
      Left: "1" ‚Üí [1]
      Right: "1" ‚Üí [1]
    Result: [1-1] = [0]
  Result: [2-0] = [2]

Split at second '-':
  Left: "2-1"
    Split at '-':
      Left: "2" ‚Üí [2]
      Right: "1" ‚Üí [1]
    Result: [2-1] = [1]
  Right: "1" ‚Üí [1]
  Result: [1-1] = [0]

All results: [2, 0]
```

---

### Pattern 2: Boolean Parenthesization

**Problem:** Count ways to parenthesize boolean expression to get true.

```python
def count_boolean_parenthesizations(expr, result, start=0, end=None, memo=None):
    """
    Count ways to parenthesize to get desired result
    
    Expression: T|F&T (T=True, F=False, |=OR, &=AND, ^=XOR)
    
    Time: O(n¬≥), Space: O(n¬≤)
    """
    if memo is None:
        memo = {}
    if end is None:
        end = len(expr) - 1
    
    key = (start, end, result)
    if key in memo:
        return memo[key]
    
    # BASE CASE: Single boolean
    if start == end:
        if result:
            return 1 if expr[start] == 'T' else 0
        else:
            return 1 if expr[start] == 'F' else 0
    
    count = 0
    
    # Try each operator as the main operator
    for i in range(start + 1, end, 2):  # Operators at odd indices
        operator = expr[i]
        
        # Count ways to get True and False on both sides
        left_true = count_boolean_parenthesizations(expr, True, start, i - 1, memo)
        left_false = count_boolean_parenthesizations(expr, False, start, i - 1, memo)
        right_true = count_boolean_parenthesizations(expr, True, i + 1, end, memo)
        right_false = count_boolean_parenthesizations(expr, False, i + 1, end, memo)
        
        # Calculate based on operator
        if operator == '&':
            if result:
                count += left_true * right_true
            else:
                count += (left_true * right_false + 
                         left_false * right_true + 
                         left_false * right_false)
        elif operator == '|':
            if result:
                count += (left_true * right_true + 
                         left_true * right_false + 
                         left_false * right_true)
            else:
                count += left_false * right_false
        elif operator == '^':
            if result:
                count += (left_true * right_false + left_false * right_true)
            else:
                count += (left_true * right_true + left_false * right_false)
    
    memo[key] = count
    return count

# Test
expr = "T|F&T"
count = count_boolean_parenthesizations(expr, True)
print(f"Ways to get True: {count}")  # 2
# (T|(F&T)) = T, ((T|F)&T) = T
```

---

### Pattern 3: Expression Add Operators

**Problem:** Place '+', '-', or '*' between digits to reach target.

```python
def add_operators(num, target):
    """
    Add operators between digits to reach target
    
    Example: num="123", target=6
    Output: ["1+2+3", "1*2*3"]
    
    Time: O(4^n), Space: O(n)
    """
    result = []
    
    def backtrack(index, path, value, last):
        """
        index: current position in num
        path: current expression string
        value: current evaluated value
        last: last operand (for handling *)
        """
        # BASE CASE: Reached end
        if index == len(num):
            if value == target:
                result.append(path)
            return
        
        # Try all possible operands starting from index
        for i in range(index, len(num)):
            # Skip numbers with leading zeros
            if i != index and num[index] == '0':
                break
            
            operand_str = num[index:i + 1]
            operand = int(operand_str)
            
            if index == 0:
                # First number, no operator
                backtrack(i + 1, operand_str, operand, operand)
            else:
                # Addition
                backtrack(i + 1, path + '+' + operand_str, 
                         value + operand, operand)
                
                # Subtraction
                backtrack(i + 1, path + '-' + operand_str, 
                         value - operand, -operand)
                
                # Multiplication (tricky: need to undo last operation)
                backtrack(i + 1, path + '*' + operand_str, 
                         value - last + last * operand, last * operand)
    
    backtrack(0, "", 0, 0)
    return result

# Test
num = "123"
target = 6
expressions = add_operators(num, target)
print(f"Expressions for {num} = {target}:")
for expr in expressions:
    print(f"  {expr}")
# Output: 1+2+3, 1*2*3
```

**Why Track Last Operand:**
```
For multiplication, we need to "undo" the last operation:

Example: num="105", target=5
Path: 1+0*5

Without tracking last:
1 + 0 * 5 = 1 (wrong, treats as (1+0)*5)

With tracking last:
value = 1 (after 1+0)
last = 0
For *5: value - last + last * 5 = 1 - 0 + 0*5 = 1
Still evaluates to 1 (correct, but this example = 1 not 5)

Better example: "123", target=6
1*2*3:
- After 1: value=1, last=1
- After *2: value=1-1+1*2=2, last=2
- After *3: value=2-2+2*3=6, last=6 ‚úì
```

---

## 14.3 Game Theory Problems

### Understanding Game Theory Recursion

In two-player games:
- Each player tries to maximize their own score
- Minimize opponent's advantage
- Recursive: try all moves, pick best

### Pattern 1: Minimax Algorithm

```python
def minimax_game(piles, is_max_turn=True, memo=None):
    """
    Game: Two players take from piles
    Maximize your score, minimize opponent's
    
    Time: O(2^n) without memo, O(n) with memo
    Space: O(n)
    """
    if memo is None:
        memo = {}
    
    # Create state key
    state = (tuple(piles), is_max_turn)
    if state in memo:
        return memo[state]
    
    # BASE CASE: No piles left
    if not piles:
        return 0
    
    if is_max_turn:
        # Maximizing player: try all moves, pick max
        best_score = float('-inf')
        for i in range(len(piles)):
            # Take pile i
            new_piles = piles[:i] + piles[i+1:]
            score = piles[i] + minimax_game(new_piles, False, memo)
            best_score = max(best_score, score)
    else:
        # Minimizing player: opponent tries to minimize our score
        best_score = float('inf')
        for i in range(len(piles)):
            new_piles = piles[:i] + piles[i+1:]
            score = minimax_game(new_piles, True, memo)
            best_score = min(best_score, score)
    
    memo[state] = best_score
    return best_score

# Test
piles = [3, 7, 2, 3]
score = minimax_game(piles)
print(f"Best score for first player: {score}")
```

---

### Pattern 2: Stone Game

**Problem:** Players alternately take from array ends. Find winner.

```python
def stone_game(piles, left=0, right=None, memo=None):
    """
    Players take from ends of array
    Return max difference (my score - opponent score)
    
    Time: O(n¬≤), Space: O(n¬≤)
    """
    if memo is None:
        memo = {}
    if right is None:
        right = len(piles) - 1
    
    if (left, right) in memo:
        return memo[(left, right)]
    
    # BASE CASE: One pile left
    if left == right:
        return piles[left]
    
    # Two choices: take left or take right
    # After taking, opponent plays optimally (minimizes our future gain)
    
    # Take left pile
    take_left = piles[left] - stone_game(piles, left + 1, right, memo)
    
    # Take right pile
    take_right = piles[right] - stone_game(piles, left, right - 1, memo)
    
    # Choose better option
    result = max(take_left, take_right)
    memo[(left, right)] = result
    return result

# Test
piles = [5, 3, 4, 5]
diff = stone_game(piles)
print(f"Score difference: {diff}")
print(f"First player {'wins' if diff > 0 else 'loses'}")
```

**Game Tree:**
```
Piles: [5, 3, 4, 5]

Player 1's turn:
  Take 5: [3,4,5] ‚Üí Player 2's turn
    Take 3: [4,5] ‚Üí Player 1 gets max(4-5, 5-4) = 1
    Take 5: [3,4] ‚Üí Player 1 gets max(3-4, 4-3) = 1
    Player 2 minimizes: take either, result = 1
    Player 1 gets: 5 - 1 = 4
  
  Take 5: [5,3,4] ‚Üí Player 2's turn
    Take 5: [3,4] ‚Üí Player 1 gets 1 (as above)
    Take 4: [5,3] ‚Üí Player 1 gets max(5-3, 3-5) = 2
    Player 2 minimizes: takes 5, result = 1
    Player 1 gets: 5 - 1 = 4

Player 1 chooses: max(4, 4) = 4
```

---

### Pattern 3: Nim Game Variations

```python
def can_win_nim(n, memo=None):
    """
    Nim game: Remove 1, 2, or 3 stones
    Player who removes last stone wins
    
    Time: O(n), Space: O(n)
    """
    if memo is None:
        memo = {}
    
    if n in memo:
        return memo[n]
    
    # BASE CASES
    if n <= 0:
        return False  # No stones left, previous player won
    if n <= 3:
        return True   # Can take all and win
    
    # Try all possible moves
    # If any move leads to opponent losing, we win
    for take in [1, 2, 3]:
        if not can_win_nim(n - take, memo):
            memo[n] = True
            return True
    
    # All moves lead to opponent winning
    memo[n] = False
    return False

# Test
for n in range(1, 11):
    result = "Win" if can_win_nim(n) else "Lose"
    print(f"Stones: {n} ‚Üí {result}")

# Pattern: Lose at 4, 8, 12, ... (multiples of 4)
```

---

## 14.4 Partition Problems

### Pattern 1: Partition into K Equal Subsets

**Problem:** Can array be partitioned into k subsets with equal sum?

```python
def can_partition_k_subsets(nums, k):
    """
    Partition array into k subsets with equal sum
    
    Time: O(k * 2^n), Space: O(n)
    """
    total = sum(nums)
    if total % k != 0:
        return False
    
    target = total // k
    nums.sort(reverse=True)  # Optimization: try larger numbers first
    
    if nums[0] > target:
        return False
    
    used = [False] * len(nums)
    
    def backtrack(k_remaining, subset_sum, start):
        # BASE CASE: All subsets formed
        if k_remaining == 0:
            return True
        
        # Current subset complete, start new one
        if subset_sum == target:
            return backtrack(k_remaining - 1, 0, 0)
        
        # Try adding each unused number
        for i in range(start, len(nums)):
            if used[i] or subset_sum + nums[i] > target:
                continue
            
            # Try including nums[i]
            used[i] = True
            if backtrack(k_remaining, subset_sum + nums[i], i + 1):
                return True
            used[i] = False
            
            # Optimization: if first element doesn't work, no point trying others
            if subset_sum == 0:
                break
        
        return False
    
    return backtrack(k, 0, 0)

# Test
nums = [4, 3, 2, 3, 5, 2, 1]
k = 4
result = can_partition_k_subsets(nums, k)
print(f"Can partition into {k} equal subsets: {result}")  # True
# Subsets: [5], [4,1], [3,2], [3,2]
```

---

### Pattern 2: Minimum Difference Partition

**Problem:** Partition into two subsets to minimize difference.

```python
def min_subset_difference(nums, index=0, sum1=0, sum2=0, memo=None):
    """
    Partition to minimize |sum1 - sum2|
    
    Time: O(2^n) without memo, O(n * sum) with memo
    Space: O(n)
    """
    if memo is None:
        memo = {}
    
    state = (index, sum1)
    if state in memo:
        return memo[state]
    
    # BASE CASE: All numbers assigned
    if index >= len(nums):
        return abs(sum1 - sum2)
    
    # Option 1: Add to subset 1
    diff1 = min_subset_difference(nums, index + 1, 
                                   sum1 + nums[index], sum2, memo)
    
    # Option 2: Add to subset 2
    diff2 = min_subset_difference(nums, index + 1, 
                                   sum1, sum2 + nums[index], memo)
    
    result = min(diff1, diff2)
    memo[state] = result
    return result

# Test
nums = [1, 6, 11, 5]
diff = min_subset_difference(nums)
print(f"Minimum difference: {diff}")  # 1
# Partition: [1, 5, 6] and [11] ‚Üí |12 - 11| = 1
```

**Optimized Version:**
```python
def min_subset_diff_optimized(nums):
    """
    Optimized: Only track one subset sum
    
    Time: O(n * total_sum), Space: O(n * total_sum)
    """
    total = sum(nums)
    memo = {}
    
    def helper(index, sum1):
        if (index, sum1) in memo:
            return memo[(index, sum1)]
        
        if index >= len(nums):
            sum2 = total - sum1
            return abs(sum1 - sum2)
        
        # Include in subset 1
        include = helper(index + 1, sum1 + nums[index])
        # Exclude from subset 1 (goes to subset 2)
        exclude = helper(index + 1, sum1)
        
        result = min(include, exclude)
        memo[(index, sum1)] = result
        return result
    
    return helper(0, 0)
```

---

## Key Takeaways from Chapter 14

### 1. Multi-Dimensional State

**Key Principle:** Identify all variables that affect the result

```python
# State components:
# - Position (x, y, z)
# - Resources (capacity, items)
# - Time (day, cooldown)
# - Game state (turn, score)

state = (position, resources, time, ...)
```

### 2. Expression Problems Pattern

```python
def evaluate_expression(expr, start, end):
    # Try each operator as main operator
    for i in range(start, end):
        if is_operator(expr[i]):
            left = evaluate(expr, start, i-1)
            right = evaluate(expr, i+1, end)
            combine(left, right, operator)
```

### 3. Game Theory Pattern

```python
def minimax(state, is_max_turn):
    if terminal_state:
        return evaluate(state)
    
    if is_max_turn:
        return max(all_moves)
    else:
        return min(all_moves)
```

### 4. Partition Pattern

```python
def partition(items, k_subsets, current_sum, target):
    if current_sum == target:
        # Start new subset
        return partition(items, k_subsets-1, 0, target)
    
    # Try adding each item to current subset
    for item in available_items:
        # Try including item
        # Backtrack
```

---

## Practice Problems

### Easy
1. Coin change (multiple dimensions)
2. Unique paths with k steps
3. Predict the winner
4. Nim game

### Medium
5. Different ways to add parentheses
6. Stone game (multiple variations)
7. Partition equal subset sum
8. Matchsticks to square
9. Shopping offers
10. Minimum cost for tickets

### Hard
11. Expression add operators
12. Boolean parenthesization
13. Partition to K equal sum subsets
14. Burst balloons
15. Stone game IV

### Challenge
16. Optimal division
17. Cat and mouse game
18. Stone game III (multiple variations)
19. Minimum cost to merge stones
20. Maximum score words formed by letters

---

## Common Mistakes

‚ùå **Not handling all state dimensions**
```python
# Wrong: Missing cooldown state
def stock(day, holding):
    # Doesn't track cooldown period

# Right
def stock(day, holding, cooldown):
    # Tracks all relevant state
```

‚ùå **Incorrect game theory recursion**
```python
# Wrong: Not considering opponent's optimal play
def game(state):
    return my_best_move()

# Right
def game(state, my_turn):
    if my_turn:
        return max(all_my_moves)
    else:
        return min(all_opponent_moves)
```

‚ùå **Forgetting to backtrack in partition**
```python
# Wrong
subset.add(item)
backtrack(...)
# Missing: subset.remove(item)

# Right
subset.add(item)
backtrack(...)
subset.remove(item)  # Restore state
```

Master these advanced patterns and you'll handle the most complex recursion problems! üöÄ
