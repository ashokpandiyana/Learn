# Chapter 2: Basic Recursion Patterns

## 2.1 Simple Recursive Problems

### Pattern 1: Print Numbers 1 to N

**Problem:** Print numbers from 1 to N using recursion.

#### Approach 1: Using Forward Recursion

```python
def print_1_to_n(current, n):
    """
    Print numbers from current to n
    Base case: when current exceeds n
    """
    # Base case
    if current > n:
        return
    
    # Print before recursive call (forward direction)
    print(current, end=" ")
    
    # Recursive call
    print_1_to_n(current + 1, n)

# Test
print_1_to_n(1, 5)  # Output: 1 2 3 4 5
```

**Recursion Flow:**
```
print_1_to_n(1, 5)
├─ print 1
└─ print_1_to_n(2, 5)
   ├─ print 2
   └─ print_1_to_n(3, 5)
      ├─ print 3
      └─ print_1_to_n(4, 5)
         ├─ print 4
         └─ print_1_to_n(5, 5)
            ├─ print 5
            └─ print_1_to_n(6, 5) → returns (base case)
```

#### Approach 2: Using Backtracking

```python
def print_1_to_n_backtrack(n):
    """
    Print numbers 1 to n using backtracking
    Print happens AFTER recursive call (during return phase)
    """
    # Base case
    if n == 0:
        return
    
    # Recursive call first
    print_1_to_n_backtrack(n - 1)
    
    # Print during return (backtracking phase)
    print(n, end=" ")

# Test
print_1_to_n_backtrack(5)  # Output: 1 2 3 4 5
```

**Recursion Flow:**
```
print_1_to_n_backtrack(5)
└─ print_1_to_n_backtrack(4)
   └─ print_1_to_n_backtrack(3)
      └─ print_1_to_n_backtrack(2)
         └─ print_1_to_n_backtrack(1)
            └─ print_1_to_n_backtrack(0) → returns
            ← print 1 (backtrack)
         ← print 2 (backtrack)
      ← print 3 (backtrack)
   ← print 4 (backtrack)
← print 5 (backtrack)
```

**Key Insight:** 
- Print **before** recursive call → forward order
- Print **after** recursive call → achieved through backtracking

---

### Pattern 2: Print Numbers N to 1

```python
def print_n_to_1(n):
    """Print numbers from n down to 1"""
    # Base case
    if n == 0:
        return
    
    # Print before recursive call (descending order)
    print(n, end=" ")
    
    # Recursive call with n-1
    print_n_to_1(n - 1)

# Test
print_n_to_1(5)  # Output: 5 4 3 2 1
```

**Using Backtracking (Alternate):**
```python
def print_n_to_1_backtrack(current, n):
    """Print n to 1 using backtracking"""
    if current > n:
        return
    
    # Recursive call first
    print_n_to_1_backtrack(current + 1, n)
    
    # Print during backtrack
    print(current, end=" ")

print_n_to_1_backtrack(1, 5)  # Output: 5 4 3 2 1
```

---

### Pattern 3: Sum of First N Natural Numbers

```python
def sum_of_n(n):
    """
    Calculate sum = 1 + 2 + 3 + ... + n
    Base case: sum(0) = 0
    Recursive relation: sum(n) = n + sum(n-1)
    """
    # Base case
    if n == 0:
        return 0
    
    # Recursive case
    return n + sum_of_n(n - 1)

# Test
print(sum_of_n(5))  # Output: 15 (1+2+3+4+5)
print(sum_of_n(10)) # Output: 55
```

**Recursion Tree:**
```
                    sum_of_n(5)
                         |
                    5 + sum_of_n(4)
                         |
                    5 + 4 + sum_of_n(3)
                         |
                    5 + 4 + 3 + sum_of_n(2)
                         |
                    5 + 4 + 3 + 2 + sum_of_n(1)
                         |
                    5 + 4 + 3 + 2 + 1 + sum_of_n(0)
                         |
                    5 + 4 + 3 + 2 + 1 + 0 = 15
```

**Time Complexity:** O(n)  
**Space Complexity:** O(n) - recursion stack

---

### Pattern 4: Factorial Calculation

```python
def factorial(n):
    """
    Calculate n! = n × (n-1) × (n-2) × ... × 1
    Base case: 0! = 1, 1! = 1
    """
    # Base case
    if n == 0 or n == 1:
        return 1
    
    # Recursive case: n! = n × (n-1)!
    return n * factorial(n - 1)

# Test
print(factorial(5))  # Output: 120
print(factorial(0))  # Output: 1
print(factorial(7))  # Output: 5040
```

**Step-by-Step Execution:**
```
factorial(5)
= 5 × factorial(4)
= 5 × 4 × factorial(3)
= 5 × 4 × 3 × factorial(2)
= 5 × 4 × 3 × 2 × factorial(1)
= 5 × 4 × 3 × 2 × 1
= 120
```

---

### Pattern 5: Power Function (x^n)

```python
def power(x, n):
    """
    Calculate x^n (x raised to power n)
    Base case: x^0 = 1
    Recursive relation: x^n = x × x^(n-1)
    """
    # Base case
    if n == 0:
        return 1
    
    # Recursive case
    return x * power(x, n - 1)

# Test
print(power(2, 5))   # Output: 32
print(power(3, 3))   # Output: 27
print(power(5, 0))   # Output: 1
```

**Optimized Version (O(log n)):**
```python
def power_optimized(x, n):
    """
    Optimized power calculation using divide and conquer
    x^n = (x^(n/2))^2 if n is even
    x^n = x × (x^(n/2))^2 if n is odd
    """
    # Base case
    if n == 0:
        return 1
    
    # Calculate half power
    half = power_optimized(x, n // 2)
    
    # If n is even
    if n % 2 == 0:
        return half * half
    else:  # If n is odd
        return x * half * half

# Test
print(power_optimized(2, 10))  # Output: 1024
```

**Comparison:**
```
Normal Power (x^8):
8 → 7 → 6 → 5 → 4 → 3 → 2 → 1 → 0  (8 steps)

Optimized Power (x^8):
8 → 4 → 2 → 1 → 0  (4 steps)

Time: O(n) → O(log n)
```

---

## 2.2 Parameterized vs Functional Recursion

### Understanding the Difference

**Functional Recursion:** Returns the result from recursive calls  
**Parameterized Recursion:** Carries result through parameters (like an accumulator)

### Example 1: Sum of N Numbers

#### Functional Approach
```python
def sum_functional(n):
    """
    Returns: n + sum(n-1)
    Result is calculated during return phase
    """
    if n == 0:
        return 0
    return n + sum_functional(n - 1)

print(sum_functional(5))  # Output: 15
```

**Flow:**
```
sum_functional(5)
= 5 + sum_functional(4)
= 5 + (4 + sum_functional(3))
= 5 + (4 + (3 + sum_functional(2)))
= 5 + (4 + (3 + (2 + sum_functional(1))))
= 5 + (4 + (3 + (2 + (1 + sum_functional(0)))))
= 5 + (4 + (3 + (2 + (1 + 0))))
= 15
```

#### Parameterized Approach
```python
def sum_parameterized(n, accumulator=0):
    """
    Carries result in accumulator parameter
    Result is calculated during forward phase
    This is tail recursive!
    """
    if n == 0:
        return accumulator
    return sum_parameterized(n - 1, accumulator + n)

print(sum_parameterized(5))  # Output: 15
```

**Flow:**
```
sum_parameterized(5, 0)
= sum_parameterized(4, 5)
= sum_parameterized(3, 9)
= sum_parameterized(2, 12)
= sum_parameterized(1, 14)
= sum_parameterized(0, 15)
= 15
```

**Key Differences:**

| Aspect | Functional | Parameterized |
|--------|-----------|---------------|
| **Result Storage** | In return values | In parameters |
| **Calculation Phase** | During return (backtrack) | During forward calls |
| **Tail Recursive** | Usually No | Usually Yes |
| **Optimization Potential** | Limited | Can be optimized by compiler |

### Example 2: Factorial

#### Functional Approach
```python
def factorial_functional(n):
    if n <= 1:
        return 1
    return n * factorial_functional(n - 1)
```

#### Parameterized Approach
```python
def factorial_parameterized(n, result=1):
    if n <= 1:
        return result
    return factorial_parameterized(n - 1, result * n)

print(factorial_parameterized(5))  # Output: 120
```

**Comparison:**
```
Functional:
factorial(5)
= 5 × factorial(4)
= 5 × 4 × factorial(3)
= 5 × 4 × 3 × 2 × 1
(Operations happen during return)

Parameterized:
factorial(5, 1)
= factorial(4, 5)
= factorial(3, 20)
= factorial(2, 60)
= factorial(1, 120)
= 120
(Result accumulated in forward direction)
```

### Example 3: Reverse a Number

#### Functional Approach
```python
def reverse_functional(n, power):
    """
    Reverse digits of a number
    power: number of digits - 1
    """
    if n == 0:
        return 0
    
    # Last digit × 10^power + reverse of remaining
    return (n % 10) * (10 ** power) + reverse_functional(n // 10, power - 1)

# Helper to calculate power
def reverse_number(n):
    import math
    if n == 0:
        return 0
    power = int(math.log10(n))
    return reverse_functional(n, power)

print(reverse_number(12345))  # Output: 54321
```

#### Parameterized Approach
```python
def reverse_parameterized(n, reversed_num=0):
    """
    Carry the reversed number in parameter
    Much cleaner and efficient!
    """
    if n == 0:
        return reversed_num
    
    # Extract last digit and add to reversed number
    last_digit = n % 10
    reversed_num = reversed_num * 10 + last_digit
    
    return reverse_parameterized(n // 10, reversed_num)

print(reverse_parameterized(12345))  # Output: 54321
```

**Step-by-Step:**
```
reverse_parameterized(12345, 0)
= reverse_parameterized(1234, 5)      # 0*10 + 5 = 5
= reverse_parameterized(123, 54)      # 5*10 + 4 = 54
= reverse_parameterized(12, 543)      # 54*10 + 3 = 543
= reverse_parameterized(1, 5432)      # 543*10 + 2 = 5432
= reverse_parameterized(0, 54321)     # 5432*10 + 1 = 54321
= 54321
```

### Converting Between Approaches

**General Pattern:**

```python
# Functional → Parameterized
# From:
def func_functional(n):
    if base_case:
        return base_value
    return operation + func_functional(n - 1)

# To:
def func_parameterized(n, accumulator=initial_value):
    if base_case:
        return accumulator
    return func_parameterized(n - 1, accumulator operation value)
```

---

## 2.3 Multiple Recursive Calls

### Understanding Multiple Recursion

When a function makes **2 or more** recursive calls, we get tree recursion.

### Example 1: Fibonacci Sequence

The classic example of binary recursion.

```python
def fibonacci(n):
    """
    Fibonacci: 0, 1, 1, 2, 3, 5, 8, 13, 21, ...
    F(n) = F(n-1) + F(n-2)
    Base cases: F(0) = 0, F(1) = 1
    """
    # Base cases
    if n == 0:
        return 0
    if n == 1:
        return 1
    
    # Two recursive calls
    return fibonacci(n - 1) + fibonacci(n - 2)

# Test
for i in range(8):
    print(f"F({i}) = {fibonacci(i)}")
```

**Output:**
```
F(0) = 0
F(1) = 1
F(2) = 1
F(3) = 2
F(4) = 3
F(5) = 5
F(6) = 8
F(7) = 13
```

**Recursion Tree for fibonacci(5):**
```
                        fib(5)
                      /        \
                 fib(4)          fib(3)
                /      \        /      \
           fib(3)    fib(2)  fib(2)  fib(1)
          /    \     /   \    /   \
      fib(2) fib(1) fib(1) fib(0) fib(1) fib(0)
      /   \
  fib(1) fib(0)
```

**Key Observations:**
1. **Overlapping Subproblems:** fib(3) calculated twice, fib(2) three times!
2. **Exponential Growth:** Number of calls grows exponentially
3. **Time Complexity:** O(2^n) - very inefficient!
4. **Space Complexity:** O(n) - maximum depth of recursion

### Counting Function Calls

```python
call_count = 0

def fibonacci_with_count(n):
    global call_count
    call_count += 1
    
    if n <= 1:
        return n
    return fibonacci_with_count(n - 1) + fibonacci_with_count(n - 2)

# Test
call_count = 0
result = fibonacci_with_count(10)
print(f"fibonacci(10) = {result}")
print(f"Total function calls: {call_count}")
```

**Output:**
```
fibonacci(10) = 55
Total function calls: 177
```

**Growth of Function Calls:**
```
n    | Calls
-----|-------
1    | 1
2    | 3
3    | 5
4    | 9
5    | 15
10   | 177
20   | 21891
30   | 2692537
```

### Why is Fibonacci Inefficient?

**Problem:** Repeated calculations of same values

```
To calculate fib(5), we calculate:
- fib(4): 1 time
- fib(3): 2 times
- fib(2): 3 times
- fib(1): 5 times
- fib(0): 3 times

Total: 15 function calls for just fib(5)!
```

### Introduction to Memoization

**Solution:** Store calculated values to avoid recomputation.

```python
def fibonacci_memo(n, memo={}):
    """
    Fibonacci with memoization
    Store calculated values in memo dictionary
    """
    # Check if already calculated
    if n in memo:
        return memo[n]
    
    # Base cases
    if n <= 1:
        return n
    
    # Calculate and store
    memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo)
    return memo[n]

# Test
print(fibonacci_memo(10))  # Output: 55
print(fibonacci_memo(50))  # Fast! Without memo, this would take forever
```

**With Memoization:**
```
To calculate fib(5), we calculate:
- fib(4): 1 time
- fib(3): 1 time
- fib(2): 1 time
- fib(1): 1 time
- fib(0): 1 time

Total: 9 function calls (much better!)

Time Complexity: O(2^n) → O(n)
```

### Example 2: Print All Binary Strings of Length N

```python
def print_binary_strings(n, prefix=""):
    """
    Print all binary strings of length n
    Each position can be 0 or 1 (2 choices → 2 recursive calls)
    """
    # Base case: if length reaches n
    if len(prefix) == n:
        print(prefix)
        return
    
    # Two recursive calls: append 0 or 1
    print_binary_strings(n, prefix + "0")
    print_binary_strings(n, prefix + "1")

# Test
print("Binary strings of length 3:")
print_binary_strings(3)
```

**Output:**
```
Binary strings of length 3:
000
001
010
011
100
101
110
111
```

**Recursion Tree:**
```
                        ""
                    /        \
                  "0"         "1"
                 /   \       /   \
             "00"   "01"  "10"   "11"
             / \    / \    / \    / \
          "000" "001" "010" "011" "100" "101" "110" "111"
```

**Analysis:**
- Height of tree: n
- Nodes at each level: 2^level
- Total nodes: 2^0 + 2^1 + ... + 2^n = 2^(n+1) - 1
- Time Complexity: O(2^n)
- Space Complexity: O(n) - recursion depth

### Example 3: Count Ways to Climb N Stairs

**Problem:** You can climb 1 or 2 stairs at a time. Count ways to reach the top.

```python
def count_ways(n):
    """
    Count ways to climb n stairs
    Can take 1 or 2 steps at a time
    
    Base cases:
    - 0 stairs: 1 way (don't move)
    - 1 stair: 1 way (one step)
    
    Recursive relation:
    ways(n) = ways(n-1) + ways(n-2)
    (Either take 1 step from n-1 or 2 steps from n-2)
    """
    if n == 0 or n == 1:
        return 1
    
    # Two ways to reach nth stair
    return count_ways(n - 1) + count_ways(n - 2)

# Test
for i in range(6):
    print(f"Ways to climb {i} stairs: {count_ways(i)}")
```

**Output:**
```
Ways to climb 0 stairs: 1
Ways to climb 1 stairs: 1
Ways to climb 2 stairs: 2
Ways to climb 3 stairs: 3
Ways to climb 4 stairs: 5
Ways to climb 5 stairs: 8
```

**Note:** This is the Fibonacci sequence! Same pattern, different problem.

### With Memoization (Optimized)

```python
def count_ways_memo(n, memo={}):
    """Optimized version with memoization"""
    if n in memo:
        return memo[n]
    
    if n == 0 or n == 1:
        return 1
    
    memo[n] = count_ways_memo(n - 1, memo) + count_ways_memo(n - 2, memo)
    return memo[n]

# Test with larger input
print(count_ways_memo(50))  # Fast!
# Without memoization, this would take extremely long
```

---

## Key Takeaways from Chapter 2

### 1. Basic Patterns Learned

✅ Print sequences (forward/backward)  
✅ Mathematical calculations (sum, factorial, power)  
✅ Number manipulation (reverse, count digits)

### 2. Two Recursion Styles

| Functional | Parameterized |
|-----------|---------------|
| Returns result | Carries result in parameters |
| Backtracking phase | Forward phase |
| Non-tail recursive | Often tail recursive |
| Natural but less efficient | More efficient, optimizable |

### 3. Multiple Recursive Calls

⚠️ **Warning Signs:**
- Exponential time complexity: O(2^n)
- Many repeated calculations
- Overlapping subproblems

✅ **Solution: Memoization**
- Store calculated results
- Check before computing
- Converts O(2^n) → O(n)

### 4. Problem-Solving Steps

1. **Identify base case(s)** - smallest subproblem
2. **Define recursive relation** - how to break down problem
3. **Ensure progress** - moving toward base case
4. **Choose style** - functional vs parameterized
5. **Optimize if needed** - memoization for overlapping subproblems

---

## Practice Problems

### Easy
1. Print sum of digits of a number
2. Check if number is palindrome
3. Count zeros in a number
4. Product of first N numbers
5. Print all numbers divisible by 5 from 1 to N

### Medium
6. GCD of two numbers (Euclidean algorithm)
7. LCM using recursion
8. Sum of series: 1 + 1/2 + 1/3 + ... + 1/n
9. Check if array is sorted (recursion)
10. Binary search using recursion

### Challenge
11. Implement both functional and parameterized versions for:
    - Count digits in a number
    - Check if string is palindrome
    - Reverse an array
12. Optimize Fibonacci using memoization
13. Count ways to climb N stairs if you can take 1, 2, or 3 steps
14. Tower of Hanoi for N disks
15. Print all subsets of a string (Introduction to next chapter)

---

## Common Mistakes to Avoid

❌ Missing base case → Infinite recursion  
❌ Wrong progress → Never reaching base case  
❌ Forgetting return statement  
❌ Not handling edge cases (n=0, n=1, empty input)  
❌ Using multiple recursion without memoization for large inputs  
❌ Modifying global state without care

✅ **Best Practices:**
- Always define base case first
- Test with small inputs (n=0, n=1, n=2)
- Draw recursion tree for understanding
- Use memoization for overlapping subproblems
- Consider converting to parameterized (tail recursive) form
