# Chapter 6: Combination and Permutation Patterns

## Understanding the Difference

### Combinations vs Permutations

**Combinations:** Order doesn't matter
- {1, 2} and {2, 1} are the **same** combination
- Used when selecting items where order is irrelevant
- Formula: C(n, k) = n! / (k! √ó (n-k)!)

**Permutations:** Order matters
- [1, 2] and [2, 1] are **different** permutations  
- Used when arrangement matters
- Formula: P(n, k) = n! / (n-k)!

**Examples:**
```
Array: [1, 2, 3]

Combinations of size 2:
{1, 2}, {1, 3}, {2, 3}  ‚Üí 3 combinations

Permutations of size 2:
[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]  ‚Üí 6 permutations
```

---

## 6.1 Combination Pattern

### Key Insight for Combinations

To avoid duplicates in combinations:
- **Use a start index** that only moves forward
- Never go back to previous indices
- This ensures {1, 2} is generated but {2, 1} is not

### Pattern 1: Combinations of Size K

```python
def combinations(arr, k, start=0, current=[]):
    """
    Generate all combinations of size k from array
    
    Time: O(C(n,k) √ó k) where C(n,k) = n!/(k!(n-k)!)
    Space: O(k) - recursion depth
    """
    # Base case: found combination of size k
    if len(current) == k:
        print(current)
        return
    
    # Try each element from start to end
    for i in range(start, len(arr)):
        # Include current element
        combinations(arr, k, i + 1, current + [arr[i]])

# Test
print("Combinations of size 2 from [1, 2, 3, 4]:")
combinations([1, 2, 3, 4], 2)
```

**Output:**
```
Combinations of size 2 from [1, 2, 3, 4]:
[1, 2]
[1, 3]
[1, 4]
[2, 3]
[2, 4]
[3, 4]
```

**Recursion Tree:**
```
For combinations([1,2,3], 2):

                    ([], start=0)
        /               |              \
    ([1], 1)        ([2], 2)        ([3], 3)
    /     \             |
([1,2], 2) ([1,3], 3) ([2,3], 3)
    ‚úì           ‚úì          ‚úì

Note: Start index ensures we never go backwards
- After picking 1, we start from index 1 (can't pick 1 again)
- After picking 2, we start from index 2 (can't pick 1 or 2)
```

---

### Pattern 2: Combination Sum (Elements Can Repeat)

**Problem:** Find all combinations that sum to target. Elements can be reused unlimited times.

```python
def combination_sum(arr, target, start=0, current=[], current_sum=0):
    """
    Find all combinations that sum to target
    Elements can be reused
    
    Example: arr=[2,3,6,7], target=7
    Output: [[2,2,3], [7]]
    
    Time: O(2^target), Space: O(target)
    """
    # Base case: target reached
    if current_sum == target:
        print(current)
        return
    
    # Base case: exceeded target
    if current_sum > target:
        return
    
    # Try each element from start (can reuse same element)
    for i in range(start, len(arr)):
        # Include current element (i not i+1 ‚Üí can reuse)
        combination_sum(arr, target, i, 
                       current + [arr[i]], 
                       current_sum + arr[i])

# Test
print("Combinations summing to 7 from [2, 3, 6, 7]:")
combination_sum([2, 3, 6, 7], 7)
```

**Output:**
```
Combinations summing to 7 from [2, 3, 6, 7]:
[2, 2, 3]
[7]
```

**Key Difference:**
- `combination_sum(arr, target, i, ...)` ‚Üí Can reuse element at index i
- `combinations(arr, k, i + 1, ...)` ‚Üí Move to next element

**Recursion Tree:**
```
For combination_sum([2,3,5], 8):

                        ([], sum=0, start=0)
            /                  |                \
    ([2], 2, 0)          ([3], 3, 1)       ([5], 5, 2)
    /     |     \            /    \              |
([2,2],4) ([2,3],5) ...  ([3,3],6) ([3,5],8)‚úì  ([5,5],10)X
  /  |  \     
([2,2,2],6) ([2,2,3],7) ([2,2,5],9)X
    ...
([2,3,3],8)‚úì
```

---

### Pattern 3: Combination Sum II (Each Element Used Once)

**Problem:** Find all combinations that sum to target. Each element used at most once. Array may have duplicates.

```python
def combination_sum2(arr, target, start=0, current=[], current_sum=0):
    """
    Find combinations summing to target
    Each element used once, array may have duplicates
    
    Example: arr=[10,1,2,7,6,1,5], target=8
    Output: [[1,1,6], [1,2,5], [1,7], [2,6]]
    
    Time: O(2^n), Space: O(n)
    """
    # Base case
    if current_sum == target:
        print(current)
        return
    
    if current_sum > target:
        return
    
    for i in range(start, len(arr)):
        # Skip duplicates at same level
        if i > start and arr[i] == arr[i - 1]:
            continue
        
        # Include current element (i+1 ‚Üí can't reuse)
        combination_sum2(arr, target, i + 1, 
                        current + [arr[i]], 
                        current_sum + arr[i])

# Test
arr = [10, 1, 2, 7, 6, 1, 5]
arr.sort()  # IMPORTANT: Must sort to handle duplicates
print("Combinations summing to 8:")
combination_sum2(arr, 8)
```

**Output:**
```
Combinations summing to 8:
[1, 1, 6]
[1, 2, 5]
[1, 7]
[2, 6]
```

**Critical Pattern: Skip Duplicates**
```python
# At each level, skip duplicate elements
if i > start and arr[i] == arr[i - 1]:
    continue
```

**Why This Works:**
```
arr = [1, 1, 2], target = 3
After sorting: [1, 1, 2]

Without duplicate handling:
[1, 2] (using first 1)
[1, 2] (using second 1)  ‚Üê DUPLICATE!

With duplicate handling:
                    ([], start=0)
            /              |            \
        ([1], 1)      ([1], 2) SKIP   ([2], 2)
         /    \
    ([1,1], 2) ([1,2], 3)‚úì
        ...

At level with start=0:
- i=0: Include first 1
- i=1: Skip (i > start and arr[1]==arr[0])
- i=2: Include 2
```

---

### Pattern 4: Combination Sum III (Fixed Size K)

**Problem:** Find all combinations of k numbers that sum to n. Only use numbers 1-9, each number used once.

```python
def combination_sum3(k, n, start=1, current=[]):
    """
    Find k numbers (1-9) that sum to n
    
    Example: k=3, n=7
    Output: [[1,2,4]]
    
    Time: O(C(9,k)), Space: O(k)
    """
    # Base case: found k numbers
    if len(current) == k:
        if sum(current) == n:
            print(current)
        return
    
    # Base case: exceeded target with fewer than k numbers
    if sum(current) > n:
        return
    
    # Try numbers from start to 9
    for i in range(start, 10):
        combination_sum3(k, n, i + 1, current + [i])

# Test
print("Combinations of 3 numbers summing to 9:")
combination_sum3(3, 9)
```

**Output:**
```
Combinations of 3 numbers summing to 9:
[1, 2, 6]
[1, 3, 5]
[2, 3, 4]
```

---

### Pattern 5: All Subsets (Power Set)

This is actually a combination problem where we generate all possible sizes.

```python
def power_set(arr):
    """
    Generate all subsets (power set)
    This is combinations of all sizes: 0 to n
    """
    result = []
    
    def backtrack(start, current):
        # Add current combination
        result.append(current[:])
        
        # Try adding each remaining element
        for i in range(start, len(arr)):
            current.append(arr[i])
            backtrack(i + 1, current)
            current.pop()  # Backtrack
    
    backtrack(0, [])
    return result

# Test
subsets = power_set([1, 2, 3])
print(f"Total subsets: {len(subsets)}")
for subset in sorted(subsets, key=len):
    print(subset)
```

**Output:**
```
Total subsets: 8
[]
[1]
[2]
[3]
[1, 2]
[1, 3]
[2, 3]
[1, 2, 3]
```

---

## 6.2 Permutation Pattern

### Key Insight for Permutations

For permutations, we need to:
- Try **every** element at each position (not just forward)
- Track which elements are already used (visited array or swap method)
- Generate all possible orderings

### Pattern 1: All Permutations

#### Method 1: Using Visited Array

```python
def permutations_visited(arr):
    """
    Generate all permutations using visited array
    
    Time: O(n! √ó n), Space: O(n)
    """
    result = []
    visited = [False] * len(arr)
    
    def backtrack(current):
        # Base case: permutation complete
        if len(current) == len(arr):
            result.append(current[:])
            return
        
        # Try each unvisited element
        for i in range(len(arr)):
            if visited[i]:
                continue
            
            # Choose
            visited[i] = True
            current.append(arr[i])
            
            # Explore
            backtrack(current)
            
            # Unchoose (backtrack)
            current.pop()
            visited[i] = False
    
    backtrack([])
    return result

# Test
perms = permutations_visited([1, 2, 3])
print(f"Total permutations: {len(perms)}")
for perm in perms:
    print(perm)
```

**Output:**
```
Total permutations: 6
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]
```

**Recursion Tree:**
```
For permutations([1,2,3]):

                        []
        /               |               \
      [1]              [2]              [3]
    /    \           /    \           /    \
[1,2]  [1,3]     [2,1]  [2,3]     [3,1]  [3,2]
  |      |         |      |         |      |
[1,2,3][1,3,2] [2,1,3][2,3,1] [3,1,2][3,2,1]

At each level, we can choose any unvisited element
```

#### Method 2: Using Swap (In-Place)

```python
def permutations_swap(arr, left=0):
    """
    Generate permutations using swap method
    More space efficient (modifies in-place)
    
    Time: O(n!), Space: O(n) - only recursion stack
    """
    arr = list(arr)  # Convert to list if needed
    result = []
    
    def backtrack(left):
        # Base case
        if left == len(arr):
            result.append(arr[:])
            return
        
        # Try swapping with each position from left to end
        for i in range(left, len(arr)):
            # Swap
            arr[left], arr[i] = arr[i], arr[left]
            
            # Recurse
            backtrack(left + 1)
            
            # Backtrack (undo swap)
            arr[left], arr[i] = arr[i], arr[left]
    
    backtrack(0)
    return result

# Test
perms = permutations_swap([1, 2, 3])
for perm in perms:
    print(perm)
```

**How Swap Method Works:**
```
[1, 2, 3]

Fix position 0:
  Swap 0‚Üî0: [1,2,3] ‚Üí Fix position 1:
    Swap 1‚Üî1: [1,2,3] ‚Üí Fix position 2: [1,2,3] ‚úì
    Swap 1‚Üî2: [1,3,2] ‚Üí Fix position 2: [1,3,2] ‚úì
  
  Swap 0‚Üî1: [2,1,3] ‚Üí Fix position 1:
    Swap 1‚Üî1: [2,1,3] ‚Üí Fix position 2: [2,1,3] ‚úì
    Swap 1‚Üî2: [2,3,1] ‚Üí Fix position 2: [2,3,1] ‚úì
  
  Swap 0‚Üî2: [3,2,1] ‚Üí Fix position 1:
    Swap 1‚Üî1: [3,2,1] ‚Üí Fix position 2: [3,2,1] ‚úì
    Swap 1‚Üî2: [3,1,2] ‚Üí Fix position 2: [3,1,2] ‚úì
```

---

### Pattern 2: Permutations with Duplicates

**Problem:** Generate permutations when array contains duplicates.

```python
def permutations_unique(arr):
    """
    Generate unique permutations when array has duplicates
    
    Example: [1,1,2] ‚Üí [1,1,2], [1,2,1], [2,1,1]
    
    Time: O(n! √ó n), Space: O(n)
    """
    arr.sort()  # IMPORTANT: Sort to identify duplicates
    result = []
    visited = [False] * len(arr)
    
    def backtrack(current):
        if len(current) == len(arr):
            result.append(current[:])
            return
        
        for i in range(len(arr)):
            # Skip if already visited
            if visited[i]:
                continue
            
            # Skip duplicates: if current same as previous and previous not visited
            if i > 0 and arr[i] == arr[i-1] and not visited[i-1]:
                continue
            
            # Choose
            visited[i] = True
            current.append(arr[i])
            
            # Explore
            backtrack(current)
            
            # Unchoose
            current.pop()
            visited[i] = False
    
    backtrack([])
    return result

# Test
perms = permutations_unique([1, 1, 2])
print(f"Unique permutations of [1,1,2]: {len(perms)}")
for perm in perms:
    print(perm)
```

**Output:**
```
Unique permutations of [1,1,2]: 3
[1, 1, 2]
[1, 2, 1]
[2, 1, 1]
```

**Critical Pattern: Skip Duplicates**
```python
# Skip if same as previous and previous not used
if i > 0 and arr[i] == arr[i-1] and not visited[i-1]:
    continue
```

**Why This Works:**
```
arr = [1, 1, 2] (sorted)
      [0, 1, 2] (indices)

Rule: Always use first occurrence of duplicate before second

At position 0:
- Can use arr[0]=1 (first 1)
- Skip arr[1]=1 (second 1, since first 1 not used)
- Can use arr[2]=2

This ensures [1‚ÇÅ, 1‚ÇÇ, 2] is generated but [1‚ÇÇ, 1‚ÇÅ, 2] is not
```

---

### Pattern 3: Next Permutation

**Problem:** Find the next lexicographically greater permutation.

```python
def next_permutation(arr):
    """
    Find next lexicographically greater permutation
    
    Example: [1,2,3] ‚Üí [1,3,2]
    Example: [3,2,1] ‚Üí [1,2,3] (wrap around)
    
    Time: O(n), Space: O(1)
    """
    n = len(arr)
    
    # Step 1: Find first decreasing element from right
    i = n - 2
    while i >= 0 and arr[i] >= arr[i + 1]:
        i -= 1
    
    # If no such element, array is in descending order
    if i == -1:
        arr.reverse()
        return arr
    
    # Step 2: Find element just larger than arr[i]
    j = n - 1
    while arr[j] <= arr[i]:
        j -= 1
    
    # Step 3: Swap
    arr[i], arr[j] = arr[j], arr[i]
    
    # Step 4: Reverse the portion after i
    arr[i + 1:] = reversed(arr[i + 1:])
    
    return arr

# Test
print(next_permutation([1, 2, 3]))  # [1, 3, 2]
print(next_permutation([1, 3, 2]))  # [2, 1, 3]
print(next_permutation([3, 2, 1]))  # [1, 2, 3]
```

**Step-by-Step Example:**
```
Input: [1, 3, 5, 4, 2]

Step 1: Find first decreasing from right
[1, 3, 5, 4, 2]
       ‚Üë
     i=1 (3 < 5)

Step 2: Find element just larger than 3
[1, 3, 5, 4, 2]
          ‚Üë
        j=3 (4 > 3)

Step 3: Swap arr[1] and arr[3]
[1, 4, 5, 3, 2]

Step 4: Reverse from i+1 to end
[1, 4, 2, 3, 5]

Output: [1, 4, 2, 3, 5]
```

---

## 6.3 Advanced Combination Problems

### Problem 1: Letter Combinations of Phone Number

**Problem:** Given a digit string, return all possible letter combinations.

```python
def letter_combinations(digits):
    """
    Phone keypad letter combinations
    
    Example: "23"
    Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]
    
    Time: O(4^n), Space: O(n)
    """
    if not digits:
        return []
    
    # Phone keypad mapping
    phone = {
        '2': 'abc', '3': 'def', '4': 'ghi',
        '5': 'jkl', '6': 'mno', '7': 'pqrs',
        '8': 'tuv', '9': 'wxyz'
    }
    
    result = []
    
    def backtrack(index, current):
        # Base case: processed all digits
        if index == len(digits):
            result.append(current)
            return
        
        # Get letters for current digit
        letters = phone[digits[index]]
        
        # Try each letter
        for letter in letters:
            backtrack(index + 1, current + letter)
    
    backtrack(0, "")
    return result

# Test
combos = letter_combinations("23")
print(f"Total combinations: {len(combos)}")
print(combos)
```

**Recursion Tree:**
```
For "23":

                        ""
            /           |           \
          "a"          "b"          "c"
        /  |  \      /  |  \      /  |  \
     "ad""ae""af" "bd""be""bf" "cd""ce""cf"
```

---

### Problem 2: Generate Parentheses

**Problem:** Generate all valid combinations of n pairs of parentheses.

```python
def generate_parentheses(n):
    """
    Generate all valid parentheses combinations
    
    Example: n=3
    Output: ["((()))","(()())","(())()","()(())","()()()"]
    
    Time: O(4^n / ‚àön) Catalan number
    Space: O(n)
    """
    result = []
    
    def backtrack(current, open_count, close_count):
        # Base case: used all parentheses
        if len(current) == 2 * n:
            result.append(current)
            return
        
        # Add opening parenthesis if we can
        if open_count < n:
            backtrack(current + '(', open_count + 1, close_count)
        
        # Add closing parenthesis if valid
        if close_count < open_count:
            backtrack(current + ')', open_count, close_count + 1)
    
    backtrack("", 0, 0)
    return result

# Test
parens = generate_parentheses(3)
print(f"Valid parentheses for n=3: {len(parens)}")
for p in parens:
    print(p)
```

**Output:**
```
Valid parentheses for n=3: 5
((()))
(()())
(())()
()(())
()()()
```

**Recursion Tree (Partial):**
```
For n=2:

                    ("", 0, 0)
                    /
                ("(", 1, 0)
            /               \
        ("((", 2, 0)      ("()", 1, 1)
            |               /
        ("(()", 2, 1)   ("()(", 2, 1)
            |               |
        ("(())", 2, 2)‚úì  ("()()", 2, 2)‚úì

Key: Can only add ')' if open_count > close_count
```

---

## Key Takeaways from Chapter 6

### 1. Combinations vs Permutations

| Aspect | Combinations | Permutations |
|--------|-------------|--------------|
| **Order** | Doesn't matter | Matters |
| **Count** | C(n,k) = n!/(k!(n-k)!) | P(n,k) = n!/(n-k)! |
| **Technique** | Start index (forward only) | Try all positions |
| **Example** | {1,2} = {2,1} | [1,2] ‚â† [2,1] |

### 2. Core Patterns

**Combination Pattern:**
```python
def combination(arr, k, start, current):
    if len(current) == k:
        add to result
        return
    for i in range(start, len(arr)):
        combination(arr, k, i+1, current+[arr[i]])
```

**Permutation Pattern:**
```python
def permutation(arr, current, visited):
    if len(current) == len(arr):
        add to result
        return
    for i in range(len(arr)):
        if not visited[i]:
            visited[i] = True
            permutation(arr, current+[arr[i]], visited)
            visited[i] = False  # Backtrack
```

### 3. Handling Duplicates

**For Combinations:**
```python
# Skip duplicates at same level
if i > start and arr[i] == arr[i-1]:
    continue
```

**For Permutations:**
```python
# Use first occurrence before second
if i > 0 and arr[i] == arr[i-1] and not visited[i-1]:
    continue
```

### 4. Complexity Analysis

| Problem | Time | Space | Count |
|---------|------|-------|-------|
| Combinations C(n,k) | O(C(n,k)) | O(k) | n!/(k!(n-k)!) |
| Permutations P(n) | O(n!) | O(n) | n! |
| Power Set | O(2^n) | O(n) | 2^n |
| With duplicates | Same | Same | Less (unique only) |

---

## Practice Problems

### Easy
1. Generate all subsets of size k
2. Permutations of string
3. Combinations summing to target (basic)
4. Generate all binary strings of length n

### Medium
5. Letter case permutation
6. Beautiful arrangements
7. Combination sum (all variations)
8. Permutation sequence (kth permutation)
9. Combination iterator
10. Unique paths with obstacles

### Hard
11. N-Queens (combinations + validation)
12. Sudoku solver (permutations + constraints)
13. Word search II (combinations + trie)
14. Expression add operators
15. Remove invalid parentheses

### Challenge
16. Generate all valid IP addresses
17. Restore IP addresses
18. Palindrome partitioning
19. Word break II
20. Combination sum IV (DP + combinations)

---

## Common Mistakes to Avoid

‚ùå **Not sorting before handling duplicates**
```python
# Wrong
for i in range(start, len(arr)):
    if i > start and arr[i] == arr[i-1]:  # Won't work!
        continue

# Right
arr.sort()  # Must sort first!
for i in range(start, len(arr)):
    if i > start and arr[i] == arr[i-1]:
        continue
```

‚ùå **Forgetting to backtrack**
```python
# Wrong
visited[i] = True
backtrack(...)
# Missing: visited[i] = False

# Right
visited[i] = True
backtrack(...)
visited[i] = False  # Essential!
```

‚ùå **Using wrong index increment**
```python
# Combinations (can reuse)
backtrack(i, ...)  # Same index

# Combinations (can't reuse)
backtrack(i+1, ...)  # Next index

# Permutations (all positions)
for i in range(len(arr)):  # All indices
```

Master these patterns and you'll handle any combination/permutation problem with confidence! üéØ
