# Chapter 11: Graph Recursion (DFS)

## Understanding Graphs

### What is a Graph?

A **graph** is a collection of nodes (vertices) connected by edges.

**Components:**
- **Vertices (V):** Nodes in the graph
- **Edges (E):** Connections between nodes
- **Directed/Undirected:** Edges have direction or not
- **Weighted/Unweighted:** Edges have weights or not

**Graph Representation:**
```python
# 1. Adjacency List (most common)
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0],
    3: [1],
    4: [1]
}

# 2. Adjacency Matrix
graph = [
    [0, 1, 1, 0, 0],  # Node 0 connects to 1, 2
    [1, 0, 0, 1, 1],  # Node 1 connects to 0, 3, 4
    [1, 0, 0, 0, 0],  # Node 2 connects to 0
    [0, 1, 0, 0, 0],  # Node 3 connects to 1
    [0, 1, 0, 0, 0]   # Node 4 connects to 1
]

# 3. Edge List
edges = [(0, 1), (0, 2), (1, 3), (1, 4)]
```

---

## 11.1 Graph DFS Fundamentals

### What is DFS (Depth-First Search)?

**DFS** explores a graph by going as deep as possible along each branch before backtracking.

**Think of it as:**
- Exploring a maze: follow one path until you hit a dead end, then backtrack
- Recursive by nature (uses call stack)
- Similar to tree traversal but with cycle handling

### Basic DFS Template

```python
def dfs(graph, node, visited):
    """
    Basic DFS template
    
    Time: O(V + E)
    Space: O(V) for visited set + O(V) for recursion stack
    """
    # Mark current node as visited
    visited.add(node)
    
    # Process current node
    print(node, end=' ')
    
    # Recursively visit all unvisited neighbors
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
```

### Complete DFS Implementation

```python
def dfs_traversal(graph, start):
    """
    Complete DFS traversal from start node
    
    Time: O(V + E)
    Space: O(V)
    """
    visited = set()
    result = []
    
    def dfs(node):
        # Mark as visited
        visited.add(node)
        result.append(node)
        
        # Visit all unvisited neighbors
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)
    
    dfs(start)
    return result

# Test
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 5],
    3: [1],
    4: [1],
    5: [2]
}

traversal = dfs_traversal(graph, 0)
print("DFS Traversal:", traversal)
# Output: [0, 1, 3, 4, 2, 5]
```

**Visualization:**
```
Graph:
    0 --- 1 --- 3
    |     |
    2     4
    |
    5

DFS from 0:
1. Visit 0, mark visited: {0}
2. Go to neighbor 1, mark visited: {0, 1}
3. Go to neighbor 3, mark visited: {0, 1, 3}
4. Backtrack to 1, go to 4, mark visited: {0, 1, 3, 4}
5. Backtrack to 0, go to 2, mark visited: {0, 1, 3, 4, 2}
6. Go to neighbor 5, mark visited: {0, 1, 3, 4, 2, 5}

Order: 0 ‚Üí 1 ‚Üí 3 ‚Üí 4 ‚Üí 2 ‚Üí 5
```

### DFS vs BFS Comparison

```
DFS (Depth-First):          BFS (Breadth-First):
- Uses stack/recursion      - Uses queue
- Goes deep first           - Goes level by level
- O(V + E) time            - O(V + E) time
- O(V) space               - O(V) space
- Good for: paths,         - Good for: shortest path,
  cycles, topology           level-order

Example traversal:
    1
   / \
  2   3
 / \
4   5

DFS: 1 ‚Üí 2 ‚Üí 4 ‚Üí 5 ‚Üí 3
BFS: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5
```

---

## 11.2 Connected Components

### Understanding Connected Components

A **connected component** is a maximal set of vertices where each pair is connected by a path.

### Pattern 1: Count Connected Components

```python
def count_components(n, edges):
    """
    Count number of connected components in undirected graph
    
    Args:
        n: number of nodes (0 to n-1)
        edges: list of edges
    
    Time: O(V + E), Space: O(V + E)
    """
    # Build adjacency list
    graph = {i: [] for i in range(n)}
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    visited = set()
    count = 0
    
    def dfs(node):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)
    
    # Try to start DFS from each unvisited node
    for node in range(n):
        if node not in visited:
            dfs(node)
            count += 1
    
    return count

# Test
n = 5
edges = [(0, 1), (1, 2), (3, 4)]
print(f"Connected components: {count_components(n, edges)}")
# Output: 2 (components: {0,1,2} and {3,4})
```

**Visualization:**
```
Graph with 5 nodes:
0 --- 1 --- 2    3 --- 4

Component 1: {0, 1, 2}
Component 2: {3, 4}

Process:
1. Start DFS from 0 (unvisited)
   - Visit 0, 1, 2
   - Mark all as visited
   - count = 1

2. Node 3 unvisited, start DFS
   - Visit 3, 4
   - Mark as visited
   - count = 2

Total components: 2
```

### Pattern 2: Find All Connected Components

```python
def find_all_components(n, edges):
    """
    Find all connected components
    
    Time: O(V + E), Space: O(V + E)
    """
    # Build graph
    graph = {i: [] for i in range(n)}
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    visited = set()
    components = []
    
    def dfs(node, component):
        visited.add(node)
        component.append(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor, component)
    
    for node in range(n):
        if node not in visited:
            component = []
            dfs(node, component)
            components.append(component)
    
    return components

# Test
n = 7
edges = [(0, 1), (1, 2), (3, 4), (5, 6)]
components = find_all_components(n, edges)
print("All components:", components)
# Output: [[0, 1, 2], [3, 4], [5, 6]]
```

### Pattern 3: Strongly Connected Components (Directed Graph)

**Kosaraju's Algorithm** using DFS:

```python
def strongly_connected_components(n, edges):
    """
    Find strongly connected components in directed graph
    Uses Kosaraju's algorithm
    
    Time: O(V + E), Space: O(V + E)
    """
    # Build graph and reverse graph
    graph = {i: [] for i in range(n)}
    reverse_graph = {i: [] for i in range(n)}
    
    for u, v in edges:
        graph[u].append(v)
        reverse_graph[v].append(u)
    
    # Step 1: Fill order using DFS
    visited = set()
    stack = []
    
    def fill_order(node):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                fill_order(neighbor)
        stack.append(node)  # Add after visiting all neighbors
    
    for node in range(n):
        if node not in visited:
            fill_order(node)
    
    # Step 2: DFS on reverse graph in order of stack
    visited.clear()
    sccs = []
    
    def dfs(node, component):
        visited.add(node)
        component.append(node)
        for neighbor in reverse_graph[node]:
            if neighbor not in visited:
                dfs(neighbor, component)
    
    while stack:
        node = stack.pop()
        if node not in visited:
            component = []
            dfs(node, component)
            sccs.append(component)
    
    return sccs

# Test
n = 5
edges = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4)]
sccs = strongly_connected_components(n, edges)
print("Strongly connected components:", sccs)
# Output: [[0, 2, 1], [3], [4]]
```

**Visualization:**
```
Directed Graph:
    0 ‚Üí 1 ‚Üí 3 ‚Üí 4
    ‚Üë   ‚Üì
    ‚îî‚îÄ‚Üê 2

SCCs:
1. {0, 1, 2} - can reach each other
2. {3} - standalone
3. {4} - standalone

Strong connectivity: For every pair (u,v) in SCC,
there exists path u‚Üív AND path v‚Üíu
```

---

## 11.3 Cycle Detection

### Pattern 1: Cycle Detection in Undirected Graph

```python
def has_cycle_undirected(n, edges):
    """
    Detect cycle in undirected graph using DFS
    
    Time: O(V + E), Space: O(V + E)
    """
    # Build adjacency list
    graph = {i: [] for i in range(n)}
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    visited = set()
    
    def dfs(node, parent):
        visited.add(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                if dfs(neighbor, node):
                    return True
            elif neighbor != parent:
                # Visited neighbor that's not parent = cycle
                return True
        
        return False
    
    # Check all components
    for node in range(n):
        if node not in visited:
            if dfs(node, -1):
                return True
    
    return False

# Test
n = 4
edges_no_cycle = [(0, 1), (1, 2), (2, 3)]
edges_with_cycle = [(0, 1), (1, 2), (2, 3), (3, 0)]

print(has_cycle_undirected(n, edges_no_cycle))      # False
print(has_cycle_undirected(n, edges_with_cycle))    # True
```

**Why Track Parent?**
```
Undirected Graph:
0 --- 1
|     |
3 --- 2

Without parent tracking:
DFS: 0 ‚Üí 1
From 1, neighbor 0 is visited
FALSE POSITIVE: Think it's a cycle!

With parent tracking:
DFS: 0 ‚Üí 1 (parent=0)
From 1, neighbor 0 is visited but it's parent
Skip it, continue
0 ‚Üí 2 ‚Üí 3
From 3, neighbor 0 is visited and NOT parent
CYCLE DETECTED ‚úì
```

### Pattern 2: Cycle Detection in Directed Graph

```python
def has_cycle_directed(n, edges):
    """
    Detect cycle in directed graph
    Use recursion stack to track current path
    
    Time: O(V + E), Space: O(V + E)
    """
    # Build graph
    graph = {i: [] for i in range(n)}
    for u, v in edges:
        graph[u].append(v)
    
    visited = set()
    rec_stack = set()  # Recursion stack (current path)
    
    def dfs(node):
        visited.add(node)
        rec_stack.add(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                if dfs(neighbor):
                    return True
            elif neighbor in rec_stack:
                # Back edge to node in current path = cycle
                return True
        
        rec_stack.remove(node)  # Backtrack
        return False
    
    for node in range(n):
        if node not in visited:
            if dfs(node):
                return True
    
    return False

# Test
n = 4
edges_no_cycle = [(0, 1), (1, 2), (2, 3)]
edges_with_cycle = [(0, 1), (1, 2), (2, 3), (3, 1)]

print(has_cycle_directed(n, edges_no_cycle))       # False
print(has_cycle_directed(n, edges_with_cycle))     # True
```

**Recursion Stack Concept:**
```
Graph with cycle:
0 ‚Üí 1 ‚Üí 2 ‚Üí 3
    ‚Üë_________|

DFS from 0:
Visit 0: visited={0}, rec_stack={0}
Visit 1: visited={0,1}, rec_stack={0,1}
Visit 2: visited={0,1,2}, rec_stack={0,1,2}
Visit 3: visited={0,1,2,3}, rec_stack={0,1,2,3}
Check neighbor 1: 1 is in rec_stack!
CYCLE DETECTED ‚úì

After detecting cycle, we backtrack:
rec_stack={0,1,2} then {0,1} then {0} then {}
```

### Pattern 3: Find All Cycles

```python
def find_all_cycles(n, edges):
    """
    Find all cycles in directed graph
    
    Time: O(V + E), Space: O(V + E)
    """
    graph = {i: [] for i in range(n)}
    for u, v in edges:
        graph[u].append(v)
    
    visited = set()
    rec_stack = set()
    path = []
    cycles = []
    
    def dfs(node):
        visited.add(node)
        rec_stack.add(node)
        path.append(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)
            elif neighbor in rec_stack:
                # Found cycle: extract it from path
                cycle_start = path.index(neighbor)
                cycle = path[cycle_start:] + [neighbor]
                cycles.append(cycle)
        
        path.pop()
        rec_stack.remove(node)
    
    for node in range(n):
        if node not in visited:
            dfs(node)
    
    return cycles

# Test
n = 4
edges = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 1)]
cycles = find_all_cycles(n, edges)
print("All cycles:", cycles)
# Output: [[0, 1, 2, 0], [1, 3, 1]]
```

---

## 11.4 Topological Sort

### Understanding Topological Sort

**Topological sort** is a linear ordering of vertices in a directed acyclic graph (DAG) such that for every edge u‚Üív, u comes before v in the ordering.

**Use cases:**
- Course scheduling (prerequisites)
- Task scheduling
- Build systems
- Dependency resolution

### DFS-Based Topological Sort

```python
def topological_sort(n, edges):
    """
    Topological sort using DFS
    
    Time: O(V + E), Space: O(V + E)
    """
    # Build graph
    graph = {i: [] for i in range(n)}
    for u, v in edges:
        graph[u].append(v)
    
    visited = set()
    stack = []
    
    def dfs(node):
        visited.add(node)
        
        # Visit all neighbors first
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)
        
        # Add to stack after visiting all neighbors
        stack.append(node)
    
    # DFS from all unvisited nodes
    for node in range(n):
        if node not in visited:
            dfs(node)
    
    # Reverse stack for topological order
    return stack[::-1]

# Test
n = 6
edges = [(5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1)]
topo_order = topological_sort(n, edges)
print("Topological order:", topo_order)
# Output: [5, 4, 2, 3, 1, 0] or [4, 5, 2, 0, 3, 1]
```

**Visualization:**
```
Graph:
    5 ‚Üí 0
    ‚Üì   
    2 ‚Üí 3 ‚Üí 1
            ‚Üë
    4 ------‚îò

Topological orders (multiple valid):
[5, 4, 2, 3, 1, 0]
[4, 5, 2, 3, 1, 0]
[5, 2, 4, 3, 1, 0]
etc.

Key: For every edge u‚Üív, u appears before v

DFS Process:
1. Visit 5: go deep to 2 ‚Üí 3 ‚Üí 1
   Stack after: [1, 3, 2]
2. Visit 0: Stack: [1, 3, 2, 0]
3. Add 5: Stack: [1, 3, 2, 0, 5]
4. Visit 4: Stack: [1, 3, 2, 0, 5, 4]
5. Reverse: [4, 5, 0, 2, 3, 1]
```

### Pattern: Course Schedule Problems

**Problem 1: Can Finish All Courses?**
```python
def can_finish(num_courses, prerequisites):
    """
    Check if all courses can be finished
    (Check if topological sort exists = no cycle)
    
    Time: O(V + E), Space: O(V + E)
    """
    # Build graph
    graph = {i: [] for i in range(num_courses)}
    for course, prereq in prerequisites:
        graph[prereq].append(course)
    
    visited = set()
    rec_stack = set()
    
    def has_cycle(node):
        visited.add(node)
        rec_stack.add(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                if has_cycle(neighbor):
                    return True
            elif neighbor in rec_stack:
                return True
        
        rec_stack.remove(node)
        return False
    
    # Check all components for cycles
    for course in range(num_courses):
        if course not in visited:
            if has_cycle(course):
                return False
    
    return True

# Test
num_courses = 4
prerequisites = [(1, 0), (2, 1), (3, 2)]  # 0‚Üí1‚Üí2‚Üí3
print(can_finish(num_courses, prerequisites))  # True

prerequisites_cycle = [(1, 0), (0, 1)]  # 0‚Üî1 cycle
print(can_finish(2, prerequisites_cycle))  # False
```

**Problem 2: Course Schedule Order**
```python
def find_order(num_courses, prerequisites):
    """
    Find order to take all courses
    Return topological sort
    
    Time: O(V + E), Space: O(V + E)
    """
    # Build graph
    graph = {i: [] for i in range(num_courses)}
    for course, prereq in prerequisites:
        graph[prereq].append(course)
    
    visited = set()
    rec_stack = set()
    stack = []
    has_cycle_flag = [False]
    
    def dfs(node):
        if has_cycle_flag[0]:
            return
        
        visited.add(node)
        rec_stack.add(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)
            elif neighbor in rec_stack:
                has_cycle_flag[0] = True
                return
        
        rec_stack.remove(node)
        stack.append(node)
    
    for course in range(num_courses):
        if course not in visited:
            dfs(course)
            if has_cycle_flag[0]:
                return []
    
    return stack[::-1]

# Test
num_courses = 4
prerequisites = [(1, 0), (2, 0), (3, 1), (3, 2)]
order = find_order(num_courses, prerequisites)
print("Course order:", order)
# Output: [0, 1, 2, 3] or [0, 2, 1, 3]
```

---

## 11.5 Practical Graph Problems

### Problem 1: Clone Graph

```python
class Node:
    def __init__(self, val=0, neighbors=None):
        self.val = val
        self.neighbors = neighbors if neighbors else []

def clone_graph(node):
    """
    Deep copy a graph
    
    Time: O(V + E), Space: O(V)
    """
    if not node:
        return None
    
    cloned = {}
    
    def dfs(node):
        if node in cloned:
            return cloned[node]
        
        # Create clone
        clone = Node(node.val)
        cloned[node] = clone
        
        # Clone neighbors
        for neighbor in node.neighbors:
            clone.neighbors.append(dfs(neighbor))
        
        return clone
    
    return dfs(node)
```

### Problem 2: All Paths from Source to Target

```python
def all_paths_source_target(graph):
    """
    Find all paths from node 0 to node n-1
    
    Time: O(2^V √ó V), Space: O(V)
    """
    n = len(graph)
    target = n - 1
    result = []
    
    def dfs(node, path):
        if node == target:
            result.append(path[:])
            return
        
        for neighbor in graph[node]:
            path.append(neighbor)
            dfs(neighbor, path)
            path.pop()  # Backtrack
    
    dfs(0, [0])
    return result

# Test
graph = [[1, 2], [3], [3], []]
# 0 ‚Üí 1 ‚Üí 3
# 0 ‚Üí 2 ‚Üí 3
paths = all_paths_source_target(graph)
print("All paths:", paths)
# Output: [[0, 1, 3], [0, 2, 3]]
```

### Problem 3: Critical Connections (Bridges)

**Tarjan's Algorithm:**
```python
def critical_connections(n, connections):
    """
    Find critical connections (bridges) in network
    Bridge: edge whose removal increases components
    
    Time: O(V + E), Space: O(V + E)
    """
    # Build graph
    graph = {i: [] for i in range(n)}
    for u, v in connections:
        graph[u].append(v)
        graph[v].append(u)
    
    discovery_time = [-1] * n
    low = [-1] * n
    time = [0]
    bridges = []
    
    def dfs(node, parent):
        discovery_time[node] = low[node] = time[0]
        time[0] += 1
        
        for neighbor in graph[node]:
            if neighbor == parent:
                continue
            
            if discovery_time[neighbor] == -1:
                dfs(neighbor, node)
                low[node] = min(low[node], low[neighbor])
                
                # Bridge condition
                if low[neighbor] > discovery_time[node]:
                    bridges.append([node, neighbor])
            else:
                low[node] = min(low[node], discovery_time[neighbor])
    
    for i in range(n):
        if discovery_time[i] == -1:
            dfs(i, -1)
    
    return bridges

# Test
n = 4
connections = [[0, 1], [1, 2], [2, 0], [1, 3]]
bridges = critical_connections(n, connections)
print("Critical connections:", bridges)
# Output: [[1, 3]]
```

---

## Key Takeaways from Chapter 11

### 1. DFS Patterns Summary

| Pattern | Use Case | Key Technique |
|---------|----------|---------------|
| **Basic DFS** | Graph traversal | Visited set |
| **Connected Components** | Find groups | DFS from each unvisited |
| **Cycle Detection (Undirected)** | Find cycles | Track parent |
| **Cycle Detection (Directed)** | Find cycles | Recursion stack |
| **Topological Sort** | Order with dependencies | Post-order DFS |
| **Bridges/Articulation** | Critical edges/nodes | Tarjan's algorithm |

### 2. Common Techniques

**Visited Tracking:**
```python
# Set for unordered tracking
visited = set()

# List/array for index-based
visited = [False] * n

# Dictionary for node objects
visited = {}
```

**State Tracking for Directed Graphs:**
```python
visited = set()      # All visited nodes
rec_stack = set()    # Current path (for cycle detection)

# Three-color approach
# WHITE (0): unvisited
# GRAY (1): in current path
# BLACK (2): fully processed
color = [0] * n
```

### 3. Time & Space Complexity

**Standard DFS:**
- Time: O(V + E) - visit each vertex and edge once
- Space: O(V) - visited set + recursion stack

**With Path Tracking:**
- Time: O(V + E)
- Space: O(V) for path + O(V) for recursion

### 4. Common Mistakes

‚ùå **Forgetting to mark visited**
```python
# Wrong - infinite loop!
def dfs(node):
    for neighbor in graph[node]:
        dfs(neighbor)

# Right
def dfs(node):
    visited.add(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(neighbor)
```

‚ùå **Not handling disconnected graphs**
```python
# Wrong - misses disconnected components
dfs(0)

# Right - check all nodes
for node in range(n):
    if node not in visited:
        dfs(node)
```

---

## Practice Problems

### Easy
1. Number of provinces
2. Find if path exists
3. All ancestors in DAG
4. Keys and rooms
5. Find center of star graph

### Medium
6. Course schedule (I & II)
7. Clone graph
8. Redundant connection
9. Possible bipartition
10. Accounts merge

### Hard
11. Critical connections in network
12. Minimum number of vertices to reach all nodes
13. Longest increasing path in matrix
14. Reconstruct itinerary
15. Alien dictionary

### Challenge
16. Strongly connected components
17. Articulation points
18. Cut vertices and bridges
19. Eulerian path/circuit
20. Hamiltonian path

Master graph DFS and you unlock powerful tools for solving network problems! üï∏Ô∏è
