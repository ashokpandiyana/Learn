# Chapter 3: Recursion on Arrays

## 3.1 Array Traversal Patterns

### Pattern 1: Check if Array is Sorted

**Problem:** Determine if an array is sorted in ascending order.

#### Approach 1: Using Index Parameter

```python
def is_sorted(arr, index=0):
    """
    Check if array is sorted from index to end
    
    Base cases:
    - If index reaches second-last element, array is sorted
    - If current element > next element, array is not sorted
    
    Time: O(n), Space: O(n) - recursion stack
    """
    # Base case: reached end
    if index >= len(arr) - 1:
        return True
    
    # If current element > next element, not sorted
    if arr[index] > arr[index + 1]:
        return False
    
    # Check rest of array
    return is_sorted(arr, index + 1)

# Test cases
print(is_sorted([1, 2, 3, 4, 5]))      # True
print(is_sorted([1, 3, 2, 4, 5]))      # False
print(is_sorted([5, 4, 3, 2, 1]))      # False
print(is_sorted([1]))                   # True
print(is_sorted([]))                    # True
```

**Recursion Flow:**
```
is_sorted([1, 2, 4, 3, 5], 0)
â”œâ”€ arr[0] < arr[1]? Yes (1 < 2)
â””â”€ is_sorted([1, 2, 4, 3, 5], 1)
   â”œâ”€ arr[1] < arr[2]? Yes (2 < 4)
   â””â”€ is_sorted([1, 2, 4, 3, 5], 2)
      â”œâ”€ arr[2] < arr[3]? No (4 > 3)
      â””â”€ return False
```

#### Approach 2: Using Array Slicing

```python
def is_sorted_slice(arr):
    """
    Using array slicing (less efficient due to copying)
    """
    # Base cases
    if len(arr) <= 1:
        return True
    
    # Check first two elements and recurse on rest
    if arr[0] > arr[1]:
        return False
    
    return is_sorted_slice(arr[1:])

# Test
print(is_sorted_slice([1, 2, 3, 4, 5]))  # True
```

**Note:** Array slicing creates a copy, adding O(n) space per call!

---

### Pattern 2: Find Element in Array

```python
def find_element(arr, target, index=0):
    """
    Find if target exists in array
    Returns True if found, False otherwise
    
    Time: O(n), Space: O(n)
    """
    # Base case: reached end without finding
    if index >= len(arr):
        return False
    
    # Base case: found the element
    if arr[index] == target:
        return True
    
    # Search in rest of array
    return find_element(arr, target, index + 1)

# Test
arr = [3, 7, 1, 9, 4, 6]
print(find_element(arr, 9))   # True
print(find_element(arr, 10))  # False
```

#### Variant: Find Index of Element

```python
def find_index(arr, target, index=0):
    """
    Find index of target in array
    Returns index if found, -1 otherwise
    """
    # Base case: not found
    if index >= len(arr):
        return -1
    
    # Base case: found
    if arr[index] == target:
        return index
    
    # Search in rest
    return find_index(arr, target, index + 1)

# Test
arr = [3, 7, 1, 9, 4, 6]
print(find_index(arr, 9))   # 3
print(find_index(arr, 10))  # -1
```

#### Variant: Find Last Index of Element

```python
def find_last_index(arr, target, index=0):
    """
    Find last occurrence of target
    Search entire array and return last found index
    """
    # Base case
    if index >= len(arr):
        return -1
    
    # Recursively search rest of array
    rest_result = find_last_index(arr, target, index + 1)
    
    # If found in rest, return that
    if rest_result != -1:
        return rest_result
    
    # If current element matches and not found in rest
    if arr[index] == target:
        return index
    
    return -1

# Test
arr = [3, 7, 1, 9, 4, 9, 6]
print(find_last_index(arr, 9))  # 5 (last occurrence)
```

---

### Pattern 3: Print All Elements

```python
def print_array(arr, index=0):
    """Print all elements of array"""
    # Base case
    if index >= len(arr):
        return
    
    # Print current element
    print(arr[index], end=" ")
    
    # Process rest
    print_array(arr, index + 1)

# Test
print_array([1, 2, 3, 4, 5])  # Output: 1 2 3 4 5
```

#### Print in Reverse Order

```python
def print_reverse(arr, index=0):
    """Print array in reverse using backtracking"""
    # Base case
    if index >= len(arr):
        return
    
    # Recurse first (go to end)
    print_reverse(arr, index + 1)
    
    # Print during backtrack
    print(arr[index], end=" ")

# Test
print_reverse([1, 2, 3, 4, 5])  # Output: 5 4 3 2 1
```

**Visualization:**
```
print_reverse([1,2,3,4,5], 0)
â””â”€ print_reverse([1,2,3,4,5], 1)
   â””â”€ print_reverse([1,2,3,4,5], 2)
      â””â”€ print_reverse([1,2,3,4,5], 3)
         â””â”€ print_reverse([1,2,3,4,5], 4)
            â””â”€ print_reverse([1,2,3,4,5], 5) [returns]
            â† print 5
         â† print 4
      â† print 3
   â† print 2
â† print 1
```

---

### Pattern 4: Reverse an Array

#### Approach 1: Using Extra Space

```python
def reverse_array_newspace(arr, index=0):
    """
    Create new reversed array
    Space: O(n) for new array + O(n) for recursion = O(n)
    """
    # Base case
    if index >= len(arr):
        return []
    
    # Return: [rest reversed] + [current element]
    return reverse_array_newspace(arr, index + 1) + [arr[index]]

# Test
original = [1, 2, 3, 4, 5]
reversed_arr = reverse_array_newspace(original)
print(reversed_arr)  # [5, 4, 3, 2, 1]
```

#### Approach 2: In-Place Reversal (Two Pointers)

```python
def reverse_array_inplace(arr, start=0, end=None):
    """
    Reverse array in-place using two pointers
    Space: O(n) for recursion only (optimal)
    """
    if end is None:
        end = len(arr) - 1
    
    # Base case: pointers meet or cross
    if start >= end:
        return
    
    # Swap elements
    arr[start], arr[end] = arr[end], arr[start]
    
    # Recurse with moved pointers
    reverse_array_inplace(arr, start + 1, end - 1)

# Test
arr = [1, 2, 3, 4, 5]
reverse_array_inplace(arr)
print(arr)  # [5, 4, 3, 2, 1]
```

**Step-by-Step:**
```
Initial: [1, 2, 3, 4, 5]
         â†‘           â†‘
       start       end

Step 1: Swap 1 and 5
[5, 2, 3, 4, 1]
    â†‘       â†‘
  start   end

Step 2: Swap 2 and 4
[5, 4, 3, 2, 1]
       â†‘
   start/end (overlap â†’ stop)

Final: [5, 4, 3, 2, 1]
```

---

## 3.2 Array Manipulation

### Pattern 1: Find Maximum Element

```python
def find_max(arr, index=0):
    """
    Find maximum element in array
    
    Recursive relation:
    max(arr, index) = max(arr[index], max(arr, index+1))
    """
    # Base case: last element
    if index == len(arr) - 1:
        return arr[index]
    
    # Get max of remaining elements
    max_of_rest = find_max(arr, index + 1)
    
    # Return max of current and rest
    return max(arr[index], max_of_rest)

# Test
print(find_max([3, 7, 1, 9, 4, 6]))  # 9
```

**Recursion Tree:**
```
find_max([3,7,1,9,4,6], 0)
â”œâ”€ current = 3
â””â”€ max_of_rest = find_max([3,7,1,9,4,6], 1)
   â”œâ”€ current = 7
   â””â”€ max_of_rest = find_max([3,7,1,9,4,6], 2)
      â”œâ”€ current = 1
      â””â”€ max_of_rest = find_max([3,7,1,9,4,6], 3)
         â”œâ”€ current = 9
         â””â”€ max_of_rest = find_max([3,7,1,9,4,6], 4)
            â”œâ”€ current = 4
            â””â”€ max_of_rest = find_max([3,7,1,9,4,6], 5)
               â””â”€ return 6
            â””â”€ return max(4, 6) = 6
         â””â”€ return max(9, 6) = 9
      â””â”€ return max(1, 9) = 9
   â””â”€ return max(7, 9) = 9
â””â”€ return max(3, 9) = 9
```

### Pattern 2: Find Minimum Element

```python
def find_min(arr, index=0):
    """Find minimum element in array"""
    # Base case
    if index == len(arr) - 1:
        return arr[index]
    
    # Get min of rest
    min_of_rest = find_min(arr, index + 1)
    
    # Return min of current and rest
    return min(arr[index], min_of_rest)

# Test
print(find_min([3, 7, 1, 9, 4, 6]))  # 1
```

### Pattern 3: Sum of Array Elements

```python
def array_sum(arr, index=0):
    """Calculate sum of all elements"""
    # Base case
    if index >= len(arr):
        return 0
    
    # Current element + sum of rest
    return arr[index] + array_sum(arr, index + 1)

# Test
print(array_sum([1, 2, 3, 4, 5]))  # 15
```

#### Parameterized Version (Tail Recursive)

```python
def array_sum_tail(arr, index=0, total=0):
    """Tail recursive sum"""
    # Base case
    if index >= len(arr):
        return total
    
    # Accumulate and recurse
    return array_sum_tail(arr, index + 1, total + arr[index])

# Test
print(array_sum_tail([1, 2, 3, 4, 5]))  # 15
```

### Pattern 4: Count Occurrences

```python
def count_occurrences(arr, target, index=0):
    """
    Count how many times target appears in array
    """
    # Base case
    if index >= len(arr):
        return 0
    
    # Count current + count in rest
    current_count = 1 if arr[index] == target else 0
    return current_count + count_occurrences(arr, target, index + 1)

# Test
arr = [3, 7, 1, 9, 7, 4, 7, 6]
print(count_occurrences(arr, 7))  # 3
```

### Pattern 5: Find All Indices of Element

```python
def find_all_indices(arr, target, index=0, result=None):
    """
    Find all indices where target appears
    Returns list of indices
    """
    if result is None:
        result = []
    
    # Base case
    if index >= len(arr):
        return result
    
    # If found, add to result
    if arr[index] == target:
        result.append(index)
    
    # Continue searching
    return find_all_indices(arr, target, index + 1, result)

# Test
arr = [3, 7, 1, 9, 7, 4, 7, 6]
print(find_all_indices(arr, 7))  # [1, 4, 6]
```

#### Functional Approach (Without Mutable Parameter)

```python
def find_all_indices_functional(arr, target, index=0):
    """
    Functional approach - returns new list
    """
    # Base case
    if index >= len(arr):
        return []
    
    # Get indices from rest
    rest_indices = find_all_indices_functional(arr, target, index + 1)
    
    # If current matches, add current index
    if arr[index] == target:
        return [index] + rest_indices
    
    return rest_indices

# Test
arr = [3, 7, 1, 9, 7, 4, 7, 6]
print(find_all_indices_functional(arr, 7))  # [1, 4, 6]
```

---

## 3.3 Two-Pointer Recursion

Two-pointer technique is powerful for problems involving comparisons or modifications from both ends of array.

### Pattern 1: Check Palindrome Array

```python
def is_palindrome_array(arr, start=0, end=None):
    """
    Check if array is palindrome using two pointers
    
    Time: O(n/2) = O(n)
    Space: O(n/2) = O(n) - recursion depth
    """
    if end is None:
        end = len(arr) - 1
    
    # Base case: pointers meet or cross
    if start >= end:
        return True
    
    # If elements don't match, not palindrome
    if arr[start] != arr[end]:
        return False
    
    # Check remaining elements
    return is_palindrome_array(arr, start + 1, end - 1)

# Test
print(is_palindrome_array([1, 2, 3, 2, 1]))  # True
print(is_palindrome_array([1, 2, 3, 4, 5]))  # False
print(is_palindrome_array([1]))              # True
print(is_palindrome_array([]))               # True
```

**Visualization:**
```
Array: [1, 2, 3, 2, 1]
        â†‘           â†‘
      start       end
      
Step 1: arr[0] == arr[4]? Yes (1 == 1) âœ“
        [1, 2, 3, 2, 1]
            â†‘       â†‘
          start   end

Step 2: arr[1] == arr[3]? Yes (2 == 2) âœ“
        [1, 2, 3, 2, 1]
               â†‘
           start/end

Step 3: start >= end â†’ return True
```

### Pattern 2: Check String Palindrome

```python
def is_palindrome_string(s, start=0, end=None):
    """Check if string is palindrome"""
    if end is None:
        end = len(s) - 1
    
    # Base case
    if start >= end:
        return True
    
    # Compare characters (case-insensitive)
    if s[start].lower() != s[end].lower():
        return False
    
    return is_palindrome_string(s, start + 1, end - 1)

# Test
print(is_palindrome_string("racecar"))   # True
print(is_palindrome_string("hello"))     # False
print(is_palindrome_string("A man a plan a canal Panama"))  # False (spaces)
```

#### With Space Handling

```python
def is_palindrome_alphanumeric(s, start=0, end=None):
    """
    Check palindrome considering only alphanumeric characters
    """
    if end is None:
        end = len(s) - 1
    
    # Base case
    if start >= end:
        return True
    
    # Skip non-alphanumeric from start
    if not s[start].isalnum():
        return is_palindrome_alphanumeric(s, start + 1, end)
    
    # Skip non-alphanumeric from end
    if not s[end].isalnum():
        return is_palindrome_alphanumeric(s, start, end - 1)
    
    # Compare alphanumeric characters
    if s[start].lower() != s[end].lower():
        return False
    
    return is_palindrome_alphanumeric(s, start + 1, end - 1)

# Test
print(is_palindrome_alphanumeric("A man, a plan, a canal: Panama"))  # True
```

### Pattern 3: Reverse String with Two Pointers

```python
def reverse_string(s, start=0, end=None):
    """
    Reverse string in-place using two pointers
    (Convert string to list for in-place modification)
    """
    # Convert to list if string
    if isinstance(s, str):
        s = list(s)
    
    if end is None:
        end = len(s) - 1
    
    # Base case
    if start >= end:
        return ''.join(s) if isinstance(s, list) else s
    
    # Swap
    s[start], s[end] = s[end], s[start]
    
    # Recurse
    return reverse_string(s, start + 1, end - 1)

# Test
print(reverse_string("hello"))  # "olleh"
```

### Pattern 4: Compare Two Arrays

```python
def arrays_equal(arr1, arr2, index=0):
    """
    Check if two arrays are equal
    """
    # Base case: different lengths
    if len(arr1) != len(arr2):
        return False
    
    # Base case: checked all elements
    if index >= len(arr1):
        return True
    
    # If current elements differ
    if arr1[index] != arr2[index]:
        return False
    
    # Check rest
    return arrays_equal(arr1, arr2, index + 1)

# Test
print(arrays_equal([1, 2, 3], [1, 2, 3]))  # True
print(arrays_equal([1, 2, 3], [1, 2, 4]))  # False
```

### Pattern 5: Remove Element from Array

```python
def remove_element(arr, target, index=0):
    """
    Remove all occurrences of target from array
    Returns new array without target
    """
    # Base case
    if index >= len(arr):
        return []
    
    # Get result from rest of array
    rest_result = remove_element(arr, target, index + 1)
    
    # If current element is not target, include it
    if arr[index] != target:
        return [arr[index]] + rest_result
    
    return rest_result

# Test
arr = [3, 7, 1, 9, 7, 4, 7, 6]
result = remove_element(arr, 7)
print(result)  # [3, 1, 9, 4, 6]
```

---

## Advanced Array Problems

### Problem 1: Selection Sort Using Recursion

```python
def selection_sort(arr, start=0):
    """
    Selection sort: Find min element and swap with first
    Then recurse on remaining array
    
    Time: O(nÂ²), Space: O(n)
    """
    # Base case: array of size 0 or 1
    if start >= len(arr) - 1:
        return
    
    # Find index of minimum element in unsorted part
    min_index = start
    for i in range(start + 1, len(arr)):
        if arr[i] < arr[min_index]:
            min_index = i
    
    # Swap minimum with first element of unsorted part
    arr[start], arr[min_index] = arr[min_index], arr[start]
    
    # Recurse on remaining array
    selection_sort(arr, start + 1)

# Test
arr = [64, 25, 12, 22, 11]
selection_sort(arr)
print(arr)  # [11, 12, 22, 25, 64]
```

### Problem 2: Bubble Sort Using Recursion

```python
def bubble_sort(arr, n=None):
    """
    Bubble sort using recursion
    After each pass, largest element reaches its position
    
    Time: O(nÂ²), Space: O(n)
    """
    if n is None:
        n = len(arr)
    
    # Base case: array of size 0 or 1
    if n <= 1:
        return
    
    # One pass of bubble sort (largest element bubbles to end)
    for i in range(n - 1):
        if arr[i] > arr[i + 1]:
            arr[i], arr[i + 1] = arr[i + 1], arr[i]
    
    # Recurse for remaining array (excluding last element)
    bubble_sort(arr, n - 1)

# Test
arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print(arr)  # [11, 12, 22, 25, 34, 64, 90]
```

### Problem 3: Binary Search Using Recursion

```python
def binary_search(arr, target, left=0, right=None):
    """
    Binary search on sorted array
    
    Time: O(log n), Space: O(log n)
    """
    if right is None:
        right = len(arr) - 1
    
    # Base case: element not found
    if left > right:
        return -1
    
    # Calculate middle
    mid = (left + right) // 2
    
    # Base case: found
    if arr[mid] == target:
        return mid
    
    # Search left half
    if target < arr[mid]:
        return binary_search(arr, target, left, mid - 1)
    
    # Search right half
    return binary_search(arr, target, mid + 1, right)

# Test
arr = [1, 3, 5, 7, 9, 11, 13, 15]
print(binary_search(arr, 7))   # 3
print(binary_search(arr, 10))  # -1
```

**Recursion Tree for binary_search([1,3,5,7,9,11,13,15], 7):**
```
                    [1,3,5,7,9,11,13,15]
                     left=0, right=7, mid=3
                     arr[3]=7 == target
                     return 3
```

### Problem 4: Merge Two Sorted Arrays

```python
def merge_sorted_arrays(arr1, arr2, i=0, j=0):
    """
    Merge two sorted arrays into one sorted array
    
    Time: O(m + n), Space: O(m + n)
    """
    # Base cases
    if i >= len(arr1):
        return arr2[j:]
    if j >= len(arr2):
        return arr1[i:]
    
    # Compare and merge
    if arr1[i] <= arr2[j]:
        return [arr1[i]] + merge_sorted_arrays(arr1, arr2, i + 1, j)
    else:
        return [arr2[j]] + merge_sorted_arrays(arr1, arr2, i, j + 1)

# Test
arr1 = [1, 3, 5, 7]
arr2 = [2, 4, 6, 8]
result = merge_sorted_arrays(arr1, arr2)
print(result)  # [1, 2, 3, 4, 5, 6, 7, 8]
```

---

## Key Takeaways from Chapter 3

### 1. Array Traversal Patterns

âœ… **Single Pointer:** Move from start to end
- Check sorted, find element, sum, max/min
- Base case: index >= len(arr)

âœ… **Two Pointers:** Move from both ends
- Palindrome check, reverse, compare
- Base case: start >= end

### 2. Common Techniques

| Technique | When to Use | Space |
|-----------|-------------|-------|
| **Index Parameter** | Most common, efficient | O(1) auxiliary |
| **Array Slicing** | Cleaner but inefficient | O(n) per call |
| **Accumulator** | Collecting results | O(n) for result |
| **Two Pointers** | Symmetry problems | O(1) auxiliary |

### 3. Complexity Analysis

**Typical Complexities:**
- Linear traversal: O(n) time, O(n) space
- Binary search: O(log n) time, O(log n) space
- Nested recursion (sorting): O(nÂ²) time, O(n) space
- Two pointers: O(n) time, O(n) space

### 4. Best Practices

âœ… **Do:**
- Pass index instead of slicing arrays
- Use two pointers for symmetry
- Handle empty arrays
- Check boundaries before accessing

âŒ **Don't:**
- Create array copies unnecessarily
- Forget base cases
- Ignore boundary conditions
- Use global variables when avoidable

---

## Practice Problems

### Easy
1. Count even numbers in array
2. Find second largest element
3. Check if array contains duplicates
4. Remove duplicates from sorted array
5. Rotate array by K positions

### Medium
6. Find missing number in array (1 to n)
7. Move all zeros to end
8. Find pair with given sum
9. Kadane's algorithm (max subarray sum) - recursive
10. Dutch National Flag problem (sort 0s, 1s, 2s)

### Hard
11. Quick sort using recursion
12. Merge sort using recursion
13. Find kth smallest element
14. Count inversions in array
15. Trapping rain water (using recursion)

### Challenge
16. Convert all problems from iterative to recursive
17. Implement binary search for: first occurrence, last occurrence, count occurrences
18. Find peak element in array
19. Search in rotated sorted array
20. Maximum sum subarray of size k

---

## Common Patterns Summary

```python
# Pattern 1: Linear Traversal
def traverse(arr, index=0):
    if index >= len(arr):
        return
    process(arr[index])
    traverse(arr, index + 1)

# Pattern 2: Divide and Conquer
def divide_conquer(arr, left, right):
    if left > right:
        return
    mid = (left + right) // 2
    divide_conquer(arr, left, mid - 1)
    divide_conquer(arr, mid + 1, right)

# Pattern 3: Two Pointers
def two_pointer(arr, left=0, right=None):
    if right is None:
        right = len(arr) - 1
    if left >= right:
        return
    # Process from both ends
    two_pointer(arr, left + 1, right - 1)

# Pattern 4: Accumulator
def with_accumulator(arr, index=0, result=[]):
    if index >= len(arr):
        return result
    # Modify result
    return with_accumulator(arr, index + 1, result)
```

Master these patterns, and array recursion becomes second nature! ðŸš€
