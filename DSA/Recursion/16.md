# Chapter 16: Optimization Techniques

## 16.1 Tail Recursion Optimization

### Understanding Tail Recursion

**Tail Recursion:** A recursive call is in **tail position** if it's the last operation in the function (nothing happens after it returns).

**Why it matters:** Some compilers can optimize tail recursion to use O(1) space instead of O(n).

### Non-Tail vs Tail Recursive

**Non-Tail Recursive (NOT Optimizable):**
```python
def factorial_non_tail(n):
    """
    Non-tail recursive: multiplication happens AFTER recursive call
    Space: O(n)
    """
    if n <= 1:
        return 1
    
    # Operation AFTER recursive call
    return n * factorial_non_tail(n - 1)
    #      ↑ This multiplication means it's NOT tail recursive
```

**Call Stack:**
```
factorial_non_tail(4)
= 4 * factorial_non_tail(3)
= 4 * (3 * factorial_non_tail(2))
= 4 * (3 * (2 * factorial_non_tail(1)))
= 4 * (3 * (2 * 1))
= 4 * (3 * 2)
= 4 * 6
= 24

Stack grows to depth n!
```

**Tail Recursive (Optimizable):**
```python
def factorial_tail(n, accumulator=1):
    """
    Tail recursive: recursive call is LAST operation
    Can be optimized to O(1) space
    """
    if n <= 1:
        return accumulator
    
    # Recursive call is LAST (nothing after it)
    return factorial_tail(n - 1, accumulator * n)
    #      ↑ This is tail recursive!
```

**Call Stack (with TCO):**
```
factorial_tail(4, 1)
= factorial_tail(3, 4)   # Reuse same stack frame
= factorial_tail(2, 12)  # Reuse same stack frame
= factorial_tail(1, 24)  # Reuse same stack frame
= 24

Stack depth = 1 (constant)!
```

---

### Converting to Tail Recursion

**General Pattern:**
```python
# Non-tail (carries computation in stack)
def non_tail(n):
    if base_case:
        return base_value
    return operation(n, non_tail(n - 1))

# Tail (uses accumulator parameter)
def tail(n, accumulator=initial):
    if base_case:
        return accumulator
    return tail(n - 1, operation(accumulator, n))
```

### Example 1: Sum of Numbers

**Non-Tail:**
```python
def sum_non_tail(n):
    """Sum 1 to n (non-tail)"""
    if n == 0:
        return 0
    return n + sum_non_tail(n - 1)
```

**Tail:**
```python
def sum_tail(n, acc=0):
    """Sum 1 to n (tail recursive)"""
    if n == 0:
        return acc
    return sum_tail(n - 1, acc + n)

print(sum_tail(100))  # Efficient!
```

---

### Example 2: Fibonacci

**Non-Tail:**
```python
def fib_non_tail(n):
    """Fibonacci (non-tail)"""
    if n <= 1:
        return n
    return fib_non_tail(n - 1) + fib_non_tail(n - 2)
```

**Tail:**
```python
def fib_tail(n, a=0, b=1):
    """
    Fibonacci (tail recursive)
    a, b are previous two numbers
    """
    if n == 0:
        return a
    if n == 1:
        return b
    return fib_tail(n - 1, b, a + b)

print(fib_tail(100))  # Much faster!
```

---

### Example 3: List Reversal

**Non-Tail:**
```python
def reverse_non_tail(lst, index=0):
    """Reverse list (non-tail)"""
    if index >= len(lst):
        return []
    # Operation after recursive call
    return reverse_non_tail(lst, index + 1) + [lst[index]]
```

**Tail:**
```python
def reverse_tail(lst, index=0, acc=None):
    """Reverse list (tail recursive)"""
    if acc is None:
        acc = []
    
    if index >= len(lst):
        return acc
    
    # Build result in accumulator
    return reverse_tail(lst, index + 1, [lst[index]] + acc)

print(reverse_tail([1, 2, 3, 4, 5]))  # [5, 4, 3, 2, 1]
```

---

### Tail Call Optimization Support

**Python:** Does NOT optimize tail recursion (design decision)
```python
# Still uses O(n) stack in Python
def tail_recursive(n, acc=0):
    if n == 0:
        return acc
    return tail_recursive(n - 1, acc + n)

# Python treats this the same as non-tail recursive
```

**Languages with TCO:**
- Scheme, Racket
- Scala
- Kotlin
- JavaScript (ES6, but not all engines)

**Workaround for Python:**
```python
def tail_to_iterative(n):
    """Convert tail recursion to iteration"""
    acc = 0
    while n > 0:
        acc = acc + n
        n = n - 1
    return acc
```

---

## 16.2 Pruning Techniques

### What is Pruning?

**Pruning:** Cutting off branches of recursion tree that won't lead to valid solutions.

**Benefits:**
- Reduce unnecessary computation
- Can turn exponential → polynomial
- Essential for large search spaces

### Technique 1: Early Termination

```python
def subset_sum_with_pruning(nums, target, index=0, current_sum=0):
    """
    Subset sum with pruning
    
    Without pruning: O(2^n)
    With pruning: Much faster in practice
    """
    # BASE CASE: Found target
    if current_sum == target:
        return True
    
    # PRUNING: Exceeded target (for positive numbers)
    if current_sum > target:
        return False  # No point continuing this branch
    
    # BASE CASE: Exhausted array
    if index >= len(nums):
        return False
    
    # Try including current number
    if subset_sum_with_pruning(nums, target, index + 1, 
                               current_sum + nums[index]):
        return True
    
    # Try excluding current number
    return subset_sum_with_pruning(nums, target, index + 1, current_sum)

# Test
nums = [3, 34, 4, 12, 5, 2]
print(subset_sum_with_pruning(nums, 9))  # True (4 + 5)
```

**With vs Without Pruning:**
```
Without pruning (nums=[1,2,3,4], target=5):
Explores all 2^4 = 16 possibilities

With pruning:
[1,2,3,4] sum=0
├─ Include 1: sum=1
│  ├─ Include 2: sum=3
│  │  ├─ Include 3: sum=6 > 5 ✂️ PRUNE!
│  │  └─ Exclude 3: sum=3
│  │     ├─ Include 4: sum=7 > 5 ✂️ PRUNE!
│  │     └─ Exclude 4: sum=3 ✗
│  └─ Exclude 2: sum=1
│     ├─ Include 3: sum=4
│     │  ├─ Include 4: sum=8 > 5 ✂️ PRUNE!
│     │  └─ Exclude 4: sum=4 ✗
│     └─ Exclude 3: sum=1
│        ├─ Include 4: sum=5 ✓ FOUND!

Pruned 3 branches, found solution faster!
```

---

### Technique 2: Bounds Checking

```python
def n_queens_with_pruning(n):
    """
    N-Queens with aggressive pruning
    
    Check if position is valid BEFORE placing queen
    """
    result = []
    board = [['.'] * n for _ in range(n)]
    cols = set()
    diag1 = set()
    diag2 = set()
    
    def backtrack(row):
        if row == n:
            result.append([''.join(r) for r in board])
            return
        
        for col in range(n):
            # PRUNING: Check all constraints before recursing
            if (col in cols or 
                (row - col) in diag1 or 
                (row + col) in diag2):
                continue  # Skip invalid positions
            
            # Place queen
            board[row][col] = 'Q'
            cols.add(col)
            diag1.add(row - col)
            diag2.add(row + col)
            
            # Recurse
            backtrack(row + 1)
            
            # Backtrack
            board[row][col] = '.'
            cols.remove(col)
            diag1.remove(row - col)
            diag2.remove(row + col)
    
    backtrack(0)
    return result

# Test
solutions = n_queens_with_pruning(4)
print(f"Solutions for 4-Queens: {len(solutions)}")
```

---

### Technique 3: Constraint Propagation

```python
def sudoku_with_pruning(board):
    """
    Sudoku with smart pruning
    Only try numbers that could be valid
    """
    def is_valid(row, col, num):
        """Check if num can be placed at (row, col)"""
        # Check row
        if num in board[row]:
            return False
        
        # Check column
        if num in [board[i][col] for i in range(9)]:
            return False
        
        # Check 3x3 box
        box_row, box_col = 3 * (row // 3), 3 * (col // 3)
        for i in range(box_row, box_row + 3):
            for j in range(box_col, box_col + 3):
                if board[i][j] == num:
                    return False
        
        return True
    
    def get_candidates(row, col):
        """PRUNING: Get only valid candidates"""
        candidates = []
        for num in '123456789':
            if is_valid(row, col, num):
                candidates.append(num)
        return candidates
    
    def solve():
        # Find empty cell
        for row in range(9):
            for col in range(9):
                if board[row][col] == '.':
                    # PRUNING: Only try valid numbers
                    for num in get_candidates(row, col):
                        board[row][col] = num
                        if solve():
                            return True
                        board[row][col] = '.'
                    return False
        return True
    
    solve()
    return board
```

---

### Technique 4: Ordering (Best-First Search)

```python
def subset_sum_ordered(nums, target):
    """
    Try larger numbers first for faster pruning
    """
    nums.sort(reverse=True)  # Sort descending
    
    def helper(index, current_sum):
        if current_sum == target:
            return True
        
        # PRUNING: If current exceeds target, all remaining will too
        if current_sum > target:
            return False
        
        if index >= len(nums):
            return False
        
        # Try including (larger numbers first)
        if helper(index + 1, current_sum + nums[index]):
            return True
        
        return helper(index + 1, current_sum)
    
    return helper(0, 0)

# Larger numbers tried first → faster pruning
```

---

## 16.3 Space Optimization

### Technique 1: Iterative Conversion

**When to convert:**
- Deep recursion causing stack overflow
- Space is critical
- Tail recursion not supported

**Example: Tree Level Order (Iterative)**
```python
def level_order_iterative(root):
    """
    Level order traversal iteratively
    Space: O(width) instead of O(height)
    """
    if not root:
        return []
    
    result = []
    queue = [root]
    
    while queue:
        level_size = len(queue)
        level = []
        
        for _ in range(level_size):
            node = queue.pop(0)
            level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(level)
    
    return result
```

---

### Technique 2: State Compression

**Reduce the amount of state tracked**

**Before (Large State):**
```python
def game_with_large_state(board, player, move_history, scores):
    """Tracks too much state"""
    state = (tuple(map(tuple, board)), player, 
             tuple(move_history), tuple(scores))
    # State is huge!
```

**After (Compressed):**
```python
def game_compressed(board_hash, player):
    """Only track essential state"""
    # Use hash of board instead of full board
    # Only track current player
    state = (board_hash, player)
    # Much smaller state space!
```

---

### Technique 3: In-Place Modification

**Modify input instead of creating copies**

**Space-Inefficient:**
```python
def permute_with_copies(nums, path=None, result=None):
    """Creates many list copies"""
    if path is None:
        path = []
    if result is None:
        result = []
    
    if len(path) == len(nums):
        result.append(path[:])  # Copy
        return result
    
    for num in nums:
        if num not in path:
            # Creates new list each time
            permute_with_copies(nums, path + [num], result)
    
    return result
```

**Space-Efficient:**
```python
def permute_inplace(nums, start=0, result=None):
    """Uses swapping instead of copying"""
    if result is None:
        result = []
    
    if start == len(nums):
        result.append(nums[:])  # Only copy at leaves
        return result
    
    for i in range(start, len(nums)):
        # Swap in-place
        nums[start], nums[i] = nums[i], nums[start]
        permute_inplace(nums, start + 1, result)
        # Swap back
        nums[start], nums[i] = nums[i], nums[start]
    
    return result
```

---

### Technique 4: Rolling Window

**For problems needing only recent values**

```python
def fibonacci_rolling(n):
    """
    Fibonacci with O(1) space
    Only keep last 2 values
    """
    if n <= 1:
        return n
    
    # Only store previous 2 values
    prev2, prev1 = 0, 1
    
    for _ in range(2, n + 1):
        current = prev1 + prev2
        prev2, prev1 = prev1, current
    
    return prev1

# O(1) space instead of O(n)!
```

---

## 16.4 Practical Optimization Examples

### Example 1: Optimized Subset Sum

```python
def subset_sum_optimized(nums, target):
    """
    All optimizations combined:
    1. Sort for better pruning
    2. Early termination
    3. Memoization
    """
    nums.sort(reverse=True)
    memo = {}
    
    def helper(index, remaining):
        # Check memo
        if (index, remaining) in memo:
            return memo[(index, remaining)]
        
        # BASE CASES
        if remaining == 0:
            return True
        if remaining < 0 or index >= len(nums):
            return False
        
        # PRUNING: If current number > remaining, skip it
        if nums[index] > remaining:
            result = helper(index + 1, remaining)
        else:
            # Try including or excluding
            result = (helper(index + 1, remaining - nums[index]) or
                     helper(index + 1, remaining))
        
        memo[(index, remaining)] = result
        return result
    
    return helper(0, target)
```

---

### Example 2: Optimized Palindrome Partitioning

```python
def palindrome_partition_optimized(s):
    """
    With memoization and palindrome caching
    """
    n = len(s)
    
    # Pre-compute palindrome checks
    is_palindrome = [[False] * n for _ in range(n)]
    for i in range(n):
        is_palindrome[i][i] = True
    
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j]:
                if length == 2:
                    is_palindrome[i][j] = True
                else:
                    is_palindrome[i][j] = is_palindrome[i + 1][j - 1]
    
    # Main recursion with memoization
    memo = {}
    
    def helper(start, path):
        if start == n:
            return [path[:]]
        
        if start in memo:
            return memo[start]
        
        result = []
        for end in range(start, n):
            if is_palindrome[start][end]:
                path.append(s[start:end + 1])
                result.extend(helper(end + 1, path))
                path.pop()
        
        memo[start] = result
        return result
    
    return helper(0, [])
```

---

## Key Takeaways from Chapter 16

### 1. Optimization Decision Tree

```
Is recursion too slow/deep?
├─ YES: Deep recursion?
│   ├─ Convert to tail recursive
│   ├─ Convert to iterative
│   └─ Use explicit stack
└─ YES: Too many calls?
    ├─ Add memoization
    ├─ Add pruning
    └─ Compress state
```

### 2. Tail Recursion Checklist

✅ Recursive call is last operation  
✅ No computation after return  
✅ Use accumulator parameter  
✅ Move operations before recursive call  

### 3. Pruning Checklist

✅ Early termination conditions  
✅ Constraint checking before recursion  
✅ Ordering for better pruning  
✅ Skip impossible branches  

### 4. Space Optimization Checklist

✅ Can use tail recursion?  
✅ Can convert to iterative?  
✅ Can modify in-place?  
✅ Can compress state?  
✅ Can use rolling window?  

---

## Practice Problems

### Easy
1. Convert factorial to tail recursive
2. Convert sum to tail recursive
3. Add pruning to subset sum
4. Optimize fibonacci

### Medium
5. Convert binary tree traversal to iterative
6. Optimize N-Queens with pruning
7. Optimize palindrome problems
8. Add memoization to game problems

### Hard
9. Optimize Sudoku solver
10. Optimize word break
11. Optimize expression evaluation
12. Optimize partition problems

### Challenge
13. Convert complex recursion to iterative
14. Optimize with all techniques combined
15. Benchmark optimizations
16. Design custom optimization for problem

---

## Optimization Impact

**Example: Fibonacci(40)**
```
Naive recursion:    ~2 seconds, 2^40 calls
With memoization:   <0.001s, 40 calls
Tail recursive:     <0.001s, O(1) space
Iterative:          <0.0001s, best

Speedup: ~20,000x faster!
```

**Example: N-Queens(8)**
```
Without pruning:    Check ~8^8 = 16M positions
With pruning:       Check ~2,000 positions

Speedup: ~8,000x faster!
```

Master these optimization techniques and turn exponential algorithms into practical solutions! ⚡
