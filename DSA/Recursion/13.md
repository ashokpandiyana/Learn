# Chapter 13: Memoization (Recursion Optimization)

## 13.1 Introduction to Memoization

### What is Memoization?

**Memoization** is an optimization technique that stores the results of expensive function calls and returns the cached result when the same inputs occur again.

**Think of it as:**
- A lookup table for function results
- Trading space for time
- Avoiding redundant calculations

### Why Do We Need Memoization?

**Problem: Overlapping Subproblems**

Many recursive solutions recalculate the same values multiple times.

**Classic Example: Fibonacci**
```python
def fibonacci(n):
    """Without memoization - VERY SLOW!"""
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

# For fibonacci(5), makes 15 function calls
# For fibonacci(40), makes 331,160,281 calls!
```

**Call Tree for fibonacci(5):**
```
                        fib(5)
                    /            \
                fib(4)            fib(3)
              /      \           /      \
          fib(3)   fib(2)    fib(2)   fib(1)
         /    \    /    \    /    \
     fib(2) fib(1) fib(1) fib(0) fib(1) fib(0)
     /   \
 fib(1) fib(0)

Notice: fib(3) calculated 2 times
        fib(2) calculated 3 times
        fib(1) calculated 5 times
        Total: 15 calls for just fib(5)!
```

**Time Complexity Analysis:**
```
Without memoization: O(2^n) - exponential!
Space: O(n) - recursion depth

With memoization: O(n) - linear!
Space: O(n) - memo storage + recursion
```

---

### Basic Memoization Pattern

```python
def function_with_memo(n, memo=None):
    """
    Basic memoization template
    """
    # Initialize memo
    if memo is None:
        memo = {}
    
    # Check if result already calculated
    if n in memo:
        return memo[n]
    
    # Base case(s)
    if base_condition:
        return base_value
    
    # Calculate result
    result = recursive_calls(...)
    
    # Store in memo before returning
    memo[n] = result
    return result
```

### Fibonacci with Memoization

```python
def fibonacci_memo(n, memo=None):
    """
    Fibonacci with memoization
    
    Time: O(n), Space: O(n)
    """
    if memo is None:
        memo = {}
    
    # Check memo
    if n in memo:
        return memo[n]
    
    # Base cases
    if n <= 1:
        return n
    
    # Calculate and store
    memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo)
    return memo[n]

# Test
print(fibonacci_memo(50))  # Instant! (12586269025)
print(fibonacci_memo(100))  # Still fast!
```

**With Memoization - Call Tree:**
```
                        fib(5)
                    /            \
                fib(4)            fib(3) â† CACHED!
              /      \           
          fib(3)   fib(2) â† CACHED!
         /    \    
     fib(2) fib(1) â† CACHED!
     /   \
 fib(1) fib(0)

Only 9 calls instead of 15!
Each unique value calculated exactly once.
```

---

## 13.2 Memoization Techniques

### Technique 1: Dictionary/Hash Map

**Most flexible approach - works with any hashable key**

```python
def example_dict_memo(n, memo=None):
    """Using dictionary for memoization"""
    if memo is None:
        memo = {}
    
    if n in memo:
        return memo[n]
    
    # Calculate result
    result = calculate(n)
    memo[n] = result
    return result
```

**When to use:**
- Single parameter problems
- Negative numbers
- Non-contiguous values
- String/tuple keys

---

### Technique 2: List/Array

**Faster for integer indices**

```python
def example_array_memo(n):
    """Using list for memoization"""
    # Initialize memo array
    memo = [-1] * (n + 1)  # -1 means not calculated
    
    def helper(i):
        # Check if calculated
        if memo[i] != -1:
            return memo[i]
        
        # Base case
        if i <= 1:
            return i
        
        # Calculate and store
        memo[i] = helper(i - 1) + helper(i - 2)
        return memo[i]
    
    return helper(n)
```

**When to use:**
- Integer indices
- Known maximum size
- Slightly faster than dict

---

### Technique 3: 2D Memoization

**For problems with two parameters**

```python
def example_2d_memo(m, n):
    """
    2D memoization - two parameters
    """
    # Using dictionary with tuple key
    memo = {}
    
    def helper(i, j):
        if (i, j) in memo:
            return memo[(i, j)]
        
        # Base cases
        if i == 0 or j == 0:
            return 1
        
        # Calculate
        result = helper(i - 1, j) + helper(i, j - 1)
        memo[(i, j)] = result
        return result
    
    return helper(m, n)

# Alternative: 2D list
def example_2d_memo_array(m, n):
    """Using 2D array"""
    memo = [[-1] * (n + 1) for _ in range(m + 1)]
    
    def helper(i, j):
        if memo[i][j] != -1:
            return memo[i][j]
        
        if i == 0 or j == 0:
            return 1
        
        memo[i][j] = helper(i - 1, j) + helper(i, j - 1)
        return memo[i][j]
    
    return helper(m, n)
```

---

### Technique 4: Using Decorators (Python)

**Automatic memoization with @lru_cache**

```python
from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci_auto(n):
    """
    Automatic memoization using decorator
    
    Time: O(n), Space: O(n)
    """
    if n <= 1:
        return n
    return fibonacci_auto(n - 1) + fibonacci_auto(n - 2)

# Test
print(fibonacci_auto(100))  # Fast and clean!
```

**When to use:**
- Quick prototyping
- Clean code
- Simple parameter types
- Python-specific

---

## 13.3 Classic Memoization Problems

### Problem 1: Climbing Stairs

**Problem:** Count ways to climb n stairs (1 or 2 steps at a time).

```python
def climb_stairs(n, memo=None):
    """
    Climbing stairs with memoization
    
    Time: O(n), Space: O(n)
    """
    if memo is None:
        memo = {}
    
    if n in memo:
        return memo[n]
    
    # Base cases
    if n <= 2:
        return n
    
    # ways(n) = ways(n-1) + ways(n-2)
    memo[n] = climb_stairs(n - 1, memo) + climb_stairs(n - 2, memo)
    return memo[n]

# Test
print(climb_stairs(10))  # 89
print(climb_stairs(40))  # 165580141 (instant!)
```

**Without Memoization:**
```
climb_stairs(5):
- O(2^5) = 32 recursive calls

climb_stairs(40):
- O(2^40) = 1,099,511,627,776 calls
- Takes hours/days!
```

**With Memoization:**
```
climb_stairs(40):
- O(40) = 40 calls
- Instant!
```

---

### Problem 2: Minimum Coins (Coin Change)

**Problem:** Minimum coins needed to make amount using given denominations.

```python
def coin_change(coins, amount, memo=None):
    """
    Minimum coins to make amount
    
    Time: O(amount Ã— len(coins)), Space: O(amount)
    """
    if memo is None:
        memo = {}
    
    if amount in memo:
        return memo[amount]
    
    # Base cases
    if amount == 0:
        return 0
    if amount < 0:
        return float('inf')
    
    # Try each coin
    min_coins = float('inf')
    for coin in coins:
        result = coin_change(coins, amount - coin, memo)
        if result != float('inf'):
            min_coins = min(min_coins, result + 1)
    
    memo[amount] = min_coins
    return min_coins

# Test
coins = [1, 2, 5]
amount = 11
result = coin_change(coins, amount)
print(f"Minimum coins: {result}")  # 3 (5 + 5 + 1)
```

**Recursion Tree (Partial):**
```
Without memo:
                    change(11)
        /               |              \
    change(10)      change(9)      change(6)
    /  |  \         /  |  \        /  |  \
  ...  ... ...    ... ... ...   ... ... ...

With memo:
Each amount calculated only once!
change(11) â†’ change(10), change(9), change(6)
change(10) â†’ change(9), change(8), change(5)
...
No duplicate calculations!
```

---

### Problem 3: Longest Increasing Subsequence (LIS)

**Problem:** Length of longest strictly increasing subsequence.

```python
def longest_increasing_subsequence(nums):
    """
    LIS using memoization
    
    Time: O(nÂ²), Space: O(n)
    """
    if not nums:
        return 0
    
    memo = {}
    
    def lis_from(index, prev):
        """
        LIS starting from index with previous value
        """
        if (index, prev) in memo:
            return memo[(index, prev)]
        
        # Base case: reached end
        if index >= len(nums):
            return 0
        
        # Option 1: Skip current element
        skip = lis_from(index + 1, prev)
        
        # Option 2: Take current (if possible)
        take = 0
        if prev is None or nums[index] > prev:
            take = 1 + lis_from(index + 1, nums[index])
        
        result = max(skip, take)
        memo[(index, prev)] = result
        return result
    
    return lis_from(0, None)

# Test
nums = [10, 9, 2, 5, 3, 7, 101, 18]
print(f"LIS length: {longest_increasing_subsequence(nums)}")  # 4
```

---

### Problem 4: Matrix Chain Multiplication

**Problem:** Find minimum cost to multiply chain of matrices.

```python
def matrix_chain_multiplication(dims):
    """
    Minimum cost to multiply matrices
    
    dims[i-1] Ã— dims[i] = size of matrix i
    
    Time: O(nÂ³), Space: O(nÂ²)
    """
    n = len(dims) - 1  # Number of matrices
    memo = {}
    
    def mcm(i, j):
        """
        Minimum cost to multiply matrices from i to j
        """
        if (i, j) in memo:
            return memo[(i, j)]
        
        # Base case: single matrix
        if i == j:
            return 0
        
        min_cost = float('inf')
        
        # Try all possible split points
        for k in range(i, j):
            # Cost = left + right + merge
            cost = (mcm(i, k) +
                   mcm(k + 1, j) +
                   dims[i - 1] * dims[k] * dims[j])
            min_cost = min(min_cost, cost)
        
        memo[(i, j)] = min_cost
        return min_cost
    
    return mcm(1, n)

# Test
# Matrices: 10Ã—30, 30Ã—5, 5Ã—60
dims = [10, 30, 5, 60]
cost = matrix_chain_multiplication(dims)
print(f"Minimum cost: {cost}")  # 4500
```

**Explanation:**
```
Matrices: A(10Ã—30), B(30Ã—5), C(5Ã—60)

Option 1: (AB)C
Cost = 10Ã—30Ã—5 + 10Ã—5Ã—60 = 1500 + 3000 = 4500

Option 2: A(BC)
Cost = 30Ã—5Ã—60 + 10Ã—30Ã—60 = 9000 + 18000 = 27000

Minimum: 4500
```

---

### Problem 5: Word Break

**Problem:** Check if string can be segmented into dictionary words.

```python
def word_break(s, word_dict):
    """
    Word break with memoization
    
    Time: O(nÂ² Ã— k) where k = avg word length
    Space: O(n)
    """
    word_set = set(word_dict)
    memo = {}
    
    def can_break(start):
        if start in memo:
            return memo[start]
        
        # Base case: reached end
        if start >= len(s):
            return True
        
        # Try all possible words
        for end in range(start + 1, len(s) + 1):
            word = s[start:end]
            if word in word_set and can_break(end):
                memo[start] = True
                return True
        
        memo[start] = False
        return False
    
    return can_break(0)

# Test
s = "leetcode"
word_dict = ["leet", "code"]
print(word_break(s, word_dict))  # True

s = "applepenapple"
word_dict = ["apple", "pen"]
print(word_break(s, word_dict))  # True
```

**Call Tree:**
```
s = "leetcode", dict = ["leet", "code"]

can_break(0):
  Try "l": not in dict
  Try "le": not in dict
  Try "lee": not in dict
  Try "leet": in dict! âœ“
    can_break(4):
      Try "c": not in dict
      Try "co": not in dict
      Try "cod": not in dict
      Try "code": in dict! âœ“
        can_break(8):
          return True (end reached)
        return True
      return True
    return True
  return True
```

---

## 13.4 Advanced Memoization Patterns

### Pattern 1: String-Based Keys

**For problems with string state**

```python
def string_key_memo(s1, s2):
    """Using string tuples as keys"""
    memo = {}
    
    def helper(i, j):
        key = (s1[i:], s2[j:])  # String tuple key
        
        if key in memo:
            return memo[key]
        
        # Calculate result
        result = calculate(i, j)
        memo[key] = result
        return result
    
    return helper(0, 0)
```

---

### Pattern 2: Multi-Dimensional Memoization

**For 3+ parameters**

```python
def multidim_memo(a, b, c):
    """3D memoization"""
    memo = {}
    
    def helper(i, j, k):
        if (i, j, k) in memo:
            return memo[(i, j, k)]
        
        # Base cases
        if i == 0 or j == 0 or k == 0:
            return 0
        
        # Calculate
        result = helper(i-1, j, k) + helper(i, j-1, k) + helper(i, j, k-1)
        memo[(i, j, k)] = result
        return result
    
    return helper(a, b, c)
```

---

### Pattern 3: State Compression

**Reduce space by identifying essential state**

```python
def space_optimized_memo(n):
    """
    Sometimes only need last few values
    
    Example: Fibonacci only needs last 2 values
    """
    if n <= 1:
        return n
    
    # Only store last 2 values
    prev2, prev1 = 0, 1
    
    for i in range(2, n + 1):
        curr = prev1 + prev2
        prev2, prev1 = prev1, curr
    
    return prev1

# This is O(1) space instead of O(n)!
```

---

### Pattern 4: Memoization with Backtracking

**Combine memoization with backtracking**

```python
def memo_with_backtracking(grid, path=None, memo=None):
    """
    Memoization + backtracking for path problems
    """
    if path is None:
        path = []
    if memo is None:
        memo = {}
    
    # Create hashable key from path state
    key = tuple(path)
    
    if key in memo:
        return memo[key]
    
    # Backtracking logic
    result = []
    for choice in get_choices():
        path.append(choice)  # Choose
        result.extend(memo_with_backtracking(grid, path, memo))
        path.pop()  # Unchoose
    
    memo[key] = result
    return result
```

---

## 13.5 Converting Recursion to DP

### Top-Down (Memoization) vs Bottom-Up (DP)

**Top-Down (Memoization):**
```python
def fibonacci_topdown(n, memo=None):
    """
    Top-Down: Start from problem, recurse down
    Natural recursive thinking
    """
    if memo is None:
        memo = {}
    
    if n in memo:
        return memo[n]
    
    if n <= 1:
        return n
    
    memo[n] = fibonacci_topdown(n-1, memo) + fibonacci_topdown(n-2, memo)
    return memo[n]
```

**Bottom-Up (DP):**
```python
def fibonacci_bottomup(n):
    """
    Bottom-Up: Start from base cases, build up
    Iterative, often more space-efficient
    """
    if n <= 1:
        return n
    
    dp = [0] * (n + 1)
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]
```

**Comparison:**
```
Top-Down (Memoization):
âœ… More intuitive (matches recursive thinking)
âœ… Only computes needed subproblems
âœ… Better for sparse problems
âŒ Recursion overhead
âŒ Stack space for recursion

Bottom-Up (DP):
âœ… No recursion overhead
âœ… Often more space-efficient
âœ… Predictable performance
âŒ May compute unneeded subproblems
âŒ Less intuitive
```

---

## Key Takeaways from Chapter 13

### 1. When to Use Memoization

âœ… **Use memoization when:**
- Overlapping subproblems exist
- Same inputs computed multiple times
- Recursive solution exists
- Can identify state uniquely

âŒ **Don't use when:**
- No overlapping subproblems
- State space too large
- Can't create hashable keys
- Iterative solution is simpler

### 2. Memoization Checklist

```
1. âœ“ Identify overlapping subproblems
2. âœ“ Define state (parameters that change)
3. âœ“ Choose memo structure (dict/list/2D)
4. âœ“ Check memo before computing
5. âœ“ Store result before returning
6. âœ“ Pass memo through recursive calls
```

### 3. Space-Time Tradeoff

```
Without Memoization:
- Time: Often exponential
- Space: O(depth) recursion only

With Memoization:
- Time: Polynomial (usually)
- Space: O(states) + O(depth)

Example: Fibonacci
Without: O(2^n) time, O(n) space
With: O(n) time, O(n) space
```

### 4. Common Mistakes

âŒ **Forgetting to pass memo**
```python
# Wrong
def fib(n, memo={}):
    # memo shared across calls!
    
# Right
def fib(n, memo=None):
    if memo is None:
        memo = {}
```

âŒ **Mutable default arguments**
```python
# Wrong
def solve(n, path=[]):
    # path shared across calls!

# Right
def solve(n, path=None):
    if path is None:
        path = []
```

âŒ **Not checking memo**
```python
# Wrong
def solve(n, memo={}):
    # Calculate without checking
    result = expensive_calc()
    memo[n] = result

# Right
def solve(n, memo={}):
    if n in memo:
        return memo[n]
    result = expensive_calc()
    memo[n] = result
```

---

## Practice Problems

### Easy
1. Fibonacci (with memo)
2. Climbing stairs
3. Min cost climbing stairs
4. House robber
5. Decode ways

### Medium
6. Coin change
7. Longest increasing subsequence
8. Unique paths with obstacles
9. Word break
10. Target sum

### Hard
11. Edit distance
12. Longest common subsequence
13. Matrix chain multiplication
14. Scramble string
15. Burst balloons

### Challenge
16. Regular expression matching
17. Wildcard matching
18. Distinct subsequences
19. Minimum cost to merge stones
20. Stone game (all variations)

---

## Debugging Memoization

### Add Logging

```python
def fibonacci_debug(n, memo=None, depth=0):
    """Fibonacci with debug logging"""
    if memo is None:
        memo = {}
    
    indent = "  " * depth
    print(f"{indent}Computing fib({n})")
    
    if n in memo:
        print(f"{indent}â†’ Cached: {memo[n]}")
        return memo[n]
    
    if n <= 1:
        print(f"{indent}â†’ Base case: {n}")
        return n
    
    result = (fibonacci_debug(n-1, memo, depth+1) +
             fibonacci_debug(n-2, memo, depth+1))
    
    memo[n] = result
    print(f"{indent}â†’ Computed: {result}")
    return result

# Test
fibonacci_debug(5)
```

**Output:**
```
Computing fib(5)
  Computing fib(4)
    Computing fib(3)
      Computing fib(2)
        Computing fib(1)
        â†’ Base case: 1
        Computing fib(0)
        â†’ Base case: 0
      â†’ Computed: 1
      Computing fib(1)
      â†’ Base case: 1
    â†’ Computed: 2
    Computing fib(2)
    â†’ Cached: 1
  â†’ Computed: 3
  Computing fib(3)
  â†’ Cached: 2
â†’ Computed: 5
```

Master memoization and you'll optimize your recursive solutions to compete with the best iterative approaches! ðŸš€
