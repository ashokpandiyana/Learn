# Chapter 5: Subset and Subsequence Pattern

## 5.1 Print All Subsequences

### Understanding the Pick/Not-Pick Pattern

The **Pick/Not-Pick** pattern is one of the most fundamental recursive patterns. At each element, we have **two choices**:
1. **Pick:** Include the element in current subsequence
2. **Not Pick:** Exclude the element from current subsequence

This creates a **binary decision tree** with 2^n total outcomes.

### Basic Implementation

```python
def print_subsequences(arr, index=0, current=[]):
    """
    Print all subsequences of array using Pick/Not-Pick pattern
    
    Time: O(2^n Ã— n) - 2^n subsequences, O(n) to print each
    Space: O(n) - recursion depth
    """
    # Base case: processed all elements
    if index >= len(arr):
        print(current)
        return
    
    # Not Pick: exclude current element
    print_subsequences(arr, index + 1, current)
    
    # Pick: include current element
    print_subsequences(arr, index + 1, current + [arr[index]])

# Test
print("All subsequences of [1, 2, 3]:")
print_subsequences([1, 2, 3])
```

**Output:**
```
All subsequences of [1, 2, 3]:
[]
[3]
[2]
[2, 3]
[1]
[1, 3]
[1, 2]
[1, 2, 3]
```

### Recursion Tree Visualization

```
For array [1, 2, 3]:

                        ([], 0)
                    /              \
              ([], 1)              ([1], 1)
             /        \           /         \
        ([], 2)    ([2], 2)   ([1], 2)   ([1,2], 2)
        /    \      /    \      /    \      /     \
      []    [3]   [2]  [2,3]  [1]  [1,3] [1,2] [1,2,3]

Each level represents a decision for one element:
Level 0: Decide for element 1
Level 1: Decide for element 2
Level 2: Decide for element 3
```

### Complete Binary Tree Properties

```
Height of tree = n (number of elements)
Nodes at level i = 2^i
Total nodes = 2^0 + 2^1 + 2^2 + ... + 2^n = 2^(n+1) - 1
Leaf nodes (subsequences) = 2^n
```

---

### Alternative: Return as List

```python
def get_subsequences(arr, index=0):
    """
    Return all subsequences as list of lists
    """
    # Base case
    if index >= len(arr):
        return [[]]  # Return list containing empty subsequence
    
    # Get subsequences of rest of array
    rest_subsequences = get_subsequences(arr, index + 1)
    
    # For each subsequence, create two versions:
    # 1. Without current element
    # 2. With current element
    new_subsequences = []
    for subsequence in rest_subsequences:
        # Add subsequence without current element
        new_subsequences.append(subsequence)
        # Add subsequence with current element
        new_subsequences.append([arr[index]] + subsequence)
    
    return new_subsequences

# Test
result = get_subsequences([1, 2, 3])
print(f"Total subsequences: {len(result)}")
for sub in sorted(result, key=len):
    print(sub)
```

**Output:**
```
Total subsequences: 8
[]
[1]
[2]
[3]
[1, 2]
[1, 3]
[2, 3]
[1, 2, 3]
```

---

### String Subsequences

```python
def string_subsequences(s, index=0, current=""):
    """Generate all subsequences of string"""
    # Base case
    if index >= len(s):
        print(f"'{current}'")
        return
    
    # Not pick
    string_subsequences(s, index + 1, current)
    
    # Pick
    string_subsequences(s, index + 1, current + s[index])

# Test
print("Subsequences of 'abc':")
string_subsequences("abc")
```

**Output:**
```
Subsequences of 'abc':
''
'c'
'b'
'bc'
'a'
'ac'
'ab'
'abc'
```

---

### Important Notes

âš ï¸ **Key Insights:**

1. **Total Subsequences = 2^n** (including empty subsequence)
2. **Exponential Time Complexity:** Cannot be optimized much
3. **Order Matters:** We explore in specific order (not pick first)
4. **Maintains Original Order:** Elements in subsequence maintain their relative order from original array

**Difference: Subsequence vs Subset**
- **Subsequence:** Order matters. [1, 3] from [1, 2, 3] is valid
- **Subset:** Order doesn't matter. {1, 3} = {3, 1}
- For our purposes, they're treated the same in problems

---

## 5.2 Subsequence with Conditions

### Pattern 1: Subsequences with Sum K

**Problem:** Print all subsequences whose sum equals K.

```python
def subsequences_with_sum(arr, target, index=0, current=[], current_sum=0):
    """
    Print all subsequences with sum equal to target
    
    Time: O(2^n), Space: O(n)
    """
    # Base case
    if index >= len(arr):
        # Check if current sum equals target
        if current_sum == target:
            print(current)
        return
    
    # Not pick current element
    subsequences_with_sum(arr, target, index + 1, current, current_sum)
    
    # Pick current element
    subsequences_with_sum(arr, target, index + 1, 
                         current + [arr[index]], 
                         current_sum + arr[index])

# Test
print("Subsequences with sum = 5:")
subsequences_with_sum([1, 2, 3, 4], 5)
```

**Output:**
```
Subsequences with sum = 5:
[2, 3]
[1, 4]
[5] (if 5 was in array)
```

**Recursion Tree (Pruned):**
```
For [1, 2, 3], target = 5:

                    ([], sum=0, idx=0)
                  /                    \
          ([], sum=0, 1)           ([1], sum=1, 1)
          /            \            /              \
    ([], 0, 2)    ([2], 2, 2)  ([1], 1, 2)    ([1,2], 3, 2)
                       |             |              |
                  ([2,3], 5) âœ“  ([1,3], 4)   ([1,2,3], 6)
```

---

### Pattern 2: Print Only ONE Subsequence

**Problem:** Print any one subsequence with sum K, then stop.

```python
def print_one_subsequence(arr, target, index=0, current=[], current_sum=0):
    """
    Print only first subsequence with sum K
    Return True if found, False otherwise
    
    Time: Best O(n), Worst O(2^n)
    """
    # Base case
    if index >= len(arr):
        if current_sum == target:
            print(current)
            return True  # Found one, stop searching
        return False
    
    # Pick current element
    if print_one_subsequence(arr, target, index + 1, 
                            current + [arr[index]], 
                            current_sum + arr[index]):
        return True  # Already found, propagate True
    
    # Not pick current element (try only if pick didn't work)
    if print_one_subsequence(arr, target, index + 1, current, current_sum):
        return True
    
    return False  # Neither path found solution

# Test
print("First subsequence with sum = 5:")
print_one_subsequence([1, 2, 3, 4], 5)
```

**Key Technique:** Return `True` to stop further exploration once one solution is found.

---

### Pattern 3: Count Subsequences with Sum K

**Problem:** Count total number of subsequences with sum K.

```python
def count_subsequences_with_sum(arr, target, index=0, current_sum=0):
    """
    Count all subsequences with sum equal to target
    
    Time: O(2^n), Space: O(n)
    """
    # Base case
    if index >= len(arr):
        # Return 1 if target reached, 0 otherwise
        return 1 if current_sum == target else 0
    
    # Not pick: count from rest
    not_pick = count_subsequences_with_sum(arr, target, index + 1, current_sum)
    
    # Pick: count from rest (with current element added)
    pick = count_subsequences_with_sum(arr, target, index + 1, 
                                       current_sum + arr[index])
    
    # Total count is sum of both paths
    return not_pick + pick

# Test
arr = [1, 2, 3, 4]
target = 5
count = count_subsequences_with_sum(arr, target)
print(f"Count of subsequences with sum {target}: {count}")
```

**Recursion Tree with Counts:**
```
For [1, 2, 1], target = 2:

                    (sum=0, idx=0) [returns 2]
                  /                              \
        (sum=0, idx=1) [returns 1]         (sum=1, idx=1) [returns 1]
        /                    \              /                    \
  (sum=0, 2) [0]      (sum=2, 2) [1]  (sum=1, 2) [0]      (sum=3, 2) [0]
      /      \           /      \         /      \           /      \
  [0]  [0]     [1]âœ“    [0]     [0]      [0]     [1]âœ“      [0]     [0]

Total: 2 subsequences with sum=2: [2] and [1, 1]
```

---

### Pattern 4: Subsequences in Sorted Order

```python
def sorted_subsequences_with_sum(arr, target, index=0, current=[]):
    """
    Generate subsequences with sum K in sorted order
    Sort array first for sorted output
    """
    # Base case
    if index >= len(arr):
        if sum(current) == target:
            print(current)
        return
    
    # Pick (this comes first for sorted output)
    sorted_subsequences_with_sum(arr, target, index + 1, 
                                current + [arr[index]])
    
    # Not pick
    sorted_subsequences_with_sum(arr, target, index + 1, current)

# Test
arr = [1, 2, 3, 4, 5]
arr.sort()  # Ensure sorted
print("Subsequences with sum = 5 (sorted):")
sorted_subsequences_with_sum(arr, 5)
```

---

### Optimization: Early Pruning

We can optimize by adding pruning conditions to avoid unnecessary recursive calls.

```python
def optimized_subsequences_with_sum(arr, target, index=0, current=[], current_sum=0):
    """
    Optimized version with pruning
    Skip branches that can't possibly reach target
    """
    # Base case
    if index >= len(arr):
        if current_sum == target:
            print(current)
        return
    
    # Pruning: if current sum already exceeds target (for positive numbers)
    if current_sum > target:
        return
    
    # Pick current element
    optimized_subsequences_with_sum(arr, target, index + 1, 
                                   current + [arr[index]], 
                                   current_sum + arr[index])
    
    # Not pick current element
    optimized_subsequences_with_sum(arr, target, index + 1, 
                                   current, current_sum)

# Test
print("Subsequences with sum = 5 (optimized):")
optimized_subsequences_with_sum([1, 2, 3, 4], 5)
```

**Effect of Pruning:**
```
Without pruning: Explores all 2^n paths
With pruning: Stops early when sum > target

Example: [1,2,3,4], target=5
Without: 2^4 = 16 recursive calls
With: ~10 recursive calls (prunes [1,2,3,4], [1,3,4], etc.)
```

---

## 5.3 Subset Sum Problems

### Problem 1: Subset Sum Equal to Target

**Problem:** Check if there exists any subset with sum equal to target.

```python
def has_subset_sum(arr, target, index=0, current_sum=0):
    """
    Check if any subset has sum equal to target
    Return True/False
    
    Time: O(2^n), Space: O(n)
    """
    # Base case
    if index >= len(arr):
        return current_sum == target
    
    # Not pick
    if has_subset_sum(arr, target, index + 1, current_sum):
        return True
    
    # Pick
    if has_subset_sum(arr, target, index + 1, current_sum + arr[index]):
        return True
    
    return False

# Test
print(has_subset_sum([3, 34, 4, 12, 5, 2], 9))   # True (4+5)
print(has_subset_sum([3, 34, 4, 12, 5, 2], 30))  # False
```

**With Memoization (Optimization):**

```python
def has_subset_sum_memo(arr, target, index=0, current_sum=0, memo=None):
    """
    Optimized with memoization
    
    Time: O(n Ã— target), Space: O(n Ã— target)
    """
    if memo is None:
        memo = {}
    
    # Check memo
    key = (index, current_sum)
    if key in memo:
        return memo[key]
    
    # Base case
    if index >= len(arr):
        result = (current_sum == target)
        memo[key] = result
        return result
    
    # Not pick
    not_pick = has_subset_sum_memo(arr, target, index + 1, current_sum, memo)
    
    # Pick
    pick = has_subset_sum_memo(arr, target, index + 1, 
                               current_sum + arr[index], memo)
    
    result = not_pick or pick
    memo[key] = result
    return result

# Test
print(has_subset_sum_memo([3, 34, 4, 12, 5, 2], 9))  # True
```

---

### Problem 2: Partition Equal Subset Sum

**Problem:** Can array be partitioned into two subsets with equal sum?

**Approach:** 
1. Calculate total sum
2. If odd, return False (can't be divided equally)
3. If even, check if subset with sum = total/2 exists

```python
def can_partition(arr):
    """
    Check if array can be partitioned into two equal sum subsets
    
    Example: [1, 5, 11, 5] â†’ [1, 5, 5] and [11]
    """
    total_sum = sum(arr)
    
    # If odd sum, can't partition equally
    if total_sum % 2 != 0:
        return False
    
    target = total_sum // 2
    
    # Check if subset with sum = target exists
    return has_subset_sum(arr, target)

# Test
print(can_partition([1, 5, 11, 5]))    # True
print(can_partition([1, 2, 3, 5]))     # False
print(can_partition([1, 2, 5]))        # False
```

**Recursion Tree for [1, 5, 11, 5], target = 11:**
```
Goal: Find subset with sum = 11

                    (sum=0, idx=0)
                  /                \
          (sum=0, 1)           (sum=1, 1)
          /        \            /         \
    (sum=0,2)  (sum=5,2)   (sum=1,2)  (sum=6,2)
                    |                      |
              (sum=16) X              (sum=17) X
    
    ... continues until finding [5, 6] or [11] or [1, 5, 5]
```

---

### Problem 3: Minimum Subset Sum Difference

**Problem:** Partition array into two subsets such that absolute difference of their sums is minimum.

```python
def min_subset_sum_difference(arr, index=0, sum1=0, sum2=0):
    """
    Find minimum possible difference between two subset sums
    
    Approach: Try all possible partitions
    
    Time: O(2^n), Space: O(n)
    """
    # Base case: all elements assigned
    if index >= len(arr):
        return abs(sum1 - sum2)
    
    # Add current element to subset 1
    diff1 = min_subset_sum_difference(arr, index + 1, 
                                     sum1 + arr[index], sum2)
    
    # Add current element to subset 2
    diff2 = min_subset_sum_difference(arr, index + 1, 
                                     sum1, sum2 + arr[index])
    
    # Return minimum difference
    return min(diff1, diff2)

# Test
print(min_subset_sum_difference([1, 6, 11, 5]))  # 1 ([1,5,6] vs [11])
print(min_subset_sum_difference([1, 2, 7]))      # 4 ([7] vs [1,2])
```

**Optimized Approach:**

```python
def min_subset_sum_diff_optimized(arr):
    """
    Optimized: Only track one sum (other is total - sum1)
    
    Time: O(2^n), Space: O(n)
    """
    total = sum(arr)
    
    def helper(index, sum1):
        # Base case
        if index >= len(arr):
            sum2 = total - sum1
            return abs(sum1 - sum2)
        
        # Include in subset 1
        include = helper(index + 1, sum1 + arr[index])
        
        # Don't include (goes to subset 2)
        exclude = helper(index + 1, sum1)
        
        return min(include, exclude)
    
    return helper(0, 0)

# Test
print(min_subset_sum_diff_optimized([1, 6, 11, 5]))  # 1
```

---

## Key Takeaways from Chapter 5

### 1. The Pick/Not-Pick Pattern

This is the **fundamental pattern** for generating all subsets/subsequences:

```python
def pick_not_pick(arr, index, current):
    if index >= len(arr):
        process(current)
        return
    
    # Not pick
    pick_not_pick(arr, index + 1, current)
    
    # Pick
    pick_not_pick(arr, index + 1, current + [arr[index]])
```

### 2. Variations of the Pattern

| Variation | Modification |
|-----------|-------------|
| **Print all** | Print at base case |
| **Print one** | Return True after finding one |
| **Count all** | Return count from both paths |
| **With condition** | Check condition at base case |
| **Optimization** | Add pruning conditions |

### 3. Complexity Analysis

**Without Memoization:**
- Time: O(2^n) - exponential
- Space: O(n) - recursion depth

**With Memoization:**
- Time: O(n Ã— sum) - pseudo-polynomial
- Space: O(n Ã— sum)

### 4. When to Use This Pattern

âœ… **Use when:**
- Need to explore all possible subsets
- Problem involves "include/exclude" decisions
- Need to find combinations that satisfy condition
- Classic subset/subsequence problems

âŒ **Don't use when:**
- Only need one optimal solution (use greedy/DP)
- Can solve with mathematical formula
- Linear scan would work

---

## Practice Problems

### Easy
1. Print all subsets of array
2. Find if subset with sum 0 exists
3. Count subsets with given XOR
4. Partition array into K equal sum subsets
5. Subset with maximum sum

### Medium
6. Combination Sum (elements can repeat)
7. Combination Sum II (each element used once)
8. Subset Sum with negative numbers
9. Target Sum (assign +/- to reach target)
10. Partition to K equal sum subsets

### Hard
11. Maximum XOR subset
12. Partition array for minimum sum difference
13. Count of subsets with given difference
14. Tallest billboard problem
15. Fair distribution problem

### Challenge
16. Generate subsets with size K
17. Subsets with sum in range [L, R]
18. K-th largest sum contiguous subarray
19. Perfect Sum Problem (count subsets with sum S)
20. Subsets avoiding adjacent elements

---

## Common Patterns Summary

```python
# Pattern 1: Generate All
def generate_all(arr, idx, current):
    if idx >= len(arr):
        result.append(current[:])
        return
    generate_all(arr, idx+1, current)
    current.append(arr[idx])
    generate_all(arr, idx+1, current)
    current.pop()  # backtrack

# Pattern 2: Find One
def find_one(arr, idx, current, target):
    if idx >= len(arr):
        if check(current, target):
            return True
        return False
    if find_one(arr, idx+1, current, target):
        return True
    current.append(arr[idx])
    if find_one(arr, idx+1, current, target):
        return True
    current.pop()
    return False

# Pattern 3: Count
def count(arr, idx, current_sum, target):
    if idx >= len(arr):
        return 1 if current_sum == target else 0
    not_pick = count(arr, idx+1, current_sum, target)
    pick = count(arr, idx+1, current_sum + arr[idx], target)
    return not_pick + pick

# Pattern 4: With Memoization
def with_memo(arr, idx, current_sum, memo):
    if (idx, current_sum) in memo:
        return memo[(idx, current_sum)]
    # ... recursive logic
    memo[(idx, current_sum)] = result
    return result
```

**Remember:** The Pick/Not-Pick pattern is your foundation for all subset and subsequence problems! Master it, and you'll solve dozens of problems with ease. ðŸš€
