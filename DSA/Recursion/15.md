# Chapter 15: Recursion with Data Structures

## 15.1 Linked List Recursion

### Why Recursion Works Well with Linked Lists

Linked lists are naturally recursive:
- A list is either empty OR a node + rest of list
- Operations on list = operation on head + recursion on tail
- No indices needed

**Node Definition:**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```

### Pattern 1: Reverse Linked List

**Problem:** Reverse a singly linked list recursively.

```python
def reverse_list(head):
    """
    Reverse linked list using recursion
    
    Time: O(n), Space: O(n) - recursion stack
    """
    # BASE CASE: Empty or single node
    if head is None or head.next is None:
        return head
    
    # Recursively reverse the rest
    new_head = reverse_list(head.next)
    
    # Reverse the current link
    # Before: head ‚Üí next ‚Üí ...
    # After:  head ‚Üê next ‚Üê ...
    head.next.next = head
    head.next = None
    
    return new_head

# Helper to create list
def create_list(values):
    dummy = ListNode(0)
    current = dummy
    for val in values:
        current.next = ListNode(val)
        current = current.next
    return dummy.next

# Helper to print list
def print_list(head):
    values = []
    while head:
        values.append(head.val)
        head = head.next
    print(" -> ".join(map(str, values)))

# Test
head = create_list([1, 2, 3, 4, 5])
print("Original:")
print_list(head)
reversed_head = reverse_list(head)
print("Reversed:")
print_list(reversed_head)
```

**Step-by-Step Visualization:**
```
Original: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí None

Recursion calls:
reverse(1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5)
‚îú‚îÄ reverse(2 ‚Üí 3 ‚Üí 4 ‚Üí 5)
   ‚îú‚îÄ reverse(3 ‚Üí 4 ‚Üí 5)
      ‚îú‚îÄ reverse(4 ‚Üí 5)
         ‚îú‚îÄ reverse(5)
         ‚îÇ  ‚îî‚îÄ return 5 (base case)
         ‚îî‚îÄ Make: 5 ‚Üí 4, return 5
      ‚îî‚îÄ Make: 4 ‚Üê 5 ‚Üí 3, return 5
   ‚îî‚îÄ Make: 3 ‚Üê 4 ‚Üê 5 ‚Üí 2, return 5
‚îî‚îÄ Make: 2 ‚Üê 3 ‚Üê 4 ‚Üê 5 ‚Üí 1, return 5

Final: 5 ‚Üí 4 ‚Üí 3 ‚Üí 2 ‚Üí 1 ‚Üí None
```

**Key Insight:**
```python
# At each step:
head.next.next = head  # Reverse the link
head.next = None       # Remove forward link
```

---

### Pattern 2: Merge Two Sorted Lists

```python
def merge_two_lists(l1, l2):
    """
    Merge two sorted linked lists
    
    Time: O(m + n), Space: O(m + n) - recursion
    """
    # BASE CASE: One list is empty
    if l1 is None:
        return l2
    if l2 is None:
        return l1
    
    # Compare heads and merge recursively
    if l1.val <= l2.val:
        l1.next = merge_two_lists(l1.next, l2)
        return l1
    else:
        l2.next = merge_two_lists(l1, l2.next)
        return l2

# Test
l1 = create_list([1, 3, 5])
l2 = create_list([2, 4, 6])
merged = merge_two_lists(l1, l2)
print("Merged:")
print_list(merged)  # 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 6
```

**Recursion Tree:**
```
merge([1,3,5], [2,4,6])
‚îú‚îÄ 1.next = merge([3,5], [2,4,6])
   ‚îú‚îÄ 2.next = merge([3,5], [4,6])
      ‚îú‚îÄ 3.next = merge([5], [4,6])
         ‚îú‚îÄ 4.next = merge([5], [6])
            ‚îú‚îÄ 5.next = merge([], [6])
               ‚îî‚îÄ return [6]
            ‚îî‚îÄ return 5‚Üí6
         ‚îî‚îÄ return 4‚Üí5‚Üí6
      ‚îî‚îÄ return 3‚Üí4‚Üí5‚Üí6
   ‚îî‚îÄ return 2‚Üí3‚Üí4‚Üí5‚Üí6
‚îî‚îÄ return 1‚Üí2‚Üí3‚Üí4‚Üí5‚Üí6
```

---

### Pattern 3: Palindrome Check

```python
def is_palindrome_list(head):
    """
    Check if linked list is palindrome
    
    Time: O(n), Space: O(n)
    """
    values = []
    
    def collect_values(node):
        if node is None:
            return
        values.append(node.val)
        collect_values(node.next)
    
    collect_values(head)
    return values == values[::-1]

# Alternative: Recursive comparison
def is_palindrome_recursive(head):
    """Using recursion with two pointers"""
    # Use list to maintain reference
    front = [head]
    
    def check(node):
        if node is None:
            return True
        
        # Go to end
        if not check(node.next):
            return False
        
        # Compare during backtrack
        if node.val != front[0].val:
            return False
        
        front[0] = front[0].next
        return True
    
    return check(head)

# Test
head = create_list([1, 2, 3, 2, 1])
print(f"Is palindrome: {is_palindrome_recursive(head)}")  # True
```

---

### Pattern 4: Remove Nth Node from End

```python
def remove_nth_from_end(head, n):
    """
    Remove nth node from end of list
    
    Time: O(n), Space: O(n)
    """
    def helper(node):
        """Returns (new_head, position_from_end)"""
        if node is None:
            return None, 0
        
        # Recurse to end
        next_node, pos = helper(node.next)
        
        # Current position
        current_pos = pos + 1
        
        # If this is the node to remove
        if current_pos == n:
            return next_node, current_pos
        
        # Otherwise, keep this node
        node.next = next_node
        return node, current_pos
    
    new_head, _ = helper(head)
    return new_head

# Test
head = create_list([1, 2, 3, 4, 5])
result = remove_nth_from_end(head, 2)
print_list(result)  # 1 ‚Üí 2 ‚Üí 3 ‚Üí 5
```

---

### Pattern 5: Merge K Sorted Lists

```python
def merge_k_lists(lists):
    """
    Merge k sorted linked lists using divide and conquer
    
    Time: O(N log k) where N = total nodes, k = number of lists
    Space: O(log k) - recursion depth
    """
    if not lists:
        return None
    
    def merge_two(l1, l2):
        """Helper to merge two lists"""
        if not l1:
            return l2
        if not l2:
            return l1
        
        if l1.val <= l2.val:
            l1.next = merge_two(l1.next, l2)
            return l1
        else:
            l2.next = merge_two(l1, l2.next)
            return l2
    
    def merge_range(start, end):
        """Merge lists from start to end index"""
        if start == end:
            return lists[start]
        
        if start > end:
            return None
        
        mid = (start + end) // 2
        left = merge_range(start, mid)
        right = merge_range(mid + 1, end)
        
        return merge_two(left, right)
    
    return merge_range(0, len(lists) - 1)

# Test
lists = [
    create_list([1, 4, 5]),
    create_list([1, 3, 4]),
    create_list([2, 6])
]
merged = merge_k_lists(lists)
print_list(merged)  # 1‚Üí1‚Üí2‚Üí3‚Üí4‚Üí4‚Üí5‚Üí6
```

---

## 15.2 Stack and Queue Recursion

### Pattern 1: Sort a Stack

**Problem:** Sort a stack using only recursion (no extra data structures).

```python
def sort_stack(stack):
    """
    Sort stack using recursion
    
    Time: O(n¬≤), Space: O(n)
    """
    # BASE CASE: Empty stack
    if not stack:
        return
    
    # Remove top element
    top = stack.pop()
    
    # Sort remaining stack
    sort_stack(stack)
    
    # Insert top element in sorted position
    insert_sorted(stack, top)

def insert_sorted(stack, element):
    """Insert element in sorted stack"""
    # BASE CASE: Stack empty or element belongs on top
    if not stack or element >= stack[-1]:
        stack.append(element)
        return
    
    # Remove top
    top = stack.pop()
    
    # Insert element in remaining stack
    insert_sorted(stack, element)
    
    # Put top back
    stack.append(top)

# Test
stack = [3, 1, 4, 2, 5]
print(f"Original: {stack}")
sort_stack(stack)
print(f"Sorted: {stack}")  # [1, 2, 3, 4, 5]
```

**Visualization:**
```
Sort [3, 1, 4, 2, 5]:

1. Pop 5, sort [3,1,4,2]
2. Pop 2, sort [3,1,4]
3. Pop 4, sort [3,1]
4. Pop 1, sort [3]
5. Pop 3, sort []
6. Insert 3: [3]
7. Insert 1: [1,3]
8. Insert 4: [1,3,4]
9. Insert 2: [1,2,3,4]
10. Insert 5: [1,2,3,4,5]
```

---

### Pattern 2: Reverse a Stack

```python
def reverse_stack(stack):
    """
    Reverse stack using recursion
    
    Time: O(n¬≤), Space: O(n)
    """
    # BASE CASE: Empty stack
    if not stack:
        return
    
    # Remove top element
    top = stack.pop()
    
    # Reverse remaining stack
    reverse_stack(stack)
    
    # Insert at bottom
    insert_at_bottom(stack, top)

def insert_at_bottom(stack, element):
    """Insert element at bottom of stack"""
    # BASE CASE: Empty stack
    if not stack:
        stack.append(element)
        return
    
    # Remove top
    top = stack.pop()
    
    # Insert element at bottom
    insert_at_bottom(stack, element)
    
    # Put top back
    stack.append(top)

# Test
stack = [1, 2, 3, 4, 5]
print(f"Original: {stack}")
reverse_stack(stack)
print(f"Reversed: {stack}")  # [5, 4, 3, 2, 1]
```

---

### Pattern 3: Delete Middle Element

```python
def delete_middle(stack, current=0):
    """
    Delete middle element of stack
    
    Time: O(n), Space: O(n)
    """
    size = len(stack)
    middle = size // 2
    
    def helper(index):
        # BASE CASE: Reached middle
        if index == middle:
            stack.pop()
            return
        
        # Remove top
        top = stack.pop()
        
        # Recurse
        helper(index + 1)
        
        # Put back if not middle
        stack.append(top)
    
    helper(0)

# Test
stack = [1, 2, 3, 4, 5]
print(f"Original: {stack}")
delete_middle(stack)
print(f"After deleting middle: {stack}")  # [1, 2, 4, 5]
```

---

## 15.3 Heap Recursion

### Pattern 1: Heapify Process

```python
def heapify(arr, n, i):
    """
    Heapify subtree rooted at index i
    (Max heap implementation)
    
    Time: O(log n), Space: O(log n)
    """
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    # Compare with left child
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    # Compare with right child
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    # If largest is not root
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        # Recursively heapify affected subtree
        heapify(arr, n, largest)

def build_max_heap(arr):
    """Build max heap from array"""
    n = len(arr)
    # Start from last non-leaf node
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

# Test
arr = [4, 10, 3, 5, 1]
print(f"Original: {arr}")
build_max_heap(arr)
print(f"Max heap: {arr}")  # [10, 5, 3, 4, 1]
```

**Heap Structure:**
```
Original array: [4, 10, 3, 5, 1]

Tree representation:
        4
       / \
      10  3
     / \
    5   1

After heapify:
       10
       / \
      5   3
     / \
    4   1

Array: [10, 5, 3, 4, 1]
```

---

### Pattern 2: Kth Largest/Smallest Element

```python
def find_kth_largest_heap(nums, k):
    """
    Find kth largest element using heap approach
    
    Time: O(n log n), Space: O(log n)
    """
    def heapify_down(arr, n, i):
        """Max heapify"""
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n and arr[left] > arr[largest]:
            largest = left
        if right < n and arr[right] > arr[largest]:
            largest = right
        
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify_down(arr, n, largest)
    
    # Build max heap
    n = len(nums)
    for i in range(n // 2 - 1, -1, -1):
        heapify_down(nums, n, i)
    
    # Extract max k times
    for _ in range(k - 1):
        # Swap root with last element
        nums[0], nums[n - 1] = nums[n - 1], nums[0]
        n -= 1
        heapify_down(nums, n, 0)
    
    return nums[0]

# Test
nums = [3, 2, 1, 5, 6, 4]
k = 2
result = find_kth_largest_heap(nums[:], k)
print(f"{k}th largest: {result}")  # 5
```

---

### Pattern 3: Merge K Sorted Arrays (Heap)

```python
def merge_k_sorted_arrays(arrays):
    """
    Merge k sorted arrays using recursion
    
    Time: O(N log k), Space: O(k)
    """
    def merge_two(arr1, arr2):
        """Merge two sorted arrays"""
        if not arr1:
            return arr2
        if not arr2:
            return arr1
        
        result = []
        i = j = 0
        
        while i < len(arr1) and j < len(arr2):
            if arr1[i] <= arr2[j]:
                result.append(arr1[i])
                i += 1
            else:
                result.append(arr2[j])
                j += 1
        
        result.extend(arr1[i:])
        result.extend(arr2[j:])
        return result
    
    def merge_range(start, end):
        """Merge arrays from start to end"""
        if start == end:
            return arrays[start]
        if start > end:
            return []
        
        mid = (start + end) // 2
        left = merge_range(start, mid)
        right = merge_range(mid + 1, end)
        
        return merge_two(left, right)
    
    if not arrays:
        return []
    
    return merge_range(0, len(arrays) - 1)

# Test
arrays = [
    [1, 4, 7],
    [2, 5, 8],
    [3, 6, 9]
]
result = merge_k_sorted_arrays(arrays)
print(f"Merged: {result}")  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

---

## 15.4 Advanced List Problems

### Pattern 1: Reorder List

**Problem:** Reorder list to: L0 ‚Üí Ln ‚Üí L1 ‚Üí Ln-1 ‚Üí L2 ‚Üí Ln-2 ‚Üí ...

```python
def reorder_list(head):
    """
    Reorder list: first, last, second, second-last, ...
    
    Time: O(n), Space: O(n)
    """
    if not head or not head.next:
        return head
    
    # Collect all nodes
    nodes = []
    current = head
    while current:
        nodes.append(current)
        current = current.next
    
    def reorder_recursive(left, right):
        """Reorder nodes from left to right indices"""
        if left >= right:
            nodes[left].next = None
            return
        
        # Connect left to next
        nodes[left].next = nodes[right]
        
        if left + 1 == right:
            nodes[right].next = None
        else:
            # Connect right to next left
            nodes[right].next = nodes[left + 1]
            reorder_recursive(left + 1, right - 1)
    
    reorder_recursive(0, len(nodes) - 1)
    return head

# Test
head = create_list([1, 2, 3, 4, 5])
reorder_list(head)
print_list(head)  # 1 ‚Üí 5 ‚Üí 2 ‚Üí 4 ‚Üí 3
```

---

### Pattern 2: Add Two Numbers (Lists as Numbers)

```python
def add_two_numbers(l1, l2, carry=0):
    """
    Add two numbers represented as linked lists
    
    Example: 342 + 465 = 807
    Lists: (2‚Üí4‚Üí3) + (5‚Üí6‚Üí4) = (7‚Üí0‚Üí8)
    
    Time: O(max(m,n)), Space: O(max(m,n))
    """
    # BASE CASE: Both lists empty and no carry
    if l1 is None and l2 is None and carry == 0:
        return None
    
    # Get values
    val1 = l1.val if l1 else 0
    val2 = l2.val if l2 else 0
    
    # Calculate sum
    total = val1 + val2 + carry
    digit = total % 10
    carry = total // 10
    
    # Create result node
    result = ListNode(digit)
    
    # Move to next nodes
    next1 = l1.next if l1 else None
    next2 = l2.next if l2 else None
    
    # Recursively add remaining
    result.next = add_two_numbers(next1, next2, carry)
    
    return result

# Test
l1 = create_list([2, 4, 3])  # 342
l2 = create_list([5, 6, 4])  # 465
result = add_two_numbers(l1, l2)
print_list(result)  # 7 ‚Üí 0 ‚Üí 8 (807)
```

---

### Pattern 3: Copy List with Random Pointer

```python
class NodeWithRandom:
    def __init__(self, val=0, next=None, random=None):
        self.val = val
        self.next = next
        self.random = random

def copy_random_list(head, visited=None):
    """
    Deep copy linked list with random pointers
    
    Time: O(n), Space: O(n)
    """
    if visited is None:
        visited = {}
    
    # BASE CASE: None node
    if head is None:
        return None
    
    # If already visited, return the copy
    if head in visited:
        return visited[head]
    
    # Create new node
    new_node = NodeWithRandom(head.val)
    visited[head] = new_node
    
    # Recursively copy next and random
    new_node.next = copy_random_list(head.next, visited)
    new_node.random = copy_random_list(head.random, visited)
    
    return new_node
```

---

## Key Takeaways from Chapter 15

### 1. Linked List Patterns

| Pattern | Key Technique | Complexity |
|---------|---------------|------------|
| **Reverse** | Reverse links during backtrack | O(n) time, O(n) space |
| **Merge** | Compare heads recursively | O(m+n) time |
| **Remove node** | Skip node during return | O(n) time |
| **Palindrome** | Compare front and back | O(n) time |

### 2. Stack Recursion Template

```python
def operate_stack(stack):
    if base_case:
        return
    
    # Remove element
    element = stack.pop()
    
    # Operate on remaining
    operate_stack(stack)
    
    # Process element (insert/modify)
    process(element)
```

### 3. Heap Recursion

- **Heapify:** O(log n) - recursively fix heap property
- **Build heap:** O(n) - heapify from bottom up
- **Extract:** O(log n) - remove root, heapify

### 4. When to Use Recursion with Data Structures

‚úÖ **Use recursion when:**
- Natural recursive structure (lists, trees)
- Need to process in reverse order
- Problem requires backtracking
- Clean solution without indices

‚ùå **Consider iterative when:**
- Very long lists (stack overflow risk)
- Space is critical
- Simple sequential processing

---

## Practice Problems

### Easy
1. Reverse linked list
2. Merge two sorted lists
3. Remove linked list elements
4. Middle of linked list
5. Check if linked list is sorted

### Medium
6. Reverse list in groups of k
7. Add two numbers (lists)
8. Sort stack using recursion
9. Remove duplicates from sorted list II
10. Flatten multilevel doubly linked list

### Hard
11. Merge k sorted lists
12. Reverse nodes in k-group
13. Copy list with random pointer
14. LRU cache (with recursion)
15. Reorder list

### Challenge
16. Sort linked list (merge sort)
17. Detect and remove cycle
18. Clone complex list with random pointers
19. Implement queue using stacks (recursive)
20. Design browser history (recursive)

---

## Common Mistakes

‚ùå **Losing list references**
```python
# Wrong
head = head.next  # Lost reference to original head!

# Right
current = head
while current:
    # Process
    current = current.next
```

‚ùå **Not handling None cases**
```python
# Wrong
def reverse(head):
    head.next.next = head  # Crash if head.next is None!

# Right
def reverse(head):
    if not head or not head.next:
        return head
    # Safe to proceed
```

‚ùå **Infinite recursion in cycles**
```python
# Wrong - infinite loop if list has cycle
def process(node):
    process(node.next)

# Right - track visited nodes
def process(node, visited=None):
    if visited is None:
        visited = set()
    if node in visited:
        return
    visited.add(node)
    process(node.next, visited)
```

Master recursion with data structures and you'll write elegant solutions to complex problems! üìö
