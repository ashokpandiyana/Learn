# Chapter 7: Backtracking Fundamentals

## 7.1 Understanding Backtracking

### What is Backtracking?

**Backtracking** is an algorithmic technique that incrementally builds candidates for solutions and **abandons a candidate** ("backtracks") as soon as it determines that the candidate cannot lead to a valid solution.

**Think of it as:**
- Exploring a maze: try a path, if it's a dead end, go back and try another
- Trial and error with systematic exploration
- **Recursion + Exploration + Reverting choices**

### Key Difference: Recursion vs Backtracking

```
Recursion:
- Just breaks problem into subproblems
- All paths are valid to explore

Backtracking:
- Explores solution space systematically
- Abandons invalid paths early (pruning)
- Must undo changes when backtracking
- Uses constraints to avoid invalid solutions
```

### The Three Steps of Backtracking

Every backtracking solution follows this pattern:

```python
def backtrack(state):
    if is_solution(state):
        # Base case: found a solution
        add state to results
        return
    
    for choice in available_choices(state):
        # 1. CHOOSE: Make a choice
        make_choice(choice)
        
        # 2. EXPLORE: Recurse with new state
        backtrack(new_state)
        
        # 3. UNCHOOSE: Undo the choice (backtrack)
        undo_choice(choice)
```

### Simple Example: Generate Binary Strings

```python
def generate_binary(n, current=""):
    """
    Generate all binary strings of length n
    Demonstrates basic backtracking
    """
    # Base case: reached desired length
    if len(current) == n:
        print(current)
        return
    
    # Choice 1: Add '0'
    generate_binary(n, current + '0')
    
    # Choice 2: Add '1'
    generate_binary(n, current + '1')

# Test
print("Binary strings of length 3:")
generate_binary(3)
```

**Output:**
```
Binary strings of length 3:
000
001
010
011
100
101
110
111
```

**Recursion Tree:**
```
                        ""
                    /        \
                  "0"         "1"
                /    \       /    \
             "00"   "01"  "10"   "11"
             / \    / \    / \    / \
          000 001 010 011 100 101 110 111
```

---

## 7.2 Backtracking Template

### Universal Backtracking Template

This template works for **90% of backtracking problems**:

```python
def backtracking_template(state, choices, path, result):
    """
    Universal backtracking template
    
    Args:
        state: Current state of exploration
        choices: Available choices at this state
        path: Current solution being built
        result: Collection of all valid solutions
    """
    # BASE CASE: Check if current path is a solution
    if is_valid_solution(path, state):
        result.append(path.copy())  # Important: copy!
        return
    
    # RECURSIVE CASE: Try all possible choices
    for choice in get_choices(state, choices):
        
        # PRUNING: Skip invalid choices early
        if not is_valid_choice(choice, state):
            continue
        
        # CHOOSE: Make the choice
        path.append(choice)
        update_state(state, choice)  # Optional: modify state
        
        # EXPLORE: Recurse with updated state
        backtracking_template(state, choices, path, result)
        
        # UNCHOOSE: Revert the choice (backtrack)
        path.pop()
        revert_state(state, choice)  # Optional: restore state
```

### Detailed Example: Subset Generation

```python
def generate_subsets(nums):
    """
    Generate all subsets using backtracking template
    
    Time: O(2^n), Space: O(n)
    """
    result = []
    
    def backtrack(start, current_subset):
        # BASE CASE: Add current subset to result
        # (Every state is valid, so we add immediately)
        result.append(current_subset[:])  # Copy!
        
        # RECURSIVE CASE: Try adding each remaining element
        for i in range(start, len(nums)):
            # CHOOSE: Add nums[i] to subset
            current_subset.append(nums[i])
            
            # EXPLORE: Recurse with next index
            backtrack(i + 1, current_subset)
            
            # UNCHOOSE: Remove nums[i] (backtrack)
            current_subset.pop()
    
    backtrack(0, [])
    return result

# Test
subsets = generate_subsets([1, 2, 3])
print("All subsets:")
for subset in sorted(subsets, key=lambda x: (len(x), x)):
    print(subset)
```

**Output:**
```
All subsets:
[]
[1]
[2]
[3]
[1, 2]
[1, 3]
[2, 3]
[1, 2, 3]
```

**Visualization with Choose/Unchoose:**
```
Start: current_subset = []

Choose 1: [1]
  Choose 2: [1, 2]
    Choose 3: [1, 2, 3]  â†’ Add to result
    Unchoose 3: [1, 2]
  Unchoose 2: [1]
  Choose 3: [1, 3]  â†’ Add to result
  Unchoose 3: [1]
Unchoose 1: []

Choose 2: [2]
  Choose 3: [2, 3]  â†’ Add to result
  Unchoose 3: [2]
Unchoose 2: []

Choose 3: [3]  â†’ Add to result
Unchoose 3: []
```

---

## 7.3 Classic Backtracking Problems

### Problem 1: N-Queens

**Problem:** Place N queens on an NÃ—N chessboard such that no two queens attack each other.

**Constraints:**
- No two queens in same row
- No two queens in same column
- No two queens in same diagonal

```python
def solve_n_queens(n):
    """
    Solve N-Queens problem using backtracking
    
    Time: O(N!), Space: O(N)
    """
    result = []
    board = [['.'] * n for _ in range(n)]
    
    # Track attacked columns and diagonals
    cols = set()
    diag1 = set()  # row - col is constant for diagonal
    diag2 = set()  # row + col is constant for anti-diagonal
    
    def backtrack(row):
        # BASE CASE: All queens placed
        if row == n:
            # Convert board to required format
            result.append([''.join(row) for row in board])
            return
        
        # RECURSIVE CASE: Try placing queen in each column
        for col in range(n):
            # PRUNING: Check if position is safe
            if col in cols or (row - col) in diag1 or (row + col) in diag2:
                continue
            
            # CHOOSE: Place queen
            board[row][col] = 'Q'
            cols.add(col)
            diag1.add(row - col)
            diag2.add(row + col)
            
            # EXPLORE: Move to next row
            backtrack(row + 1)
            
            # UNCHOOSE: Remove queen (backtrack)
            board[row][col] = '.'
            cols.remove(col)
            diag1.remove(row - col)
            diag2.remove(row + col)
    
    backtrack(0)
    return result

# Test
solutions = solve_n_queens(4)
print(f"Total solutions for 4-Queens: {len(solutions)}")
print("\nFirst solution:")
for row in solutions[0]:
    print(row)
```

**Output:**
```
Total solutions for 4-Queens: 2

First solution:
.Q..
...Q
Q...
..Q.
```

**Visualization of Backtracking:**
```
4x4 Board - Trying to place 4 queens

Row 0: Try col 0
[Q...]  Place queen at (0,0)
[....]
[....]
[....]

Row 1: Try col 0 - INVALID (same col)
       Try col 1 - INVALID (diagonal)
       Try col 2 - VALID
[Q...]
[..Q.]
[....]
[....]

Row 2: Try col 0 - INVALID (diagonal)
       Try col 1 - INVALID (diagonal)
       Try col 2 - INVALID (same col)
       Try col 3 - INVALID (diagonal)
       NO VALID POSITION!

BACKTRACK to Row 1, try col 3
[Q...]
[...Q]
[....]
[....]

Row 2: Try col 1 - VALID
[Q...]
[...Q]
[.Q..]
[....]

Row 3: Try col 2 - INVALID (diagonal)
       Try col 3 - INVALID (same col)
       NO VALID POSITION!

BACKTRACK to Row 1, remove queen...
BACKTRACK to Row 0, try col 1...

Eventually finds:
[.Q..]
[...Q]
[Q...]
[..Q.]
```

**Key Techniques:**
1. **State representation:** Sets for columns and diagonals
2. **Pruning:** Check constraints before placing queen
3. **Backtracking:** Remove queen if no solution found in subsequent rows

---

### Problem 2: Sudoku Solver

**Problem:** Fill a 9Ã—9 Sudoku board following the rules.

```python
def solve_sudoku(board):
    """
    Solve Sudoku using backtracking
    
    board: 9x9 grid with '.' for empty cells
    Time: O(9^(empty_cells)), Space: O(1)
    """
    def is_valid(row, col, num):
        """Check if placing num at (row, col) is valid"""
        # Check row
        if num in board[row]:
            return False
        
        # Check column
        if num in [board[i][col] for i in range(9)]:
            return False
        
        # Check 3x3 box
        box_row, box_col = 3 * (row // 3), 3 * (col // 3)
        for i in range(box_row, box_row + 3):
            for j in range(box_col, box_col + 3):
                if board[i][j] == num:
                    return False
        
        return True
    
    def backtrack():
        # Find next empty cell
        for row in range(9):
            for col in range(9):
                if board[row][col] == '.':
                    # Try each digit 1-9
                    for num in '123456789':
                        # PRUNING: Check if valid
                        if is_valid(row, col, num):
                            # CHOOSE: Place number
                            board[row][col] = num
                            
                            # EXPLORE: Continue solving
                            if backtrack():
                                return True
                            
                            # UNCHOOSE: Reset cell (backtrack)
                            board[row][col] = '.'
                    
                    # No valid number found, backtrack
                    return False
        
        # All cells filled successfully
        return True
    
    backtrack()
    return board

# Test
board = [
    ["5","3",".",".","7",".",".",".","."],
    ["6",".",".","1","9","5",".",".","."],
    [".","9","8",".",".",".",".","6","."],
    ["8",".",".",".","6",".",".",".","3"],
    ["4",".",".","8",".","3",".",".","1"],
    ["7",".",".",".","2",".",".",".","6"],
    [".","6",".",".",".",".","2","8","."],
    [".",".",".","4","1","9",".",".","5"],
    [".",".",".",".","8",".",".","7","9"]
]

result = solve_sudoku(board)
print("Solved Sudoku:")
for row in result:
    print(' '.join(row))
```

**Backtracking Flow:**
```
Start with partially filled board:
5 3 . | . 7 . | . . .
6 . . | 1 9 5 | . . .
. 9 8 | . . . | . 6 .
------+-------+------
8 . . | . 6 . | . . 3
4 . . | 8 . 3 | . . 1
7 . . | . 2 . | . . 6
------+-------+------
. 6 . | . . . | 2 8 .
. . . | 4 1 9 | . . 5
. . . | . 8 . | . 7 9

Find first empty: (0, 2)
Try 1: Invalid (column conflict)
Try 2: Invalid (box conflict)
Try 3: Invalid (row conflict)
Try 4: Valid! Place 4
  Continue to next empty cell...
  Eventually hit a dead end
  BACKTRACK: Remove 4, try 5...
  
Continue until all cells filled
```

---

### Problem 3: Rat in a Maze

**Problem:** Find path from top-left to bottom-right in a maze.

```python
def rat_in_maze(maze):
    """
    Find path in maze using backtracking
    1 = open path, 0 = blocked
    
    Time: O(2^(nÂ²)), Space: O(nÂ²)
    """
    n = len(maze)
    solution = [[0] * n for _ in range(n)]
    result = []
    
    def is_safe(x, y):
        """Check if (x, y) is valid position"""
        return (0 <= x < n and 0 <= y < n and 
                maze[x][y] == 1 and solution[x][y] == 0)
    
    def backtrack(x, y, path):
        # BASE CASE: Reached destination
        if x == n - 1 and y == n - 1:
            solution[x][y] = 1
            result.append([row[:] for row in solution])
            solution[x][y] = 0  # Backtrack for other paths
            return
        
        # CHOOSE: Mark current cell as part of path
        solution[x][y] = 1
        
        # EXPLORE: Try all four directions
        # Down
        if is_safe(x + 1, y):
            backtrack(x + 1, y, path + 'D')
        
        # Right
        if is_safe(x, y + 1):
            backtrack(x, y + 1, path + 'R')
        
        # Up
        if is_safe(x - 1, y):
            backtrack(x - 1, y, path + 'U')
        
        # Left
        if is_safe(x, y - 1):
            backtrack(x, y - 1, path + 'L')
        
        # UNCHOOSE: Unmark cell (backtrack)
        solution[x][y] = 0
    
    if maze[0][0] == 1:
        backtrack(0, 0, "")
    
    return result

# Test
maze = [
    [1, 0, 0, 0],
    [1, 1, 0, 1],
    [0, 1, 0, 0],
    [1, 1, 1, 1]
]

paths = rat_in_maze(maze)
print(f"Total paths: {len(paths)}")
if paths:
    print("\nFirst path:")
    for row in paths[0]:
        print(' '.join(map(str, row)))
```

**Output:**
```
Total paths: 1

First path:
1 0 0 0
1 1 0 0
0 1 0 0
0 1 1 1
```

**Visualization:**
```
Maze (1=open, 0=blocked):
S 0 0 0    S = Start
1 1 0 1    E = End
0 1 0 0
1 1 1 E

Try going Down from (0,0):
  (1,0) - Valid, go Down
  (2,0) - Blocked! Backtrack to (1,0)
  
Try going Right from (1,0):
  (1,1) - Valid, go Down
  (2,1) - Valid, go Down
  (3,1) - Valid, go Right
  (3,2) - Valid, go Right
  (3,3) - Reached end! Solution found!

Path: D â†’ R â†’ D â†’ D â†’ R â†’ R
```

---

### Problem 4: Knight's Tour

**Problem:** Move a knight to visit every square on a chessboard exactly once.

```python
def knights_tour(n):
    """
    Find knight's tour on nÃ—n board
    
    Time: O(8^(nÂ²)), Space: O(nÂ²)
    """
    board = [[-1] * n for _ in range(n)]
    
    # Knight's possible moves
    move_x = [2, 1, -1, -2, -2, -1, 1, 2]
    move_y = [1, 2, 2, 1, -1, -2, -2, -1]
    
    def is_safe(x, y):
        """Check if (x, y) is valid and unvisited"""
        return (0 <= x < n and 0 <= y < n and board[x][y] == -1)
    
    def backtrack(x, y, move_count):
        # CHOOSE: Mark current position
        board[x][y] = move_count
        
        # BASE CASE: All squares visited
        if move_count == n * n - 1:
            return True
        
        # EXPLORE: Try all 8 knight moves
        for i in range(8):
            next_x = x + move_x[i]
            next_y = y + move_y[i]
            
            # PRUNING: Check if move is valid
            if is_safe(next_x, next_y):
                if backtrack(next_x, next_y, move_count + 1):
                    return True
        
        # UNCHOOSE: Unmark position (backtrack)
        board[x][y] = -1
        return False
    
    # Start from (0, 0)
    if backtrack(0, 0, 0):
        return board
    return None

# Test (warning: takes time for n > 5)
result = knights_tour(5)
if result:
    print("Knight's Tour (5x5):")
    for row in result:
        print(' '.join(f'{x:2}' for x in row))
```

**Knight's Moves:**
```
From position K, knight can move to any X:

  X . X . .
  . . . X .
  . K . . .
  . . . X .
  X . X . .

8 possible moves in L-shape
```

---

## 7.4 State Restoration (Critical Concept)

### Why State Restoration Matters

When backtracking, you must **undo ALL changes** made during the "choose" step.

#### Example: Incorrect Backtracking

```python
def incorrect_backtracking(arr, used, current):
    """
    WRONG: Not restoring state properly
    """
    if len(current) == len(arr):
        print(current)
        return
    
    for i in range(len(arr)):
        if not used[i]:
            used[i] = True
            current.append(arr[i])
            incorrect_backtracking(arr, used, current)
            # BUG: Forgot to restore state!
            # Missing: used[i] = False
            # Missing: current.pop()

# This will produce incorrect results!
```

#### Correct Backtracking

```python
def correct_backtracking(arr, used, current):
    """
    CORRECT: Properly restoring state
    """
    if len(current) == len(arr):
        print(current[:])  # Must copy!
        return
    
    for i in range(len(arr)):
        if not used[i]:
            # CHOOSE
            used[i] = True
            current.append(arr[i])
            
            # EXPLORE
            correct_backtracking(arr, used, current)
            
            # UNCHOOSE (restore state)
            used[i] = False
            current.pop()
```

### Types of State to Restore

```python
def comprehensive_backtracking():
    """
    Examples of different types of state restoration
    """
    
    # 1. Boolean flags
    visited[i] = True
    backtrack()
    visited[i] = False  # Restore
    
    # 2. List modifications
    path.append(value)
    backtrack()
    path.pop()  # Restore
    
    # 3. Set modifications
    used.add(item)
    backtrack()
    used.remove(item)  # Restore
    
    # 4. Grid modifications
    grid[i][j] = 'X'
    backtrack()
    grid[i][j] = original_value  # Restore
    
    # 5. Counter modifications
    count += 1
    backtrack()
    count -= 1  # Restore
    
    # 6. Multiple state changes
    state.update({'key': value})
    visited[i] = True
    path.append(i)
    backtrack()
    path.pop()
    visited[i] = False
    state.update({'key': old_value})  # Restore all!
```

---

## Key Takeaways from Chapter 7

### 1. Three Steps of Backtracking

```
1. CHOOSE: Make a decision/choice
2. EXPLORE: Recursively explore consequences
3. UNCHOOSE: Undo the choice (backtrack)
```

### 2. When to Use Backtracking

âœ… **Use backtracking when:**
- Need to find all solutions (not just one)
- Problem has constraints
- Solution involves making a sequence of choices
- Can detect invalid paths early
- Problems: N-Queens, Sudoku, mazes, permutations

âŒ **Don't use when:**
- Only need one solution (might use greedy/DP)
- No constraints to prune
- Problem has optimal substructure (use DP)

### 3. Optimization: Pruning

**Pruning** = Avoiding unnecessary exploration

```python
for choice in choices:
    # PRUNING: Check constraints before exploring
    if not is_valid(choice):
        continue  # Skip this entire branch!
    
    # Only explore if potentially valid
    make_choice()
    backtrack()
    undo_choice()
```

**Impact:**
```
Without pruning:
- Explores all 2^n paths
- Time: Exponential

With pruning:
- Skips invalid branches early
- Time: Still exponential but much faster in practice
- Can reduce from millions to thousands of checks
```

### 4. Common Patterns

| Pattern | Use Case | Template |
|---------|----------|----------|
| **Permutations** | All arrangements | Use visited array |
| **Combinations** | Selections (order doesn't matter) | Use start index |
| **Partitioning** | Split into groups | Try all split points |
| **Path finding** | Navigate grid/graph | Mark visited, 4/8 directions |
| **Constraint satisfaction** | N-Queens, Sudoku | Check constraints before placing |

---

## Practice Problems

### Easy
1. Generate all permutations of string
2. Find all subsets of array
3. Combination sum (target sum)
4. Letter combinations of phone number
5. Palindrome partitioning

### Medium
6. N-Queens (all solutions)
7. Sudoku solver
8. Word search in grid
9. Restore IP addresses
10. Generate parentheses

### Hard
11. N-Queens optimized
12. Word search II (with Trie)
13. Sudoku solver optimized
14. Expression add operators
15. Remove invalid parentheses

### Challenge
16. Knight's tour
17. Hamiltonian path
18. Graph coloring
19. Crossword puzzle solver
20. Cryptarithmetic puzzles

---

## Debugging Backtracking

### Common Issues

1. **Not copying result**
```python
# Wrong
result.append(path)  # Stores reference!

# Right
result.append(path[:])  # Stores copy
result.append(list(path))  # Also works
```

2. **Forgetting to backtrack**
```python
# Check: Every "choose" must have "unchoose"
visited[i] = True  # Choose
backtrack()
visited[i] = False  # Unchoose (must have!)
```

3. **Wrong pruning condition**
```python
# Wrong: Too aggressive pruning
if sum(path) >= target:  # Might skip valid solutions
    return

# Right: Prune only when definitely invalid
if sum(path) > target:  # Still allow equality
    return
```

### Visualization Technique

Add print statements to visualize:
```python
def backtrack(depth, path):
    indent = "  " * depth
    print(f"{indent}Exploring: {path}")
    
    if is_solution(path):
        print(f"{indent}âœ“ Solution found!")
        return
    
    for choice in choices:
        print(f"{indent}Trying: {choice}")
        path.append(choice)
        backtrack(depth + 1, path)
        path.pop()
        print(f"{indent}Backtracked from: {choice}")
```

Master backtracking, and you'll solve dozens of complex problems systematically! ðŸŽ¯
