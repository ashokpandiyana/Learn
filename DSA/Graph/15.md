# Chapter 15: Essential Graph Patterns for Interviews
## Master Templates and Problem-Solving Strategies

---

## 15.1 Pattern Recognition Framework

### How to Identify Graph Problems

```
┌─────────────────────────────────────────────────────────────────┐
│ IS THIS A GRAPH PROBLEM?                                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│ Look for these keywords:                                        │
│ ✓ "Connected", "reachable", "path"                             │
│ ✓ "Network", "relationships", "dependencies"                    │
│ ✓ "Grid", "matrix", "board"                                    │
│ ✓ "States", "transitions", "transformations"                    │
│ ✓ "Minimum steps", "shortest path", "fewest moves"             │
│ ✓ "Groups", "clusters", "components"                           │
│ ✓ "Order", "sequence", "prerequisites"                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Algorithm Selection Flowchart

```
                         START
                           │
                           ▼
              ┌─── Is it a graph? ───┐
              │                      │
             YES                     NO
              │                   (Not covered)
              ▼
    ┌─── Shortest path? ───┐
    │                      │
   YES                     NO
    │                      │
    ▼                      ▼
Unweighted?        ┌─── Ordering/Dependencies? ───┐
    │              │                              │
  ┌─┴─┐           YES                            NO
 YES  NO           │                              │
  │    │           ▼                              ▼
 BFS   │    Topological Sort         ┌─── Connectivity? ───┐
       │                             │                     │
       ▼                            YES                    NO
  Negative edges?                    │                     │
       │                             ▼                     ▼
    ┌──┴──┐               Dynamic updates?         Explore all?
   YES    NO                    │                        │
    │      │              ┌─────┴─────┐            ┌─────┴─────┐
    ▼      ▼             YES         NO           YES         NO
Bellman  Dijkstra         │           │            │           │
-Ford                     ▼           ▼            ▼           ▼
                    Union-Find    BFS/DFS        DFS     Other pattern
```

---

## 15.2 Pattern 1: Grid as Graph

### Concept

Treat a 2D grid as an implicit graph:
- Each cell is a vertex
- Adjacent cells are connected by edges

```
Grid:                    Implicit Graph:
┌───┬───┬───┐           (0,0)──(0,1)──(0,2)
│ . │ . │ # │             │      │      │
├───┼───┼───┤             │      │      │
│ . │ # │ . │           (1,0)──(1,1)  (1,2)
├───┼───┼───┤             │             │
│ . │ . │ . │           (2,0)──(2,1)──(2,2)
└───┴───┴───┘

# = obstacle (no vertex/edges)
```

### Template

```python
from collections import deque

def grid_bfs(grid, start, end):
    """
    BFS on grid - finds shortest path
    """
    rows, cols = len(grid), len(grid[0])
    
    # 4-directional movement
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    # 8-directional (if diagonals allowed)
    # directions = [(0,1), (0,-1), (1,0), (-1,0), 
    #               (1,1), (1,-1), (-1,1), (-1,-1)]
    
    visited = set()
    visited.add(start)
    queue = deque([(start[0], start[1], 0)])  # (row, col, distance)
    
    while queue:
        row, col, dist = queue.popleft()
        
        if (row, col) == end:
            return dist
        
        for dr, dc in directions:
            nr, nc = row + dr, col + dc
            
            # Check bounds
            if 0 <= nr < rows and 0 <= nc < cols:
                # Check if valid and not visited
                if (nr, nc) not in visited and grid[nr][nc] != '#':
                    visited.add((nr, nc))
                    queue.append((nr, nc, dist + 1))
    
    return -1  # No path found


# Example: Shortest path in binary matrix
grid = [
    ['.', '.', '#'],
    ['.', '#', '.'],
    ['.', '.', '.']
]
print(grid_bfs(grid, (0, 0), (2, 2)))  # 4
```

### Common Grid Problems

| Problem | Approach |
|---------|----------|
| Number of Islands | DFS/BFS from each unvisited land |
| Shortest Path in Binary Matrix | BFS (8-directional) |
| Rotting Oranges | Multi-source BFS |
| Walls and Gates | Multi-source BFS from gates |
| Pacific Atlantic Water Flow | DFS/BFS from ocean borders |
| Surrounded Regions | DFS from border O's |

---

## 15.3 Pattern 2: State Space Graph

### Concept

When the problem involves **states and transitions**, model each state as a vertex and valid transitions as edges.

```
Example: Word Ladder
States: Words
Transitions: Change one letter

State Graph:
    "hit" ──→ "hot" ──→ "dot" ──→ "dog" ──→ "cog"
                │                    │
                └──→ "lot" ──→ "log" ┘

Shortest path in state space = minimum transformations!
```

### Template

```python
from collections import deque

def state_space_bfs(start_state, is_goal, get_neighbors):
    """
    Generic BFS on state space
    
    Args:
        start_state: Initial state (must be hashable)
        is_goal: Function to check if state is goal
        get_neighbors: Function to get valid next states
    
    Returns:
        Minimum steps to reach goal, or -1
    """
    if is_goal(start_state):
        return 0
    
    visited = set()
    visited.add(start_state)
    queue = deque([(start_state, 0)])
    
    while queue:
        state, steps = queue.popleft()
        
        for next_state in get_neighbors(state):
            if next_state not in visited:
                if is_goal(next_state):
                    return steps + 1
                
                visited.add(next_state)
                queue.append((next_state, steps + 1))
    
    return -1
```

### Example: Open the Lock (LeetCode 752)

```python
def openLock(deadends, target):
    """
    Find minimum moves to reach target from "0000"
    Each move: turn one wheel up or down
    """
    dead_set = set(deadends)
    
    if "0000" in dead_set:
        return -1
    
    def get_neighbors(state):
        neighbors = []
        for i in range(4):
            digit = int(state[i])
            
            # Turn up
            up = (digit + 1) % 10
            neighbors.append(state[:i] + str(up) + state[i+1:])
            
            # Turn down
            down = (digit - 1) % 10
            neighbors.append(state[:i] + str(down) + state[i+1:])
        
        return [n for n in neighbors if n not in dead_set]
    
    return state_space_bfs(
        "0000",
        lambda s: s == target,
        get_neighbors
    )
```

### Example: Sliding Puzzle (LeetCode 773)

```python
def slidingPuzzle(board):
    """
    Solve 2x3 sliding puzzle
    State: tuple of board configuration
    """
    # Convert to tuple for hashing
    start = tuple(board[0] + board[1])
    goal = (1, 2, 3, 4, 5, 0)
    
    # Valid moves for each position of 0
    moves = {
        0: [1, 3],
        1: [0, 2, 4],
        2: [1, 5],
        3: [0, 4],
        4: [1, 3, 5],
        5: [2, 4]
    }
    
    def get_neighbors(state):
        state = list(state)
        zero_idx = state.index(0)
        neighbors = []
        
        for swap_idx in moves[zero_idx]:
            new_state = state.copy()
            new_state[zero_idx], new_state[swap_idx] = \
                new_state[swap_idx], new_state[zero_idx]
            neighbors.append(tuple(new_state))
        
        return neighbors
    
    return state_space_bfs(start, lambda s: s == goal, get_neighbors)
```

---

## 15.4 Pattern 3: Multi-Source BFS

### Concept

Start BFS from **multiple sources simultaneously**. All sources begin at level 0.

```
Traditional BFS:          Multi-Source BFS:
Single starting point     Multiple starting points

    ○                         ●     ●
    │                        / \   / \
    ●                       ○   ○ ○   ○
   / \                        \ │ │ /
  ○   ○                        ○ ○ ○

Expands from ONE point    Expands from ALL sources at once
```

### Template

```python
from collections import deque

def multi_source_bfs(grid, sources):
    """
    BFS from multiple sources simultaneously
    Returns distance from nearest source to each cell
    """
    rows, cols = len(grid), len(grid[0])
    distance = [[float('inf')] * cols for _ in range(rows)]
    queue = deque()
    
    # Initialize all sources at distance 0
    for r, c in sources:
        distance[r][c] = 0
        queue.append((r, c))
    
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    while queue:
        r, c = queue.popleft()
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            if 0 <= nr < rows and 0 <= nc < cols:
                if distance[nr][nc] > distance[r][c] + 1:
                    distance[nr][nc] = distance[r][c] + 1
                    queue.append((nr, nc))
    
    return distance
```

### Example: Rotting Oranges (LeetCode 994)

```python
def orangesRotting(grid):
    """
    Multi-source BFS from all rotten oranges
    """
    rows, cols = len(grid), len(grid[0])
    queue = deque()
    fresh = 0
    
    # Find all rotten oranges (sources) and count fresh
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:
                queue.append((r, c, 0))  # (row, col, time)
            elif grid[r][c] == 1:
                fresh += 1
    
    if fresh == 0:
        return 0
    
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    max_time = 0
    
    while queue:
        r, c, time = queue.popleft()
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            if 0 <= nr < rows and 0 <= nc < cols:
                if grid[nr][nc] == 1:  # Fresh orange
                    grid[nr][nc] = 2    # Becomes rotten
                    fresh -= 1
                    max_time = time + 1
                    queue.append((nr, nc, time + 1))
    
    return max_time if fresh == 0 else -1
```

### Example: 01 Matrix (LeetCode 542)

```python
def updateMatrix(mat):
    """
    Find distance to nearest 0 for each cell
    Multi-source BFS from all 0s
    """
    rows, cols = len(mat), len(mat[0])
    dist = [[float('inf')] * cols for _ in range(rows)]
    queue = deque()
    
    # All 0s are sources
    for r in range(rows):
        for c in range(cols):
            if mat[r][c] == 0:
                dist[r][c] = 0
                queue.append((r, c))
    
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    while queue:
        r, c = queue.popleft()
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            if 0 <= nr < rows and 0 <= nc < cols:
                if dist[nr][nc] > dist[r][c] + 1:
                    dist[nr][nc] = dist[r][c] + 1
                    queue.append((nr, nc))
    
    return dist
```

---

## 15.5 Pattern 4: Bidirectional BFS

### Concept

Search from **both source and destination** simultaneously. Stop when they meet.

```
Traditional BFS:              Bidirectional BFS:
      ○                           ○───────●
     /│\                         /│\     /│\
    ○ ○ ○                       ○ ○ ○   ○ ○ ○
   /│ │ │\                       \ │   │ /
  ○ ○ ○ ○ ○                       ○ ○ ○ ○
  │ │ │ │ │                        │ │ │
  ○ ○ ○ ○ ○                        meets!
  
Explores ALL levels           Explores HALF depth from each side
from source to dest           Much fewer nodes!
```

### Why It's Faster

```
If branching factor = b and distance = d:

Traditional BFS: O(b^d) nodes
Bidirectional:   O(2 × b^(d/2)) = O(b^(d/2)) nodes

Example: b=10, d=10
Traditional: 10^10 = 10 billion nodes
Bidirectional: 2 × 10^5 = 200,000 nodes

Huge improvement!
```

### Template

```python
def bidirectional_bfs(start, end, get_neighbors):
    """
    Bidirectional BFS - meet in the middle
    """
    if start == end:
        return 0
    
    # Two frontiers
    front_start = {start}
    front_end = {end}
    
    visited_start = {start}
    visited_end = {end}
    
    level = 0
    
    while front_start and front_end:
        level += 1
        
        # Always expand the smaller frontier (optimization)
        if len(front_start) > len(front_end):
            front_start, front_end = front_end, front_start
            visited_start, visited_end = visited_end, visited_start
        
        next_front = set()
        
        for state in front_start:
            for neighbor in get_neighbors(state):
                # Check if we met the other side
                if neighbor in visited_end:
                    return level
                
                if neighbor not in visited_start:
                    visited_start.add(neighbor)
                    next_front.add(neighbor)
        
        front_start = next_front
    
    return -1  # No path
```

### Example: Word Ladder with Bidirectional BFS

```python
def ladderLength(beginWord, endWord, wordList):
    """
    Word Ladder with bidirectional BFS
    """
    word_set = set(wordList)
    
    if endWord not in word_set:
        return 0
    
    def get_neighbors(word):
        neighbors = []
        for i in range(len(word)):
            for c in 'abcdefghijklmnopqrstuvwxyz':
                if c != word[i]:
                    new_word = word[:i] + c + word[i+1:]
                    if new_word in word_set:
                        neighbors.append(new_word)
        return neighbors
    
    # Bidirectional BFS
    front = {beginWord}
    back = {endWord}
    visited = {beginWord, endWord}
    length = 1
    
    while front and back:
        length += 1
        
        # Expand smaller set
        if len(front) > len(back):
            front, back = back, front
        
        next_front = set()
        
        for word in front:
            for neighbor in get_neighbors(word):
                if neighbor in back:
                    return length
                
                if neighbor not in visited:
                    visited.add(neighbor)
                    next_front.add(neighbor)
        
        front = next_front
    
    return 0
```

---

## 15.6 Pattern 5: Dijkstra Variants

### Variant A: Dijkstra with State

Sometimes you need to track additional state beyond just the vertex.

```python
import heapq

def dijkstra_with_state(graph, start, end, initial_state):
    """
    Dijkstra where state = (vertex, additional_info)
    """
    # dist[(vertex, state)] = minimum distance
    dist = {}
    dist[(start, initial_state)] = 0
    
    # Priority queue: (distance, vertex, state)
    pq = [(0, start, initial_state)]
    
    while pq:
        d, u, state = heapq.heappop(pq)
        
        if u == end:
            return d
        
        if d > dist.get((u, state), float('inf')):
            continue
        
        for v, weight, new_state in get_transitions(u, state, graph):
            new_dist = d + weight
            
            if new_dist < dist.get((v, new_state), float('inf')):
                dist[(v, new_state)] = new_dist
                heapq.heappush(pq, (new_dist, v, new_state))
    
    return -1
```

### Example: Cheapest Flights Within K Stops (LeetCode 787)

```python
def findCheapestPrice(n, flights, src, dst, k):
    """
    State = (city, stops_used)
    """
    graph = defaultdict(list)
    for u, v, price in flights:
        graph[u].append((v, price))
    
    # dist[(city, stops)] = minimum cost
    dist = {}
    dist[(src, 0)] = 0
    
    pq = [(0, src, 0)]  # (cost, city, stops)
    
    while pq:
        cost, city, stops = heapq.heappop(pq)
        
        if city == dst:
            return cost
        
        if stops > k:
            continue
        
        if cost > dist.get((city, stops), float('inf')):
            continue
        
        for next_city, price in graph[city]:
            new_cost = cost + price
            new_stops = stops + 1
            
            if new_cost < dist.get((next_city, new_stops), float('inf')):
                dist[(next_city, new_stops)] = new_cost
                heapq.heappush(pq, (new_cost, next_city, new_stops))
    
    return -1
```

### Variant B: Modified Priority (Max/Min/Product)

```python
def dijkstra_max_probability(graph, start, end):
    """
    Maximize product of probabilities (instead of minimize sum)
    
    Trick: Use max-heap (negate values) or track max probability
    """
    prob = defaultdict(float)
    prob[start] = 1.0
    
    pq = [(-1.0, start)]  # Negate for max-heap
    
    while pq:
        p, u = heapq.heappop(pq)
        p = -p
        
        if u == end:
            return p
        
        if p < prob[u]:
            continue
        
        for v, edge_prob in graph[u]:
            new_prob = p * edge_prob
            
            if new_prob > prob[v]:
                prob[v] = new_prob
                heapq.heappush(pq, (-new_prob, v))
    
    return 0.0
```

---

## 15.7 Pattern 6: Topological Sort + DP

### Concept

For DAG problems, process vertices in topological order and use dynamic programming.

```
DAG Property:
If we process vertices in topological order,
when we reach vertex v, all its predecessors are already processed!

This allows DP: dp[v] = f(dp[predecessors of v])
```

### Template

```python
def dag_dp(graph, n):
    """
    DP on DAG using topological sort
    Example: Longest path in DAG
    """
    # Get topological order
    in_degree = [0] * n
    for u in range(n):
        for v in graph[u]:
            in_degree[v] += 1
    
    queue = deque([i for i in range(n) if in_degree[i] == 0])
    topo_order = []
    
    while queue:
        u = queue.popleft()
        topo_order.append(u)
        for v in graph[u]:
            in_degree[v] -= 1
            if in_degree[v] == 0:
                queue.append(v)
    
    # DP in topological order
    dp = [0] * n  # dp[v] = longest path ending at v
    
    for u in topo_order:
        for v in graph[u]:
            dp[v] = max(dp[v], dp[u] + 1)
    
    return max(dp)
```

### Example: Longest Increasing Path in Matrix (LeetCode 329)

```python
def longestIncreasingPath(matrix):
    """
    Treat as DAG where edge exists if cell value increases
    """
    rows, cols = len(matrix), len(matrix[0])
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    # Memoization (DFS with cache)
    memo = {}
    
    def dfs(r, c):
        if (r, c) in memo:
            return memo[(r, c)]
        
        longest = 1
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            if 0 <= nr < rows and 0 <= nc < cols:
                if matrix[nr][nc] > matrix[r][c]:
                    longest = max(longest, 1 + dfs(nr, nc))
        
        memo[(r, c)] = longest
        return longest
    
    result = 0
    for r in range(rows):
        for c in range(cols):
            result = max(result, dfs(r, c))
    
    return result
```

---

## 15.8 Pattern 7: Graph Coloring / Bipartition

### When to Use

- Grouping into 2 categories
- Scheduling without conflicts
- Checking if structure is possible

### Template

```python
def can_bipartition(n, edges):
    """
    Check if vertices can be split into two groups
    where no edge connects same-group vertices
    """
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    color = {}
    
    def dfs(node, c):
        color[node] = c
        
        for neighbor in graph[node]:
            if neighbor in color:
                if color[neighbor] == c:
                    return False
            else:
                if not dfs(neighbor, 1 - c):
                    return False
        
        return True
    
    for i in range(n):
        if i not in color:
            if not dfs(i, 0):
                return False
    
    return True
```

---

## 15.9 Pattern 8: Union-Find for Dynamic Connectivity

### When to Use

- Checking connectivity with updates
- Counting components dynamically
- Finding redundant connections (cycles)

### Template

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.components = n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1
        self.components -= 1
        return True

# Usage: Adding edges one by one, track connectivity
uf = UnionFind(n)
for u, v in edges:
    if not uf.union(u, v):
        print(f"Edge {u}-{v} creates cycle!")
```

---

## 15.10 Quick Reference: Problem Type → Pattern

```
┌─────────────────────────────────────────────────────────────────┐
│ PROBLEM TYPE                    →  PATTERN/ALGORITHM            │
├─────────────────────────────────────────────────────────────────┤
│ Shortest path (unweighted)      →  BFS                          │
│ Shortest path (weighted)        →  Dijkstra                     │
│ Shortest path (negative)        →  Bellman-Ford                 │
│ All-pairs shortest              →  Floyd-Warshall               │
│                                                                 │
│ Dependencies/ordering           →  Topological Sort             │
│ Cycle detection (directed)      →  DFS with colors              │
│ Cycle detection (undirected)    →  Union-Find or DFS            │
│                                                                 │
│ Connected components (static)   →  BFS/DFS                      │
│ Connected components (dynamic)  →  Union-Find                   │
│ Minimum spanning tree          →  Kruskal's / Prim's           │
│                                                                 │
│ Grid traversal                  →  BFS/DFS on grid              │
│ State transformations           →  State Space BFS              │
│ Two-way search                  →  Bidirectional BFS            │
│ Multiple starting points        →  Multi-source BFS             │
│                                                                 │
│ Two-group division             →  Bipartite Check              │
│ Matching problems              →  Max Matching / Max Flow       │
│ Bottleneck problems            →  Max Flow / Min Cut            │
│                                                                 │
│ Longest path in DAG            →  Topological Sort + DP         │
│ Path with constraints          →  Dijkstra with state           │
└─────────────────────────────────────────────────────────────────┘
```

---

## 15.11 Interview Tips

### Before Coding

```
1. IDENTIFY the graph structure
   - What are vertices?
   - What are edges?
   - Directed or undirected?
   - Weighted or unweighted?

2. RECOGNIZE the problem type
   - Shortest path?
   - Connectivity?
   - Ordering?
   - Optimization?

3. SELECT the algorithm
   - Use the flowchart/table above
   - Consider constraints (graph size, weights)

4. PLAN the implementation
   - Choose representation (adj list vs matrix)
   - Handle edge cases (disconnected, cycles)
```

### Common Mistakes to Avoid

```
❌ Forgetting to mark visited BEFORE adding to queue
❌ Using Dijkstra with negative weights
❌ Wrong cycle detection for directed vs undirected
❌ Not handling disconnected components
❌ Integer overflow with path sums
❌ Using DFS for shortest path (use BFS!)
```

### Complexity Quick Check

```
Most graph algorithms: O(V + E)
- BFS, DFS, Topological Sort, Union-Find

Shortest path with weights: O((V + E) log V)
- Dijkstra with priority queue

All-pairs: O(V³)
- Floyd-Warshall

MST: O(E log E)
- Kruskal's
```

---

## 15.12 Practice Problems by Pattern

### Grid Problems
- Number of Islands (LC 200)
- Shortest Path in Binary Matrix (LC 1091)
- Rotting Oranges (LC 994)
- Pacific Atlantic Water Flow (LC 417)

### State Space Problems
- Word Ladder (LC 127)
- Open the Lock (LC 752)
- Sliding Puzzle (LC 773)
- Minimum Knight Moves (LC 1197)

### Shortest Path Problems
- Network Delay Time (LC 743)
- Cheapest Flights Within K Stops (LC 787)
- Path with Maximum Probability (LC 1514)

### Topological Sort Problems
- Course Schedule I & II (LC 207, 210)
- Alien Dictionary (LC 269)
- Parallel Courses (LC 1136)

### Union-Find Problems
- Number of Provinces (LC 547)
- Redundant Connection (LC 684)
- Accounts Merge (LC 721)

### Bipartite/Matching
- Is Graph Bipartite? (LC 785)
- Possible Bipartition (LC 886)
