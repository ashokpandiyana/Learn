# Chapter 4: Depth-First Search (DFS)
## Exploring the Depths of Graph Traversal

---

## 4.1 What is DFS?

### Concept

**Depth-First Search (DFS)** explores a graph by going as **deep as possible** along each branch before backtracking. It's like exploring a maze by following one path until you hit a dead end, then backtracking.

```
DFS Philosophy: "Go deep, then backtrack"

Starting from vertex 0:

Step 1:     Step 2:     Step 3:     Step 4:     Step 5:
   (0)         (0)         (0)         (0)         (0)
   â†“           â†“           â†“           â†“           â†“
  (1)         (1)         (1)         (1)         (1)
              â†“           â†“           â†“           â†“
             (3)         (3)         (3)â†â”€â”€â”     (3)
                         â†“           â†“     â”‚      â†“
                        (4)         (4)    â”‚     (4)
                                   dead   back   
                                   end!   track!

Go: 0â†’1â†’3â†’4 (dead end) â†’ backtrack â†’ explore other branches
```

### Visual: DFS vs BFS Comparison

```
Same Graph:
        (0)
       /   \
     (1)   (2)
     / \     \
   (3) (4)   (5)

BFS Order: 0 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
           (level by level, wide)

DFS Order: 0 â†’ 1 â†’ 3 â†’ 4 â†’ 2 â†’ 5
           (branch by branch, deep)
```

---

## 4.2 Core DFS Algorithm

### The Key Concept: Recursion or Stack

DFS naturally uses a **stack** (Last-In-First-Out):
- Recursion uses the **call stack** implicitly
- Iterative DFS uses an **explicit stack**

```
Stack behavior:
[1, 2, 3]  â†’  push(4)  â†’  [1, 2, 3, 4]  â†’  pop()  â†’  [1, 2, 3]
                                              â†“
                                           returns 4

Last In = First Out
Most recently discovered vertex is explored first â†’ Deep exploration!
```

### Recursive DFS (Most Common)

```python
def dfs_recursive(graph, start):
    """
    Basic recursive DFS traversal
    Returns: list of vertices in DFS order
    """
    visited = set()
    result = []
    
    def dfs(node):
        # Mark as visited
        visited.add(node)
        result.append(node)
        
        # Explore all unvisited neighbors
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)
    
    dfs(start)
    return result

# Example
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 5],
    3: [1],
    4: [1],
    5: [2]
}

print(dfs_recursive(graph, 0))  # [0, 1, 3, 4, 2, 5]
```

### Step-by-Step Recursive Execution

```
Graph:
    (0)
   /   \
 (1)   (2)
 / \     \
(3)(4)   (5)

Call Stack Visualization:

dfs(0) â†’ visited={0}
  â”‚
  â”œâ”€â†’ dfs(1) â†’ visited={0,1}
  â”‚     â”‚
  â”‚     â”œâ”€â†’ dfs(3) â†’ visited={0,1,3}
  â”‚     â”‚     â””â”€â†’ return (no unvisited neighbors)
  â”‚     â”‚
  â”‚     â””â”€â†’ dfs(4) â†’ visited={0,1,3,4}
  â”‚           â””â”€â†’ return
  â”‚     
  â””â”€â†’ dfs(2) â†’ visited={0,1,3,4,2}
        â”‚
        â””â”€â†’ dfs(5) â†’ visited={0,1,3,4,2,5}
              â””â”€â†’ return

DFS Order: 0 â†’ 1 â†’ 3 â†’ 4 â†’ 2 â†’ 5
```

### Iterative DFS (Using Explicit Stack)

```python
def dfs_iterative(graph, start):
    """
    Iterative DFS using explicit stack
    Returns: list of vertices in DFS order
    """
    visited = set()
    stack = [start]
    result = []
    
    while stack:
        node = stack.pop()
        
        if node not in visited:
            visited.add(node)
            result.append(node)
            
            # Add neighbors to stack (reverse for same order as recursive)
            for neighbor in reversed(graph[node]):
                if neighbor not in visited:
                    stack.append(neighbor)
    
    return result

# Example
print(dfs_iterative(graph, 0))  # [0, 1, 3, 4, 2, 5]
```

### Iterative Step-by-Step

```
Step 1: stack=[0], visited={}
        pop 0 â†’ visited={0}, result=[0]
        push neighbors [2,1] â†’ stack=[2,1]

Step 2: stack=[2,1], visited={0}
        pop 1 â†’ visited={0,1}, result=[0,1]
        push neighbors [4,3] â†’ stack=[2,4,3]

Step 3: stack=[2,4,3], visited={0,1}
        pop 3 â†’ visited={0,1,3}, result=[0,1,3]
        no new neighbors â†’ stack=[2,4]

Step 4: stack=[2,4], visited={0,1,3}
        pop 4 â†’ visited={0,1,3,4}, result=[0,1,3,4]
        no new neighbors â†’ stack=[2]

Step 5: stack=[2], visited={0,1,3,4}
        pop 2 â†’ visited={0,1,3,4,2}, result=[0,1,3,4,2]
        push neighbor [5] â†’ stack=[5]

Step 6: stack=[5], visited={0,1,3,4,2}
        pop 5 â†’ visited={0,1,3,4,2,5}, result=[0,1,3,4,2,5]
        stack=[] â†’ DONE!
```

> âš ï¸ **NOTE**: Iterative DFS may produce different order than recursive depending on how neighbors are added. Use `reversed()` to match recursive order.

---

## 4.3 Time and Space Complexity

### Analysis

```
DFS visits each vertex exactly once: O(V)
DFS examines each edge exactly once: O(E)

Total Time: O(V + E)
```

### Space Complexity

```
Recursive DFS:
- visited set: O(V)
- call stack: O(H) where H = maximum depth
- Worst case (linear graph): O(V)

    (0)â†’(1)â†’(2)â†’(3)â†’(4)  â† Call stack depth = V
    
- Best case (star graph): O(1)

        (1)
         |
    (2)-(0)-(3)  â† Call stack depth = 1
         |
        (4)

Iterative DFS:
- visited set: O(V)
- explicit stack: O(V) worst case

Total Space: O(V)
```

### Complexity Summary

| Aspect | Complexity |
|--------|------------|
| Time | O(V + E) |
| Space (recursive) | O(V) worst, O(H) typical |
| Space (iterative) | O(V) |

---

## 4.4 DFS Edge Classification

In directed graphs, DFS classifies edges into four types. This is **crucial** for understanding cycle detection and other algorithms.

### The Four Edge Types

```
During DFS, we assign discovery time (when first visited) 
and finish time (when all descendants processed)

Edge (u â†’ v) classification:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Edge Type    â”‚ Condition                â”‚ Meaning           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Tree Edge    â”‚ v not yet discovered     â”‚ Part of DFS tree  â”‚
â”‚ Back Edge    â”‚ v is ancestor of u       â”‚ Points backward   â”‚
â”‚ Forward Edge â”‚ v is descendant of u     â”‚ Skips down tree   â”‚
â”‚ Cross Edge   â”‚ v in different subtree   â”‚ Crosses branches  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Visual Example

```
Directed Graph:
    (A) â”€â”€â†’ (B) â”€â”€â†’ (C)
     â”‚       â”‚       â”‚
     â”‚       â”‚       â†“
     â†“       â””â”€â”€â”€â”€â”€â†’(D)
    (E) â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

DFS from A (discovery/finish times):
A(1/10) â†’ B(2/7) â†’ C(3/6) â†’ D(4/5)
    â†“
   E(8/9)

Edge Classification:
Aâ†’B: Tree Edge (B discovered from A)
Bâ†’C: Tree Edge
Câ†’D: Tree Edge
Bâ†’D: Forward Edge (D is descendant of B, but not via Bâ†’D)
Dâ†’E: Cross Edge (E is in different subtree)
Eâ†’A: Back Edge (A is ancestor of E) â† INDICATES CYCLE!
```

### Implementation with Edge Classification

```python
def dfs_classify_edges(graph, n):
    """
    Classify all edges in a directed graph
    Returns: dictionary of edge types
    """
    WHITE, GRAY, BLACK = 0, 1, 2  # Unvisited, In-progress, Completed
    color = [WHITE] * n
    discovery = [0] * n
    finish = [0] * n
    time = [0]  # Using list for mutability in nested function
    
    edge_types = {
        'tree': [],
        'back': [],
        'forward': [],
        'cross': []
    }
    
    def dfs(u):
        color[u] = GRAY  # Mark as in-progress
        time[0] += 1
        discovery[u] = time[0]
        
        for v in graph[u]:
            if color[v] == WHITE:
                # Tree edge: v not yet discovered
                edge_types['tree'].append((u, v))
                dfs(v)
            elif color[v] == GRAY:
                # Back edge: v is still being processed (ancestor)
                edge_types['back'].append((u, v))
            else:  # color[v] == BLACK
                if discovery[u] < discovery[v]:
                    # Forward edge: v discovered after u, already finished
                    edge_types['forward'].append((u, v))
                else:
                    # Cross edge: v in different subtree
                    edge_types['cross'].append((u, v))
        
        color[u] = BLACK  # Mark as completed
        time[0] += 1
        finish[u] = time[0]
    
    for u in range(n):
        if color[u] == WHITE:
            dfs(u)
    
    return edge_types, discovery, finish

# Example
graph = {
    0: [1, 4],  # Aâ†’B, Aâ†’E
    1: [2, 3],  # Bâ†’C, Bâ†’D
    2: [3],     # Câ†’D
    3: [],      # D
    4: []       # E
}
# Convert to list format
graph_list = [graph.get(i, []) for i in range(5)]

edges, disc, fin = dfs_classify_edges(graph_list, 5)
print("Tree edges:", edges['tree'])
print("Back edges:", edges['back'])
print("Forward edges:", edges['forward'])
print("Cross edges:", edges['cross'])
```

> ğŸ”¥ **KEY INSIGHT**: Back edges indicate cycles! If DFS finds a back edge, the graph has a cycle.

---

## 4.5 The Three-Color (Three-State) Pattern

This is the **most important DFS pattern** for interviews. It tracks the state of each vertex during DFS.

### The Three States

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Color  â”‚ State         â”‚ Meaning                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ WHITE  â”‚ Unvisited     â”‚ Not yet discovered        â”‚
â”‚ GRAY   â”‚ In Progress   â”‚ Currently in DFS stack    â”‚
â”‚ BLACK  â”‚ Completed     â”‚ Fully processed           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Visualization

```
DFS Progress:
        WHITE          GRAY           BLACK
         (â—‹)    â†’      (â—)     â†’      (â—)
      Unvisited    Processing     Completed

Graph traversal:
Time 1:  â—â”€â—‹â”€â—‹â”€â—‹    (A being processed)
         A B C D
         
Time 2:  â—â”€â—â”€â—‹â”€â—‹    (A,B being processed - B is descendant of A)
         A B C D
         
Time 3:  â—â”€â—â”€â—â”€â—‹    (A,B,C being processed)
         A B C D
         
Time 4:  â—â”€â—â”€â—â”€â—‹    (C completed, back to B)
         A B C D
         
Time 5:  â—â”€â—â”€â—â”€â—‹    (B completed, back to A)
         A B C D

If we find edge to GRAY vertex â†’ CYCLE (back edge)!
```

### Implementation

```python
def dfs_three_color(graph, n):
    """
    DFS with three-color marking
    Useful for cycle detection in directed graphs
    """
    WHITE, GRAY, BLACK = 0, 1, 2
    color = [WHITE] * n
    
    def dfs(node):
        color[node] = GRAY  # Start processing
        
        for neighbor in graph[node]:
            if color[neighbor] == GRAY:
                # Found back edge - cycle exists!
                return True
            if color[neighbor] == WHITE:
                if dfs(neighbor):
                    return True
        
        color[node] = BLACK  # Finished processing
        return False
    
    # Check all components
    for i in range(n):
        if color[i] == WHITE:
            if dfs(i):
                return True  # Cycle found
    
    return False  # No cycle

# Example: Cycle detection
graph_with_cycle = [[1], [2], [0]]  # 0â†’1â†’2â†’0
graph_no_cycle = [[1], [2], []]     # 0â†’1â†’2

print(dfs_three_color(graph_with_cycle, 3))  # True
print(dfs_three_color(graph_no_cycle, 3))    # False
```

---

## 4.6 Cycle Detection

### Cycle Detection in Undirected Graphs

For undirected graphs, we only need **two states** (visited/not visited) plus **parent tracking**.

```python
def has_cycle_undirected(graph, n):
    """
    Detect cycle in undirected graph
    Key: Track parent to avoid false positive from bidirectional edge
    """
    visited = [False] * n
    
    def dfs(node, parent):
        visited[node] = True
        
        for neighbor in graph[node]:
            if not visited[neighbor]:
                if dfs(neighbor, node):
                    return True
            elif neighbor != parent:
                # Visited and not parent = back edge = cycle!
                return True
        
        return False
    
    # Check all components
    for i in range(n):
        if not visited[i]:
            if dfs(i, -1):
                return True
    
    return False

# Example
#   0 -- 1
#   |    |
#   3 -- 2
graph_undirected = [
    [1, 3],  # 0
    [0, 2],  # 1
    [1, 3],  # 2
    [0, 2]   # 3
]
print(has_cycle_undirected(graph_undirected, 4))  # True (0-1-2-3-0)
```

### Why Parent Tracking?

```
Without parent tracking:
    (0) â”€â”€â”€ (1)
    
DFS from 0: visit 0, then visit 1
At 1: neighbor 0 is visited â†’ FALSE CYCLE DETECTION!

With parent tracking:
At 1: neighbor 0 is visited BUT 0 is parent â†’ NOT a cycle

Real cycle:
    (0) â”€â”€â”€ (1)
     â”‚       â”‚
    (3) â”€â”€â”€ (2)

At 2: neighbor 0 is visited AND 0 is NOT parent â†’ REAL CYCLE!
```

### Cycle Detection in Directed Graphs

For directed graphs, use the **three-color method** (Section 4.5).

```python
def has_cycle_directed(graph, n):
    """
    Detect cycle in directed graph using three colors
    """
    WHITE, GRAY, BLACK = 0, 1, 2
    color = [WHITE] * n
    
    def dfs(node):
        color[node] = GRAY
        
        for neighbor in graph[node]:
            if color[neighbor] == GRAY:
                return True  # Back edge = cycle
            if color[neighbor] == WHITE:
                if dfs(neighbor):
                    return True
        
        color[node] = BLACK
        return False
    
    for i in range(n):
        if color[i] == WHITE:
            if dfs(i):
                return True
    return False
```

### Finding the Actual Cycle

```python
def find_cycle_directed(graph, n):
    """
    Find and return the actual cycle in directed graph
    """
    WHITE, GRAY, BLACK = 0, 1, 2
    color = [WHITE] * n
    parent = [-1] * n
    cycle_start = -1
    cycle_end = -1
    
    def dfs(node):
        nonlocal cycle_start, cycle_end
        color[node] = GRAY
        
        for neighbor in graph[node]:
            if color[neighbor] == GRAY:
                cycle_start = neighbor
                cycle_end = node
                return True
            if color[neighbor] == WHITE:
                parent[neighbor] = node
                if dfs(neighbor):
                    return True
        
        color[node] = BLACK
        return False
    
    for i in range(n):
        if color[i] == WHITE:
            if dfs(i):
                # Reconstruct cycle
                cycle = []
                current = cycle_end
                while current != cycle_start:
                    cycle.append(current)
                    current = parent[current]
                cycle.append(cycle_start)
                cycle.reverse()
                return cycle
    
    return []  # No cycle

# Example
graph = [[1], [2], [3], [1]]  # 0â†’1â†’2â†’3â†’1 (cycle: 1â†’2â†’3â†’1)
print(find_cycle_directed(graph, 4))  # [1, 2, 3]
```

---

## 4.7 DFS on Grids

### Basic Grid DFS

```python
def dfs_grid(grid, start_row, start_col):
    """
    DFS on 2D grid
    """
    if not grid:
        return []
    
    rows, cols = len(grid), len(grid[0])
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    visited = set()
    result = []
    
    def dfs(r, c):
        if (r < 0 or r >= rows or c < 0 or c >= cols or
            (r, c) in visited or grid[r][c] == '#'):
            return
        
        visited.add((r, c))
        result.append((r, c))
        
        for dr, dc in directions:
            dfs(r + dr, c + dc)
    
    dfs(start_row, start_col)
    return result

# Example
grid = [
    ['.', '.', '#'],
    ['.', '.', '.'],
    ['#', '.', '.']
]
print(dfs_grid(grid, 0, 0))
```

### Flood Fill Algorithm

```python
def flood_fill(image, sr, sc, new_color):
    """
    Classic flood fill (like paint bucket tool)
    """
    if not image:
        return image
    
    rows, cols = len(image), len(image[0])
    original_color = image[sr][sc]
    
    if original_color == new_color:
        return image
    
    def dfs(r, c):
        if (r < 0 or r >= rows or c < 0 or c >= cols or
            image[r][c] != original_color):
            return
        
        image[r][c] = new_color
        
        dfs(r + 1, c)
        dfs(r - 1, c)
        dfs(r, c + 1)
        dfs(r, c - 1)
    
    dfs(sr, sc)
    return image

# Example
image = [
    [1, 1, 1],
    [1, 1, 0],
    [1, 0, 1]
]
print(flood_fill(image, 1, 1, 2))
# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]
```

### Number of Islands

```python
def num_islands(grid):
    """
    Count connected components of '1's
    """
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    count = 0
    
    def dfs(r, c):
        if (r < 0 or r >= rows or c < 0 or c >= cols or
            grid[r][c] != '1'):
            return
        
        grid[r][c] = '#'  # Mark as visited
        
        dfs(r + 1, c)
        dfs(r - 1, c)
        dfs(r, c + 1)
        dfs(r, c - 1)
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                dfs(r, c)
                count += 1
    
    return count

# Example
grid = [
    ['1','1','0','0','0'],
    ['1','1','0','0','0'],
    ['0','0','1','0','0'],
    ['0','0','0','1','1']
]
print(num_islands(grid))  # 3
```

---

## 4.8 DFS for Path Finding

### Find All Paths (Backtracking)

```python
def find_all_paths(graph, start, end):
    """
    Find ALL paths from start to end using DFS backtracking
    """
    all_paths = []
    current_path = [start]
    visited = {start}
    
    def dfs(node):
        if node == end:
            all_paths.append(current_path.copy())
            return
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                current_path.append(neighbor)
                
                dfs(neighbor)
                
                # Backtrack
                current_path.pop()
                visited.remove(neighbor)
    
    dfs(start)
    return all_paths

# Example
graph = {
    0: [1, 2],
    1: [3],
    2: [3],
    3: [4],
    4: []
}
print(find_all_paths(graph, 0, 4))
# [[0, 1, 3, 4], [0, 2, 3, 4]]
```

### Path Exists Check

```python
def has_path(graph, start, end):
    """
    Check if path exists from start to end
    """
    visited = set()
    
    def dfs(node):
        if node == end:
            return True
        
        visited.add(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                if dfs(neighbor):
                    return True
        
        return False
    
    return dfs(start)
```

---

## 4.9 Connected Components

### Finding All Connected Components

```python
def find_connected_components(graph, n):
    """
    Find all connected components in undirected graph
    """
    visited = [False] * n
    components = []
    
    def dfs(node, component):
        visited[node] = True
        component.append(node)
        
        for neighbor in graph[node]:
            if not visited[neighbor]:
                dfs(neighbor, component)
    
    for i in range(n):
        if not visited[i]:
            component = []
            dfs(i, component)
            components.append(component)
    
    return components

# Example
# Graph: 0-1-2  3-4  5 (three components)
graph = [
    [1],     # 0
    [0, 2],  # 1
    [1],     # 2
    [4],     # 3
    [3],     # 4
    []       # 5
]
print(find_connected_components(graph, 6))
# [[0, 1, 2], [3, 4], [5]]
```

---

## 4.10 DFS Tree Properties

### Pre-order, Post-order, and In-order

```python
def dfs_with_timestamps(graph, start):
    """
    DFS with pre-order and post-order tracking
    """
    pre_order = []   # When node is first discovered
    post_order = []  # When node is finished (all descendants processed)
    visited = set()
    
    def dfs(node):
        visited.add(node)
        pre_order.append(node)  # Pre-order: before processing children
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)
        
        post_order.append(node)  # Post-order: after processing children
    
    dfs(start)
    return pre_order, post_order

# Example
graph = {
    0: [1, 2],
    1: [3, 4],
    2: [],
    3: [],
    4: []
}
pre, post = dfs_with_timestamps(graph, 0)
print(f"Pre-order: {pre}")   # [0, 1, 3, 4, 2]
print(f"Post-order: {post}") # [3, 4, 1, 2, 0]
```

```
Visualization:
        (0)
       /   \
     (1)   (2)
     / \
   (3) (4)

Pre-order (entry time):  0, 1, 3, 4, 2
Post-order (exit time):  3, 4, 1, 2, 0

Post-order reversed = Topological order (for DAGs)!
```

---

## 4.11 Common Interview Problems

### Problem 1: Clone Graph

```python
def clone_graph(node):
    """
    Deep clone a graph given a reference to one node
    """
    if not node:
        return None
    
    cloned = {}  # Maps original node to its clone
    
    def dfs(original):
        if original in cloned:
            return cloned[original]
        
        # Create clone
        clone = Node(original.val)
        cloned[original] = clone
        
        # Clone neighbors
        for neighbor in original.neighbors:
            clone.neighbors.append(dfs(neighbor))
        
        return clone
    
    return dfs(node)
```

### Problem 2: Course Schedule (Cycle Detection)

```python
def can_finish(numCourses, prerequisites):
    """
    Determine if all courses can be finished (no circular dependency)
    """
    # Build graph
    graph = [[] for _ in range(numCourses)]
    for course, prereq in prerequisites:
        graph[prereq].append(course)
    
    # Three-color cycle detection
    WHITE, GRAY, BLACK = 0, 1, 2
    color = [WHITE] * numCourses
    
    def has_cycle(node):
        color[node] = GRAY
        
        for neighbor in graph[node]:
            if color[neighbor] == GRAY:
                return True
            if color[neighbor] == WHITE and has_cycle(neighbor):
                return True
        
        color[node] = BLACK
        return False
    
    for i in range(numCourses):
        if color[i] == WHITE:
            if has_cycle(i):
                return False
    
    return True
```

### Problem 3: Surrounded Regions

```python
def solve(board):
    """
    Capture all 'O' regions surrounded by 'X'
    Key insight: Only 'O's connected to border survive
    """
    if not board:
        return
    
    rows, cols = len(board), len(board[0])
    
    def dfs(r, c):
        if (r < 0 or r >= rows or c < 0 or c >= cols or
            board[r][c] != 'O'):
            return
        
        board[r][c] = 'S'  # Mark as safe (connected to border)
        dfs(r + 1, c)
        dfs(r - 1, c)
        dfs(r, c + 1)
        dfs(r, c - 1)
    
    # Step 1: Mark all 'O's connected to border as safe
    for r in range(rows):
        dfs(r, 0)
        dfs(r, cols - 1)
    for c in range(cols):
        dfs(0, c)
        dfs(rows - 1, c)
    
    # Step 2: Capture surrounded 'O's, restore safe ones
    for r in range(rows):
        for c in range(cols):
            if board[r][c] == 'O':
                board[r][c] = 'X'  # Captured
            elif board[r][c] == 'S':
                board[r][c] = 'O'  # Restore
```

---

## 4.12 DFS vs BFS Summary

| Aspect | DFS | BFS |
|--------|-----|-----|
| Data Structure | Stack (recursion/explicit) | Queue |
| Space | O(H) height of tree | O(W) width of tree |
| Shortest Path | âœ— No | âœ“ Yes (unweighted) |
| Memory (trees) | Better for deep trees | Better for wide trees |
| Finds | Any path | Shortest path |
| Implementation | Simpler (recursion) | Slightly more code |
| Use Cases | Cycle detection, topological sort, backtracking | Shortest path, level order |

---

## 4.13 Practice Problems

### Easy
1. Flood Fill (LC 733)
2. Max Area of Island (LC 695)
3. Number of Islands (LC 200)

### Medium
1. Clone Graph (LC 133)
2. Course Schedule (LC 207)
3. Course Schedule II (LC 210)
4. Pacific Atlantic Water Flow (LC 417)
5. Surrounded Regions (LC 130)
6. All Paths From Source to Target (LC 797)
7. Keys and Rooms (LC 841)

### Hard
1. Critical Connections in Network (LC 1192)
2. Longest Increasing Path in Matrix (LC 329)
3. Word Search II (LC 212)
4. Reconstruct Itinerary (LC 332)
