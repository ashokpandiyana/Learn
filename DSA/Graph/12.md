# Chapter 12: Bridges and Articulation Points
## Finding Critical Elements in Graphs

---

## 12.1 Definitions

### Bridge (Cut Edge)

A **bridge** is an edge whose removal **disconnects** the graph (or increases the number of connected components).

```
Graph with Bridge:
    (A)───(B)───(C)───(D)
           │
          (E)

Edge B-C is a bridge!
If we remove it:

    (A)───(B)     (C)───(D)
           │
          (E)

Graph becomes disconnected.

Edge A-B is NOT a bridge:
If we remove it, B is still connected via E? No, wait...
Actually A-B IS also a bridge. Let me redo:

Better example:
    (A)───(B)
     │   / │
     │  /  │
    (C)   (D)───(E)
    
Bridge: D-E (removing it disconnects E)
Not bridges: A-B, A-C, B-C (they form a cycle, removing one keeps graph connected)
```

### Articulation Point (Cut Vertex)

An **articulation point** is a vertex whose removal **disconnects** the graph.

```
Graph with Articulation Point:
    (A)───(B)───(C)
           │
          (D)───(E)

Vertex B is an articulation point!
Removing B:
    (A)     (C)
    
    (D)───(E)

Graph splits into multiple components.

Example 2:
      (A)
     / | \
   (B)(C)(D)
   
Vertex A is articulation point.
Removing A disconnects B, C, D from each other.
```

### Visual Summary

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   BRIDGE (Cut Edge)           ARTICULATION POINT (Cut Vertex)   │
│   ─────────────────           ───────────────────────────────   │
│                                                                 │
│   (A)───(B)═══(C)             (A)───(█)───(C)                  │
│         │                           │                           │
│        (D)                         (D)                          │
│                                                                 │
│   Edge B-C is bridge          Vertex █ is articulation point   │
│   (double line)               (filled square)                   │
│                                                                 │
│   Removing it splits          Removing it splits               │
│   graph into pieces           graph into pieces                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 12.2 Applications

```
┌─────────────────────────────────────────────────────────────────┐
│ Real-World Applications                                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│ BRIDGES:                                                        │
│ • Network reliability: Single points of failure in networks    │
│ • Road planning: Critical roads that can't be closed           │
│ • Communication networks: Links that must stay operational     │
│ • Power grid: Transmission lines critical to connectivity      │
│                                                                 │
│ ARTICULATION POINTS:                                           │
│ • Social networks: Key influencers connecting communities      │
│ • Computer networks: Routers whose failure partitions network  │
│ • Biology: Critical proteins in interaction networks           │
│ • Infrastructure: Critical facilities in supply chains         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 12.3 Tarjan's Bridge-Finding Algorithm

### Key Concepts: Discovery Time and Low-Link

```
Discovery Time (disc[u]):
The timestamp when vertex u was first visited during DFS.

Low-Link Value (low[u]):
The minimum discovery time reachable from the subtree rooted at u,
including back edges (but NOT through parent edge for bridges).

An edge (u, v) is a BRIDGE if:
    low[v] > disc[u]

This means: From v's subtree, we CANNOT reach u or any ancestor of u.
So removing edge (u,v) disconnects v's subtree from the rest.
```

### Visual Walkthrough

```
Graph:
    (0)───(1)───(3)
     │   /
     │  /
    (2)       (4)───(5)
               │
              (6)

DFS from 0:

Step 1: Visit 0
    disc[0]=0, low[0]=0
    Stack: [0]

Step 2: Visit 1 (from 0)
    disc[1]=1, low[1]=1
    Stack: [0, 1]

Step 3: Visit 2 (from 1)
    disc[2]=2, low[2]=2
    Stack: [0, 1, 2]

Step 4: At 2, see back edge to 0
    low[2] = min(low[2], disc[0]) = min(2, 0) = 0
    
Step 5: Back to 1
    low[1] = min(low[1], low[2]) = min(1, 0) = 0
    Edge 1-2: low[2]=0 ≤ disc[1]=1 → NOT a bridge ✓

Step 6: Visit 3 (from 1)
    disc[3]=3, low[3]=3
    No more edges from 3.
    
Step 7: Back to 1
    Edge 1-3: low[3]=3 > disc[1]=1 → BRIDGE! ★
    low[1] = min(low[1], low[3]) = min(0, 3) = 0

Step 8: Back to 0
    Edge 0-1: low[1]=0 ≤ disc[0]=0 → NOT a bridge
    low[0] = min(low[0], low[1]) = 0

Continue DFS for disconnected component (4,5,6)...

Bridges found: (1,3), and edges in component 4-5-6 if any
```

### Implementation

```python
def find_bridges(n, edges):
    """
    Find all bridges in an undirected graph using Tarjan's algorithm
    
    Args:
        n: number of vertices
        edges: list of (u, v) edges
    
    Returns:
        List of bridges as (u, v) tuples
    """
    # Build adjacency list
    graph = [[] for _ in range(n)]
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    disc = [-1] * n      # Discovery time
    low = [-1] * n       # Low-link value
    bridges = []
    time = [0]           # Using list for mutability in nested function
    
    def dfs(u, parent):
        disc[u] = low[u] = time[0]
        time[0] += 1
        
        for v in graph[u]:
            if disc[v] == -1:
                # Tree edge - v not yet visited
                dfs(v, u)
                
                # After DFS, update low[u] from child
                low[u] = min(low[u], low[v])
                
                # Check if edge u-v is a bridge
                if low[v] > disc[u]:
                    bridges.append((u, v))
                    
            elif v != parent:
                # Back edge to ancestor (not parent)
                low[u] = min(low[u], disc[v])
    
    # Run DFS from all unvisited vertices (handle disconnected graph)
    for i in range(n):
        if disc[i] == -1:
            dfs(i, -1)
    
    return bridges


# Example
edges = [
    (0, 1), (1, 2), (2, 0),  # Cycle: 0-1-2-0 (no bridges)
    (1, 3),                   # Bridge: 1-3
    (3, 4), (4, 5), (5, 3)   # Cycle: 3-4-5-3 (no bridges)
]
bridges = find_bridges(6, edges)
print(f"Bridges: {bridges}")  # [(1, 3)]
```

### Handling Multiple Edges

```python
def find_bridges_multi_edge(n, edges):
    """
    Handle graphs with multiple edges between same vertices.
    Multiple edges between u and v means u-v is NOT a bridge.
    """
    from collections import defaultdict
    
    # Count edges between each pair
    edge_count = defaultdict(int)
    graph = [[] for _ in range(n)]
    
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
        edge_count[(min(u,v), max(u,v))] += 1
    
    disc = [-1] * n
    low = [-1] * n
    bridges = []
    time = [0]
    
    def dfs(u, parent):
        disc[u] = low[u] = time[0]
        time[0] += 1
        
        for v in graph[u]:
            if disc[v] == -1:
                dfs(v, u)
                low[u] = min(low[u], low[v])
                
                # Only bridge if single edge
                edge_key = (min(u,v), max(u,v))
                if low[v] > disc[u] and edge_count[edge_key] == 1:
                    bridges.append((u, v))
                    
            elif v != parent:
                low[u] = min(low[u], disc[v])
            # If v == parent and multiple edges exist, we can still use one
            # This is handled by edge_count check
    
    for i in range(n):
        if disc[i] == -1:
            dfs(i, -1)
    
    return bridges
```

---

## 12.4 Finding Articulation Points

### The Algorithm

```
A vertex u is an articulation point if:

Case 1: u is the ROOT of DFS tree
    → u is AP if it has 2 or more children
    (Removing root disconnects its children from each other)

Case 2: u is NOT the root
    → u is AP if it has a child v where low[v] >= disc[u]
    (v's subtree cannot reach any ancestor of u)
```

### Visual Explanation

```
Case 1: Root with multiple children

        (A) ← Root, 2 DFS children
       /   \
     (B)   (C)
     /       \
   (D)       (E)

A is articulation point because B and C are separate DFS subtrees.
Removing A disconnects {B,D} from {C,E}.

Case 2: Non-root articulation point

    (A)
     │
    (B) ← low[C] >= disc[B]
     │
    (C)───(D)
     │
    (E)

B is articulation point because:
- C is child of B
- low[C] = disc[C] (C can't reach A or above)
- low[C] >= disc[B]
Removing B disconnects {C,D,E} from {A}.
```

### Implementation

```python
def find_articulation_points(n, edges):
    """
    Find all articulation points in an undirected graph
    
    Args:
        n: number of vertices
        edges: list of (u, v) edges
    
    Returns:
        List of articulation points
    """
    graph = [[] for _ in range(n)]
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    disc = [-1] * n
    low = [-1] * n
    parent = [-1] * n
    is_ap = [False] * n
    time = [0]
    
    def dfs(u):
        children = 0
        disc[u] = low[u] = time[0]
        time[0] += 1
        
        for v in graph[u]:
            if disc[v] == -1:
                # Tree edge
                children += 1
                parent[v] = u
                dfs(v)
                
                low[u] = min(low[u], low[v])
                
                # Case 1: u is root with 2+ children
                if parent[u] == -1 and children > 1:
                    is_ap[u] = True
                
                # Case 2: u is not root and no back edge from v's subtree
                if parent[u] != -1 and low[v] >= disc[u]:
                    is_ap[u] = True
                    
            elif v != parent[u]:
                # Back edge
                low[u] = min(low[u], disc[v])
    
    for i in range(n):
        if disc[i] == -1:
            dfs(i)
    
    return [i for i in range(n) if is_ap[i]]


# Example
edges = [
    (0, 1), (1, 2), (2, 0),  # Cycle
    (1, 3),                   # 1 is AP
    (3, 4)                    # 3 is AP
]
aps = find_articulation_points(5, edges)
print(f"Articulation Points: {aps}")  # [1, 3]
```

### Detailed Walkthrough

```python
def find_articulation_points_verbose(n, edges):
    """
    Verbose version for understanding
    """
    graph = [[] for _ in range(n)]
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    disc = [-1] * n
    low = [-1] * n
    parent = [-1] * n
    is_ap = [False] * n
    time = [0]
    
    def dfs(u, depth=0):
        indent = "  " * depth
        children = 0
        disc[u] = low[u] = time[0]
        time[0] += 1
        
        print(f"{indent}Visit {u}: disc={disc[u]}")
        
        for v in graph[u]:
            if disc[v] == -1:
                children += 1
                parent[v] = u
                print(f"{indent}  Tree edge {u}-{v}")
                dfs(v, depth + 1)
                
                low[u] = min(low[u], low[v])
                print(f"{indent}  Back from {v}: low[{u}]={low[u]}, low[{v}]={low[v]}")
                
                # Check articulation point conditions
                if parent[u] == -1 and children > 1:
                    print(f"{indent}  {u} is AP (root with {children} children)")
                    is_ap[u] = True
                
                if parent[u] != -1 and low[v] >= disc[u]:
                    print(f"{indent}  {u} is AP (low[{v}]={low[v]} >= disc[{u}]={disc[u]})")
                    is_ap[u] = True
                    
            elif v != parent[u]:
                print(f"{indent}  Back edge {u}-{v}")
                low[u] = min(low[u], disc[v])
    
    for i in range(n):
        if disc[i] == -1:
            print(f"Starting DFS from {i}")
            dfs(i)
    
    return [i for i in range(n) if is_ap[i]]


# Test
edges = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4)]
print("Finding Articulation Points:")
aps = find_articulation_points_verbose(5, edges)
print(f"\nArticulation Points: {aps}")
```

---

## 12.5 Complete Combined Implementation

```python
def find_bridges_and_aps(n, edges):
    """
    Find both bridges and articulation points in one DFS
    
    Returns:
        (bridges, articulation_points)
    """
    graph = [[] for _ in range(n)]
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    disc = [-1] * n
    low = [-1] * n
    parent = [-1] * n
    is_ap = [False] * n
    bridges = []
    time = [0]
    
    def dfs(u):
        children = 0
        disc[u] = low[u] = time[0]
        time[0] += 1
        
        for v in graph[u]:
            if disc[v] == -1:
                children += 1
                parent[v] = u
                dfs(v)
                
                low[u] = min(low[u], low[v])
                
                # Bridge condition
                if low[v] > disc[u]:
                    bridges.append((u, v))
                
                # Articulation point conditions
                if parent[u] == -1 and children > 1:
                    is_ap[u] = True
                if parent[u] != -1 and low[v] >= disc[u]:
                    is_ap[u] = True
                    
            elif v != parent[u]:
                low[u] = min(low[u], disc[v])
    
    for i in range(n):
        if disc[i] == -1:
            dfs(i)
    
    articulation_points = [i for i in range(n) if is_ap[i]]
    return bridges, articulation_points


# Example
edges = [
    (0, 1), (1, 2), (2, 3), (3, 0),  # Square (no bridges or APs)
    (2, 4),                           # Bridge: 2-4, AP: 2
    (4, 5), (5, 6), (6, 4)           # Triangle (no bridges)
]

bridges, aps = find_bridges_and_aps(7, edges)
print(f"Bridges: {bridges}")
print(f"Articulation Points: {aps}")
```

---

## 12.6 Edge Cases and Special Scenarios

### Single Node Graph

```python
# No bridges, no articulation points
n = 1
edges = []
# Bridges: [], APs: []
```

### Tree Graph

```python
# Every edge is a bridge
# Every internal node is an articulation point

#     0
#    /|\
#   1 2 3
#   |
#   4

edges = [(0,1), (0,2), (0,3), (1,4)]
# Bridges: all edges
# APs: [0, 1]
```

### Complete Graph

```python
# No bridges, no articulation points
# K4: 0-1, 0-2, 0-3, 1-2, 1-3, 2-3
# Bridges: [], APs: []
```

### Cycle

```python
# No bridges, no articulation points
# Cycle: 0-1-2-3-0
edges = [(0,1), (1,2), (2,3), (3,0)]
# Bridges: [], APs: []
```

---

## 12.7 Interview Problems

### Problem 1: Critical Connections in a Network (LeetCode 1192)

```python
def critical_connections(n, connections):
    """
    LeetCode 1192: Critical Connections in a Network
    Return all bridges (critical connections)
    """
    graph = [[] for _ in range(n)]
    for u, v in connections:
        graph[u].append(v)
        graph[v].append(u)
    
    disc = [-1] * n
    low = [-1] * n
    bridges = []
    time = [0]
    
    def dfs(u, parent):
        disc[u] = low[u] = time[0]
        time[0] += 1
        
        for v in graph[u]:
            if disc[v] == -1:
                dfs(v, u)
                low[u] = min(low[u], low[v])
                if low[v] > disc[u]:
                    bridges.append([u, v])
            elif v != parent:
                low[u] = min(low[u], disc[v])
    
    dfs(0, -1)
    return bridges
```

### Problem 2: Minimum Number of Days to Disconnect Island

```python
def min_days_to_disconnect(grid):
    """
    LeetCode 1568: Minimum Number of Days to Disconnect Island
    
    Key insight:
    - If already disconnected: 0 days
    - If has articulation point: 1 day
    - Otherwise: at most 2 days (remove corner cell and its neighbor)
    """
    rows, cols = len(grid), len(grid[0])
    
    def count_islands():
        """Count number of islands using DFS"""
        visited = [[False] * cols for _ in range(rows)]
        count = 0
        
        def dfs(r, c):
            if r < 0 or r >= rows or c < 0 or c >= cols:
                return
            if visited[r][c] or grid[r][c] == 0:
                return
            visited[r][c] = True
            dfs(r+1, c)
            dfs(r-1, c)
            dfs(r, c+1)
            dfs(r, c-1)
        
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == 1 and not visited[r][c]:
                    dfs(r, c)
                    count += 1
        return count
    
    # Check if already disconnected
    if count_islands() != 1:
        return 0
    
    # Check if removing one cell disconnects
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 1:
                grid[r][c] = 0
                if count_islands() != 1:
                    return 1
                grid[r][c] = 1
    
    # Otherwise, always possible in 2 days
    return 2
```

### Problem 3: Biconnected Components

```python
def find_biconnected_components(n, edges):
    """
    Find all biconnected components (maximal 2-edge-connected subgraphs)
    
    A biconnected component has no articulation points.
    """
    graph = [[] for _ in range(n)]
    for i, (u, v) in enumerate(edges):
        graph[u].append((v, i))
        graph[v].append((u, i))
    
    disc = [-1] * n
    low = [-1] * n
    parent = [-1] * n
    edge_stack = []
    bccs = []  # Biconnected components (lists of edge indices)
    time = [0]
    
    def dfs(u):
        children = 0
        disc[u] = low[u] = time[0]
        time[0] += 1
        
        for v, edge_idx in graph[u]:
            if disc[v] == -1:
                children += 1
                parent[v] = u
                edge_stack.append(edge_idx)
                dfs(v)
                
                low[u] = min(low[u], low[v])
                
                # Check if u is articulation point
                if (parent[u] == -1 and children > 1) or \
                   (parent[u] != -1 and low[v] >= disc[u]):
                    # Pop edges until current edge to form BCC
                    bcc = []
                    while edge_stack and edge_stack[-1] != edge_idx:
                        bcc.append(edge_stack.pop())
                    if edge_stack:
                        bcc.append(edge_stack.pop())
                    bccs.append(bcc)
                    
            elif v != parent[u] and disc[v] < disc[u]:
                edge_stack.append(edge_idx)
                low[u] = min(low[u], disc[v])
    
    for i in range(n):
        if disc[i] == -1:
            dfs(i)
            if edge_stack:
                bccs.append(edge_stack[:])
                edge_stack.clear()
    
    return bccs
```

---

## 12.8 Summary

### Key Formulas

```
BRIDGE (u-v is tree edge, v is child of u):
    low[v] > disc[u]
    (v's subtree cannot reach u or above)

ARTICULATION POINT:
    Case 1 (Root): children > 1
    Case 2 (Non-root): low[v] >= disc[u] for some child v
    
Note the difference:
    Bridge: low[v] > disc[u]   (strictly greater)
    AP:     low[v] >= disc[u]  (greater or equal)
```

### Algorithm Template

```python
def tarjan_bridges_and_aps(n, graph):
    disc = [-1] * n
    low = [-1] * n
    parent = [-1] * n
    is_ap = [False] * n
    bridges = []
    time = [0]
    
    def dfs(u):
        children = 0
        disc[u] = low[u] = time[0]
        time[0] += 1
        
        for v in graph[u]:
            if disc[v] == -1:  # Tree edge
                children += 1
                parent[v] = u
                dfs(v)
                low[u] = min(low[u], low[v])
                
                # Bridge check
                if low[v] > disc[u]:
                    bridges.append((u, v))
                
                # AP check
                if parent[u] == -1 and children > 1:
                    is_ap[u] = True
                if parent[u] != -1 and low[v] >= disc[u]:
                    is_ap[u] = True
                    
            elif v != parent[u]:  # Back edge
                low[u] = min(low[u], disc[v])
    
    for i in range(n):
        if disc[i] == -1:
            dfs(i)
    
    return bridges, [i for i in range(n) if is_ap[i]]
```

### Complexity

```
Time Complexity: O(V + E)
- Single DFS traversal
- Each vertex and edge visited once

Space Complexity: O(V)
- Arrays for disc, low, parent: O(V)
- Recursion stack: O(V) worst case
```

---

## 12.9 Practice Problems

1. Critical Connections in a Network (LC 1192)
2. Minimum Number of Days to Disconnect Island (LC 1568)
3. Number of Operations to Make Network Connected (LC 1319) - Related
4. Biconnected Components (Classic)
5. 2-Edge-Connected Components (Classic)
6. Block-Cut Tree Construction (Advanced)
