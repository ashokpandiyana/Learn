# Chapter 5: Single Source Shortest Path (SSSP)
## Finding Optimal Paths in Weighted Graphs

---

## 5.1 Overview

### The Problem

Given a **weighted graph** and a **source vertex**, find the shortest path from the source to all other vertices.

```
Problem:
         5
    (A)────────(B)
     │  \       │
   2 │   \ 10   │ 3
     │    \     │
    (C)────────(D)
         4

Source: A
Find: Shortest path from A to every other vertex

Answer:
A→A: 0
A→B: 5 (direct)
A→C: 2 (direct)  
A→D: 6 (A→C→D = 2+4)  ← Not A→B→D (5+3=8)!
```

### Algorithm Selection Guide

```
┌─────────────────────────────────────────────────────────────────┐
│ Which Shortest Path Algorithm Should I Use?                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Is the graph unweighted?                                       │
│       │                                                         │
│       ├── YES → Use BFS (Chapter 3)                            │
│       │                                                         │
│       └── NO → Are there negative edges?                        │
│                    │                                            │
│                    ├── NO → Use DIJKSTRA                        │
│                    │                                            │
│                    └── YES → Use BELLMAN-FORD                   │
│                                                                 │
│  Special case: All weights are 0 or 1?                         │
│       → Use 0-1 BFS (fastest!)                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Complexity Comparison

| Algorithm | Time | Space | Negative Edges? | Best For |
|-----------|------|-------|-----------------|----------|
| BFS | O(V+E) | O(V) | N/A (unweighted) | Unweighted |
| Dijkstra | O((V+E)logV) | O(V) | ✗ No | Non-negative weights |
| Bellman-Ford | O(VE) | O(V) | ✓ Yes | Negative edges |
| 0-1 BFS | O(V+E) | O(V) | Only 0/1 | Binary weights |

---

## 5.2 Dijkstra's Algorithm

### Concept

Dijkstra's algorithm uses a **greedy approach**: always process the unvisited vertex with the smallest known distance.

```
Key Insight:
Once we process a vertex, its distance is FINAL (guaranteed shortest).
This only works because all edges are non-negative!

Why?
If all edges ≥ 0, we can't find a shorter path later
through an unprocessed vertex (it would have ≥ current distance).
```

### Visual Walkthrough

```
Graph:
         5
    (A)────────(B)
     │  \       │
   2 │   \ 10   │ 3
     │    \     │
    (C)────────(D)
         4

Step-by-step from source A:

Initial:
dist = {A:0, B:∞, C:∞, D:∞}
pq = [(0,A)]

Step 1: Process A (dist=0)
Update neighbors: B=5, C=2, D=10
dist = {A:0, B:5, C:2, D:10}
pq = [(2,C), (5,B), (10,D)]

Step 2: Process C (dist=2) ← smallest!
Update neighbors: D = min(10, 2+4) = 6
dist = {A:0, B:5, C:2, D:6}
pq = [(5,B), (6,D), (10,D)]  ← old D entry still there

Step 3: Process B (dist=5)
Update neighbors: D = min(6, 5+3) = 6 (no change)
dist = {A:0, B:5, C:2, D:6}
pq = [(6,D), (10,D)]

Step 4: Process D (dist=6)
No unvisited neighbors
pq = [(10,D)]  ← skip (D already processed)

Final: dist = {A:0, B:5, C:2, D:6}
```

### Implementation

```python
import heapq
from collections import defaultdict

def dijkstra(graph, start, n):
    """
    Dijkstra's algorithm for single-source shortest paths
    
    Args:
        graph: adjacency list {node: [(neighbor, weight), ...]}
        start: source vertex
        n: number of vertices (if using 0 to n-1)
    
    Returns:
        dist: dictionary of shortest distances from start
        parent: dictionary to reconstruct paths
    """
    # Initialize distances
    dist = {i: float('inf') for i in range(n)}
    dist[start] = 0
    
    # Parent pointers for path reconstruction
    parent = {start: None}
    
    # Min-heap: (distance, vertex)
    pq = [(0, start)]
    
    # Track processed vertices
    processed = set()
    
    while pq:
        # Get vertex with minimum distance
        d, u = heapq.heappop(pq)
        
        # Skip if already processed (handles duplicate entries)
        if u in processed:
            continue
        processed.add(u)
        
        # Skip if this is an outdated entry
        if d > dist[u]:
            continue
        
        # Relax all edges from u
        for v, weight in graph[u]:
            if v not in processed:
                new_dist = dist[u] + weight
                
                if new_dist < dist[v]:
                    dist[v] = new_dist
                    parent[v] = u
                    heapq.heappush(pq, (new_dist, v))
    
    return dist, parent


def reconstruct_path(parent, start, end):
    """
    Reconstruct shortest path from parent pointers
    """
    if end not in parent:
        return []  # No path exists
    
    path = []
    current = end
    
    while current is not None:
        path.append(current)
        current = parent[current]
    
    return path[::-1]  # Reverse to get start→end


# Example Usage
graph = defaultdict(list)
edges = [
    (0, 1, 5),  # A→B, weight 5
    (0, 2, 2),  # A→C, weight 2
    (0, 3, 10), # A→D, weight 10
    (1, 3, 3),  # B→D, weight 3
    (2, 3, 4),  # C→D, weight 4
]

# Build undirected graph
for u, v, w in edges:
    graph[u].append((v, w))
    graph[v].append((u, w))

dist, parent = dijkstra(graph, 0, 4)
print("Distances:", dist)  # {0: 0, 1: 5, 2: 2, 3: 6}

path = reconstruct_path(parent, 0, 3)
print("Path 0→3:", path)  # [0, 2, 3]
```

### Why Dijkstra Fails with Negative Edges

```
Graph with negative edge:
    (A)──1──(B)
     │       │
     2      -5   ← Negative!
     │       │
    (C)──1──(D)

Dijkstra from A:
1. Process A: dist={A:0, B:1, C:2}
2. Process B (dist=1): dist={..., D:1+(-5)=-4} 
3. Process C (dist=2): dist={..., D=min(-4, 2+1)=-4}
4. Process D (dist=-4): Done!

BUT WAIT: Path A→C→D→B = 2+1+(-5)= -2
This means dist[B] should be -2, not 1!

Once we processed B at step 2, we marked it as "final"
but later found a shorter path through D!

This is why Dijkstra fails with negative edges.
```

> ⚠️ **CRITICAL**: Never use Dijkstra when graph has negative edge weights!

### Complexity Analysis

```
Time Complexity:
- Each vertex extracted from heap once: O(V) extractions
- Each extraction: O(log V)
- Each edge causes at most one heap insertion: O(E) insertions
- Each insertion: O(log V)

Total: O((V + E) × log V) = O((V + E) log V)

Space Complexity:
- Distance array: O(V)
- Priority queue: O(V) in worst case
- Parent array: O(V)

Total: O(V)
```

### Dijkstra Variants

#### Finding Shortest Distance Only (Simplified)

```python
def dijkstra_simple(graph, start, n):
    """Simplified Dijkstra - just returns distances"""
    dist = [float('inf')] * n
    dist[start] = 0
    pq = [(0, start)]
    
    while pq:
        d, u = heapq.heappop(pq)
        
        if d > dist[u]:
            continue
        
        for v, w in graph[u]:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                heapq.heappush(pq, (dist[v], v))
    
    return dist
```

#### Shortest Path to Specific Target

```python
def dijkstra_target(graph, start, target, n):
    """Stop early when target is reached"""
    dist = [float('inf')] * n
    dist[start] = 0
    pq = [(0, start)]
    
    while pq:
        d, u = heapq.heappop(pq)
        
        if u == target:
            return d  # Found shortest path to target!
        
        if d > dist[u]:
            continue
        
        for v, w in graph[u]:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                heapq.heappush(pq, (dist[v], v))
    
    return -1  # Target unreachable
```

---

## 5.3 Bellman-Ford Algorithm

### Concept

Bellman-Ford uses **dynamic programming**: relax all edges V-1 times. Works with negative edges and detects negative cycles.

```
Key Insight:
In a graph with V vertices, the shortest path has at most V-1 edges.
If we relax all edges V-1 times, we guarantee finding shortest paths.

If distances still change on the Vth iteration → Negative cycle exists!
```

### Visual Walkthrough

```
Graph with negative edge:
    (0)──4──(1)
     │       │
     5      -6   ← Negative!
     │       │
    (2)──2──(3)

Edges: (0,1,4), (0,2,5), (1,3,-6), (2,3,2)
Source: 0

Iteration 1:
dist = [0, ∞, ∞, ∞]
Relax (0,1,4): dist[1] = min(∞, 0+4) = 4
Relax (0,2,5): dist[2] = min(∞, 0+5) = 5
Relax (1,3,-6): dist[3] = min(∞, 4+(-6)) = -2
Relax (2,3,2): dist[3] = min(-2, 5+2) = -2 (no change)
dist = [0, 4, 5, -2]

Iteration 2:
No changes (already optimal)
dist = [0, 4, 5, -2]

Iteration 3:
No changes
dist = [0, 4, 5, -2]

Negative cycle check (Iteration V):
No changes → No negative cycle!

Final: dist = [0, 4, 5, -2]
```

### Implementation

```python
def bellman_ford(n, edges, start):
    """
    Bellman-Ford algorithm for single-source shortest paths
    
    Args:
        n: number of vertices
        edges: list of (u, v, weight) tuples
        start: source vertex
    
    Returns:
        dist: list of shortest distances (or None if negative cycle)
        parent: list for path reconstruction
    """
    # Initialize
    dist = [float('inf')] * n
    dist[start] = 0
    parent = [-1] * n
    
    # Relax all edges V-1 times
    for i in range(n - 1):
        updated = False
        
        for u, v, w in edges:
            if dist[u] != float('inf') and dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                parent[v] = u
                updated = True
        
        # Early termination if no updates
        if not updated:
            break
    
    # Check for negative cycles (Vth iteration)
    for u, v, w in edges:
        if dist[u] != float('inf') and dist[u] + w < dist[v]:
            return None, None  # Negative cycle detected!
    
    return dist, parent


# Example
edges = [
    (0, 1, 4),
    (0, 2, 5),
    (1, 3, -6),  # Negative edge
    (2, 3, 2)
]

dist, parent = bellman_ford(4, edges, 0)
if dist is None:
    print("Negative cycle exists!")
else:
    print("Distances:", dist)  # [0, 4, 5, -2]
```

### Detecting Negative Cycles

```python
def has_negative_cycle(n, edges):
    """
    Check if graph contains a negative cycle
    """
    dist = [0] * n  # Start all at 0 to detect any negative cycle
    
    # Relax V-1 times
    for _ in range(n - 1):
        for u, v, w in edges:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
    
    # Check for negative cycle
    for u, v, w in edges:
        if dist[u] + w < dist[v]:
            return True
    
    return False


# Example with negative cycle
#   0 → 1 → 2 → 0 (cycle)
#   weights: 1, 1, -5
#   Cycle sum: 1 + 1 + (-5) = -3 (negative!)
edges_with_cycle = [
    (0, 1, 1),
    (1, 2, 1),
    (2, 0, -5)  # Creates negative cycle
]

print(has_negative_cycle(3, edges_with_cycle))  # True
```

### Finding the Negative Cycle

```python
def find_negative_cycle(n, edges):
    """
    Find and return a negative cycle if one exists
    """
    dist = [0] * n
    parent = [-1] * n
    
    # Relax V-1 times
    for _ in range(n - 1):
        for u, v, w in edges:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                parent[v] = u
    
    # Find vertex in negative cycle
    cycle_vertex = -1
    for u, v, w in edges:
        if dist[u] + w < dist[v]:
            cycle_vertex = v
            break
    
    if cycle_vertex == -1:
        return []  # No negative cycle
    
    # Go back V times to ensure we're in the cycle
    for _ in range(n):
        cycle_vertex = parent[cycle_vertex]
    
    # Collect cycle
    cycle = []
    current = cycle_vertex
    while True:
        cycle.append(current)
        current = parent[current]
        if current == cycle_vertex:
            break
    
    cycle.reverse()
    return cycle
```

### Complexity Analysis

```
Time Complexity:
- Outer loop: V-1 iterations
- Inner loop: Process all E edges
- Total: O(V × E)

Space Complexity:
- Distance array: O(V)
- Parent array: O(V)
- Total: O(V)
```

### When to Use Bellman-Ford

| Use Bellman-Ford When... | Don't Use When... |
|-------------------------|-------------------|
| Graph has negative edges | All edges non-negative (use Dijkstra) |
| Need to detect negative cycles | Graph is very dense |
| Edges given as list | Time is critical |
| Simple implementation needed | - |

---

## 5.4 0-1 BFS

### Concept

When all edge weights are either **0 or 1**, we can achieve O(V+E) using a **deque** instead of a priority queue.

```
Key Insight:
- Weight 0: Add to FRONT of deque (same "level")
- Weight 1: Add to BACK of deque (next "level")

This maintains sorted order without heap operations!
```

### Visual Walkthrough

```
Graph with 0/1 weights:
    (0)──1──(1)
     │       │
     0       1
     │       │
    (2)──0──(3)

Process from source 0:

deque = [(0, 0)]  // (distance, vertex)

Step 1: Pop (0, 0)
  - Edge to 1 (weight=1): add (1, 1) to BACK
  - Edge to 2 (weight=0): add (0, 2) to FRONT
  deque = [(0, 2), (1, 1)]

Step 2: Pop (0, 2)  ← Front has smaller dist!
  - Edge to 3 (weight=0): add (0, 3) to FRONT
  deque = [(0, 3), (1, 1)]

Step 3: Pop (0, 3)
  - Edge to 1 (weight=1): dist[1]=1, no update needed
  deque = [(1, 1)]

Step 4: Pop (1, 1)
  - All neighbors processed
  deque = []

Final: dist = [0, 1, 0, 0]
```

### Implementation

```python
from collections import deque

def zero_one_bfs(graph, start, n):
    """
    0-1 BFS for graphs with only 0 and 1 edge weights
    
    Args:
        graph: adjacency list {node: [(neighbor, weight), ...]}
               where weight is 0 or 1
        start: source vertex
        n: number of vertices
    
    Returns:
        dist: list of shortest distances
    """
    dist = [float('inf')] * n
    dist[start] = 0
    
    dq = deque([start])
    
    while dq:
        u = dq.popleft()
        
        for v, w in graph[u]:
            new_dist = dist[u] + w
            
            if new_dist < dist[v]:
                dist[v] = new_dist
                
                if w == 0:
                    dq.appendleft(v)  # Weight 0: add to FRONT
                else:
                    dq.append(v)      # Weight 1: add to BACK
    
    return dist


# Example
graph = {
    0: [(1, 1), (2, 0)],
    1: [(0, 1), (3, 1)],
    2: [(0, 0), (3, 0)],
    3: [(1, 1), (2, 0)]
}

dist = zero_one_bfs(graph, 0, 4)
print(dist)  # [0, 1, 0, 0]
```

### Why It Works

```
Deque maintains vertices in sorted order by distance!

When processing vertex u with distance d:
- Adding v with weight 0 → dist[v] = d + 0 = d (same level)
  → Add to FRONT (processed before larger distances)
- Adding v with weight 1 → dist[v] = d + 1 (next level)
  → Add to BACK (processed after current level)

This is essentially BFS with 0-weight edges being "free"!
```

### Complexity Analysis

```
Time Complexity:
- Each vertex added to deque at most twice
- Each edge examined once
- Total: O(V + E)

Space Complexity:
- Distance array: O(V)
- Deque: O(V)
- Total: O(V)
```

### Common 0-1 BFS Problems

```
1. Minimum Cost to Make Valid Path in Grid
   - Cost 0: continue in same direction
   - Cost 1: change direction

2. Minimum Flips to Binary Matrix
   - Cost 0: select cell that needs flip
   - Cost 1: select unnecessary cell

3. Graph with Portals
   - Cost 0: use portal
   - Cost 1: walk to adjacent cell
```

---

## 5.5 Algorithm Comparison

### Visual Comparison

```
Same Graph, Different Methods:

      2       3
  (A)───(B)───(C)
   │    │      │
  1│   4│     2│
   │    │      │
  (D)───(E)───(F)
      5       1

BFS (unweighted): Treats all edges as weight 1
Path A→F: A→B→C→F (3 hops) ← NOT shortest by weight!

Dijkstra: Uses priority queue
Path A→F: A→D→E→F (1+5+1=7)? or A→B→C→F (2+3+2=7)?
Actually: A→D→...→F finds optimal

Bellman-Ford: Relaxes all edges V-1 times
Same result as Dijkstra, but slower
```

### Choosing the Right Algorithm

```python
def choose_sssp_algorithm(has_negative_edges, edge_weights_binary, graph_sparse):
    """
    Decision helper for SSSP algorithm selection
    """
    if not has_negative_edges:
        if edge_weights_binary:  # Only 0 and 1
            return "0-1 BFS - O(V+E)"
        else:
            return "Dijkstra - O((V+E)logV)"
    else:
        return "Bellman-Ford - O(VE)"
```

### Summary Table

| Feature | BFS | Dijkstra | Bellman-Ford | 0-1 BFS |
|---------|-----|----------|--------------|---------|
| Time | O(V+E) | O((V+E)logV) | O(VE) | O(V+E) |
| Edge weights | Unweighted | Non-negative | Any | 0 or 1 only |
| Negative edges | N/A | ✗ | ✓ | N/A |
| Negative cycle detection | N/A | ✗ | ✓ | N/A |
| Data structure | Queue | Min-Heap | Arrays | Deque |
| Implementation | Simple | Medium | Simple | Simple |

---

## 5.6 Common Interview Problems

### Problem 1: Network Delay Time (Dijkstra)

```python
def network_delay_time(times, n, k):
    """
    Find time for signal to reach all nodes from node k
    times: [[u, v, w], ...] edge list
    """
    # Build graph
    graph = defaultdict(list)
    for u, v, w in times:
        graph[u].append((v, w))
    
    # Dijkstra
    dist = {k: 0}
    pq = [(0, k)]
    
    while pq:
        d, u = heapq.heappop(pq)
        
        if d > dist.get(u, float('inf')):
            continue
        
        for v, w in graph[u]:
            new_dist = d + w
            if new_dist < dist.get(v, float('inf')):
                dist[v] = new_dist
                heapq.heappush(pq, (new_dist, v))
    
    if len(dist) != n:
        return -1  # Not all nodes reachable
    
    return max(dist.values())
```

### Problem 2: Cheapest Flights Within K Stops (Modified Bellman-Ford)

```python
def find_cheapest_price(n, flights, src, dst, k):
    """
    Find cheapest price with at most k stops
    """
    # Use Bellman-Ford with k+1 iterations
    dist = [float('inf')] * n
    dist[src] = 0
    
    for _ in range(k + 1):  # At most k stops = k+1 edges
        temp = dist.copy()  # Use previous iteration's values
        
        for u, v, price in flights:
            if dist[u] != float('inf'):
                temp[v] = min(temp[v], dist[u] + price)
        
        dist = temp
    
    return dist[dst] if dist[dst] != float('inf') else -1
```

### Problem 3: Path with Maximum Probability (Modified Dijkstra)

```python
def max_probability(n, edges, succ_prob, start, end):
    """
    Find path with maximum probability
    Trick: Dijkstra with max-heap (or negate probabilities)
    """
    graph = defaultdict(list)
    for i, (u, v) in enumerate(edges):
        graph[u].append((v, succ_prob[i]))
        graph[v].append((u, succ_prob[i]))
    
    # Max-heap using negative probabilities
    prob = [0.0] * n
    prob[start] = 1.0
    pq = [(-1.0, start)]
    
    while pq:
        p, u = heapq.heappop(pq)
        p = -p
        
        if u == end:
            return p
        
        if p < prob[u]:
            continue
        
        for v, edge_prob in graph[u]:
            new_prob = p * edge_prob
            if new_prob > prob[v]:
                prob[v] = new_prob
                heapq.heappush(pq, (-new_prob, v))
    
    return 0.0
```

---

## 5.7 Practice Problems

### Dijkstra Problems
1. Network Delay Time (LC 743)
2. Path with Minimum Effort (LC 1631)
3. Swim in Rising Water (LC 778)
4. Path with Maximum Probability (LC 1514)

### Bellman-Ford Problems
1. Cheapest Flights Within K Stops (LC 787)
2. Negative Weight Cycle Detection
3. Minimum Cost to Reach Destination in Time (LC 1928)

### 0-1 BFS Problems
1. Minimum Cost to Make at Least One Valid Path (LC 1368)
2. Minimum Obstacle Removal to Reach Corner (LC 2290)
