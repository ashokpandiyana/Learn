# Chapter 13: Bipartite Graphs
## Two-Colorable Graphs and Matching Problems

---

## 13.1 What is a Bipartite Graph?

### Definition

A **Bipartite Graph** is a graph whose vertices can be divided into **two disjoint sets** U and V such that every edge connects a vertex in U to a vertex in V. No edge connects vertices within the same set.

```
Bipartite Graph:
    Set U          Set V
    â”Œâ”€â”€â”€â”          â”Œâ”€â”€â”€â”
    â”‚ A â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ X â”‚
    â”‚   â”‚    â•²     â”‚   â”‚
    â””â”€â”€â”€â”˜     â•²    â””â”€â”€â”€â”˜
               â•²
    â”Œâ”€â”€â”€â”       â•²  â”Œâ”€â”€â”€â”
    â”‚ B â”‚â”€â”€â”€â”€â”€â”€â”€â”€â•²â”€â”‚ Y â”‚
    â”‚   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â•±â”€â”‚   â”‚
    â””â”€â”€â”€â”˜       â•±  â””â”€â”€â”€â”˜
               â•±
    â”Œâ”€â”€â”€â”     â•±    â”Œâ”€â”€â”€â”
    â”‚ C â”‚â”€â”€â”€â”€â•±â”€â”€â”€â”€â”€â”‚ Z â”‚
    â”‚   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚   â”‚
    â””â”€â”€â”€â”˜          â””â”€â”€â”€â”˜

All edges go BETWEEN sets, never within a set!

U = {A, B, C}
V = {X, Y, Z}
```

### Two-Coloring Perspective

A graph is bipartite if and only if it can be **colored with exactly 2 colors** such that no two adjacent vertices have the same color.

```
Two-Coloring:
    ğŸ”´ A â”€â”€â”€â”€â”€â”€ X ğŸ”µ
         â•²    
    ğŸ”´ B â”€â”€â•²â”€â”€ Y ğŸ”µ
         â”€â”€â•±â”€
    ğŸ”´ C â”€â”€â•±â”€â”€ Z ğŸ”µ

Red vertices (U): A, B, C
Blue vertices (V): X, Y, Z

Every edge connects Red â†” Blue
```

### Key Property: No Odd Cycles

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FUNDAMENTAL THEOREM                                              â”‚
â”‚                                                                 â”‚
â”‚ A graph is bipartite âŸº It contains NO odd-length cycles        â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why?**

```
Consider a cycle: v1 â†’ v2 â†’ v3 â†’ ... â†’ vk â†’ v1

For 2-coloring:
- v1 gets color A
- v2 must get color B (adjacent to v1)
- v3 must get color A (adjacent to v2)
- v4 must get color B
- Pattern: odd positions get A, even positions get B

If k is ODD:
- vk gets color A (k is odd)
- v1 gets color A (position 1)
- But vk â†’ v1 is an edge!
- Two adjacent vertices with SAME color â†’ IMPOSSIBLE!

Triangle (3-cycle) - NOT bipartite:
    A â”€â”€â”€ B
     \   /
      \ /
       C

Try coloring:
A = Red, B = Blue, C = ? 
C is adjacent to both A(Red) and B(Blue)
C cannot be colored! â†’ Not bipartite
```

---

## 13.2 Real-World Examples

### Example 1: Students and Courses

```
Students can enroll in courses:

Students (U)     Courses (V)
   Alice    â”€â”€â”€â”€â”€  Math
      â”‚     â•²â”€â”€â”€â”€  Physics
   Bob      â”€â”€â”€â”€â”€  Math
      â”‚     â”€â”€â”€â”€â”€  Chemistry
   Charlie  â”€â”€â”€â”€â”€  Physics
            â”€â”€â”€â”€â”€  Chemistry

This is naturally bipartite:
- Students only connect to courses
- Courses only connect to students
- No student-student or course-course edges
```

### Example 2: Job Matching

```
Workers and Jobs:

Workers (U)      Jobs (V)
   W1    â”€â”€â”€â”€â”€â”€â”€  J1
    â”‚    â•²
   W2    â”€â”€â•²â”€â”€â”€â”€  J2
    â”‚    â”€â”€â”€â•²â”€â”€â”€  J3
   W3    â”€â”€â”€â”€â”€â”€â”€â”€  J4

Each worker can do certain jobs.
Find maximum matching (assign jobs to workers)!
```

### Example 3: Graph Coloring in Scheduling

```
Time Slots and Events:

If events conflict, they cannot share a time slot.
If the conflict graph is bipartite, we only need 2 time slots!

Events: {A, B, C, D}
Conflicts: A-B, C-D (A conflicts with B, C conflicts with D)

Conflict Graph:
A â”€â”€â”€ B    C â”€â”€â”€ D

This IS bipartite!
Time Slot 1: {A, C}
Time Slot 2: {B, D}
```

---

## 13.3 Checking if a Graph is Bipartite

### Method 1: BFS Two-Coloring

```python
from collections import deque

def is_bipartite_bfs(graph, n):
    """
    Check if graph is bipartite using BFS coloring
    
    Args:
        graph: adjacency list
        n: number of vertices
    
    Returns:
        (is_bipartite, coloring) or (False, None)
    """
    color = [-1] * n  # -1 = uncolored, 0 = color A, 1 = color B
    
    for start in range(n):
        # Skip if already colored (handles disconnected components)
        if color[start] != -1:
            continue
        
        # BFS from this vertex
        queue = deque([start])
        color[start] = 0  # Start with color 0
        
        while queue:
            node = queue.popleft()
            
            for neighbor in graph[node]:
                if color[neighbor] == -1:
                    # Color with opposite color
                    color[neighbor] = 1 - color[node]
                    queue.append(neighbor)
                elif color[neighbor] == color[node]:
                    # Same color as current node â†’ NOT bipartite!
                    return False, None
    
    return True, color


# Example
graph = [
    [1, 3],     # 0 connects to 1, 3
    [0, 2],     # 1 connects to 0, 2
    [1, 3],     # 2 connects to 1, 3
    [0, 2]      # 3 connects to 0, 2
]

is_bip, coloring = is_bipartite_bfs(graph, 4)
print(f"Is bipartite: {is_bip}")  # True
print(f"Coloring: {coloring}")    # [0, 1, 0, 1]
```

### Visual Walkthrough: BFS Coloring

```
Graph:
    0 â”€â”€â”€ 1
    â”‚     â”‚
    â”‚     â”‚
    3 â”€â”€â”€ 2

Step 1: Start BFS from 0, color it RED (0)
    ğŸ”´0 â”€â”€â”€ 1
    â”‚      â”‚
    â”‚      â”‚
    3 â”€â”€â”€ 2

Step 2: Process 0's neighbors (1, 3), color them BLUE (1)
    ğŸ”´0 â”€â”€â”€ ğŸ”µ1
    â”‚       â”‚
    â”‚       â”‚
    ğŸ”µ3 â”€â”€â”€ 2

Step 3: Process 1's neighbors
    - 0 already colored RED âœ“ (different from 1's BLUE)
    - 2 uncolored â†’ color RED
    ğŸ”´0 â”€â”€â”€ ğŸ”µ1
    â”‚       â”‚
    â”‚       â”‚
    ğŸ”µ3 â”€â”€â”€ ğŸ”´2

Step 4: Process 3's neighbors
    - 0 already RED âœ“ (different from 3's BLUE)
    - 2 already RED âœ“ (different from 3's BLUE)

Step 5: Process 2's neighbors
    - 1 already BLUE âœ“
    - 3 already BLUE âœ“

Done! Graph is bipartite.
Set U (RED):  {0, 2}
Set V (BLUE): {1, 3}
```

### Method 2: DFS Two-Coloring

```python
def is_bipartite_dfs(graph, n):
    """
    Check if graph is bipartite using DFS coloring
    """
    color = [-1] * n
    
    def dfs(node, c):
        color[node] = c
        
        for neighbor in graph[node]:
            if color[neighbor] == -1:
                # Color neighbor with opposite color
                if not dfs(neighbor, 1 - c):
                    return False
            elif color[neighbor] == c:
                # Same color â†’ not bipartite
                return False
        
        return True
    
    # Handle disconnected components
    for i in range(n):
        if color[i] == -1:
            if not dfs(i, 0):
                return False, None
    
    return True, color


# Example with odd cycle (triangle) - NOT bipartite
triangle = [
    [1, 2],  # 0
    [0, 2],  # 1
    [0, 1]   # 2
]

is_bip, _ = is_bipartite_dfs(triangle, 3)
print(f"Triangle is bipartite: {is_bip}")  # False
```

### Detecting Odd Cycle

```python
def find_odd_cycle(graph, n):
    """
    Find an odd cycle if graph is not bipartite
    Returns the cycle or empty list if bipartite
    """
    color = [-1] * n
    parent = [-1] * n
    
    def bfs(start):
        queue = deque([start])
        color[start] = 0
        
        while queue:
            node = queue.popleft()
            
            for neighbor in graph[node]:
                if color[neighbor] == -1:
                    color[neighbor] = 1 - color[node]
                    parent[neighbor] = node
                    queue.append(neighbor)
                elif color[neighbor] == color[node]:
                    # Found odd cycle! Reconstruct it.
                    cycle = []
                    
                    # Path from node to common ancestor
                    path1 = [node]
                    curr = node
                    while curr != -1:
                        path1.append(curr)
                        curr = parent[curr]
                    
                    # Path from neighbor to common ancestor
                    path2 = [neighbor]
                    curr = neighbor
                    while curr != -1:
                        path2.append(curr)
                        curr = parent[curr]
                    
                    # Find LCA and construct cycle
                    set1 = set(path1)
                    for v in path2:
                        if v in set1:
                            # v is LCA
                            cycle = []
                            for u in path1:
                                cycle.append(u)
                                if u == v:
                                    break
                            
                            idx = path2.index(v)
                            cycle.extend(reversed(path2[:idx]))
                            return cycle
        
        return []
    
    for i in range(n):
        if color[i] == -1:
            cycle = bfs(i)
            if cycle:
                return cycle
    
    return []
```

### Complexity Analysis

```
Time Complexity: O(V + E)
- Each vertex processed once
- Each edge examined once

Space Complexity: O(V)
- Color array: O(V)
- Queue/recursion: O(V)
```

---

## 13.4 Bipartite Matching

### Maximum Bipartite Matching Problem

Given a bipartite graph, find the **maximum number of edges** such that no two edges share a vertex.

```
Matching Problem:

Workers (U)      Jobs (V)
   W1    â”€â”€â”€â”€â”€â”€â”€  J1
    â”‚    â•²
   W2    â”€â”€â•²â”€â”€â”€â”€  J2
    â”‚    â”€â”€â”€â•²â”€â”€â”€  J3
   W3    â”€â”€â”€â”€â”€â”€â”€â”€  J4

Maximum Matching (one solution):
   W1 â”€â”€â”€â”€â”€â”€â”€ J1
   W2 â”€â”€â”€â”€â”€â”€â”€ J2
   W3 â”€â”€â”€â”€â”€â”€â”€ J4

Size = 3 (3 workers assigned)
```

### Hungarian Algorithm / Kuhn's Algorithm

```python
def max_bipartite_matching(graph, n, m):
    """
    Maximum Bipartite Matching using Kuhn's Algorithm (DFS-based)
    
    Args:
        graph: adjacency list for left vertices (U)
        n: number of vertices in U (left side)
        m: number of vertices in V (right side)
    
    Returns:
        Maximum matching size
    """
    # match_v[j] = vertex in U matched to vertex j in V (-1 if unmatched)
    match_v = [-1] * m
    
    def dfs(u, visited):
        """Try to find augmenting path from u"""
        for v in graph[u]:
            if visited[v]:
                continue
            
            visited[v] = True
            
            # If v is unmatched OR we can find alternative for current match
            if match_v[v] == -1 or dfs(match_v[v], visited):
                match_v[v] = u
                return True
        
        return False
    
    matching = 0
    
    for u in range(n):
        visited = [False] * m
        if dfs(u, visited):
            matching += 1
    
    return matching


# Example
# Workers: 0, 1, 2 (left side)
# Jobs: 0, 1, 2, 3 (right side)
# graph[i] = jobs that worker i can do
graph = [
    [0, 1],     # Worker 0 can do Job 0, 1
    [0, 2],     # Worker 1 can do Job 0, 2
    [1, 2, 3]   # Worker 2 can do Job 1, 2, 3
]

result = max_bipartite_matching(graph, 3, 4)
print(f"Maximum matching: {result}")  # 3
```

### Visual: Augmenting Path

```
Initial state (no matching):
   W0 â”€â”€â”€â”€ J0
    â”‚ â•²
   W1 â”€â”€â•²â”€ J1
    â”‚ â”€â”€â•±â”€ J2
   W2 â”€â”€â”€â”€ J3

Step 1: Try to match W0
- W0 can do J0 (unmatched) â†’ Match W0-J0 âœ“

   W0 â•â•â•â• J0    (â•â•â• means matched)
    â”‚ 
   W1 â”€â”€â”€â”€ J1
    â”‚ â”€â”€â”€â”€ J2
   W2 â”€â”€â”€â”€ J3

Step 2: Try to match W1
- W1 can do J0, but J0 matched to W0
- Can W0 find alternative? W0 can do J1 (unmatched)!
- Augmenting path: W1 â†’ J0 â†’ W0 â†’ J1
- Result: Match W1-J0, W0-J1

   W0 â•â•â•â• J1
          
   W1 â•â•â•â• J0
    â”‚ â”€â”€â”€â”€ J2
   W2 â”€â”€â”€â”€ J3

Step 3: Try to match W2
- W2 can do J1, but J1 matched to W0
- Can W0 find alternative? W0 only does J0, J1 - both taken!
- Try J2 - unmatched! â†’ Match W2-J2 âœ“

   W0 â•â•â•â• J1
          
   W1 â•â•â•â• J0
          J2
   W2 â•â•â•â• J3

Wait, let me redo: W2 can do J1, J2, J3
- J2 unmatched â†’ Match W2-J2 âœ“

Final:
   W0 â•â•â•â• J1
   W1 â•â•â•â• J0
   W2 â•â•â•â• J2

Maximum matching = 3
```

### Complexity

```
Kuhn's Algorithm:
- For each of n vertices in U, run DFS
- Each DFS: O(E)
- Total: O(n Ã— E) = O(V Ã— E)

Can be improved to O(E Ã— âˆšV) using Hopcroft-Karp algorithm
```

---

## 13.5 Minimum Vertex Cover in Bipartite Graphs

### KÃ¶nig's Theorem

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ KÃ–NIG'S THEOREM                                                  â”‚
â”‚                                                                 â”‚
â”‚ In a bipartite graph:                                           â”‚
â”‚ Maximum Matching = Minimum Vertex Cover                         â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Vertex Cover**: A set of vertices such that every edge has at least one endpoint in the set.

```
Graph:
   A â”€â”€â”€ X
   â”‚ â•²
   B â”€â”€â•²â”€ Y
   â”‚ â”€â”€â•±â”€ Z
   C â”€â”€â•±

Minimum Vertex Cover: {A, B} or {X, Y, Z}?

Let's check {B, X}:
- Edge A-X: covered by X âœ“
- Edge A-Y: NOT covered âœ—

Try {A, B, Z}:
- All edges covered? 
- A-X âœ“, A-Y âœ“, B-Y âœ“, B-Z âœ“, C-Z âœ“
- Size = 3

By KÃ¶nig's theorem:
If max matching = 3, then min vertex cover = 3
```

---

## 13.6 Common Interview Problems

### Problem 1: Is Graph Bipartite? (LeetCode 785)

```python
def isBipartite(graph):
    """
    LeetCode 785: Is Graph Bipartite?
    """
    n = len(graph)
    color = [0] * n  # 0 = uncolored, 1 = color A, -1 = color B
    
    for start in range(n):
        if color[start] != 0:
            continue
        
        # BFS
        queue = deque([start])
        color[start] = 1
        
        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if color[neighbor] == 0:
                    color[neighbor] = -color[node]
                    queue.append(neighbor)
                elif color[neighbor] == color[node]:
                    return False
    
    return True
```

### Problem 2: Possible Bipartition (LeetCode 886)

```python
def possibleBipartition(n, dislikes):
    """
    LeetCode 886: Possible Bipartition
    
    Divide n people into 2 groups such that
    no two people who dislike each other are in same group.
    """
    # Build graph
    graph = [[] for _ in range(n + 1)]
    for a, b in dislikes:
        graph[a].append(b)
        graph[b].append(a)
    
    color = [0] * (n + 1)
    
    def bfs(start):
        queue = deque([start])
        color[start] = 1
        
        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if color[neighbor] == 0:
                    color[neighbor] = -color[node]
                    queue.append(neighbor)
                elif color[neighbor] == color[node]:
                    return False
        return True
    
    for i in range(1, n + 1):
        if color[i] == 0:
            if not bfs(i):
                return False
    
    return True
```

### Problem 3: Maximum Students Taking Exam (LeetCode 1349)

```python
def maxStudents(seats):
    """
    LeetCode 1349: Maximum Students Taking Exam
    
    Place students in seats such that no one can cheat
    (no adjacent students horizontally or diagonally)
    
    This is a bipartite matching problem!
    - Columns alternate between two sets
    - Find maximum independent set
    """
    m, n = len(seats), len(seats[0])
    
    # Valid seats
    valid = []
    for i in range(m):
        for j in range(n):
            if seats[i][j] == '.':
                valid.append((i, j))
    
    # Build conflict graph (edges between seats that can see each other)
    # Then find maximum independent set
    # For bipartite graphs: Max Independent Set = Total - Min Vertex Cover
    #                                           = Total - Max Matching
    
    # Group by column parity (odd/even columns form bipartition)
    left = [(i, j) for i, j in valid if j % 2 == 0]
    right = [(i, j) for i, j in valid if j % 2 == 1]
    
    # Build adjacency for matching
    # Edge exists if two seats can see each other
    def can_see(s1, s2):
        r1, c1 = s1
        r2, c2 = s2
        if r1 == r2 and abs(c1 - c2) == 1:
            return True
        if abs(r1 - r2) == 1 and abs(c1 - c2) == 1:
            return True
        return False
    
    # Create mapping for matching algorithm
    left_idx = {s: i for i, s in enumerate(left)}
    right_idx = {s: i for i, s in enumerate(right)}
    
    graph = [[] for _ in range(len(left))]
    for s1 in left:
        for s2 in right:
            if can_see(s1, s2):
                graph[left_idx[s1]].append(right_idx[s2])
    
    # Maximum matching
    match_r = [-1] * len(right)
    
    def dfs(u, visited):
        for v in graph[u]:
            if visited[v]:
                continue
            visited[v] = True
            if match_r[v] == -1 or dfs(match_r[v], visited):
                match_r[v] = u
                return True
        return False
    
    matching = 0
    for u in range(len(left)):
        if dfs(u, [False] * len(right)):
            matching += 1
    
    # Max independent set = Total valid - Max matching
    return len(valid) - matching
```

### Problem 4: Flower Planting With No Adjacent (LeetCode 1042)

```python
def gardenNoAdj(n, paths):
    """
    LeetCode 1042: Flower Planting With No Adjacent
    
    Assign flowers (1-4) to gardens such that
    no adjacent gardens have the same flower.
    
    Note: Each garden has at most 3 neighbors,
    so 4 colors always suffice (greedy works)
    """
    graph = [[] for _ in range(n + 1)]
    for a, b in paths:
        graph[a].append(b)
        graph[b].append(a)
    
    result = [0] * (n + 1)
    
    for garden in range(1, n + 1):
        # Find colors used by neighbors
        used = set()
        for neighbor in graph[garden]:
            if result[neighbor] != 0:
                used.add(result[neighbor])
        
        # Assign first available color
        for color in range(1, 5):
            if color not in used:
                result[garden] = color
                break
    
    return result[1:]
```

---

## 13.7 Summary

### Key Takeaways

```
Bipartite Graph:
- Vertices can be split into two disjoint sets
- All edges go between sets, not within
- Equivalent to 2-colorable graph
- Contains NO odd-length cycles

Checking Bipartiteness:
- BFS/DFS with 2-coloring
- Time: O(V + E)

Bipartite Matching:
- Find maximum set of non-sharing edges
- Kuhn's algorithm: O(V Ã— E)
- Applications: job assignment, scheduling

KÃ¶nig's Theorem:
- Max Matching = Min Vertex Cover (in bipartite graphs)
```

### Quick Reference

```python
# Bipartite Check Template
def is_bipartite(graph, n):
    color = [-1] * n
    
    for start in range(n):
        if color[start] != -1:
            continue
        
        queue = deque([start])
        color[start] = 0
        
        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if color[neighbor] == -1:
                    color[neighbor] = 1 - color[node]
                    queue.append(neighbor)
                elif color[neighbor] == color[node]:
                    return False
    
    return True
```

---

## 13.8 Practice Problems

1. Is Graph Bipartite? (LC 785)
2. Possible Bipartition (LC 886)
3. Flower Planting With No Adjacent (LC 1042)
4. Maximum Students Taking Exam (LC 1349)
5. Divide Nodes Into Maximum Groups (LC 2493)
