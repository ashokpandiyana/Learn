# Chapter 9: Union-Find (Disjoint Set Union)
## Efficient Connected Component Management

---

## 9.1 What is Union-Find?

### The Problem

We need a data structure to efficiently:
1. **Union**: Merge two sets together
2. **Find**: Determine which set an element belongs to
3. **Connected**: Check if two elements are in the same set

```
Scenario: Track friend groups in a social network

Initially: Everyone is in their own group
{Alice}, {Bob}, {Charlie}, {David}, {Eve}

Operation: Alice and Bob become friends
{Alice, Bob}, {Charlie}, {David}, {Eve}

Operation: Charlie and David become friends
{Alice, Bob}, {Charlie, David}, {Eve}

Operation: Alice and Charlie become friends
{Alice, Bob, Charlie, David}, {Eve}

Query: Are Bob and David in the same group?
Answer: Yes! (through Alice-Bob and Alice-Charlie-David)
```

### Why Union-Find?

```
Alternative approaches:

1. Store explicit sets:
   - Union: O(n) to merge two sets
   - Find: O(1) with hash map
   Problem: Merging is slow!

2. Store graph and do BFS/DFS:
   - Connected: O(V + E) to traverse
   Problem: Repeated queries are slow!

3. Union-Find with optimizations:
   - Union: O(α(n)) ≈ O(1) amortized
   - Find: O(α(n)) ≈ O(1) amortized
   - Connected: O(α(n)) ≈ O(1) amortized
   
α(n) is the inverse Ackermann function - practically constant!
```

---

## 9.2 Basic Concept: Forest of Trees

### Representation

Union-Find represents sets as **trees**. Each set is a tree, and the **root** of the tree is the set's representative.

```
Initial state (each element is its own root):
parent = [0, 1, 2, 3, 4]  // parent[i] = i means i is a root

0    1    2    3    4     // 5 separate trees/sets
●    ●    ●    ●    ●

After union(0, 1):
parent = [0, 0, 2, 3, 4]  // parent[1] = 0

0    2    3    4          // 4 sets
│
1

After union(2, 3):
parent = [0, 0, 2, 2, 4]

0    2    4               // 3 sets
│    │
1    3

After union(0, 2):
parent = [0, 0, 0, 2, 4]  // 2's root becomes 0

    0       4             // 2 sets
   /│
  1 2
    │
    3
```

### Basic Operations

```
Find(x): Follow parent pointers until reaching root
         The root is the representative of x's set

Union(x, y): 
    1. Find root of x: root_x = Find(x)
    2. Find root of y: root_y = Find(y)
    3. Make one root point to the other: parent[root_x] = root_y

Connected(x, y):
    Return Find(x) == Find(y)
```

---

## 9.3 Naive Implementation

```python
class UnionFindNaive:
    """Basic Union-Find without optimizations"""
    
    def __init__(self, n):
        # Initially, each element is its own parent (root)
        self.parent = list(range(n))
    
    def find(self, x):
        """Find root of x by following parent pointers"""
        while self.parent[x] != x:
            x = self.parent[x]
        return x
    
    def union(self, x, y):
        """Merge sets containing x and y"""
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x != root_y:
            self.parent[root_x] = root_y
    
    def connected(self, x, y):
        """Check if x and y are in the same set"""
        return self.find(x) == self.find(y)


# Example
uf = UnionFindNaive(5)
print(uf.connected(0, 1))  # False

uf.union(0, 1)
uf.union(2, 3)
print(uf.connected(0, 1))  # True
print(uf.connected(0, 2))  # False

uf.union(1, 3)
print(uf.connected(0, 2))  # True (0-1-3-2)
```

### Problem with Naive Approach

```
Worst case: Linear chain

union(0, 1): 0 → 1
union(1, 2): 0 → 1 → 2
union(2, 3): 0 → 1 → 2 → 3
union(3, 4): 0 → 1 → 2 → 3 → 4

Tree becomes a linked list!

find(0) requires traversing 4 edges → O(n)

After n unions: find can be O(n)
Total for n operations: O(n²) worst case
```

---

## 9.4 Optimization 1: Path Compression

### Concept

When finding the root, make all nodes along the path point directly to the root.

```
Before path compression:
    4
    │
    3
    │
    2
    │
    1
    │
    0

find(0):
- Follow path: 0 → 1 → 2 → 3 → 4
- Root is 4

After path compression:
        4
      / | \
     0  1  2  3

All nodes now point directly to root!
Next find(0) is O(1)!
```

### Implementation

```python
def find_with_path_compression(self, x):
    """Find with path compression"""
    if self.parent[x] != x:
        self.parent[x] = self.find(self.parent[x])  # Recursively find root
                                                     # and update parent
    return self.parent[x]
```

### Iterative Path Compression

```python
def find_iterative(self, x):
    """Iterative find with path compression"""
    # First pass: find root
    root = x
    while self.parent[root] != root:
        root = self.parent[root]
    
    # Second pass: compress path
    while self.parent[x] != root:
        next_x = self.parent[x]
        self.parent[x] = root
        x = next_x
    
    return root
```

---

## 9.5 Optimization 2: Union by Rank/Size

### Concept

When unioning two trees, attach the **smaller tree** under the **larger tree** to keep trees balanced.

```
Without union by rank:
union(big_tree, small_tree) might do:

    small
      │
    big_tree (many nodes)

Height increases!

With union by rank:
Always attach smaller under larger:

        big_tree
           │
         small

Height stays small!
```

### Two Variants

```
Union by RANK:
- Track the "rank" (approximate height) of each tree
- Attach lower rank tree under higher rank tree
- Only increase rank when two equal ranks merge

Union by SIZE:
- Track the size (number of nodes) of each tree
- Attach smaller tree under larger tree
- Update sizes after merge
```

### Implementation: Union by Rank

```python
class UnionFindRank:
    """Union-Find with path compression and union by rank"""
    
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n  # Rank (approximate height)
    
    def find(self, x):
        """Find with path compression"""
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        """Union by rank"""
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return False  # Already in same set
        
        # Attach smaller rank tree under larger rank tree
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            # Same rank: attach one to other, increase rank
            self.parent[root_y] = root_x
            self.rank[root_x] += 1
        
        return True
    
    def connected(self, x, y):
        return self.find(x) == self.find(y)
```

### Implementation: Union by Size

```python
class UnionFindSize:
    """Union-Find with path compression and union by size"""
    
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n  # Size of each tree
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return False
        
        # Attach smaller tree under larger tree
        if self.size[root_x] < self.size[root_y]:
            self.parent[root_x] = root_y
            self.size[root_y] += self.size[root_x]
        else:
            self.parent[root_y] = root_x
            self.size[root_x] += self.size[root_y]
        
        return True
    
    def get_size(self, x):
        """Get size of the set containing x"""
        return self.size[self.find(x)]
```

---

## 9.6 Complete Optimized Implementation

```python
class UnionFind:
    """
    Optimized Union-Find with:
    - Path compression
    - Union by rank
    - Component counting
    """
    
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.components = n  # Track number of connected components
    
    def find(self, x):
        """Find with path compression"""
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        """
        Union by rank
        Returns: True if union performed (were in different sets)
                 False if already in same set
        """
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return False
        
        # Union by rank
        if self.rank[root_x] < self.rank[root_y]:
            root_x, root_y = root_y, root_x
        
        self.parent[root_y] = root_x
        
        if self.rank[root_x] == self.rank[root_y]:
            self.rank[root_x] += 1
        
        self.components -= 1  # Merged two components into one
        return True
    
    def connected(self, x, y):
        """Check if x and y are in the same set"""
        return self.find(x) == self.find(y)
    
    def get_components(self):
        """Return number of connected components"""
        return self.components


# Example usage
uf = UnionFind(5)
print(f"Components: {uf.get_components()}")  # 5

uf.union(0, 1)
print(f"Components: {uf.get_components()}")  # 4

uf.union(2, 3)
print(f"Components: {uf.get_components()}")  # 3

uf.union(0, 2)
print(f"Components: {uf.get_components()}")  # 2

print(f"0 and 3 connected: {uf.connected(0, 3)}")  # True
print(f"0 and 4 connected: {uf.connected(0, 4)}")  # False
```

---

## 9.7 Time Complexity Analysis

### With Both Optimizations

```
Time Complexity per operation: O(α(n))

α(n) = Inverse Ackermann function

For all practical purposes:
α(n) ≤ 4 for any n ≤ 10^600

This means: O(α(n)) ≈ O(1) amortized!

For m operations on n elements:
Total time: O(m × α(n)) ≈ O(m)
```

### Comparison

| Implementation | Find | Union |
|----------------|------|-------|
| Naive | O(n) | O(n) |
| Path Compression only | O(log n) amortized | O(log n) |
| Union by Rank only | O(log n) | O(log n) |
| Both optimizations | O(α(n)) ≈ O(1) | O(α(n)) ≈ O(1) |

---

## 9.8 Applications

### Application 1: Cycle Detection in Undirected Graph

```python
def has_cycle(n, edges):
    """
    Detect cycle in undirected graph using Union-Find
    
    Key insight: If two vertices are already connected
    and we try to add an edge between them → cycle!
    """
    uf = UnionFind(n)
    
    for u, v in edges:
        if uf.connected(u, v):
            return True  # Already connected → adding edge creates cycle
        uf.union(u, v)
    
    return False


# Example
edges_with_cycle = [(0, 1), (1, 2), (2, 0)]  # Triangle
print(has_cycle(3, edges_with_cycle))  # True

edges_no_cycle = [(0, 1), (1, 2)]  # Line
print(has_cycle(3, edges_no_cycle))  # False
```

### Application 2: Number of Connected Components

```python
def count_components(n, edges):
    """
    Count connected components in undirected graph
    """
    uf = UnionFind(n)
    
    for u, v in edges:
        uf.union(u, v)
    
    return uf.get_components()


# Example
# Graph: 0-1-2  3-4  5 (three components)
edges = [(0, 1), (1, 2), (3, 4)]
print(count_components(6, edges))  # 3
```

### Application 3: Number of Islands (Grid)

```python
def num_islands(grid):
    """
    Count islands in a grid using Union-Find
    """
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    
    # Map 2D coordinates to 1D index
    def index(r, c):
        return r * cols + c
    
    uf = UnionFind(rows * cols)
    
    # Count land cells
    land_count = 0
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                land_count += 1
                
                # Union with adjacent land cells
                for dr, dc in [(0, 1), (1, 0)]:  # Only right and down
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == '1':
                        if uf.union(index(r, c), index(nr, nc)):
                            land_count -= 1  # Merged two land cells
    
    return land_count
```

### Application 4: Accounts Merge

```python
def accounts_merge(accounts):
    """
    LeetCode 721: Accounts Merge
    Merge accounts with common emails
    """
    from collections import defaultdict
    
    email_to_id = {}  # Map email to account ID
    email_to_name = {}  # Map email to account name
    
    n = len(accounts)
    uf = UnionFind(n)
    
    # Build email mappings
    for i, account in enumerate(accounts):
        name = account[0]
        for email in account[1:]:
            email_to_name[email] = name
            
            if email in email_to_id:
                # Email seen before - union the accounts
                uf.union(i, email_to_id[email])
            else:
                email_to_id[email] = i
    
    # Group emails by root account
    root_to_emails = defaultdict(set)
    for email, account_id in email_to_id.items():
        root = uf.find(account_id)
        root_to_emails[root].add(email)
    
    # Build result
    result = []
    for root, emails in root_to_emails.items():
        name = email_to_name[next(iter(emails))]
        result.append([name] + sorted(emails))
    
    return result
```

### Application 5: Redundant Connection

```python
def find_redundant_connection(edges):
    """
    LeetCode 684: Redundant Connection
    Find the edge that creates a cycle
    
    Return the last edge in the input that, when removed,
    results in a tree.
    """
    n = len(edges)
    uf = UnionFind(n + 1)  # 1-indexed vertices
    
    for u, v in edges:
        if not uf.union(u, v):
            # u and v already connected - this edge creates cycle!
            return [u, v]
    
    return []


# Example
edges = [[1,2], [1,3], [2,3]]
print(find_redundant_connection(edges))  # [2, 3]
```

---

## 9.9 Advanced Techniques

### Weighted Union-Find (Union by Weight/Size)

```python
class WeightedUnionFind:
    """
    Union-Find that tracks the size of each component
    Useful for problems that need component sizes
    """
    
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n
        self.max_size = 1
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        root_x, root_y = self.find(x), self.find(y)
        
        if root_x == root_y:
            return self.size[root_x]
        
        # Union by size
        if self.size[root_x] < self.size[root_y]:
            root_x, root_y = root_y, root_x
        
        self.parent[root_y] = root_x
        self.size[root_x] += self.size[root_y]
        self.max_size = max(self.max_size, self.size[root_x])
        
        return self.size[root_x]
    
    def get_size(self, x):
        return self.size[self.find(x)]
    
    def get_max_size(self):
        return self.max_size
```

### Union-Find with Distance/Weight on Edges

```python
class UnionFindWithWeight:
    """
    Union-Find where edges have weights
    Tracks relative weight/distance between elements
    
    Used in: Evaluate Division (LeetCode 399)
    """
    
    def __init__(self, n):
        self.parent = list(range(n))
        self.weight = [1.0] * n  # weight[x] = weight of edge to parent
    
    def find(self, x):
        if self.parent[x] != x:
            original_parent = self.parent[x]
            self.parent[x] = self.find(self.parent[x])
            self.weight[x] *= self.weight[original_parent]
        return self.parent[x]
    
    def union(self, x, y, w):
        """
        Union x and y such that x/y = w
        """
        root_x, root_y = self.find(x), self.find(y)
        
        if root_x == root_y:
            return
        
        # x/root_x = weight[x]
        # y/root_y = weight[y]
        # x/y = w
        # root_x/root_y = ?
        # root_x = x/weight[x], root_y = y/weight[y]
        # root_x/root_y = (x/weight[x]) / (y/weight[y])
        #               = (x/y) * (weight[y]/weight[x])
        #               = w * weight[y] / weight[x]
        
        self.parent[root_x] = root_y
        self.weight[root_x] = w * self.weight[y] / self.weight[x]
    
    def query(self, x, y):
        """
        Return x/y if known, else -1
        """
        root_x, root_y = self.find(x), self.find(y)
        
        if root_x != root_y:
            return -1.0
        
        # x/y = (x/root) / (y/root) = weight[x] / weight[y]
        return self.weight[x] / self.weight[y]
```

---

## 9.10 Common Interview Problems

### Problem 1: Number of Provinces

```python
def find_circle_num(isConnected):
    """
    LeetCode 547: Number of Provinces
    isConnected is adjacency matrix
    """
    n = len(isConnected)
    uf = UnionFind(n)
    
    for i in range(n):
        for j in range(i + 1, n):
            if isConnected[i][j] == 1:
                uf.union(i, j)
    
    return uf.get_components()
```

### Problem 2: Earliest Time When Everyone Becomes Friends

```python
def earliest_acq(logs, n):
    """
    LeetCode 1101: The Earliest Moment When Everyone Become Friends
    logs = [[timestamp, x, y], ...] sorted by timestamp
    """
    logs.sort()  # Sort by timestamp
    uf = UnionFind(n)
    
    for timestamp, x, y in logs:
        uf.union(x, y)
        
        if uf.get_components() == 1:
            return timestamp
    
    return -1
```

### Problem 3: Satisfiability of Equality Equations

```python
def equations_possible(equations):
    """
    LeetCode 990: Satisfiability of Equality Equations
    equations like ["a==b", "b!=a"]
    """
    uf = UnionFind(26)  # 26 lowercase letters
    
    # First pass: process all == equations
    for eq in equations:
        if eq[1] == '=':  # "x==y"
            x = ord(eq[0]) - ord('a')
            y = ord(eq[3]) - ord('a')
            uf.union(x, y)
    
    # Second pass: check all != equations
    for eq in equations:
        if eq[1] == '!':  # "x!=y"
            x = ord(eq[0]) - ord('a')
            y = ord(eq[3]) - ord('a')
            
            if uf.connected(x, y):
                return False  # Contradiction!
    
    return True
```

### Problem 4: Largest Component Size by Common Factor

```python
def largest_component_size(nums):
    """
    LeetCode 952: Largest Component Size by Common Factor
    Connect numbers that share a common factor > 1
    """
    from collections import defaultdict
    
    max_num = max(nums)
    uf = UnionFind(max_num + 1)
    
    # For each number, union it with its factors
    for num in nums:
        for factor in range(2, int(num ** 0.5) + 1):
            if num % factor == 0:
                uf.union(num, factor)
                uf.union(num, num // factor)
    
    # Count size of each component
    count = defaultdict(int)
    max_size = 0
    
    for num in nums:
        root = uf.find(num)
        count[root] += 1
        max_size = max(max_size, count[root])
    
    return max_size
```

---

## 9.11 Summary

### Key Takeaways

```
Union-Find Data Structure:
- Efficiently tracks disjoint sets
- Two main operations: Union and Find
- Key optimizations: Path Compression + Union by Rank
- Time: O(α(n)) ≈ O(1) per operation

When to Use Union-Find:
✓ Dynamic connectivity queries
✓ Cycle detection in undirected graphs
✓ Counting connected components
✓ Kruskal's MST algorithm
✓ Problems involving merging groups

When NOT to Use:
✗ Need to split sets (Union-Find can't efficiently undo)
✗ Need shortest paths (use BFS/Dijkstra)
✗ Directed graphs (Union-Find is for undirected)
```

### Quick Reference Template

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1
        return True
    
    def connected(self, x, y):
        return self.find(x) == self.find(y)
```

---

## 9.12 Practice Problems

### Basic
1. Number of Provinces (LC 547)
2. Redundant Connection (LC 684)
3. Number of Connected Components (LC 323)

### Medium
1. Accounts Merge (LC 721)
2. Satisfiability of Equality Equations (LC 990)
3. Number of Operations to Make Network Connected (LC 1319)
4. Most Stones Removed (LC 947)
5. Regions Cut By Slashes (LC 959)

### Hard
1. Redundant Connection II (LC 685)
2. Largest Component Size by Common Factor (LC 952)
3. Swim in Rising Water (LC 778)
4. Minimize Malware Spread (LC 924)
5. Couples Holding Hands (LC 765)
