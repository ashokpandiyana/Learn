# Chapter 8: Topological Sort
## Ordering Vertices in Directed Acyclic Graphs

---

## 8.1 What is Topological Sort?

### Definition

A **Topological Sort** of a Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge (u → v), vertex u comes **before** vertex v in the ordering.

```
DAG:
    (A) ──→ (B) ──→ (D)
     │       │
     │       ↓
     └─────→(C) ──→ (E)

Valid Topological Orders:
✓ A, B, C, D, E  (A before B, B before C and D, C before E)
✓ A, B, D, C, E  (also valid!)
✓ A, C, B, D, E  (wait... is this valid? Let's check)
  - A before C? ✓ (A→C exists)
  - A before B? ✓ (A→B exists)
  - But B→C exists, so B must come before C ✗

So valid orders are: [A,B,C,D,E], [A,B,D,C,E], etc.

Invalid Order:
✗ B, A, C, D, E  (B before A, but A→B requires A first!)
```

### Key Properties

```
┌─────────────────────────────────────────────────────────────────┐
│ Topological Sort Properties                                      │
├─────────────────────────────────────────────────────────────────┤
│ 1. Only exists for DAGs (Directed Acyclic Graphs)               │
│ 2. If graph has cycle → NO topological order exists             │
│ 3. May not be unique (multiple valid orderings possible)        │
│ 4. First vertex has in-degree 0                                 │
│ 5. Last vertex has out-degree 0                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Why No Cycles Allowed?

```
Graph with cycle:
    (A) ──→ (B)
     ↑       │
     │       ↓
    (D) ←── (C)

Cycle: A → B → C → D → A

Try to order:
- A must come before B (A→B)
- B must come before C (B→C)
- C must come before D (C→D)
- D must come before A (D→A)

But A must come before B, and D must come before A...
So: D before A before B before C before D before A...

IMPOSSIBLE! No valid ordering exists.
```

> ⚠️ **CRITICAL**: Topological sort only works on DAGs. If the graph has a cycle, topological ordering is impossible!

---

## 8.2 Real-World Applications

### Course Prerequisites

```
Courses and prerequisites:
- CS101: No prerequisites
- CS102: Requires CS101
- CS201: Requires CS101, CS102
- CS202: Requires CS201
- MATH101: No prerequisites
- CS301: Requires CS201, MATH101

Graph:
    CS101 ──→ CS102
      │         │
      ↓         ↓
    CS201 ←────┘
      │
      ↓
    CS202      MATH101
      ↑          │
      └────CS301←┘

Topological Order (one valid schedule):
CS101 → MATH101 → CS102 → CS201 → CS202 → CS301

or

MATH101 → CS101 → CS102 → CS201 → CS301 → CS202
```

### Build Systems

```
Source file dependencies:
main.cpp depends on utils.h, config.h
utils.cpp depends on utils.h
config.cpp depends on config.h

Compilation order (topological sort):
utils.h → config.h → utils.cpp → config.cpp → main.cpp
```

### Task Scheduling

```
Tasks with dependencies:
Task A: No dependencies
Task B: Depends on A
Task C: Depends on A
Task D: Depends on B, C
Task E: Depends on D

Valid execution orders:
A → B → C → D → E
A → C → B → D → E
```

---

## 8.3 Kahn's Algorithm (BFS-Based)

### Concept

Kahn's algorithm uses **in-degree** counting:
1. Find all vertices with in-degree 0 (no prerequisites)
2. Remove them from graph (add to result)
3. Update in-degrees of neighbors
4. Repeat until all vertices processed

```
Key Insight:
Vertices with in-degree 0 have no dependencies → can be processed first!
After processing, reduce in-degrees of dependents.
```

### Visual Walkthrough

```
Graph:
    (0) ──→ (1) ──→ (3)
     │       │
     ↓       ↓
    (2) ──→ (4)

Calculate in-degrees:
Vertex: 0  1  2  3  4
In-deg: 0  1  1  1  2

Step 1: Find in-degree 0 vertices
Queue: [0]
Result: []

Step 2: Process vertex 0
Remove 0, add to result
Update neighbors (1, 2): decrease their in-degrees
In-deg: 0  0  0  1  2
Queue: [1, 2]
Result: [0]

Step 3: Process vertex 1
Remove 1, add to result
Update neighbors (3, 4): decrease their in-degrees
In-deg: 0  0  0  0  1
Queue: [2, 3]
Result: [0, 1]

Step 4: Process vertex 2
Remove 2, add to result
Update neighbor (4): decrease in-degree
In-deg: 0  0  0  0  0
Queue: [3, 4]
Result: [0, 1, 2]

Step 5: Process vertex 3
Remove 3, add to result
No neighbors to update
Queue: [4]
Result: [0, 1, 2, 3]

Step 6: Process vertex 4
Remove 4, add to result
Queue: []
Result: [0, 1, 2, 3, 4]

Final topological order: [0, 1, 2, 3, 4]
```

### Implementation

```python
from collections import deque, defaultdict

def topological_sort_kahn(n, edges):
    """
    Kahn's Algorithm for Topological Sort (BFS-based)
    
    Args:
        n: number of vertices (0 to n-1)
        edges: list of (u, v) tuples representing u → v
    
    Returns:
        List of vertices in topological order, or [] if cycle exists
    """
    # Build adjacency list and calculate in-degrees
    graph = defaultdict(list)
    in_degree = [0] * n
    
    for u, v in edges:
        graph[u].append(v)
        in_degree[v] += 1
    
    # Initialize queue with all vertices having in-degree 0
    queue = deque()
    for i in range(n):
        if in_degree[i] == 0:
            queue.append(i)
    
    topo_order = []
    
    while queue:
        # Remove vertex with in-degree 0
        vertex = queue.popleft()
        topo_order.append(vertex)
        
        # Reduce in-degree of neighbors
        for neighbor in graph[vertex]:
            in_degree[neighbor] -= 1
            
            # If neighbor now has in-degree 0, add to queue
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    # Check if all vertices were processed
    if len(topo_order) != n:
        return []  # Cycle detected! Not all vertices could be processed
    
    return topo_order


# Example Usage
edges = [
    (0, 1), (0, 2),  # 0 → 1, 0 → 2
    (1, 3), (1, 4),  # 1 → 3, 1 → 4
    (2, 4)           # 2 → 4
]

result = topological_sort_kahn(5, edges)
print(f"Topological Order: {result}")  # [0, 1, 2, 3, 4] or [0, 2, 1, 3, 4]
```

### Detecting Cycles with Kahn's

```python
def has_cycle_kahn(n, edges):
    """
    Detect cycle using Kahn's algorithm
    If we can't process all vertices, there's a cycle!
    """
    graph = defaultdict(list)
    in_degree = [0] * n
    
    for u, v in edges:
        graph[u].append(v)
        in_degree[v] += 1
    
    queue = deque([i for i in range(n) if in_degree[i] == 0])
    processed = 0
    
    while queue:
        vertex = queue.popleft()
        processed += 1
        
        for neighbor in graph[vertex]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    return processed != n  # True if cycle exists


# Example with cycle
edges_with_cycle = [(0, 1), (1, 2), (2, 0)]  # 0→1→2→0
print(has_cycle_kahn(3, edges_with_cycle))  # True

edges_no_cycle = [(0, 1), (1, 2)]  # 0→1→2
print(has_cycle_kahn(3, edges_no_cycle))  # False
```

### Complexity Analysis

```
Time Complexity:
- Building graph: O(E)
- Calculating in-degrees: O(E)
- Processing vertices: Each vertex processed once O(V)
- Processing edges: Each edge processed once O(E)

Total: O(V + E)

Space Complexity:
- Adjacency list: O(V + E)
- In-degree array: O(V)
- Queue: O(V)

Total: O(V + E)
```

---

## 8.4 DFS-Based Topological Sort

### Concept

Use DFS and add vertices to result in **post-order** (after processing all descendants). Reverse the result for topological order.

```
Key Insight:
In DFS, when we finish processing a vertex (all descendants done),
that vertex can come AFTER all its descendants in topological order.

Post-order gives reverse topological order!
```

### Visual Walkthrough

```
Graph:
    (0) ──→ (1) ──→ (3)
     │       │
     ↓       ↓
    (2) ──→ (4)

DFS from vertex 0:

dfs(0):
  │
  ├── dfs(1):
  │     │
  │     ├── dfs(3):
  │     │     └── finish 3, post_order = [3]
  │     │
  │     └── dfs(4):  (4 not yet visited)
  │           └── finish 4, post_order = [3, 4]
  │     
  │     └── finish 1, post_order = [3, 4, 1]
  │
  └── dfs(2):
        │
        └── dfs(4): already visited, skip
        
        └── finish 2, post_order = [3, 4, 1, 2]
  
  └── finish 0, post_order = [3, 4, 1, 2, 0]

Reverse post_order: [0, 2, 1, 4, 3]

This is a valid topological order!
```

### Implementation

```python
def topological_sort_dfs(n, edges):
    """
    DFS-based Topological Sort
    
    Args:
        n: number of vertices (0 to n-1)
        edges: list of (u, v) tuples representing u → v
    
    Returns:
        List of vertices in topological order, or [] if cycle exists
    """
    # Build adjacency list
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
    
    # States: 0 = unvisited, 1 = in current path, 2 = completed
    WHITE, GRAY, BLACK = 0, 1, 2
    state = [WHITE] * n
    
    post_order = []
    has_cycle = False
    
    def dfs(vertex):
        nonlocal has_cycle
        
        if has_cycle:
            return
        
        state[vertex] = GRAY  # Mark as in current DFS path
        
        for neighbor in graph[vertex]:
            if state[neighbor] == GRAY:
                # Back edge found - cycle!
                has_cycle = True
                return
            if state[neighbor] == WHITE:
                dfs(neighbor)
        
        state[vertex] = BLACK  # Mark as completed
        post_order.append(vertex)  # Add to post-order
    
    # Run DFS from all unvisited vertices
    for i in range(n):
        if state[i] == WHITE:
            dfs(i)
    
    if has_cycle:
        return []
    
    return post_order[::-1]  # Reverse post-order = topological order


# Example
edges = [(0, 1), (0, 2), (1, 3), (1, 4), (2, 4)]
result = topological_sort_dfs(5, edges)
print(f"Topological Order: {result}")  # [0, 2, 1, 4, 3]
```

### Iterative DFS Version

```python
def topological_sort_dfs_iterative(n, edges):
    """
    Iterative DFS-based Topological Sort
    """
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
    
    WHITE, GRAY, BLACK = 0, 1, 2
    state = [WHITE] * n
    post_order = []
    
    for start in range(n):
        if state[start] != WHITE:
            continue
        
        stack = [(start, False)]  # (vertex, is_processed)
        
        while stack:
            vertex, processed = stack.pop()
            
            if processed:
                post_order.append(vertex)
                state[vertex] = BLACK
                continue
            
            if state[vertex] == GRAY:
                # Already being processed - cycle!
                return []
            
            if state[vertex] == BLACK:
                continue
            
            state[vertex] = GRAY
            stack.append((vertex, True))  # Will add to post_order later
            
            for neighbor in graph[vertex]:
                if state[neighbor] == GRAY:
                    return []  # Cycle!
                if state[neighbor] == WHITE:
                    stack.append((neighbor, False))
    
    return post_order[::-1]
```

---

## 8.5 Kahn's vs DFS Comparison

```
┌─────────────────────────────────────────────────────────────────┐
│              Topological Sort Algorithm Comparison               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  KAHN'S (BFS)                     DFS-BASED                     │
│  ───────────                      ─────────                     │
│  • Uses in-degree counting        • Uses post-order traversal   │
│  • Iterative with queue           • Recursive (or stack)        │
│  • Natural level-by-level         • Explores deeply first       │
│  • Easy cycle detection           • Also detects cycles         │
│  • Can find vertices at           • Harder to identify levels   │
│    same "level"                                                 │
│                                                                 │
│  Time: O(V + E)                   Time: O(V + E)                │
│  Space: O(V + E)                  Space: O(V + E)               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

When to use which?
- Kahn's: When you need level information (parallel scheduling)
- DFS: When you want simpler recursive code
- Both: Work equally well for basic topological sort
```

---

## 8.6 Finding All Topological Orders

```python
def all_topological_sorts(n, edges):
    """
    Find ALL valid topological orderings using backtracking
    """
    graph = defaultdict(list)
    in_degree = [0] * n
    
    for u, v in edges:
        graph[u].append(v)
        in_degree[v] += 1
    
    result = []
    current = []
    visited = [False] * n
    
    def backtrack():
        # If all vertices added, we found a valid order
        if len(current) == n:
            result.append(current.copy())
            return
        
        # Try each vertex with in-degree 0
        for v in range(n):
            if not visited[v] and in_degree[v] == 0:
                # Choose vertex v
                visited[v] = True
                current.append(v)
                
                # Reduce in-degrees of neighbors
                for neighbor in graph[v]:
                    in_degree[neighbor] -= 1
                
                # Recurse
                backtrack()
                
                # Backtrack: undo the choice
                visited[v] = False
                current.pop()
                for neighbor in graph[v]:
                    in_degree[neighbor] += 1
    
    backtrack()
    return result


# Example
edges = [(0, 1), (0, 2), (1, 3), (2, 3)]
all_orders = all_topological_sorts(4, edges)
print(f"All topological orders: {all_orders}")
# [[0, 1, 2, 3], [0, 2, 1, 3]]
```

---

## 8.7 Topological Sort with Levels (Parallel Scheduling)

### Finding Minimum Number of Semesters

```python
def minimum_semesters(n, relations):
    """
    LeetCode 1136: Parallel Courses
    Find minimum semesters to complete all courses
    
    Key: Use Kahn's algorithm with level tracking
    Each level = one semester (parallel processing)
    """
    graph = defaultdict(list)
    in_degree = [0] * (n + 1)  # 1-indexed
    
    for prev, next_course in relations:
        graph[prev].append(next_course)
        in_degree[next_course] += 1
    
    # Start with all courses that have no prerequisites
    queue = deque()
    for i in range(1, n + 1):
        if in_degree[i] == 0:
            queue.append(i)
    
    semesters = 0
    courses_taken = 0
    
    while queue:
        semesters += 1
        # Process ALL courses at current level (one semester)
        level_size = len(queue)
        
        for _ in range(level_size):
            course = queue.popleft()
            courses_taken += 1
            
            for next_course in graph[course]:
                in_degree[next_course] -= 1
                if in_degree[next_course] == 0:
                    queue.append(next_course)
    
    return semesters if courses_taken == n else -1  # -1 if impossible (cycle)


# Example
#   1 → 3
#   2 → 3 → 4
relations = [(1, 3), (2, 3), (3, 4)]
print(minimum_semesters(4, relations))  # 3
# Semester 1: [1, 2], Semester 2: [3], Semester 3: [4]
```

### Visualization of Level-Based Processing

```
Graph:
    (1)──┐
         ├──→(3)──→(4)
    (2)──┘      │
                ↓
               (5)

Level 0 (in-degree 0): [1, 2]    ← Can do in parallel
Level 1: [3]                      ← After 1 and 2
Level 2: [4, 5]                   ← Can do in parallel

Minimum semesters/time = 3
```

---

## 8.8 Common Interview Problems

### Problem 1: Course Schedule (Cycle Detection)

```python
def can_finish(numCourses, prerequisites):
    """
    LeetCode 207: Course Schedule
    Return true if possible to finish all courses
    """
    graph = defaultdict(list)
    in_degree = [0] * numCourses
    
    for course, prereq in prerequisites:
        graph[prereq].append(course)
        in_degree[course] += 1
    
    queue = deque([i for i in range(numCourses) if in_degree[i] == 0])
    completed = 0
    
    while queue:
        course = queue.popleft()
        completed += 1
        
        for next_course in graph[course]:
            in_degree[next_course] -= 1
            if in_degree[next_course] == 0:
                queue.append(next_course)
    
    return completed == numCourses
```

### Problem 2: Course Schedule II (Return Order)

```python
def find_order(numCourses, prerequisites):
    """
    LeetCode 210: Course Schedule II
    Return the order of courses to take
    """
    graph = defaultdict(list)
    in_degree = [0] * numCourses
    
    for course, prereq in prerequisites:
        graph[prereq].append(course)
        in_degree[course] += 1
    
    queue = deque([i for i in range(numCourses) if in_degree[i] == 0])
    order = []
    
    while queue:
        course = queue.popleft()
        order.append(course)
        
        for next_course in graph[course]:
            in_degree[next_course] -= 1
            if in_degree[next_course] == 0:
                queue.append(next_course)
    
    return order if len(order) == numCourses else []
```

### Problem 3: Alien Dictionary

```python
def alien_order(words):
    """
    LeetCode 269: Alien Dictionary
    Given sorted words in alien language, find character order
    """
    # Build graph from adjacent word pairs
    graph = defaultdict(set)
    in_degree = {c: 0 for word in words for c in word}
    
    for i in range(len(words) - 1):
        w1, w2 = words[i], words[i + 1]
        
        # Check for invalid case: "abc" before "ab"
        if len(w1) > len(w2) and w1[:len(w2)] == w2:
            return ""
        
        # Find first different character
        for c1, c2 in zip(w1, w2):
            if c1 != c2:
                if c2 not in graph[c1]:
                    graph[c1].add(c2)
                    in_degree[c2] += 1
                break
    
    # Kahn's algorithm
    queue = deque([c for c in in_degree if in_degree[c] == 0])
    result = []
    
    while queue:
        c = queue.popleft()
        result.append(c)
        
        for neighbor in graph[c]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    if len(result) != len(in_degree):
        return ""  # Cycle detected
    
    return "".join(result)


# Example
words = ["wrt", "wrf", "er", "ett", "rftt"]
print(alien_order(words))  # "wertf"
```

### Problem 4: Longest Path in DAG

```python
def longest_path_dag(n, edges):
    """
    Find longest path in a DAG using topological sort + DP
    """
    graph = defaultdict(list)
    in_degree = [0] * n
    
    for u, v in edges:
        graph[u].append(v)
        in_degree[v] += 1
    
    # Get topological order
    queue = deque([i for i in range(n) if in_degree[i] == 0])
    topo_order = []
    
    while queue:
        node = queue.popleft()
        topo_order.append(node)
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    # DP: dist[v] = longest path ending at v
    dist = [0] * n
    
    for node in topo_order:
        for neighbor in graph[node]:
            dist[neighbor] = max(dist[neighbor], dist[node] + 1)
    
    return max(dist)
```

---

## 8.9 Summary

### Key Takeaways

```
Topological Sort Essentials:
1. Only works on DAGs (no cycles!)
2. Linear ordering where u comes before v for all edges u→v
3. May not be unique - multiple valid orderings possible

Kahn's Algorithm (BFS):
- Use in-degree counting
- Process vertices with in-degree 0
- Time: O(V + E)

DFS-Based:
- Post-order traversal, then reverse
- Three-color cycle detection
- Time: O(V + E)

Cycle Detection:
- Kahn's: processed < n vertices → cycle
- DFS: back edge (GRAY → GRAY) → cycle
```

### Quick Reference Templates

```python
# Kahn's Algorithm Template
def kahn(n, edges):
    in_degree = [0] * n
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        in_degree[v] += 1
    
    queue = deque([i for i in range(n) if in_degree[i] == 0])
    order = []
    
    while queue:
        node = queue.popleft()
        order.append(node)
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    return order if len(order) == n else []

# DFS Template
def topo_dfs(n, edges):
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
    
    WHITE, GRAY, BLACK = 0, 1, 2
    state = [WHITE] * n
    result = []
    
    def dfs(node):
        state[node] = GRAY
        for nei in graph[node]:
            if state[nei] == GRAY:
                return False
            if state[nei] == WHITE and not dfs(nei):
                return False
        state[node] = BLACK
        result.append(node)
        return True
    
    for i in range(n):
        if state[i] == WHITE and not dfs(i):
            return []
    
    return result[::-1]
```

---

## 8.10 Practice Problems

1. Course Schedule (LC 207)
2. Course Schedule II (LC 210)
3. Alien Dictionary (LC 269)
4. Parallel Courses (LC 1136)
5. Sequence Reconstruction (LC 444)
6. Minimum Height Trees (LC 310)
7. Longest Increasing Path in Matrix (LC 329)
8. Sort Items by Groups (LC 1203)
