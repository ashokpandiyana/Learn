# Chapter 1: Graph Fundamentals
## A Complete Deep Dive into Graph Basics

---

## 1.1 What is a Graph?

### Mathematical Definition

A **Graph** is formally defined as an ordered pair **G = (V, E)** where:
- **V** = Set of vertices (also called nodes)
- **E** = Set of edges (connections between vertices)

Each edge connects two vertices. In mathematical notation:
- For undirected graphs: E âŠ† {{u, v} | u, v âˆˆ V}
- For directed graphs: E âŠ† {(u, v) | u, v âˆˆ V}

### Real-World Analogy

Think of a graph like a social network:
- **People** = Vertices/Nodes
- **Friendships** = Edges

```
    Alice -------- Bob
      |            /
      |           /
      |          /
    Charlie ----+
```

In this social network:
- V = {Alice, Bob, Charlie}
- E = {(Alice, Bob), (Alice, Charlie), (Bob, Charlie)}

### Why Graphs Matter

Graphs model relationships and are everywhere:
- ðŸŒ Internet (web pages linked by hyperlinks)
- ðŸ—ºï¸ Maps (cities connected by roads)
- ðŸ‘¥ Social Networks (people connected by relationships)
- ðŸ’» Computer Networks (devices connected by cables/wifi)
- ðŸ§¬ Biology (protein interaction networks)
- ðŸ“¦ Dependencies (software packages, course prerequisites)

---

## 1.2 Graph Terminology (Complete Glossary)

### Basic Terms

#### Vertex (Node)
The fundamental unit of a graph. Represents an entity.

```
Vertex representation:
    ( A )    ( B )    ( C )
    
Each circle is a vertex/node
```

#### Edge
A connection between two vertices. Represents a relationship.

```
Edge connecting A and B:
    ( A ) â€”â€”â€”â€”â€”â€”â€”â€” ( B )
           edge
```

#### Adjacent Vertices
Two vertices are **adjacent** if they share an edge.

```
A and B are adjacent:
    ( A ) â€”â€”â€”â€” ( B )
    
A and C are NOT adjacent:
    ( A ) â€”â€”â€”â€” ( B ) â€”â€”â€”â€” ( C )
```

### Degree Concepts

#### Degree of a Vertex
The **degree** of a vertex is the number of edges connected to it.

```
        ( B )
         /|\
        / | \
       /  |  \
    (A)  (C)  (D)
    
Degree of B = 3 (connected to A, C, D)
Degree of A = 1 (connected only to B)
```

**Mathematical Property**: 
> Sum of all degrees = 2 Ã— Number of edges
> 
> This is called the **Handshaking Lemma**

```python
def calculate_degrees(graph):
    """
    Calculate degree of each vertex
    graph: adjacency list representation
    """
    degrees = {}
    for vertex in graph:
        degrees[vertex] = len(graph[vertex])
    return degrees

# Example
graph = {
    'A': ['B'],
    'B': ['A', 'C', 'D'],
    'C': ['B'],
    'D': ['B']
}
print(calculate_degrees(graph))
# Output: {'A': 1, 'B': 3, 'C': 1, 'D': 1}
# Sum = 1 + 3 + 1 + 1 = 6 = 2 Ã— 3 edges âœ“
```

#### In-Degree and Out-Degree (Directed Graphs Only)

For directed graphs, we distinguish:
- **In-degree**: Number of edges coming INTO a vertex
- **Out-degree**: Number of edges going OUT from a vertex

```
Directed Graph:
    (A) â€”â€”â†’ (B) â€”â€”â†’ (C)
     â†“       â†‘
     â†“       |
     +â€”â€”â†’ (D)â€”â€”+

In-degrees:  A=0, B=2, C=1, D=1
Out-degrees: A=2, B=1, C=0, D=1
```

```python
def calculate_directed_degrees(graph):
    """
    Calculate in-degree and out-degree for directed graph
    """
    vertices = set(graph.keys())
    for neighbors in graph.values():
        vertices.update(neighbors)
    
    in_degree = {v: 0 for v in vertices}
    out_degree = {v: 0 for v in vertices}
    
    for vertex in graph:
        out_degree[vertex] = len(graph[vertex])
        for neighbor in graph[vertex]:
            in_degree[neighbor] += 1
    
    return in_degree, out_degree

# Example
directed_graph = {
    'A': ['B', 'D'],
    'B': ['C'],
    'C': [],
    'D': ['B']
}
in_deg, out_deg = calculate_directed_degrees(directed_graph)
print(f"In-degrees: {in_deg}")   # {'A': 0, 'B': 2, 'C': 1, 'D': 1}
print(f"Out-degrees: {out_deg}") # {'A': 2, 'B': 1, 'C': 0, 'D': 1}
```

### Path Concepts

#### Path
A **path** is a sequence of vertices where each adjacent pair is connected by an edge.

```
Path from A to D:
    (A) â€”â€” (B) â€”â€” (C) â€”â€” (D)
    
Path: A â†’ B â†’ C â†’ D
Length: 3 (number of edges)
```

#### Simple Path
A path where **no vertex is repeated**.

```
Simple Path: A â†’ B â†’ C â†’ D  (all vertices unique)
NOT Simple:  A â†’ B â†’ C â†’ B â†’ D  (B repeated)
```

#### Cycle
A path that **starts and ends at the same vertex**.

```
Cycle: A â†’ B â†’ C â†’ A

    (A) â€”â€”â€”â€” (B)
      \      /
       \    /
        (C)
```

```python
def has_path(graph, start, end, visited=None):
    """
    Check if path exists between start and end (DFS)
    """
    if visited is None:
        visited = set()
    
    if start == end:
        return True
    
    visited.add(start)
    
    for neighbor in graph.get(start, []):
        if neighbor not in visited:
            if has_path(graph, neighbor, end, visited):
                return True
    
    return False

# Example
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A'],
    'D': ['B']
}
print(has_path(graph, 'A', 'D'))  # True (Aâ†’Bâ†’D)
print(has_path(graph, 'C', 'D'))  # True (Câ†’Aâ†’Bâ†’D)
```

### Connectivity Concepts

#### Connected Graph (Undirected)
An undirected graph is **connected** if there's a path between every pair of vertices.

```
Connected:              NOT Connected:
    (A)â€”(B)                (A)â€”(B)    (D)â€”(E)
     |   |                  |   |
    (C)â€”(D)                (C)â€”â€”â€”+

Every vertex reachable    D,E not reachable from A,B,C
```

#### Connected Component
A **maximal** connected subgraph. In a disconnected graph, we have multiple connected components.

```
Graph with 2 connected components:

Component 1:    Component 2:
    (A)â€”(B)        (D)
     |   |          |
    (C)â€”â€”â€”+        (E)â€”(F)
```

```python
def find_connected_components(graph):
    """
    Find all connected components in undirected graph
    """
    visited = set()
    components = []
    
    def dfs(node, component):
        visited.add(node)
        component.append(node)
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                dfs(neighbor, component)
    
    for vertex in graph:
        if vertex not in visited:
            component = []
            dfs(vertex, component)
            components.append(component)
    
    return components

# Example
graph = {
    'A': ['B', 'C'], 'B': ['A', 'C'], 'C': ['A', 'B'],
    'D': ['E'], 'E': ['D', 'F'], 'F': ['E']
}
print(find_connected_components(graph))
# Output: [['A', 'B', 'C'], ['D', 'E', 'F']]
```

#### Strongly Connected (Directed Graphs)
A directed graph is **strongly connected** if there's a directed path from every vertex to every other vertex.

```
Strongly Connected:        NOT Strongly Connected:
    (A) â‡„ (B)                 (A) â†’ (B)
     â‡…     â‡…                   â†“     â†“
    (D) â‡„ (C)                 (D) â†’ (C)
    
Can go Aâ†’Bâ†’Câ†’Dâ†’A           Can't go from C back to A
```

---

## 1.3 Types of Graphs

### Classification by Direction

#### Undirected Graph
Edges have **no direction** - connection goes both ways.

```
Undirected:
    (A) â€”â€”â€”â€” (B)
    
If A connects to B, then B connects to A
Edge notation: {A, B} or (A, B)
```

```python
# Undirected graph - add edges both ways
def add_undirected_edge(graph, u, v):
    graph[u].append(v)
    graph[v].append(u)

from collections import defaultdict
graph = defaultdict(list)
add_undirected_edge(graph, 'A', 'B')
add_undirected_edge(graph, 'B', 'C')

print(dict(graph))
# {'A': ['B'], 'B': ['A', 'C'], 'C': ['B']}
```

#### Directed Graph (Digraph)
Edges have **direction** - one-way connections.

```
Directed:
    (A) â€”â€”â€”â€”â†’ (B)
    
A connects to B, but B does NOT connect to A
Edge notation: (A, B) means A â†’ B
```

```python
# Directed graph - add edge one way only
def add_directed_edge(graph, u, v):
    graph[u].append(v)
    # Note: we do NOT add vâ†’u

from collections import defaultdict
graph = defaultdict(list)
add_directed_edge(graph, 'A', 'B')
add_directed_edge(graph, 'B', 'C')

print(dict(graph))
# {'A': ['B'], 'B': ['C']}
# Note: C has no outgoing edges, A has no incoming edges
```

### Classification by Weight

#### Unweighted Graph
All edges have **equal weight** (or weight = 1).

```
Unweighted:
    (A) â€”â€”â€”â€” (B) â€”â€”â€”â€” (C)
    
All edges are "equal" - no cost difference
```

#### Weighted Graph
Edges have **associated costs/weights**.

```
Weighted:
    (A) â€”â€”5â€”â€” (B) â€”â€”3â€”â€” (C)
         \          /
          \â€”â€”10â€”â€”/
    
Edge A-B costs 5
Edge B-C costs 3
Edge A-C costs 10
```

```python
# Weighted graph representation
from collections import defaultdict

# Method 1: Adjacency list with tuples (neighbor, weight)
weighted_graph = defaultdict(list)
weighted_graph['A'].append(('B', 5))
weighted_graph['A'].append(('C', 10))
weighted_graph['B'].append(('A', 5))
weighted_graph['B'].append(('C', 3))
weighted_graph['C'].append(('A', 10))
weighted_graph['C'].append(('B', 3))

# Method 2: Dictionary of dictionaries
weighted_graph2 = {
    'A': {'B': 5, 'C': 10},
    'B': {'A': 5, 'C': 3},
    'C': {'A': 10, 'B': 3}
}

# Access weight of edge Aâ†’B
print(weighted_graph2['A']['B'])  # 5
```

### Special Graph Types

#### Simple Graph
- No **self-loops** (edge from vertex to itself)
- No **multiple edges** between same pair of vertices

```
Simple Graph:           NOT Simple (has self-loop):
    (A)â€”â€”(B)               (A)â€”â€”(B)
     |                      |    â†º
    (C)                    (C)
```

#### Complete Graph (Kâ‚™)
Every vertex is connected to **every other vertex**.

```
Complete Graph Kâ‚„:
      (A)
     /|\\ 
    / | \\
   /  |  \\
 (B)â€”â€”+â€”â€”(D)
   \\  |  /
    \\ | /
      (C)

Number of edges in Kâ‚™ = n(n-1)/2
Kâ‚„ has 4Ã—3/2 = 6 edges
```

```python
def create_complete_graph(n):
    """Create complete graph with n vertices (0 to n-1)"""
    graph = defaultdict(list)
    for i in range(n):
        for j in range(n):
            if i != j:
                graph[i].append(j)
    return graph

# Complete graph with 4 vertices
K4 = create_complete_graph(4)
# Each vertex connects to 3 others
```

#### Bipartite Graph
Vertices can be divided into **two disjoint sets** where edges only connect vertices from different sets.

```
Bipartite Graph:
Set 1: {A, B}     Set 2: {X, Y, Z}

    (A)         (X)
     |\\       //|
     | \\     // |
     |  \\   //  |
     |   \\ //   |
    (B)â€”â€”â€”â€”â€”â€”(Y)
              \\
               (Z)

Edges only between Set 1 and Set 2
```

```python
def is_bipartite(graph):
    """
    Check if graph is bipartite using BFS coloring
    """
    color = {}
    
    for start in graph:
        if start in color:
            continue
        
        # BFS with 2-coloring
        queue = [start]
        color[start] = 0
        
        while queue:
            node = queue.pop(0)
            for neighbor in graph[node]:
                if neighbor not in color:
                    color[neighbor] = 1 - color[node]
                    queue.append(neighbor)
                elif color[neighbor] == color[node]:
                    return False  # Same color = not bipartite
    
    return True

# Bipartite graph
bipartite = {
    'A': ['X', 'Y'],
    'B': ['Y', 'Z'],
    'X': ['A'],
    'Y': ['A', 'B'],
    'Z': ['B']
}
print(is_bipartite(bipartite))  # True

# Non-bipartite (triangle)
non_bipartite = {
    'A': ['B', 'C'],
    'B': ['A', 'C'],
    'C': ['A', 'B']
}
print(is_bipartite(non_bipartite))  # False
```

#### DAG (Directed Acyclic Graph)
A **directed** graph with **no cycles**.

```
DAG:                    NOT a DAG (has cycle):
    (A)                     (A)
   â†™   â†˜                   â†™   â†˜
 (B)    (C)              (B) â†’ (C)
   â†˜   â†™                   â†–   â†™
    (D)                     (D)

No way to return          Bâ†’Câ†’Dâ†’B forms cycle
to starting point
```

> âš ï¸ **CRITICAL**: DAGs are essential for:
> - Topological sorting
> - Dependency resolution
> - Task scheduling

#### Tree
A **connected acyclic undirected** graph.

```
Tree Properties:
- Connected: Can reach any node from any other
- Acyclic: No cycles
- N nodes = N-1 edges (always!)
- Exactly ONE path between any two nodes

Example Tree:
        (A)
       / | \
     (B)(C)(D)
     /       \
   (E)       (F)

6 nodes, 5 edges âœ“
```

> ðŸ’¡ **KEY INSIGHT**: A tree is a minimally connected graph. Remove any edge and it becomes disconnected.

---

## 1.4 Summary Table

| Property | Description | Example Use Case |
|----------|-------------|------------------|
| Directed | One-way edges | Twitter follows |
| Undirected | Two-way edges | Facebook friends |
| Weighted | Edges have costs | Road distances |
| Unweighted | Equal edge costs | Social connections |
| Cyclic | Contains cycles | Circular dependencies |
| Acyclic | No cycles | Task prerequisites |
| Connected | All vertices reachable | Network connectivity |
| Bipartite | Two-colorable | Matching problems |
| Complete | All pairs connected | Tournament schedules |
| Tree | Connected + Acyclic | Hierarchies |
| DAG | Directed + Acyclic | Build systems |

---

## 1.5 Visual Summary Diagram

```
                        GRAPHS
                          |
          +---------------+---------------+
          |                               |
      UNDIRECTED                      DIRECTED
          |                               |
    +-----+-----+                   +-----+-----+
    |           |                   |           |
 WEIGHTED  UNWEIGHTED            WEIGHTED  UNWEIGHTED
                                        |
                                   +----+----+
                                   |         |
                                 CYCLIC     DAG
                                          (Acyclic)

Special Types:
- Tree = Undirected + Connected + Acyclic
- Complete = Every pair connected
- Bipartite = 2-colorable
- Simple = No self-loops, no multi-edges
```

---

## Practice Problems for Chapter 1

1. **Degree Calculation**: Given an adjacency list, calculate the degree of each vertex.

2. **Graph Classification**: Given a graph, determine if it's:
   - Directed or Undirected
   - Connected or Disconnected
   - Cyclic or Acyclic

3. **Bipartite Check**: Determine if a given graph is bipartite.

4. **Tree Validation**: Given n nodes and n-1 edges, verify if it forms a valid tree.

5. **Complete Graph Edges**: For a complete graph with n vertices, calculate the number of edges.
