# Chapter 10: Cycle Detection
## Finding Loops in Graphs

---

## 10.1 What is a Cycle?

### Definition

A **cycle** is a path in a graph that starts and ends at the same vertex, with no repeated edges.

```
Cycle in Undirected Graph:
    (A)───(B)
     │     │
     │     │
    (D)───(C)

Cycle: A → B → C → D → A

Cycle in Directed Graph:
    (A)──→(B)
     ↑     │
     │     ↓
    (D)←──(C)

Cycle: A → B → C → D → A
```

### Why Detect Cycles?

```
┌─────────────────────────────────────────────────────────────────┐
│ Cycle Detection Applications                                     │
├─────────────────────────────────────────────────────────────────┤
│ • Deadlock detection in operating systems                       │
│ • Detecting circular dependencies (build systems, imports)      │
│ • Validating DAGs (topological sort requires no cycles)         │
│ • Finding redundant connections in networks                     │
│ • Detecting infinite loops in state machines                    │
│ • Course prerequisite validation                                │
│ • Detecting circular references in garbage collection           │
└─────────────────────────────────────────────────────────────────┘
```

### Key Difference: Directed vs Undirected

```
CRITICAL: Cycle detection is DIFFERENT for directed vs undirected graphs!

Undirected Graph:
    (A)───(B)
    
    A → B → A is NOT a cycle (just traversing same edge twice)
    
    (A)───(B)
     │     │
    (C)───(D)
    
    A → B → D → C → A IS a cycle (different edges)

Directed Graph:
    (A)──→(B)
     ↑     │
     └─────┘
    
    A → B → A IS a cycle (following directed edges)
```

---

## 10.2 Cycle Detection in Undirected Graphs

### Method 1: DFS with Parent Tracking

The key insight: In undirected graphs, we need to track the **parent** vertex to avoid false positives from the bidirectional nature of edges.

```
Why Parent Tracking?

    (A)───(B)
    
DFS from A:
- Visit A
- Go to B (via edge A-B)
- At B, neighbor A is visited!

Without parent: "A is visited → CYCLE!" (WRONG!)
With parent: "A is visited but A is parent → NOT a cycle" (CORRECT!)

Real Cycle:
    (A)───(B)
     │     │
    (C)───(D)

DFS from A → B → D → C:
- At C, neighbor A is visited
- A is NOT the parent of C (parent of C is D)
- Therefore, CYCLE DETECTED! (CORRECT!)
```

### Implementation: DFS with Parent

```python
def has_cycle_undirected_dfs(graph, n):
    """
    Detect cycle in undirected graph using DFS with parent tracking
    
    Args:
        graph: adjacency list (list of lists or dict)
        n: number of vertices
    
    Returns:
        True if cycle exists, False otherwise
    """
    visited = [False] * n
    
    def dfs(node, parent):
        visited[node] = True
        
        for neighbor in graph[node]:
            if not visited[neighbor]:
                # Explore unvisited neighbor
                if dfs(neighbor, node):
                    return True
            elif neighbor != parent:
                # Visited neighbor that's NOT parent = Back edge = Cycle!
                return True
        
        return False
    
    # Check all components (graph may be disconnected)
    for i in range(n):
        if not visited[i]:
            if dfs(i, -1):  # -1 indicates no parent (starting node)
                return True
    
    return False


# Example
# Graph with cycle: 0-1-2-3-0
graph_cycle = [
    [1, 3],  # 0: connected to 1, 3
    [0, 2],  # 1: connected to 0, 2
    [1, 3],  # 2: connected to 1, 3
    [2, 0]   # 3: connected to 2, 0
]
print(has_cycle_undirected_dfs(graph_cycle, 4))  # True

# Graph without cycle: 0-1-2-3 (line)
graph_no_cycle = [
    [1],     # 0
    [0, 2],  # 1
    [1, 3],  # 2
    [2]      # 3
]
print(has_cycle_undirected_dfs(graph_no_cycle, 4))  # False
```

### Visual Walkthrough: DFS with Parent

```
Graph:
    (0)───(1)
     │     │
    (3)───(2)

DFS starting from 0:

dfs(0, parent=-1):
    visited = [T, F, F, F]
    │
    ├── neighbor 1: not visited
    │   └── dfs(1, parent=0):
    │       visited = [T, T, F, F]
    │       │
    │       ├── neighbor 0: visited, but 0 == parent → skip
    │       │
    │       └── neighbor 2: not visited
    │           └── dfs(2, parent=1):
    │               visited = [T, T, T, F]
    │               │
    │               ├── neighbor 1: visited, but 1 == parent → skip
    │               │
    │               └── neighbor 3: not visited
    │                   └── dfs(3, parent=2):
    │                       visited = [T, T, T, T]
    │                       │
    │                       ├── neighbor 2: visited, 2 == parent → skip
    │                       │
    │                       └── neighbor 0: visited, 0 ≠ parent
    │                           └── CYCLE DETECTED! Return True
```

### Method 2: Union-Find

Using Union-Find, we detect a cycle when we try to union two vertices that are already in the same component.

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False  # Already connected = cycle!
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1
        return True


def has_cycle_undirected_union_find(n, edges):
    """
    Detect cycle using Union-Find
    
    Args:
        n: number of vertices
        edges: list of (u, v) tuples
    
    Returns:
        True if cycle exists
    """
    uf = UnionFind(n)
    
    for u, v in edges:
        if not uf.union(u, v):
            # u and v already connected → adding this edge creates cycle
            return True
    
    return False


# Example
edges_cycle = [(0, 1), (1, 2), (2, 3), (3, 0)]
print(has_cycle_undirected_union_find(4, edges_cycle))  # True

edges_no_cycle = [(0, 1), (1, 2), (2, 3)]
print(has_cycle_undirected_union_find(4, edges_no_cycle))  # False
```

### Visual: Union-Find Cycle Detection

```
Processing edges one by one:

Edge (0,1): Union 0 and 1
    Components: {0,1}, {2}, {3}
    
Edge (1,2): Union 1 and 2
    Components: {0,1,2}, {3}
    
Edge (2,3): Union 2 and 3
    Components: {0,1,2,3}
    
Edge (3,0): Try to union 3 and 0
    Find(3) = 0, Find(0) = 0
    Same root! Already connected!
    → CYCLE DETECTED!
```

### Comparison: DFS vs Union-Find

| Aspect | DFS with Parent | Union-Find |
|--------|-----------------|------------|
| Time | O(V + E) | O(E × α(V)) ≈ O(E) |
| Space | O(V) for visited + O(V) recursion | O(V) |
| Input format | Adjacency list | Edge list |
| Can find cycle path | Yes (with modification) | No |
| Online processing | No | Yes (process edges one by one) |

---

## 10.3 Cycle Detection in Directed Graphs

### Why Different from Undirected?

```
In directed graphs, we CAN'T use simple parent tracking!

    (A)──→(B)
     │     │
     ↓     ↓
    (C)──→(D)

DFS from A → B → D, then A → C → D
When we reach D from C, D is already visited.
Is this a cycle? NO! It's just two paths converging.

But in:
    (A)──→(B)
     ↑     │
     │     ↓
    (D)←──(C)

A → B → C → D → A is a REAL cycle.

How to distinguish? Track if node is IN CURRENT DFS PATH!
```

### The Three-Color Algorithm

The key insight: Use three states to track each vertex's status during DFS.

```
Three Colors/States:

WHITE (0): Unvisited
    - Not yet discovered by DFS

GRAY (1): In Progress  
    - Currently in the DFS recursion stack
    - We started processing but haven't finished

BLACK (2): Completed
    - Fully processed (all descendants explored)
    - No longer in recursion stack

Cycle Detection Rule:
If we find an edge to a GRAY vertex → BACK EDGE → CYCLE!
```

### Visual: Three-Color States

```
Graph:
    (A)──→(B)
     │     │
     ↓     ↓
    (C)──→(D)──→(E)
           ↑     │
           └─────┘

DFS from A:

Time 1: Start DFS(A)
    Colors: A=GRAY, B=WHITE, C=WHITE, D=WHITE, E=WHITE
    Stack: [A]

Time 2: DFS(A) → DFS(B)
    Colors: A=GRAY, B=GRAY, C=WHITE, D=WHITE, E=WHITE
    Stack: [A, B]

Time 3: DFS(B) → DFS(D)
    Colors: A=GRAY, B=GRAY, C=WHITE, D=GRAY, E=WHITE
    Stack: [A, B, D]

Time 4: DFS(D) → DFS(E)
    Colors: A=GRAY, B=GRAY, C=WHITE, D=GRAY, E=GRAY
    Stack: [A, B, D, E]

Time 5: DFS(E) sees D is GRAY!
    E → D and D is GRAY (in current path)
    BACK EDGE FOUND → CYCLE: D → E → D
```

### Implementation: Three-Color DFS

```python
def has_cycle_directed(graph, n):
    """
    Detect cycle in directed graph using three-color DFS
    
    Args:
        graph: adjacency list
        n: number of vertices
    
    Returns:
        True if cycle exists
    """
    WHITE, GRAY, BLACK = 0, 1, 2
    color = [WHITE] * n
    
    def dfs(node):
        color[node] = GRAY  # Mark as in-progress
        
        for neighbor in graph[node]:
            if color[neighbor] == GRAY:
                # Back edge to vertex in current path → Cycle!
                return True
            if color[neighbor] == WHITE:
                if dfs(neighbor):
                    return True
        
        color[node] = BLACK  # Mark as completed
        return False
    
    # Check all vertices (handle disconnected components)
    for i in range(n):
        if color[i] == WHITE:
            if dfs(i):
                return True
    
    return False


# Example with cycle
# 0 → 1 → 2 → 0
graph_cycle = [[1], [2], [0]]
print(has_cycle_directed(graph_cycle, 3))  # True

# Example without cycle
# 0 → 1 → 2
graph_no_cycle = [[1], [2], []]
print(has_cycle_directed(graph_no_cycle, 3))  # False
```

### Finding the Actual Cycle

```python
def find_cycle_directed(graph, n):
    """
    Find and return the vertices in a cycle (if exists)
    
    Returns:
        List of vertices forming the cycle, or empty list
    """
    WHITE, GRAY, BLACK = 0, 1, 2
    color = [WHITE] * n
    parent = [-1] * n
    cycle_start = -1
    cycle_end = -1
    
    def dfs(node):
        nonlocal cycle_start, cycle_end
        color[node] = GRAY
        
        for neighbor in graph[node]:
            if color[neighbor] == GRAY:
                # Found cycle!
                cycle_start = neighbor
                cycle_end = node
                return True
            if color[neighbor] == WHITE:
                parent[neighbor] = node
                if dfs(neighbor):
                    return True
        
        color[node] = BLACK
        return False
    
    for i in range(n):
        if color[i] == WHITE:
            if dfs(i):
                break
    
    if cycle_start == -1:
        return []  # No cycle
    
    # Reconstruct cycle
    cycle = []
    current = cycle_end
    while current != cycle_start:
        cycle.append(current)
        current = parent[current]
    cycle.append(cycle_start)
    cycle.reverse()
    
    return cycle


# Example
# Graph: 0 → 1 → 2 → 3 → 1 (cycle: 1 → 2 → 3 → 1)
graph = [[1], [2], [3], [1]]
print(find_cycle_directed(graph, 4))  # [1, 2, 3]
```

### Iterative Three-Color DFS

```python
def has_cycle_directed_iterative(graph, n):
    """
    Iterative version of three-color cycle detection
    """
    WHITE, GRAY, BLACK = 0, 1, 2
    color = [WHITE] * n
    
    for start in range(n):
        if color[start] != WHITE:
            continue
        
        stack = [(start, iter(graph[start]))]
        color[start] = GRAY
        
        while stack:
            node, neighbors = stack[-1]
            
            try:
                neighbor = next(neighbors)
                
                if color[neighbor] == GRAY:
                    return True  # Cycle!
                if color[neighbor] == WHITE:
                    color[neighbor] = GRAY
                    stack.append((neighbor, iter(graph[neighbor])))
            
            except StopIteration:
                # All neighbors processed
                stack.pop()
                color[node] = BLACK
    
    return False
```

---

## 10.4 Cycle Detection in Specific Scenarios

### Detecting Cycle in a Linked List (Floyd's Algorithm)

```python
def has_cycle_linked_list(head):
    """
    Floyd's Tortoise and Hare algorithm
    Two pointers: slow moves 1 step, fast moves 2 steps
    If they meet → cycle exists
    """
    if not head or not head.next:
        return False
    
    slow = head
    fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        
        if slow == fast:
            return True
    
    return False


def find_cycle_start(head):
    """
    Find the node where cycle begins
    """
    if not head or not head.next:
        return None
    
    slow = fast = head
    
    # Phase 1: Detect cycle
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            break
    else:
        return None  # No cycle
    
    # Phase 2: Find cycle start
    # Reset slow to head, move both at same speed
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next
    
    return slow  # Cycle starts here
```

### Visual: Floyd's Algorithm

```
Linked List with Cycle:
1 → 2 → 3 → 4 → 5
            ↑   │
            └───┘

Phase 1: Detect cycle
    slow: 1 → 2 → 3 → 4 → 5 → 3 → 4
    fast: 1 → 3 → 5 → 4 → 3 → 5 → 4
                              ↑
                           Meet at 4!

Phase 2: Find cycle start
    Reset slow to head
    slow: 1 → 2 → 3
    fast: 4 → 5 → 3
                  ↑
               Meet at 3! (cycle start)
```

### Detecting Negative Cycle (Bellman-Ford)

```python
def has_negative_cycle(n, edges):
    """
    Detect negative cycle using Bellman-Ford
    If we can still relax after V-1 iterations → negative cycle
    """
    dist = [0] * n  # Initialize all to 0 to detect any negative cycle
    
    # Relax all edges V-1 times
    for _ in range(n - 1):
        for u, v, w in edges:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
    
    # Check for negative cycle (V-th iteration)
    for u, v, w in edges:
        if dist[u] + w < dist[v]:
            return True  # Can still relax → negative cycle!
    
    return False
```

---

## 10.5 Cycle Detection on Grids

### Finding Cycle in Grid

```python
def has_cycle_grid(grid):
    """
    Detect if there's a cycle of same characters in grid
    LeetCode 1559: Detect Cycles in 2D Grid
    """
    rows, cols = len(grid), len(grid[0])
    visited = [[False] * cols for _ in range(rows)]
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    def dfs(r, c, pr, pc, char):
        """
        DFS with parent tracking for undirected grid
        pr, pc = parent row, parent col
        """
        visited[r][c] = True
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            # Check bounds
            if 0 <= nr < rows and 0 <= nc < cols:
                # Must be same character
                if grid[nr][nc] != char:
                    continue
                
                # Skip parent (undirected)
                if nr == pr and nc == pc:
                    continue
                
                if visited[nr][nc]:
                    # Visited cell that's not parent → Cycle!
                    return True
                
                if dfs(nr, nc, r, c, char):
                    return True
        
        return False
    
    for r in range(rows):
        for c in range(cols):
            if not visited[r][c]:
                if dfs(r, c, -1, -1, grid[r][c]):
                    return True
    
    return False


# Example
grid = [
    ['a', 'a', 'a', 'a'],
    ['a', 'b', 'b', 'a'],
    ['a', 'b', 'b', 'a'],
    ['a', 'a', 'a', 'a']
]
print(has_cycle_grid(grid))  # True (cycle of 'a's around the border)
```

---

## 10.6 Common Interview Problems

### Problem 1: Course Schedule (Cycle = Cannot Finish)

```python
def can_finish(numCourses, prerequisites):
    """
    LeetCode 207: Course Schedule
    Return True if all courses can be finished (no cycle)
    """
    graph = [[] for _ in range(numCourses)]
    for course, prereq in prerequisites:
        graph[prereq].append(course)
    
    WHITE, GRAY, BLACK = 0, 1, 2
    color = [WHITE] * numCourses
    
    def has_cycle(node):
        color[node] = GRAY
        for neighbor in graph[node]:
            if color[neighbor] == GRAY:
                return True
            if color[neighbor] == WHITE and has_cycle(neighbor):
                return True
        color[node] = BLACK
        return False
    
    for i in range(numCourses):
        if color[i] == WHITE and has_cycle(i):
            return False
    
    return True
```

### Problem 2: Redundant Connection

```python
def find_redundant_connection(edges):
    """
    LeetCode 684: Redundant Connection
    Find edge that, when removed, results in a tree
    (Return the edge that creates the cycle)
    """
    n = len(edges)
    parent = list(range(n + 1))
    rank = [0] * (n + 1)
    
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]
    
    def union(x, y):
        px, py = find(x), find(y)
        if px == py:
            return False
        if rank[px] < rank[py]:
            px, py = py, px
        parent[py] = px
        if rank[px] == rank[py]:
            rank[px] += 1
        return True
    
    for u, v in edges:
        if not union(u, v):
            return [u, v]  # This edge creates cycle
    
    return []
```

### Problem 3: Graph Valid Tree

```python
def valid_tree(n, edges):
    """
    LeetCode 261: Graph Valid Tree
    A valid tree: connected + no cycles + exactly n-1 edges
    """
    # Quick check: tree must have exactly n-1 edges
    if len(edges) != n - 1:
        return False
    
    # Check connectivity using Union-Find
    parent = list(range(n))
    
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]
    
    def union(x, y):
        px, py = find(x), find(y)
        if px == py:
            return False
        parent[px] = py
        return True
    
    for u, v in edges:
        if not union(u, v):
            return False  # Cycle detected
    
    # With n-1 edges and no cycle, must be connected tree
    return True
```

### Problem 4: Detect Cycle in Directed Graph with Entry Point

```python
def find_eventual_safe_nodes(graph):
    """
    LeetCode 802: Find Eventual Safe States
    A node is safe if every path leads to terminal node (no outgoing edges)
    Nodes in or leading to cycles are unsafe
    """
    n = len(graph)
    WHITE, GRAY, BLACK = 0, 1, 2
    color = [WHITE] * n
    
    def is_safe(node):
        if color[node] != WHITE:
            return color[node] == BLACK
        
        color[node] = GRAY
        
        for neighbor in graph[node]:
            if not is_safe(neighbor):
                return False
        
        color[node] = BLACK
        return True
    
    return [i for i in range(n) if is_safe(i)]
```

---

## 10.7 Summary

### Algorithm Selection Guide

```
┌─────────────────────────────────────────────────────────────────┐
│               Cycle Detection Algorithm Selection                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Is the graph DIRECTED or UNDIRECTED?                          │
│       │                                                         │
│       ├── UNDIRECTED:                                          │
│       │       │                                                 │
│       │       ├── Given adjacency list → DFS with Parent       │
│       │       │                                                 │
│       │       └── Given edge list → Union-Find                 │
│       │                                                         │
│       └── DIRECTED:                                            │
│               │                                                 │
│               └── Use Three-Color DFS (WHITE/GRAY/BLACK)       │
│                                                                 │
│  Special Cases:                                                │
│  • Linked List → Floyd's Tortoise and Hare                     │
│  • Negative Cycle → Bellman-Ford                               │
│  • Grid → DFS with Parent (treat as undirected)                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Quick Reference

```python
# Undirected: DFS with Parent
def has_cycle_undirected(node, parent, visited, graph):
    visited[node] = True
    for neighbor in graph[node]:
        if not visited[neighbor]:
            if has_cycle_undirected(neighbor, node, visited, graph):
                return True
        elif neighbor != parent:
            return True  # Cycle!
    return False

# Directed: Three-Color DFS
def has_cycle_directed(node, color, graph):
    color[node] = GRAY
    for neighbor in graph[node]:
        if color[neighbor] == GRAY:
            return True  # Cycle!
        if color[neighbor] == WHITE:
            if has_cycle_directed(neighbor, color, graph):
                return True
    color[node] = BLACK
    return False
```

---

## 10.8 Practice Problems

### Easy
1. Linked List Cycle (LC 141)
2. Linked List Cycle II (LC 142)

### Medium
1. Course Schedule (LC 207)
2. Course Schedule II (LC 210)
3. Redundant Connection (LC 684)
4. Graph Valid Tree (LC 261)
5. Find Eventual Safe States (LC 802)
6. Detect Cycles in 2D Grid (LC 1559)

### Hard
1. Redundant Connection II (LC 685)
2. Critical Connections in a Network (LC 1192)
