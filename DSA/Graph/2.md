# Chapter 2: Graph Representations
## How to Store Graphs in Memory

---

## 2.1 Overview

Before we can run algorithms on graphs, we need to store them in memory. The choice of representation significantly impacts:
- **Space complexity**
- **Time complexity** of operations
- **Code simplicity**

```
The Big Question:
Given a graph, how do we represent it in code?

Visual:           In Code:
   (0)‚Äî‚Äî(1)        ???
    |  / |
    | /  |
   (2)‚Äî‚Äî(3)
```

We'll cover 4 main representations:
1. **Adjacency Matrix**
2. **Adjacency List**
3. **Edge List**
4. **Implicit Graphs**

---

## 2.2 Adjacency Matrix

### Concept

Store the graph as a **2D matrix** where:
- `matrix[i][j] = 1` if edge exists from vertex i to vertex j
- `matrix[i][j] = 0` if no edge exists

```
Graph:                    Adjacency Matrix:
   (0)‚Äî‚Äî(1)                  0  1  2  3
    |  / |               0 [ 0  1  1  0 ]
    | /  |               1 [ 1  0  1  1 ]
   (2)‚Äî‚Äî(3)              2 [ 1  1  0  1 ]
                         3 [ 0  1  1  0 ]

matrix[0][1] = 1  ‚Üí  Edge exists between 0 and 1
matrix[0][3] = 0  ‚Üí  No edge between 0 and 3
```

### Implementation

```python
class GraphMatrix:
    def __init__(self, num_vertices):
        self.V = num_vertices
        # Initialize V√óV matrix with zeros
        self.matrix = [[0] * num_vertices for _ in range(num_vertices)]
    
    def add_edge(self, u, v, directed=False):
        """Add edge between u and v"""
        self.matrix[u][v] = 1
        if not directed:
            self.matrix[v][u] = 1  # Undirected: add both ways
    
    def remove_edge(self, u, v, directed=False):
        """Remove edge between u and v"""
        self.matrix[u][v] = 0
        if not directed:
            self.matrix[v][u] = 0
    
    def has_edge(self, u, v):
        """Check if edge exists - O(1)"""
        return self.matrix[u][v] == 1
    
    def get_neighbors(self, u):
        """Get all neighbors of u - O(V)"""
        neighbors = []
        for v in range(self.V):
            if self.matrix[u][v] == 1:
                neighbors.append(v)
        return neighbors
    
    def get_degree(self, u):
        """Get degree of vertex u - O(V)"""
        return sum(self.matrix[u])
    
    def display(self):
        """Print the matrix"""
        print("  ", end="")
        for i in range(self.V):
            print(f"{i} ", end="")
        print()
        for i in range(self.V):
            print(f"{i} ", end="")
            for j in range(self.V):
                print(f"{self.matrix[i][j]} ", end="")
            print()

# Example Usage
g = GraphMatrix(4)
g.add_edge(0, 1)
g.add_edge(0, 2)
g.add_edge(1, 2)
g.add_edge(1, 3)
g.add_edge(2, 3)

g.display()
# Output:
#   0 1 2 3
# 0 0 1 1 0
# 1 1 0 1 1
# 2 1 1 0 1
# 3 0 1 1 0

print(g.has_edge(0, 1))      # True
print(g.has_edge(0, 3))      # False
print(g.get_neighbors(1))    # [0, 2, 3]
```

### Weighted Adjacency Matrix

For weighted graphs, store the weight instead of 1:

```python
class WeightedGraphMatrix:
    def __init__(self, num_vertices):
        self.V = num_vertices
        # Use infinity for no edge
        self.matrix = [[float('inf')] * num_vertices 
                       for _ in range(num_vertices)]
        # Distance to self is 0
        for i in range(num_vertices):
            self.matrix[i][i] = 0
    
    def add_edge(self, u, v, weight, directed=False):
        self.matrix[u][v] = weight
        if not directed:
            self.matrix[v][u] = weight
    
    def get_weight(self, u, v):
        return self.matrix[u][v]

# Example: Weighted graph
#    (0)‚Äî‚Äî5‚Äî‚Äî(1)
#     |      /|
#     2    3  4
#     |  /    |
#    (2)‚Äî‚Äî1‚Äî‚Äî(3)

wg = WeightedGraphMatrix(4)
wg.add_edge(0, 1, 5)
wg.add_edge(0, 2, 2)
wg.add_edge(1, 2, 3)
wg.add_edge(1, 3, 4)
wg.add_edge(2, 3, 1)

print(wg.get_weight(0, 1))  # 5
print(wg.get_weight(0, 3))  # inf (no direct edge)
```

### Complexity Analysis

| Operation | Time Complexity | Notes |
|-----------|-----------------|-------|
| Add Edge | O(1) | Direct array access |
| Remove Edge | O(1) | Direct array access |
| Check Edge Exists | O(1) | Direct array access |
| Get All Neighbors | O(V) | Must scan entire row |
| Get Degree | O(V) | Must scan entire row |
| Space | O(V¬≤) | Always V√óV matrix |

### When to Use Adjacency Matrix

‚úÖ **Good For:**
- Dense graphs (many edges)
- Frequent edge existence checks
- Small graphs (V < 1000)
- Algorithms needing O(1) edge lookup
- Floyd-Warshall algorithm

‚ùå **Bad For:**
- Sparse graphs (wastes space)
- Large graphs (V¬≤ can be huge)
- Finding all neighbors frequently

```
Visualization of space usage:

Dense Graph (many edges):    Sparse Graph (few edges):
[1 1 1 1 1]                  [0 1 0 0 0]
[1 1 1 1 1]                  [1 0 1 0 0]
[1 1 1 1 1]  ‚Üê efficient     [0 1 0 0 1]  ‚Üê wasteful
[1 1 1 1 1]                  [0 0 0 0 1]
[1 1 1 1 1]                  [0 0 1 1 0]

80% ones = good use          20% ones = 80% wasted
```

---

## 2.3 Adjacency List

### Concept

Store each vertex with a **list of its neighbors**. Most common representation for interview problems.

```
Graph:                    Adjacency List:
   (0)‚Äî‚Äî(1)               0: [1, 2]
    |  / |                1: [0, 2, 3]
    | /  |                2: [0, 1, 3]
   (2)‚Äî‚Äî(3)               3: [1, 2]

Vertex 0 connects to vertices 1 and 2
Vertex 1 connects to vertices 0, 2, and 3
etc.
```

### Implementation Methods

#### Method 1: Dictionary with Lists (Most Flexible)

```python
from collections import defaultdict

class GraphAdjList:
    def __init__(self):
        # defaultdict automatically creates empty list for new keys
        self.graph = defaultdict(list)
    
    def add_edge(self, u, v, directed=False):
        """Add edge between u and v"""
        self.graph[u].append(v)
        if not directed:
            self.graph[v].append(u)
    
    def remove_edge(self, u, v, directed=False):
        """Remove edge between u and v"""
        if v in self.graph[u]:
            self.graph[u].remove(v)
        if not directed and u in self.graph[v]:
            self.graph[v].remove(u)
    
    def has_edge(self, u, v):
        """Check if edge exists - O(degree of u)"""
        return v in self.graph[u]
    
    def get_neighbors(self, u):
        """Get all neighbors - O(1)"""
        return self.graph[u]
    
    def get_degree(self, u):
        """Get degree - O(1)"""
        return len(self.graph[u])
    
    def get_all_vertices(self):
        """Get all vertices"""
        vertices = set(self.graph.keys())
        for neighbors in self.graph.values():
            vertices.update(neighbors)
        return vertices
    
    def display(self):
        for vertex in sorted(self.graph.keys()):
            print(f"{vertex}: {self.graph[vertex]}")

# Example Usage
g = GraphAdjList()
g.add_edge(0, 1)
g.add_edge(0, 2)
g.add_edge(1, 2)
g.add_edge(1, 3)
g.add_edge(2, 3)

g.display()
# Output:
# 0: [1, 2]
# 1: [0, 2, 3]
# 2: [0, 1, 3]
# 3: [1, 2]

print(g.get_neighbors(1))  # [0, 2, 3]
print(g.get_degree(1))     # 3
```

#### Method 2: List of Lists (When vertices are 0 to n-1)

```python
class GraphAdjListArray:
    def __init__(self, num_vertices):
        self.V = num_vertices
        self.graph = [[] for _ in range(num_vertices)]
    
    def add_edge(self, u, v, directed=False):
        self.graph[u].append(v)
        if not directed:
            self.graph[v].append(u)
    
    def get_neighbors(self, u):
        return self.graph[u]

# Example
g = GraphAdjListArray(4)
g.add_edge(0, 1)
g.add_edge(0, 2)
g.add_edge(1, 2)

print(g.graph)
# [[1, 2], [0, 2], [0, 1], []]
```

> üí° **TIP**: Use `defaultdict(list)` when vertices can be any hashable type (strings, tuples, etc.). Use list of lists when vertices are integers 0 to n-1.

### Weighted Adjacency List

```python
from collections import defaultdict

class WeightedGraphAdjList:
    def __init__(self):
        self.graph = defaultdict(list)
    
    def add_edge(self, u, v, weight, directed=False):
        """Store as (neighbor, weight) tuples"""
        self.graph[u].append((v, weight))
        if not directed:
            self.graph[v].append((u, weight))
    
    def get_neighbors_with_weights(self, u):
        """Returns list of (neighbor, weight) tuples"""
        return self.graph[u]
    
    def display(self):
        for vertex in self.graph:
            edges = [f"{v}(w={w})" for v, w in self.graph[vertex]]
            print(f"{vertex}: {edges}")

# Example
wg = WeightedGraphAdjList()
wg.add_edge('A', 'B', 5)
wg.add_edge('A', 'C', 2)
wg.add_edge('B', 'C', 3)
wg.add_edge('B', 'D', 4)

wg.display()
# Output:
# A: ['B(w=5)', 'C(w=2)']
# B: ['A(w=5)', 'C(w=3)', 'D(w=4)']
# C: ['A(w=2)', 'B(w=3)']
# D: ['B(w=4)']

# Access in Dijkstra-style iteration
for neighbor, weight in wg.graph['B']:
    print(f"B -> {neighbor} with cost {weight}")
# B -> A with cost 5
# B -> C with cost 3
# B -> D with cost 4
```

### Complexity Analysis

| Operation | Time Complexity | Notes |
|-----------|-----------------|-------|
| Add Edge | O(1) | Append to list |
| Remove Edge | O(degree) | Search in list |
| Check Edge Exists | O(degree) | Search in list |
| Get All Neighbors | O(1) | Return list reference |
| Get Degree | O(1) | Length of list |
| Space | O(V + E) | Proportional to graph size |

### When to Use Adjacency List

‚úÖ **Good For:**
- Sparse graphs (most real-world graphs)
- Iterating over neighbors (BFS, DFS)
- Space-efficient for large graphs
- Most interview problems!

‚ùå **Bad For:**
- Frequent edge existence checks
- Dense graphs where O(V¬≤) operations are needed

---

## 2.4 Adjacency Matrix vs Adjacency List

### Side-by-Side Comparison

```
Same Graph, Different Representations:

Graph:           Matrix:              List:
  (0)‚Äî‚Äî(1)       [0,1,1,0]           0: [1,2]
   |  /          [1,0,1,1]           1: [0,2,3]
   | /           [1,1,0,1]           2: [0,1,3]
  (2)‚Äî‚Äî(3)       [0,1,1,0]           3: [1,2]
```

### Comparison Table

| Aspect | Adjacency Matrix | Adjacency List |
|--------|------------------|----------------|
| Space | O(V¬≤) | O(V + E) |
| Check edge (u,v) | O(1) ‚úì | O(degree(u)) |
| Find all neighbors | O(V) | O(degree) ‚úì |
| Add edge | O(1) ‚úì | O(1) ‚úì |
| Remove edge | O(1) ‚úì | O(degree) |
| Best for | Dense graphs | Sparse graphs ‚úì |
| Memory for sparse | Wasteful | Efficient ‚úì |

### Practical Example: When It Matters

```python
# For a social network with 1 million users
# and average 100 friends each:

# Matrix: 1,000,000 √ó 1,000,000 = 10^12 cells = ~1 TB memory!
# List: 1,000,000 vertices + 100,000,000 edges = ~100 MB memory

# Clearly, adjacency list wins for real-world sparse graphs!
```

> üî• **INTERVIEW TIP**: 90% of graph interview problems use adjacency list. Default to it unless you have a specific reason to use matrix.

---

## 2.5 Edge List

### Concept

Store the graph as a simple **list of edges**.

```
Graph:               Edge List:
   (0)‚Äî‚Äî(1)          edges = [
    |  /               (0, 1),
    | /                (0, 2),
   (2)‚Äî‚Äî(3)            (1, 2),
                       (1, 3),
                       (2, 3)
                     ]
```

### Implementation

```python
class GraphEdgeList:
    def __init__(self):
        self.edges = []
        self.vertices = set()
    
    def add_edge(self, u, v, weight=1):
        """Add edge as (u, v, weight) tuple"""
        self.edges.append((u, v, weight))
        self.vertices.add(u)
        self.vertices.add(v)
    
    def get_edges(self):
        return self.edges
    
    def get_vertices(self):
        return self.vertices
    
    def sort_by_weight(self):
        """Sort edges by weight - useful for Kruskal's"""
        self.edges.sort(key=lambda x: x[2])

# Example: Weighted graph for MST
g = GraphEdgeList()
g.add_edge(0, 1, 4)
g.add_edge(0, 2, 3)
g.add_edge(1, 2, 1)
g.add_edge(1, 3, 2)
g.add_edge(2, 3, 4)

g.sort_by_weight()
print(g.edges)
# [(1, 2, 1), (1, 3, 2), (0, 2, 3), (0, 1, 4), (2, 3, 4)]
```

### When to Use Edge List

‚úÖ **Good For:**
- Kruskal's MST algorithm (needs sorted edges)
- Problems that iterate over all edges
- Input parsing (edges often given as pairs)
- Bellman-Ford algorithm

‚ùå **Bad For:**
- Finding neighbors of a vertex
- Checking if edge exists
- BFS/DFS traversals

### Complexity

| Operation | Time |
|-----------|------|
| Add Edge | O(1) |
| Find Neighbors | O(E) |
| Check Edge Exists | O(E) |
| Space | O(E) |

---

## 2.6 Implicit Graphs

### Concept

Sometimes the graph isn't stored explicitly. Instead, **edges are computed on-the-fly** based on rules.

### Example 1: Grid as Graph

A 2D grid is an implicit graph where:
- Each cell is a vertex
- Adjacent cells (up, down, left, right) are connected by edges

```
Grid:               Implicit Graph:
[0,0] [0,1] [0,2]      (0,0)‚Äî‚Äî(0,1)‚Äî‚Äî(0,2)
                         |       |       |
[1,0] [1,1] [1,2]      (1,0)‚Äî‚Äî(1,1)‚Äî‚Äî(1,2)
                         |       |       |
[2,0] [2,1] [2,2]      (2,0)‚Äî‚Äî(2,1)‚Äî‚Äî(2,2)

Cell (1,1) has neighbors: (0,1), (1,0), (1,2), (2,1)
```

```python
def grid_neighbors(grid, row, col):
    """
    Get valid neighbors in a grid (4-directional)
    """
    rows, cols = len(grid), len(grid[0])
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # right, left, down, up
    
    neighbors = []
    for dr, dc in directions:
        new_row, new_col = row + dr, col + dc
        # Check bounds
        if 0 <= new_row < rows and 0 <= new_col < cols:
            # Check if cell is valid (not obstacle)
            if grid[new_row][new_col] != '#':
                neighbors.append((new_row, new_col))
    
    return neighbors

# Example: Grid with obstacles
grid = [
    ['.', '.', '#'],
    ['.', '.', '.'],
    ['#', '.', '.']
]

print(grid_neighbors(grid, 1, 1))  # [(0, 1), (1, 0), (1, 2), (2, 1)]
print(grid_neighbors(grid, 0, 0))  # [(0, 1), (1, 0)] - only 2 neighbors
```

### Example 2: State Space Graph

In many problems, vertices represent **states** and edges represent **valid transitions**.

```python
# Example: "Open the Lock" problem
# State: 4-digit combination
# Edges: Turning any wheel up or down

def get_next_states(state):
    """
    Get all states reachable from current state
    by turning one wheel up or down
    """
    next_states = []
    
    for i in range(4):  # 4 wheels
        digit = int(state[i])
        
        # Turn up (0->1, 9->0)
        up = (digit + 1) % 10
        next_states.append(state[:i] + str(up) + state[i+1:])
        
        # Turn down (0->9, 1->0)
        down = (digit - 1) % 10
        next_states.append(state[:i] + str(down) + state[i+1:])
    
    return next_states

print(get_next_states("0000"))
# ['1000', '9000', '0100', '0900', '0010', '0090', '0001', '0009']
# 8 neighbors (each of 4 wheels can go up or down)
```

### Example 3: Word Ladder Graph

States are words, edges connect words differing by one letter.

```python
def get_word_neighbors(word, word_set):
    """
    Find all valid words that differ by exactly one letter
    """
    neighbors = []
    word_list = list(word)
    
    for i in range(len(word)):
        original_char = word_list[i]
        
        for c in 'abcdefghijklmnopqrstuvwxyz':
            if c != original_char:
                word_list[i] = c
                new_word = ''.join(word_list)
                if new_word in word_set:
                    neighbors.append(new_word)
        
        word_list[i] = original_char  # Restore
    
    return neighbors

word_set = {'hot', 'dot', 'dog', 'lot', 'log', 'cog'}
print(get_word_neighbors('hot', word_set))  # ['dot', 'lot']
print(get_word_neighbors('dot', word_set))  # ['hot', 'dog', 'lot']
```

### Why Implicit Graphs?

| Aspect | Explicit Graph | Implicit Graph |
|--------|---------------|----------------|
| Memory | Store all edges | Compute on demand |
| Setup time | O(E) to build | O(1) |
| Neighbor access | O(1) lookup | O(k) computation |
| Best for | Fixed structure | Dynamic/huge state spaces |

---

## 2.7 Converting Between Representations

### Edge List ‚Üí Adjacency List

```python
def edge_list_to_adj_list(edges, directed=False):
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        if not directed:
            graph[v].append(u)
    return graph

edges = [(0, 1), (0, 2), (1, 2), (1, 3)]
adj_list = edge_list_to_adj_list(edges)
print(dict(adj_list))
# {0: [1, 2], 1: [0, 2, 3], 2: [0, 1], 3: [1]}
```

### Adjacency List ‚Üí Adjacency Matrix

```python
def adj_list_to_matrix(adj_list, n):
    matrix = [[0] * n for _ in range(n)]
    for u in adj_list:
        for v in adj_list[u]:
            matrix[u][v] = 1
    return matrix

adj_list = {0: [1, 2], 1: [0, 2], 2: [0, 1]}
matrix = adj_list_to_matrix(adj_list, 3)
# [[0, 1, 1], [1, 0, 1], [1, 1, 0]]
```

### Adjacency Matrix ‚Üí Edge List

```python
def matrix_to_edge_list(matrix, directed=False):
    edges = []
    n = len(matrix)
    for i in range(n):
        start = 0 if directed else i  # Avoid duplicate undirected edges
        for j in range(start, n):
            if matrix[i][j] != 0:
                edges.append((i, j, matrix[i][j]))
    return edges
```

---

## 2.8 Representation Decision Flowchart

```
                    START
                      |
                      v
        Is the graph dense (E ‚âà V¬≤)?
                /           \
              YES            NO
               |              |
               v              v
        Use MATRIX      Is it a grid/state problem?
                              /          \
                            YES           NO
                             |             |
                             v             v
                     Use IMPLICIT     Need sorted edges?
                         GRAPH            /        \
                                        YES         NO
                                         |           |
                                         v           v
                                   Use EDGE      Use ADJACENCY
                                     LIST           LIST
                                     
Default choice for interviews: ADJACENCY LIST
```

---

## 2.9 Summary Code Templates

### Quick Setup for Interviews

```python
from collections import defaultdict, deque

# Template 1: Unweighted undirected graph
def build_graph_unweighted(edges):
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    return graph

# Template 2: Unweighted directed graph
def build_directed_graph(edges):
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
    return graph

# Template 3: Weighted graph
def build_weighted_graph(edges):
    graph = defaultdict(list)
    for u, v, w in edges:
        graph[u].append((v, w))
        graph[v].append((u, w))
    return graph

# Template 4: Graph from n nodes (0 to n-1)
def build_graph_from_n(n, edges):
    graph = [[] for _ in range(n)]
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    return graph
```

---

## Practice Problems for Chapter 2

1. **Representation Conversion**: Given an adjacency matrix, convert it to an adjacency list.

2. **Build Graph from Input**: Given n cities and m roads as pairs, build an adjacency list.

3. **Grid Graph**: Given a grid, find all cells reachable from (0,0) without crossing obstacles.

4. **Space Comparison**: For a graph with V=1000 and E=5000, calculate memory usage for matrix vs list.

5. **Edge Count**: Given an adjacency list, count the total number of edges (handle undirected case).
