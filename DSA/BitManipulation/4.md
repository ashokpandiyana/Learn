# Chapter 4: Counting Bits Patterns - In-Depth Explanation

## Overview
Counting bits is one of the most fundamental operations in bit manipulation. This chapter explores multiple algorithms for counting set bits, understanding their trade-offs, and applying them to solve complex problems.

---

## 4.1 Count Number of Set Bits (Hamming Weight)

The **Hamming Weight** of a number is the count of '1' bits in its binary representation. This is also called **population count** or **popcount**.

### Why is this Important?
- Used in error detection/correction codes
- Cryptography and hash functions
- Machine learning (distance metrics)
- Database indexing
- Network protocols

---

### Method 1: Brian Kernighan's Algorithm

#### The Core Idea
The key insight: `n & (n-1)` removes the rightmost set bit from n.

#### Visual Explanation
```
Example: n = 12 (binary: 1100)

Iteration 1:
    n     = 12 = 1100
    n-1   = 11 = 1011
    n&(n-1)= 8  = 1000  ← rightmost 1 removed
    count = 1

Iteration 2:
    n     = 8  = 1000
    n-1   = 7  = 0111
    n&(n-1)= 0  = 0000  ← rightmost 1 removed
    count = 2

Result: 2 set bits
```

#### Why Does `n & (n-1)` Work?

When you subtract 1 from a number:
1. All bits after the rightmost set bit get flipped
2. The rightmost set bit becomes 0
3. All bits before the rightmost set bit remain unchanged

```
Example breakdown:
n    = 10110100
n-1  = 10110011  (rightmost 1→0, all bits after flip)
     = --------
AND  = 10110000  (rightmost set bit cleared!)
```

#### Python Implementation

```python
def count_set_bits_kernighan(n):
    """
    Brian Kernighan's Algorithm
    Time: O(k) where k = number of set bits
    Space: O(1)
    """
    count = 0
    while n:
        n = n & (n - 1)  # Remove rightmost set bit
        count += 1
    return count

# Examples
print(count_set_bits_kernighan(12))   # Output: 2 (1100)
print(count_set_bits_kernighan(15))   # Output: 4 (1111)
print(count_set_bits_kernighan(255))  # Output: 8 (11111111)
```

#### Complexity Analysis
- **Time**: O(k), where k is the number of set bits
- **Space**: O(1)
- **Best for**: Numbers with few set bits

#### When to Use
✅ When the number has relatively few set bits  
✅ When you need constant space  
❌ Not optimal for numbers with many set bits (like 0xFFFFFFFF)

---

### Method 2: Naive Approach - Check Each Bit

#### The Concept
Check every bit position from right to left by:
1. Extracting the rightmost bit using `n & 1`
2. Right-shifting the number by 1

#### Visual Step-by-Step

```
Example: n = 13 (binary: 1101)

Step 1: n = 1101, rightmost bit = 1, count = 1
        n >> 1 = 0110

Step 2: n = 0110, rightmost bit = 0, count = 1
        n >> 1 = 0011

Step 3: n = 0011, rightmost bit = 1, count = 2
        n >> 1 = 0001

Step 4: n = 0001, rightmost bit = 1, count = 3
        n >> 1 = 0000

Result: 3 set bits
```

#### Python Implementation

```python
def count_set_bits_naive(n):
    """
    Check each bit position
    Time: O(log n) - number of bits in n
    Space: O(1)
    """
    count = 0
    while n:
        count += n & 1  # Add 1 if rightmost bit is set
        n >>= 1         # Right shift by 1
    return count

# Alternative: Loop exactly 32 times (for 32-bit integers)
def count_set_bits_fixed(n):
    """For fixed-width integers (e.g., 32-bit)"""
    count = 0
    for i in range(32):  # Check all 32 bits
        if n & (1 << i):
            count += 1
    return count

# Examples
print(count_set_bits_naive(13))   # Output: 3 (1101)
print(count_set_bits_fixed(13))   # Output: 3 (1101)
```

#### Complexity Analysis
- **Time**: O(log n) or O(32) for 32-bit integers
- **Space**: O(1)
- **Characteristics**: Checks every bit position regardless of value

#### Comparison with Kernighan's

```
Number: 1000...0001 (2 set bits in 32-bit)

Kernighan's: 2 iterations ✓ Fast!
Naive:       32 iterations ✗ Slow!

Number: 1111...1111 (32 set bits)

Kernighan's: 32 iterations
Naive:       32 iterations ✓ Same!
```

---

### Method 3: Lookup Table Approach

#### The Strategy
Precompute the bit counts for all possible 8-bit values (0-255), then process the number 8 bits at a time.

#### Visual Representation

```
Number: 0xABCD1234 (32-bit)

Split into bytes:
┌──────┬──────┬──────┬──────┐
│ 0xAB │ 0xCD │ 0x12 │ 0x34 │
└──────┴──────┴──────┴──────┘
   ↓      ↓      ↓      ↓
Lookup: 5 + 6 + 2 + 3 = 16 set bits
```

#### Python Implementation

```python
def count_set_bits_lookup():
    """Generate lookup table for 0-255"""
    lookup = [0] * 256
    for i in range(256):
        lookup[i] = (i & 1) + lookup[i >> 1]
    return lookup

# Precompute once
BIT_COUNT_LOOKUP = count_set_bits_lookup()

def count_set_bits_table(n):
    """
    Using lookup table
    Time: O(1) for 32-bit, O(log n / 8) in general
    Space: O(256) for the table
    """
    count = 0
    while n:
        count += BIT_COUNT_LOOKUP[n & 0xFF]  # Process 8 bits
        n >>= 8  # Move to next byte
    return count

# Example
print(count_set_bits_table(0xABCD1234))

# Verify lookup table
print("First 16 entries:", BIT_COUNT_LOOKUP[:16])
# [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4]
```

#### How the Lookup Table is Built

```python
def explain_lookup_generation():
    """Show how lookup table is generated"""
    for i in range(16):  # Show first 16
        binary = format(i, '04b')
        count = (i & 1) + (BIT_COUNT_LOOKUP[i >> 1] if i > 0 else 0)
        print(f"{i:2d} = {binary} → {count} bits")

explain_lookup_generation()
```

Output:
```
 0 = 0000 → 0 bits
 1 = 0001 → 1 bits
 2 = 0010 → 1 bits
 3 = 0011 → 2 bits
 4 = 0100 → 1 bits
 5 = 0101 → 2 bits
...
```

#### Complexity Analysis
- **Time**: O(1) for fixed-width integers, O(log n / 8) in general
- **Space**: O(256) = O(1) constant space
- **Best for**: Processing many numbers repeatedly

---

### Method 4: Built-in Functions (Most Practical)

Python and other languages provide optimized built-in functions.

```python
def count_set_bits_builtin(n):
    """
    Using Python's built-in
    Time: O(1) - highly optimized in C
    Space: O(1)
    """
    return bin(n).count('1')

# Alternative for other languages:
# C++: __builtin_popcount(n)
# Java: Integer.bitCount(n)

# Examples with explanation
numbers = [0, 1, 7, 15, 16, 255, 1023]
for num in numbers:
    binary = bin(num)[2:]  # Remove '0b' prefix
    count = count_set_bits_builtin(num)
    print(f"{num:4d} = {binary:>10s} → {count} set bits")
```

Output:
```
   0 =          0 → 0 set bits
   1 =          1 → 1 set bits
   7 =        111 → 3 set bits
  15 =       1111 → 4 set bits
  16 =      10000 → 1 set bits
 255 =   11111111 → 8 set bits
1023 = 1111111111 → 10 set bits
```

---

### Performance Comparison

```python
import time

def benchmark_methods(n, iterations=100000):
    """Compare all methods"""
    methods = [
        ("Kernighan", count_set_bits_kernighan),
        ("Naive", count_set_bits_naive),
        ("Lookup", count_set_bits_table),
        ("Built-in", count_set_bits_builtin)
    ]
    
    print(f"\nBenchmark for n = {n} (binary: {bin(n)})")
    print("-" * 50)
    
    for name, func in methods:
        start = time.time()
        for _ in range(iterations):
            result = func(n)
        elapsed = time.time() - start
        print(f"{name:12s}: {elapsed:.4f}s (result: {result})")

# Test with different numbers
benchmark_methods(15)         # Few set bits
benchmark_methods(0xFFFFFF)   # Many set bits
```

---

## 4.2 Count Total Bits Required

### The Problem
Find the number of bits needed to represent a number.

#### Examples
```
5    = 101     → 3 bits
8    = 1000    → 4 bits
15   = 1111    → 4 bits
16   = 10000   → 5 bits
255  = 11111111 → 8 bits
```

### Method 1: Using Logarithm

```python
import math

def count_bits_needed_log(n):
    """
    Using mathematical formula
    Time: O(1)
    """
    if n == 0:
        return 1  # Special case
    return math.floor(math.log2(n)) + 1

# Examples
for num in [0, 1, 5, 8, 15, 16, 255]:
    bits = count_bits_needed_log(num)
    print(f"{num:3d} = {bin(num)[2:]:>8s} needs {bits} bits")
```

### Method 2: Using Bit Length

```python
def count_bits_needed_builtin(n):
    """
    Python's bit_length() method
    Time: O(1)
    """
    return n.bit_length()

# Example
print(f"255 needs {(255).bit_length()} bits")  # 8
```

### Method 3: Count Leading Zeros

```python
def count_bits_needed_clz(n):
    """
    Using count leading zeros concept
    For 32-bit integers
    """
    if n == 0:
        return 1
    
    # Count leading zeros
    leading_zeros = 0
    mask = 1 << 31  # Start from MSB
    
    while mask and not (n & mask):
        leading_zeros += 1
        mask >>= 1
    
    return 32 - leading_zeros

# Example
print(count_bits_needed_clz(255))  # 8
```

### Visual Explanation

```
Number: 42 (decimal)

Step 1: Convert to binary
42 = 101010

Step 2: Count digits
     101010
     ^^^^^^
     6 bits

Verification: 2^5 = 32 ≤ 42 < 64 = 2^6
Therefore: floor(log2(42)) + 1 = 5 + 1 = 6 ✓
```

---

## 4.3 Parity (Even/Odd Count of Set Bits)

### What is Parity?
**Parity** determines if the number of set bits is even (parity = 0) or odd (parity = 1).

#### Applications
- Error detection in data transmission
- Checksums
- Cryptographic algorithms
- RAID systems

### Method 1: Count and Check

```python
def parity_naive(n):
    """
    Count set bits and check if odd
    Time: O(log n)
    """
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count % 2

# Examples
for num in [5, 7, 15, 16]:
    par = parity_naive(num)
    bits = bin(num).count('1')
    print(f"{num:2d} = {bin(num)[2:]:>5s} → {bits} bits → parity: {par}")
```

Output:
```
 5 =   101 → 2 bits → parity: 0 (even)
 7 =   111 → 3 bits → parity: 1 (odd)
15 =  1111 → 4 bits → parity: 0 (even)
16 = 10000 → 1 bits → parity: 1 (odd)
```

### Method 2: XOR Trick (Optimal)

#### The Insight
XOR is its own inverse and cancels pairs!

```
If we XOR all bits:
- Even pairs cancel out (1 ^ 1 = 0)
- Odd bit remains (1 ^ 0 = 1)
```

```python
def parity_xor(n):
    """
    Using XOR to compute parity
    Time: O(log n)
    """
    parity = 0
    while n:
        parity ^= (n & 1)
        n >>= 1
    return parity

# Visual demonstration
def parity_xor_visual(n):
    """Show step-by-step XOR"""
    parity = 0
    original = n
    step = 1
    
    print(f"\nComputing parity of {original} = {bin(original)[2:]}")
    print("-" * 40)
    
    while n:
        bit = n & 1
        old_parity = parity
        parity ^= bit
        print(f"Step {step}: bit={bit}, parity: {old_parity} ^ {bit} = {parity}")
        n >>= 1
        step += 1
    
    return parity

# Example
result = parity_xor_visual(13)  # 1101
print(f"\nFinal parity: {result}")
```

Output:
```
Computing parity of 13 = 1101
----------------------------------------
Step 1: bit=1, parity: 0 ^ 1 = 1
Step 2: bit=0, parity: 1 ^ 0 = 1
Step 3: bit=1, parity: 1 ^ 1 = 0
Step 4: bit=1, parity: 0 ^ 1 = 1

Final parity: 1 (odd number of bits)
```

### Method 3: Parallel XOR (Advanced)

Divide and conquer approach - XOR halves repeatedly.

```python
def parity_parallel(n):
    """
    Parallel parity computation
    XOR all bits by repeatedly XORing halves
    Time: O(log log n) - very fast!
    """
    # For 32-bit numbers
    n ^= n >> 16  # XOR top 16 bits with bottom 16
    n ^= n >> 8   # XOR top 8 bits with bottom 8
    n ^= n >> 4   # XOR top 4 bits with bottom 4
    n ^= n >> 2   # XOR top 2 bits with bottom 2
    n ^= n >> 1   # XOR top bit with bottom bit
    return n & 1  # Final parity in LSB

# Example with visualization
def parity_parallel_visual(n):
    """Show each step"""
    print(f"\nComputing parity of {n} = {bin(n)[2:].zfill(32)}")
    print("-" * 60)
    
    original = n
    
    n ^= n >> 16
    print(f"After >> 16: {bin(n)[2:].zfill(32)}")
    
    n ^= n >> 8
    print(f"After >> 8:  {bin(n)[2:].zfill(32)}")
    
    n ^= n >> 4
    print(f"After >> 4:  {bin(n)[2:].zfill(32)}")
    
    n ^= n >> 2
    print(f"After >> 2:  {bin(n)[2:].zfill(32)}")
    
    n ^= n >> 1
    print(f"After >> 1:  {bin(n)[2:].zfill(32)}")
    
    result = n & 1
    print(f"\nParity: {result}")
    return result

parity_parallel_visual(0b10110101)
```

### Method 4: Lookup Table

```python
# Precompute parity for all 8-bit values
PARITY_LOOKUP = [0] * 256
for i in range(256):
    PARITY_LOOKUP[i] = parity_xor(i)

def parity_lookup(n):
    """
    Using lookup table
    Time: O(1) for 32-bit
    """
    # XOR all bytes
    parity = 0
    while n:
        parity ^= PARITY_LOOKUP[n & 0xFF]
        n >>= 8
    return parity

print(parity_lookup(0xABCD1234))
```

---

## Practical Applications & Interview Problems

### Problem 1: Hamming Distance

**Definition**: Number of positions where bits differ.

```python
def hamming_distance(x, y):
    """
    Find Hamming distance between two numbers
    Approach: Count set bits in XOR
    """
    return count_set_bits_kernighan(x ^ y)

# Why? XOR gives 1 where bits differ!
print(hamming_distance(1, 4))  # 1=001, 4=100, XOR=101 → 2
```

### Problem 2: Total Hamming Distance

**Problem**: Sum of Hamming distances between all pairs.

```python
def total_hamming_distance(nums):
    """
    For each bit position, count numbers with that bit set.
    If k numbers have bit set, (n-k) don't have it.
    Pairs with different bits at position i: k * (n-k)
    
    Time: O(32 * n) = O(n)
    """
    total = 0
    n = len(nums)
    
    for i in range(32):  # Check each bit position
        count_set = 0
        for num in nums:
            if num & (1 << i):
                count_set += 1
        
        # Pairs with different bits at position i
        count_unset = n - count_set
        total += count_set * count_unset
    
    return total

# Example
print(total_hamming_distance([4, 14, 2]))  # 6
```

### Problem 3: Counting Bits (0 to n)

**Problem**: Given n, return array of bit counts for 0 to n.

```python
def count_bits(n):
    """
    Dynamic Programming approach
    Pattern: bits[i] = bits[i >> 1] + (i & 1)
    
    Explanation: 
    - i >> 1 removes last bit
    - i & 1 checks if last bit is set
    
    Time: O(n), Space: O(n)
    """
    result = [0] * (n + 1)
    for i in range(1, n + 1):
        result[i] = result[i >> 1] + (i & 1)
    return result

# Example
print(count_bits(5))  # [0, 1, 1, 2, 1, 2]

# Verify
for i, count in enumerate(count_bits(5)):
    print(f"{i} = {bin(i)[2:]:>3s} → {count} bits")
```

---

## Summary Table

| Method | Time | Space | Best Use Case |
|--------|------|-------|---------------|
| Kernighan | O(k) | O(1) | Few set bits |
| Naive | O(log n) | O(1) | General purpose |
| Lookup | O(1) | O(256) | Many queries |
| Built-in | O(1) | O(1) | Production code |
| Parity XOR | O(log n) | O(1) | Error detection |
| Parity Parallel | O(log log n) | O(1) | Ultra-fast parity |

---

## Key Takeaways

1. **Kernighan's algorithm** is elegant and efficient for sparse bit patterns
2. **XOR properties** make parity computation trivial
3. **Lookup tables** trade space for speed
4. **Built-in functions** are optimized in hardware - use them in production!
5. Understanding **bit patterns** helps in dynamic programming solutions

---

## Practice Problems

1. **Easy**: Number of 1 Bits, Counting Bits
2. **Medium**: Hamming Distance, Total Hamming Distance
3. **Hard**: Binary Watch, UTF-8 Validation