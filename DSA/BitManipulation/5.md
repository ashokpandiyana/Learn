# Chapter 5: Advanced Bit Manipulation Patterns - In-Depth Explanation

## Overview
This chapter covers advanced patterns that leverage the unique properties of bitwise operations to solve complex problems efficiently. These patterns are frequently asked in technical interviews at top companies.

---

## 5.1 XOR Pattern - Finding Unique Elements

### Why XOR is Magical for Finding Unique Elements

XOR has three critical properties that make it perfect for "finding unique" problems:

```
Property 1: a ^ a = 0     (Self-cancellation)
Property 2: a ^ 0 = a     (Identity)
Property 3: a ^ b = b ^ a (Commutative)
```

**Key Insight**: When you XOR all numbers, pairs cancel out (become 0), leaving only unique elements!

---

### Pattern 5.1.1: Single Number (One Unique Among Duplicates)

**Problem**: Every element appears twice except one. Find that single element.

#### Visual Explanation

```
Array: [4, 1, 2, 1, 2]

Step-by-step XOR:
4 ^ 1 ^ 2 ^ 1 ^ 2

Rearrange (XOR is commutative):
4 ^ (1 ^ 1) ^ (2 ^ 2)
4 ^    0    ^    0
4

Result: 4 is the unique element!
```

#### Why It Works

```
Example: [7, 3, 5, 3, 7]

Binary representation:
7 = 111
3 = 011
5 = 101
3 = 011
7 = 111

XOR all:
  111  (7)
^ 011  (3)
^ 101  (5)
^ 011  (3)
^ 111  (7)
------
  101  (5) ‚Üê Pairs canceled!
```

#### Python Implementation

```python
def single_number(nums):
    """
    Find the single unique number
    Time: O(n), Space: O(1)
    """
    result = 0
    for num in nums:
        result ^= num
    return result

# Examples
print(single_number([4, 1, 2, 1, 2]))  # 4
print(single_number([2, 2, 1]))        # 1
print(single_number([1]))              # 1

# Detailed trace
def single_number_trace(nums):
    """Show each XOR operation"""
    result = 0
    print(f"Array: {nums}")
    print("-" * 50)
    
    for i, num in enumerate(nums):
        old_result = result
        result ^= num
        print(f"Step {i+1}: {old_result:3d} ^ {num:3d} = {result:3d}")
    
    print(f"\nUnique number: {result}")
    return result

single_number_trace([4, 1, 2, 1, 2])
```

Output:
```
Array: [4, 1, 2, 1, 2]
--------------------------------------------------
Step 1:   0 ^   4 =   4
Step 2:   4 ^   1 =   5
Step 3:   5 ^   2 =   7
Step 4:   7 ^   1 =   6
Step 5:   6 ^   2 =   4

Unique number: 4
```

---

### Pattern 5.1.2: Two Unique Numbers

**Problem**: Every element appears twice except two numbers. Find both unique numbers.

#### The Challenge
If we XOR all numbers, we get `a ^ b` (XOR of the two unique numbers). How do we separate them?

#### The Solution Strategy

```
Step 1: XOR all numbers ‚Üí Get xor_result = a ^ b

Step 2: Find any bit position where a and b differ
        (Use rightmost set bit: xor_result & (-xor_result))

Step 3: Divide all numbers into two groups based on this bit
        - Group 1: Numbers with this bit SET
        - Group 2: Numbers with this bit CLEAR

Step 4: XOR each group separately
        - Group 1 will give us 'a'
        - Group 2 will give us 'b'
```

#### Visual Example

```
Array: [1, 2, 1, 3, 2, 5]
Two unique numbers: 3 and 5

Step 1: XOR all
1 ^ 2 ^ 1 ^ 3 ^ 2 ^ 5 = 3 ^ 5 = 6 (binary: 110)

Step 2: Find rightmost set bit
6 = 110
Rightmost set bit at position 1 (bit mask: 010)

Step 3: Partition by bit 1
Bit 1 is SET:   [2, 3, 2]    ‚Üí XOR = 3 ‚úì
Bit 1 is CLEAR: [1, 1, 5]    ‚Üí XOR = 5 ‚úì
```

#### Detailed Visualization

```
Why does partitioning work?

Original: [1, 2, 1, 3, 2, 5]
          001 010 001 011 010 101

Check bit position 1 (mask = 010):

Group A (bit 1 = 1): 2(010), 3(011), 2(010)
    2 ^ 3 ^ 2 = 3 ‚úì

Group B (bit 1 = 0): 1(001), 1(001), 5(101)
    1 ^ 1 ^ 5 = 5 ‚úì

Key insight: 
- Duplicate pairs stay in same group (same bit pattern)
- Different unique numbers go to different groups (differ in at least one bit)
```

#### Python Implementation

```python
def single_number_two_unique(nums):
    """
    Find two unique numbers among duplicates
    Time: O(n), Space: O(1)
    """
    # Step 1: XOR all numbers
    xor_result = 0
    for num in nums:
        xor_result ^= num
    
    # Step 2: Find rightmost set bit
    # This bit differs between the two unique numbers
    rightmost_bit = xor_result & (-xor_result)
    
    # Step 3: Partition and XOR each group
    num1, num2 = 0, 0
    for num in nums:
        if num & rightmost_bit:
            num1 ^= num  # Group 1
        else:
            num2 ^= num  # Group 2
    
    return [num1, num2]

# Example with detailed trace
def single_number_two_detailed(nums):
    """Show the algorithm step by step"""
    print(f"Array: {nums}")
    print("=" * 60)
    
    # Step 1
    xor_all = 0
    for num in nums:
        xor_all ^= num
    print(f"\nStep 1: XOR all numbers = {xor_all} (binary: {bin(xor_all)})")
    
    # Step 2
    rightmost = xor_all & (-xor_all)
    print(f"\nStep 2: Rightmost set bit = {rightmost} (binary: {bin(rightmost)})")
    
    bit_pos = (rightmost).bit_length() - 1
    print(f"        This is bit position {bit_pos}")
    
    # Step 3
    group1, group2 = [], []
    for num in nums:
        if num & rightmost:
            group1.append(num)
        else:
            group2.append(num)
    
    print(f"\nStep 3: Partition numbers")
    print(f"        Group 1 (bit {bit_pos} SET):   {group1}")
    print(f"        Group 2 (bit {bit_pos} CLEAR): {group2}")
    
    # Step 4
    num1 = 0
    for num in group1:
        num1 ^= num
    
    num2 = 0
    for num in group2:
        num2 ^= num
    
    print(f"\nStep 4: XOR each group")
    print(f"        Group 1 XOR: {num1}")
    print(f"        Group 2 XOR: {num2}")
    
    return [num1, num2]

# Test
result = single_number_two_detailed([1, 2, 1, 3, 2, 5])
print(f"\nüéØ Result: {result}")
```

---

### Pattern 5.1.3: Single Number III (Appears Once, Others Thrice)

**Problem**: Every element appears three times except one that appears once. Find it.

#### The Challenge
XOR won't work directly because `a ^ a ^ a = a` (not zero!).

#### The Solution: Bit-by-Bit Counting

**Key Insight**: If we count occurrences of each bit across all numbers:
- Bits appearing in the unique number will have count: `3k + 1`
- Other bits will have count: `3k`
- Taking modulo 3 extracts the unique number!

#### Visual Example

```
Array: [2, 2, 3, 2]
Binary:
2 = 010
2 = 010
3 = 011
2 = 010

Count each bit position:
Position 0: 0+0+1+0 = 1 ‚Üí 1 % 3 = 1
Position 1: 1+1+1+1 = 4 ‚Üí 4 % 3 = 1
Position 2: 0+0+0+0 = 0 ‚Üí 0 % 3 = 0

Result: 011 = 3 ‚úì
```

#### Method 1: Simple Counting

```python
def single_number_three_times(nums):
    """
    Find single number when others appear 3 times
    Method: Count bits at each position
    Time: O(32n) = O(n), Space: O(1)
    """
    result = 0
    
    # Check each bit position (32 bits for integers)
    for i in range(32):
        bit_sum = 0
        
        # Count occurrences of bit i across all numbers
        for num in nums:
            if num & (1 << i):
                bit_sum += 1
        
        # If not divisible by 3, this bit is in unique number
        if bit_sum % 3:
            result |= (1 << i)
    
    return result

# Example
print(single_number_three_times([2, 2, 3, 2]))  # 3
print(single_number_three_times([0, 1, 0, 1, 0, 1, 99]))  # 99
```

#### Method 2: State Machine (Advanced)

This uses two variables to track bits appearing once and twice.

```python
def single_number_three_times_optimized(nums):
    """
    Advanced method using bit manipulation state machine
    
    States:
    - ones: bits that appeared 1 time (or 4, 7, 10...)
    - twos: bits that appeared 2 times (or 5, 8, 11...)
    - When a bit appears 3 times, we reset it in both
    
    Time: O(n), Space: O(1)
    """
    ones = 0  # Bits appearing 1 time
    twos = 0  # Bits appearing 2 times
    
    for num in nums:
        # Update twos: add bits that are in both 'ones' and current 'num'
        twos |= ones & num
        
        # Update ones: XOR with current number
        ones ^= num
        
        # Find bits that appeared 3 times
        threes = ones & twos
        
        # Remove these bits from ones and twos
        ones &= ~threes
        twos &= ~threes
    
    return ones

# Test
print(single_number_three_times_optimized([2, 2, 3, 2]))  # 3
```

#### State Machine Visualization

```python
def single_number_state_trace(nums):
    """Trace the state machine"""
    ones = twos = 0
    
    print(f"Array: {nums}")
    print("=" * 70)
    print(f"{'Step':<6} {'num':<6} {'ones':<15} {'twos':<15} {'threes':<15}")
    print("-" * 70)
    
    for i, num in enumerate(nums):
        # Show initial state
        print(f"{i+1:<6} {num:<6} ", end="")
        
        twos_old = twos
        ones_old = ones
        
        # Update
        twos |= ones & num
        ones ^= num
        threes = ones & twos
        ones &= ~threes
        twos &= ~threes
        
        # Show results
        print(f"{bin(ones)[2:].zfill(3):<15} {bin(twos)[2:].zfill(3):<15} "
              f"{bin(threes)[2:].zfill(3):<15}")
    
    print("-" * 70)
    print(f"Result: {ones} (binary: {bin(ones)})")
    return ones

single_number_state_trace([2, 2, 3, 2])
```

---

## 5.2 Subset Generation Pattern

### The Core Concept

A bitmask can represent which elements are included in a subset:
- Bit position `i` set (1) ‚Üí element `i` is included
- Bit position `i` clear (0) ‚Üí element `i` is excluded

For n elements, there are **2^n possible subsets** (including empty set).

#### Visual Representation

```
Array: [A, B, C]  (n = 3)

Mask 000 (0) ‚Üí { }         (empty)
Mask 001 (1) ‚Üí {C}
Mask 010 (2) ‚Üí {B}
Mask 011 (3) ‚Üí {B, C}
Mask 100 (4) ‚Üí {A}
Mask 101 (5) ‚Üí {A, C}
Mask 110 (6) ‚Üí {A, B}
Mask 111 (7) ‚Üí {A, B, C}  (full)

Total: 2^3 = 8 subsets
```

---

### Generate All Subsets

```python
def generate_all_subsets(arr):
    """
    Generate all subsets using bit manipulation
    Time: O(2^n * n), Space: O(2^n * n) for output
    """
    n = len(arr)
    total_subsets = 1 << n  # 2^n
    result = []
    
    # Iterate through all possible masks
    for mask in range(total_subsets):
        subset = []
        
        # Check each bit position
        for i in range(n):
            if mask & (1 << i):
                subset.append(arr[i])
        
        result.append(subset)
    
    return result

# Example
arr = ['A', 'B', 'C']
subsets = generate_all_subsets(arr)

print(f"Array: {arr}")
print(f"Total subsets: {len(subsets)}")
print("\nAll subsets:")
for i, subset in enumerate(subsets):
    binary = bin(i)[2:].zfill(len(arr))
    print(f"{i:2d} ({binary}): {subset}")
```

Output:
```
Array: ['A', 'B', 'C']
Total subsets: 8

All subsets:
 0 (000): []
 1 (001): ['A']
 2 (010): ['B']
 3 (011): ['A', 'B']
 4 (100): ['C']
 5 (101): ['A', 'C']
 6 (110): ['B', 'C']
 7 (111): ['A', 'B', 'C']
```

---

### Iterate Through All Subsets of a Mask

**Problem**: Given a mask, iterate through all its subsets efficiently.

#### Visual Example

```
Mask = 5 (binary: 101) ‚Üí Elements {0, 2}

Possible subsets of {0, 2}:
101 (5) ‚Üí {0, 2}  (full)
100 (4) ‚Üí {2}
001 (1) ‚Üí {0}
000 (0) ‚Üí {}      (empty)
```

#### The Algorithm

```python
def iterate_subsets_of_mask(mask):
    """
    Iterate all subsets of a given mask
    Formula: submask = (submask - 1) & mask
    
    This is FASTER than checking all 2^n masks!
    """
    subsets = []
    submask = mask
    
    # Include the mask itself first
    while True:
        subsets.append(submask)
        
        if submask == 0:
            break
        
        # Move to next submask
        submask = (submask - 1) & mask
    
    return subsets

# Example
mask = 5  # Binary: 101
subsets = iterate_subsets_of_mask(mask)

print(f"Mask: {mask} (binary: {bin(mask)})")
print(f"Total subsets: {len(subsets)}\n")

for submask in subsets:
    print(f"{submask:2d} (binary: {bin(submask)[2:].zfill(3)})")
```

#### Why This Works

```
Mask = 101 (5)

Start: submask = 101 (5)

Step 1: submask - 1 = 100 (4)
        100 & 101 = 100 ‚úì

Step 2: submask - 1 = 011 (3)
        011 & 101 = 001 ‚úì

Step 3: submask - 1 = 000 (0)
        000 & 101 = 000 ‚úì (stop)

The AND operation ensures we only keep bits present in original mask!
```

#### Application: Subset Sum

```python
def subset_sum_bitmask(arr, target):
    """
    Find if any subset sums to target
    Time: O(2^n * n)
    """
    n = len(arr)
    
    # Try all possible subsets
    for mask in range(1 << n):
        subset_sum = 0
        subset = []
        
        for i in range(n):
            if mask & (1 << i):
                subset_sum += arr[i]
                subset.append(arr[i])
        
        if subset_sum == target:
            return True, subset
    
    return False, []

# Example
arr = [3, 34, 4, 12, 5, 2]
target = 9

found, subset = subset_sum_bitmask(arr, target)
print(f"Array: {arr}")
print(f"Target: {target}")
print(f"Found: {found}")
print(f"Subset: {subset}")  # [4, 5]
```

---

## 5.3 Gray Code Pattern

### What is Gray Code?

A sequence where consecutive values differ by exactly **one bit**.

#### Example

```
Decimal  |  Gray Code  |  Binary
---------|-------------|----------
   0     |     000     |   000
   1     |     001     |   001  ‚Üê 1 bit diff
   2     |     011     |   010  ‚Üê 1 bit diff
   3     |     010     |   011  ‚Üê 1 bit diff
   4     |     110     |   100  ‚Üê 1 bit diff
   5     |     111     |   101  ‚Üê 1 bit diff
   6     |     101     |   110  ‚Üê 1 bit diff
   7     |     100     |   111  ‚Üê 1 bit diff
```

### Why Gray Code?

**Applications**:
- Minimize errors in analog-to-digital conversion
- Karnaugh maps in digital logic
- Genetic algorithms
- Position encoders
- Puzzle solving (e.g., Tower of Hanoi)

### The Formula

```
Gray(i) = i ^ (i >> 1)
```

This simple formula converts binary to Gray code!

#### Why It Works

```
Binary: 101 (5)

Step 1: Shift right by 1
        101 >> 1 = 010

Step 2: XOR with original
        101 ^ 010 = 111

Result: Gray(5) = 111 = 7

Verification:
Gray(4) = 110 = 6
Gray(5) = 111 = 7
Diff: 6 ^ 7 = 1 (binary: 001) ‚úì Only 1 bit different!
```

### Python Implementation

```python
def generate_gray_code(n):
    """
    Generate n-bit Gray code sequence
    Time: O(2^n), Space: O(2^n)
    """
    result = []
    for i in range(1 << n):  # 2^n iterations
        gray = i ^ (i >> 1)
        result.append(gray)
    return result

# Example
n = 3
gray_codes = generate_gray_code(n)

print(f"Gray code for n = {n}:")
print(f"{'Dec':<5} {'Binary':<8} {'Gray':<8} {'Gray Binary':<12}")
print("-" * 40)

for i, gray in enumerate(gray_codes):
    binary = bin(i)[2:].zfill(n)
    gray_binary = bin(gray)[2:].zfill(n)
    print(f"{i:<5} {binary:<8} {gray:<8} {gray_binary:<12}")
```

### Visualizing Bit Changes

```python
def visualize_gray_transitions(n):
    """Show which bit changes at each step"""
    gray_codes = generate_gray_code(n)
    
    print(f"\nGray code transitions for n = {n}:")
    print("=" * 50)
    
    prev_gray = 0
    for i, gray in enumerate(gray_codes):
        if i == 0:
            print(f"Step {i}: {bin(gray)[2:].zfill(n)} (start)")
        else:
            diff = prev_gray ^ gray
            changed_bit = (diff).bit_length() - 1
            print(f"Step {i}: {bin(gray)[2:].zfill(n)} "
                  f"(bit {changed_bit} changed)")
        prev_gray = gray

visualize_gray_transitions(3)
```

### Inverse: Gray to Binary

```python
def gray_to_binary(gray):
    """
    Convert Gray code back to binary
    Keep XORing with shifted version
    """
    binary = gray
    while gray >>= 1:
        binary ^= gray
    return binary

# Verify round-trip
for i in range(8):
    gray = i ^ (i >> 1)
    recovered = gray_to_binary(gray)
    print(f"{i} ‚Üí Gray: {gray} ‚Üí Binary: {recovered} ‚úì")
```

---

## 5.4 Range XOR Queries

### The Pattern

XOR from 1 to n follows a repeating pattern every 4 numbers!

```
n    | XOR(1 to n) | Binary
-----|-------------|--------
1    |      1      | 0001
2    |      3      | 0011
3    |      0      | 0000
4    |      4      | 0100
5    |      1      | 0001  ‚Üê Pattern repeats!
6    |      7      | 0111
7    |      0      | 0000
8    |      8      | 1000
9    |      1      | 0001  ‚Üê Pattern repeats!
```

### The Formula

```python
def xor_from_1_to_n(n):
    """
    Compute XOR of all numbers from 1 to n in O(1)
    Pattern repeats every 4 numbers
    """
    if n % 4 == 0:
        return n
    elif n % 4 == 1:
        return 1
    elif n % 4 == 2:
        return n + 1
    else:  # n % 4 == 3
        return 0

# Verify the pattern
print("n   | XOR(1 to n) | Pattern")
print("----|-------------|--------")
for n in range(1, 17):
    xor_result = xor_from_1_to_n(n)
    print(f"{n:2d}  |     {xor_result:2d}      | n%4={n%4}")
```

### Range XOR [L, R]

```python
def range_xor(L, R):
    """
    XOR of all numbers from L to R
    Formula: XOR(1, R) ^ XOR(1, L-1)
    
    Why? Because XOR(1,L-1) cancels out with XOR(1,L-1) in XOR(1,R)
    
    Time: O(1)
    """
    return xor_from_1_to_n(R) ^ xor_from_1_to_n(L - 1)

# Examples
print(f"\nXOR(3, 7) = {range_xor(3, 7)}")  # 3^4^5^6^7 = 3
print(f"XOR(5, 5) = {range_xor(5, 5)}")    # Just 5 = 5
print(f"XOR(1, 10) = {range_xor(1, 10)}")  # 1^2^..^10 = 11

# Verify
def verify_range_xor(L, R):
    """Verify by computing directly"""
    result = 0
    for i in range(L, R + 1):
        result ^= i
    
    fast_result = range_xor(L, R)
    print(f"XOR({L}, {R}): Direct = {result}, Fast = {fast_result}, "
          f"Match: {result == fast_result}")

verify_range_xor(3, 7)
verify_range_xor(10, 20)
```

---

## 5.5 Bitmask Dynamic Programming

### The Concept

Use an integer (bitmask) to represent the state of which items/cities/tasks have been processed.

**Advantages**:
- Compact state representation
- Fast state transitions using bit operations
- Natural for "subset" problems

**Constraints**: Usually n ‚â§ 20 (since 2^20 ‚âà 1 million states)

---

### Example: Traveling Salesman Problem (TSP)

**Problem**: Visit all n cities exactly once, minimizing total distance.

```python
def tsp_bitmask_dp(dist):
    """
    TSP using bitmask DP
    
    State: dp[mask][i] = minimum cost to visit cities in 'mask', 
                         ending at city i
    
    Time: O(n^2 * 2^n), Space: O(n * 2^n)
    """
    n = len(dist)
    INF = float('inf')
    
    # dp[mask][i] = min cost to visit cities in mask, ending at city i
    dp = [[INF] * n for _ in range(1 << n)]
    
    # Start at city 0
    dp[1][0] = 0  # Mask 000...001, at city 0
    
    # Iterate through all masks
    for mask in range(1 << n):
        for i in range(n):
            # Check if city i is in current mask
            if not (mask & (1 << i)):
                continue
            
            if dp[mask][i] == INF:
                continue
            
            # Try going to city j
            for j in range(n):
                # Skip if j is already visited
                if mask & (1 << j):
                    continue
                
                new_mask = mask | (1 << j)
                dp[new_mask][j] = min(
                    dp[new_mask][j],
                    dp[mask][i] + dist[i][j]
                )
    
    # Find minimum cost visiting all cities
    full_mask = (1 << n) - 1  # All bits set
    min_cost = INF
    
    for i in range(n):
        # Return to city 0
        min_cost = min(min_cost, dp[full_mask][i] + dist[i][0])
    
    return min_cost

# Example
dist = [
    [0, 10, 15, 20],
    [10, 0, 35, 25],
    [15, 35, 0, 30],
    [20, 25, 30, 0]
]

print(f"Minimum TSP cost: {tsp_bitmask_dp(dist)}")
```

---

### Example: Assignment Problem

**Problem**: Assign n tasks to n people, each person does one task, minimize total cost.

```python
def assignment_problem(cost):
    """
    Assignment using bitmask DP
    
    State: dp[mask] = minimum cost to assign tasks in 'mask'
    
    Time: O(n * 2^n), Space: O(2^n)
    """
    n = len(cost)
    INF = float('inf')
    
    # dp[mask] = min cost to assign tasks represented by mask
    dp = [INF] * (1 << n)
    dp[0] = 0  # No tasks assigned
    
    for mask in range(1 << n):
        if dp[mask] == INF:
            continue
        
        # Count number of tasks assigned (= person index)
        person = bin(mask).count('1')
        
        if person >= n:
            continue
        
        # Try assigning task j to this person
        for task in range(n):
            # Skip if task already assigned
            if mask & (1 << task):
                continue
            
            new_mask = mask | (1 << task)
            dp[new_mask] = min(
                dp[new_mask],
                dp[mask] + cost[person][task]
            )
    
    return dp[(1 << n) - 1]

# Example
cost = [
    [9, 2, 7, 8],
    [6, 4, 3, 7],
    [5, 8, 1, 8],
    [7, 6, 9, 4]
]

print(f"Minimum assignment cost: {assignment_problem(cost)}")
```

---

## Summary: When to Use Each Pattern

| Pattern | Use Case | Time Complexity |
|---------|----------|-----------------|
| Single Number | Find unique among pairs | O(n) |
| Two Unique | Find 2 unique among pairs | O(n) |
| Three Times | Unique when others appear 3x | O(n) |
| Subset Generation | All combinations | O(2^n * n) |
| Gray Code | Minimize state changes | O(2^n) |
| Range XOR | Fast XOR queries | O(1) |
| Bitmask DP | Subset optimization | O(n * 2^n) to O(n^2 * 2^n) |

---

## Key Takeaways

1. **XOR is self-inverse** - Perfect for finding unique elements
2. **Bitmasks represent subsets** - Each bit = include/exclude
3. **Gray code minimizes changes** - Consecutive values differ by 1 bit
4. **XOR has patterns** - Range queries in O(1)
5. **Bitmask DP** - Powerful for subset problems with n ‚â§ 20

---

## Practice Problems

**XOR Patterns**: Single Number I/II/III, Missing Number, Find Duplicate  
**Subset Generation**: Subsets, Subset Sum, Maximum XOR Subset  
**Bitmask DP**: TSP, Assignment Problem, Shortest Path Visiting All Nodes