# Chapter 3: Essential Bit Manipulation Tricks
## Master the Most Powerful Bit Manipulation Patterns

---

## Introduction

This chapter covers the **most important bit manipulation tricks** that you'll use repeatedly in coding interviews and competitive programming. Each trick has been proven in countless problems.

**üî¥ Master these 13 tricks and you'll solve 90% of bit manipulation problems!**

---

## 3.1 Check if Number is Power of 2

### The Trick

```python
def is_power_of_2(n):
    """
    Check if n is a power of 2
    Works for positive numbers only
    """
    return n > 0 and (n & (n - 1)) == 0
```

### Why It Works

**Powers of 2 have exactly ONE set bit:**
```
1  = 0001  (2‚Å∞)
2  = 0010  (2¬π)
4  = 0100  (2¬≤)
8  = 1000  (2¬≥)
16 = 0001 0000  (2‚Å¥)
```

**When you subtract 1 from a power of 2:**
```
8 =     1000
8-1=    0111
     ‚Üì  ‚Üì‚Üì‚Üì‚Üì
     The set bit becomes 0
     All bits after it become 1
```

**Now AND them:**
```
    1000  (8)
&   0111  (7)
    ‚îÄ‚îÄ‚îÄ‚îÄ
    0000  (0)  ‚Üê Result is 0 for power of 2!
```

**For non-powers of 2:**
```
6 =     0110
6-1=    0101
     ‚Üì  ‚Üì‚Üì‚Üì‚Üì
&   0100  ‚Üê NOT zero!
```

### Complete Implementation

```python
def is_power_of_2_comprehensive(n):
    """Check if n is power of 2 with detailed explanation"""
    
    if n <= 0:
        return False
    
    result = (n & (n - 1)) == 0
    
    # Visualization
    print(f"\nChecking if {n} is power of 2:")
    print(f"{n:4d} = {bin(n)[2:].zfill(8)}")
    print(f"{n-1:4d} = {bin(n-1)[2:].zfill(8)}")
    print(f"AND  = {bin(n & (n-1))[2:].zfill(8)}")
    print(f"Result: {result}")
    
    return result

# Test cases
test_numbers = [1, 2, 3, 4, 6, 8, 15, 16, 32, 33]
for num in test_numbers:
    result = "‚úì Power of 2" if is_power_of_2(num) else "‚úó Not power of 2"
    print(f"{num:3d}: {result}")
```

### Related: Check if Power of 4

```python
def is_power_of_4(n):
    """
    Check if n is power of 4
    Power of 4 is also power of 2, AND
    the set bit must be at even position (0, 2, 4, 6...)
    """
    # 0x55555555 = 0101 0101 0101 0101... (bits at even positions)
    return n > 0 and (n & (n - 1)) == 0 and (n & 0x55555555) != 0

# Test
for i in [1, 2, 4, 8, 16, 32, 64]:
    p4 = is_power_of_4(i)
    print(f"{i:3d} is power of 4: {p4}")
```

---

## 3.2 Turn Off the Rightmost Set Bit

### The Trick

```python
def turn_off_rightmost_bit(n):
    """
    Turn off (clear) the rightmost set bit
    Formula: n & (n - 1)
    """
    return n & (n - 1)
```

### Why It Works

**Subtracting 1 from a number:**
1. Finds the rightmost set bit
2. Flips that bit to 0
3. Flips all bits to the right of it to 1

```
Example: n = 12 (binary: 1100)

Step 1: n - 1
  1100  (12)
- 0001  (1)
  ‚îÄ‚îÄ‚îÄ‚îÄ
  1011  (11)
  
  Notice: rightmost 1 became 0, and bit after it became 1

Step 2: n & (n-1)
  1100  (12)
& 1011  (11)
  ‚îÄ‚îÄ‚îÄ‚îÄ
  1000  (8)
  
  Only the rightmost set bit is cleared!
```

### Visualization Function

```python
def visualize_turn_off_rightmost(n, bits=8):
    """Visualize turning off rightmost set bit"""
    result = n & (n - 1)
    
    print(f"\nTurn off rightmost bit of {n}:")
    print(f"Original: {n:3d} = {bin(n)[2:].zfill(bits)}")
    print(f"n - 1:    {n-1:3d} = {bin(n-1)[2:].zfill(bits)}")
    print(f"n&(n-1):  {result:3d} = {bin(result)[2:].zfill(bits)}")
    print(f"              {'‚Üë' * bits}")
    
    # Find which bit was cleared
    cleared_bit = n ^ result
    if cleared_bit:
        position = (cleared_bit & -cleared_bit).bit_length() - 1
        print(f"Cleared bit at position {position}")
    
    return result

# Examples
for n in [12, 40, 45, 255]:
    visualize_turn_off_rightmost(n)
```

### Applications

**1. Count Set Bits (Brian Kernighan's Algorithm)**

```python
def count_set_bits(n):
    """
    Count number of set bits efficiently
    Each iteration removes one set bit
    Time: O(number of set bits)
    """
    count = 0
    while n:
        n = n & (n - 1)  # Turn off rightmost set bit
        count += 1
    return count

# Test
print("\nCounting set bits:")
for n in [7, 15, 45, 255]:
    bits = count_set_bits(n)
    print(f"{n:3d} ({bin(n)[2:].zfill(8)}): {bits} bits")

# Show step-by-step
def count_set_bits_verbose(n):
    """Show each step of bit removal"""
    print(f"\nCounting bits in {n} ({bin(n)[2:].zfill(8)}):")
    count = 0
    step = 1
    while n:
        print(f"  Step {step}: {n:3d} = {bin(n)[2:].zfill(8)}")
        n = n & (n - 1)
        count += 1
        step += 1
    print(f"  Total: {count} bits")
    return count

count_set_bits_verbose(45)
```

**2. Check if Number Has Adjacent Set Bits**

```python
def has_adjacent_set_bits(n):
    """
    Check if number has two consecutive 1s
    If we shift and AND, adjacent bits will create overlap
    """
    return (n & (n >> 1)) != 0

# Visualization
def check_adjacent_bits_visual(n):
    print(f"\nChecking {n} for adjacent bits:")
    print(f"n     : {bin(n)[2:].zfill(8)}")
    print(f"n >> 1: {bin(n >> 1)[2:].zfill(8)}")
    print(f"n&(n>>1): {bin(n & (n >> 1))[2:].zfill(8)}")
    
    result = has_adjacent_set_bits(n)
    print(f"Has adjacent bits: {result}")
    return result

check_adjacent_bits_visual(6)   # 0110 - Yes
check_adjacent_bits_visual(5)   # 0101 - No
check_adjacent_bits_visual(12)  # 1100 - Yes
```

---

## 3.3 Isolate the Rightmost Set Bit

### The Trick

```python
def isolate_rightmost_bit(n):
    """
    Keep only the rightmost set bit, clear all others
    Formula: n & (-n)  or  n & (~n + 1)
    """
    return n & -n
```

### Why It Works

**Understanding -n (Two's Complement):**
```
To get -n:
1. Flip all bits (~n)
2. Add 1

Example: n = 12 (binary: 1100)

Step 1: ~n
  1100  (12)
  ‚Üì
  0011  (~12 in 4-bit)

Step 2: ~n + 1 = -n
  0011
+ 0001
  ‚îÄ‚îÄ‚îÄ‚îÄ
  0100  (-12 in 4-bit)

Step 3: n & (-n)
  1100  (12)
& 0100  (-12)
  ‚îÄ‚îÄ‚îÄ‚îÄ
  0100  (4)  ‚Üê Only rightmost set bit remains!
```

**Key Insight:** When you negate a number, all bits before the rightmost set bit flip, but the rightmost set bit and trailing zeros remain the same!

### Detailed Visualization

```python
def visualize_isolate_rightmost(n, bits=8):
    """Visualize isolating rightmost set bit"""
    result = n & -n
    
    print(f"\nIsolate rightmost bit of {n}:")
    print(f"n:       {n:4d} = {bin(n)[2:].zfill(bits)}")
    
    # Show two's complement process
    not_n = ~n & ((1 << bits) - 1)
    neg_n = (-n) & ((1 << bits) - 1)
    
    print(f"~n:      {not_n:4d} = {bin(not_n)[2:].zfill(bits)}")
    print(f"-n:      {neg_n:4d} = {bin(neg_n)[2:].zfill(bits)}")
    print(f"n & -n:  {result:4d} = {bin(result)[2:].zfill(bits)}")
    
    if result:
        position = result.bit_length() - 1
        print(f"Rightmost bit at position {position}")
    
    return result

# Examples
for n in [12, 40, 45, 96]:
    visualize_isolate_rightmost(n)
```

### Applications

**1. Find Position of Rightmost Set Bit**

```python
def rightmost_bit_position(n):
    """
    Find the position (0-indexed) of rightmost set bit
    """
    if n == 0:
        return -1
    
    isolated = n & -n
    position = isolated.bit_length() - 1
    return position

# Alternative method
def rightmost_bit_position_log(n):
    """Using logarithm"""
    if n == 0:
        return -1
    
    import math
    return int(math.log2(n & -n))

# Test
print("\nRightmost bit positions:")
for n in [12, 40, 45, 96]:
    pos = rightmost_bit_position(n)
    print(f"{n:3d} ({bin(n)[2:].zfill(8)}): position {pos}")
```

**2. Binary Indexed Tree (Fenwick Tree) Operations**

```python
def fenwick_parent(index):
    """
    Get parent index in Fenwick Tree
    Parent is obtained by removing rightmost set bit
    """
    return index - (index & -index)

def fenwick_next(index):
    """
    Get next index in Fenwick Tree
    Next is obtained by adding rightmost set bit
    """
    return index + (index & -index)

# Demonstrate Fenwick Tree indexing
def show_fenwick_structure(n):
    """Show parent-child relationships in Fenwick Tree"""
    print(f"\nFenwick Tree structure for n={n}:")
    for i in range(1, n + 1):
        parent = fenwick_parent(i)
        next_idx = fenwick_next(i)
        rightmost = i & -i
        
        print(f"Index {i:2d} ({bin(i)[2:].zfill(4)}): "
              f"rightmost_bit={rightmost}, "
              f"parent={parent:2d}, "
              f"next={next_idx:2d}")

show_fenwick_structure(8)
```

**3. Extract All Set Bits Separately**

```python
def extract_all_bits(n):
    """
    Extract each set bit separately
    Returns list of isolated bits
    """
    bits = []
    original = n
    
    while n:
        rightmost = n & -n
        bits.append(rightmost)
        n = n & (n - 1)  # Remove rightmost bit
    
    return bits

# Visualization
def show_bit_extraction(n):
    print(f"\nExtracting bits from {n} ({bin(n)[2:].zfill(8)}):")
    bits = extract_all_bits(n)
    
    for i, bit in enumerate(bits):
        position = bit.bit_length() - 1
        print(f"  Bit {i+1}: {bit:3d} = {bin(bit)[2:].zfill(8)} (position {position})")
    
    return bits

show_bit_extraction(45)
show_bit_extraction(255)
```

---

## 3.4 Turn On the Rightmost Clear Bit

### The Trick

```python
def turn_on_rightmost_zero(n):
    """
    Turn on (set to 1) the rightmost 0 bit
    Formula: n | (n + 1)
    """
    return n | (n + 1)
```

### Why It Works

```
Example: n = 5 (binary: 0101)

n     = 0101  (5)
n + 1 = 0110  (6)

When we add 1:
- Rightmost 0 becomes 1
- All 1s to the right become 0

n | (n+1):
  0101  (5)
| 0110  (6)
  ‚îÄ‚îÄ‚îÄ‚îÄ
  0111  (7)
  
The rightmost 0 is now 1!
```

### Visualization

```python
def visualize_turn_on_rightmost_zero(n, bits=8):
    """Visualize turning on rightmost zero bit"""
    result = n | (n + 1)
    
    print(f"\nTurn on rightmost 0 in {n}:")
    print(f"n:       {n:3d} = {bin(n)[2:].zfill(bits)}")
    print(f"n + 1:   {n+1:3d} = {bin(n+1)[2:].zfill(bits)}")
    print(f"n|(n+1): {result:3d} = {bin(result)[2:].zfill(bits)}")
    
    return result

# Examples
for n in [5, 10, 13, 20]:
    visualize_turn_on_rightmost_zero(n)
```

---

## 3.5 Get All Set Bits Mask (of length n)

### The Trick

```python
def all_bits_set_mask(n):
    """
    Create a number with lower n bits all set to 1
    Formula: (1 << n) - 1
    """
    return (1 << n) - 1
```

### Why It Works

```
Example: n = 5

Step 1: 1 << 5
  1 << 5 = 100000 (32 in decimal)
  
Step 2: Subtract 1
  100000 (32)
-      1 (1)
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  011111 (31)
  
All lower 5 bits are set!
```

### Complete Implementation

```python
def create_bit_masks():
    """Show bit masks of different lengths"""
    print("Bit Masks:")
    print("n | Binary        | Decimal")
    print("--|---------------|--------")
    
    for n in range(1, 9):
        mask = (1 << n) - 1
        binary = bin(mask)[2:].zfill(8)
        print(f"{n} | {binary} | {mask:3d}")

create_bit_masks()

# Practical application: Extract fields from packed data
def extract_field_with_mask(data, start_bit, length):
    """
    Extract a field from packed data
    """
    mask = (1 << length) - 1
    return (data >> start_bit) & mask

# Example: Extract RGB from 24-bit color
def extract_rgb(color):
    """Extract R, G, B components"""
    r = extract_field_with_mask(color, 16, 8)
    g = extract_field_with_mask(color, 8, 8)
    b = extract_field_with_mask(color, 0, 8)
    return r, g, b

color = 0xFF8040
r, g, b = extract_rgb(color)
print(f"\nColor 0x{color:06X}:")
print(f"  Red:   {r} (0x{r:02X})")
print(f"  Green: {g} (0x{g:02X})")
print(f"  Blue:  {b} (0x{b:02X})")
```

---

## 3.6 Check if i-th Bit is Set

### The Trick

```python
def is_bit_set_method1(n, i):
    """Method 1: Create mask and AND"""
    return (n & (1 << i)) != 0

def is_bit_set_method2(n, i):
    """Method 2: Shift and check LSB"""
    return ((n >> i) & 1) == 1
```

### Comparison of Methods

```python
def compare_methods(n, i):
    """Compare both methods"""
    print(f"\nChecking bit {i} in {n} ({bin(n)[2:].zfill(8)}):")
    
    # Method 1
    mask = 1 << i
    result1 = (n & mask) != 0
    print(f"Method 1: {n} & (1 << {i})")
    print(f"  {bin(n)[2:].zfill(8)} & {bin(mask)[2:].zfill(8)} = {bin(n & mask)[2:].zfill(8)}")
    print(f"  Result: {result1}")
    
    # Method 2
    shifted = n >> i
    result2 = (shifted & 1) == 1
    print(f"Method 2: ({n} >> {i}) & 1")
    print(f"  {bin(shifted)[2:].zfill(8)} & 00000001 = {shifted & 1}")
    print(f"  Result: {result2}")
    
    return result1, result2

# Test
compare_methods(45, 3)
compare_methods(45, 4)
```

---

## 3.7 Set the i-th Bit

### The Trick

```python
def set_bit(n, i):
    """
    Set i-th bit to 1
    Formula: n | (1 << i)
    """
    return n | (1 << i)
```

### Visualization

```python
def visualize_set_bit(n, i, bits=8):
    """Visualize setting a bit"""
    mask = 1 << i
    result = n | mask
    
    print(f"\nSet bit {i} in {n}:")
    print(f"Original:  {n:3d} = {bin(n)[2:].zfill(bits)}")
    print(f"Mask:          {mask:3d} = {bin(mask)[2:].zfill(bits)}")
    print(f"n | mask:  {result:3d} = {bin(result)[2:].zfill(bits)}")
    print(f"                {' ' * (bits - i - 1)}‚Üë")
    print(f"                {' ' * (bits - i - 1)}Bit {i} is now SET")
    
    return result

# Examples
visualize_set_bit(40, 0)  # Set bit 0
visualize_set_bit(40, 2)  # Set bit 2 (already set)
visualize_set_bit(40, 4)  # Set bit 4
```

---

## 3.8 Clear the i-th Bit

### The Trick

```python
def clear_bit(n, i):
    """
    Clear i-th bit (set to 0)
    Formula: n & ~(1 << i)
    """
    return n & ~(1 << i)
```

### Visualization

```python
def visualize_clear_bit(n, i, bits=8):
    """Visualize clearing a bit"""
    mask = 1 << i
    inv_mask = ~mask & ((1 << bits) - 1)
    result = n & inv_mask
    
    print(f"\nClear bit {i} in {n}:")
    print(f"Original:    {n:3d} = {bin(n)[2:].zfill(bits)}")
    print(f"Mask (1<<i): {mask:3d} = {bin(mask)[2:].zfill(bits)}")
    print(f"~(1<<i):     {inv_mask:3d} = {bin(inv_mask)[2:].zfill(bits)}")
    print(f"Result:      {result:3d} = {bin(result)[2:].zfill(bits)}")
    print(f"                  {' ' * (bits - i - 1)}‚Üë")
    print(f"                  {' ' * (bits - i - 1)}Bit {i} is now CLEAR")
    
    return result

# Examples
visualize_clear_bit(45, 0)  # Clear bit 0
visualize_clear_bit(45, 3)  # Clear bit 3
visualize_clear_bit(45, 5)  # Clear bit 5
```

---

## 3.9 Toggle the i-th Bit

### The Trick

```python
def toggle_bit(n, i):
    """
    Toggle i-th bit (0‚Üí1 or 1‚Üí0)
    Formula: n ^ (1 << i)
    """
    return n ^ (1 << i)
```

### Visualization

```python
def visualize_toggle_bit(n, i, bits=8):
    """Visualize toggling a bit"""
    mask = 1 << i
    result = n ^ mask
    
    old_bit = (n >> i) & 1
    new_bit = (result >> i) & 1
    
    print(f"\nToggle bit {i} in {n}:")
    print(f"Original: {n:3d} = {bin(n)[2:].zfill(bits)} (bit {i} = {old_bit})")
    print(f"Mask:     {mask:3d} = {bin(mask)[2:].zfill(bits)}")
    print(f"Result:   {result:3d} = {bin(result)[2:].zfill(bits)} (bit {i} = {new_bit})")
    print(f"               {' ' * (bits - i - 1)}‚Üë")
    print(f"               {' ' * (bits - i - 1)}Toggled from {old_bit} to {new_bit}")
    
    return result

# Examples - Toggle same bit twice
n = 45
print(f"Starting with n = {n} ({bin(n)[2:].zfill(8)})")
n = visualize_toggle_bit(n, 2)
n = visualize_toggle_bit(n, 2)  # Toggle back
```

---

## 3.10 Clear All Bits from MSB to i (inclusive)

### The Trick

```python
def clear_bits_msb_to_i(n, i):
    """
    Clear all bits from MSB down to position i (inclusive)
    Keep only bits from 0 to i-1
    Formula: n & ((1 << i) - 1)
    """
    mask = (1 << i) - 1
    return n & mask
```

### Visualization

```python
def visualize_clear_msb_to_i(n, i, bits=8):
    """Visualize clearing bits from MSB to i"""
    mask = (1 << i) - 1
    result = n & mask
    
    print(f"\nClear bits {bits-1} down to {i} in {n}:")
    print(f"Original: {n:3d} = {bin(n)[2:].zfill(bits)}")
    print(f"Mask:     {mask:3d} = {bin(mask)[2:].zfill(bits)}")
    print(f"Result:   {result:3d} = {bin(result)[2:].zfill(bits)}")
    print(f"               {'X' * (bits - i)}{' ' * i}")
    print(f"               ‚Üë These bits cleared")
    
    return result

# Examples
visualize_clear_msb_to_i(255, 4)  # Keep lower 4 bits
visualize_clear_msb_to_i(170, 5)  # Keep lower 5 bits
```

---

## 3.11 Clear All Bits from i to 0 (inclusive)

### The Trick

```python
def clear_bits_i_to_0(n, i):
    """
    Clear all bits from position i down to 0 (inclusive)
    Keep only bits above position i
    Formula: n & ~((1 << (i + 1)) - 1)
    """
    mask = ~((1 << (i + 1)) - 1)
    return n & mask

# Alternative: shift-based approach
def clear_bits_i_to_0_alt(n, i):
    """Alternative method using left shift"""
    mask = (-1 << (i + 1))  # Same as ~((1 << (i+1)) - 1)
    return n & mask
```

### Visualization

```python
def visualize_clear_i_to_0(n, i, bits=8):
    """Visualize clearing bits from i to 0"""
    mask_unmasked = (1 << (i + 1)) - 1
    mask = ~mask_unmasked & ((1 << bits) - 1)
    result = n & mask
    
    print(f"\nClear bits {i} down to 0 in {n}:")
    print(f"Original:        {n:3d} = {bin(n)[2:].zfill(bits)}")
    print(f"(1<<{i+1})-1:     {mask_unmasked:3d} = {bin(mask_unmasked)[2:].zfill(bits)}")
    print(f"~((1<<{i+1})-1): {mask:3d} = {bin(mask)[2:].zfill(bits)}")
    print(f"Result:          {result:3d} = {bin(result)[2:].zfill(bits)}")
    print(f"                  {' ' * (bits - i - 1)}{'X' * (i + 1)}")
    print(f"                  {' ' * (bits - i - 1)}‚Üë These bits cleared")
    
    return result

# Examples
visualize_clear_i_to_0(255, 3)  # Clear lower 4 bits
visualize_clear_i_to_0(170, 4)  # Clear lower 5 bits
```

---

## 3.12 Swap Two Numbers Without Temp Variable

### The Trick

```python
def swap_xor(a, b):
    """
    Swap two variables using XOR without temp variable
    """
    print(f"Before: a={a}, b={b}")
    
    a = a ^ b  # a now holds XOR of both
    b = a ^ b  # b = (a^b) ^ b = a (original a)
    a = a ^ b  # a = (a^b) ^ a = b (original b)
    
    print(f"After: a={a}, b={b}")
    return a, b
```

### Step-by-Step Explanation

```python
def swap_xor_detailed(a, b):
    """Detailed step-by-step swap"""
    print(f"\n{'='*50}")
    print(f"Swapping a={a} and b={b} using XOR")
    print(f"{'='*50}")
    
    orig_a, orig_b = a, b
    
    print(f"\nInitial:")
    print(f"  a = {a:3d} = {bin(a)[2:].zfill(8)}")
    print(f"  b = {b:3d} = {bin(b)[2:].zfill(8)}")
    
    # Step 1
    a = a ^ b
    print(f"\nStep 1: a = a ^ b = {orig_a} ^ {orig_b}")
    print(f"  a = {a:3d} = {bin(a)[2:].zfill(8)}")
    print(f"  b = {b:3d} = {bin(b)[2:].zfill(8)}")
    print(f"  (a now holds XOR of both original values)")
    
    # Step 2
    b = a ^ b
    print(f"\nStep 2: b = a ^ b = {a} ^ {orig_b}")
    print(f"  a = {a:3d} = {bin(a)[2:].zfill(8)}")
    print(f"  b = {b:3d} = {bin(b)[2:].zfill(8)}")
    print(f"  (b now holds original a: {orig_a})")
    
    # Step 3
    a = a ^ b
    print(f"\nStep 3: a = a ^ b = {orig_a ^ orig_b} ^ {orig_a}")
    print(f"  a = {a:3d} = {bin(a)[2:].zfill(8)}")
    print(f"  b = {b:3d} = {bin(b)[2:].zfill(8)}")
    print(f"  (a now holds original b: {orig_b})")
    
    print(f"\nSwap complete!")
    print(f"Original: a={orig_a}, b={orig_b}")
    print(f"Final:    a={a}, b={b}")
    
    return a, b

# Test
swap_xor_detailed(5, 10)
swap_xor_detailed(42, 17)
```

### Alternative Methods

```python
# Method 2: Using arithmetic (can overflow)
def swap_arithmetic(a, b):
    """Swap using addition/subtraction"""
    a = a + b
    b = a - b  # b = (a+b) - b = a
    a = a - b  # a = (a+b) - a = b
    return a, b

# Method 3: Python tuple unpacking (Pythonic way)
def swap_pythonic(a, b):
    """The pythonic way"""
    a, b = b, a
    return a, b
```

---

## 3.13 Check if Two Numbers Have Opposite Signs

### The Trick

```python
def opposite_signs(x, y):
    """
    Check if two numbers have opposite signs
    XOR of sign bits will be 1 if signs differ
    Formula: (x ^ y) < 0
    """
    return (x ^ y) < 0
```

### Why It Works

```
For signed integers, MSB indicates sign:
- MSB = 0: Positive
- MSB = 1: Negative

If signs differ, XOR will have MSB set:

Positive ^ Negative ‚Üí MSB = 1 (result < 0)
Positive ^ Positive ‚Üí MSB = 0 (result >= 0)
Negative ^ Negative ‚Üí MSB = 0 (result >= 0)
```

### Complete Implementation

```python
def check_opposite_signs(x, y, bits=8):
    """Check and visualize opposite signs"""
    # Convert to fixed-width representation for visualization
    def to_signed(n, bits):
        if n >= 0:
            return n
        else:
            return (1 << bits) + n
    
    x_repr = to_signed(x, bits)
    y_repr = to_signed(y, bits)
    xor = x_repr ^ y_repr
    
    result = (x ^ y) < 0
    
    print(f"\nChecking if {x} and {y} have opposite signs:")
    print(f"x = {x:4d} = {bin(x_repr)[2:].zfill(bits)}")
    print(f"y = {y:4d} = {bin(y_repr)[2:].zfill(bits)}")
    print(f"x^y:        {bin(xor)[2:].zfill(bits)}")
    print(f"            ‚Üë MSB = {1 if xor & (1 << (bits-1)) else 0}")
    print(f"Result: {'Opposite signs' if result else 'Same sign'}")
    
    return result

# Test
check_opposite_signs(5, -3)
check_opposite_signs(-5, -3)
check_opposite_signs(5, 3)
check_opposite_signs(-5, 3)
```

---

## Complete Tricks Reference Card

```python
class BitManipulationTricks:
    """All essential tricks in one class"""
    
    @staticmethod
    def power_of_2(n):
        """Check if power of 2"""
        return n > 0 and (n & (n - 1)) == 0
    
    @staticmethod
    def turn_off_rightmost_bit(n):
        """Clear rightmost set bit"""
        return n & (n - 1)
    
    @staticmethod
    def isolate_rightmost_bit(n):
        """Keep only rightmost set bit"""
        return n & -n
    
    @staticmethod
    def turn_on_rightmost_zero(n):
        """Set rightmost 0 bit"""
        return n | (n + 1)
    
    @staticmethod
    def all_bits_mask(n):
        """Create mask with n bits set"""
        return (1 << n) - 1
    
    @staticmethod
    def is_bit_set(num, i):
        """Check if i-th bit is set"""
        return (num & (1 << i)) != 0
    
    @staticmethod
    def set_bit(num, i):
        """Set i-th bit"""
        return num | (1 << i)
    
    @staticmethod
    def clear_bit(num, i):
        """Clear i-th bit"""
        return num & ~(1 << i)
    
    @staticmethod
    def toggle_bit(num, i):
        """Toggle i-th bit"""
        return num ^ (1 << i)
    
    @staticmethod
    def clear_msb_to_i(num, i):
        """Clear bits from MSB to i"""
        return num & ((1 << i) - 1)
    
    @staticmethod
    def clear_i_to_0(num, i):
        """Clear bits from i to 0"""
        return num & ~((1 << (i + 1)) - 1)

# Demo all tricks
def demo_all_tricks():
    tricks = BitManipulationTricks()
    n = 45  # Binary: 00101101
    
    print(f"Testing with n = {n} ({bin(n)[2:].zfill(8)})")
    print("=" * 50)
    
    print(f"Power of 2: {tricks.power_of_2(n)}")
    print(f"Turn off rightmost: {tricks.turn_off_rightmost_bit(n)} ({bin(tricks.turn_off_rightmost_bit(n))[2:].zfill(8)})")
    print(f"Isolate rightmost: {tricks.isolate_rightmost_bit(n)} ({bin(tricks.isolate_rightmost_bit(n))[2:].zfill(8)})")
    print(f"Check bit 3: {tricks.is_bit_set(n, 3)}")
    print(f"Set bit 1: {tricks.set_bit(n, 1)} ({bin(tricks.set_bit(n, 1))[2:].zfill(8)})")
    print(f"Clear bit 0: {tricks.clear_bit(n, 0)} ({bin(tricks.clear_bit(n, 0))[2:].zfill(8)})")
    print(f"Toggle bit 4: {tricks.toggle_bit(n, 4)} ({bin(tricks.toggle_bit(n, 4))[2:].zfill(8)})")

demo_all_tricks()
```

---

## Practice Problems

```python
# Problem 1: Find missing number using XOR
def find_missing_number(arr, n):
    """
    Find missing number from 0 to n
    XOR all numbers and indices
    """
    xor_all = n
    for i, num in enumerate(arr):
        xor_all ^= i ^ num
    return xor_all

# Test
arr = [0, 1, 3, 4, 5]
print(f"Array: {arr}")
print(f"Missing: {find_missing_number(arr, 5)}")

# Problem 2: Count bits to flip to convert A to B
def bits_to_flip(a, b):
    """
    Count bits that differ between a and b
    XOR gives bits that are different
    """
    xor = a ^ b
    count = 0
    while xor:
        count += 1
        xor &= (xor - 1)  # Remove rightmost bit
    return count

print(f"\nBits to flip 29 to 15: {bits_to_flip(29, 15)}")

# Problem 3: Reverse bits
def reverse_bits(n, bits=8):
    """Reverse bit order"""
    result = 0
    for i in range(bits):
        if n & (1 << i):
            result |= (1 << (bits - 1 - i))
    return result

n = 45  # 00101101
reversed_n = reverse_bits(n)
print(f"\nOriginal: {n} = {bin(n)[2:].zfill(8)}")
print(f"Reversed: {reversed_n} = {bin(reversed_n)[2:].zfill(8)}")
```

---

## üéØ Key Takeaways

1. **n & (n-1)** removes rightmost set bit
2. **n & -n** isolates rightmost set bit
3. **(1 << i)** creates single-bit mask at position i
4. **(1 << n) - 1** creates mask with n bits set
5. **XOR** is magical for finding unique elements
6. **Know these patterns** - they appear in 90% of bit problems!

**Master these 13 tricks and you're ready for advanced patterns!**