# Chapter 8: Common Interview Problems & Templates (In-Depth)

## 8.1 Template: Check Bit Property

### 8.1.1 Check if i-th Bit is Set

```python
def is_bit_set(n, i):
    """
    Method 1: Use AND with mask
    Create mask with only i-th bit set: (1 << i)
    AND with n, if result != 0, bit is set
    
    Example: n=12 (1100), i=2
    1 << 2 = 0100
    1100 & 0100 = 0100 != 0 → True
    """
    return (n & (1 << i)) != 0

def is_bit_set_v2(n, i):
    """
    Method 2: Right shift and check LSB
    Shift n right by i positions, check if LSB is 1
    """
    return ((n >> i) & 1) == 1

# Test both methods
n = 12  # 1100 in binary
print(f"Binary of {n}: {bin(n)}")
for i in range(4):
    print(f"Bit {i}: {is_bit_set(n, i)}")

# Output:
# Bit 0: False
# Bit 1: False
# Bit 2: True
# Bit 3: True
```

**Visual Explanation**:
```
n = 12 = 1100

Check bit 2:
  1 << 2 = 0100
  1100 & 0100 = 0100 (non-zero) → bit is SET ✓

Check bit 1:
  1 << 1 = 0010
  1100 & 0010 = 0000 (zero) → bit is CLEAR ✗
```

---

### 8.1.2 Count Bits in Range

```python
def count_bits_in_range(n, start, end):
    """
    Count set bits between positions start and end (inclusive)
    
    Example: n=29 (11101), start=1, end=3
    Bits at positions 1,2,3: 110 → count = 2
    """
    count = 0
    for i in range(start, end + 1):
        if n & (1 << i):
            count += 1
    return count

# Alternative: Create mask and count
def count_bits_in_range_v2(n, start, end):
    # Create mask for range [start, end]
    mask = ((1 << (end + 1)) - 1) - ((1 << start) - 1)
    masked = n & mask
    return bin(masked).count('1')

# Test
n = 29  # 11101
print(count_bits_in_range(n, 1, 3))  # Output: 2
```

---

## 8.2 Template: Modify Bit

### 8.2.1 Set Bit (Turn ON)

```python
def set_bit(n, i):
    """
    Set i-th bit to 1 (if not already)
    
    Use OR with mask: n | (1 << i)
    OR ensures bit becomes 1 regardless of original value
    
    Example: n=12 (1100), i=1
    1 << 1 = 0010
    1100 | 0010 = 1110 = 14
    """
    return n | (1 << i)

# Test
n = 12  # 1100
print(f"Before: {bin(n)}")
n = set_bit(n, 1)
print(f"After setting bit 1: {bin(n)}")  # 1110

# Multiple bits
def set_multiple_bits(n, positions):
    """Set multiple bits at once"""
    for i in positions:
        n |= (1 << i)
    return n

print(set_multiple_bits(0, [0, 2, 4]))  # 10101 = 21
```

**Why OR works**:
```
Original bit | Mask | Result
     0       |  1   |   1    (bit gets SET)
     1       |  1   |   1    (bit stays SET)
```

---

### 8.2.2 Clear Bit (Turn OFF)

```python
def clear_bit(n, i):
    """
    Clear i-th bit (set to 0)
    
    Use AND with inverted mask: n & ~(1 << i)
    ~(1 << i) has all bits 1 except i-th bit
    
    Example: n=14 (1110), i=1
    1 << 1 = 0010
    ~0010 = 1101
    1110 & 1101 = 1100 = 12
    """
    return n & ~(1 << i)

# Test
n = 14  # 1110
print(f"Before: {bin(n)}")
n = clear_bit(n, 1)
print(f"After clearing bit 1: {bin(n)}")  # 1100

# Clear multiple bits
def clear_multiple_bits(n, positions):
    """Clear multiple bits at once"""
    for i in positions:
        n &= ~(1 << i)
    return n

print(bin(clear_multiple_bits(31, [0, 2, 4])))  # 11111 → 01010
```

**Why AND with NOT works**:
```
Original bit | Mask | Result
     0       |  0   |   0    (bit stays CLEAR)
     1       |  0   |   0    (bit gets CLEAR)
```

---

### 8.2.3 Toggle Bit (Flip)

```python
def toggle_bit(n, i):
    """
    Toggle i-th bit (0→1, 1→0)
    
    Use XOR with mask: n ^ (1 << i)
    XOR flips the bit
    
    Example: n=12 (1100), i=0
    1 << 0 = 0001
    1100 ^ 0001 = 1101 = 13
    """
    return n ^ (1 << i)

# Test
n = 12  # 1100
print(f"Before: {bin(n)}")
n = toggle_bit(n, 0)
print(f"After toggling bit 0: {bin(n)}")  # 1101

# Toggle multiple times
n = 12
for _ in range(2):
    n = toggle_bit(n, 2)
print(f"After double toggle: {bin(n)}")  # Same as original
```

**Why XOR works**:
```
Original bit | Mask | Result
     0       |  1   |   1    (bit gets SET)
     1       |  1   |   0    (bit gets CLEAR)
```

---

### 8.2.4 Update Bit to Specific Value

```python
def update_bit(n, i, value):
    """
    Set i-th bit to specific value (0 or 1)
    
    Strategy:
    1. Clear the bit first: n & ~(1 << i)
    2. OR with new value shifted: | (value << i)
    """
    # Clear bit i
    n = n & ~(1 << i)
    # Set to value
    n = n | (value << i)
    return n

# Test
n = 12  # 1100
print(f"Original: {bin(n)}")
n = update_bit(n, 1, 1)  # Set bit 1 to 1
print(f"After update: {bin(n)}")  # 1110
```

---

## 8.3 Template: Iterate Set Bits

### 8.3.1 Iterate Through All Set Bits

```python
def iterate_set_bits(n):
    """
    Process each set bit efficiently
    Uses n & (n-1) to clear rightmost set bit
    """
    positions = []
    original = n
    
    while n:
        # Find position of rightmost set bit
        rightmost = n & (-n)
        position = (rightmost).bit_length() - 1
        positions.append(position)
        
        # Clear rightmost set bit
        n = n & (n - 1)
    
    return positions

# Test
n = 26  # 11010
print(f"Set bit positions in {n} ({bin(n)}): {iterate_set_bits(n)}")
# Output: [1, 3, 4]
```

**Visual Process**:
```
n = 26 = 11010

Iteration 1:
  rightmost = 11010 & -11010 = 00010 (bit 1)
  n = 11010 & 11001 = 11000

Iteration 2:
  rightmost = 11000 & -11000 = 01000 (bit 3)
  n = 11000 & 10111 = 10000

Iteration 3:
  rightmost = 10000 & -10000 = 10000 (bit 4)
  n = 10000 & 01111 = 00000

Positions: [1, 3, 4]
```

---

### 8.3.2 Process Set Bits with Values

```python
def process_set_bits_with_values(n):
    """
    Calculate sum of powers corresponding to set bits
    
    Example: n=13 (1101)
    Bits set at: 0, 2, 3
    Sum = 2^0 + 2^2 + 2^3 = 1 + 4 + 8 = 13
    """
    total = 0
    position = 0
    
    while n:
        if n & 1:
            total += (1 << position)
        n >>= 1
        position += 1
    
    return total

# Test
print(process_set_bits_with_values(13))  # Output: 13
```

---

## 8.4 Template: Bitmask DP

### 8.4.1 General Bitmask DP Framework

```python
def bitmask_dp_template(n, data):
    """
    General template for bitmask DP problems
    
    State: dp[mask][additional_dimension]
    - mask: represents which elements are selected/visited
    - additional_dimension: could be last element, current position, etc.
    
    Transition: Try all valid next moves
    """
    INF = float('inf')
    
    # Initialize DP table
    dp = [[INF] * n for _ in range(1 << n)]
    
    # Base case
    dp[0][0] = 0  # or appropriate base case
    
    # Iterate through all masks
    for mask in range(1 << n):
        for i in range(n):
            if dp[mask][i] == INF:
                continue
            
            # Try next element
            for j in range(n):
                if mask & (1 << j):  # j already used
                    continue
                
                new_mask = mask | (1 << j)
                # Update dp[new_mask][j] based on transition
                # dp[new_mask][j] = min(dp[new_mask][j], dp[mask][i] + cost)
    
    # Extract answer from final states
    full_mask = (1 << n) - 1
    return min(dp[full_mask])

# Example: Shortest Hamiltonian Path
def shortest_hamiltonian_path(graph):
    """
    Find shortest path that visits all nodes exactly once
    
    dp[mask][i] = minimum distance to visit nodes in mask, ending at i
    """
    n = len(graph)
    INF = float('inf')
    dp = [[INF] * n for _ in range(1 << n)]
    
    # Can start from any node
    for i in range(n):
        dp[1 << i][i] = 0
    
    for mask in range(1 << n):
        for last in range(n):
            if not (mask & (1 << last)):
                continue
            if dp[mask][last] == INF:
                continue
            
            for next_node in range(n):
                if mask & (1 << next_node):
                    continue
                
                new_mask = mask | (1 << next_node)
                new_dist = dp[mask][last] + graph[last][next_node]
                dp[new_mask][next_node] = min(dp[new_mask][next_node], new_dist)
    
    # Find minimum among all ending nodes
    full_mask = (1 << n) - 1
    return min(dp[full_mask])

# Test
graph = [
    [0, 1, 15, 6],
    [2, 0, 7, 3],
    [9, 6, 0, 12],
    [10, 4, 8, 0]
]
print(shortest_hamiltonian_path(graph))
```

---

### 8.4.2 Subset DP with Bitmask

```python
def subset_sum_dp(nums, target):
    """
    Find if any subset sums to target using DP with bitmask
    
    dp[mask] = True if subset represented by mask sums to <= target
    """
    n = len(nums)
    dp = [False] * (1 << n)
    dp[0] = True  # Empty subset
    
    for mask in range(1 << n):
        if not dp[mask]:
            continue
        
        current_sum = sum(nums[i] for i in range(n) if mask & (1 << i))
        
        if current_sum == target:
            return True
        
        for i in range(n):
            if mask & (1 << i):  # Already included
                continue
            if current_sum + nums[i] <= target:
                dp[mask | (1 << i)] = True
    
    return False

# Test
print(subset_sum_dp([3, 34, 4, 12, 5, 2], 9))  # True (4+5=9)
```

---

## 8.5 Complete Interview Problems with Solutions

### Problem 1: Number of 1 Bits

```python
def hamming_weight(n):
    """
    LeetCode 191: Number of 1 Bits
    
    Write a function that takes an unsigned integer and returns 
    the number of '1' bits it has.
    
    Example: n = 11 (00000000000000000000000000001011)
    Output: 3
    """
    count = 0
    while n:
        n &= n - 1  # Clear rightmost set bit
        count += 1
    return count

# Test
print(hamming_weight(11))  # Output: 3
print(hamming_weight(128))  # Output: 1
```

---

### Problem 2: Counting Bits

```python
def counting_bits(n):
    """
    LeetCode 338: Counting Bits
    
    Given integer n, return array where ans[i] is number of 1's 
    in binary representation of i.
    
    Example: n = 5
    Output: [0,1,1,2,1,2]
    
    Explanation:
    0 → 0 (0 ones)
    1 → 1 (1 one)
    2 → 10 (1 one)
    3 → 11 (2 ones)
    4 → 100 (1 one)
    5 → 101 (2 ones)
    """
    # Method 1: Using previous results
    result = [0] * (n + 1)
    for i in range(1, n + 1):
        result[i] = result[i >> 1] + (i & 1)
    return result

# Method 2: Using i & (i-1)
def counting_bits_v2(n):
    result = [0] * (n + 1)
    for i in range(1, n + 1):
        result[i] = result[i & (i - 1)] + 1
    return result

# Test
print(counting_bits(5))  # [0, 1, 1, 2, 1, 2]
```

**Recurrence Explanation**:
```
result[i] = result[i >> 1] + (i & 1)

Why? 
- i >> 1 removes the last bit
- i & 1 checks if last bit is 1

Example: i = 5 (101)
  i >> 1 = 2 (10)
  result[5] = result[2] + 1 = 1 + 1 = 2 ✓
```

---

### Problem 3: Bitwise AND of Numbers Range

```python
def range_bitwise_and(left, right):
    """
    LeetCode 201: Bitwise AND of Numbers Range
    
    Given two integers left and right, return bitwise AND of all 
    numbers in range [left, right].
    
    Example: left = 5, right = 7
    5 = 101
    6 = 110
    7 = 111
    AND = 100 = 4
    
    Key insight: Find common prefix of left and right
    """
    shift = 0
    # Find common prefix by removing different bits
    while left < right:
        left >>= 1
        right >>= 1
        shift += 1
    
    # Restore the common prefix
    return left << shift

# Alternative: Keep removing rightmost bit from right until <= left
def range_bitwise_and_v2(left, right):
    while left < right:
        right = right & (right - 1)
    return right

# Test
print(range_bitwise_and(5, 7))  # Output: 4
print(range_bitwise_and(1, 2147483647))  # Output: 0
```

**Visual Explanation**:
```
left = 5 = 101
right = 7 = 111

Step 1: right = 7 & 6 = 111 & 110 = 110 = 6
Step 2: right = 6 & 5 = 110 & 101 = 100 = 4
Step 3: left < right? No, stop

Answer: 4
```

---

### Problem 4: UTF-8 Validation

```python
def valid_utf8(data):
    """
    LeetCode 393: UTF-8 Validation
    
    Return if data represents valid UTF-8 encoding
    
    UTF-8 rules:
    1-byte: 0xxxxxxx
    2-byte: 110xxxxx 10xxxxxx
    3-byte: 1110xxxx 10xxxxxx 10xxxxxx
    4-byte: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
    """
    n_bytes = 0
    
    # Masks to check patterns
    mask1 = 1 << 7    # 10000000
    mask2 = 1 << 6    # 01000000
    
    for num in data:
        mask = 1 << 7
        
        if n_bytes == 0:
            # Count leading 1s to determine byte count
            while mask & num:
                n_bytes += 1
                mask >>= 1
            
            # 1-byte character
            if n_bytes == 0:
                continue
            
            # Invalid if 1 or > 4 bytes
            if n_bytes == 1 or n_bytes > 4:
                return False
        else:
            # Check if it's a continuation byte (10xxxxxx)
            if not (num & mask1 and not (num & mask2)):
                return False
        
        n_bytes -= 1
    
    return n_bytes == 0

# Test
print(valid_utf8([197, 130, 1]))  # True
print(valid_utf8([235, 140, 4]))  # False
```

---

### Problem 5: Maximum Product of Word Lengths

```python
def max_product(words):
    """
    LeetCode 318: Maximum Product of Word Lengths
    
    Find maximum product of lengths of two words that share no letters.
    
    Strategy: Use bitmask to represent letters in each word
    If two masks have no common bits (AND = 0), words share no letters
    """
    n = len(words)
    masks = [0] * n
    
    # Create bitmask for each word
    for i, word in enumerate(words):
        for char in word:
            # Set bit for this character
            masks[i] |= 1 << (ord(char) - ord('a'))
    
    max_prod = 0
    
    # Check all pairs
    for i in range(n):
        for j in range(i + 1, n):
            # If no common letters
            if masks[i] & masks[j] == 0:
                max_prod = max(max_prod, len(words[i]) * len(words[j]))
    
    return max_prod

# Test
words = ["abcw", "baz", "foo", "bar", "xtfn", "abcdef"]
print(max_product(words))  # Output: 16 ("abcw" x "xtfn")
```

**Bitmask Example**:
```
"abc" → set bits at positions 0, 1, 2 → 0000...0111
"xyz" → set bits at positions 23, 24, 25 → 111...0000

"abc" & "xyz" = 0 → no common letters ✓
```

---

## Summary: Essential Templates

### Quick Reference
```python
# Check bit
is_set = (n & (1 << i)) != 0

# Set bit
n |= (1 << i)

# Clear bit
n &= ~(1 << i)

# Toggle bit
n ^= (1 << i)

# Isolate rightmost set bit
rightmost = n & (-n)

# Clear rightmost set bit
n &= (n - 1)

# Check power of 2
is_power = n > 0 and (n & (n - 1)) == 0

# Create mask with n bits set
mask = (1 << n) - 1

# Iterate set bits
while n:
    # Process
    n &= (n - 1)
```

Practice these templates until they become second nature!