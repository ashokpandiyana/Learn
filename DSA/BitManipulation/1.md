# Chapter 1: Fundamentals of Binary & Bit Representation
## Deep Dive into Binary Number Systems

---

## 1.1 Binary Number System

### What is Binary?

Binary is a **base-2 number system** that uses only two digits: **0** and **1**. In contrast, our everyday decimal system is base-10 (uses digits 0-9). Every number in a computer is represented in binary.

**Why Binary?**
- Computers use transistors that have two states: ON (1) and OFF (0)
- Easy to implement electronically
- Simple logic operations
- Reliable signal detection

---

### 1.1.1 Binary to Decimal Conversion

Each position in a binary number represents a power of 2, starting from the rightmost position (2‚Å∞).

**Formula:**
```
Decimal = (bit_n √ó 2^n) + (bit_n-1 √ó 2^(n-1)) + ... + (bit_1 √ó 2^1) + (bit_0 √ó 2^0)
```

**Visual Example:**
```
Binary: 1 0 1 1 0 1
Position: ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì
Power:   2‚Åµ 2‚Å¥ 2¬≥ 2¬≤ 2¬π 2‚Å∞
Value:   32 16 8  4  2  1

Calculation:
(1√ó32) + (0√ó16) + (1√ó8) + (1√ó4) + (0√ó2) + (1√ó1)
= 32 + 0 + 8 + 4 + 0 + 1
= 45
```

**Python Implementation:**

```python
def binary_to_decimal(binary_str):
    """
    Convert binary string to decimal
    
    Args:
        binary_str: String of 0s and 1s (e.g., "101101")
    Returns:
        Decimal integer value
    """
    decimal = 0
    power = 0
    
    # Process from right to left
    for i in range(len(binary_str) - 1, -1, -1):
        if binary_str[i] == '1':
            decimal += 2 ** power
        power += 1
    
    return decimal

# Test examples
print(binary_to_decimal("1011"))      # Output: 11
print(binary_to_decimal("101101"))    # Output: 45
print(binary_to_decimal("11111111"))  # Output: 255

# Python built-in method
print(int("1011", 2))                 # Output: 11
```

**Method 2: Using Bit Shifting (More Efficient)**

```python
def binary_to_decimal_optimized(binary_str):
    """
    Convert binary to decimal using bit operations
    """
    decimal = 0
    for bit in binary_str:
        decimal = (decimal << 1) | int(bit)
    return decimal

print(binary_to_decimal_optimized("1011"))  # Output: 11
```

---

### 1.1.2 Decimal to Binary Conversion

Two common methods:

**Method 1: Division by 2 (Bottom-up)**

Keep dividing by 2 and track remainders, then read remainders from bottom to top.

```
Convert 45 to binary:

45 √∑ 2 = 22  remainder 1  ‚Üë
22 √∑ 2 = 11  remainder 0  |
11 √∑ 2 = 5   remainder 1  |
5  √∑ 2 = 2   remainder 1  |
2  √∑ 2 = 1   remainder 0  |
1  √∑ 2 = 0   remainder 1  | Read upward

Binary: 101101
```

**Python Implementation:**

```python
def decimal_to_binary(n):
    """
    Convert decimal to binary string
    
    Args:
        n: Positive decimal integer
    Returns:
        Binary string representation
    """
    if n == 0:
        return "0"
    
    binary = ""
    while n > 0:
        remainder = n % 2
        binary = str(remainder) + binary  # Prepend to string
        n = n // 2
    
    return binary

# Test examples
print(decimal_to_binary(45))   # Output: "101101"
print(decimal_to_binary(255))  # Output: "11111111"
print(decimal_to_binary(16))   # Output: "10000"

# Python built-in methods
print(bin(45))                 # Output: "0b101101" (0b prefix)
print(bin(45)[2:])             # Output: "101101" (remove prefix)
print(format(45, 'b'))         # Output: "101101"
```

**Method 2: Using Bit Operations**

```python
def decimal_to_binary_bits(n):
    """
    Convert decimal to binary using bit operations
    """
    if n == 0:
        return "0"
    
    binary = ""
    while n > 0:
        binary = str(n & 1) + binary  # Check if last bit is 1
        n >>= 1                        # Right shift by 1
    
    return binary

print(decimal_to_binary_bits(45))  # Output: "101101"
```

---

### 1.1.3 Signed vs Unsigned Integers

**Unsigned Integers:**
- Can only represent non-negative numbers (0 and positive)
- All bits represent magnitude
- Range for n bits: 0 to 2^n - 1

```
8-bit unsigned:  00000000 to 11111111 (0 to 255)
16-bit unsigned: 0 to 65,535
32-bit unsigned: 0 to 4,294,967,295
```

**Signed Integers:**
- Can represent both positive and negative numbers
- Most Significant Bit (MSB) represents sign
  - MSB = 0: Positive number
  - MSB = 1: Negative number
- Range for n bits: -2^(n-1) to 2^(n-1) - 1

```
8-bit signed:  -128 to 127
16-bit signed: -32,768 to 32,767
32-bit signed: -2,147,483,648 to 2,147,483,647
```

**Visual Representation (8-bit):**
```
Unsigned:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ All bits represent magnitude        ‚îÇ
‚îÇ 0 0 0 0 0 0 0 0  ‚Üí  0               ‚îÇ
‚îÇ 1 1 1 1 1 1 1 1  ‚Üí  255             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Signed (Two's Complement):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ MSB = Sign | Rest = Magnitude       ‚îÇ
‚îÇ 0 1 1 1 1 1 1 1  ‚Üí  +127            ‚îÇ
‚îÇ 0 0 0 0 0 0 0 0  ‚Üí  0               ‚îÇ
‚îÇ 1 0 0 0 0 0 0 0  ‚Üí  -128            ‚îÇ
‚îÇ 1 1 1 1 1 1 1 1  ‚Üí  -1              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Python Code:**

```python
# Python integers are arbitrary precision (unlimited size)
# But we can simulate fixed-width behavior

def to_unsigned_8bit(value):
    """Convert to 8-bit unsigned (0-255)"""
    return value & 0xFF

def to_signed_8bit(value):
    """Convert to 8-bit signed (-128 to 127)"""
    value = value & 0xFF
    if value >= 128:  # If MSB is set
        value = value - 256  # Convert to negative
    return value

# Examples
print(to_unsigned_8bit(300))    # Output: 44 (300 % 256)
print(to_unsigned_8bit(-5))     # Output: 251

print(to_signed_8bit(127))      # Output: 127
print(to_signed_8bit(200))      # Output: -56
print(to_signed_8bit(255))      # Output: -1
```

---

### 1.1.4 Two's Complement Representation

**What is Two's Complement?**

Two's complement is the standard way computers represent negative numbers. It allows for simple arithmetic operations without separate circuits for subtraction.

**Why Two's Complement?**
1. Only one representation for zero (no +0 and -0)
2. Addition/subtraction use same circuitry
3. Sign extension is straightforward
4. Range is symmetric around zero

**How to Calculate Two's Complement:**

**Method 1: Flip and Add**
1. Write positive number in binary
2. Flip all bits (1‚Üí0, 0‚Üí1) - this is called **One's Complement**
3. Add 1

```
Example: Find -6 in 8-bit two's complement

Step 1: +6 in binary
   00000110

Step 2: Flip all bits (One's Complement)
   11111001

Step 3: Add 1
   11111001
 +        1
   --------
   11111010  ‚Üê This is -6 in two's complement
```

**Method 2: Keep Rightmost 1 and Flip Rest**
1. Starting from right, keep all bits same until you hit the first 1 (inclusive)
2. Flip all remaining bits to the left

```
Example: -6

+6 = 00000110
     ‚Üì‚Üì‚Üì‚Üì‚Üì‚Üë‚Üë (flip these, keep these)
-6 = 11111010
```

**Visual Understanding:**
```
8-bit Two's Complement Number Line:

     10000000 = -128
     10000001 = -127
     ...
     11111110 = -2
     11111111 = -1
     00000000 =  0
     00000001 =  1
     00000010 =  2
     ...
     01111111 =  127
```

**Python Implementation:**

```python
def twos_complement(n, bits=8):
    """
    Calculate two's complement representation
    
    Args:
        n: Integer (can be positive or negative)
        bits: Number of bits (default 8)
    Returns:
        Two's complement as binary string
    """
    if n >= 0:
        # Positive numbers: just convert to binary
        binary = bin(n)[2:].zfill(bits)
    else:
        # Negative numbers: calculate two's complement
        # Method: (2^bits) + n
        max_val = 2 ** bits
        binary = bin(max_val + n)[2:]
    
    return binary

# Test examples
print(f"+6 in 8-bit: {twos_complement(6, 8)}")    # 00000110
print(f"-6 in 8-bit: {twos_complement(-6, 8)}")   # 11111010
print(f"-1 in 8-bit: {twos_complement(-1, 8)}")   # 11111111
print(f"-128 in 8-bit: {twos_complement(-128, 8)}") # 10000000

def twos_comp_to_decimal(binary_str):
    """
    Convert two's complement binary to decimal
    """
    bits = len(binary_str)
    # Check if negative (MSB = 1)
    if binary_str[0] == '1':
        # It's negative: flip bits and add 1
        flipped = ''.join('1' if b == '0' else '0' for b in binary_str)
        value = int(flipped, 2) + 1
        return -value
    else:
        # It's positive
        return int(binary_str, 2)

# Test reverse conversion
print(twos_comp_to_decimal("00000110"))  # Output: 6
print(twos_comp_to_decimal("11111010"))  # Output: -6
print(twos_comp_to_decimal("11111111"))  # Output: -1
```

**Key Property:** To negate a number in two's complement, take two's complement again!
```python
def negate(n, bits=8):
    """Negate a number using two's complement"""
    mask = (1 << bits) - 1
    return ((~n) + 1) & mask

print(f"6 negated: {negate(6)}")      # Output: 250 (which is -6 in 8-bit)
print(f"250 negated: {negate(250)}")  # Output: 6 (back to positive)
```

**Why Two's Complement Addition Works:**

```
Add 5 + (-3) = 2:

  00000101  (5)
+ 11111101  (-3 in two's complement)
  --------
 100000010  (carry is ignored in fixed-width)
  00000010  (2) ‚úì Correct!
```

---

## 1.2 Bit Indexing & Terminology

### Understanding Bit Positions

Bits are indexed from **right to left**, starting at position **0**.

```
Binary Number: 1 0 1 1 0 1 0 1

Bit Index:     7 6 5 4 3 2 1 0
               ‚Üì               ‚Üì
              MSB             LSB

Position 7: Most Significant Bit (MSB)
Position 0: Least Significant Bit (LSB)
```

### Key Terminology

**1. Least Significant Bit (LSB)**
- The **rightmost** bit (position 0)
- Represents the smallest power of 2 (2‚Å∞ = 1)
- Determines if number is odd (LSB=1) or even (LSB=0)

```python
def get_lsb(n):
    """Get the Least Significant Bit"""
    return n & 1

def is_odd(n):
    """Check if number is odd using LSB"""
    return (n & 1) == 1

def is_even(n):
    """Check if number is even using LSB"""
    return (n & 1) == 0

# Examples
print(f"LSB of 5: {get_lsb(5)}")   # Output: 1
print(f"LSB of 8: {get_lsb(8)}")   # Output: 0
print(f"Is 7 odd? {is_odd(7)}")    # Output: True
print(f"Is 10 even? {is_even(10)}") # Output: True
```

**2. Most Significant Bit (MSB)**
- The **leftmost** bit
- In signed integers, indicates sign (0=positive, 1=negative)
- Represents the largest power of 2 in the representation

```python
def get_msb_position(n):
    """Find position of MSB (leftmost set bit)"""
    if n == 0:
        return -1
    
    position = 0
    while n > 1:
        n >>= 1
        position += 1
    return position

def get_msb_value(n):
    """Get the value at MSB position"""
    if n == 0:
        return 0
    pos = get_msb_position(n)
    return 1 << pos

# Examples
print(f"MSB position of 45 (101101): {get_msb_position(45)}")  # Output: 5
print(f"MSB value of 45: {get_msb_value(45)}")                 # Output: 32
print(f"MSB position of 255: {get_msb_position(255)}")         # Output: 7
```

**3. Set Bit**
- A bit with value **1**
- Also called "on" bit or "high" bit

```python
def count_set_bits(n):
    """Count number of set bits (bits with value 1)"""
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count

# Alternative using Python's built-in
def count_set_bits_builtin(n):
    return bin(n).count('1')

print(f"Set bits in 45 (101101): {count_set_bits(45)}")  # Output: 4
print(f"Set bits in 255: {count_set_bits(255)}")         # Output: 8
```

**4. Clear Bit**
- A bit with value **0**
- Also called "off" bit or "low" bit

```python
def count_clear_bits(n, total_bits=8):
    """Count number of clear bits in fixed-width representation"""
    return total_bits - count_set_bits(n)

print(f"Clear bits in 45 (8-bit): {count_clear_bits(45)}")  # Output: 4
```

**5. Bit Position**
- 0-based index from right to left
- Used to identify specific bits in operations

```python
def get_bit_at_position(n, pos):
    """Get bit value at specific position"""
    return (n >> pos) & 1

def print_bits_with_positions(n, width=8):
    """Print number in binary with position labels"""
    binary = bin(n)[2:].zfill(width)
    print(f"Number: {n}")
    print(f"Binary: {binary}")
    print(f"Position: ", end="")
    for i in range(width-1, -1, -1):
        print(i, end=" ")
    print("\nBit Value:", end="")
    for i in range(width-1, -1, -1):
        print(get_bit_at_position(n, i), end=" ")
    print("\n")

# Example usage
print_bits_with_positions(45)
```

**Output:**
```
Number: 45
Binary: 00101101
Position: 7 6 5 4 3 2 1 0
Bit Value:0 0 1 0 1 1 0 1
```

---

## Visual Summary

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    8-Bit Number: 45                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                             ‚îÇ
‚îÇ  Binary:     0    0    1    0    1    1    0    1         ‚îÇ
‚îÇ              ‚Üì    ‚Üì    ‚Üì    ‚Üì    ‚Üì    ‚Üì    ‚Üì    ‚Üì         ‚îÇ
‚îÇ  Position:   7    6    5    4    3    2    1    0         ‚îÇ
‚îÇ              ‚Üë                                  ‚Üë           ‚îÇ
‚îÇ             MSB                                LSB          ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  Value:    0√ó128 0√ó64 1√ó32 0√ó16 1√ó8  1√ó4  0√ó2  1√ó1        ‚îÇ
‚îÇ              0    0    32   0    8    4    0    1         ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  Sum: 0 + 0 + 32 + 0 + 8 + 4 + 0 + 1 = 45                 ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  Set Bits: positions 0, 2, 3, 5 (count = 4)               ‚îÇ
‚îÇ  Clear Bits: positions 1, 4, 6, 7 (count = 4)             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Practical Applications

```python
# Application 1: Extract nibbles (4-bit groups)
def get_high_nibble(byte):
    """Get upper 4 bits of a byte"""
    return (byte >> 4) & 0xF

def get_low_nibble(byte):
    """Get lower 4 bits of a byte"""
    return byte & 0xF

print(f"45 = 0x{45:02X}")
print(f"High nibble: {get_high_nibble(45)} (binary: {bin(get_high_nibble(45))[2:].zfill(4)})")
print(f"Low nibble: {get_low_nibble(45)} (binary: {bin(get_low_nibble(45))[2:].zfill(4)})")

# Application 2: Pack/Unpack RGB color values
def pack_rgb(r, g, b):
    """Pack RGB values (0-255) into single integer"""
    return (r << 16) | (g << 8) | b

def unpack_rgb(color):
    """Unpack integer into RGB values"""
    r = (color >> 16) & 0xFF
    g = (color >> 8) & 0xFF
    b = color & 0xFF
    return r, g, b

color = pack_rgb(255, 128, 64)
print(f"Packed color: 0x{color:06X}")
r, g, b = unpack_rgb(color)
print(f"Unpacked: R={r}, G={g}, B={b}")
```

---

## üéØ Key Takeaways

1. **Binary is base-2**: Only uses 0 and 1
2. **Bit positions** are 0-indexed from right to left
3. **Two's complement** is the standard for negative numbers
4. **MSB** determines sign in signed integers
5. **LSB** determines odd/even parity
6. Understanding bit representation is crucial for bit manipulation

---

## Practice Exercises

Try these to solidify your understanding:

```python
# Exercise 1: Convert between binary and decimal
def exercise_1():
    print("Exercise 1: Conversions")
    print(f"Binary 11010 = {binary_to_decimal('11010')}")  # Should be 26
    print(f"Decimal 100 = {decimal_to_binary(100)}")       # Should be 1100100

# Exercise 2: Work with signed integers
def exercise_2():
    print("\nExercise 2: Signed Integers")
    for num in [-1, -5, -128, 127]:
        binary = twos_complement(num, 8)
        decimal = twos_comp_to_decimal(binary)
        print(f"{num} ‚Üí {binary} ‚Üí {decimal}")

# Exercise 3: Bit position operations
def exercise_3():
    print("\nExercise 3: Bit Positions")
    n = 45
    print(f"Number: {n} (binary: {bin(n)[2:].zfill(8)})")
    print(f"LSB: {get_lsb(n)}")
    print(f"MSB position: {get_msb_position(n)}")
    print(f"Set bits: {count_set_bits(n)}")

# Run exercises
exercise_1()
exercise_2()
exercise_3()
```

This foundational knowledge will be crucial as we move into bitwise operators and advanced manipulation techniques!