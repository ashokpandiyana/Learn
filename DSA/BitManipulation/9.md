# Chapter 9: Optimization Techniques (In-Depth)

## 9.1 Space Optimization

### 9.1.1 Bit Arrays vs Boolean Arrays

**Problem**: Store 1 million boolean values efficiently.

```python
class BitArray:
    """
    Efficient storage using bits instead of bytes
    
    Memory comparison:
    - Boolean array: 1 million bytes = ~1 MB
    - Bit array: 1 million bits = ~125 KB (8x reduction!)
    """
    def __init__(self, size):
        # Each integer stores 32 bits (assuming 32-bit int)
        self.size = size
        self.data = [0] * ((size + 31) // 32)
    
    def set(self, index):
        """Set bit at index to 1"""
        if index >= self.size:
            raise IndexError("Index out of bounds")
        
        # Find which integer contains this bit
        int_index = index // 32
        # Find position within that integer
        bit_position = index % 32
        
        self.data[int_index] |= (1 << bit_position)
    
    def clear(self, index):
        """Set bit at index to 0"""
        int_index = index // 32
        bit_position = index % 32
        self.data[int_index] &= ~(1 << bit_position)
    
    def get(self, index):
        """Get bit value at index"""
        int_index = index // 32
        bit_position = index % 32
        return (self.data[int_index] & (1 << bit_position)) != 0
    
    def toggle(self, index):
        """Flip bit at index"""
        int_index = index // 32
        bit_position = index % 32
        self.data[int_index] ^= (1 << bit_position)

# Test
bit_array = BitArray(100)
bit_array.set(0)
bit_array.set(50)
bit_array.set(99)

print(f"Bit 0: {bit_array.get(0)}")   # True
print(f"Bit 50: {bit_array.get(50)}") # True
print(f"Bit 25: {bit_array.get(25)}") # False

# Memory analysis
import sys
regular_array = [False] * 1000000
bit_array_obj = BitArray(1000000)
print(f"Regular array: {sys.getsizeof(regular_array)} bytes")
print(f"Bit array data: {sys.getsizeof(bit_array_obj.data)} bytes")
```

**Visual Representation**:
```
BitArray storing 100 elements:

data[0]: bits 0-31
  [0][1][2]...[31]
  
data[1]: bits 32-63
  [32][33]...[63]
  
data[2]: bits 64-95
  [64][65]...[95]
  
data[3]: bits 96-99
  [96][97][98][99]

Each integer stores 32 bits, total needed: ⌈100/32⌉ = 4 integers
```

---

### 9.1.2 Packing Multiple Values in Single Integer

```python
class ColorPixel:
    """
    Pack RGB values (0-255) into single 32-bit integer
    
    Format: [unused 8 bits][R 8 bits][G 8 bits][B 8 bits]
    Example: Red=255, Green=128, Blue=64
    Binary: 00000000 11111111 10000000 01000000
    """
    def __init__(self, r, g, b):
        # Pack into single integer
        self.packed = (r << 16) | (g << 8) | b
    
    def get_red(self):
        """Extract red component"""
        return (self.packed >> 16) & 0xFF
    
    def get_green(self):
        """Extract green component"""
        return (self.packed >> 8) & 0xFF
    
    def get_blue(self):
        """Extract blue component"""
        return self.packed & 0xFF
    
    def set_red(self, r):
        """Update red component"""
        # Clear red bits and set new value
        self.packed = (self.packed & 0x00FFFF) | (r << 16)
    
    def set_green(self, g):
        """Update green component"""
        self.packed = (self.packed & 0xFF00FF) | (g << 8)
    
    def set_blue(self, b):
        """Update blue component"""
        self.packed = (self.packed & 0xFFFF00) | b

# Test
pixel = ColorPixel(255, 128, 64)
print(f"Red: {pixel.get_red()}")     # 255
print(f"Green: {pixel.get_green()}") # 128
print(f"Blue: {pixel.get_blue()}")   # 64

pixel.set_green(200)
print(f"New Green: {pixel.get_green()}")  # 200
```

**Bit Layout**:
```
32-bit integer for RGB:

[31-24]: Unused (8 bits)
[23-16]: Red    (8 bits) - values 0-255
[15-8]:  Green  (8 bits) - values 0-255
[7-0]:   Blue   (8 bits) - values 0-255

Example: RGB(255, 128, 64)
Binary: 00000000 11111111 10000000 01000000
Hex:    0x00FF8040
```

---

### 9.1.3 State Compression using Bitmask

```python
def solve_with_bitmask_vs_set():
    """
    Compare space usage: bitmask vs set
    
    Problem: Track visited cities in TSP
    """
    n = 20  # 20 cities
    
    # Method 1: Using set (inefficient)
    visited_set = set()
    visited_set.add(0)
    visited_set.add(5)
    visited_set.add(19)
    
    # Method 2: Using bitmask (efficient)
    visited_mask = 0
    visited_mask |= (1 << 0)
    visited_mask |= (1 << 5)
    visited_mask |= (1 << 19)
    
    # Check membership
    # Set: O(1) but uses more memory
    is_visited_set = 5 in visited_set
    
    # Bitmask: O(1) and uses minimal memory
    is_visited_mask = (visited_mask & (1 << 5)) != 0
    
    print(f"Set representation: {visited_set}")
    print(f"Mask representation: {bin(visited_mask)}")
    print(f"Both methods agree: {is_visited_set == is_visited_mask}")
    
    # Space comparison
    import sys
    print(f"Set size: {sys.getsizeof(visited_set)} bytes")
    print(f"Int size: {sys.getsizeof(visited_mask)} bytes")

solve_with_bitmask_vs_set()
```

**Space Efficiency**:
```
For n=20 elements:

Set approach:
- Each element: 8 bytes (pointer)
- Hash table overhead: ~200 bytes
- Total: ~260 bytes

Bitmask approach:
- Single integer: 4-8 bytes
- Total: ~8 bytes

Space saved: 32x reduction!
```

---

## 9.2 Time Optimization

### 9.2.1 Fast Modulo with Powers of 2

```python
def fast_modulo_comparison():
    """
    Replace modulo with bitwise AND when modulus is power of 2
    
    Mathematical proof:
    x % 2^n = x & (2^n - 1)
    
    Why? 
    2^n in binary is 100...0 (one 1 followed by n zeros)
    2^n - 1 is 011...1 (n ones)
    AND operation keeps only lower n bits = remainder
    """
    import time
    
    n = 10000000
    modulus = 16  # 2^4
    
    # Method 1: Traditional modulo
    start = time.time()
    result1 = sum(i % modulus for i in range(n))
    time1 = time.time() - start
    
    # Method 2: Bitwise AND
    start = time.time()
    result2 = sum(i & (modulus - 1) for i in range(n))
    time2 = time.time() - start
    
    print(f"Modulo result: {result1}, Time: {time1:.4f}s")
    print(f"Bitwise result: {result2}, Time: {time2:.4f}s")
    print(f"Speedup: {time1/time2:.2f}x")
    print(f"Results match: {result1 == result2}")

# Example usage
def fast_modulo(x, n):
    """
    Fast modulo when n is power of 2
    """
    # Check if n is power of 2
    if n & (n - 1) != 0:
        return x % n  # Fall back to regular modulo
    return x & (n - 1)

print(fast_modulo(23, 16))  # 23 % 16 = 7
print(fast_modulo(100, 32))  # 100 % 32 = 4
```

**Visual Proof**:
```
x = 23 = 10111
n = 16 = 10000 (2^4)
n-1 = 15 = 01111

x % n: 
  23 ÷ 16 = 1 remainder 7

x & (n-1):
  10111
& 01111
  -----
  00111 = 7 ✓

The mask (n-1) keeps only the lower 4 bits!
```

---

### 9.2.2 Fast Multiplication and Division by Powers of 2

```python
def fast_arithmetic():
    """
    Left shift = multiply by 2^n
    Right shift = divide by 2^n
    """
    x = 25
    
    # Multiplication
    print(f"{x} * 4 = {x << 2}")    # 25 * 2^2 = 100
    print(f"{x} * 8 = {x << 3}")    # 25 * 2^3 = 200
    print(f"{x} * 16 = {x << 4}")   # 25 * 2^4 = 400
    
    # Division
    print(f"{x} / 4 = {x >> 2}")    # 25 / 2^2 = 6 (floor division)
    print(f"{x} / 8 = {x >> 3}")    # 25 / 2^3 = 3
    
    # Performance comparison
    import time
    
    n = 10000000
    
    # Regular multiplication
    start = time.time()
    for i in range(n):
        result = i * 16
    time1 = time.time() - start
    
    # Bit shift
    start = time.time()
    for i in range(n):
        result = i << 4
    time2 = time.time() - start
    
    print(f"Regular multiply: {time1:.4f}s")
    print(f"Bit shift: {time2:.4f}s")
    print(f"Speedup: {time1/time2:.2f}x")

fast_arithmetic()
```

**Why it's faster**:
```
CPU operations:
- Multiplication: ~3-10 cycles
- Bit shift: 1 cycle

Left shift by n = multiply by 2^n:
  5 << 2 = 5 * 4 = 20
  0101 << 2 = 10100

Right shift by n = divide by 2^n:
  20 >> 2 = 20 / 4 = 5
  10100 >> 2 = 00101
```

---

### 9.2.3 Check if Number is Even/Odd

```python
def check_parity():
    """
    Use bitwise AND instead of modulo
    """
    import time
    
    def is_even_modulo(n):
        return n % 2 == 0
    
    def is_even_bitwise(n):
        return (n & 1) == 0
    
    # Performance test
    n = 10000000
    
    start = time.time()
    count1 = sum(1 for i in range(n) if is_even_modulo(i))
    time1 = time.time() - start
    
    start = time.time()
    count2 = sum(1 for i in range(n) if is_even_bitwise(i))
    time2 = time.time() - start
    
    print(f"Modulo: {time1:.4f}s")
    print(f"Bitwise: {time2:.4f}s")
    print(f"Speedup: {time1/time2:.2f}x")

check_parity()
```

---

### 9.2.4 Swap Variables Without Temporary

```python
def swap_methods():
    """
    Multiple ways to swap, XOR is most efficient
    """
    a, b = 5, 10
    
    # Method 1: Using temporary (standard)
    def swap_temp(a, b):
        temp = a
        a = b
        b = temp
        return a, b
    
    # Method 2: Using tuple unpacking (Pythonic)
    def swap_tuple(a, b):
        a, b = b, a
        return a, b
    
    # Method 3: Using XOR (no extra memory)
    def swap_xor(a, b):
        a = a ^ b  # a now contains XOR of a and b
        b = a ^ b  # b = (a^b) ^ b = a
        a = a ^ b  # a = (a^b) ^ a = b
        return a, b
    
    # Method 4: Using arithmetic (can overflow)
    def swap_arithmetic(a, b):
        a = a + b
        b = a - b  # b = (a+b) - b = a
        a = a - b  # a = (a+b) - a = b
        return a, b
    
    print(f"Original: a={5}, b={10}")
    print(f"After swap: {swap_xor(5, 10)}")

swap_methods()
```

**XOR Swap Explained**:
```
Initial: a=5 (101), b=10 (1010)

Step 1: a = a ^ b
  a = 101 ^ 1010 = 1111

Step 2: b = a ^ b
  b = 1111 ^ 1010 = 0101 = 5 ✓

Step 3: a = a ^ b
  a = 1111 ^ 0101 = 1010 = 10 ✓

Result: a=10, b=5
```

---

## 9.3 Built-in Functions and Their Implementations

### 9.3.1 Python Built-in Bit Functions

```python
def python_builtin_demos():
    """
    Demonstrate Python's built-in bit manipulation functions
    """
    n = 12  # 1100 in binary
    
    # 1. bin() - Convert to binary string
    print(f"Binary of {n}: {bin(n)}")  # '0b1100'
    
    # 2. int() with base 2 - Parse binary string
    binary_str = '1100'
    print(f"Parse binary: {int(binary_str, 2)}")  # 12
    
    # 3. bit_length() - Number of bits needed
    print(f"Bits needed for {n}: {n.bit_length()}")  # 4
    
    # 4. bit_count() - Count set bits (Python 3.10+)
    if hasattr(int, 'bit_count'):
        print(f"Set bits in {n}: {n.bit_count()}")  # 2
    else:
        print(f"Set bits in {n}: {bin(n).count('1')}")
    
    # 5. to_bytes() - Convert to bytes
    byte_repr = n.to_bytes(2, byteorder='big')
    print(f"Bytes: {byte_repr}")
    
    # 6. from_bytes() - Convert from bytes
    restored = int.from_bytes(byte_repr, byteorder='big')
    print(f"Restored: {restored}")

python_builtin_demos()
```

---

### 9.3.2 Implementing GCC Built-in Functions in Python

```python
class BitOperations:
    """
    Python implementations of common GCC built-in functions
    """
    
    @staticmethod
    def popcount(n):
        """
        Count number of set bits
        Equivalent to __builtin_popcount
        """
        return bin(n).count('1')
    
    @staticmethod
    def clz(n):
        """
        Count leading zeros (32-bit)
        Equivalent to __builtin_clz
        """
        if n == 0:
            return 32
        return 32 - n.bit_length()
    
    @staticmethod
    def ctz(n):
        """
        Count trailing zeros
        Equivalent to __builtin_ctz
        """
        if n == 0:
            return 32
        count = 0
        while (n & 1) == 0:
            count += 1
            n >>= 1
        return count
    
    @staticmethod
    def parity(n):
        """
        Parity of set bits (odd=1, even=0)
        Equivalent to __builtin_parity
        """
        count = BitOperations.popcount(n)
        return count & 1
    
    @staticmethod
    def ffs(n):
        """
        Find first set bit (1-indexed, 0 if none)
        Equivalent to __builtin_ffs
        """
        if n == 0:
            return 0
        return BitOperations.ctz(n) + 1

# Test all functions
n = 12  # 1100
ops = BitOperations()

print(f"Number: {n} ({bin(n)})")
print(f"popcount: {ops.popcount(n)}")  # 2
print(f"clz: {ops.clz(n)}")            # 28 (32 - 4)
print(f"ctz: {ops.ctz(n)}")            # 2
print(f"parity: {ops.parity(n)}")      # 0 (even)
print(f"ffs: {ops.ffs(n)}")            # 3 (first set bit at position 2, 1-indexed)
```

**Visual Explanation for n=12**:
```
n = 12 = 00000000000000000000000000001100 (32-bit)

popcount: Count 1s → 2
clz: Leading zeros → 28 (from left until first 1)
ctz: Trailing zeros → 2 (from right until first 1)
parity: 2 ones (even) → 0
ffs: First set bit at position 2 (0-indexed) → 3 (1-indexed)
```

---

## 9.4 Advanced Optimization Patterns

### 9.4.1 Parallel Bit Operations

```python
def parallel_bit_ops():
    """
    Process multiple bits in parallel
    """
    # Count bits in groups
    def count_bits_parallel(n):
        """
        Count bits in parallel using divide and conquer
        """
        # Count pairs
        n = (n & 0x55555555) + ((n >> 1) & 0x55555555)
        # Count nibbles
        n = (n & 0x33333333) + ((n >> 2) & 0x33333333)
        # Count bytes
        n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F)
        # Sum all bytes
        n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF)
        n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF)
        return n
    
    # Test
    print(count_bits_parallel(0xFF))  # 8 ones
    print(count_bits_parallel(0xAA))  # 01010101 = 4 ones

parallel_bit_ops()
```

**How Parallel Counting Works**:
```
n = 10110110 (182 in decimal)

Step 1: Count in pairs
  Mask with 01010101, shift and mask with 01010101
  01 01 01 01 (pairs counted)

Step 2: Count in nibbles (4 bits)
  0010 0010 (4-bit groups counted)

Step 3: Count in bytes
  00000100

Result: 4 ones
```

---

### 9.4.2 Bit Manipulation for Set Operations

```python
class BitSet:
    """
    Efficient set operations using bits
    """
    def __init__(self, max_val=64):
        self.max_val = max_val
        self.bits = 0
    
    def add(self, x):
        """Add element to set - O(1)"""
        if x >= self.max_val:
            raise ValueError("Value too large")
        self.bits |= (1 << x)
    
    def remove(self, x):
        """Remove element from set - O(1)"""
        self.bits &= ~(1 << x)
    
    def contains(self, x):
        """Check membership - O(1)"""
        return (self.bits & (1 << x)) != 0
    
    def union(self, other):
        """Union of sets - O(1)"""
        result = BitSet(self.max_val)
        result.bits = self.bits | other.bits
        return result
    
    def intersection(self, other):
        """Intersection of sets - O(1)"""
        result = BitSet(self.max_val)
        result.bits = self.bits & other.bits
        return result
    
    def difference(self, other):
        """Set difference - O(1)"""
        result = BitSet(self.max_val)
        result.bits = self.bits & ~other.bits
        return result
    
    def size(self):
        """Count elements - O(1) with popcount"""
        return bin(self.bits).count('1')
    
    def __str__(self):
        elements = [i for i in range(self.max_val) if self.contains(i)]
        return str(set(elements))

# Test
set1 = BitSet()
set1.add(1)
set1.add(3)
set1.add(5)

set2 = BitSet()
set2.add(3)
set2.add(4)
set2.add(5)

print(f"Set 1: {set1}")
print(f"Set 2: {set2}")
print(f"Union: {set1.union(set2)}")
print(f"Intersection: {set1.intersection(set2)}")
print(f"Difference: {set1.difference(set2)}")
```

---

## 9.5 Memory vs Speed Trade-offs

```python
def tradeoff_analysis():
    """
    Analyze trade-offs between different approaches
    """
    import time
    import sys
    
    n = 1000
    
    # Approach 1: List of booleans
    bool_list = [False] * n
    for i in range(0, n, 2):
        bool_list[i] = True
    
    # Approach 2: Set
    num_set = set(range(0, n, 2))
    
    # Approach 3: Bitmask (using integers)
    bitmask = 0
    for i in range(0, n, 2):
        bitmask |= (1 << i) if i < 64 else 0  # Limited to 64 bits per int
    
    # Memory comparison
    print("Memory Usage:")
    print(f"Boolean list: {sys.getsizeof(bool_list)} bytes")
    print(f"Set: {sys.getsizeof(num_set)} bytes")
    print(f"Bitmask: {sys.getsizeof(bitmask)} bytes")
    
    # Speed comparison
    def test_membership(container, value):
        if isinstance(container, int):
            return (container & (1 << value)) != 0 if value < 64 else False
        elif isinstance(container, set):
            return value in container
        else:
            return container[value]
    
    iterations = 100000
    
    start = time.time()
    for _ in range(iterations):
        test_membership(bool_list, 50)
    time1 = time.time() - start
    
    start = time.time()
    for _ in range(iterations):
        test_membership(num_set, 50)
    time2 = time.time() - start
    
    start = time.time()
    for _ in range(iterations):
        test_membership(bitmask, 50)
    time3 = time.time() - start
    
    print("\nSpeed (membership test):")
    print(f"Boolean list: {time1:.4f}s")
    print(f"Set: {time2:.4f}s")
    print(f"Bitmask: {time3:.4f}s")

tradeoff_analysis()
```

---

## Summary: Optimization Checklist

### When to Use Each Optimization

| Scenario | Use | Benefit |
|----------|-----|---------|
| Many boolean flags | Bit array | 8x-32x memory |
| Power of 2 modulo | `x & (n-1)` | 2-3x faster |
| Multiply/divide by 2^n | Bit shifts | 3-10x faster |
| Check even/odd | `x & 1` | 1.5-2x faster |
| Small set (n≤64) | Bitmask | Memory + speed |
| Swap without temp | XOR swap | No extra space |
| RGB colors | Packed int | 3x memory |

### Optimization Priority
1. **Correctness** - Always prioritize correct code
2. **Readability** - Use bit tricks only when beneficial
3. **Profiling** - Measure before optimizing
4. **Context** - Consider problem constraints

**Remember**: Premature optimization is the root of all evil. Use these techniques when profiling shows they're needed!