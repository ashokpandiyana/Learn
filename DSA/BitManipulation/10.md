# Chapter 10: Hard-Level Interview Patterns (In-Depth)

## 10.1 Maximum XOR Patterns with Trie

### 10.1.1 Understanding Bitwise Trie

**Concept**: A trie where each node represents a bit (0 or 1), built from MSB to LSB.

```python
class TrieNode:
    """
    Node in bitwise trie
    Each node has two children: 0 and 1
    """
    def __init__(self):
        self.children = {}  # {0: TrieNode, 1: TrieNode}
        self.value = None   # Store original number at leaf

class BitwiseTrie:
    """
    Trie for storing numbers and finding maximum XOR
    
    Key insight: To maximize XOR, choose opposite bits
    If current bit is 1, try to go to 0 (and vice versa)
    """
    def __init__(self, max_bits=32):
        self.root = TrieNode()
        self.max_bits = max_bits
    
    def insert(self, num):
        """
        Insert number into trie (from MSB to LSB)
        
        Time: O(32) = O(1) for fixed-size integers
        """
        node = self.root
        
        # Traverse from MSB to LSB
        for i in range(self.max_bits - 1, -1, -1):
            bit = (num >> i) & 1
            
            if bit not in node.children:
                node.children[bit] = TrieNode()
            
            node = node.children[bit]
        
        node.value = num
    
    def find_max_xor(self, num):
        """
        Find number in trie that gives maximum XOR with num
        
        Strategy: At each bit position, try to go opposite direction
        
        Time: O(32) = O(1)
        """
        if not self.root.children:
            return 0
        
        node = self.root
        current_xor = 0
        
        for i in range(self.max_bits - 1, -1, -1):
            bit = (num >> i) & 1
            # Try opposite bit first (to maximize XOR)
            opposite = 1 - bit
            
            if opposite in node.children:
                current_xor |= (1 << i)  # This bit will be 1 in XOR
                node = node.children[opposite]
            elif bit in node.children:
                node = node.children[bit]
            else:
                break
        
        return current_xor

# Example usage
def max_xor_in_array(nums):
    """
    Find maximum XOR of any two numbers in array
    
    LeetCode 421: Maximum XOR of Two Numbers in an Array
    """
    trie = BitwiseTrie()
    max_xor = 0
    
    # Insert first number
    trie.insert(nums[0])
    
    # For each subsequent number, find max XOR then insert
    for i in range(1, len(nums)):
        max_xor = max(max_xor, trie.find_max_xor(nums[i]))
        trie.insert(nums[i])
    
    return max_xor

# Test
nums = [3, 10, 5, 25, 2, 8]
print(f"Maximum XOR: {max_xor_in_array(nums)}")  # 28 (5 XOR 25)
```

**Visual Example**:
```
Insert numbers [3, 10] into trie (4-bit for simplicity)

3 = 0011:
    root
     |
     0 (bit 3)
     |
     0 (bit 2)
     |
     1 (bit 1)
     |
     1 (bit 0) → value=3

10 = 1010:
    root
     |
    / \
   0   1 (bit 3)
   |   |
   0   0 (bit 2)
   |   |
   1   1 (bit 1)
   |   |
   1   0 (bit 0) → value=10

Finding max XOR with 5 = 0101:
- Bit 3: Have 0, want 1 (opposite) ✓ → XOR bit 3 = 1
- Bit 2: Have 1, want 0 (opposite) ✓ → XOR bit 2 = 1
- Bit 1: Have 0, want 1 (opposite) ✓ → XOR bit 1 = 1
- Bit 0: Have 1, want 0 (opposite) ✓ → XOR bit 0 = 1
Result: 1111 = 15 (5 XOR 10)
```

---

### 10.1.2 Maximum XOR with Element from Array (Queries)

```python
class Solution:
    """
    LeetCode 1707: Maximum XOR With an Element From Array
    
    Given array and queries [xi, mi], find max XOR of xi with 
    elements ≤ mi. Return -1 if no such element.
    """
    
    def maximize_xor(self, nums, queries):
        """
        Strategy:
        1. Sort both nums and queries
        2. For each query, insert valid nums into trie
        3. Find max XOR
        """
        # Sort nums
        nums.sort()
        
        # Add index to queries and sort by mi
        indexed_queries = [(m, x, i) for i, (x, m) in enumerate(queries)]
        indexed_queries.sort()
        
        trie = BitwiseTrie(max_bits=31)
        result = [-1] * len(queries)
        nums_idx = 0
        
        for mi, xi, orig_idx in indexed_queries:
            # Insert all nums <= mi into trie
            while nums_idx < len(nums) and nums[nums_idx] <= mi:
                trie.insert(nums[nums_idx])
                nums_idx += 1
            
            # Find max XOR if trie is not empty
            if nums_idx > 0:
                result[orig_idx] = trie.find_max_xor(xi)
        
        return result

# Test
sol = Solution()
nums = [0, 1, 2, 3, 4]
queries = [[3, 1], [1, 3], [5, 6]]
print(sol.maximize_xor(nums, queries))  # [3, 3, 7]
```

**Explanation**:
```
Query [3, 1]: xi=3, mi=1
  Valid nums: [0, 1]
  3 XOR 0 = 3 ✓ (max)
  3 XOR 1 = 2

Query [1, 3]: xi=1, mi=3
  Valid nums: [0, 1, 2, 3]
  1 XOR 3 = 2
  1 XOR 2 = 3 ✓ (max)

Query [5, 6]: xi=5, mi=6
  Valid nums: [0, 1, 2, 3, 4]
  5 XOR 2 = 7 ✓ (max)
```

---

## 10.2 Multi-Dimensional Bitmask DP

### 10.2.1 Minimum Cost to Connect Two Groups

```python
def min_cost_connect_groups(cost):
    """
    LeetCode 1595: Minimum Cost to Connect Two Groups of Points
    
    cost[i][j] = cost to connect point i in group1 with point j in group2
    Each point must be connected to at least one point in other group
    
    State: dp[i][mask]
    - i: considered first i points from group1
    - mask: which points in group2 are connected
    """
    m, n = len(cost), len(cost[0])
    INF = float('inf')
    
    # Precompute minimum cost to connect each point in group2
    min_cost_2 = [min(cost[i][j] for i in range(m)) for j in range(n)]
    
    # dp[mask] = min cost when group2 points in mask are connected
    dp = [INF] * (1 << n)
    dp[0] = 0
    
    for i in range(m):
        new_dp = [INF] * (1 << n)
        
        for mask in range(1 << n):
            if dp[mask] == INF:
                continue
            
            # Try connecting point i to each point in group2
            for j in range(n):
                new_mask = mask | (1 << j)
                new_dp[new_mask] = min(new_dp[new_mask], 
                                      dp[mask] + cost[i][j])
        
        # After processing point i, connect unconnected group2 points
        for mask in range(1 << n):
            for j in range(n):
                if not (mask & (1 << j)):  # j not connected
                    new_mask = mask | (1 << j)
                    new_dp[new_mask] = min(new_dp[new_mask],
                                          new_dp[mask] + min_cost_2[j])
        
        dp = new_dp
    
    return dp[(1 << n) - 1]

# Test
cost = [[15, 96], [36, 2]]
print(min_cost_connect_groups(cost))  # 17
```

**State Space Visualization**:
```
For m=2, n=2 (2 points in each group):

Group1: [P0, P1]
Group2: [Q0, Q1]

States (mask for Group2):
00: Neither Q0 nor Q1 connected
01: Q0 connected
10: Q1 connected
11: Both connected (goal)

Transitions:
- Connect P0 to Q0: 00 → 01
- Connect P0 to Q1: 00 → 10
- Connect P0 to both: 00 → 11
...
```

---

### 10.2.2 Number of Ways to Wear Different Hats

```python
def number_ways_wear_hats(hats):
    """
    LeetCode 1434: Number of Ways to Wear Different Hats to Each Other
    
    n people, each has favorite hats
    Find ways to assign hats such that:
    - Each person gets exactly one hat
    - No two people wear same hat
    - Each person wears a favorite hat
    
    Approach: DP on hat assignment
    dp[hat][mask] = ways to assign first 'hat' hats to people in 'mask'
    """
    MOD = 10**9 + 7
    n = len(hats)
    
    # Create hat-to-people mapping
    hat_to_people = [[] for _ in range(41)]  # Max 40 hats
    for person in range(n):
        for hat in hats[person]:
            hat_to_people[hat].append(person)
    
    # dp[mask] = ways to assign hats to people in mask
    dp = [0] * (1 << n)
    dp[0] = 1  # Base case: no one assigned
    
    # Try assigning each hat
    for hat in range(1, 41):
        # Process in reverse to avoid using same state twice
        for mask in range((1 << n) - 1, -1, -1):
            if dp[mask] == 0:
                continue
            
            # Try assigning this hat to each person who likes it
            for person in hat_to_people[hat]:
                if mask & (1 << person):  # Person already has hat
                    continue
                
                new_mask = mask | (1 << person)
                dp[new_mask] = (dp[new_mask] + dp[mask]) % MOD
    
    return dp[(1 << n) - 1]

# Test
hats = [[3,4], [4,5], [5]]
print(number_ways_wear_hats(hats))  # 1
```

**Example Walkthrough**:
```
hats = [[3,4], [4,5], [5]]
Person 0 likes: [3, 4]
Person 1 likes: [4, 5]
Person 2 likes: [5]

Hat-to-people mapping:
Hat 3: [0]
Hat 4: [0, 1]
Hat 5: [1, 2]

DP Process:
Initial: dp[000] = 1

Process Hat 3:
  Can assign to person 0
  dp[001] = 1

Process Hat 4:
  From dp[000]: Can assign to 0 → dp[001]++
  From dp[001]: Can assign to 1 → dp[011] = 1

Process Hat 5:
  From dp[001]: Can assign to 1 → dp[011]++
  From dp[011]: Can assign to 2 → dp[111] = 1

Answer: dp[111] = 1 way
```

---

## 10.3 Game Theory with Bits

### 10.3.1 Nim Game with XOR

```python
def nim_game(piles):
    """
    Classic Nim game
    
    Rules:
    - Two players alternate turns
    - On each turn, remove any number from one pile
    - Player who removes last stone wins
    
    Solution: XOR all pile sizes
    - If XOR = 0: Losing position
    - If XOR != 0: Winning position
    """
    xor_sum = 0
    for pile in piles:
        xor_sum ^= pile
    
    return xor_sum != 0  # True if current player wins

def nim_winning_move(piles):
    """
    If winning position, find the winning move
    """
    xor_sum = 0
    for pile in piles:
        xor_sum ^= pile
    
    if xor_sum == 0:
        return None  # No winning move
    
    # Find pile where removal leads to losing position
    for i, pile in enumerate(piles):
        new_pile = pile ^ xor_sum
        if new_pile < pile:
            return (i, pile - new_pile)  # (pile_index, stones_to_remove)
    
    return None

# Test
piles = [3, 4, 5]
print(f"Can win: {nim_game(piles)}")  # True
print(f"Winning move: {nim_winning_move(piles)}")  # (0, 1) remove 1 from pile 0
```

**Why XOR Works**:
```
Piles: [3, 4, 5]
XOR: 3 ^ 4 ^ 5 = 011 ^ 100 ^ 101 = 010 = 2 (non-zero → winning)

After optimal move [2, 4, 5]:
XOR: 2 ^ 4 ^ 5 = 010 ^ 100 ^ 101 = 011 = 3 (non-zero)

Wait, that's wrong. Let me recalculate:
3 ^ 4 ^ 5:
  011
  100 ^
  ---
  111
  101 ^
  ---
  010 = 2

To make XOR = 0, we need to remove from a pile:
Target XOR = 0
For pile 0 (3): 3 ^ 2 = 1, so make it 1 (remove 2)
Check: 1 ^ 4 ^ 5 = 001 ^ 100 ^ 101 = 000 ✓
```

---

### 10.3.2 Grundy Numbers (Sprague-Grundy Theorem)

```python
def calculate_grundy(position, memo=None):
    """
    Calculate Grundy number for a position
    
    Grundy number = MEX (Minimum Excludant) of all reachable positions
    MEX = smallest non-negative integer not in set
    
    Example game: Remove 1, 2, or 3 stones from pile
    """
    if memo is None:
        memo = {}
    
    if position in memo:
        return memo[position]
    
    if position == 0:
        return 0  # Losing position
    
    # Find all reachable Grundy numbers
    reachable = set()
    for move in [1, 2, 3]:
        if position >= move:
            reachable.add(calculate_grundy(position - move, memo))
    
    # MEX of reachable positions
    mex = 0
    while mex in reachable:
        mex += 1
    
    memo[position] = mex
    return mex

def solve_game(piles):
    """
    Multi-pile game: XOR of Grundy numbers
    """
    xor_sum = 0
    for pile in piles:
        xor_sum ^= calculate_grundy(pile)
    
    return xor_sum != 0  # Non-zero XOR = winning position

# Test
print(f"Grundy(5) = {calculate_grundy(5)}")  # Grundy number for 5 stones
print(f"Can win [3, 5]: {solve_game([3, 5])}")
```

**Grundy Number Example**:
```
Game: Remove 1, 2, or 3 stones

Position 0: Grundy = 0 (losing)
Position 1: Can reach {0} → Grundy = MEX{0} = 1
Position 2: Can reach {0, 1} → Grundy = MEX{0,1} = 2
Position 3: Can reach {0, 1, 2} → Grundy = MEX{0,1,2} = 3
Position 4: Can reach {1, 2, 3} → Grundy = MEX{1,2,3} = 0
Position 5: Can reach {2, 3, 0} → Grundy = MEX{0,2,3} = 1

Pattern: 0, 1, 2, 3, 0, 1, 2, 3, ...
```

---

## 10.4 Advanced Bitwise Trie Applications

### 10.4.1 Count Pairs with XOR in Range

```python
class XORTrie:
    """
    Trie for counting pairs with XOR in range [low, high]
    """
    def __init__(self):
        self.root = {}
    
    def insert(self, num):
        node = self.root
        for i in range(31, -1, -1):
            bit = (num >> i) & 1
            if bit not in node:
                node[bit] = {'count': 0, 'children': {}}
            node = node[bit]
            node['count'] = node.get('count', 0) + 1
    
    def count_less_than(self, num, k):
        """
        Count numbers in trie such that num XOR x < k
        """
        node = self.root
        count = 0
        
        for i in range(31, -1, -1):
            if not node:
                break
            
            num_bit = (num >> i) & 1
            k_bit = (k >> i) & 1
            
            if k_bit == 1:
                # If k_bit is 1, all numbers with same bit as num contribute
                same = node.get(num_bit, {})
                count += same.get('count', 0)
                # Continue with opposite bit
                node = node.get(1 - num_bit, {})
            else:
                # If k_bit is 0, must follow same bit as num
                node = node.get(num_bit, {})
        
        return count

def count_pairs_xor_range(nums, low, high):
    """
    LeetCode 1803: Count Pairs With XOR in a Range
    
    Count pairs (i, j) where low <= nums[i] XOR nums[j] <= high
    """
    trie = XORTrie()
    count = 0
    
    for num in nums:
        # Count pairs with XOR <= high
        count += trie.count_less_than(num, high + 1)
        # Subtract pairs with XOR < low
        count -= trie.count_less_than(num, low)
        # Insert current number
        trie.insert(num)
    
    return count

# Test
nums = [1, 4, 2, 7]
low, high = 2, 6
print(count_pairs_xor_range(nums, low, high))
```

---

## 10.5 Matrix Exponentiation with Bitmasks

### 10.5.1 Count Ways with DP and Matrix Power

```python
def matrix_multiply(A, B, mod):
    """
    Multiply two matrices modulo mod
    """
    n = len(A)
    C = [[0] * n for _ in range(n)]
    
    for i in range(n):
        for j in range(n):
            for k in range(n):
                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % mod
    
    return C

def matrix_power(M, n, mod):
    """
    Compute M^n using binary exponentiation
    Uses bit representation of n
    """
    size = len(M)
    result = [[1 if i == j else 0 for j in range(size)] 
              for i in range(size)]  # Identity matrix
    
    base = [row[:] for row in M]  # Copy M
    
    while n > 0:
        if n & 1:  # If bit is set
            result = matrix_multiply(result, base, mod)
        base = matrix_multiply(base, base, mod)
        n >>= 1
    
    return result

def count_ways_n_steps(n):
    """
    Count ways to reach position n with steps of 1 or 2
    (Classic Fibonacci problem using matrix exponentiation)
    
    Recurrence: f(n) = f(n-1) + f(n-2)
    
    Matrix form:
    [f(n)  ]   [1 1] [f(n-1)]
    [f(n-1)] = [1 0] [f(n-2)]
    """
    if n <= 1:
        return 1
    
    MOD = 10**9 + 7
    
    # Transformation matrix
    M = [[1, 1],
         [1, 0]]
    
    # Compute M^(n-1)
    result = matrix_power(M, n - 1, MOD)
    
    # f(n) = result[0][0] * f(1) + result[0][1] * f(0)
    # f(1) = 1, f(0) = 1
    return result[0][0]

# Test
print(count_ways_n_steps(10))  # 89 (11th Fibonacci number)
```

**Binary Exponentiation Visualization**:
```
Compute M^13:
13 = 1101 in binary

Process bits right to left:
Bit 0 (1): result = M^1
Bit 1 (0): skip
Bit 2 (1): result = result * M^4 = M^5
Bit 3 (1): result = result * M^8 = M^13

Only 4 matrix multiplications instead of 13!
```

---

## 10.6 Complete Hard Problem: Shortest Path to Get All Keys

```python
def shortest_path_all_keys(grid):
    """
    LeetCode 864: Shortest Path to Get All Keys
    
    Grid contains:
    - '@': starting position
    - '#': wall
    - '.': empty
    - 'a'-'f': keys
    - 'A'-'F': locks
    
    Find shortest path to collect all keys
    Use bitmask to represent collected keys
    """
    from collections import deque
    
    rows, cols = len(grid), len(grid[0])
    
    # Find start position and count keys
    start = None
    all_keys = 0
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == '@':
                start = (i, j)
            elif grid[i][j].islower():
                # Mark this key in bitmask
                all_keys |= (1 << (ord(grid[i][j]) - ord('a')))
    
    # BFS with state: (row, col, keys_collected)
    queue = deque([(start[0], start[1], 0, 0)])  # (r, c, keys, dist)
    visited = set([(start[0], start[1], 0)])
    
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    while queue:
        r, c, keys, dist = queue.popleft()
        
        # Check if collected all keys
        if keys == all_keys:
            return dist
        
        # Try all 4 directions
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            # Check bounds
            if not (0 <= nr < rows and 0 <= nc < cols):
                continue
            
            cell = grid[nr][nc]
            
            # Check walls
            if cell == '#':
                continue
            
            # Check locks
            if cell.isupper():
                key_needed = ord(cell.lower()) - ord('a')
                if not (keys & (1 << key_needed)):
                    continue  # Don't have required key
            
            new_keys = keys
            
            # Collect key if present
            if cell.islower():
                new_keys |= (1 << (ord(cell) - ord('a')))
            
            # Check if visited this state
            state = (nr, nc, new_keys)
            if state in visited:
                continue
            
            visited.add(state)
            queue.append((nr, nc, new_keys, dist + 1))
    
    return -1  # Cannot collect all keys

# Test
grid = [
    "@.a.#",
    "###.#",
    "b.A.B"
]
print(shortest_path_all_keys(grid))  # 8
```

**State Space Explanation**:
```
For 6 possible keys (a-f):
- Each key can be collected or not: 2^6 = 64 states
- For each position (r, c) and key state, track:
  State = (row, col, key_bitmask)

Example key_bitmask:
- 000000: no keys
- 000001: key 'a' collected
- 000011: keys 'a' and 'b' collected
- 111111: all keys collected

This way we avoid revisiting same position with same keys!
```

---

## Summary: Hard-Level Patterns

### Pattern Recognition Guide

| Problem Type | Key Technique | Example |
|-------------|---------------|---------|
| Max XOR queries | Bitwise Trie | LC 1707, LC 421 |
| Multiple groups | Multi-dim bitmask DP | LC 1595, LC 1434 |
| Game theory | XOR, Grundy numbers | Nim, SG theorem |
| Path with states | Bitmask BFS | LC 864, LC 847 |
| Fast exponentiation | Binary rep of power | Matrix power |
| XOR range queries | Trie + counting | LC 1803 |

### Complexity Analysis

```
Bitwise Trie:
- Insert: O(log max_val) = O(32) = O(1)
- Query: O(log max_val) = O(32) = O(1)
- Space: O(n * log max_val)

Bitmask DP:
- Time: O(2^n * n * transitions)
- Space: O(2^n * dimensions)
- Feasible for n ≤ 20

Matrix Exponentiation:
- Time: O(k^3 * log n) for k×k matrix
- Space: O(k^2)
```

### Interview Tips

1. **Recognize patterns quickly**:
   - XOR in problem → Think Trie or XOR properties
   - Small n (≤ 20) → Think bitmask DP
   - Pair counts → Think Trie for counting

2. **State representation**:
   - Use bitmask for "subset of items"
   - Each bit = one item's state

3. **Optimization**:
   - Precompute when possible
   - Sort inputs strategically
   - Use efficient bit operations

4. **Common mistakes**:
   - Forgetting to check bounds (1 << n can overflow)
   - Not handling edge cases (empty input, n=0)
   - Incorrect bit indexing (0-based vs 1-based)

**Master these patterns and you'll handle any hard-level bit manipulation interview question!**