# Complete Bit Manipulation Mastery Guide
## From Beginner to Hard-Level Interview Problems

---

## Chapter 1: Fundamentals of Binary & Bit Representation

### 1.1 Binary Number System
- **Binary to Decimal Conversion**
- **Decimal to Binary Conversion**
- **Signed vs Unsigned Integers**
- **Two's Complement Representation** (for negative numbers)

#### ðŸ”´ Important Notes:
- In most languages, integers are 32-bit or 64-bit
- Leftmost bit in signed integers represents the sign (0 = positive, 1 = negative)
- Two's complement: flip all bits and add 1 to get negative representation

### 1.2 Bit Indexing & Terminology
- **Least Significant Bit (LSB)** - rightmost bit (position 0)
- **Most Significant Bit (MSB)** - leftmost bit
- **Set Bit** - bit value is 1
- **Clear Bit** - bit value is 0
- **Bit Position** - indexed from right to left (0-based)

---

## Chapter 2: Basic Bitwise Operators

### 2.1 AND Operator (&)
- Returns 1 only if both bits are 1
- **Use Cases**: Checking if bit is set, clearing bits, masking

```
5 & 3 = 101 & 011 = 001 = 1
```

#### ðŸ”´ Key Pattern:
- `x & 1` checks if number is odd (LSB is 1)
- `x & (1 << i)` checks if i-th bit is set

### 2.2 OR Operator (|)
- Returns 1 if at least one bit is 1
- **Use Cases**: Setting bits, merging bit patterns

```
5 | 3 = 101 | 011 = 111 = 7
```

#### ðŸ”´ Key Pattern:
- `x | (1 << i)` sets the i-th bit

### 2.3 XOR Operator (^)
- Returns 1 if bits are different
- **Use Cases**: Toggling bits, finding unique elements, swapping

```
5 ^ 3 = 101 ^ 011 = 110 = 6
```

#### ðŸ”´ Critical Properties:
- `x ^ 0 = x` (identity)
- `x ^ x = 0` (self-inverse)
- `x ^ y ^ y = x` (cancellation)
- XOR is commutative and associative
- **Golden Rule**: XOR of same numbers = 0

### 2.4 NOT Operator (~)
- Flips all bits (1's complement)
- **Use Cases**: Creating masks, bit inversion

```
~5 = ~0101 = 1010 (in 4-bit)
```

#### ðŸ”´ Important:
- `~x = -x - 1` in two's complement
- `~0` gives all bits set (useful for masks)

### 2.5 Left Shift (<<)
- Shifts bits to the left, fills with 0s
- **Effect**: Multiplies by 2^n

```
5 << 2 = 101 << 2 = 10100 = 20
```

#### ðŸ”´ Key Pattern:
- `1 << n` creates a number with only n-th bit set
- `x << n` = `x * 2^n`

### 2.6 Right Shift (>>)
- **Arithmetic Right Shift**: Preserves sign (fills with sign bit)
- **Logical Right Shift**: Fills with 0s
- **Effect**: Divides by 2^n (rounds down)

```
20 >> 2 = 10100 >> 2 = 101 = 5
```

#### ðŸ”´ Key Pattern:
- `x >> n` = `x / 2^n` (integer division)

---

## Chapter 3: Essential Bit Manipulation Tricks

### 3.1 Check if Number is Power of 2
```
x > 0 && (x & (x - 1)) == 0
```
#### ðŸ”´ Why it works:
Power of 2 has exactly one set bit. `x - 1` flips all bits after that bit.

### 3.2 Turn Off the Rightmost Set Bit
```
x & (x - 1)
```
#### ðŸ”´ Applications:
- Counting set bits
- Checking power of 2
- Used in Brian Kernighan's algorithm

### 3.3 Isolate the Rightmost Set Bit
```
x & (-x)  or  x & (~x + 1)
```
#### ðŸ”´ Use Cases:
- Fenwick Tree operations
- Finding least significant set bit

### 3.4 Turn On the Rightmost Clear Bit
```
x | (x + 1)
```

### 3.5 Get All Set Bits Mask (of length n)
```
(1 << n) - 1
```
**Example**: `(1 << 4) - 1 = 15 = 1111`

### 3.6 Check if i-th Bit is Set
```
(x & (1 << i)) != 0
or
(x >> i) & 1
```

### 3.7 Set the i-th Bit
```
x | (1 << i)
```

### 3.8 Clear the i-th Bit
```
x & ~(1 << i)
```

### 3.9 Toggle the i-th Bit
```
x ^ (1 << i)
```

### 3.10 Clear All Bits from MSB to i (inclusive)
```
x & ((1 << i) - 1)
```

### 3.11 Clear All Bits from i to 0 (inclusive)
```
x & (~((1 << (i + 1)) - 1))
```

### 3.12 Swap Two Numbers Without Temp Variable
```
a = a ^ b
b = a ^ b
a = a ^ b
```

### 3.13 Check if Two Numbers Have Opposite Signs
```
(x ^ y) < 0
```
(Works because XOR of opposite signs has MSB set)

---

## Chapter 4: Counting Bits Patterns

### 4.1 Count Number of Set Bits (Hamming Weight)

#### Method 1: Brian Kernighan's Algorithm
```
int count = 0;
while (x) {
    x = x & (x - 1);
    count++;
}
```
**Time**: O(number of set bits)

#### Method 2: Loop Through All Bits
```
int count = 0;
while (x) {
    count += x & 1;
    x >>= 1;
}
```
**Time**: O(log n)

#### Method 3: Lookup Table
- Precompute counts for all 8-bit numbers
- Process 8 bits at a time

#### ðŸ”´ Built-in Functions:
- C++: `__builtin_popcount(x)`
- Java: `Integer.bitCount(x)`
- Python: `bin(x).count('1')`

### 4.2 Count Total Bits Required
```
floor(log2(x)) + 1
or
32 - __builtin_clz(x)  // count leading zeros
```

### 4.3 Parity (Even/Odd Count of Set Bits)
```
bool parity = false;
while (x) {
    parity ^= (x & 1);
    x >>= 1;
}
```
**Shortcut**: Parity = `__builtin_parity(x)`

---

## Chapter 5: Advanced Bit Manipulation Patterns

### 5.1 XOR Pattern - Finding Unique Elements

#### Pattern 5.1.1: Single Number (One unique among duplicates)
**Problem**: All numbers appear twice except one
**Solution**: XOR all numbers
```
int result = 0;
for (int num : nums) {
    result ^= num;
}
```
#### ðŸ”´ Why: `a ^ a = 0`, all pairs cancel out

#### Pattern 5.1.2: Two Unique Numbers
**Problem**: All appear twice except two numbers
**Solution**: 
1. XOR all â†’ `xor = a ^ b`
2. Find rightmost set bit in xor â†’ `rightmost = xor & (-xor)`
3. Divide numbers into two groups based on this bit
4. XOR each group separately

```
int xor = 0;
for (int num : nums) xor ^= num;

int rightmost = xor & (-xor);
int a = 0, b = 0;

for (int num : nums) {
    if (num & rightmost) a ^= num;
    else b ^= num;
}
```

#### Pattern 5.1.3: Single Number III (Appears once, others thrice)
**Solution**: Use two variables to track bits appearing 1x and 2x
```
int ones = 0, twos = 0;
for (int num : nums) {
    twos |= ones & num;
    ones ^= num;
    int threes = ones & twos;
    ones &= ~threes;
    twos &= ~threes;
}
```

### 5.2 Subset Generation Pattern

#### Generate All Subsets
```
for (int mask = 0; mask < (1 << n); mask++) {
    for (int i = 0; i < n; i++) {
        if (mask & (1 << i)) {
            // i-th element is in this subset
        }
    }
}
```
**Time**: O(2^n * n)

#### ðŸ”´ Key Insight:
Each mask from 0 to 2^n - 1 represents a unique subset

#### Iterate Through All Subsets of a Mask
```
for (int submask = mask; submask > 0; submask = (submask - 1) & mask) {
    // submask is a subset of mask
}
```

### 5.3 Gray Code Pattern
- Consecutive values differ by only 1 bit
- **Formula**: `i ^ (i >> 1)`
- **Use**: Minimize changes between states

```
vector<int> grayCode(int n) {
    vector<int> result;
    for (int i = 0; i < (1 << n); i++) {
        result.push_back(i ^ (i >> 1));
    }
    return result;
}
```

### 5.4 Range XOR Queries
**Property**: XOR from 1 to n has pattern (repeats every 4)
- If n % 4 == 1: answer = 1
- If n % 4 == 2: answer = n + 1
- If n % 4 == 3: answer = 0
- If n % 4 == 0: answer = n

**Range [L, R]**: `xor(1, R) ^ xor(1, L-1)`

### 5.5 Bitmask Dynamic Programming
Use integer as state to represent set membership

**Example**: Traveling Salesman, Assignment Problem
```
dp[mask][i] = minimum cost to visit cities in 'mask' ending at city 'i'
```

#### ðŸ”´ Space Optimization:
- For n=20 items: 2^20 = ~1M states (feasible)
- For n=30: 2^30 = ~1B states (limit)

---

## Chapter 6: Bit Manipulation in Common Data Structures

### 6.1 Bitset
- Efficient storage: 1 bit per boolean
- Operations: set, reset, flip, count, any, all, none
- **Memory**: N bits instead of N bytes

### 6.2 Bloom Filter
- Uses multiple hash functions and bit array
- Fast membership testing (false positives possible)

### 6.3 Fenwick Tree (Binary Indexed Tree)
- Uses `x & (-x)` to isolate rightmost set bit
- Efficient range queries and updates

---

## Chapter 7: Problem-Solving Patterns by Category

### 7.1 Bit Counting & Manipulation
- Count set bits
- Reverse bits
- Check power of 2/4
- Bit difference between numbers
- Minimum bit flips to convert A to B

### 7.2 XOR Magic Problems
- Single Number (I, II, III)
- Missing Number
- Find duplicate
- Maximum XOR of two numbers in array
- XOR queries on array
- XOR linked list

### 7.3 Subset & Combination Problems
- Generate all subsets
- Subset sum using bitmask
- Maximum AND/OR/XOR subset
- Count subsets with XOR = K

### 7.4 Bitmask DP Problems
- Traveling Salesman Problem (TSP)
- Assignment Problem
- Hamiltonian Path
- Shortest Path visiting all nodes
- Job scheduling with constraints

### 7.5 Bitwise Tricks in Algorithms
- Fast multiplication/division by powers of 2
- Check if number is divisible by 3 (count set bits at odd/even positions)
- Swap adjacent bits
- Find position of only set bit
- Detect if two integers have same sign

### 7.6 Advanced Patterns
- Trie with bits (for max XOR queries)
- Bitwise operations in graphs
- Using bits for optimization flags
- Coordinate compression with bits

---

## Chapter 8: Common Interview Problems & Templates

### 8.1 Template: Check Bit Property
```cpp
bool checkBit(int n, int pos) {
    return (n & (1 << pos)) != 0;
}
```

### 8.2 Template: Modify Bit
```cpp
int setBit(int n, int pos) {
    return n | (1 << pos);
}

int clearBit(int n, int pos) {
    return n & ~(1 << pos);
}

int toggleBit(int n, int pos) {
    return n ^ (1 << pos);
}
```

### 8.3 Template: Iterate Set Bits
```cpp
while (n) {
    int pos = __builtin_ctz(n);  // position of rightmost set bit
    // Process bit at position 'pos'
    n &= (n - 1);  // clear rightmost set bit
}
```

### 8.4 Template: Bitmask DP
```cpp
int dp[1 << N][N];  // N <= 20
for (int mask = 0; mask < (1 << n); mask++) {
    for (int i = 0; i < n; i++) {
        if (mask & (1 << i)) {
            // Transition from previous states
            int prev = mask ^ (1 << i);
            // dp[mask][i] = min/max of dp[prev][j] + cost
        }
    }
}
```

---

## Chapter 9: Optimization Techniques

### 9.1 Space Optimization
- Use bit arrays instead of boolean arrays (32x memory reduction)
- Pack multiple values in single integer
- Use bitmask instead of set/hashmap when range â‰¤ 32

### 9.2 Time Optimization
- Use bitwise AND for modulo with power of 2: `x % 2^n = x & (2^n - 1)`
- Use bit shifts for multiplication/division by powers of 2
- Use `__builtin` functions for counting bits

### 9.3 Built-in Functions (GCC)
- `__builtin_popcount(x)` - count set bits
- `__builtin_clz(x)` - count leading zeros
- `__builtin_ctz(x)` - count trailing zeros
- `__builtin_parity(x)` - parity of set bits
- For `long long`: add `ll` suffix (e.g., `__builtin_popcountll`)

---

## Chapter 10: Hard-Level Interview Patterns

### 10.1 Maximum XOR Patterns
- **Trie-based solutions** for maximum XOR queries
- **Prefix-based XOR** for subarray problems
- **Divide and conquer** for maximum XOR pair

### 10.2 Bitwise Trie Problems
- Insert numbers bit by bit (from MSB)
- Query for maximum XOR with given number
- Time: O(32) per operation

### 10.3 Multi-Dimensional Bitmask DP
- Use multiple bitmasks simultaneously
- Example: Match 2 sets of items with constraints

### 10.4 Game Theory with Bits
- Nim game and XOR
- Grundy numbers
- Bitwise operations in minimax

### 10.5 Matrix Exponentiation with Bits
- Fast power using bit representation of exponent
- State transitions encoded as bitmasks

---

## Chapter 11: Practice Strategy

### 11.1 Beginner Level (Start Here)
1. Number of 1 Bits
2. Power of Two
3. Reverse Bits
4. Single Number
5. Counting Bits

### 11.2 Intermediate Level
1. Single Number II
2. Single Number III
3. Bitwise AND of Numbers Range
4. Maximum XOR of Two Numbers
5. Subsets
6. Gray Code

### 11.3 Advanced Level
1. Maximum XOR with Element from Array
2. Shortest Path Visiting All Nodes
3. Minimum One Bit Operations
4. Number of Valid Words
5. Maximum Students Taking Exam

### 11.4 Hard Level
1. Maximize XOR for Queries (Trie)
2. Find XOR Sum of All Pairs
3. Concatenated Words (Trie)
4. Shortest Path to Get All Keys (Bitmask BFS)
5. Smallest Sufficient Team (Bitmask DP)

---

## Chapter 12: Key Takeaways & Cheat Sheet

### ðŸ”´ Golden Rules:
1. **XOR Properties**: Self-inverse, commutative, `a ^ a = 0`, `a ^ 0 = a`
2. **Power of 2 Check**: `x & (x-1) == 0`
3. **Rightmost Set Bit**: `x & (-x)`
4. **Clear Rightmost Set Bit**: `x & (x-1)`
5. **All Bits Set Mask**: `(1 << n) - 1`

### ðŸ”´ Time Complexities:
- Check/Set/Clear/Toggle bit: O(1)
- Count set bits (Kernighan): O(k), k = set bits
- Generate subsets: O(2^n)
- Bitmask DP: O(2^n * n) to O(2^n * n^2)

### ðŸ”´ Space Complexities:
- Bitset for n elements: O(n/32) = O(n) bits
- Bitmask DP: O(2^n * states)

### ðŸ”´ When to Use Bit Manipulation:
- âœ… Finding unique elements with XOR
- âœ… Subset generation and enumeration
- âœ… State compression in DP (n â‰¤ 20)
- âœ… Space optimization for boolean arrays
- âœ… Fast powers of 2 operations
- âŒ When readability is more important
- âŒ When n > 30 (bitmask becomes too large)

---

## Appendix: Common Mistakes to Avoid

1. **Operator Precedence**: `&` and `|` have lower precedence than `==`, use parentheses
2. **Signed vs Unsigned**: Right shift behaves differently
3. **Overflow**: `1 << 31` might overflow in 32-bit int, use `1LL << 31`
4. **Off-by-one**: Remember bits are 0-indexed
5. **Masking**: Always create proper masks, don't assume bit patterns

---

**Master these patterns and you'll be ready for any bit manipulation question in hard-level interviews!**