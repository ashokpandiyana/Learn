# Chapter 12: Key Takeaways & Cheat Sheet - Complete In-Depth Guide

This chapter provides comprehensive explanations of essential bit manipulation patterns, formulas, and techniques with Python implementations.

---

## 12.1 Golden Rules - Deep Dive

### Rule 1: XOR Properties (The Magic of XOR)

XOR (Exclusive OR) is the most powerful operator in bit manipulation due to its unique properties.

#### Property 1: Self-Inverse (a ^ a = 0)

```python
# Any number XOR with itself equals 0
print(f"5 ^ 5 = {5 ^ 5}")      # 0
print(f"100 ^ 100 = {100 ^ 100}")  # 0

# Why?
# 5 in binary:   101
# 5 in binary:   101
# XOR:           000 (bits are same, XOR gives 0)

# Visual proof:
def xor_self_demo(n):
    """Demonstrate a ^ a = 0"""
    binary = bin(n)[2:].zfill(8)
    print(f"Number: {n} = {binary}")
    print(f"Same number: {n} = {binary}")
    print(f"XOR result: {n ^ n} = {bin(n ^ n)[2:].zfill(8)}")
    print(f"All bits cancel out! {n} ^ {n} = 0\n")

xor_self_demo(42)
```

**Applications**:
- Finding single number among duplicates
- Detecting duplicates
- Swapping values without temporary variable

#### Property 2: Identity (a ^ 0 = a)

```python
# Any number XOR with 0 equals itself
print(f"5 ^ 0 = {5 ^ 0}")      # 5
print(f"100 ^ 0 = {100 ^ 0}")  # 100

# Why?
# 5 in binary:   101
# 0 in binary:   000
# XOR:           101 (unchanged)

# Visual proof:
def xor_identity_demo(n):
    """Demonstrate a ^ 0 = a"""
    binary = bin(n)[2:].zfill(8)
    print(f"Number: {n} = {binary}")
    print(f"Zero: 0 = {bin(0)[2:].zfill(8)}")
    print(f"XOR result: {n ^ 0} = {bin(n ^ 0)[2:].zfill(8)}")
    print(f"Identity preserved! {n} ^ 0 = {n}\n")

xor_identity_demo(42)
```

**Applications**:
- Initializing XOR accumulator
- Removing elements from XOR chain

#### Property 3: Commutative (a ^ b = b ^ a)

```python
# Order doesn't matter
a, b = 5, 3
print(f"{a} ^ {b} = {a ^ b}")  # 6
print(f"{b} ^ {a} = {b ^ a}")  # 6

# Why?
# XOR compares bits independently
# Bit comparison is symmetric: 
#   0 ^ 1 = 1 and 1 ^ 0 = 1
#   0 ^ 0 = 0 and 0 ^ 0 = 0
```

#### Property 4: Associative ((a ^ b) ^ c = a ^ (b ^ c))

```python
# Grouping doesn't matter
a, b, c = 5, 3, 7
print(f"(a ^ b) ^ c = {(a ^ b) ^ c}")  
print(f"a ^ (b ^ c) = {a ^ (b ^ c)}")  
# Both give same result

# Combined with commutativity:
# We can rearrange XOR expressions freely!
```

#### The Magic Combination: Finding Single Number

```python
def single_number_explained(nums):
    """
    Use XOR properties to find single number
    
    All duplicates cancel out due to a ^ a = 0
    Single number survives due to a ^ 0 = a
    Order doesn't matter due to commutative/associative properties
    """
    result = 0
    print(f"Finding single number in {nums}\n")
    
    for i, num in enumerate(nums):
        old_result = result
        result ^= num
        print(f"Step {i+1}: {old_result:04b} ^ {num:04b} = {result:04b} ({result})")
    
    print(f"\nDue to XOR properties:")
    print(f"- All pairs cancel: a ^ a = 0")
    print(f"- Single remains: a ^ 0 = a")
    print(f"- Order irrelevant: commutative & associative")
    print(f"\nSingle number: {result}")
    return result

single_number_explained([4, 1, 2, 1, 2])
```

---

### Rule 2: Power of 2 Check (x & (x-1) == 0)

Powers of 2 have exactly ONE set bit:
```
1   = 00001 (2^0)
2   = 00010 (2^1)
4   = 00100 (2^2)
8   = 01000 (2^3)
16  = 10000 (2^4)
```

#### Why x & (x-1) Works

```python
def power_of_2_visualization(x):
    """Visualize why x & (x-1) == 0 for powers of 2"""
    if x <= 0:
        print(f"{x} is not a power of 2 (must be positive)")
        return False
    
    print(f"\nChecking if {x} is a power of 2:")
    print(f"x     = {x:3d} = {bin(x)[2:].zfill(8)}")
    print(f"x-1   = {x-1:3d} = {bin(x-1)[2:].zfill(8)}")
    result = x & (x - 1)
    print(f"x&x-1 = {result:3d} = {bin(result)[2:].zfill(8)}")
    
    is_power_of_2 = (result == 0)
    
    if is_power_of_2:
        print(f"\n✓ {x} IS a power of 2!")
        print(f"Explanation: x has ONE set bit")
        print(f"When we subtract 1, that bit becomes 0 and all lower bits become 1")
        print(f"x & (x-1) removes that one set bit → result is 0")
    else:
        print(f"\n✗ {x} is NOT a power of 2")
        print(f"Explanation: x has MULTIPLE set bits")
        print(f"x & (x-1) only removes ONE set bit → result still has bits")
    
    return is_power_of_2

# Test powers of 2
for num in [1, 2, 4, 8, 16]:
    power_of_2_visualization(num)

print("\n" + "="*60 + "\n")

# Test non-powers of 2
for num in [3, 5, 6, 18]:
    power_of_2_visualization(num)
```

**Detailed Breakdown**:
```
For x = 8 (power of 2):
x   = 1000
x-1 = 0111
x & (x-1) = 1000 & 0111 = 0000 ✓

For x = 10 (not power of 2):
x   = 1010
x-1 = 1001
x & (x-1) = 1010 & 1001 = 1000 ≠ 0 ✗
```

**Complete Implementation**:
```python
def is_power_of_two(x):
    """
    Check if x is a power of 2
    
    Time: O(1)
    Space: O(1)
    """
    return x > 0 and (x & (x - 1)) == 0

# Alternative: Count set bits
def is_power_of_two_alt(x):
    """Alternative using bit count"""
    return x > 0 and bin(x).count('1') == 1

# Test
print(f"16 is power of 2: {is_power_of_two(16)}")
print(f"18 is power of 2: {is_power_of_two(18)}")
```

---

### Rule 3: Rightmost Set Bit (x & -x)

This isolates the rightmost (least significant) set bit.

#### How It Works: Two's Complement

```python
def rightmost_bit_visualization(x):
    """Visualize x & (-x) for isolating rightmost set bit"""
    print(f"\nIsolating rightmost set bit of {x}:")
    
    # For visualization, work with 8 bits
    bits = 8
    x_positive = x & ((1 << bits) - 1)  # Ensure positive for display
    
    print(f"x       = {x:3d} = {bin(x_positive)[2:].zfill(bits)}")
    
    # Two's complement: flip bits and add 1
    x_flipped = ~x_positive & ((1 << bits) - 1)
    print(f"~x      =       {bin(x_flipped)[2:].zfill(bits)} (flip all bits)")
    
    neg_x = (x_flipped + 1) & ((1 << bits) - 1)
    print(f"-x      = {-x & ((1 << bits) - 1):3d} = {bin(neg_x)[2:].zfill(bits)} (add 1)")
    
    result = x & (-x)
    print(f"x & -x  = {result:3d} = {bin(result)[2:].zfill(bits)}")
    
    # Find position
    if result > 0:
        position = (result & -result).bit_length() - 1
        print(f"\nRightmost set bit is at position {position} (0-indexed from right)")
    
    return result

# Test various numbers
for num in [12, 10, 8, 7, 16]:
    rightmost_bit_visualization(num)
```

**Why It Works**:
```
Step-by-step for x = 12 (1100):

1. x      = 1100
2. ~x     = 0011 (flip all bits)
3. ~x + 1 = 0100 (add 1, this is -x in two's complement)
4. x & -x = 1100 & 0100 = 0100

The magic:
- When we add 1 to ~x, it propagates until it reaches the rightmost 0
- That rightmost 0 (which is rightmost 1 in x) becomes 1
- All bits to the right become 0
- All bits to the left stay opposite of x
- When we AND with x, only the rightmost set bit survives!
```

**Applications**:
```python
def rightmost_bit_applications():
    """Show practical uses of x & -x"""
    
    # Application 1: Find position of rightmost set bit
    def rightmost_position(x):
        rightmost = x & -x
        return rightmost.bit_length() - 1 if rightmost else -1
    
    print("Application 1: Find position")
    for num in [8, 12, 7]:
        pos = rightmost_position(num)
        print(f"  {num} = {bin(num)[2:].zfill(8)}, rightmost set bit at position {pos}")
    
    # Application 2: Fenwick Tree (Binary Indexed Tree)
    def fenwick_parent(i):
        """In Fenwick tree, parent is found by removing rightmost bit"""
        return i - (i & -i)
    
    print("\nApplication 2: Fenwick Tree navigation")
    for i in [6, 7, 8]:
        parent = fenwick_parent(i)
        print(f"  Index {i}: parent is {parent}")
    
    # Application 3: Count trailing zeros
    def count_trailing_zeros(x):
        if x == 0:
            return 32  # or word size
        rightmost = x & -x
        return (rightmost - 1).bit_count()
    
    print("\nApplication 3: Count trailing zeros")
    for num in [8, 12, 16]:
        zeros = count_trailing_zeros(num)
        print(f"  {num} = {bin(num)[2:].zfill(8)}, trailing zeros: {zeros}")

rightmost_bit_applications()
```

---

### Rule 4: Clear Rightmost Set Bit (x & (x-1))

This removes the rightmost set bit.

```python
def clear_rightmost_visualization(x):
    """Visualize x & (x-1) clearing rightmost set bit"""
    print(f"\nClearing rightmost set bit of {x}:")
    print(f"x     = {x:3d} = {bin(x)[2:].zfill(8)}")
    print(f"x-1   = {x-1:3d} = {bin(x-1)[2:].zfill(8)}")
    
    result = x & (x - 1)
    print(f"x&x-1 = {result:3d} = {bin(result)[2:].zfill(8)}")
    
    # Show what changed
    diff = x ^ result
    print(f"\nBit removed: {bin(diff)[2:].zfill(8)}")
    
    return result

# Brian Kernighan's algorithm for counting set bits
def count_set_bits_brian_kernighan(x):
    """
    Count set bits by repeatedly clearing rightmost set bit
    
    Time: O(k) where k is number of set bits
    """
    count = 0
    print(f"\nCounting set bits in {x} = {bin(x)[2:].zfill(8)}")
    
    while x:
        print(f"  Step {count + 1}: x = {bin(x)[2:].zfill(8)} ({x})")
        x = x & (x - 1)
        count += 1
    
    print(f"Total set bits: {count}")
    return count

# Test
clear_rightmost_visualization(12)  # 1100 → 1000
count_set_bits_brian_kernighan(23)  # 10111 has 4 set bits
```

**Why x-1 Flips Bits**:
```
When we subtract 1:
1. Rightmost 1 becomes 0
2. All 0s to the right become 1
3. Everything to the left stays same

Example: x = 10110
         x-1 = 10101
         
Rightmost 1 is at position 1
After x-1: position 1 becomes 0, position 0 (which was 0) becomes 1

x & (x-1) = 10110 & 10101 = 10100
The rightmost 1 is gone!
```

---

### Rule 5: All Bits Set Mask ((1 << n) - 1)

Create a number with n lowest bits set to 1.

```python
def create_mask_visualization(n):
    """Visualize creating n-bit mask"""
    print(f"\nCreating mask with {n} bits set:")
    
    # Step 1: 1 << n creates 1 followed by n zeros
    shifted = 1 << n
    print(f"Step 1: 1 << {n} = {shifted} = {bin(shifted)[2:].zfill(n+1)}")
    
    # Step 2: Subtract 1 to get n ones
    mask = shifted - 1
    print(f"Step 2: {shifted} - 1 = {mask} = {bin(mask)[2:].zfill(n)}")
    
    print(f"\nResult: {n}-bit mask = {mask} = {bin(mask)[2:]}")
    
    return mask

# Test
for n in [4, 8, 16]:
    create_mask_visualization(n)

print("\n" + "="*60 + "\n")

# Practical applications
def mask_applications():
    """Show uses of bit masks"""
    
    # Application 1: Extract lower n bits
    def extract_lower_bits(x, n):
        mask = (1 << n) - 1
        return x & mask
    
    x = 0b11010110
    print(f"Number: {x} = {bin(x)[2:].zfill(8)}")
    print(f"Lower 4 bits: {extract_lower_bits(x, 4)} = {bin(extract_lower_bits(x, 4))[2:].zfill(4)}")
    print(f"Lower 3 bits: {extract_lower_bits(x, 3)} = {bin(extract_lower_bits(x, 3))[2:].zfill(3)}")
    
    # Application 2: Check if number fits in n bits
    def fits_in_n_bits(x, n):
        max_value = (1 << n) - 1
        return 0 <= x <= max_value
    
    print(f"\nChecking if numbers fit in 4 bits (max value = 15):")
    for num in [10, 15, 16, 20]:
        print(f"  {num}: {fits_in_n_bits(num, 4)}")
    
    # Application 3: Subset generation
    def generate_subsets(n):
        """Generate all subsets using bitmask"""
        print(f"\nGenerating all subsets of {n} elements:")
        for mask in range(1 << n):
            subset = [i for i in range(n) if mask & (1 << i)]
            print(f"  Mask {bin(mask)[2:].zfill(n)}: subset {subset}")
    
    generate_subsets(3)

mask_applications()
```

**Mathematical Proof**:
```
Why (1 << n) - 1 gives n bits set?

1 << n in binary:
n=1: 10       (2)
n=2: 100      (4)
n=3: 1000     (8)
n=4: 10000    (16)

When we subtract 1, we borrow from the only set bit:
n=1: 10 - 1   = 1      (01)
n=2: 100 - 1  = 11     (011)
n=3: 1000 - 1 = 111    (0111)
n=4: 10000 - 1 = 1111  (01111)

Pattern: Subtracting 1 from 10...0 gives 01...1 (n ones)
```

---

## 12.2 Time Complexities - In-Depth Analysis

### Bit Operation Complexities

```python
def complexity_analysis():
    """Analyze time complexity of common bit operations"""
    
    print("Basic Bit Operations (all O(1)):")
    operations = [
        ("Check bit", "x & (1 << i)"),
        ("Set bit", "x | (1 << i)"),
        ("Clear bit", "x & ~(1 << i)"),
        ("Toggle bit", "x ^ (1 << i)"),
        ("Isolate rightmost", "x & -x"),
        ("Clear rightmost", "x & (x-1)"),
    ]
    
    for name, op in operations:
        print(f"  {name:20} {op:20} Time: O(1)")
    
    print("\n" + "="*60)
    print("\nCounting Set Bits:")
    
    # Method 1: Check all bits
    def count_bits_all(x):
        """O(log n) = O(32) for 32-bit integer"""
        count = 0
        iterations = 0
        while x:
            count += x & 1
            x >>= 1
            iterations += 1
        return count, iterations
    
    # Method 2: Brian Kernighan
    def count_bits_kernighan(x):
        """O(k) where k = number of set bits"""
        count = 0
        original = x
        while x:
            x &= (x - 1)
            count += 1
        return count, count  # iterations = count
    
    test_nums = [15, 255, 1023, 1024]  # Different numbers of set bits
    
    print("\nMethod 1: Check all bits - O(log n)")
    for num in test_nums:
        count, iters = count_bits_all(num)
        print(f"  {num:4d} ({bin(num)[2:]:10s}): {count} set bits, {iters} iterations")
    
    print("\nMethod 2: Brian Kernighan - O(k)")
    for num in test_nums:
        count, iters = count_bits_kernighan(num)
        print(f"  {num:4d} ({bin(num)[2:]:10s}): {count} set bits, {iters} iterations")
    
    print("\n" + "="*60)
    print("\nSubset Generation: O(2^n)")
    
    def count_subsets(n):
        """Count total subsets"""
        return 1 << n  # 2^n
    
    for n in [3, 5, 10, 20]:
        subsets = count_subsets(n)
        print(f"  n={n:2d}: {subsets:10d} subsets (2^{n})")
    
    print("\n" + "="*60)
    print("\nBitmask DP Complexity:")
    print("  State space: O(2^n * m) where")
    print("    n = items to mask (usually n ≤ 20)")
    print("    m = additional dimensions")
    print("\n  Examples:")
    print("    TSP: O(2^n * n^2) - visit all cities")
    print("    Assignment: O(2^n * n) - assign n tasks")
    print("    Subset sum: O(2^n * sum) - if sum is small")

complexity_analysis()
```

---

## 12.3 Space Complexities - Memory Optimization

```python
def space_complexity_analysis():
    """Analyze space usage with bit manipulation"""
    
    print("Space Optimization Examples:\n")
    
    # Example 1: Boolean array vs Bitset
    print("1. Boolean Array vs Bitset:")
    n = 10000
    
    # Boolean array: 1 byte per boolean
    bool_array_bytes = n * 1  # Python uses more, but conceptually
    print(f"  Boolean array for {n} elements: ~{bool_array_bytes:,} bytes")
    
    # Bitset: 1 bit per boolean
    bitset_bytes = (n + 7) // 8  # Round up to nearest byte
    print(f"  Bitset for {n} elements: {bitset_bytes:,} bytes")
    print(f"  Space reduction: {bool_array_bytes / bitset_bytes:.1f}x")
    
    # Implementation
    class Bitset:
        def __init__(self, size):
            self.size = size
            # Store in list of integers (each int holds 32 bits in Python)
            self.bits = [0] * ((size + 31) // 32)
        
        def set(self, pos):
            """Set bit at position pos"""
            if 0 <= pos < self.size:
                idx = pos // 32
                bit = pos % 32
                self.bits[idx] |= (1 << bit)
        
        def clear(self, pos):
            """Clear bit at position pos"""
            if 0 <= pos < self.size:
                idx = pos // 32
                bit = pos % 32
                self.bits[idx] &= ~(1 << bit)
        
        def test(self, pos):
            """Test if bit at position pos is set"""
            if 0 <= pos < self.size:
                idx = pos // 32
                bit = pos % 32
                return bool(self.bits[idx] & (1 << bit))
            return False
    
    # Demo
    bitset = Bitset(100)
    bitset.set(5)
    bitset.set(50)
    bitset.set(99)
    print(f"\n  Bitset demo: positions 5, 50, 99 are set")
    print(f"  Test position 5: {bitset.test(5)}")
    print(f"  Test position 10: {bitset.test(10)}")
    
    print("\n" + "="*60)
    print("\n2. Bitmask DP Space Usage:")
    
    def bitmask_dp_space(n, m):
        """Calculate space for bitmask DP"""
        states = (1 << n) * m
        bytes_per_state = 4  # Assuming 32-bit integers
        total_bytes = states * bytes_per_state
        return states, total_bytes
    
    configs = [(10, 10), (15, 15), (20, 20), (25, 25)]
    
    print(f"  {'n':<4} {'m':<4} {'States':<15} {'Memory':<15} {'Feasible?'}")
    print("  " + "-"*55)
    
    for n, m in configs:
        states, bytes_used = bitmask_dp_space(n, m)
        mb = bytes_used / (1024 * 1024)
        feasible = "✓" if mb < 1000 else "✗"
        print(f"  {n:<4} {m:<4} {states:<15,} {mb:>10.2f} MB   {feasible}")
    
    print("\n  Note: n > 20 typically not feasible for bitmask DP")
    
    print("\n" + "="*60)
    print("\n3. Compact Data Structures:")
    
    # Store multiple small values in one integer
    def pack_rgb(r, g, b):
        """Pack 3 color values (0-255) into one integer"""
        return (r << 16) | (g << 8) | b
    
    def unpack_rgb(color):
        """Extract RGB values from packed integer"""
        r = (color >> 16) & 0xFF
        g = (color >> 8) & 0xFF
        b = color & 0xFF
        return r, g, b
    
    packed = pack_rgb(255, 128, 64)
    print(f"  Packed RGB(255,128,64): {packed} = {hex(packed)}")
    print(f"  Unpacked: RGB{unpack_rgb(packed)}")
    print(f"  Space: 1 integer instead of 3")
    
    # Store flags in one integer
    FLAGS_READ = 1 << 0
    FLAGS_WRITE = 1 << 1
    FLAGS_EXECUTE = 1 << 2
    FLAGS_ADMIN = 1 << 3
    
    user_permissions = FLAGS_READ | FLAGS_WRITE
    print(f"\n  User permissions: {bin(user_permissions)[2:].zfill(4)}")
    print(f"  Has read: {bool(user_permissions & FLAGS_READ)}")
    print(f"  Has execute: {bool(user_permissions & FLAGS_EXECUTE)}")

space_complexity_analysis()
```

---

## 12.4 When to Use Bit Manipulation - Decision Guide

```python
def decision_guide():
    """Guide for when to use bit manipulation"""
    
    scenarios = [
        {
            "use_case": "Finding unique element among duplicates",
            "should_use": True,
            "reason": "XOR properties make this O(1) space, O(n) time",
            "example": "[1,2,3,2,1] → use XOR to find 3"
        },
        {
            "use_case": "Subset generation (n ≤ 20)",
            "should_use": True,
            "reason": "Bitmask naturally represents subsets, 2^20 = ~1M is feasible",
            "example": "Generate all subsets of [a,b,c]"
        },
        {
            "use_case": "Dynamic programming with state (n ≤ 20)",
            "should_use": True,
            "reason": "Compact state representation, enables DP on combinations",
            "example": "Traveling Salesman, Assignment problems"
        },
        {
            "use_case": "Fast multiplication/division by powers of 2",
            "should_use": True,
            "reason": "Bit shifts are faster than arithmetic operations",
            "example": "x * 8 → x << 3, x / 4 → x >> 2"
        },
        {
            "use_case": "Space optimization for boolean flags",
            "should_use": True,
            "reason": "32x memory reduction using bits instead of bytes",
            "example": "Store 1M boolean values in 125KB instead of 1MB"
        },
        {
            "use_case": "Readable business logic",
            "should_use": False,
            "reason": "Bit manipulation reduces code clarity",
            "example": "Use 'if user.is_admin' not 'if user & FLAG_ADMIN'"
        },
        {
            "use_case": "State compression (n > 30)",
            "should_use": False,
            "reason": "2^30+ states cause memory/time explosion",
            "example": "TSP with 40 cities → use different approach"
        },
        {
            "use_case": "Floating point operations",
            "should_use": False,
            "reason": "Bit operations are for integers, floats have special representation",
            "example": "Don't use << for float multiplication"
        }
    ]
    
    print("WHEN TO USE BIT MANIPULATION:\n")
    print("✓ GOOD USE CASES:")
    print("="*60)
    
    for scenario in scenarios:
        if scenario["should_use"]:
            print(f"\n{scenario['use_case']}")
            print(f"  Reason: {scenario['reason']}")
            print(f"  Example: {scenario['example']}")
    
    print("\n" + "="*60)
    print("\n✗ AVOID IN THESE CASES:")
    print("="*60)
    
    for scenario in scenarios:
        if not scenario["should_use"]:
            print(f"\n{scenario['use_case']}")
            print(f"  Reason: {scenario['reason']}")
            print(f"  Example: {scenario['example']}")
    
    print("\n" + "="*60)
    print("\nQUICK DECISION FLOWCHART:")
    print("""
    Is the problem about:
    
    ┌─ Unique elements with duplicates? ────────────→ Use XOR
    │
    ├─ Subsets/combinations (n ≤ 20)? ─────────────→ Use bitmask
    │
    ├─ DP with small state space (n ≤ 20)? ────────→ Use bitmask DP
    │
    ├─ Fast power-of-2 operations? ────────────────→ Use bit shifts
    │
    ├─ Memory optimization for booleans? ──────────→ Use bitset
    │
    ├─ Readable business logic? ───────────────────→ DON'T use bits
    │
    ├─ Large state space (n > 30)? ────────────────→ DON'T use bits
    │
    └─ Floating point math? ───────────────────────→ DON'T use bits
    """)

decision_guide()
```

---

## 12.5 Common Mistakes to Avoid - Detailed Examples

```python
def common_mistakes():
    """Demonstrate common bit manipulation mistakes and fixes"""
    
    print("COMMON MISTAKES AND FIXES:\n")
    
    # Mistake 1: Operator precedence
    print("1. OPERATOR PRECEDENCE")
    print("="*60)
    
    x = 5
    # WRONG
    wrong = x & 1 == 0  # Parsed as: x & (1 == 0) → x & False → 0
    print(f"Wrong: x & 1 == 0 evaluates to {wrong}")
    
    # CORRECT
    correct = (x & 1) == 0
    print(f"Correct: (x & 1) == 0 evaluates to {correct}")
    
    print("\nWhy? Because == has higher precedence than &")
    print("Always use parentheses with bitwise operators in comparisons!")
    
    print("\n" + "="*60)
    
    # Mistake 2: Signed vs unsigned right shift
    print("\n2. SIGNED VS UNSIGNED RIGHT SHIFT")
    print("="*60)
    
    # Python handles this automatically, but be aware in other languages
    positive = 8
    negative = -8
    
    print(f"Positive {positive} >> 1 = {positive >> 1}")
    print(f"Negative {negative} >> 1 = {negative >> 1}")
    print("\nIn Python, >> is arithmetic (sign-preserving)")
    print("In Java/C++, >>> is logical (zero-fill)")
    
    print("\n" + "="*60)
    
    # Mistake 3: Integer overflow with shifts
    print("\n3. INTEGER OVERFLOW WITH SHIFTS")
    print("="*60)
    
    # WRONG in languages with fixed-size integers
    print("In C++/Java (32-bit int):")
    print("  1 << 31 might overflow to negative")
    print("  1 << 32 is undefined behavior")
    
    # CORRECT
    print("\nCorrect approach:")
    print("  Use 1LL << 31 in C++ (64-bit)")
    print("  Check bit position < 32")
    
    # Python handles arbitrary precision
    large_shift = 1 << 100
    print(f"\nPython handles large shifts fine: 1 << 100 = {large_shift}")
    
    print("\n" + "="*60)
    
    # Mistake 4: Off-by-one with bit positions
    print("\n4. OFF-BY-ONE ERRORS")
    print("="*60)
    
    def demonstrate_indexing():
        x = 0b10110
        print(f"Number: {x} = {bin(x)[2:]}")
        print("\nBit positions (0-indexed from right):")
        print("  Position: 4 3 2 1 0")
        print(f"  Bits:     {bin(x)[2:].zfill(5).replace('', ' ').strip()}")
        
        # Extract bit at position 2
        bit_2 = (x >> 2) & 1
        print(f"\nBit at position 2: {bit_2}")
        print("Remember: Positions start at 0 from the RIGHT")
    
    demonstrate_indexing()
    
    print("\n" + "="*60)
    
    # Mistake 5: Forgetting to check for zero
    print("\n5. NOT CHECKING FOR ZERO")
    print("="*60)
    
    def power_of_two_wrong(x):
        """WRONG: Doesn't check for zero"""
        return (x & (x - 1)) == 0
    
    def power_of_two_correct(x):
        """CORRECT: Checks for zero"""
        return x > 0 and (x & (x - 1)) == 0
    
    print(f"Is 0 a power of 2?")
    print(f"  Wrong version: {power_of_two_wrong(0)}")  # True (wrong!)
    print(f"  Correct version: {power_of_two_correct(0)}")  # False
    
    print("\n" + "="*60)
    
    # Mistake 6: Not handling negative numbers
    print("\n6. NOT HANDLING NEGATIVE NUMBERS")
    print("="*60)
    
    def count_bits_wrong(x):
        """WRONG: Infinite loop for negative numbers in some languages"""
        count = 0
        while x:
            count += x & 1
            x >>= 1  # In Python this works, but in Java/C++ with int...
        return count
    
    def count_bits_correct(x):
        """CORRECT: Convert to positive or use different method"""
        if x < 0:
            # In Python, use bin() and count
            return bin(x).count('1')
        count = 0
        while x:
            count += x & 1
            x >>= 1
        return count
    
    print("For negative numbers:")
    print("  Use absolute value or language-specific handling")
    print("  Python's bin() handles negatives correctly")
    
    print("\n" + "="*60)
    
    # Mistake 7: Creating wrong masks
    print("\n7. INCORRECT MASK CREATION")
    print("="*60)
    
    def create_mask_wrong(n):
        """WRONG: Doesn't account for n=0"""
        return (1 << n) - 1
    
    def create_mask_correct(n):
        """CORRECT: Handles edge cases"""
        if n <= 0:
            return 0
        return (1 << n) - 1
    
    for n in [0, 4, 8]:
        wrong = create_mask_wrong(n) if n > 0 else "crashes for n=0"
        correct = create_mask_correct(n)
        print(f"  n={n}: correct={bin(correct)[2:].zfill(max(n,1))}")

common_mistakes()
```

---

## 12.6 Quick Reference - Bit Manipulation Cheat Sheet

```python
def create_cheat_sheet():
    """Comprehensive quick reference for bit manipulation"""
    
    print("""
╔═══════════════════════════════════════════════════════════════════════╗
║                  BIT MANIPULATION CHEAT SHEET                         ║
╚═══════════════════════════════════════════════════════════════════════╝

┌─────────────────────────────────────────────────────────────────────┐
│ BASIC OPERATIONS                                                     │
├─────────────────────────────────────────────────────────────────────┤
│ Operation              │ Code              │ Example (x=5,i=2)      │
├────────────────────────┼───────────────────┼────────────────────────┤
│ Check i-th bit         │ x & (1 << i)      │ 5 & 4 = 4 (TRUE)      │
│ Set i-th bit           │ x | (1 << i)      │ 5 | 4 = 5 (no change) │
│ Clear i-th bit         │ x & ~(1 << i)     │ 5 & ~4 = 1            │
│ Toggle i-th bit        │ x ^ (1 << i)      │ 5 ^ 4 = 1             │
│ Rightmost set bit      │ x & (-x)          │ 5 & -5 = 1            │
│ Clear rightmost bit    │ x & (x - 1)       │ 5 & 4 = 4             │
│ Create n-bit mask      │ (1 << n) - 1      │ (1 << 3) - 1 = 7      │
└────────────────────────┴───────────────────┴────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ COMMON CHECKS                                                        │
├─────────────────────────────────────────────────────────────────────┤
│ Check                  │ Code              │ Explanation            │
├────────────────────────┼───────────────────┼────────────────────────┤
│ Is odd?                │ x & 1             │ LSB is 1               │
│ Is even?               │ !(x & 1)          │ LSB is 0               │
│ Is power of 2?         │ x>0 & !(x&(x-1))  │ Only one bit set       │
│ Is power of 4?         │ x>0 & !(x&(x-1))  │ One bit at even pos    │
│                        │   & (x&0xAAAAAAAA)│                        │
│ Same sign?             │ (x^y) >= 0        │ XOR MSB same           │
│ Opposite sign?         │ (x^y) < 0         │ XOR MSB differ         │
└────────────────────────┴───────────────────┴────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ ARITHMETIC SHORTCUTS                                                 │
├─────────────────────────────────────────────────────────────────────┤
│ Operation              │ Bit Version       │ Example                │
├────────────────────────┼───────────────────┼────────────────────────┤
│ Multiply by 2^n        │ x << n            │ 5 << 2 = 20           │
│ Divide by 2^n          │ x >> n            │ 20 >> 2 = 5           │
│ Modulo 2^n             │ x & ((1<<n)-1)    │ 13 & 7 = 5 (13%8)     │
│ Average (no overflow)  │ (x&y)+((x^y)>>1)  │ Avoid (x+y)/2         │
│ Min of two             │ y^((x^y)&-(x<y))  │ Without branch        │
│ Max of two             │ x^((x^y)&-(x<y))  │ Without branch        │
│ Absolute value         │ (x^(x>>31))-(x>>31) │ For signed int      │
│ Sign (-1, 0, or 1)     │ (x!=0)|-(x<0)     │ Compact sign          │
└────────────────────────┴───────────────────┴────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ XOR PROPERTIES (THE MAGIC OPERATOR)                                 │
├─────────────────────────────────────────────────────────────────────┤
│ Property               │ Formula           │ Use Case               │
├────────────────────────┼───────────────────┼────────────────────────┤
│ Self-inverse           │ a ^ a = 0         │ Find unique number     │
│ Identity               │ a ^ 0 = a         │ Preserve value         │
│ Commutative            │ a ^ b = b ^ a     │ Rearrange terms        │
│ Associative            │ (a^b)^c = a^(b^c) │ Group differently      │
│ Swap without temp      │ a^=b; b^=a; a^=b  │ In-place swap          │
└────────────────────────┴───────────────────┴────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ BIT COUNTING                                                         │
├─────────────────────────────────────────────────────────────────────┤
│ Method                 │ Code              │ Complexity             │
├────────────────────────┼───────────────────┼────────────────────────┤
│ Loop all bits          │ while x: c+=x&1;  │ O(log n) = O(32)      │
│                        │   x>>=1           │                        │
│ Brian Kernighan        │ while x: x&=x-1;  │ O(k) k=set bits       │
│                        │   c+=1            │                        │
│ Python builtin         │ bin(x).count('1') │ O(1) optimized        │
└────────────────────────┴───────────────────┴────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ SUBSET GENERATION                                                    │
├─────────────────────────────────────────────────────────────────────┤
│ for mask in range(1 << n):              # All 2^n subsets          │
│     subset = [i for i in range(n)                                   │
│               if mask & (1 << i)]                                   │
│                                                                       │
│ # Iterate subsets of mask                                           │
│ submask = mask                                                       │
│ while submask:                                                       │
│     # Process submask                                               │
│     submask = (submask - 1) & mask                                  │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ COMPLEXITY GUIDELINES                                                │
├─────────────────────────────────────────────────────────────────────┤
│ n ≤ 10  → O(2^n) = 1,024           EASY                            │
│ n ≤ 15  → O(2^n) = 32,768          MEDIUM                          │
│ n ≤ 20  → O(2^n) = 1,048,576       FEASIBLE (use bitmask DP)      │
│ n ≤ 25  → O(2^n) = 33,554,432      TIGHT (careful optimization)   │
│ n > 30  → O(2^n) = 1B+             INFEASIBLE (different approach) │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ PROBLEM PATTERNS                                                     │
├─────────────────────────────────────────────────────────────────────┤
│ Pattern                │ Key Technique      │ Example Problem       │
├────────────────────────┼────────────────────┼───────────────────────┤
│ Find unique            │ XOR all            │ Single Number         │
│ Count subsets          │ Iterate 2^n masks  │ Subset Sum            │
│ Optimize selection     │ Bitmask DP         │ TSP, Assignment       │
│ Binary structure       │ Trie of bits       │ Maximum XOR           │
│ Graph state            │ Bitmask BFS/DFS    │ Visit all nodes       │
│ Bit properties         │ AND/OR ranges      │ Range queries         │
└────────────────────────┴────────────────────┴───────────────────────┘

╔═══════════════════════════════════════════════════════════════════════╗
║  GOLDEN RULE: If XOR, power of 2, or state compression (n≤20) →      ║
║               USE bit manipulation!                                   ║
╚═══════════════════════════════════════════════════════════════════════╝
""")

create_cheat_sheet()

# Interactive testing function
def test_bit_operations():
    """Interactive tester for bit operations"""
    print("\n" + "="*60)
    print("INTERACTIVE BIT MANIPULATION TESTER")
    print("="*60)
    
    operations = {
        "1": ("Check i-th bit", lambda x, i: bool(x & (1 << i))),
        "2": ("Set i-th bit", lambda x, i: x | (1 << i)),
        "3": ("Clear i-th bit", lambda x, i: x & ~(1 << i)),
        "4": ("Toggle i-th bit", lambda x, i: x ^ (1 << i)),
        "5": ("Is power of 2", lambda x, i: x > 0 and (x & (x-1)) == 0),
        "6": ("Count set bits", lambda x, i: bin(x).count('1')),
        "7": ("Rightmost set bit", lambda x, i: x & -x if x else 0),
    }
    
    # Test with example values
    test_values = [(5, 2), (12, 1), (16, 4), (7, 2)]
    
    for x, i in test_values:
        print(f"\nTesting with x={x} ({bin(x)[2:].zfill(8)}), i={i}")
        print("-" * 60)
        for key, (name, func) in operations.items():
            try:
                if "i-th" in name:
                    result = func(x, i)
                    if isinstance(result, bool):
                        print(f"  {key}. {name:20s}: {result}")
                    else:
                        print(f"  {key}. {name:20s}: {result} ({bin(result)[2:].zfill(8)})")
                else:
                    result = func(x, i)
                    if isinstance(result, bool):
                        print(f"  {key}. {name:20s}: {result}")
                    else:
                        print(f"  {key}. {name:20s}: {result}")
            except:
                pass

test_bit_operations()
```

---

## Final Summary

This comprehensive guide covers:

1. **Golden Rules**: Deep understanding of XOR, power of 2 checks, bit isolation, and mask creation
2. **Complexity Analysis**: Time and space trade-offs with detailed examples
3. **Decision Framework**: When to use (and not use) bit manipulation
4. **Common Pitfalls**: Mistakes to avoid with correct implementations
5. **Quick Reference**: Cheat sheet for interview preparation

**Key Takeaway**: Master these patterns and you'll handle any bit manipulation problem in interviews with confidence! The three pillars are:
- **XOR for uniqueness**
- **Bitmask for state (n ≤ 20)**
- **Bit tricks for optimization**

Practice the problems from Chapter 11 using these techniques, and you'll be interview-ready!