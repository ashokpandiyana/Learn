# Chapter 11: Practice Strategy - Complete In-Depth Guide with Python

This chapter provides a structured learning path from beginner to hard-level bit manipulation problems, with complete explanations and Python implementations.

---

## 11.1 Beginner Level Problems

### Problem 1: Number of 1 Bits (Hamming Weight)

**Problem Statement**: Count the number of set bits (1s) in the binary representation of a number.

**Example**:
```
Input: n = 11 (binary: 1011)
Output: 3
Explanation: There are three '1' bits.
```

**Detailed Explanation**:

The binary representation of 11 is `1011`, which has three 1s. We need to count them efficiently.

**Approach 1: Check Each Bit (Naive)**
```python
def hammingWeight_naive(n):
    """
    Check each bit from right to left
    Time: O(32) = O(1) for 32-bit integer
    Space: O(1)
    """
    count = 0
    while n:
        if n & 1:  # Check if rightmost bit is 1
            count += 1
        n >>= 1    # Right shift to check next bit
    return count

# Test
print(hammingWeight_naive(11))  # Output: 3
print(hammingWeight_naive(128)) # Output: 1 (10000000)
print(hammingWeight_naive(255)) # Output: 8 (11111111)
```

**How it works**:
- `n & 1` checks if the rightmost bit is 1 (AND with 00...001)
- `n >>= 1` shifts all bits right by 1 position
- Continue until n becomes 0

**Approach 2: Brian Kernighan's Algorithm (Optimal)**
```python
def hammingWeight_optimal(n):
    """
    Turn off rightmost set bit in each iteration
    Time: O(k) where k = number of set bits
    Space: O(1)
    
    Key Insight: n & (n-1) removes the rightmost set bit
    """
    count = 0
    while n:
        n &= (n - 1)  # Remove rightmost set bit
        count += 1
    return count

# Visualization of how n & (n-1) works:
# n     = 1011 (11)
# n-1   = 1010 (10)
# n&n-1 = 1010 (removes rightmost 1)
#
# n     = 1010 (10)
# n-1   = 1001 (9)
# n&n-1 = 1000 (removes rightmost 1)
#
# n     = 1000 (8)
# n-1   = 0111 (7)
# n&n-1 = 0000 (removes rightmost 1)

print(hammingWeight_optimal(11))  # Output: 3
```

**Why `n & (n-1)` removes rightmost set bit**:
```
When you subtract 1 from n:
- All bits after rightmost 1 flip (0→1, 1→0)
- The rightmost 1 becomes 0
- All bits before remain same

Example: n = 10110 (22)
         n-1 = 10101 (21)
         
Rightmost 1 is at position 1 (from right, 0-indexed)
After n-1: that 1 becomes 0, and bit at position 0 flips from 0 to 1

n & (n-1) = 10110 & 10101 = 10100
The rightmost 1 is removed!
```

**Approach 3: Python Built-in**
```python
def hammingWeight_builtin(n):
    """Using Python's built-in function"""
    return bin(n).count('1')

print(hammingWeight_builtin(11))  # Output: 3
```

---

### Problem 2: Power of Two

**Problem Statement**: Determine if a number is a power of 2.

**Example**:
```
Input: n = 16
Output: True (2^4 = 16)

Input: n = 18
Output: False
```

**Detailed Explanation**:

Powers of 2 have exactly ONE set bit in binary:
```
1   = 0001 (2^0)
2   = 0010 (2^1)
4   = 0100 (2^2)
8   = 1000 (2^3)
16  = 10000 (2^4)
```

Non-powers of 2 have multiple set bits:
```
3   = 0011 (2 set bits)
5   = 0101 (2 set bits)
6   = 0110 (2 set bits)
18  = 10010 (2 set bits)
```

**Solution**:
```python
def isPowerOfTwo(n):
    """
    Check if n is power of 2
    
    Key Insight: Power of 2 has exactly one set bit
    So n & (n-1) should be 0 (removing the only set bit makes it 0)
    
    Time: O(1)
    Space: O(1)
    """
    if n <= 0:
        return False
    
    return (n & (n - 1)) == 0

# Detailed visualization:
# n = 16 (10000)
# n-1 = 15 (01111)
# n & (n-1) = 10000 & 01111 = 00000 = 0 ✓
#
# n = 18 (10010)
# n-1 = 17 (10001)
# n & (n-1) = 10010 & 10001 = 10000 ≠ 0 ✗

print(isPowerOfTwo(16))   # True
print(isPowerOfTwo(18))   # False
print(isPowerOfTwo(1))    # True (2^0)
print(isPowerOfTwo(0))    # False (edge case)
```

**Why this works**:
```
For power of 2 (one set bit):
n     = 100...000
n-1   = 011...111
n&n-1 = 000...000 = 0

For non-power of 2 (multiple set bits):
n     = 10110
n-1   = 10101
n&n-1 = 10100 ≠ 0 (still has set bits)
```

**Alternative approach** (less elegant):
```python
def isPowerOfTwo_alternative(n):
    """Count set bits - should be exactly 1"""
    if n <= 0:
        return False
    return bin(n).count('1') == 1
```

---

### Problem 3: Reverse Bits

**Problem Statement**: Reverse the bits of a 32-bit unsigned integer.

**Example**:
```
Input:  n = 00000010100101000001111010011100
Output:    00111001011110000010100101000000
```

**Detailed Explanation**:

We need to reverse the bit order - the first bit becomes last, second becomes second-to-last, etc.

**Solution**:
```python
def reverseBits(n):
    """
    Reverse bits of a 32-bit unsigned integer
    
    Approach: Extract each bit from right, add it to result from left
    
    Time: O(32) = O(1)
    Space: O(1)
    """
    result = 0
    for i in range(32):
        # Extract rightmost bit of n
        bit = n & 1
        
        # Shift result left to make room
        result = result << 1
        
        # Add the extracted bit
        result = result | bit
        
        # Move to next bit in n
        n = n >> 1
    
    return result

# Detailed step-by-step for n = 5 (00000101 in 8-bit for simplicity):
# Initial: result = 0, n = 5 (00000101)
# 
# i=0: bit=1, result=(0<<1)|1=1     (00000001), n=2 (00000010)
# i=1: bit=0, result=(1<<1)|0=2     (00000010), n=1 (00000001)
# i=2: bit=1, result=(2<<1)|1=5     (00000101), n=0 (00000000)
# i=3: bit=0, result=(5<<1)|0=10    (00001010), n=0
# i=4: bit=0, result=(10<<1)|0=20   (00010100), n=0
# i=5: bit=0, result=(20<<1)|0=40   (00101000), n=0
# i=6: bit=0, result=(40<<1)|0=80   (01010000), n=0
# i=7: bit=0, result=(80<<1)|0=160  (10100000), n=0
#
# Original: 00000101 → Reversed: 10100000 ✓

# Test
print(bin(reverseBits(5)))  # For 32-bit, 5 becomes large number

# More visual example:
def reverseBits_visual(n, bits=8):
    """Reverse bits with visualization (use bits=32 for full)"""
    result = 0
    print(f"Original: {bin(n)[2:].zfill(bits)}")
    
    for i in range(bits):
        bit = n & 1
        result = (result << 1) | bit
        n >>= 1
        print(f"Step {i+1}: result={bin(result)[2:].zfill(i+1)}, n={bin(n)[2:].zfill(bits-i-1) if n else '0'}")
    
    print(f"Reversed: {bin(result)[2:].zfill(bits)}")
    return result

reverseBits_visual(5, 8)
```

**Optimized Approach - Divide and Conquer**:
```python
def reverseBits_optimized(n):
    """
    Reverse using divide and conquer
    Swap pairs, then nibbles, then bytes, then 16-bit chunks
    
    Time: O(1) - only 5 operations regardless of n
    Space: O(1)
    """
    # Swap every two bits
    n = ((n & 0xAAAAAAAA) >> 1) | ((n & 0x55555555) << 1)
    
    # Swap every two 2-bit groups (nibbles)
    n = ((n & 0xCCCCCCCC) >> 2) | ((n & 0x33333333) << 2)
    
    # Swap every two nibbles (bytes)
    n = ((n & 0xF0F0F0F0) >> 4) | ((n & 0x0F0F0F0F) << 4)
    
    # Swap bytes in each 16-bit chunk
    n = ((n & 0xFF00FF00) >> 8) | ((n & 0x00FF00FF) << 8)
    
    # Swap 16-bit chunks
    n = (n >> 16) | ((n & 0xFFFF) << 16)
    
    return n

# Explanation of masks:
# 0xAAAAAAAA = 10101010... (all odd positions)
# 0x55555555 = 01010101... (all even positions)
# 0xCCCCCCCC = 11001100... (alternating 2-bit groups)
# 0x33333333 = 00110011... (alternating 2-bit groups)
```

---

### Problem 4: Single Number

**Problem Statement**: Given an array where every element appears twice except one, find that single element.

**Example**:
```
Input: [4, 1, 2, 1, 2]
Output: 4
```

**Detailed Explanation**:

This is the classic XOR problem. XOR has a magical property:
- `a ^ a = 0` (any number XOR with itself is 0)
- `a ^ 0 = a` (any number XOR with 0 is itself)
- XOR is commutative and associative

**Solution**:
```python
def singleNumber(nums):
    """
    Find the single number using XOR
    
    Key Insight: All pairs cancel out due to XOR properties
    
    Time: O(n)
    Space: O(1)
    """
    result = 0
    for num in nums:
        result ^= num
    return result

# Detailed trace for [4, 1, 2, 1, 2]:
# result = 0
# result ^= 4  →  result = 0 ^ 4 = 4
# result ^= 1  →  result = 4 ^ 1 = 5
# result ^= 2  →  result = 5 ^ 2 = 7
# result ^= 1  →  result = 7 ^ 1 = 6  (the first 1 and this 1 will cancel)
# result ^= 2  →  result = 6 ^ 2 = 4  (the first 2 and this 2 will cancel)
#
# In reality, due to associativity:
# 4 ^ 1 ^ 2 ^ 1 ^ 2 = 4 ^ (1 ^ 1) ^ (2 ^ 2) = 4 ^ 0 ^ 0 = 4

print(singleNumber([4, 1, 2, 1, 2]))  # Output: 4
print(singleNumber([2, 2, 1]))        # Output: 1
print(singleNumber([1]))              # Output: 1

# Visualization with binary:
def singleNumber_visual(nums):
    """Show XOR step by step"""
    result = 0
    print("XOR Process:")
    for i, num in enumerate(nums):
        old_result = result
        result ^= num
        print(f"Step {i+1}: {old_result:04b} ^ {num:04b} = {result:04b} ({result})")
    return result

print("\nVisualization:")
singleNumber_visual([4, 1, 2, 1, 2])
```

**Why XOR works**:
```
Properties used:
1. a ^ a = 0  (self-cancellation)
2. a ^ 0 = a  (identity)
3. Commutative: a ^ b = b ^ a
4. Associative: (a ^ b) ^ c = a ^ (b ^ c)

For [4, 1, 2, 1, 2]:
= 4 ^ 1 ^ 2 ^ 1 ^ 2
= 4 ^ (1 ^ 1) ^ (2 ^ 2)  [rearrange using commutativity]
= 4 ^ 0 ^ 0               [apply a ^ a = 0]
= 4                        [apply a ^ 0 = a]
```

---

### Problem 5: Counting Bits

**Problem Statement**: Given a number n, return an array where arr[i] is the number of 1's in binary representation of i.

**Example**:
```
Input: n = 5
Output: [0, 1, 1, 2, 1, 2]
Explanation:
0 → 0000 → 0 ones
1 → 0001 → 1 one
2 → 0010 → 1 one
3 → 0011 → 2 ones
4 → 0100 → 1 one
5 → 0101 → 2 ones
```

**Detailed Explanation**:

We could count bits for each number independently, but there's a pattern!

**Pattern Discovery**:
```
i    Binary  Count  Observation
0    0000    0      Base case
1    0001    1      Base case
2    0010    1      count[2] = count[2>>1] + (2&1) = count[1] + 0 = 1
3    0011    2      count[3] = count[3>>1] + (3&1) = count[1] + 1 = 2
4    0100    1      count[4] = count[4>>1] + (4&1) = count[2] + 0 = 1
5    0101    2      count[5] = count[5>>1] + (5&1) = count[2] + 1 = 2
6    0110    2      count[6] = count[6>>1] + (6&1) = count[3] + 0 = 2
7    0111    3      count[7] = count[7>>1] + (7&1) = count[3] + 1 = 3
```

**Key Insight**: `count[i] = count[i >> 1] + (i & 1)`
- `i >> 1` removes the rightmost bit
- `i & 1` tells us if rightmost bit is 1
- Count of i = count of (i without rightmost bit) + rightmost bit

**Solution**:
```python
def countBits(n):
    """
    Count set bits for all numbers from 0 to n
    
    Approach: Dynamic Programming using bit manipulation
    count[i] = count[i >> 1] + (i & 1)
    
    Time: O(n)
    Space: O(n) for output
    """
    result = [0] * (n + 1)
    
    for i in range(1, n + 1):
        # i >> 1 is i with rightmost bit removed
        # i & 1 is the rightmost bit
        result[i] = result[i >> 1] + (i & 1)
    
    return result

# Detailed trace for n = 5:
print(countBits(5))  # [0, 1, 1, 2, 1, 2]

# Step-by-step:
def countBits_visual(n):
    """Visualize the DP process"""
    result = [0] * (n + 1)
    
    print(f"{'i':<3} {'Binary':<8} {'i>>1':<5} {'result[i>>1]':<13} {'i&1':<5} {'result[i]':<10}")
    print("-" * 60)
    
    for i in range(n + 1):
        if i == 0:
            print(f"{i:<3} {bin(i)[2:].zfill(4):<8} {'-':<5} {'-':<13} {'-':<5} {result[i]:<10}")
        else:
            parent = i >> 1
            bit = i & 1
            result[i] = result[parent] + bit
            print(f"{i:<3} {bin(i)[2:].zfill(4):<8} {parent:<5} {result[parent]:<13} {bit:<5} {result[i]:<10}")
    
    return result

print("\nVisualization:")
countBits_visual(5)
```

**Alternative Approach - Using n & (n-1)**:
```python
def countBits_alternative(n):
    """
    Using the pattern: count[i] = count[i & (i-1)] + 1
    
    i & (i-1) removes the rightmost set bit
    So count[i] = count[number with one less set bit] + 1
    """
    result = [0] * (n + 1)
    
    for i in range(1, n + 1):
        result[i] = result[i & (i - 1)] + 1
    
    return result

print(countBits_alternative(5))  # [0, 1, 1, 2, 1, 2]
```

---

## 11.2 Intermediate Level Problems

### Problem 6: Single Number II

**Problem Statement**: Given an array where every element appears three times except one, find that single element.

**Example**:
```
Input: [2, 2, 3, 2]
Output: 3
```

**Detailed Explanation**:

XOR won't work here because `a ^ a ^ a = a` (not 0). We need a different approach.

**Approach: Bit Counting Modulo 3**

Count how many times each bit position appears across all numbers. If a bit appears a number of times not divisible by 3, it must belong to the single number.

```python
def singleNumber2_approach1(nums):
    """
    Count each bit position across all numbers
    If count % 3 != 0, that bit belongs to single number
    
    Time: O(32n) = O(n)
    Space: O(1)
    """
    result = 0
    
    # Check each bit position (0 to 31 for 32-bit integers)
    for i in range(32):
        bit_count = 0
        
        # Count how many numbers have bit i set
        for num in nums:
            if num & (1 << i):
                bit_count += 1
        
        # If count is not divisible by 3, set this bit in result
        if bit_count % 3 != 0:
            result |= (1 << i)
    
    return result

# Example: [2, 2, 3, 2]
# Binary representations:
# 2 = 010
# 2 = 010
# 3 = 011
# 2 = 010
#
# Bit 0 (rightmost): appears 1 time (only in 3) → 1 % 3 = 1 → set
# Bit 1: appears 4 times (in all numbers) → 4 % 3 = 1 → set
# Bit 2: appears 0 times → 0 % 3 = 0 → not set
#
# Result: 011 = 3 ✓

print(singleNumber2_approach1([2, 2, 3, 2]))  # Output: 3
```

**Optimized Approach: State Machine**

Use two variables to track bits that appear once and twice:
```python
def singleNumber2_optimized(nums):
    """
    Use two variables: ones and twos
    - ones: tracks bits that appeared 1 time
    - twos: tracks bits that appeared 2 times
    - When a bit appears 3 times, remove it from both
    
    Time: O(n)
    Space: O(1)
    """
    ones = 0  # Bits that appeared 1 time (mod 3)
    twos = 0  # Bits that appeared 2 times (mod 3)
    
    for num in nums:
        # Add to twos if bit is already in ones
        twos |= ones & num
        
        # Add to ones (XOR because if already in ones, remove it)
        ones ^= num
        
        # Remove bits that appeared 3 times (in both ones and twos)
        threes = ones & twos
        ones &= ~threes
        twos &= ~threes
    
    return ones

# Detailed trace for [2, 2, 3, 2]:
def singleNumber2_visual(nums):
    """Visualize the state machine"""
    ones = 0
    twos = 0
    
    print(f"{'Num':<5} {'Binary':<8} {'ones':<15} {'twos':<15}")
    print("-" * 50)
    
    for num in nums:
        old_ones, old_twos = ones, twos
        
        twos |= ones & num
        ones ^= num
        threes = ones & twos
        ones &= ~threes
        twos &= ~threes
        
        print(f"{num:<5} {bin(num)[2:].zfill(3):<8} {bin(ones)[2:].zfill(3):<6}({ones:<2})   {bin(twos)[2:].zfill(3):<6}({twos:<2})")
    
    print(f"\nFinal ones: {ones} (this is our answer)")
    return ones

print("\nVisualization:")
singleNumber2_visual([2, 2, 3, 2])
```

**State Machine Explanation**:
```
For each number:
1. If bit is in ones and we see it again → move to twos
2. XOR with ones (add if not there, remove if there)
3. Find bits in both ones and twos (appeared 3 times)
4. Remove those bits from both ones and twos

State transitions for bit:
0 → see bit → 1 (in ones)
1 → see bit → 2 (in twos, removed from ones)
2 → see bit → 0 (removed from both)
```

---

### Problem 7: Single Number III

**Problem Statement**: Given an array where every element appears twice except two, find those two elements.

**Example**:
```
Input: [1, 2, 1, 3, 2, 5]
Output: [3, 5]
```

**Detailed Explanation**:

Let's call the two unique numbers `a` and `b`.

**Step 1**: XOR all numbers → `xor = a ^ b`
- All pairs cancel out, leaving `a ^ b`

**Step 2**: Find a bit where `a` and `b` differ
- `a ^ b` has set bits where `a` and `b` differ
- Find any set bit (usually rightmost): `rightmost_bit = xor & (-xor)`

**Step 3**: Partition array based on this bit
- Group 1: numbers with this bit set (contains `a`)
- Group 2: numbers with this bit clear (contains `b`)

**Step 4**: XOR each group separately
- All pairs in each group cancel out
- Group 1 result = `a`, Group 2 result = `b`

```python
def singleNumber3(nums):
    """
    Find two numbers that appear once
    
    Approach:
    1. XOR all → get a ^ b
    2. Find differing bit
    3. Partition and XOR groups
    
    Time: O(n)
    Space: O(1)
    """
    # Step 1: XOR all numbers
    xor = 0
    for num in nums:
        xor ^= num
    # Now xor = a ^ b
    
    # Step 2: Find rightmost set bit (any set bit works)
    # This bit differs in a and b
    rightmost_bit = xor & (-xor)
    
    # Step 3 & 4: Partition and XOR
    a, b = 0, 0
    for num in nums:
        if num & rightmost_bit:
            a ^= num  # Group 1
        else:
            b ^= num  # Group 2
    
    return [a, b]

# Detailed example: [1, 2, 1, 3, 2, 5]
print(singleNumber3([1, 2, 1, 3, 2, 5]))  # [3, 5] or [5, 3]

# Visualization:
def singleNumber3_visual(nums):
    """Show the algorithm step by step"""
    print(f"Input: {nums}\n")
    
    # Step 1
    xor = 0
    print("Step 1: XOR all numbers")
    for num in nums:
        old_xor = xor
        xor ^= num
        print(f"  {old_xor:04b} ^ {num:04b} = {xor:04b} ({xor})")
    
    print(f"\nXOR result: {xor} = {bin(xor)[2:].zfill(4)}")
    print(f"This is a ^ b where a and b are the two unique numbers\n")
    
    # Step 2
    rightmost_bit = xor & (-xor)
    print(f"Step 2: Find rightmost set bit")
    print(f"  xor     = {bin(xor)[2:].zfill(4)} ({xor})")
    print(f"  -xor    = {bin(-xor & 0xFFFF)[2:].zfill(4)}")
    print(f"  rightmost_bit = {bin(rightmost_bit)[2:].zfill(4)} ({rightmost_bit})")
    print(f"  (This bit differs between a and b)\n")
    
    # Step 3
    print("Step 3: Partition based on this bit")
    group1, group2 = [], []
    for num in nums:
        if num & rightmost_bit:
            group1.append(num)
        else:
            group2.append(num)
    
    print(f"  Group 1 (bit set):   {group1}")
    print(f"  Group 2 (bit clear): {group2}\n")
    
    # Step 4
    print("Step 4: XOR each group")
    a, b = 0, 0
    
    print("  Group 1:")
    for num in group1:
        old_a = a
        a ^= num
        print(f"    {old_a:04b} ^ {num:04b} = {a:04b} ({a})")
    
    print(f"  Result for group 1: {a}\n")
    
    print("  Group 2:")
    for num in group2:
        old_b = b
        b ^= num
        print(f"    {old_b:04b} ^ {num:04b} = {b:04b} ({b})")
    
    print(f"  Result for group 2: {b}\n")
    
    print(f"Final answer: [{a}, {b}]")
    return [a, b]

print("\nDetailed visualization:")
singleNumber3_visual([1, 2, 1, 3, 2, 5])
```

**Why the partition works**:
```
Let's say a = 3 (011) and b = 5 (101)
a ^ b = 110 (6)

Rightmost set bit = 010 (bit position 1)

This bit is:
- SET in 3 (011) ✓
- CLEAR in 5 (101) ✗

So a and b will be in different groups!

Numbers with bit 1 set: [1(001), 1(001), 3(011)] → XOR = 3
Numbers with bit 1 clear: [2(010), 2(010), 5(101)] → XOR = 5
```

---

(Continuing in next section due to length...)

## 11.3 Advanced Level Problems

### Problem 8: Bitwise AND of Numbers Range

**Problem Statement**: Given two integers left and right representing a range [left, right], return the bitwise AND of all numbers in this range.

**Example**:
```
Input: left = 5, right = 7
Output: 4

Explanation:
5 = 101
6 = 110
7 = 111
AND = 100 = 4
```

**Detailed Explanation**:

**Naive Approach** (Time Limit Exceeded for large ranges):
```python
def rangeBitwiseAnd_naive(left, right):
    """
    AND all numbers in range - TOO SLOW for large ranges
    Time: O(right - left)
    """
    result = left
    for num in range(left + 1, right + 1):
        result &= num
    return result
```

**Key Insight**: 
When we AND consecutive numbers, lower bits become 0 quickly. We only care about common prefix of left and right in binary.

**Example**:
```
left  = 5 = 0101
right = 7 = 0111

As we AND numbers 5, 6, 7:
5 & 6 = 0101 & 0110 = 0100
0100 & 7 = 0100 & 0111 = 0100

Notice: The result is the common prefix (01) followed by zeros.
```

**Optimized Solution - Find Common Prefix**:
```python
def rangeBitwiseAnd_optimal(left, right):
    """
    Find common prefix of left and right
    
    Approach: Right shift both until they're equal
    That's the common prefix. Then shift back.
    
    Time: O(log n) where n is the number of bits
    Space: O(1)
    """
    shift = 0
    
    # Find common prefix by right-shifting
    while left < right:
        left >>= 1
        right >>= 1
        shift += 1
    
    # Shift back to get the result
    return left << shift

# Visualization:
def rangeBitwiseAnd_visual(left, right):
    """Show the algorithm step by step"""
    print(f"Finding AND of range [{left}, {right}]\n")
    
    original_left, original_right = left, right
    shift = 0
    
    print(f"{'Step':<6} {'left':<8} {'right':<8} {'left_bin':<10} {'right_bin':<10}")
    print("-" * 50)
    print(f"{'Start':<6} {left:<8} {right:<8} {bin(left)[2:].zfill(8):<10} {bin(right)[2:].zfill(8):<10}")
    
    while left < right:
        left >>= 1
        right >>= 1
        shift += 1
        print(f"{shift:<6} {left:<8} {right:<8} {bin(left)[2:].zfill(8):<10} {bin(right)[2:].zfill(8):<10}")
    
    result = left << shift
    print(f"\nCommon prefix found: {left} = {bin(left)[2:]}")
    print(f"Shift back by {shift}: {result} = {bin(result)[2:].zfill(8)}")
    print(f"\nAnswer: {result}")
    
    # Verify by actual AND
    print(f"\nVerification:")
    actual = original_left
    for num in range(original_left, min(original_right + 1, original_left + 10)):
        print(f"  {num:3d} = {bin(num)[2:].zfill(8)}")
        if num > original_left:
            actual &= num
    if original_right - original_left < 10:
        print(f"  AND = {bin(actual)[2:].zfill(8)} = {actual}")
    
    return result

print(rangeBitwiseAnd_visual(5, 7))
print("\n" + "="*50 + "\n")
print(rangeBitwiseAnd_visual(26, 30))
```

**Why it works**:
```
When we AND consecutive numbers:
- Any bit position that changes (0→1 or 1→0) will become 0
- Only bits that remain constant across the range stay set
- The common prefix is exactly those constant bits

Example: [26, 30]
26 = 11010
27 = 11011
28 = 11100
29 = 11101
30 = 11110

Common prefix: 11 (bits 4 and 3)
All lower bits change, so they become 0
Result: 11000 = 24
```

---

### Problem 9: Maximum XOR of Two Numbers in Array

**Problem Statement**: Find the maximum XOR of any two numbers in an array.

**Example**:
```
Input: [3, 10, 5, 25, 2, 8]
Output: 28
Explanation: 5 ^ 25 = 28 (maximum)
```

**Detailed Explanation**:

**Naive Approach** (O(n²)):
```python
def findMaximumXOR_naive(nums):
    """Check all pairs - TOO SLOW"""
    max_xor = 0
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            max_xor = max(max_xor, nums[i] ^ nums[j])
    return max_xor
```

**Optimized Approach - Bitwise Trie**:

Build a binary trie and for each number, try to find a path that maximizes XOR by choosing opposite bits.

```python
class TrieNode:
    def __init__(self):
        self.children = {}  # 0 or 1

class Solution:
    def findMaximumXOR(self, nums):
        """
        Use Trie to find maximum XOR
        
        Approach:
        1. Insert all numbers into trie (bit by bit from MSB)
        2. For each number, traverse trie choosing opposite bits
        
        Time: O(32n) = O(n)
        Space: O(32n) = O(n)
        """
        root = TrieNode()
        
        # Build trie
        for num in nums:
            node = root
            for i in range(31, -1, -1):
                bit = (num >> i) & 1
                if bit not in node.children:
                    node.children[bit] = TrieNode()
                node = node.children[bit]
        
        max_xor = 0
        
        # For each number, find maximum XOR
        for num in nums:
            node = root
            current_xor = 0
            
            for i in range(31, -1, -1):
                bit = (num >> i) & 1
                # Try to go opposite direction for maximum XOR
                toggle_bit = 1 - bit
                
                if toggle_bit in node.children:
                    current_xor |= (1 << i)
                    node = node.children[toggle_bit]
                else:
                    node = node.children[bit]
            
            max_xor = max(max_xor, current_xor)
        
        return max_xor

# Visualization:
def findMaximumXOR_visual(nums):
    """Show trie construction and XOR finding"""
    print(f"Numbers: {nums}\n")
    
    # Show binary representations
    print("Binary representations (8-bit for simplicity):")
    for num in nums:
        print(f"  {num:3d} = {bin(num)[2:].zfill(8)}")
    
    print("\nBuilding Trie...")
    sol = Solution()
    result = sol.findMaximumXOR(nums)
    
    print(f"\nMaximum XOR: {result}")
    
    # Find which pair gives maximum
    max_xor = 0
    pair = (0, 0)
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            xor_val = nums[i] ^ nums[j]
            if xor_val > max_xor:
                max_xor = xor_val
                pair = (nums[i], nums[j])
    
    print(f"Achieved by: {pair[0]} ^ {pair[1]}")
    print(f"  {pair[0]:3d} = {bin(pair[0])[2:].zfill(8)}")
    print(f"  {pair[1]:3d} = {bin(pair[1])[2:].zfill(8)}")
    print(f"  XOR = {bin(max_xor)[2:].zfill(8)} = {max_xor}")
    
    return result

findMaximumXOR_visual([3, 10, 5, 25, 2, 8])
```

**How Bitwise Trie Works**:
```
For [3, 10, 5]:
3  = 0011
10 = 1010
5  = 0101

Trie structure (from MSB to LSB):
        root
       /    \
      0      1
     / \      \
    0   1      0
   / \   \      \
  1   0   0      1
 /     \   \      \
1       1   1      0

To maximize XOR for 3 (0011):
- Start at root, 3 has 0 at bit 3 → want to go to 1 (found!)
- At 1, 3 has 0 at bit 2 → want to go to 1 (not found, go to 0)
- At 0, 3 has 1 at bit 1 → want to go to 0 (found!)
- At 0, 3 has 1 at bit 0 → want to go to 0 (found!)

Path taken represents: 1010 = 10
3 ^ 10 = 0011 ^ 1010 = 1001 = 9
```

---

## 11.4 Hard Level Problems

### Problem 10: Shortest Path Visiting All Nodes (Bitmask BFS)

**Problem Statement**: Given an undirected graph, return the length of shortest path that visits every node at least once.

**Example**:
```
Graph: 0 -- 1 -- 2
           |
           3

Output: 4
Path: 0 → 1 → 3 → 1 → 2 or similar
```

**Detailed Explanation**:

Use bitmask to represent visited nodes state + BFS for shortest path.

```python
from collections import deque

def shortestPathLength(graph):
    """
    BFS with state = (node, visited_mask)
    
    visited_mask: bit i is 1 if node i has been visited
    Goal: reach state where all bits are set
    
    Time: O(2^n * n^2) where n is number of nodes
    Space: O(2^n * n)
    """
    n = len(graph)
    target = (1 << n) - 1  # All bits set
    
    # State: (node, mask, distance)
    # Start from all nodes simultaneously
    queue = deque()
    seen = set()
    
    for i in range(n):
        mask = 1 << i  # Only node i visited
        queue.append((i, mask, 0))
        seen.add((i, mask))
    
    while queue:
        node, mask, dist = queue.popleft()
        
        # If all nodes visited
        if mask == target:
            return dist
        
        # Explore neighbors
        for neighbor in graph[node]:
            new_mask = mask | (1 << neighbor)  # Mark neighbor as visited
            
            if (neighbor, new_mask) not in seen:
                seen.add((neighbor, new_mask))
                queue.append((neighbor, new_mask, dist + 1))
    
    return -1  # Should never reach here for valid input

# Visualization:
def shortestPathLength_visual(graph):
    """Show BFS exploration with bitmasks"""
    n = len(graph)
    target = (1 << n) - 1
    
    print(f"Graph: {graph}")
    print(f"Number of nodes: {n}")
    print(f"Target mask (all visited): {bin(target)[2:].zfill(n)} = {target}\n")
    
    queue = deque()
    seen = set()
    
    print("Initial states (start from each node):")
    for i in range(n):
        mask = 1 << i
        queue.append((i, mask, 0))
        seen.add((i, mask))
        print(f"  Node {i}: mask = {bin(mask)[2:].zfill(n)}")
    
    print("\nBFS Exploration:")
    step = 0
    while queue and step < 20:  # Limit steps for visualization
        node, mask, dist = queue.popleft()
        
        print(f"Step {step}: Node {node}, Mask {bin(mask)[2:].zfill(n)}, Dist {dist}")
        
        if mask == target:
            print(f"\n✓ All nodes visited! Distance: {dist}")
            return dist
        
        for neighbor in graph[node]:
            new_mask = mask | (1 << neighbor)
            
            if (neighbor, new_mask) not in seen:
                seen.add((neighbor, new_mask))
                queue.append((neighbor, new_mask, dist + 1))
                print(f"  → Neighbor {neighbor}, New mask {bin(new_mask)[2:].zfill(n)}")
        
        step += 1
    
    return -1

# Example graph: 0 -- 1 -- 2, 1 -- 3
graph = [[1], [0, 2, 3], [1], [1]]
shortestPathLength_visual(graph)
```

**Key Concepts**:
```
Bitmask represents state:
- n = 4 nodes → 4 bits
- Mask 1010 means nodes 1 and 3 have been visited
- Target = 1111 (all nodes visited)

State space:
- Each state = (current_node, visited_mask)
- Total states = n * 2^n
- Use BFS to find shortest path to target state

Why start from all nodes?
- Optimal path might not start from node 0
- Starting from all nodes ensures we find shortest path
```

---

This completes the Intermediate and Advanced sections. The Hard-level problems demonstrate complex applications of bit manipulation with dynamic programming and graph algorithms. Would you like me to continue with more hard problems or move to Chapter 12?