# Chapter 6: Bit Manipulation in Common Data Structures - In-Depth Explanation

## Overview
This chapter explores how bit manipulation powers several efficient data structures. Understanding these implementations provides insights into both bit operations and advanced data structure design.

---

## 6.1 Bitset - Compact Boolean Storage

### The Problem
Storing n boolean values using arrays wastes space:
- Each boolean typically uses 1 byte (8 bits)
- For 1 million booleans: 1 MB of memory

**Bitset Solution**: Use individual bits!
- 1 bit per boolean
- For 1 million booleans: ~125 KB (8x improvement!)

---

### Implementation from Scratch

```python
class Bitset:
    """
    A compact bit array implementation
    Uses integers to store bits efficiently
    """
    
    def __init__(self, size):
        """
        Initialize bitset of given size
        Uses list of integers (each stores 32 bits)
        """
        self.size = size
        # Number of integers needed
        self.num_ints = (size + 31) // 32
        self.bits = [0] * self.num_ints
    
    def set(self, pos):
        """
        Set bit at position pos to 1
        Time: O(1)
        """
        if pos < 0 or pos >= self.size:
            raise IndexError("Position out of range")
        
        int_index = pos // 32      # Which integer?
        bit_offset = pos % 32      # Which bit in that integer?
        
        # Set the bit using OR
        self.bits[int_index] |= (1 << bit_offset)
    
    def clear(self, pos):
        """
        Set bit at position pos to 0
        Time: O(1)
        """
        if pos < 0 or pos >= self.size:
            raise IndexError("Position out of range")
        
        int_index = pos // 32
        bit_offset = pos % 32
        
        # Clear the bit using AND with complement
        self.bits[int_index] &= ~(1 << bit_offset)
    
    def test(self, pos):
        """
        Check if bit at position pos is set
        Time: O(1)
        """
        if pos < 0 or pos >= self.size:
            raise IndexError("Position out of range")
        
        int_index = pos // 32
        bit_offset = pos % 32
        
        # Test the bit
        return bool(self.bits[int_index] & (1 << bit_offset))
    
    def flip(self, pos):
        """
        Toggle bit at position pos
        Time: O(1)
        """
        if pos < 0 or pos >= self.size:
            raise IndexError("Position out of range")
        
        int_index = pos // 32
        bit_offset = pos % 32
        
        # Flip the bit using XOR
        self.bits[int_index] ^= (1 << bit_offset)
    
    def count(self):
        """
        Count number of set bits
        Time: O(n/32) where n is size
        """
        total = 0
        for num in self.bits:
            # Count bits in each integer
            while num:
                num &= num - 1  # Kernighan's algorithm
                total += 1
        return total
    
    def any(self):
        """Check if any bit is set"""
        return any(num != 0 for num in self.bits)
    
    def all(self):
        """Check if all bits are set"""
        # Check all complete integers
        for i in range(self.num_ints - 1):
            if self.bits[i] != 0xFFFFFFFF:
                return False
        
        # Check last integer (may be partial)
        remaining_bits = self.size % 32
        if remaining_bits == 0:
            remaining_bits = 32
        
        mask = (1 << remaining_bits) - 1
        return (self.bits[-1] & mask) == mask
    
    def none(self):
        """Check if no bits are set"""
        return not self.any()
    
    def __str__(self):
        """String representation"""
        result = []
        for i in range(self.size):
            result.append('1' if self.test(i) else '0')
        return ''.join(reversed(result))  # MSB first

# Example usage
print("=== Bitset Example ===\n")

bs = Bitset(16)
print(f"Initial (16 bits): {bs}")

# Set some bits
bs.set(0)
bs.set(5)
bs.set(10)
bs.set(15)
print(f"After setting bits 0, 5, 10, 15: {bs}")

# Test bits
print(f"\nBit 5 is set: {bs.test(5)}")
print(f"Bit 7 is set: {bs.test(7)}")

# Flip a bit
bs.flip(5)
print(f"\nAfter flipping bit 5: {bs}")
print(f"Bit 5 is now set: {bs.test(5)}")

# Count set bits
print(f"\nTotal set bits: {bs.count()}")
print(f"Any bits set: {bs.any()}")
print(f"All bits set: {bs.all()}")
```

---

### Visual Representation

```
Bitset of size 100 (requires 4 integers of 32 bits each)

Position:  0-31        32-63       64-95       96-99
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
bits[0]: ‚îÇxxxxxxxx...‚îÇ
bits[1]: ‚îÇ           ‚îÇxxxxxxxx...‚îÇ
bits[2]: ‚îÇ           ‚îÇ           ‚îÇxxxxxxxx...‚îÇ
bits[3]: ‚îÇ           ‚îÇ           ‚îÇ           ‚îÇxxxx    ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Each 'x' represents a bit (0 or 1)

Example: To access bit 50
- int_index = 50 // 32 = 1      (second integer)
- bit_offset = 50 % 32 = 18     (19th bit in that integer)
- Access: bits[1] & (1 << 18)
```

---

### Applications of Bitset

```python
def sieve_of_eratosthenes(n):
    """
    Find all primes up to n using bitset
    Memory efficient prime sieve
    """
    is_prime = Bitset(n + 1)
    
    # Initially assume all are prime
    for i in range(2, n + 1):
        is_prime.set(i)
    
    # Sieve
    for i in range(2, int(n**0.5) + 1):
        if is_prime.test(i):
            # Mark multiples as not prime
            for j in range(i * i, n + 1, i):
                is_prime.clear(j)
    
    # Collect primes
    primes = [i for i in range(2, n + 1) if is_prime.test(i)]
    return primes

# Example
primes = sieve_of_eratosthenes(50)
print(f"\nPrimes up to 50: {primes}")

# Memory comparison
print(f"\nMemory comparison for 1,000,000 booleans:")
print(f"Boolean array: ~1,000,000 bytes (1 MB)")
print(f"Bitset: ~125,000 bytes (125 KB)")
print(f"Savings: 8x less memory!")
```

---

## 6.2 Bloom Filter - Probabilistic Set Membership

### The Concept

A **Bloom Filter** is a space-efficient probabilistic data structure that tests whether an element is in a set.

**Key Properties**:
- ‚úÖ Can definitively say "definitely not in set"
- ‚ö†Ô∏è Can say "probably in set" (false positives possible)
- ‚ùå No false negatives (won't miss actual members)
- üöÄ Extremely space-efficient

---

### How It Works

```
1. Create a bit array of size m (all 0s)
2. Use k different hash functions
3. Add element:
   - Compute k hash values
   - Set all k corresponding bits to 1
4. Query element:
   - Compute k hash values
   - Check if all k bits are set
   - If any is 0 ‚Üí definitely NOT in set
   - If all are 1 ‚Üí probably in set
```

#### Visual Example

```
Bit array (size 16):
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

Add "apple":
hash1("apple") = 3  ‚Üí set bit 3
hash2("apple") = 7  ‚Üí set bit 7
hash3("apple") = 11 ‚Üí set bit 11

[0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0]
          ‚Üë           ‚Üë           ‚Üë

Add "banana":
hash1("banana") = 5  ‚Üí set bit 5
hash2("banana") = 7  ‚Üí set bit 7 (already set!)
hash3("banana") = 13 ‚Üí set bit 13

[0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0]
          ‚Üë       ‚Üë   ‚Üë           ‚Üë       ‚Üë

Query "apple":
Check bits 3, 7, 11 ‚Üí All set ‚Üí Probably in set ‚úì

Query "cherry":
hash1("cherry") = 2  ‚Üí bit 2 is 0 ‚Üí Definitely NOT in set ‚úì
```

---

### Implementation

```python
import hashlib

class BloomFilter:
    """
    Bloom filter for efficient set membership testing
    """
    
    def __init__(self, size, num_hash_functions):
        """
        size: bit array size
        num_hash_functions: number of hash functions to use
        """
        self.size = size
        self.num_hash = num_hash_functions
        self.bit_array = Bitset(size)
        self.count = 0  # Number of elements added
    
    def _hash(self, item, seed):
        """
        Generate hash value for item with given seed
        """
        # Combine item with seed
        h = hashlib.md5(f"{item}{seed}".encode())
        return int(h.hexdigest(), 16) % self.size
    
    def add(self, item):
        """
        Add item to bloom filter
        Time: O(k) where k is num_hash_functions
        """
        for i in range(self.num_hash):
            index = self._hash(item, i)
            self.bit_array.set(index)
        self.count += 1
    
    def contains(self, item):
        """
        Check if item might be in the set
        Returns:
            True: item might be in set (or false positive)
            False: item is definitely NOT in set
        
        Time: O(k) where k is num_hash_functions
        """
        for i in range(self.num_hash):
            index = self._hash(item, i)
            if not self.bit_array.test(index):
                return False  # Definitely not in set
        return True  # Probably in set
    
    def false_positive_rate(self):
        """
        Estimate false positive probability
        Formula: (1 - e^(-k*n/m))^k
        where k=num_hash, n=count, m=size
        """
        import math
        k = self.num_hash
        n = self.count
        m = self.size
        
        if n == 0:
            return 0.0
        
        return (1 - math.exp(-k * n / m)) ** k

# Example usage
print("\n=== Bloom Filter Example ===\n")

# Create bloom filter
bf = BloomFilter(size=1000, num_hash_functions=3)

# Add elements
words = ["apple", "banana", "cherry", "date", "elderberry"]
for word in words:
    bf.add(word)
    print(f"Added: {word}")

print(f"\nTotal elements added: {bf.count}")
print(f"Estimated false positive rate: {bf.false_positive_rate():.4f}")

# Test membership
test_words = ["apple", "fig", "banana", "grape", "cherry"]
print("\nMembership tests:")
for word in test_words:
    result = bf.contains(word)
    actual = word in words
    status = "‚úì" if result == actual else "‚ö† (false positive)"
    print(f"  {word}: {result} (actual: {actual}) {status}")
```

---

### False Positive Example

```python
def demonstrate_false_positive():
    """
    Show how false positives occur
    """
    bf = BloomFilter(size=20, num_hash_functions=2)
    
    print("=== False Positive Demonstration ===\n")
    
    # Add "cat"
    bf.add("cat")
    print("Added 'cat'")
    
    # Show which bits are set
    print("Hash values for 'cat':")
    for i in range(bf.num_hash):
        h = bf._hash("cat", i)
        print(f"  hash{i}('cat') = {h}")
    
    # Check "dog" - not added!
    print("\nChecking 'dog' (never added):")
    hashes = []
    for i in range(bf.num_hash):
        h = bf._hash("dog", i)
        hashes.append(h)
        is_set = bf.bit_array.test(h)
        print(f"  hash{i}('dog') = {h}, bit is set: {is_set}")
    
    result = bf.contains("dog")
    print(f"\nBloom filter says 'dog' is in set: {result}")
    
    if result:
        print("‚ö† This is a FALSE POSITIVE!")
        print("'dog' was never added, but all its hash positions")
        print("happen to be set by other elements.")

demonstrate_false_positive()
```

---

### Applications of Bloom Filters

```python
class WebCrawler:
    """
    Example: Use Bloom filter to avoid re-visiting URLs
    Saves memory compared to storing all URLs in a set
    """
    
    def __init__(self):
        # For 1 million URLs with 1% false positive rate
        self.visited = BloomFilter(size=10_000_000, num_hash_functions=7)
        self.true_visited = set()  # For comparison
    
    def crawl(self, url):
        """Crawl URL if not visited"""
        if self.visited.contains(url):
            print(f"  Skipping {url} (probably visited)")
            return False
        
        # Crawl the URL
        print(f"  Crawling {url}")
        self.visited.add(url)
        self.true_visited.add(url)
        return True

# Demo
crawler = WebCrawler()
urls = [
    "example.com",
    "test.com",
    "example.com",  # Duplicate
    "hello.com",
    "world.com"
]

print("\n=== Web Crawler with Bloom Filter ===\n")
for url in urls:
    crawler.crawl(url)

print(f"\nTotal unique URLs: {len(crawler.true_visited)}")
print(f"Memory saved: ~{(1 - 10_000_000 / (1_000_000 * 8 * 20)) * 100:.0f}%")
```

---

## 6.3 Fenwick Tree (Binary Indexed Tree)

### The Problem

**Range Sum Queries**: Given array, answer queries:
1. Sum of elements from index L to R
2. Update element at index i

**Naive Approach**:
- Range sum: O(n)
- Update: O(1)

**Prefix Sum Approach**:
- Range sum: O(1)
- Update: O(n) - need to update all prefix sums

**Fenwick Tree**: Both in O(log n)! üéØ

---

### The Bit Manipulation Magic

Fenwick tree uses `i & -i` to isolate the rightmost set bit!

```
Number i     | Binary  | i & -i | Responsibility
-------------|---------|--------|---------------
1            | 0001    | 0001   | [1, 1]
2            | 0010    | 0010   | [1, 2]
3            | 0011    | 0001   | [3, 3]
4            | 0100    | 0100   | [1, 4]
5            | 0101    | 0001   | [5, 5]
6            | 0110    | 0010   | [5, 6]
7            | 0111    | 0001   | [7, 7]
8            | 1000    | 1000   | [1, 8]
```

**Key Insight**: `i & -i` tells us how many elements this node covers!

---

### Visual Structure

```
Array:    [1,  2,  3,  4,  5,  6,  7,  8]
Index:     1   2   3   4   5   6   7   8

Fenwick Tree Structure:

tree[1] = arr[1]                                    (covers 1 element)
tree[2] = arr[1] + arr[2]                          (covers 2 elements)
tree[3] = arr[3]                                    (covers 1 element)
tree[4] = arr[1] + arr[2] + arr[3] + arr[4]       (covers 4 elements)
tree[5] = arr[5]                                    (covers 1 element)
tree[6] = arr[5] + arr[6]                          (covers 2 elements)
tree[7] = arr[7]                                    (covers 1 element)
tree[8] = arr[1] + ... + arr[8]                    (covers 8 elements)

Visual hierarchy:
                    8 (covers [1-8])
                   / \
                  /   \
              4 (covers [1-4])   (implicit)
             / \                  / \
            /   \                /   \
        2 (covers [1-2])    6 (covers [5-6])
       / \                  / \
      /   \                /   \
  1 (covers [1])      3   5    7 (each covers 1)
```

---

### Implementation

```python
class FenwickTree:
    """
    Binary Indexed Tree (Fenwick Tree)
    Efficient range queries and point updates
    """
    
    def __init__(self, n):
        """
        Initialize tree for n elements
        Note: 1-indexed (index 0 unused)
        """
        self.n = n
        self.tree = [0] * (n + 1)
    
    def update(self, index, delta):
        """
        Add delta to element at index
        Time: O(log n)
        """
        # Move to next node in tree
        while index <= self.n:
            self.tree[index] += delta
            # Add rightmost set bit to move up
            index += index & (-index)
    
    def prefix_sum(self, index):
        """
        Get sum of elements from 1 to index
        Time: O(log n)
        """
        result = 0
        # Move to parent node
        while index > 0:
            result += self.tree[index]
            # Remove rightmost set bit to move down
            index -= index & (-index)
        return result
    
    def range_sum(self, left, right):
        """
        Get sum from left to right (inclusive)
        Time: O(log n)
        """
        return self.prefix_sum(right) - self.prefix_sum(left - 1)
    
    def visualize_update_path(self, index):
        """Show which nodes get updated"""
        print(f"\nUpdate path for index {index}:")
        path = []
        i = index
        while i <= self.n:
            path.append(i)
            i += i & (-i)
        print(f"Nodes updated: {path}")
        
        # Show binary representation
        for node in path:
            binary = bin(node)[2:].zfill(8)
            rightmost = node & (-node)
            print(f"  {node:3d} = {binary}, "
                  f"rightmost bit: {bin(rightmost)[2:]}")
    
    def visualize_query_path(self, index):
        """Show which nodes get queried"""
        print(f"\nQuery path for prefix sum up to {index}:")
        path = []
        i = index
        while i > 0:
            path.append(i)
            i -= i & (-i)
        print(f"Nodes queried: {path}")
        
        # Show binary representation
        for node in path:
            binary = bin(node)[2:].zfill(8)
            rightmost = node & (-node)
            print(f"  {node:3d} = {binary}, "
                  f"rightmost bit: {bin(rightmost)[2:]}")

# Example usage
print("=== Fenwick Tree Example ===\n")

# Create tree for 8 elements
ft = FenwickTree(8)

# Build tree from array
arr = [0, 1, 2, 3, 4, 5, 6, 7, 8]  # 1-indexed
print(f"Array (1-indexed): {arr[1:]}")

for i in range(1, 9):
    ft.update(i, arr[i])

print(f"\nFenwick tree: {ft.tree}")

# Query examples
print(f"\nPrefix sum(5) = {ft.prefix_sum(5)}")  # 1+2+3+4+5 = 15
print(f"Range sum(3, 6) = {ft.range_sum(3, 6)}")  # 3+4+5+6 = 18

# Visualize paths
ft.visualize_update_path(5)
ft.visualize_query_path(5)

# Update element
print(f"\nUpdating index 5: add 10")
ft.update(5, 10)
print(f"New prefix sum(5) = {ft.prefix_sum(5)}")  # 15 + 10 = 25
print(f"New range sum(3, 6) = {ft.range_sum(3, 6)}")  # 18 + 10 = 28
```

---

### Why `i & -i` Works

```python
def explain_rightmost_bit():
    """
    Explain how i & -i isolates rightmost set bit
    """
    print("=== Understanding i & -i ===\n")
    
    for i in range(1, 17):
        # Show binary representations
        binary = bin(i)[2:].zfill(8)
        neg_binary = bin(-i & 0xFF)[2:].zfill(8)  # 8-bit for display
        rightmost = i & -i
        result_binary = bin(rightmost)[2:].zfill(8)
        
        print(f"i = {i:2d}:  {binary}")
        print(f"-i     :  {neg_binary}  (two's complement)")
        print(f"i & -i :  {result_binary}  = {rightmost}")
        print()

explain_rightmost_bit()
```

Output shows:
```
i =  5:  00000101
-i     :  11111011  (two's complement)
i & -i :  00000001  = 1  ‚Üê Rightmost set bit isolated!

i =  6:  00000110
-i     :  11111010  (two's complement)
i & -i :  00000010  = 2  ‚Üê Rightmost set bit isolated!
```

---

### Application: Inversion Count

```python
def count_inversions_fenwick(arr):
    """
    Count inversions using Fenwick tree
    Inversion: pair (i, j) where i < j but arr[i] > arr[j]
    
    Time: O(n log n)
    """
    # Coordinate compression
    sorted_arr = sorted(enumerate(arr), key=lambda x: x[1])
    rank = [0] * len(arr)
    for i, (orig_idx, _) in enumerate(sorted_arr):
        rank[orig_idx] = i + 1  # 1-indexed
    
    # Count inversions
    ft = FenwickTree(len(arr))
    inversions = 0
    
    for i, val in enumerate(arr):
        # Count how many larger elements came before
        # (elements with rank > current rank that were already processed)
        inversions += i - ft.prefix_sum(rank[i])
        ft.update(rank[i], 1)
    
    return inversions

# Example
arr = [5, 3, 2, 4, 1]
print(f"\n=== Inversion Count ===")
print(f"Array: {arr}")
print(f"Inversions: {count_inversions_fenwick(arr)}")
# Inversions: (5,3), (5,2), (5,4), (5,1), (3,2), (3,1), (2,1), (4,1) = 8
```

---

## Comparison Summary

| Data Structure | Space | Add/Update | Query | Use Case |
|----------------|-------|------------|-------|----------|
| **Bitset** | O(n/8) | O(1) | O(1) | Boolean flags, prime sieve |
| **Bloom Filter** | O(m) bits | O(k) | O(k) | Membership testing, cache |
| **Fenwick Tree** | O(n) | O(log n) | O(log n) | Range queries, inversions |

Where:
- n = number of elements
- m = bit array size
- k = number of hash functions

---

## Key Bit Operations Used

| Data Structure | Key Bit Operation | Purpose |
|----------------|-------------------|---------|
| Bitset | `x \| (1 << i)` | Set bit i |
| Bitset | `x & ~(1 << i)` | Clear bit i |
| Bitset | `x & (1 << i)` | Test bit i |
| Bloom Filter | Multiple hash & set | Probabilistic membership |
| Fenwick | `i & -i` | Isolate rightmost bit |
| Fenwick | `i + (i & -i)` | Move to parent |
| Fenwick | `i - (i & -i)` | Move to child |

---

## Real-World Applications

### Bitset
- Database indexes
- Image compression
- Network routing tables
- Sudoku solvers
- Graph algorithms (visited tracking)

### Bloom Filter
- Web caching (Squid, Varnish)
- Database query optimization (BigTable, Cassandra)
- Spell checkers
- Bitcoin transaction verification
- Malware detection

### Fenwick Tree
- Competitive programming (range queries)
- Order statistics
- Counting inversions in arrays
- 2D range sum queries
- Frequency analysis

---

## Advanced Topics Preview

### Bitset Advanced
- Bitset operations (AND, OR, XOR between bitsets)
- Fast bitset traversal
- Bitset in graph algorithms

### Bloom Filter Variants
- Counting Bloom Filter (supports deletion)
- Scalable Bloom Filter
- Quotient Filter

### Fenwick Tree Extensions
- 2D Fenwick Tree
- Range update, point query
- Range update, range query

---

## Summary

1. **Bitset**: Use bits instead of bytes - 8x space savings
2. **Bloom Filter**: Probabilistic but extremely space-efficient
3. **Fenwick Tree**: `i & -i` enables O(log n) range queries

All three demonstrate how **bit manipulation unlocks efficient data structure implementations**!

---

## Practice Problems

**Bitset**: 
- Sieve of Eratosthenes
- Sudoku Solver
- Find Missing Number

**Bloom Filter**:
- Design Cache System
- URL Shortener Uniqueness
- Spell Checker

**Fenwick Tree**:
- Range Sum Query (Mutable)
- Count of Smaller Numbers After Self
- Reversible Pairs