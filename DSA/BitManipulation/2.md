# Chapter 2: Basic Bitwise Operators - Deep Dive
## Mastering the Foundation of Bit Manipulation

---

## Overview of Bitwise Operators

Bitwise operators work on individual bits of numbers. They are the building blocks of all bit manipulation techniques.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Operator   â”‚  Symbol  â”‚         Operation              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    AND      â”‚    &     â”‚  Both bits must be 1           â”‚
â”‚    OR       â”‚    |     â”‚  At least one bit is 1         â”‚
â”‚    XOR      â”‚    ^     â”‚  Bits must be different        â”‚
â”‚    NOT      â”‚    ~     â”‚  Flip all bits                 â”‚
â”‚ Left Shift  â”‚    <<    â”‚  Shift bits left, fill with 0  â”‚
â”‚ Right Shift â”‚    >>    â”‚  Shift bits right              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2.1 AND Operator (&)

### How AND Works

The AND operator returns **1** only when **both bits are 1**, otherwise returns **0**.

**Truth Table:**
```
A | B | A & B
--|---|------
0 | 0 |   0
0 | 1 |   0
1 | 0 |   0
1 | 1 |   1
```

**Visual Example:**
```
    12 = 0 0 0 0 1 1 0 0
    10 = 0 0 0 0 1 0 1 0
         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (AND)
     8 = 0 0 0 0 1 0 0 0

Only bits where BOTH are 1 remain set.
```

### Python Implementation

```python
def visualize_and(a, b, bits=8):
    """Visualize AND operation"""
    result = a & b
    
    print(f"AND Operation: {a} & {b}")
    print(f"{a:3d} = {bin(a)[2:].zfill(bits)}")
    print(f"{b:3d} = {bin(b)[2:].zfill(bits)}")
    print(f"      {'-' * bits} (AND)")
    print(f"{result:3d} = {bin(result)[2:].zfill(bits)}")
    print()
    return result

# Examples
visualize_and(12, 10)   # 8
visualize_and(15, 7)    # 7
visualize_and(5, 3)     # 1
```

### Key Use Cases of AND

**1. Check if a Number is Odd or Even**

```python
def is_odd_and(n):
    """
    Check if number is odd using AND
    If last bit is 1, number is odd
    """
    return (n & 1) == 1

def is_even_and(n):
    """Check if number is even"""
    return (n & 1) == 0

# Test
for i in range(10):
    print(f"{i}: {'Odd' if is_odd_and(i) else 'Even'}")
```

**Why this works:**
```
Even numbers end in 0: ...0
Odd numbers end in 1:  ...1

ANY_NUMBER & 1 extracts only the last bit:
  xxxxxx10 & 00000001 = 00000000 (even)
  xxxxxx11 & 00000001 = 00000001 (odd)
```

**2. Check if Specific Bit is Set**

```python
def is_bit_set(n, position):
    """
    Check if bit at 'position' is set (equals 1)
    
    Args:
        n: Number to check
        position: Bit position (0-indexed from right)
    Returns:
        True if bit is set, False otherwise
    """
    return (n & (1 << position)) != 0

# Test
n = 45  # Binary: 00101101
print(f"Number {n} = {bin(n)[2:].zfill(8)}")
for i in range(8):
    status = "SET" if is_bit_set(n, i) else "NOT SET"
    print(f"Bit {i}: {status}")
```

**Explanation:**
```
Check if bit 3 is set in 45:

45      = 0 0 1 0 1 1 0 1
1 << 3  = 0 0 0 0 1 0 0 0  (only bit 3 is set)
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (AND)
Result  = 0 0 0 0 1 0 0 0  (non-zero, so bit 3 IS set)

Check if bit 4 is set in 45:

45      = 0 0 1 0 1 1 0 1
1 << 4  = 0 0 0 1 0 0 0 0
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (AND)
Result  = 0 0 0 0 0 0 0 0  (zero, so bit 4 is NOT set)
```

**3. Clear/Extract Specific Bits (Masking)**

```python
def extract_lower_bits(n, num_bits):
    """
    Extract lower 'num_bits' bits from n
    Example: Extract lower 4 bits from 45 (0010 1101) â†’ 1101 (13)
    """
    mask = (1 << num_bits) - 1  # Create mask with 'num_bits' ones
    return n & mask

def extract_bits_range(n, start, end):
    """
    Extract bits from position 'start' to 'end' (inclusive)
    """
    length = end - start + 1
    mask = (1 << length) - 1
    return (n >> start) & mask

# Examples
print(f"Lower 4 bits of 45: {extract_lower_bits(45, 4)}")  # 13
print(f"Bits 2-5 of 45: {extract_bits_range(45, 2, 5)}")   # 11

# Practical example: Extract RGB from color
def extract_color_components(color):
    """Extract R, G, B from 24-bit color"""
    red = (color >> 16) & 0xFF    # AND with 11111111
    green = (color >> 8) & 0xFF
    blue = color & 0xFF
    return red, green, blue

color = 0xFF8040  # RGB(255, 128, 64)
r, g, b = extract_color_components(color)
print(f"Color 0x{color:06X} = RGB({r}, {g}, {b})")
```

**4. Modulo with Powers of 2**

```python
def fast_modulo_power_of_2(n, divisor):
    """
    Fast modulo when divisor is power of 2
    n % (2^k) = n & (2^k - 1)
    """
    return n & (divisor - 1)

# Examples - must be power of 2
print(f"17 % 8 = {fast_modulo_power_of_2(17, 8)}")   # 1
print(f"45 % 16 = {fast_modulo_power_of_2(45, 16)}")  # 13
print(f"100 % 32 = {fast_modulo_power_of_2(100, 32)}")# 4

# Verify it's correct
print(f"17 % 8 actually = {17 % 8}")
```

**Why this works:**
```
45 % 16:

45 in binary = 0010 1101
16 - 1 = 15  = 0000 1111  (lower 4 bits all set)
               â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (AND)
Result       = 0000 1101 = 13

This extracts the remainder when dividing by power of 2!
```

---

## 2.2 OR Operator (|)

### How OR Works

The OR operator returns **1** if **at least one bit is 1**, otherwise returns **0**.

**Truth Table:**
```
A | B | A | B
--|---|------
0 | 0 |   0
0 | 1 |   1
1 | 0 |   1
1 | 1 |   1
```

**Visual Example:**
```
    12 = 0 0 0 0 1 1 0 0
    10 = 0 0 0 0 1 0 1 0
         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (OR)
    14 = 0 0 0 0 1 1 1 0

Any bit that is 1 in either number becomes 1.
```

### Python Implementation

```python
def visualize_or(a, b, bits=8):
    """Visualize OR operation"""
    result = a | b
    
    print(f"OR Operation: {a} | {b}")
    print(f"{a:3d} = {bin(a)[2:].zfill(bits)}")
    print(f"{b:3d} = {bin(b)[2:].zfill(bits)}")
    print(f"      {'-' * bits} (OR)")
    print(f"{result:3d} = {bin(result)[2:].zfill(bits)}")
    print()
    return result

# Examples
visualize_or(12, 10)   # 14
visualize_or(5, 3)     # 7
visualize_or(8, 4)     # 12
```

### Key Use Cases of OR

**1. Set Specific Bit to 1**

```python
def set_bit(n, position):
    """
    Set bit at 'position' to 1
    
    Args:
        n: Original number
        position: Bit position to set
    Returns:
        Number with bit set
    """
    return n | (1 << position)

# Examples
n = 45  # Binary: 00101101
print(f"Original: {n} = {bin(n)[2:].zfill(8)}")

n_modified = set_bit(n, 1)  # Set bit 1
print(f"After setting bit 1: {n_modified} = {bin(n_modified)[2:].zfill(8)}")

n_modified = set_bit(n, 4)  # Set bit 4
print(f"After setting bit 4: {n_modified} = {bin(n_modified)[2:].zfill(8)}")
```

**Explanation:**
```
Set bit 4 in 45:

45      = 0 0 1 0 1 1 0 1
1 << 4  = 0 0 0 1 0 0 0 0
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (OR)
Result  = 0 0 1 1 1 1 0 1 = 61

The OR forces bit 4 to become 1.
```

**2. Merge Bit Patterns**

```python
def merge_permissions(perm1, perm2):
    """
    Merge two permission sets
    Each bit represents a permission (read, write, execute, etc.)
    """
    return perm1 | perm2

# Permission bits
READ = 1 << 0      # 001
WRITE = 1 << 1     # 010
EXECUTE = 1 << 2   # 100

user1_perms = READ | WRITE        # Can read and write
user2_perms = WRITE | EXECUTE     # Can write and execute

# Merge permissions
merged = merge_permissions(user1_perms, user2_perms)

print(f"User 1: {bin(user1_perms)[2:].zfill(3)} (Read + Write)")
print(f"User 2: {bin(user2_perms)[2:].zfill(3)} (Write + Execute)")
print(f"Merged: {bin(merged)[2:].zfill(3)} (All three)")
print(f"Can read? {bool(merged & READ)}")
print(f"Can write? {bool(merged & WRITE)}")
print(f"Can execute? {bool(merged & EXECUTE)}")
```

**3. Set Multiple Bits at Once**

```python
def set_multiple_bits(n, positions):
    """Set multiple bits specified in positions list"""
    mask = 0
    for pos in positions:
        mask |= (1 << pos)
    return n | mask

n = 0b00000000
result = set_multiple_bits(n, [1, 3, 5, 7])
print(f"Original: {bin(n)[2:].zfill(8)}")
print(f"After setting bits 1,3,5,7: {bin(result)[2:].zfill(8)}")
```

**4. Add Flags to Configuration**

```python
class FileMode:
    """File mode flags"""
    READ = 1 << 0
    WRITE = 1 << 1
    EXECUTE = 1 << 2
    APPEND = 1 << 3
    BINARY = 1 << 4

def open_file(mode=0):
    """Simulate file opening with mode flags"""
    mode_str = []
    if mode & FileMode.READ:
        mode_str.append("READ")
    if mode & FileMode.WRITE:
        mode_str.append("WRITE")
    if mode & FileMode.EXECUTE:
        mode_str.append("EXECUTE")
    if mode & FileMode.APPEND:
        mode_str.append("APPEND")
    if mode & FileMode.BINARY:
        mode_str.append("BINARY")
    
    return " + ".join(mode_str) if mode_str else "NO ACCESS"

# Open file with multiple modes
mode = FileMode.READ | FileMode.WRITE | FileMode.BINARY
print(f"File opened with: {open_file(mode)}")
```

---

## 2.3 XOR Operator (^)

### How XOR Works

The XOR (exclusive OR) operator returns **1** when bits are **different**, and **0** when bits are **same**.

**Truth Table:**
```
A | B | A ^ B
--|---|------
0 | 0 |   0
0 | 1 |   1
1 | 0 |   1
1 | 1 |   0
```

**Visual Example:**
```
    12 = 0 0 0 0 1 1 0 0
    10 = 0 0 0 0 1 0 1 0
         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (XOR)
     6 = 0 0 0 0 0 1 1 0

Only bits that differ become 1.
```

### Python Implementation

```python
def visualize_xor(a, b, bits=8):
    """Visualize XOR operation"""
    result = a ^ b
    
    print(f"XOR Operation: {a} ^ {b}")
    print(f"{a:3d} = {bin(a)[2:].zfill(bits)}")
    print(f"{b:3d} = {bin(b)[2:].zfill(bits)}")
    print(f"      {'-' * bits} (XOR)")
    print(f"{result:3d} = {bin(result)[2:].zfill(bits)}")
    print()
    return result

# Examples
visualize_xor(12, 10)   # 6
visualize_xor(5, 3)     # 6
visualize_xor(15, 15)   # 0
```

### Critical XOR Properties

**ğŸ”´ These are the MOST important properties in bit manipulation:**

```python
def demonstrate_xor_properties():
    """Demonstrate key XOR properties"""
    
    # Property 1: x ^ 0 = x (Identity)
    print("Property 1: x ^ 0 = x")
    for x in [5, 10, 255]:
        print(f"  {x} ^ 0 = {x ^ 0}")
    print()
    
    # Property 2: x ^ x = 0 (Self-inverse)
    print("Property 2: x ^ x = 0")
    for x in [5, 10, 255]:
        print(f"  {x} ^ {x} = {x ^ x}")
    print()
    
    # Property 3: x ^ y ^ y = x (Cancellation)
    print("Property 3: x ^ y ^ y = x")
    x, y = 42, 17
    print(f"  {x} ^ {y} ^ {y} = {x ^ y ^ y}")
    print()
    
    # Property 4: Commutative (order doesn't matter)
    print("Property 4: Commutative (x ^ y = y ^ x)")
    a, b = 12, 7
    print(f"  {a} ^ {b} = {a ^ b}")
    print(f"  {b} ^ {a} = {b ^ a}")
    print()
    
    # Property 5: Associative (grouping doesn't matter)
    print("Property 5: Associative ((x ^ y) ^ z = x ^ (y ^ z))")
    x, y, z = 5, 3, 7
    print(f"  ({x} ^ {y}) ^ {z} = {(x ^ y) ^ z}")
    print(f"  {x} ^ ({y} ^ {z}) = {x ^ (y ^ z)}")

demonstrate_xor_properties()
```

### Key Use Cases of XOR

**1. Toggle Bit (Flip 0â†”1)**

```python
def toggle_bit(n, position):
    """Toggle bit at position (0â†’1 or 1â†’0)"""
    return n ^ (1 << position)

# Example
n = 45  # Binary: 00101101
print(f"Original: {n} = {bin(n)[2:].zfill(8)}")

n = toggle_bit(n, 2)
print(f"Toggle bit 2: {n} = {bin(n)[2:].zfill(8)}")

n = toggle_bit(n, 2)  # Toggle again
print(f"Toggle bit 2 again: {n} = {bin(n)[2:].zfill(8)}")
```

**2. Swap Two Numbers Without Temporary Variable**

```python
def swap_xor(a, b):
    """
    Swap two numbers using XOR
    This is a classic interview question!
    """
    print(f"Before: a={a}, b={b}")
    
    a = a ^ b  # a now holds XOR of both
    b = a ^ b  # b = (a^b) ^ b = a (original a)
    a = a ^ b  # a = (a^b) ^ a = b (original b)
    
    print(f"After: a={a}, b={b}")
    return a, b

# Test
swap_xor(5, 10)
```

**Why this works:**
```
Initial: a=5, b=10

Step 1: a = a ^ b
   a = 5 ^ 10 = 15
   Now a holds 15, b still holds 10

Step 2: b = a ^ b  (which is: b = (5^10) ^ 10)
   b = 15 ^ 10 = 5
   Now a holds 15, b holds 5 (original a!)

Step 3: a = a ^ b  (which is: a = (5^10) ^ 5)
   a = 15 ^ 5 = 10
   Now a holds 10 (original b!), b holds 5 (original a!)
```

**3. Find Unique Number (Single Number Problem)**

```python
def find_unique(nums):
    """
    Find the number that appears once when all others appear twice
    This works because: a ^ a = 0 and a ^ 0 = a
    All pairs cancel out, leaving only the unique number
    """
    result = 0
    for num in nums:
        result ^= num
    return result

# Example
numbers = [2, 3, 5, 3, 2, 7, 5]
unique = find_unique(numbers)
print(f"Numbers: {numbers}")
print(f"Unique number: {unique}")

# Step-by-step visualization
def find_unique_verbose(nums):
    """Show XOR steps"""
    result = 0
    print("XOR chain:")
    for i, num in enumerate(nums):
        old_result = result
        result ^= num
        print(f"  Step {i+1}: {old_result} ^ {num} = {result}")
    return result

print("\nStep-by-step:")
find_unique_verbose([2, 3, 5, 3, 2, 7, 5])
```

**4. Check if Two Numbers Have Different Signs**

```python
def opposite_signs(a, b):
    """
    Check if two numbers have opposite signs
    XOR of two numbers with opposite signs has MSB set
    """
    return (a ^ b) < 0

# Test (using 32-bit signed interpretation)
def opposite_signs_demo(a, b):
    result = (a ^ b) < 0
    print(f"{a:4d} and {b:4d}: {'Opposite signs' if result else 'Same sign'}")

opposite_signs_demo(5, -3)    # Opposite
opposite_signs_demo(-5, -3)   # Same
opposite_signs_demo(5, 3)     # Same
opposite_signs_demo(-5, 3)    # Opposite
```

**5. Missing Number in Array**

```python
def find_missing_number(nums, n):
    """
    Find missing number from 0 to n
    XOR all numbers and all indices to cancel pairs
    """
    result = n  # Start with n
    
    for i, num in enumerate(nums):
        result ^= i ^ num
    
    return result

# Example: Array should have [0,1,2,3,4] but 2 is missing
arr = [0, 1, 3, 4]
missing = find_missing_number(arr, 4)
print(f"Array: {arr}")
print(f"Missing number: {missing}")
```

---

## 2.4 NOT Operator (~)

### How NOT Works

The NOT operator flips **all bits**: 1â†’0 and 0â†’1. This is called **one's complement**.

```python
def visualize_not(n, bits=8):
    """Visualize NOT operation"""
    # Python integers are arbitrary precision, so we mask to desired width
    result = ~n & ((1 << bits) - 1)
    
    print(f"NOT Operation: ~{n}")
    print(f"{n:3d} = {bin(n)[2:].zfill(bits)}")
    print(f"      {'-' * bits} (NOT)")
    print(f"{result:3d} = {bin(result)[2:].zfill(bits)}")
    print()
    return result

# Examples
visualize_not(5)    # All bits flipped
visualize_not(0)    # 0 becomes all 1s
visualize_not(255)  # 255 becomes 0
```

### Important NOT Properties

```python
def demonstrate_not_properties():
    """Show important NOT properties"""
    
    print("Property 1: ~x = -x - 1 (in two's complement)")
    for x in [0, 1, 5, 10]:
        print(f"  ~{x} = {~x} (equals -({x}+1) = {-(x+1)})")
    print()
    
    print("Property 2: ~(~x) = x (double negation)")
    for x in [5, 10, 100]:
        print(f"  ~(~{x}) = {~(~x)}")
    print()
    
    print("Property 3: x & ~x = 0 (number AND its complement = 0)")
    for x in [5, 10, 100]:
        result = x & ~x
        print(f"  {x} & ~{x} = {result}")
    print()
    
    print("Property 4: x | ~x = -1 (all bits set)")
    for x in [5, 10, 100]:
        result = x | ~x
        print(f"  {x} | ~{x} = {result}")

demonstrate_not_properties()
```

### Key Use Cases of NOT

**1. Create Bit Masks**

```python
def create_mask_with_zeros(positions, width=8):
    """
    Create a mask with 0s at specified positions, 1s elsewhere
    Useful for clearing specific bits
    """
    mask = (1 << width) - 1  # All 1s
    
    for pos in positions:
        mask &= ~(1 << pos)  # Clear bit at position
    
    return mask

mask = create_mask_with_zeros([1, 3, 5], 8)
print(f"Mask with zeros at positions 1,3,5:")
print(f"Binary: {bin(mask)[2:].zfill(8)}")
print(f"Decimal: {mask}")
```

**2. Clear Specific Bit**

```python
def clear_bit(n, position):
    """
    Clear bit at position (set it to 0)
    Uses: n & ~(1 << position)
    """
    return n & ~(1 << position)

# Example
n = 45  # Binary: 00101101
print(f"Original: {n} = {bin(n)[2:].zfill(8)}")

n = clear_bit(n, 3)
print(f"Clear bit 3: {n} = {bin(n)[2:].zfill(8)}")

n = clear_bit(n, 5)
print(f"Clear bit 5: {n} = {bin(n)[2:].zfill(8)}")
```

**Explanation:**
```
Clear bit 3 in 45 (00101101):

1 << 3    = 00001000  (only bit 3 set)
~(1 << 3) = 11110111  (all bits except 3 are set)

45        = 00101101
~(1<<3)   = 11110111
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (AND)
Result    = 00100101 = 37
```

**3. Get Lower N Bits**

```python
def get_lower_n_bits(num, n):
    """Extract lower n bits using NOT to create mask"""
    # Alternative to (1 << n) - 1
    mask = ~(~0 << n)  # Create n ones
    return num & mask

print(f"Lower 4 bits of 45: {get_lower_n_bits(45, 4)}")
print(f"Lower 3 bits of 100: {get_lower_n_bits(100, 3)}")
```

---

## 2.5 Left Shift (<<)

### How Left Shift Works

Left shift moves all bits to the left by N positions and fills with 0s on the right.

**Effect:** Multiplies the number by 2^N

```python
def visualize_left_shift(n, shift, bits=8):
    """Visualize left shift operation"""
    result = (n << shift) & ((1 << bits) - 1)  # Mask to 8 bits
    
    print(f"Left Shift: {n} << {shift}")
    print(f"Original:  {bin(n)[2:].zfill(bits)} = {n}")
    print(f"After <<{shift}: {bin(result)[2:].zfill(bits)} = {result}")
    print(f"Equals: {n} Ã— 2^{shift} = {n * (2**shift)}")
    print()
    return result

# Examples
visualize_left_shift(5, 1)   # 5 Ã— 2 = 10
visualize_left_shift(5, 2)   # 5 Ã— 4 = 20
visualize_left_shift(3, 3)   # 3 Ã— 8 = 24
```

**Detailed Example:**
```
5 << 2:

Original:     00000101  (5)
Shift left 2: 00010100  (20)
              â†‘â†‘
              These bits shifted out (lost if overflow)
                      â†‘â†‘
                      Filled with 0s

5 << 2 = 5 Ã— 2Â² = 5 Ã— 4 = 20
```

### Key Use Cases of Left Shift

**1. Create Single-Bit Mask**

```python
def create_bit_mask(position):
    """Create number with only one bit set at position"""
    return 1 << position

print("Single-bit masks:")
for i in range(8):
    mask = create_bit_mask(i)
    print(f"Position {i}: {bin(mask)[2:].zfill(8)} = {mask}")
```

**2. Fast Multiplication by Power of 2**

```python
def fast_multiply_by_power_of_2(n, power):
    """
    Multiply n by 2^power using left shift
    Much faster than regular multiplication
    """
    return n << power

# Examples
print(f"7 Ã— 2 = {fast_multiply_by_power_of_2(7, 1)}")     # 14
print(f"7 Ã— 4 = {fast_multiply_by_power_of_2(7, 2)}")     # 28
print(f"7 Ã— 8 = {fast_multiply_by_power_of_2(7, 3)}")     # 56
print(f"7 Ã— 16 = {fast_multiply_by_power_of_2(7, 4)}")    # 112
```

**3. Create Masks with N Bits Set**

```python
def create_n_bit_mask(n):
    """Create mask with lower n bits all set to 1"""
    return (1 << n) - 1

print("Masks with n bits set:")
for i in range(1, 9):
    mask = create_n_bit_mask(i)
    print(f"{i} bits: {bin(mask)[2:].zfill(8)} = {mask}")
```

**4. Pack Multiple Values**

```python
def pack_date(year, month, day):
    """
    Pack date into single integer:
    Year: 12 bits (0-4095)
    Month: 4 bits (1-12)
    Day: 5 bits (1-31)
    """
    return (year << 9) | (month << 5) | day

def unpack_date(packed):
    """Unpack date from integer"""
    day = packed & 0x1F           # Lower 5 bits
    month = (packed >> 5) & 0xF   # Next 4 bits
    year = (packed >> 9) & 0xFFF  # Next 12 bits
    return year, month, day

# Example
date = pack_date(2024, 12, 25)
print(f"Packed date: {date} (binary: {bin(date)[2:].zfill(21)})")

year, month, day = unpack_date(date)
print(f"Unpacked: {year:04d}-{month:02d}-{day:02d}")
```

---

## 2.6 Right Shift (>>)

### How Right Shift Works

Right shift moves all bits to the right by N positions.

**Effect:** Divides the number by 2^N (integer division, rounds down)

**Two types:**
- **Arithmetic shift:** Preserves sign bit (for signed numbers)
- **Logical shift:** Fills with 0s (for unsigned numbers)

```python
def visualize_right_shift(n, shift, bits=8):
    """Visualize right shift operation"""
    result = n >> shift
    
    print(f"Right Shift: {n} >> {shift}")
    print(f"Original:   {bin(n)[2:].zfill(bits)} = {n}")
    print(f"After >>{shift}:  {bin(result)[2:].zfill(bits)} = {result}")
    print(f"Equals: {n} Ã· 2^{shift} = {n // (2**shift)}")
    print()
    return result

# Examples
visualize_right_shift(20, 1)  # 20 Ã· 2 = 10
visualize_right_shift(20, 2)  # 20 Ã· 4 = 5
visualize_right_shift(20, 3)  # 20 Ã· 8 = 2
```

**Detailed Example:**
```
20 >> 2:

Original:      00010100  (20)
Shift right 2: 00000101  (5)
                      â†‘â†‘
                      These bits shifted out (lost)
               â†‘â†‘
               Filled with 0s (or sign bit for arithmetic shift)

20 >> 2 = 20 Ã· 4 = 5
```

### Key Use Cases of Right Shift

**1. Fast Division by Power of 2**

```python
def fast_divide_by_power_of_2(n, power):
    """
    Divide n by 2^power using right shift
    Much faster than regular division
    """
    return n >> power

# Examples
print(f"100 Ã· 2 = {fast_divide_by_power_of_2(100, 1)}")   # 50
print(f"100 Ã· 4 = {fast_divide_by_power_of_2(100, 2)}")   # 25
print(f"100 Ã· 8 = {fast_divide_by_power_of_2(100, 3)}")   # 12
print(f"100 Ã· 16 = {fast_divide_by_power_of_2(100, 4)}")  # 6
```

**2. Extract Specific Bits**

```python
def extract_bits(n, position, count):
    """
    Extract 'count' bits starting from 'position'
    1. Shift right to move desired bits to LSB positions
    2. AND with mask to keep only those bits
    """
    mask = (1 << count) - 1
    return (n >> position) & mask

# Example: Extract bits 3-5 from 45 (00101101)
n = 45
bits = extract_bits(n, 3, 3)
print(f"Number: {n} = {bin(n)[2:].zfill(8)}")
print(f"Bits 3-5: {bits} = {bin(bits)[2:].zfill(3)}")
```

**3. Iterate Through Bits**

```python
def print_all_bits(n):
    """Print all bits of a number from LSB to MSB"""
    print(f"Number: {n}")
    print("Bits: ", end="")
    
    temp = n
    position = 0
    while temp > 0:
        bit = temp & 1
        print(f"{bit}", end=" ")
        temp >>= 1  # Move to next bit
        position += 1
    print()

print_all_bits(45)
print_all_bits(255)
```

**4. Binary Search on Answer**

```python
def find_sqrt_binary_search(n):
    """
    Find integer square root using bit manipulation
    Start from MSB and work down
    """
    if n == 0:
        return 0
    
    # Find highest bit position
    bit = 1 << 15  # Start from a high bit
    
    result = 0
    while bit > 0:
        if (result + bit) * (result + bit) <= n:
            result += bit
        bit >>= 1  # Move to next lower bit
    
    return result

# Test
for n in [16, 25, 50, 100]:
    sqrt = find_sqrt_binary_search(n)
    print(f"âˆš{n} â‰ˆ {sqrt}")
```

---

## Complete Bitwise Operators Cheat Sheet

```python
def bitwise_operators_demo():
    """Comprehensive demo of all bitwise operators"""
    
    a, b = 12, 10
    
    print("=" * 50)
    print(f"a = {a} = {bin(a)[2:].zfill(8)}")
    print(f"b = {b} = {bin(b)[2:].zfill(8)}")
    print("=" * 50)
    
    # AND
    result = a & b
    print(f"AND:  a & b  = {result:2d} = {bin(result)[2:].zfill(8)}")
    
    # OR
    result = a | b
    print(f"OR:   a | b  = {result:2d} = {bin(result)[2:].zfill(8)}")
    
    # XOR
    result = a ^ b
    print(f"XOR:  a ^ b  = {result:2d} = {bin(result)[2:].zfill(8)}")
    
    # NOT
    result = ~a & 0xFF  # Mask to 8 bits
    print(f"NOT:  ~a     = {result:2d} = {bin(result)[2:].zfill(8)}")
    
    # Left Shift
    result = a << 2
    print(f"LEFT: a << 2 = {result:2d} = {bin(result)[2:].zfill(10)}")
    
    # Right Shift
    result = a >> 2
    print(f"RIGHT: a >> 2 = {result:2d} = {bin(result)[2:].zfill(8)}")
    
    print("=" * 50)

bitwise_operators_demo()
```

---

## Practice Problems

```python
# Problem 1: Implement all basic operations
def implement_operations(n):
    print(f"\nOperations on {n} ({bin(n)[2:].zfill(8)}):")
    print(f"  Check if odd: {(n & 1) == 1}")
    print(f"  Set bit 2: {n | (1 << 2)} ({bin(n | (1 << 2))[2:].zfill(8)})")
    print(f"  Clear bit 3: {n & ~(1 << 3)} ({bin(n & ~(1 << 3))[2:].zfill(8)})")
    print(f"  Toggle bit 4: {n ^ (1 << 4)} ({bin(n ^ (1 << 4))[2:].zfill(8)})")
    print(f"  Multiply by 8: {n << 3}")
    print(f"  Divide by 4: {n >> 2}")

implement_operations(45)
implement_operations(60)

# Problem 2: Swap bits at two positions
def swap_bits(n, i, j):
    """Swap bits at positions i and j"""
    # Extract bits
    bit_i = (n >> i) & 1
    bit_j = (n >> j) & 1
    
    # If bits are different, swap them
    if bit_i != bit_j:
        # XOR with mask to flip both bits
        n ^= (1 << i) | (1 << j)
    
    return n

n = 0b00101100  # 44
print(f"\nOriginal: {bin(n)[2:].zfill(8)}")
n = swap_bits(n, 1, 5)
print(f"After swapping bits 1 and 5: {bin(n)[2:].zfill(8)}")
```

ğŸ¯ **You now have a complete understanding of all basic bitwise operators!**