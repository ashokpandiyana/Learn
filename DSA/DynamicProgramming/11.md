# Chapter 11: Pattern 10 - Bitmask DP

## Overview

Bitmask DP is used when you need to track **which elements are included/visited** in a set where the set size is small (typically n ≤ 20). Each bit in a bitmask represents whether an element is included.

**Pattern Recognition**:
- Small set size (n ≤ 20, sometimes up to 24)
- Need to track subset selection
- Order doesn't matter (or specific order handling)
- Subset/permutation enumeration
- Visiting/assignment problems

**Why n ≤ 20?** Because 2^20 = 1,048,576 states (manageable), but 2^30 = 1 billion (too much).

---

## 11.1 Bit Manipulation Essentials

### 11.1.1 Basic Operations in Python

```python
# Set bit i (add element i to set)
mask |= (1 << i)

# Clear bit i (remove element i from set)
mask &= ~(1 << i)

# Toggle bit i
mask ^= (1 << i)

# Check if bit i is set (is element i in set?)
if mask & (1 << i):
    # Element i is in the set
    pass

# Count number of set bits (size of set)
count = bin(mask).count('1')
# Or using bit manipulation:
count = 0
temp = mask
while temp:
    count += 1
    temp &= (temp - 1)  # Remove rightmost set bit

# Get rightmost set bit
rightmost = mask & -mask

# Clear rightmost set bit
mask &= (mask - 1)

# Check if mask is empty
if mask == 0:
    # Set is empty
    pass

# Check if mask is full (all n bits set)
if mask == (1 << n) - 1:
    # All elements included
    pass
```

### 11.1.2 Iterating Through Subsets

```python
# Iterate through all possible subsets (2^n)
n = 5
for mask in range(1 << n):
    # Process subset represented by mask
    print(f"Subset: {bin(mask)}")

# Iterate through all subsets of a given mask
mask = 0b10110  # Some subset
submask = mask
while True:
    # Process submask
    print(f"Submask: {bin(submask)}")
    
    submask = (submask - 1) & mask
    if submask == 0:
        break

# Iterate through all k-bit subsets
def k_bit_subsets(n, k):
    """Generate all subsets of {0,1,...,n-1} with exactly k elements"""
    mask = (1 << k) - 1  # Start with k rightmost bits set
    limit = 1 << n
    
    while mask < limit:
        yield mask
        
        # Gosper's hack: next k-bit subset
        c = mask & -mask
        r = mask + c
        mask = (((r ^ mask) >> 2) // c) | r

# Test
for subset in k_bit_subsets(5, 3):
    print(bin(subset))
```

### 11.1.3 Extracting Elements from Mask

```python
def elements_in_mask(mask):
    """Get list of indices where bits are set"""
    elements = []
    i = 0
    while mask:
        if mask & 1:
            elements.append(i)
        mask >>= 1
        i += 1
    return elements

# Example
mask = 0b10110  # Binary: positions 1, 2, 4 are set
print(elements_in_mask(mask))  # [1, 2, 4]
```

---

## 11.2 Classic Problems

### 11.2.1 Traveling Salesman Problem (TSP)

**Problem**: Given n cities and distances between them, find shortest path visiting all cities exactly once and returning to start.

**Classic NP-hard problem**, but solvable with DP for small n!

#### Analysis

**State**: `dp[mask][i]` = minimum cost to visit all cities in `mask`, ending at city `i`

**Recurrence**:
```python
dp[mask][i] = min(
    dp[mask ^ (1 << i)][j] + dist[j][i]
    for all j where j is in (mask ^ (1 << i))
)
```

```python
def tsp(dist):
    """
    dist[i][j] = distance from city i to city j
    Returns minimum tour length
    """
    n = len(dist)
    
    # dp[mask][i] = min cost to visit cities in mask, ending at city i
    dp = [[float('inf')] * n for _ in range(1 << n)]
    
    # Start at city 0
    dp[1][0] = 0
    
    # Iterate through all subsets
    for mask in range(1 << n):
        for i in range(n):
            # If city i is not in mask, skip
            if not (mask & (1 << i)):
                continue
            
            # Try adding each unvisited city
            for j in range(n):
                # If city j already visited, skip
                if mask & (1 << j):
                    continue
                
                new_mask = mask | (1 << j)
                dp[new_mask][j] = min(
                    dp[new_mask][j],
                    dp[mask][i] + dist[i][j]
                )
    
    # Return to starting city
    full_mask = (1 << n) - 1
    result = min(dp[full_mask][i] + dist[i][0] for i in range(n))
    
    return result

# Test
dist = [
    [0, 10, 15, 20],
    [10, 0, 35, 25],
    [15, 35, 0, 30],
    [20, 25, 30, 0]
]
print(tsp(dist))  # 80
```

**Visualization for 4 cities**:
```
Cities: 0, 1, 2, 3

Optimal tour: 0 → 1 → 3 → 2 → 0
Cost: 10 + 25 + 30 + 15 = 80

States explored:
mask=0001 (city 0): dp[0001][0] = 0
mask=0011 (cities 0,1): dp[0011][1] = 10
mask=0101 (cities 0,2): dp[0101][2] = 15
...
mask=1111 (all cities): find min cost back to 0
```

**Complexity**: O(n² × 2^n) time, O(n × 2^n) space

---

### 11.2.2 Maximum Students Taking Exam

**Problem**: m×n grid of seats. Some broken ('x'). Students can't copy from adjacent seats (left, right, upper-left, upper-right). Maximize students seated.

**LeetCode**: #1349

#### Analysis

**Key Insight**: Process row by row. For each row, try all valid seating arrangements.

**State**: `dp[row][mask]` = max students up to row `row`, current row has seating `mask`

```python
def maxStudents(seats):
    """
    seats[i][j] = '.' (good seat) or '#' (broken seat)
    """
    m, n = len(seats), len(seats[0])
    
    def is_valid_mask(mask, row):
        """Check if mask is valid for given row"""
        for j in range(n):
            if mask & (1 << j):
                # Student at position j
                # Check if seat is broken
                if seats[row][j] == '#':
                    return False
                # Check if student on immediate left
                if j > 0 and (mask & (1 << (j - 1))):
                    return False
        return True
    
    def count_students(mask):
        """Count number of students in mask"""
        return bin(mask).count('1')
    
    def can_place(curr_mask, prev_mask):
        """Check if curr_mask valid given prev_mask"""
        for j in range(n):
            if curr_mask & (1 << j):
                # Check upper-left
                if j > 0 and (prev_mask & (1 << (j - 1))):
                    return False
                # Check upper-right
                if j < n - 1 and (prev_mask & (1 << (j + 1))):
                    return False
        return True
    
    # dp[mask] = max students with current row having mask
    dp = [0] * (1 << n)
    
    # First row
    for mask in range(1 << n):
        if is_valid_mask(mask, 0):
            dp[mask] = count_students(mask)
    
    # Process subsequent rows
    for row in range(1, m):
        new_dp = [0] * (1 << n)
        
        for curr_mask in range(1 << n):
            if not is_valid_mask(curr_mask, row):
                continue
            
            # Try all previous row masks
            for prev_mask in range(1 << n):
                if dp[prev_mask] == 0 and prev_mask != 0:
                    continue
                
                if can_place(curr_mask, prev_mask):
                    new_dp[curr_mask] = max(
                        new_dp[curr_mask],
                        dp[prev_mask] + count_students(curr_mask)
                    )
        
        dp = new_dp
    
    return max(dp)

# Test
seats = [
    ["#", ".", "#", "#", ".", "#"],
    [".", "#", "#", "#", "#", "."],
    ["#", ".", "#", "#", ".", "#"]
]
print(maxStudents(seats))  # 4
```

**Complexity**: O(m × 4^n) time (for each row, try all pairs of masks)

---

### 11.2.3 Partition to K Equal Sum Subsets

**Problem**: Given array and integer k, partition array into k subsets with equal sum.

**LeetCode**: #698

#### Analysis

**State**: `dp[mask]` = True if elements in `mask` can be partitioned into equal-sum groups

```python
def canPartitionKSubsets(nums, k):
    total = sum(nums)
    if total % k != 0:
        return False
    
    target = total // k
    n = len(nums)
    
    # Optimization: sort in descending order
    nums.sort(reverse=True)
    
    # If any number > target, impossible
    if nums[0] > target:
        return False
    
    # dp[mask] = remaining sum needed for current subset
    # If dp[mask] = 0, current subset is complete
    dp = [-1] * (1 << n)
    dp[0] = 0  # Empty set
    
    for mask in range(1 << n):
        if dp[mask] == -1:
            continue
        
        for i in range(n):
            # If element i already used
            if mask & (1 << i):
                continue
            
            new_mask = mask | (1 << i)
            
            # If already computed, skip
            if dp[new_mask] != -1:
                continue
            
            # Current subset sum + nums[i]
            new_sum = (dp[mask] + nums[i]) % target
            
            # If this makes sum exceed target, skip
            if dp[mask] + nums[i] <= target:
                dp[new_mask] = new_sum
    
    return dp[(1 << n) - 1] == 0

# Alternative: Backtracking with memoization
def canPartitionKSubsets_v2(nums, k):
    total = sum(nums)
    if total % k != 0:
        return False
    
    target = total // k
    nums.sort(reverse=True)
    used = [False] * len(nums)
    
    def backtrack(k_remaining, current_sum, start):
        if k_remaining == 1:
            return True
        
        if current_sum == target:
            return backtrack(k_remaining - 1, 0, 0)
        
        for i in range(start, len(nums)):
            if used[i]:
                continue
            
            if current_sum + nums[i] > target:
                continue
            
            used[i] = True
            if backtrack(k_remaining, current_sum + nums[i], i + 1):
                return True
            used[i] = False
            
            # Pruning: if this element didn't work at this position,
            # don't try other elements with same value
            if current_sum == 0:
                break
        
        return False
    
    return backtrack(k, 0, 0)

# Test
print(canPartitionKSubsets([4, 3, 2, 3, 5, 2, 1], 4))  # True
# Subsets: [5], [1,4], [2,3], [2,3]
```

**Complexity**: O(n × 2^n) time and space

---

### 11.2.4 Minimum Cost to Connect Two Groups of Points

**Problem**: Two groups of points. Connect every point in group 1 to at least one point in group 2, and vice versa. Minimize total cost.

**LeetCode**: #1595

#### Analysis

**State**: `dp[i][mask]` = min cost to connect first i points from group1, with group2 points in `mask` connected

```python
def connectTwoGroups(cost):
    """
    cost[i][j] = cost to connect point i from group1 to point j from group2
    """
    n1, n2 = len(cost), len(cost[0])
    
    # Precompute minimum cost to connect each point in group2
    min_cost2 = [min(cost[i][j] for i in range(n1)) for j in range(n2)]
    
    # dp[mask] = min cost with group2 points in mask connected
    dp = [float('inf')] * (1 << n2)
    dp[0] = 0
    
    for i in range(n1):
        new_dp = [float('inf')] * (1 << n2)
        
        for mask in range(1 << n2):
            if dp[mask] == float('inf'):
                continue
            
            # Option 1: Connect point i to all unconnected points in group2
            missing_cost = sum(
                min_cost2[j] for j in range(n2) if not (mask & (1 << j))
            )
            new_dp[(1 << n2) - 1] = min(
                new_dp[(1 << n2) - 1],
                dp[mask] + missing_cost
            )
            
            # Option 2: Connect point i to some points in group2
            for j in range(n2):
                new_mask = mask | (1 << j)
                new_dp[new_mask] = min(
                    new_dp[new_mask],
                    dp[mask] + cost[i][j]
                )
        
        dp = new_dp
    
    return dp[(1 << n2) - 1]

# Cleaner version with memoization
def connectTwoGroups_memo(cost):
    from functools import cache
    
    n1, n2 = len(cost), len(cost[0])
    min_cost2 = [min(cost[i][j] for i in range(n1)) for j in range(n2)]
    
    @cache
    def dp(i, mask):
        # Base case: processed all points in group1
        if i == n1:
            # Connect all remaining points in group2
            total = sum(min_cost2[j] for j in range(n2) if not (mask & (1 << j)))
            return total
        
        result = float('inf')
        
        # Try connecting point i to each point in group2
        for j in range(n2):
            new_mask = mask | (1 << j)
            result = min(result, cost[i][j] + dp(i + 1, new_mask))
        
        return result
    
    return dp(0, 0)

# Test
cost = [[15, 96], [36, 2]]
print(connectTwoGroups(cost))  # 17
```

**Complexity**: O(n1 × 2^n2 × n2) time

---

## 11.3 Advanced Bitmask Techniques

### 11.3.1 Subset DP Pattern

```python
# Process subsets in increasing size
for mask in range(1 << n):
    # For each subset, try adding elements
    for i in range(n):
        if not (mask & (1 << i)):
            new_mask = mask | (1 << i)
            dp[new_mask] = update(dp[mask], i)
```

### 11.3.2 Profile Optimization

For grid problems, only track current row state:

```python
# Instead of dp[row][mask]
# Use rolling array: dp[mask] for current row
for row in range(m):
    new_dp = [0] * (1 << n)
    for mask in range(1 << n):
        # Update new_dp based on dp
        pass
    dp = new_dp
```

### 11.3.3 Meet in the Middle

For n ≤ 40, split into two halves of size 20:

```python
def meet_in_middle(nums, target):
    n = len(nums)
    mid = n // 2
    
    # Generate all subsets of first half
    left_sums = {}
    for mask in range(1 << mid):
        total = sum(nums[i] for i in range(mid) if mask & (1 << i))
        left_sums[total] = left_sums.get(total, 0) + 1
    
    # For each subset of second half, check if complement exists
    result = 0
    for mask in range(1 << (n - mid)):
        total = sum(nums[mid + i] for i in range(n - mid) if mask & (1 << i))
        complement = target - total
        result += left_sums.get(complement, 0)
    
    return result
```

**Complexity**: O(2^(n/2)) instead of O(2^n)

---

## 11.4 Common Patterns

### Pattern 1: Assignment Problems

Assign n items to n positions with constraints:

```python
def assignment_dp(cost):
    n = len(cost)
    # dp[mask] = min cost to assign items in mask
    dp = [float('inf')] * (1 << n)
    dp[0] = 0
    
    for mask in range(1 << n):
        if dp[mask] == float('inf'):
            continue
        
        pos = bin(mask).count('1')  # Next position to fill
        
        for item in range(n):
            if mask & (1 << item):
                continue
            new_mask = mask | (1 << item)
            dp[new_mask] = min(dp[new_mask], dp[mask] + cost[pos][item])
    
    return dp[(1 << n) - 1]
```

### Pattern 2: Subset Selection

Select subset with maximum/minimum property:

```python
def subset_selection(items):
    n = len(items)
    dp = [0] * (1 << n)
    
    for mask in range(1 << n):
        value = compute_value(mask, items)
        dp[mask] = value
        
        # Try adding each element
        for i in range(n):
            if not (mask & (1 << i)):
                new_mask = mask | (1 << i)
                dp[new_mask] = max(dp[new_mask], combine(dp[mask], items[i]))
    
    return dp[(1 << n) - 1]
```

### Pattern 3: State Compression

Represent complex state as bitmask:

```python
# Example: Track which conditions are satisfied
CONDITION_A = 1 << 0
CONDITION_B = 1 << 1
CONDITION_C = 1 << 2

state = 0
if condition_a_satisfied:
    state |= CONDITION_A
if condition_b_satisfied:
    state |= CONDITION_B
```

---

## 11.5 Optimization Strategies

### Strategy 1: Prune Invalid States

```python
# Don't process invalid masks
for mask in range(1 << n):
    if not is_valid(mask):
        continue
    # Process only valid masks
```

### Strategy 2: Iterate Over Submasks

```python
# When need to consider all subsets of a mask
mask = current_state
submask = mask
while True:
    # Process submask
    dp[mask] = min(dp[mask], dp[submask] + cost)
    
    if submask == 0:
        break
    submask = (submask - 1) & mask
```

### Strategy 3: Precomputation

```python
# Precompute properties for all masks
valid = [False] * (1 << n)
value = [0] * (1 << n)

for mask in range(1 << n):
    valid[mask] = check_validity(mask)
    value[mask] = compute_value(mask)

# Use in DP
for mask in range(1 << n):
    if not valid[mask]:
        continue
    dp[mask] = value[mask]
```

---

## 11.6 When NOT to Use Bitmask DP

**Don't use when**:
- n > 24 (too many states)
- Order matters significantly (use permutation DP instead)
- Elements can be repeated (use different DP)
- Better greedy solution exists

**Alternatives**:
- Large n: Use approximation algorithms or heuristics
- Order matters: Use different state representation
- Overlapping elements: Use different DP formulation

---

## Practice Problems Summary

### Beginner
1. Hamming Distance (#461)
2. Number of 1 Bits (#191)
3. Power Set (#78)

### Intermediate
4. Partition to K Equal Sum Subsets (#698)
5. Fair Distribution of Cookies (#2305)
6. Maximum Students Taking Exam (#1349)

### Advanced
7. Traveling Salesman Problem (Classic)
8. Minimum Cost to Connect Two Groups (#1595)
9. Find the Shortest Superstring (#943)

---

## Key Takeaways

1. **Bitmask DP works for n ≤ 20-24** (2^20 to 2^24 states)
2. **Each bit represents element inclusion** (0 = not included, 1 = included)
3. **Use | for adding**, & for checking, ^ for toggling
4. **State**: Usually `dp[mask]` or `dp[i][mask]`
5. **Complexity**: Usually O(2^n × n) or O(2^n × n²)
6. **Subset iteration**: `submask = (submask - 1) & mask`
7. **Count bits**: `bin(mask).count('1')`
8. **Meet in the middle** for n ≤ 40
9. **Profile optimization** for grid problems
10. **Always check**: Is n small enough for bitmask DP?

Bitmask DP is powerful for subset and assignment problems with small n - master bit manipulation!