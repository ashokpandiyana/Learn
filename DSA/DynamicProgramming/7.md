# Chapter 7: Pattern 6 - Interval DP

## Overview

Interval DP (also called Range DP) solves problems on subarrays/substrings by considering all possible intervals. The key characteristic is that `dp[i][j]` represents the optimal solution for the subarray from index i to j.

**Pattern Recognition**:
- Problem asks about subarrays/substrings
- Optimal solution depends on splitting intervals
- Need to consider all possible ways to divide interval
- Often involves "which operation to do last"

**Typical Complexity**: O(n³) time, O(n²) space

---

## 7.1 Core Concept

### State Definition

**State**: `dp[i][j]` = optimal value for interval `[i, j]`

### Iteration Pattern

**CRITICAL**: Build solutions from smaller intervals to larger!

```python
# Iterate by length of interval
for length in range(2, n + 1):
    for i in range(n - length + 1):
        j = i + length - 1
        # dp[i][j] depends on all dp[i][k] and dp[k+1][j] where i <= k < j
```

**Why this order?** To compute `dp[i][j]`, we need all smaller intervals already computed!

### Common Recurrence Pattern

```python
dp[i][j] = min/max over all k in [i, j) of:
    cost(i, k, j) + dp[i][k] + dp[k+1][j]
```

---

## 7.2 Classic Problems

### 7.2.1 Burst Balloons

**Problem**: Given n balloons with values. Burst balloons to maximize coins. When you burst balloon i, you get `nums[i-1] * nums[i] * nums[i+1]` coins. Adjacent balloons become neighbors after burst.

**LeetCode**: #312

#### Analysis

**KEY INSIGHT**: Think about which balloon to burst **LAST**, not first!

If we burst balloon k last in interval [i, j]:
- It's the only balloon left in [i, j]
- Its neighbors are balloon i-1 and j+1
- Cost = `nums[i-1] * nums[k] * nums[j+1]`

**State**: `dp[i][j]` = max coins from bursting all balloons in open interval (i, j)

**Recurrence**:
```python
for k in range(i+1, j):
    dp[i][j] = max(dp[i][j], 
                   nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])
```

**Critical Trick**: Add 1 at both ends of array!

```python
def maxCoins(nums):
    # Add 1 at both ends
    nums = [1] + nums + [1]
    n = len(nums)
    
    # dp[i][j] = max coins bursting balloons in open interval (i, j)
    dp = [[0] * n for _ in range(n)]
    
    # Iterate by length of interval
    for length in range(2, n):
        for i in range(n - length):
            j = i + length
            
            # Try bursting each balloon k last in (i, j)
            for k in range(i + 1, j):
                coins = nums[i] * nums[k] * nums[j]
                total = coins + dp[i][k] + dp[k][j]
                dp[i][j] = max(dp[i][j], total)
    
    return dp[0][n - 1]

# Memoization approach
from functools import cache

def maxCoins_memo(nums):
    nums = [1] + nums + [1]
    
    @cache
    def dp(i, j):
        # Base case: no balloons to burst
        if i + 1 == j:
            return 0
        
        max_coins = 0
        for k in range(i + 1, j):
            coins = nums[i] * nums[k] * nums[j]
            max_coins = max(max_coins, coins + dp(i, k) + dp(k, j))
        
        return max_coins
    
    return dp(0, len(nums) - 1)

# Test
print(maxCoins([3, 1, 5, 8]))  # 167
```

**Visualization for [3, 1, 5, 8]**:
```
After adding 1s: [1, 3, 1, 5, 8, 1]

Optimal sequence (burst last to first):
1. Burst balloon with 1 (between 3 and 5): 3*1*5 = 15
2. Burst balloon with 3 (between 1 and 5): 1*3*5 = 15  
3. Burst balloon with 5 (between 1 and 8): 1*5*8 = 40
4. Burst balloon with 8 (between 1 and 1): 1*8*1 = 8

But we think BACKWARDS! Which to burst LAST?
```

**Complexity**:
- Time: O(n³)
- Space: O(n²)

---

### 7.2.2 Minimum Cost Tree From Leaf Values

**Problem**: Given array, build binary tree where each non-leaf node's value is product of largest leaf values in left and right subtrees. Minimize sum of non-leaf node values.

**LeetCode**: #1130

#### Analysis

**State**: `dp[i][j]` = minimum sum of non-leaf nodes for subarray `arr[i...j]`

**Recurrence**: Try all possible ways to split interval
```python
for k in range(i, j):
    # Split at k: [i...k] and [k+1...j]
    cost = max(arr[i:k+1]) * max(arr[k+1:j+1])
    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cost)
```

```python
def mctFromLeafValues(arr):
    n = len(arr)
    
    # Precompute max in each range for efficiency
    max_val = [[0] * n for _ in range(n)]
    for i in range(n):
        max_val[i][i] = arr[i]
        for j in range(i + 1, n):
            max_val[i][j] = max(max_val[i][j-1], arr[j])
    
    # dp[i][j] = min sum for subarray [i, j]
    dp = [[float('inf')] * n for _ in range(n)]
    
    # Base case: single element (leaf node, no non-leaf nodes)
    for i in range(n):
        dp[i][i] = 0
    
    # Fill by length
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            
            # Try all split points
            for k in range(i, j):
                cost = max_val[i][k] * max_val[k+1][j]
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cost)
    
    return dp[0][n-1]

# Optimized with memoization
from functools import cache

def mctFromLeafValues_memo(arr):
    @cache
    def dp(i, j):
        if i == j:
            return 0
        
        min_sum = float('inf')
        for k in range(i, j):
            left_max = max(arr[i:k+1])
            right_max = max(arr[k+1:j+1])
            cost = left_max * right_max
            min_sum = min(min_sum, dp(i, k) + dp(k, j) + cost)
        
        return min_sum
    
    return dp(0, len(arr) - 1)

# Test
print(mctFromLeafValues([6, 2, 4]))  # 32
# Tree structure: (6*4) + (2*4) = 24 + 8 = 32
```

**Complexity**:
- Time: O(n³)
- Space: O(n²)

---

### 7.2.3 Remove Boxes

**Problem**: Boxes in a row with colors. Remove boxes to get points. When you remove k consecutive boxes of same color, you get `k*k` points. Maximize total points.

**LeetCode**: #546

#### Analysis

This is a **hard** problem! The state needs an extra dimension.

**State**: `dp[i][j][k]` = max points removing boxes[i...j], where there are k boxes of same color as boxes[i] before index i.

**Key Insight**: When we have boxes of same color separated, we want to remove middle boxes first to merge them!

```python
def removeBoxes(boxes):
    from functools import cache
    
    @cache
    def dp(i, j, k):
        # Base case
        if i > j:
            return 0
        
        # Optimize: merge consecutive same-color boxes
        while i < j and boxes[i] == boxes[i+1]:
            i += 1
            k += 1
        
        # Option 1: Remove boxes[i] along with k same-color boxes before it
        result = (k + 1) * (k + 1) + dp(i + 1, j, 0)
        
        # Option 2: Try to merge boxes[i] with later same-color boxes
        for m in range(i + 1, j + 1):
            if boxes[m] == boxes[i]:
                # Remove boxes between i and m first
                # Then boxes[i] merges with boxes[m]
                result = max(result, 
                           dp(i + 1, m - 1, 0) + dp(m, j, k + 1))
        
        return result
    
    return dp(0, len(boxes) - 1, 0)

# Test
print(removeBoxes([1, 3, 2, 2, 2, 3, 4, 3, 1]))  # 23
```

**Example walkthrough**:
```
[1, 3, 2, 2, 2, 3, 4, 3, 1]

Optimal strategy:
1. Remove [2,2,2] → 3*3 = 9 points
   Remaining: [1, 3, 3, 4, 3, 1]
2. Remove [4] → 1*1 = 1 point
   Remaining: [1, 3, 3, 3, 1]
3. Remove [3,3,3] → 3*3 = 9 points
   Remaining: [1, 1]
4. Remove [1,1] → 2*2 = 4 points

Total: 9 + 1 + 9 + 4 = 23
```

**Complexity**:
- Time: O(n⁴) - three dimensions plus inner loop
- Space: O(n³)

---

## 7.3 Matrix Chain Multiplication Family

### 7.3.1 Matrix Chain Multiplication

**Problem**: Given dimensions of n matrices, find optimal order to multiply them to minimize total scalar multiplications.

**Classic DP Problem** (often in textbooks)

#### Analysis

**State**: `dp[i][j]` = minimum multiplications to multiply matrices from i to j

**Recurrence**:
```python
for k in range(i, j):
    # Split at k: multiply (M[i]...M[k]) with (M[k+1]...M[j])
    cost = dp[i][k] + dp[k+1][j] + dims[i-1] * dims[k] * dims[j]
    dp[i][j] = min(dp[i][j], cost)
```

```python
def matrixChainMultiplication(dims):
    """
    dims[i] = dimensions of matrix i
    Matrix i has dimensions dims[i-1] x dims[i]
    """
    n = len(dims) - 1  # Number of matrices
    
    # dp[i][j] = min cost to multiply matrices i to j (1-indexed)
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    
    # Length of chain
    for length in range(2, n + 1):
        for i in range(1, n - length + 2):
            j = i + length - 1
            dp[i][j] = float('inf')
            
            # Try all split points
            for k in range(i, j):
                # Cost to multiply (i..k) and (k+1..j)
                cost = (dp[i][k] + dp[k+1][j] + 
                       dims[i-1] * dims[k] * dims[j])
                dp[i][j] = min(dp[i][j], cost)
    
    return dp[1][n]

# Test
# Matrices: A(10x20), B(20x30), C(30x40), D(40x30)
dims = [10, 20, 30, 40, 30]
print(matrixChainMultiplication(dims))  # 30000

# Optimal: ((A*B)*C)*D
# (A*B): 10*20*30 = 6000
# ((A*B)*C): 10*30*40 = 12000  
# (((A*B)*C)*D): 10*40*30 = 12000
# Total: 30000
```

---

### 7.3.2 Minimum Score Triangulation of Polygon

**Problem**: Convex polygon with n vertices. Triangulate it. Each triangle has score = product of its vertex values. Minimize total score.

**LeetCode**: #1039

#### Analysis

This is similar to matrix chain multiplication!

**State**: `dp[i][j]` = min score to triangulate polygon from vertex i to j

```python
def minScoreTriangulation(values):
    n = len(values)
    dp = [[0] * n for _ in range(n)]
    
    # Length of chain (at least 3 vertices for triangle)
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            dp[i][j] = float('inf')
            
            # Try vertex k as third vertex of triangle
            for k in range(i + 1, j):
                # Triangle (i, k, j) + triangulate (i, k) and (k, j)
                score = values[i] * values[k] * values[j]
                dp[i][j] = min(dp[i][j], 
                              dp[i][k] + dp[k][j] + score)
    
    return dp[0][n - 1]

# Test
print(minScoreTriangulation([1, 2, 3]))  # 6 (only one triangle)
print(minScoreTriangulation([3, 7, 4, 5]))  # 144
# Optimal: triangles (0,1,2) and (0,2,3)
# Score: 3*7*4 + 3*4*5 = 84 + 60 = 144
```

---

## 7.4 String Palindrome Partitioning

### 7.4.1 Palindrome Removal

**Problem**: Remove palindromic subsequences to empty string. Find minimum number of steps.

**LeetCode**: #1246 (Hard)

#### Analysis

**State**: `dp[i][j]` = min removals to remove substring s[i...j]

**Key Insight**: 
- If s[i] == s[j], might be able to remove together
- Otherwise, split and solve independently

```python
def minimumMoves(arr):
    n = len(arr)
    dp = [[0] * n for _ in range(n)]
    
    # Base case: single element
    for i in range(n):
        dp[i][i] = 1
    
    # Fill by length
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            
            # Worst case: remove each element separately
            dp[i][j] = 1 + dp[i+1][j]
            
            # Try to match arr[i] with arr[k] where i < k <= j
            for k in range(i + 1, j + 1):
                if arr[i] == arr[k]:
                    # Two cases:
                    # 1. Everything between i and k is already removed
                    # 2. Remove i and k together
                    if k == i + 1:
                        dp[i][j] = min(dp[i][j], 1 + dp[k+1][j] if k < j else 1)
                    else:
                        cost = dp[i+1][k-1] + (1 if k == j else dp[k+1][j])
                        dp[i][j] = min(dp[i][j], cost)
    
    return dp[0][n-1]

# Cleaner version
def minimumMoves_v2(arr):
    n = len(arr)
    dp = [[n] * n for _ in range(n)]
    
    for i in range(n):
        dp[i][i] = 1
    
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            
            if arr[i] == arr[j]:
                if length == 2:
                    dp[i][j] = 1
                else:
                    dp[i][j] = dp[i+1][j-1]
            
            for k in range(i, j):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
    
    return dp[0][n-1]

# Test
print(minimumMoves([1, 2]))        # 2
print(minimumMoves([1, 3, 4, 1, 5]))  # 3
```

---

## 7.5 Key Techniques and Patterns

### Pattern 1: Which Operation Last?

**Critical Insight**: Instead of thinking "what to do first", think "what to do last"!

```python
# Burst Balloons: Which balloon to burst LAST?
# Matrix Multiplication: Which multiplication to do LAST?
# Triangulation: Which edge to add LAST?
```

### Pattern 2: Precomputation

```python
# Precompute range queries for efficiency
max_in_range = [[0] * n for _ in range(n)]
for i in range(n):
    max_in_range[i][i] = arr[i]
    for j in range(i + 1, n):
        max_in_range[i][j] = max(max_in_range[i][j-1], arr[j])
```

### Pattern 3: Extended State

Some problems need extra dimensions:
```python
# Remove Boxes: dp[i][j][k]
# k = number of same-color boxes before i
```

### Pattern 4: Splitting Intervals

```python
# Standard split pattern
for length in range(2, n + 1):
    for i in range(n - length + 1):
        j = i + length - 1
        for k in range(i, j):
            # Combine solutions from [i, k] and [k+1, j]
            dp[i][j] = optimize(dp[i][j], 
                               dp[i][k] + dp[k+1][j] + cost(i, k, j))
```

---

## 7.6 Optimization Strategies

### Strategy 1: Memoization vs Tabulation

```python
# Tabulation: Better for complete DP table
for length in range(...):
    for i in range(...):
        # Build bottom-up

# Memoization: Better when only need specific subproblems
@cache
def dp(i, j):
    # Top-down with caching
```

### Strategy 2: Reduce State Space

```python
# Sometimes can reduce dimensions
# From dp[i][j][k] to dp[i][j] with clever state definition
```

### Strategy 3: Monotonic Stack/Queue

For some interval problems, can use data structures:
```python
# When ranges have monotonic properties
# Use stack/queue to optimize inner loop from O(n) to O(1)
```

---

## Common Pitfalls

### Pitfall 1: Wrong Iteration Order
```python
# WRONG: Small to large i, then j
for i in range(n):
    for j in range(i, n):  # Can't use dp[i][k] and dp[k+1][j]!

# CORRECT: By length
for length in range(2, n + 1):
    for i in range(n - length + 1):
        j = i + length - 1
```

### Pitfall 2: Off-by-One Errors
```python
# Be careful with:
- Open vs closed intervals
- 0-indexed vs 1-indexed
- Range boundaries in split
```

### Pitfall 3: Missing Edge Cases
```python
# Always handle:
- Single element intervals
- Adjacent elements
- Full array
```

---

## Practice Problems Summary

### Beginner
1. Minimum Cost Tree From Leaf Values (#1130)
2. Minimum Score Triangulation (#1039)
3. Matrix Chain Multiplication (Classic)

### Intermediate
4. Burst Balloons (#312)
5. Strange Printer (#664)
6. Palindrome Removal (#1246)

### Advanced
7. Remove Boxes (#546)
8. Minimum Cost to Merge Stones (#1000)
9. Encode String with Shortest Length (#471)

---

## Key Takeaways

1. **Interval DP = O(n³)** complexity is typical
2. **Think BACKWARDS**: Which operation to do LAST?
3. **Iteration order matters**: Build from small intervals to large
4. **State often needs context**: Extra dimensions for additional info
5. **Precomputation helps**: Range max/min queries
6. **Split point selection**: Try all possible ways to split interval
7. **Base cases**: Single elements and adjacent pairs
8. **Optimization**: Memoization when not all states needed

Interval DP is challenging but appears in many optimization problems. The key is recognizing when to apply it and mastering the "last operation" thinking pattern!