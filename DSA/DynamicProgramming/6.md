# Chapter 6: Pattern 5 - Knapsack Problems

## Overview

Knapsack problems involve selecting items to maximize/minimize value under constraints. This is one of the **most important** DP patterns in computer science and appears frequently in interviews.

**Pattern Recognition**:
- Given items with weights/values
- Limited capacity/budget
- Maximize value or minimize cost
- Can/cannot reuse items
- Count number of ways to achieve target

---

## 6.1 0/1 Knapsack (Classic)

### 6.1.1 Basic Problem

**Problem**: Given n items with weights and values, and a knapsack with capacity W, select items to maximize total value. Each item can be used at most once.

#### Analysis

**State**: `dp[i][w]` = maximum value using first i items with capacity w

**Recurrence**:
```python
if weight[i-1] <= w:
    # Can choose to take or not take item i
    dp[i][w] = max(
        dp[i-1][w],                              # Don't take
        values[i-1] + dp[i-1][w - weights[i-1]]  # Take
    )
else:
    # Can't take item (too heavy)
    dp[i][w] = dp[i-1][w]
```

**Base Cases**: `dp[0][w] = 0` for all w (no items = 0 value)

```python
# Approach 1: 2D DP
def knapsack_01(weights, values, capacity):
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            if weights[i-1] <= w:
                dp[i][w] = max(
                    dp[i-1][w],
                    values[i-1] + dp[i-1][w - weights[i-1]]
                )
            else:
                dp[i][w] = dp[i-1][w]
    
    return dp[n][capacity]

# Test
weights = [1, 3, 4, 5]
values = [1, 4, 5, 7]
capacity = 7
print(knapsack_01(weights, values, capacity))  # 9 (items 2 and 3: value=4+5)
```

**Visualization**:
```
Items: [(w=1,v=1), (w=3,v=4), (w=4,v=5), (w=5,v=7)]
Capacity = 7

       w=0  1  2  3  4  5  6  7
i=0     0   0  0  0  0  0  0  0
i=1     0   1  1  1  1  1  1  1  (item 1: w=1,v=1)
i=2     0   1  1  4  5  5  5  5  (item 2: w=3,v=4)
i=3     0   1  1  4  5  6  6  9  (item 3: w=4,v=5)
i=4     0   1  1  4  5  7  8  9  (item 4: w=5,v=7)

Max value = 9
```

---

### 6.1.2 Space Optimized 0/1 Knapsack

**Key Insight**: Only need previous row, can use 1D array!

**CRITICAL**: Must iterate capacity in **REVERSE** to avoid overwriting needed values!

```python
def knapsack_01_optimized(weights, values, capacity):
    n = len(weights)
    dp = [0] * (capacity + 1)
    
    for i in range(n):
        # MUST iterate backwards!
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], values[i] + dp[w - weights[i]])
    
    return dp[capacity]

# Why backwards? Example:
# Forward iteration (WRONG):
# dp[3] = max(dp[3], val + dp[0])  # Uses new dp[0]!
# dp[6] = max(dp[6], val + dp[3])  # Uses new dp[3]! (double counting)

# Backward iteration (CORRECT):
# dp[6] = max(dp[6], val + dp[3])  # Uses old dp[3]
# dp[3] = max(dp[3], val + dp[0])  # Uses old dp[0]

# Test
weights = [1, 3, 4, 5]
values = [1, 4, 5, 7]
capacity = 7
print(knapsack_01_optimized(weights, values, capacity))  # 9
```

**Complexity**:
- Time: O(n × W)
- Space: O(W) instead of O(n × W)

---

### 6.1.3 Reconstructing the Solution

```python
def knapsack_with_items(weights, values, capacity):
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    # Build DP table
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            if weights[i-1] <= w:
                dp[i][w] = max(
                    dp[i-1][w],
                    values[i-1] + dp[i-1][w - weights[i-1]]
                )
            else:
                dp[i][w] = dp[i-1][w]
    
    # Backtrack to find items
    selected = []
    i, w = n, capacity
    
    while i > 0 and w > 0:
        # If value came from taking item i
        if dp[i][w] != dp[i-1][w]:
            selected.append(i - 1)  # Item index
            w -= weights[i-1]
        i -= 1
    
    return dp[n][capacity], selected[::-1]

# Test
weights = [1, 3, 4, 5]
values = [1, 4, 5, 7]
capacity = 7
max_val, items = knapsack_with_items(weights, values, capacity)
print(f"Max value: {max_val}, Items: {items}")  # Max value: 9, Items: [1, 2]
```

---

## 6.2 Variations of Knapsack

### 6.2.1 Unbounded Knapsack

**Problem**: Each item can be used unlimited times.

**LeetCode**: Related to #322, #518

**Key Difference**: Can reuse items, so iterate capacity **FORWARD**!

```python
def knapsack_unbounded(weights, values, capacity):
    dp = [0] * (capacity + 1)
    
    for i in range(len(weights)):
        # Iterate FORWARD for unbounded
        for w in range(weights[i], capacity + 1):
            dp[w] = max(dp[w], values[i] + dp[w - weights[i]])
    
    return dp[capacity]

# Alternative: Items in outer loop
def knapsack_unbounded_v2(weights, values, capacity):
    dp = [0] * (capacity + 1)
    
    for w in range(1, capacity + 1):
        for i in range(len(weights)):
            if weights[i] <= w:
                dp[w] = max(dp[w], values[i] + dp[w - weights[i]])
    
    return dp[capacity]

# Test
weights = [1, 3, 4, 5]
values = [1, 4, 5, 7]
capacity = 7
print(knapsack_unbounded(weights, values, capacity))  # 10 (item 2 twice + item 1)
```

---

### 6.2.2 Coin Change (Minimum Coins)

**Problem**: Given coins of different denominations and amount, find minimum coins needed.

**LeetCode**: #322

#### Analysis

This is **unbounded knapsack minimization**!

**State**: `dp[i]` = minimum coins needed for amount i

**Recurrence**:
```python
dp[i] = min(dp[i], dp[i - coin] + 1) for all coins <= i
```

```python
def coinChange(coins, amount):
    # Initialize with infinity (impossible)
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # 0 coins for amount 0
    
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1

# Alternative: Amount in outer loop
def coinChange_v2(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1

# Test
print(coinChange([1, 2, 5], 11))  # 3 (5 + 5 + 1)
print(coinChange([2], 3))         # -1 (impossible)
print(coinChange([1], 0))         # 0
```

**Visualization for coins=[1,2,5], amount=11**:
```
Amount:  0  1  2  3  4  5  6  7  8  9  10  11
Coins:   0  1  1  2  2  1  2  2  3  3  2   3

Explanation:
- Amount 11 = 5 + 5 + 1 (3 coins)
- Or: 5 + 5 + 1
```

---

### 6.2.3 Coin Change II (Number of Ways)

**Problem**: Count number of ways to make amount using given coins.

**LeetCode**: #518

#### Analysis

**Critical**: Order doesn't matter! [1,2] and [2,1] are the same way.

**State**: `dp[i]` = number of ways to make amount i

**Recurrence**: `dp[i] += dp[i - coin]`

**Important**: To avoid counting duplicates, iterate coins in outer loop!

```python
def change(amount, coins):
    dp = [0] * (amount + 1)
    dp[0] = 1  # One way to make 0: use no coins
    
    # MUST iterate coins in OUTER loop to avoid duplicates!
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] += dp[i - coin]
    
    return dp[amount]

# WRONG approach (counts duplicates):
def change_wrong(amount, coins):
    dp = [0] * (amount + 1)
    dp[0] = 1
    
    # This counts [1,2] and [2,1] as different!
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i:
                dp[i] += dp[i - coin]
    
    return dp[amount]

# Test
print(change(5, [1, 2, 5]))  # 4 ways: [5], [2,2,1], [2,1,1,1], [1,1,1,1,1]
print(change(3, [2]))        # 0 (impossible)
print(change(10, [10]))      # 1
```

**Why coin order matters**:
```
Correct (coins outer):
coin=1: dp updates for all amounts using coin 1
coin=2: dp updates for all amounts using coins 1,2
coin=5: dp updates for all amounts using coins 1,2,5

Wrong (amount outer):
amount=3: dp[3] += dp[2] (coin 1) + dp[1] (coin 2)
This counts [1,2] when processing amount 3
AND [2,1] when processing amount 3 separately!
```

---

### 6.2.4 Perfect Squares

**Problem**: Find minimum number of perfect squares that sum to n.

**LeetCode**: #279

#### Analysis

This is unbounded knapsack where "coins" are perfect squares!

```python
def numSquares(n):
    # Create list of perfect squares up to n
    squares = [i * i for i in range(1, int(n**0.5) + 1)]
    
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    
    for square in squares:
        for i in range(square, n + 1):
            dp[i] = min(dp[i], dp[i - square] + 1)
    
    return dp[n]

# Optimized version
def numSquares_optimized(n):
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    
    for i in range(1, n + 1):
        j = 1
        while j * j <= i:
            dp[i] = min(dp[i], dp[i - j*j] + 1)
            j += 1
    
    return dp[n]

# Test
print(numSquares(12))  # 3 (4 + 4 + 4)
print(numSquares(13))  # 2 (4 + 9)
```

---

## 6.3 Subset Problems

### 6.3.1 Partition Equal Subset Sum

**Problem**: Can array be partitioned into two subsets with equal sum?

**LeetCode**: #416

#### Analysis

**Key Insight**: If total sum is odd, impossible! If even, find subset with sum = total/2.

This is **0/1 knapsack decision problem** (can we achieve target?)

**State**: `dp[i]` = True if sum i is achievable

```python
def canPartition(nums):
    total = sum(nums)
    
    # Odd sum can't be split equally
    if total % 2 == 1:
        return False
    
    target = total // 2
    dp = [False] * (target + 1)
    dp[0] = True  # Sum 0 is always achievable
    
    for num in nums:
        # Iterate backwards (0/1 knapsack)
        for i in range(target, num - 1, -1):
            dp[i] = dp[i] or dp[i - num]
    
    return dp[target]

# Alternative with early termination
def canPartition_optimized(nums):
    total = sum(nums)
    if total % 2 == 1:
        return False
    
    target = total // 2
    dp = {0}  # Use set for faster lookup
    
    for num in nums:
        # Create new set to avoid modification during iteration
        new_sums = set()
        for s in dp:
            new_sum = s + num
            if new_sum == target:
                return True
            if new_sum < target:
                new_sums.add(new_sum)
        dp.update(new_sums)
    
    return target in dp

# Test
print(canPartition([1, 5, 11, 5]))  # True ([1,5,5] and [11])
print(canPartition([1, 2, 3, 5]))   # False
```

---

### 6.3.2 Target Sum

**Problem**: Assign + or - to each number to make sum equal target. Count ways.

**LeetCode**: #494

#### Analysis

**Mathematical Transformation**:
```
Let P = sum of positive numbers, N = sum of negative numbers
P - N = target
P + N = sum(nums)

Therefore: P = (target + sum) / 2
```

Problem reduces to: **Count subsets with sum = (target + sum) / 2**

```python
def findTargetSumWays(nums, target):
    total = sum(nums)
    
    # Check if solution is possible
    if total < abs(target) or (total + target) % 2 == 1:
        return 0
    
    subset_sum = (total + target) // 2
    
    # Count subsets with given sum
    dp = [0] * (subset_sum + 1)
    dp[0] = 1  # One way to make sum 0
    
    for num in nums:
        for i in range(subset_sum, num - 1, -1):
            dp[i] += dp[i - num]
    
    return dp[subset_sum]

# 2D approach (clearer logic)
def findTargetSumWays_2d(nums, target):
    total = sum(nums)
    if total < abs(target) or (total + target) % 2 == 1:
        return 0
    
    subset_sum = (total + target) // 2
    n = len(nums)
    
    # dp[i][j] = ways to make sum j using first i numbers
    dp = [[0] * (subset_sum + 1) for _ in range(n + 1)]
    dp[0][0] = 1
    
    for i in range(1, n + 1):
        for j in range(subset_sum + 1):
            dp[i][j] = dp[i-1][j]  # Don't include nums[i-1]
            if j >= nums[i-1]:
                dp[i][j] += dp[i-1][j - nums[i-1]]  # Include nums[i-1]
    
    return dp[n][subset_sum]

# Test
print(findTargetSumWays([1, 1, 1, 1, 1], 3))  # 5
# Ways: +1+1+1+1-1, +1+1+1-1+1, +1+1-1+1+1, +1-1+1+1+1, -1+1+1+1+1
```

---

### 6.3.3 Last Stone Weight II

**Problem**: Smash stones together. Stone weights are reduced by smaller stone. Minimize final stone weight.

**LeetCode**: #1049

#### Analysis

**Key Insight**: This is really asking to partition into two groups such that difference is minimized!

```
Minimize: |sum(group1) - sum(group2)|
```

This reduces to: Find subset closest to sum/2

```python
def lastStoneWeightII(stones):
    total = sum(stones)
    target = total // 2
    
    # Find maximum sum <= target that's achievable
    dp = [False] * (target + 1)
    dp[0] = True
    
    for stone in stones:
        for i in range(target, stone - 1, -1):
            dp[i] = dp[i] or dp[i - stone]
    
    # Find largest achievable sum <= target
    for i in range(target, -1, -1):
        if dp[i]:
            return total - 2 * i

# Alternative: Track all possible sums
def lastStoneWeightII_v2(stones):
    possible_sums = {0}
    
    for stone in stones:
        new_sums = set()
        for s in possible_sums:
            new_sums.add(s + stone)
            new_sums.add(abs(s - stone))
        possible_sums = new_sums
    
    return min(possible_sums)

# Test
print(lastStoneWeightII([2, 7, 4, 1, 8, 1]))  # 1
# Optimal partition: [8,7] vs [4,2,1,1] → 15 vs 8 → difference = 7... wait
# Actually: Find subset closest to sum/2 = 23/2 = 11.5
# Best subset sum = 11 → Other side = 12 → Difference = 1
```

---

## 6.4 Multiple Constraints Knapsack

### 6.4.1 Ones and Zeroes

**Problem**: Array of binary strings. Find max subset size where you have at most m zeros and n ones.

**LeetCode**: #474

#### Analysis

This is **2D knapsack** with two capacity constraints!

**State**: `dp[i][j]` = max strings using at most i zeros and j ones

```python
def findMaxForm(strs, m, n):
    # dp[zeros][ones] = max number of strings
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for s in strs:
        zeros = s.count('0')
        ones = s.count('1')
        
        # Iterate backwards (0/1 knapsack)
        for i in range(m, zeros - 1, -1):
            for j in range(n, ones - 1, -1):
                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)
    
    return dp[m][n]

# Test
strs = ["10", "0001", "111001", "1", "0"]
m, n = 5, 3
print(findMaxForm(strs, m, n))  # 4 (strings: "10","0001","1","0")
```

**Visualization**:
```
Strings with (zeros, ones):
"10" → (1, 1)
"0001" → (3, 1)
"111001" → (2, 4)
"1" → (0, 1)
"0" → (1, 0)

With m=5, n=3:
Can take: "10", "0001", "1", "0"
Uses: 1+3+0+1=5 zeros, 1+1+1+0=3 ones
```

---

## Key Patterns Summary

### Pattern Recognition Guide

| Problem Type | Loop Order | Iteration Direction | Example |
|--------------|------------|---------------------|---------|
| 0/1 Knapsack | Items outer | Capacity backward | Subset Sum |
| Unbounded | Items outer | Capacity forward | Coin Change |
| Combination | Items outer | Capacity forward | Coin Change II |
| Permutation | Capacity outer | Items any | (Rare) |

### Template Comparison

```python
# 0/1 Knapsack (each item once)
for item in items:
    for capacity in range(W, weight-1, -1):  # BACKWARD
        dp[capacity] = max(dp[capacity], dp[capacity-weight] + value)

# Unbounded Knapsack (items unlimited)
for item in items:
    for capacity in range(weight, W+1):  # FORWARD
        dp[capacity] = max(dp[capacity], dp[capacity-weight] + value)

# Combination Sum (order doesn't matter)
for item in items:  # Items OUTER
    for capacity in range(weight, W+1):
        dp[capacity] += dp[capacity-weight]

# Permutation Sum (order matters)
for capacity in range(1, W+1):  # Capacity OUTER
    for item in items:
        if weight <= capacity:
            dp[capacity] += dp[capacity-weight]
```

---

## Important Notes

### Note 1: Why Backward for 0/1?
```python
# Forward (WRONG - can use item multiple times):
dp[3] = val + dp[0]  # Uses original dp[0]
dp[6] = val + dp[3]  # Uses UPDATED dp[3]! (item used twice)

# Backward (CORRECT):
dp[6] = val + dp[3]  # Uses original dp[3]
dp[3] = val + dp[0]  # Doesn't affect dp[6]
```

### Note 2: Combination vs Permutation
```python
# Combination: [1,2] same as [2,1]
# Items in OUTER loop
for coin in coins:
    for amount in range(coin, target+1):
        dp[amount] += dp[amount-coin]

# Permutation: [1,2] different from [2,1]
# Amount in OUTER loop
for amount in range(1, target+1):
    for coin in coins:
        if coin <= amount:
            dp[amount] += dp[amount-coin]
```

### Note 3: Minimization vs Maximization
```python
# Maximization: Initialize with 0
dp = [0] * (capacity + 1)

# Minimization: Initialize with infinity
dp = [float('inf')] * (capacity + 1)
dp[0] = 0  # Base case
```

---

## Practice Problems Summary

### Beginner
1. Partition Equal Subset Sum (#416)
2. Coin Change (#322)
3. Perfect Squares (#279)

### Intermediate
4. Coin Change II (#518)
5. Target Sum (#494)
6. Last Stone Weight II (#1049)

### Advanced
7. Ones and Zeroes (#474)
8. Profitable Schemes (#879)
9. Number of Dice Rolls With Target Sum (#1155)

---

## Key Takeaways

1. **0/1 Knapsack**: Backward iteration, each item once
2. **Unbounded**: Forward iteration, items unlimited
3. **Combination**: Items in outer loop (avoid duplicates)
4. **Permutation**: Capacity in outer loop (allow different orders)
5. **Space Optimization**: Always possible to O(capacity)
6. **Subset Sum**: Boolean DP (achievable or not)
7. **Count Ways**: Addition instead of max/min
8. **Mathematical Transform**: Sometimes reduces problem complexity

Master knapsack patterns - they're the foundation for many optimization problems!