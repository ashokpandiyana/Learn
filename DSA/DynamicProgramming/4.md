# Chapter 4: Pattern 3 - Subsequence DP

## Overview

Subsequence DP problems involve finding optimal or counting subsequences in one or more sequences. A **subsequence** maintains the relative order of elements but doesn't need to be contiguous.

**Key Difference**:
- **Subarray**: Contiguous elements [a, b, c]
- **Subsequence**: Non-contiguous but ordered [a, _, c, _, e]

**Pattern Recognition**:
- Problems involving two strings/arrays comparison
- Finding longest/shortest subsequence with properties
- Counting number of subsequences
- String transformation problems

---

## 4.1 Longest Common Subsequence (LCS) Family

### 4.1.1 Classic LCS

**Problem**: Given two strings, find the length of their longest common subsequence.

**LeetCode**: #1143

#### Analysis

**State**: `dp[i][j]` = length of LCS of `s1[0...i-1]` and `s2[0...j-1]`

**Recurrence**:
```python
if s1[i-1] == s2[j-1]:
    dp[i][j] = dp[i-1][j-1] + 1  # Characters match, extend LCS
else:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])  # Skip one character
```

**Base Cases**: `dp[0][j] = 0` and `dp[i][0] = 0` (empty string has LCS of 0)

**Visualization for "abcde" and "ace"**:
```
       ""  a  c  e
    "" 0   0  0  0
    a  0   1  1  1
    b  0   1  1  1
    c  0   1  2  2
    d  0   1  2  2
    e  0   1  2  3

LCS = "ace" with length 3
```

```python
# Approach 1: 2D Tabulation
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]

# Approach 2: Space Optimized (1D)
def longestCommonSubsequence_optimized(text1, text2):
    m, n = len(text1), len(text2)
    # Keep only previous row
    dp = [0] * (n + 1)
    
    for i in range(1, m + 1):
        prev = 0  # This is dp[i-1][j-1]
        for j in range(1, n + 1):
            temp = dp[j]
            if text1[i-1] == text2[j-1]:
                dp[j] = prev + 1
            else:
                dp[j] = max(dp[j], dp[j-1])
            prev = temp
    
    return dp[n]

# Approach 3: Memoization (Top-Down)
from functools import cache

def longestCommonSubsequence_memo(text1, text2):
    @cache
    def dp(i, j):
        # Base case: reached end of either string
        if i == len(text1) or j == len(text2):
            return 0
        
        # Characters match
        if text1[i] == text2[j]:
            return 1 + dp(i + 1, j + 1)
        
        # Characters don't match: try both options
        return max(dp(i + 1, j), dp(i, j + 1))
    
    return dp(0, 0)

# Test
print(longestCommonSubsequence("abcde", "ace"))  # 3
print(longestCommonSubsequence("abc", "abc"))    # 3
print(longestCommonSubsequence("abc", "def"))    # 0
```

#### How to Reconstruct the LCS (Not Just Length)

```python
def getLCS(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Fill DP table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    # Backtrack to find actual LCS
    lcs = []
    i, j = m, n
    
    while i > 0 and j > 0:
        if text1[i-1] == text2[j-1]:
            lcs.append(text1[i-1])
            i -= 1
            j -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            i -= 1
        else:
            j -= 1
    
    return ''.join(reversed(lcs))

# Test
print(getLCS("abcde", "ace"))  # "ace"
```

**Complexity**:
- Time: O(m × n)
- Space: O(m × n) for 2D, O(n) for optimized

---

### 4.1.2 Longest Palindromic Subsequence

**Problem**: Find the length of the longest palindromic subsequence in a string.

**LeetCode**: #516

#### Analysis

**Key Insight**: A palindrome reads the same forwards and backwards!

**Solution**: LPS of string `s` = LCS of `s` and `reverse(s)`

**Why?** If a subsequence appears in both `s` and `reverse(s)`, it must be palindromic!

```python
# Method 1: Using LCS
def longestPalindromeSubseq_lcs(s):
    return longestCommonSubsequence(s, s[::-1])

# Method 2: Direct DP (More Efficient)
def longestPalindromeSubseq(s):
    n = len(s)
    # dp[i][j] = LPS length in substring s[i...j]
    dp = [[0] * n for _ in range(n)]
    
    # Every single character is a palindrome of length 1
    for i in range(n):
        dp[i][i] = 1
    
    # Build table for substrings of increasing length
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    
    return dp[0][n-1]

# Test
print(longestPalindromeSubseq("bbbab"))  # 4 ("bbbb")
print(longestPalindromeSubseq("cbbd"))   # 2 ("bb")
```

**Visualization for "bbbab"**:
```
       b  b  b  a  b
    b  1  2  3  3  4
    b     1  2  2  3
    b        1  1  3
    a           1  1
    b              1

dp[0][4] = 4 (subsequence "bbbb")
```

---

### 4.1.3 Shortest Common Supersequence

**Problem**: Find the length of the shortest string that has both `str1` and `str2` as subsequences.

**LeetCode**: #1092

#### Analysis

**Key Insight**: 
```
SCS length = len(str1) + len(str2) - LCS(str1, str2)
```

**Why?** 
- Total characters needed: len(str1) + len(str2)
- But common characters (LCS) are counted twice
- Subtract LCS once!

**To construct the actual SCS**: Merge both strings, using LCS as guide

```python
def shortestCommonSupersequence(str1, str2):
    m, n = len(str1), len(str2)
    
    # Build LCS table
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    # Reconstruct SCS by backtracking
    scs = []
    i, j = m, n
    
    while i > 0 and j > 0:
        if str1[i-1] == str2[j-1]:
            # Part of LCS - add once
            scs.append(str1[i-1])
            i -= 1
            j -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            # Not in LCS - add from str1
            scs.append(str1[i-1])
            i -= 1
        else:
            # Not in LCS - add from str2
            scs.append(str2[j-1])
            j -= 1
    
    # Add remaining characters
    while i > 0:
        scs.append(str1[i-1])
        i -= 1
    while j > 0:
        scs.append(str2[j-1])
        j -= 1
    
    return ''.join(reversed(scs))

# Test
print(shortestCommonSupersequence("abac", "cab"))  # "cabac"
# Both "abac" and "cab" are subsequences of "cabac"
```

---

### 4.1.4 Edit Distance (Levenshtein Distance)

**Problem**: Minimum number of operations (insert, delete, replace) to convert `word1` to `word2`.

**LeetCode**: #72

#### Analysis

**State**: `dp[i][j]` = edit distance between `word1[0...i-1]` and `word2[0...j-1]`

**Recurrence**:
```python
if word1[i-1] == word2[j-1]:
    dp[i][j] = dp[i-1][j-1]  # No operation needed
else:
    dp[i][j] = 1 + min(
        dp[i-1][j],      # Delete from word1
        dp[i][j-1],      # Insert into word1
        dp[i-1][j-1]     # Replace in word1
    )
```

**Base Cases**:
- `dp[0][j] = j` (insert j characters)
- `dp[i][0] = i` (delete i characters)

```python
def minDistance(word1, word2):
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Base cases
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
    
    # Fill table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(
                    dp[i-1][j],      # Delete
                    dp[i][j-1],      # Insert
                    dp[i-1][j-1]     # Replace
                )
    
    return dp[m][n]

# Space Optimized
def minDistance_optimized(word1, word2):
    m, n = len(word1), len(word2)
    dp = list(range(n + 1))
    
    for i in range(1, m + 1):
        prev = dp[0]
        dp[0] = i
        
        for j in range(1, n + 1):
            temp = dp[j]
            if word1[i-1] == word2[j-1]:
                dp[j] = prev
            else:
                dp[j] = 1 + min(dp[j], dp[j-1], prev)
            prev = temp
    
    return dp[n]

# Test
print(minDistance("horse", "ros"))     # 3 (horse -> rorse -> rose -> ros)
print(minDistance("intention", "execution"))  # 5
```

**Visualization for "horse" → "ros"**:
```
       ""  r  o  s
    "" 0   1  2  3
    h  1   1  2  3
    o  2   2  1  2
    r  3   2  2  2
    s  4   3  3  2
    e  5   4  4  3

Operations:
1. Replace h -> r
2. Delete o (keep)
3. Delete r (keep)
4. Keep s
5. Delete e
Result: 3 operations
```

---

### 4.1.5 Distinct Subsequences

**Problem**: Count number of distinct subsequences of `s` that equal `t`.

**LeetCode**: #115

#### Analysis

**State**: `dp[i][j]` = number of ways to form `t[0...j-1]` from `s[0...i-1]`

**Recurrence**:
```python
if s[i-1] == t[j-1]:
    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
    # Use this char + don't use this char
else:
    dp[i][j] = dp[i-1][j]  # Don't use this char
```

**Base Cases**:
- `dp[i][0] = 1` (empty string has one subsequence: empty)
- `dp[0][j] = 0` for j > 0 (can't form non-empty from empty)

```python
def numDistinct(s, t):
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Base case: empty t
    for i in range(m + 1):
        dp[i][0] = 1
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i-1] == t[j-1]:
                dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
            else:
                dp[i][j] = dp[i-1][j]
    
    return dp[m][n]

# Space Optimized
def numDistinct_optimized(s, t):
    m, n = len(s), len(t)
    dp = [0] * (n + 1)
    dp[0] = 1
    
    for i in range(1, m + 1):
        # Process from right to left to avoid overwriting
        for j in range(n, 0, -1):
            if s[i-1] == t[j-1]:
                dp[j] += dp[j-1]
    
    return dp[n]

# Test
print(numDistinct("rabbbit", "rabbit"))  # 3
# Three ways: ra(b)b(b)it, ra(bb)b(it), rab(bb)it
print(numDistinct("babgbag", "bag"))     # 5
```

**Visualization for "rabbbit" and "rabbit"**:
```
       ""  r  a  b  b  i  t
    "" 1   0  0  0  0  0  0
    r  1   1  0  0  0  0  0
    a  1   1  1  0  0  0  0
    b  1   1  1  1  0  0  0
    b  1   1  1  2  1  0  0
    b  1   1  1  3  3  0  0
    i  1   1  1  3  3  3  0
    t  1   1  1  3  3  3  3

Result: 3 distinct ways
```

---

### 4.1.6 Interleaving String

**Problem**: Check if `s3` is formed by interleaving `s1` and `s2`.

**LeetCode**: #97

#### Analysis

**State**: `dp[i][j]` = can form `s3[0...i+j-1]` using `s1[0...i-1]` and `s2[0...j-1]`

**Recurrence**:
```python
dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or
           (dp[i][j-1] and s2[j-1] == s3[i+j-1])
```

```python
def isInterleave(s1, s2, s3):
    m, n = len(s1), len(s2)
    
    if m + n != len(s3):
        return False
    
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True
    
    # Initialize first column
    for i in range(1, m + 1):
        dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]
    
    # Initialize first row
    for j in range(1, n + 1):
        dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]
    
    # Fill table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or \
                       (dp[i][j-1] and s2[j-1] == s3[i+j-1])
    
    return dp[m][n]

# Space Optimized
def isInterleave_optimized(s1, s2, s3):
    m, n = len(s1), len(s2)
    
    if m + n != len(s3):
        return False
    
    dp = [False] * (n + 1)
    dp[0] = True
    
    for j in range(1, n + 1):
        dp[j] = dp[j-1] and s2[j-1] == s3[j-1]
    
    for i in range(1, m + 1):
        dp[0] = dp[0] and s1[i-1] == s3[i-1]
        for j in range(1, n + 1):
            dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or \
                    (dp[j-1] and s2[j-1] == s3[i+j-1])
    
    return dp[n]

# Test
print(isInterleave("aabcc", "dbbca", "aadbbcbcac"))  # True
print(isInterleave("aabcc", "dbbca", "aadbbbaccc"))  # False
```

---

## 4.2 Longest Increasing Subsequence (LIS) Family

### 4.2.1 Classic LIS - O(n²) Solution

**Problem**: Find length of longest strictly increasing subsequence.

**LeetCode**: #300

#### Analysis

**State**: `dp[i]` = length of LIS ending at index i

**Recurrence**:
```python
for i in range(n):
    for j in range(i):
        if nums[j] < nums[i]:
            dp[i] = max(dp[i], dp[j] + 1)
```

```python
def lengthOfLIS_n2(nums):
    if not nums:
        return 0
    
    n = len(nums)
    dp = [1] * n  # Every element is LIS of length 1
    
    for i in range(1, n):
        for j in range(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    
    return max(dp)

# Test
print(lengthOfLIS_n2([10, 9, 2, 5, 3, 7, 101, 18]))  # 4 ([2,3,7,101])
```

**Visualization for [10, 9, 2, 5, 3, 7, 101, 18]**:
```
nums: [10, 9, 2, 5, 3, 7, 101, 18]
dp:   [ 1, 1, 1, 2, 2, 3,  4,   4]
                    ↑        ↑
                   LIS: 2,5,7,101 or 2,3,7,101
```

---

### 4.2.2 Classic LIS - O(n log n) Solution with Binary Search

**Key Insight**: Maintain array of smallest tail elements for all increasing subsequences.

```python
def lengthOfLIS(nums):
    """
    tails[i] = smallest tail element of all LIS of length i+1
    """
    from bisect import bisect_left
    
    tails = []
    
    for num in nums:
        pos = bisect_left(tails, num)
        if pos == len(tails):
            tails.append(num)
        else:
            tails[pos] = num
    
    return len(tails)

# Manual binary search version
def lengthOfLIS_manual(nums):
    def binary_search(arr, target):
        left, right = 0, len(arr)
        while left < right:
            mid = (left + right) // 2
            if arr[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left
    
    tails = []
    
    for num in nums:
        pos = binary_search(tails, num)
        if pos == len(tails):
            tails.append(num)
        else:
            tails[pos] = num
    
    return len(tails)

# Test
print(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]))  # 4
```

**How it works**:
```
nums = [10, 9, 2, 5, 3, 7, 101, 18]

Step by step:
tails = [10]
tails = [9]        (replace 10 with 9)
tails = [2]        (replace 9 with 2)
tails = [2, 5]     (append 5)
tails = [2, 3]     (replace 5 with 3)
tails = [2, 3, 7]  (append 7)
tails = [2, 3, 7, 101]  (append 101)
tails = [2, 3, 7, 18]   (replace 101 with 18)

Length = 4
```

**Complexity**: O(n log n) time, O(n) space

---

### 4.2.3 Number of LIS

**Problem**: Find number of distinct longest increasing subsequences.

**LeetCode**: #673

#### Analysis

Need TWO arrays:
- `lengths[i]` = length of LIS ending at i
- `counts[i]` = number of LIS ending at i

```python
def findNumberOfLIS(nums):
    if not nums:
        return 0
    
    n = len(nums)
    lengths = [1] * n
    counts = [1] * n
    
    for i in range(n):
        for j in range(i):
            if nums[j] < nums[i]:
                if lengths[j] + 1 > lengths[i]:
                    # Found longer LIS
                    lengths[i] = lengths[j] + 1
                    counts[i] = counts[j]
                elif lengths[j] + 1 == lengths[i]:
                    # Found another LIS of same length
                    counts[i] += counts[j]
    
    max_length = max(lengths)
    return sum(c for l, c in zip(lengths, counts) if l == max_length)

# Test
print(findNumberOfLIS([1, 3, 5, 4, 7]))  # 2 ([1,3,5,7] and [1,3,4,7])
print(findNumberOfLIS([2, 2, 2, 2, 2]))  # 5 (each single element)
```

---

### 4.2.4 Russian Doll Envelopes

**Problem**: Envelopes have (width, height). Can put envelope inside another if both dimensions are smaller. Find maximum number of envelopes you can nest.

**LeetCode**: #354

#### Analysis

**Key Insight**: This is 2D LIS!

**Strategy**:
1. Sort by width ascending, height descending
2. Find LIS on heights (using O(n log n) solution)

**Why height descending?** To prevent same-width envelopes from forming a sequence!

```python
def maxEnvelopes(envelopes):
    from bisect import bisect_left
    
    # Sort: width ascending, height descending
    envelopes.sort(key=lambda x: (x[0], -x[1]))
    
    # Find LIS on heights
    tails = []
    for _, h in envelopes:
        pos = bisect_left(tails, h)
        if pos == len(tails):
            tails.append(h)
        else:
            tails[pos] = h
    
    return len(tails)

# Test
envelopes = [[5,4],[6,4],[6,7],[2,3]]
print(maxEnvelopes(envelopes))  # 3 ([2,3] -> [5,4] -> [6,7])
```

**Why this works**:
```
Original: [[5,4],[6,4],[6,7],[2,3]]
After sort: [[2,3],[5,4],[6,7],[6,4]]
             ↑                    ↑
          (width, height)    Same width but descending height
          
Heights: [3, 4, 7, 4]
LIS on heights: [3, 4, 7] → Length 3
```

---

## Key Takeaways

### LCS Family Patterns
1. **State**: Usually `dp[i][j]` for two strings
2. **Recurrence**: Match vs no-match scenarios
3. **Applications**: String similarity, text diff, DNA analysis

### LIS Family Patterns
1. **State**: `dp[i]` = answer ending at index i
2. **O(n²)**: Check all previous elements
3. **O(n log n)**: Maintain sorted tails array with binary search
4. **Applications**: Scheduling, box stacking, 2D sorting

### Common Techniques
1. **Preprocessing**: Sort before applying DP (Russian Doll)
2. **Multiple arrays**: Track multiple properties (Number of LIS)
3. **Backtracking**: Reconstruct actual sequence
4. **Space optimization**: 1D array for 2D problems

### Important Notes
- LCS and Edit Distance are **foundational** - master these first!
- Binary search optimization is **critical** for LIS problems
- Many 2D problems reduce to 1D LIS after sorting
- Always consider if you need count vs length vs actual sequence

Practice these patterns extensively - they appear frequently in interviews!