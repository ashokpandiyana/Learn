# Chapter 10: Pattern 9 - Digit DP

## Overview

Digit DP is a specialized technique for solving problems that involve counting numbers with specific properties within a range. The key idea is to build numbers digit by digit while maintaining constraints.

**Pattern Recognition**:
- Count numbers in range [L, R] with certain properties
- Properties involve digits themselves (sum, product, patterns)
- Constraints on digit positions
- Large ranges (brute force too slow)

**Core Technique**: Build numbers left-to-right, tracking if we're still bounded by the limit.

---

## 10.1 Core Concepts

### 10.1.1 The "Tight" Bound Flag

**Key Concept**: When building numbers digit by digit, track if we're still at the upper bound.

**Example**: Count numbers ≤ 234 with property X
```
Building 2__ : tight=True (at bound)
Building 23_ : tight=True (still at bound)
Building 234 : tight=True (still at bound, this is limit)
Building 1__ : tight=False (below bound, any digit works)
Building 22_ : tight=False (below bound)
```

**State Variables**:
- `pos`: Current position in number
- `tight`: Are we still at the upper bound?
- `started`: Have we started placing non-zero digits?
- Additional constraints specific to problem

---

### 10.1.2 Basic Template

```python
def digit_dp(n):
    """Count numbers from 0 to n with certain property"""
    digits = [int(d) for d in str(n)]
    memo = {}
    
    def dp(pos, tight, started, other_states):
        # Base case: processed all digits
        if pos == len(digits):
            return 1 if condition_met(other_states) else 0
        
        # Memoization key
        key = (pos, tight, started, other_states)
        if key in memo:
            return memo[key]
        
        # Determine limit for current digit
        limit = digits[pos] if tight else 9
        
        result = 0
        for digit in range(0, limit + 1):
            # Check if this digit is valid
            if not is_valid(digit, other_states):
                continue
            
            # Update states
            new_tight = tight and (digit == limit)
            new_started = started or (digit != 0)
            new_states = update_states(digit, other_states)
            
            result += dp(pos + 1, new_tight, new_started, new_states)
        
        memo[key] = result
        return result
    
    return dp(0, True, False, initial_states)
```

---

## 10.2 Classic Problems

### 10.2.1 Count Numbers with Unique Digits

**Problem**: Count numbers in range [0, n] where all digits are unique.

**LeetCode**: #357

#### Analysis

**State**: Track which digits we've used via bitmask.

```python
def countNumbersWithUniqueDigits(n):
    """
    Count numbers from 0 to 10^n - 1 with all unique digits
    """
    if n == 0:
        return 1
    if n == 1:
        return 10
    
    # For n >= 2, use counting principle
    # First digit: 9 choices (1-9)
    # Second digit: 9 choices (0-9 except first)
    # Third digit: 8 choices, etc.
    
    result = 10  # All 1-digit numbers
    unique = 9   # Current count
    available = 9
    
    for i in range(2, min(n, 10) + 1):
        unique *= available
        result += unique
        available -= 1
    
    return result

# Digit DP approach (more general)
def countNumbersWithUniqueDigits_dp(n):
    from functools import cache
    
    limit = 10 ** n
    if limit == 1:
        return 1
    
    digits = [int(d) for d in str(limit - 1)]
    
    @cache
    def dp(pos, tight, used_mask):
        if pos == len(digits):
            return 1
        
        limit_digit = digits[pos] if tight else 9
        count = 0
        
        for d in range(0, limit_digit + 1):
            # Check if digit already used
            if used_mask & (1 << d):
                continue
            
            new_tight = tight and (d == limit_digit)
            new_mask = used_mask | (1 << d) if d != 0 or used_mask else used_mask
            
            count += dp(pos + 1, new_tight, new_mask)
        
        return count
    
    return dp(0, True, 0)

# Test
print(countNumbersWithUniqueDigits(2))  # 91
# 0-9 (10 numbers) + 10-99 with unique digits (81 numbers)
```

**Complexity**: 
- Counting principle: O(n)
- Digit DP: O(n × 2^10) time for memoization

---

### 10.2.2 Numbers At Most N Given Digit Set

**Problem**: Given digit set D and number n, count how many numbers ≤ n can be formed using digits from D.

**LeetCode**: #902

#### Analysis

**Key Point**: Can only use digits from set D!

```python
def atMostNGivenDigitSet(digits, n):
    """
    digits: sorted list of digit strings (e.g., ["1", "3", "5"])
    n: upper bound integer
    """
    from functools import cache
    
    n_str = str(n)
    length = len(n_str)
    
    @cache
    def dp(pos, tight, started):
        # Base case: built complete number
        if pos == length:
            return 1 if started else 0
        
        if not tight and started:
            # Can use any combination of remaining digits
            return len(digits) ** (length - pos)
        
        count = 0
        
        # Option 1: Skip current position (leading zero)
        if not started:
            count += dp(pos + 1, False, False)
        
        # Option 2: Place a digit from the set
        for d in digits:
            if tight and int(d) > int(n_str[pos]):
                break
            
            new_tight = tight and (int(d) == int(n_str[pos]))
            count += dp(pos + 1, new_tight, True)
        
        return count
    
    return dp(0, True, False)

# Alternative: Combinatorial approach
def atMostNGivenDigitSet_v2(digits, n):
    n_str = str(n)
    k = len(digits)
    length = len(n_str)
    
    # Count numbers with fewer digits
    result = sum(k ** i for i in range(1, length))
    
    # Count numbers with same number of digits
    for i, digit in enumerate(n_str):
        # Count digits in D that are less than current digit
        count = sum(d < digit for d in digits)
        result += count * (k ** (length - i - 1))
        
        # If current digit not in D, can't form any number
        if digit not in digits:
            break
    else:
        # All digits matched
        result += 1
    
    return result

# Test
print(atMostNGivenDigitSet(["1", "3", "5", "7"], 100))  # 20
print(atMostNGivenDigitSet(["1", "4", "9"], 1000000000))  # 29523
```

**Complexity**: O(length × |D|) where |D| is size of digit set

---

### 10.2.3 Numbers With Repeated Digits

**Problem**: Count positive integers ≤ n that have at least one repeated digit.

**LeetCode**: #1012

#### Analysis

**Trick**: Count unique digit numbers, then subtract from total!

```python
def numDupDigitsAtMostN(n):
    """
    Count numbers with repeated digits = Total - Unique digit numbers
    """
    # Count numbers with all unique digits
    def count_unique():
        from functools import cache
        
        digits = [int(d) for d in str(n)]
        
        @cache
        def dp(pos, tight, used_mask, started):
            if pos == len(digits):
                return 1 if started else 0
            
            limit = digits[pos] if tight else 9
            count = 0
            
            # Try each digit
            for d in range(0, limit + 1):
                # Skip if digit already used
                if started and (used_mask & (1 << d)):
                    continue
                
                # Leading zero handling
                if not started and d == 0:
                    count += dp(pos + 1, False, 0, False)
                else:
                    new_tight = tight and (d == limit)
                    new_mask = used_mask | (1 << d)
                    count += dp(pos + 1, new_tight, new_mask, True)
            
            return count
        
        return dp(0, True, 0, False)
    
    return n - count_unique()

# Test
print(numDupDigitsAtMostN(20))   # 1 (only 11 has repeated digit)
print(numDupDigitsAtMostN(100))  # 10 (11, 22, 33, ..., 99, 100)
```

**Complexity**: O(length × 2^10 × 2) for memoization

---

### 10.2.4 Count Integers with Even Digit Sum

**Problem**: Count numbers in range [L, R] where sum of digits is even.

**LeetCode**: #2180

#### Analysis

**State**: Track if digit sum is currently even or odd.

```python
def countEven(num):
    """Count numbers from 1 to num with even digit sum"""
    from functools import cache
    
    digits = [int(d) for d in str(num)]
    
    @cache
    def dp(pos, tight, digit_sum, started):
        if pos == len(digits):
            return 1 if started and digit_sum % 2 == 0 else 0
        
        limit = digits[pos] if tight else 9
        count = 0
        
        for d in range(0, limit + 1):
            if not started and d == 0:
                # Leading zero
                count += dp(pos + 1, False, 0, False)
            else:
                new_tight = tight and (d == limit)
                new_sum = digit_sum + d
                count += dp(pos + 1, new_tight, new_sum, True)
        
        return count
    
    return dp(0, True, 0, False)

# Simplified: Just track parity
def countEven_optimized(num):
    from functools import cache
    
    digits = [int(d) for d in str(num)]
    
    @cache
    def dp(pos, tight, parity):
        if pos == len(digits):
            return 1 if parity == 0 else 0
        
        limit = digits[pos] if tight else 9
        count = 0
        
        for d in range(0, limit + 1):
            new_tight = tight and (d == limit)
            new_parity = (parity + d) % 2
            count += dp(pos + 1, new_tight, new_parity)
        
        return count
    
    # Subtract 1 to exclude 0
    return dp(0, True, 0) - 1

# Test
print(countEven(4))   # 2 (2, 4)
print(countEven(30))  # 14
```

**Complexity**: O(length × 2) for parity tracking

---

## 10.3 Advanced Digit DP

### 10.3.1 Range Query Pattern

To count in range [L, R]: count(R) - count(L-1)

```python
def count_in_range(L, R, property_func):
    """
    Count numbers in [L, R] with certain property
    """
    def count_up_to(n):
        if n < 0:
            return 0
        return digit_dp(n, property_func)
    
    return count_up_to(R) - count_up_to(L - 1)
```

---

### 10.3.2 Multiple Constraints

**Example**: Numbers where digit sum is divisible by K and no digit appears more than M times.

```python
def complex_digit_dp(n, k, m):
    from functools import cache
    
    digits = [int(d) for d in str(n)]
    
    @cache
    def dp(pos, tight, digit_sum, digit_counts):
        if pos == len(digits):
            return 1 if digit_sum % k == 0 else 0
        
        limit = digits[pos] if tight else 9
        count = 0
        
        for d in range(0, limit + 1):
            # Check if digit count constraint violated
            if digit_counts[d] >= m:
                continue
            
            new_tight = tight and (d == limit)
            new_sum = digit_sum + d
            new_counts = list(digit_counts)
            new_counts[d] += 1
            
            count += dp(pos + 1, new_tight, new_sum, tuple(new_counts))
        
        return count
    
    return dp(0, True, 0, tuple([0] * 10))
```

---

## 10.4 Common Patterns

### Pattern 1: Leading Zeros

Always handle leading zeros carefully!

```python
# Option 1: Use 'started' flag
for d in range(0, limit + 1):
    if not started and d == 0:
        # This is a leading zero, special handling
        count += dp(pos + 1, False, ..., False)
    else:
        # Regular digit
        count += dp(pos + 1, ..., True)

# Option 2: Start from position 0, skip leading zeros
for d in range(0 if pos > 0 else 1, limit + 1):
    # Process digit d
```

### Pattern 2: Digit Set Constraints

```python
# Check if digit is allowed
allowed_digits = set(['1', '3', '5', '7'])

for d in range(0, limit + 1):
    if str(d) not in allowed_digits:
        continue
    # Process digit
```

### Pattern 3: Digit Properties

```python
# Track digit sum modulo k
new_sum = (digit_sum + d) % k

# Track digit product
new_prod = digit_prod * d

# Track last digit (for consecutive constraints)
new_last = d
```

---

## 10.5 Optimization Techniques

### Technique 1: Prune Invalid States

```python
# If constraint already violated, don't continue
if constraint_violated(current_state):
    return 0
```

### Technique 2: Tight Bound Optimization

```python
# When not tight, use combinatorics
if not tight and started:
    # Can use any digits for remaining positions
    return count_all_possibilities(remaining_positions)
```

### Technique 3: State Compression

```python
# Instead of tracking full list/dict
# Use bitmask for digit usage: (1 << d) for digit d
# Use modulo for sums: digit_sum % k
```

---

## 10.6 Common Pitfalls

### Pitfall 1: Forgetting Leading Zeros

```python
# WRONG: Counts 001, 002, etc. as valid numbers
def dp(pos, tight):
    if pos == length:
        return 1
    # ...

# CORRECT: Track if we've started
def dp(pos, tight, started):
    if pos == length:
        return 1 if started else 0
    # ...
```

### Pitfall 2: Mutable State in Cache Key

```python
# WRONG: Lists are not hashable
@cache
def dp(pos, tight, used_list):  # ERROR!
    # ...

# CORRECT: Use immutable types
@cache
def dp(pos, tight, used_tuple):  # OK
    # ...
```

### Pitfall 3: Off-by-One in Range Queries

```python
# WRONG: Might include/exclude boundaries incorrectly
count(R) - count(L)

# CORRECT: Adjust for inclusive/exclusive bounds
count(R) - count(L - 1)  # For inclusive [L, R]
```

---

## 10.7 Step-by-Step Problem Solving

### Framework:

1. **Identify the property** to count/check
2. **Define state variables**:
   - Position (always needed)
   - Tight bound flag (almost always needed)
   - Started flag (for leading zeros)
   - Property-specific variables
3. **Handle leading zeros** explicitly
4. **Implement transitions** for each digit
5. **Memoize** with proper cache key
6. **Handle range queries** if needed

---

## Practice Problems Summary

### Beginner
1. Count Numbers with Unique Digits (#357)
2. Count Integers with Even Digit Sum (#2180)
3. Monotone Increasing Digits (#738)

### Intermediate
4. Numbers At Most N Given Digit Set (#902)
5. Numbers With Repeated Digits (#1012)
6. Count Special Integers (#2376)

### Advanced
7. Count Numbers with Unique Digits in Range
8. Numbers with Digit Sum Divisible by K
9. Non-negative Integers without Consecutive Ones (#600)

---

## Key Takeaways

1. **Digit DP = Build numbers left-to-right** while tracking constraints
2. **Tight flag** tracks if we're at the upper bound
3. **Leading zeros** require special handling
4. **Memoization** is essential (exponential → polynomial)
5. **Range queries**: count(R) - count(L-1)
6. **State variables**: Position, tight, started, + problem-specific
7. **Complexity**: Usually O(length × states × digits)
8. **Think combinatorially** when possible for optimization
9. **Use tuples** for hashable memo keys
10. **Test edge cases**: 0, single digit, all same digits

Digit DP is powerful for counting problems with digit constraints - master the template!