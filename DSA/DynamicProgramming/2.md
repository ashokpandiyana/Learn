# Chapter 2: Pattern 1 - Linear DP (1D)

## Overview

Linear DP problems involve **sequences** where the state depends on a single index. The key characteristic is that `dp[i]` represents the solution for the first `i` elements or at position `i`.

**Pattern Recognition**:
- Input is a 1D array or sequence
- Decision at each position affects future positions
- State can be represented with a single variable

---

## 2.1 Single Sequence Problems

### 2.1.1 Fibonacci Sequence (Introduction to DP)

**Problem**: Calculate the nth Fibonacci number where F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)

This is the "Hello World" of DP!

```python
# Approach 1: Pure Recursion (Exponential - DON'T USE!)
def fib_recursive(n):
    if n <= 1:
        return n
    return fib_recursive(n - 1) + fib_recursive(n - 2)
# Time: O(2^n), Space: O(n) for call stack

# Approach 2: Memoization
from functools import cache

@cache
def fib_memo(n):
    if n <= 1:
        return n
    return fib_memo(n - 1) + fib_memo(n - 2)
# Time: O(n), Space: O(n)

# Approach 3: Tabulation
def fib_tab(n):
    if n <= 1:
        return n
    dp = [0] * (n + 1)
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
# Time: O(n), Space: O(n)

# Approach 4: Space Optimized (Best!)
def fib_optimized(n):
    if n <= 1:
        return n
    prev2, prev1 = 0, 1
    for i in range(2, n + 1):
        curr = prev1 + prev2
        prev2, prev1 = prev1, curr
    return prev1
# Time: O(n), Space: O(1)

# Test
print(fib_optimized(10))  # 55
```

**Visualization for n=5**:
```
Index:  0  1  2  3  4  5
Value:  0  1  1  2  3  5
        ↑  ↑
     F(0) F(1)
```

---

### 2.1.2 Climbing Stairs

**Problem**: You're climbing stairs. Each time you can climb 1 or 2 steps. How many distinct ways can you climb to the top?

**LeetCode**: #70

#### Analysis

**State**: `dp[i]` = number of ways to reach stair `i`

**Recurrence**: 
- To reach stair `i`, you can come from stair `i-1` (take 1 step) or `i-2` (take 2 steps)
- `dp[i] = dp[i-1] + dp[i-2]`

**Base Cases**:
- `dp[0] = 1` (one way to stay at ground)
- `dp[1] = 1` (one way: take 1 step)

**Key Insight**: This is actually Fibonacci in disguise!

```python
# Tabulation
def climbStairs(n):
    if n <= 2:
        return n
    
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    
    return dp[n]

# Space Optimized
def climbStairs_optimized(n):
    if n <= 2:
        return n
    
    prev2, prev1 = 1, 1
    
    for i in range(2, n + 1):
        curr = prev1 + prev2
        prev2, prev1 = prev1, curr
    
    return prev1

# Test
print(climbStairs(5))  # 8
# Ways: 1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+2+1+1, 2+1+1+1, 1+2+2, 2+1+2, 2+2+1
```

**Complexity**:
- Time: O(n)
- Space: O(n) for tabulation, O(1) for optimized

---

### 2.1.3 House Robber (Non-Adjacent Selection)

**Problem**: You're a robber. Houses have money. You can't rob adjacent houses (alarm will trigger). Maximize money robbed.

**LeetCode**: #198

#### Analysis

**State**: `dp[i]` = maximum money robbing houses from index 0 to i

**Recurrence**: At house `i`, you have two choices:
1. **Rob house i**: You get `nums[i] + dp[i-2]` (can't rob i-1)
2. **Don't rob house i**: You get `dp[i-1]`

`dp[i] = max(nums[i] + dp[i-2], dp[i-1])`

**Base Cases**:
- `dp[0] = nums[0]` (only one house)
- `dp[1] = max(nums[0], nums[1])` (rob the richer one)

```python
# Tabulation
def rob(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    
    n = len(nums)
    dp = [0] * n
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    
    for i in range(2, n):
        dp[i] = max(nums[i] + dp[i - 2], dp[i - 1])
    
    return dp[n - 1]

# Space Optimized
def rob_optimized(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    
    prev2 = nums[0]
    prev1 = max(nums[0], nums[1])
    
    for i in range(2, len(nums)):
        curr = max(nums[i] + prev2, prev1)
        prev2, prev1 = prev1, curr
    
    return prev1

# Test
nums = [2, 7, 9, 3, 1]
print(rob_optimized(nums))  # 12 (rob houses at index 0, 2, 4)

nums = [1, 2, 3, 1]
print(rob_optimized(nums))  # 4 (rob houses at index 1 and 3)
```

**Visualization**:
```
Houses:  [2, 7, 9, 3, 1]
Index:    0  1  2  3  4

dp[0] = 2
dp[1] = max(2, 7) = 7
dp[2] = max(9+2, 7) = 11
dp[3] = max(3+7, 11) = 11
dp[4] = max(1+11, 11) = 12

Answer: 12
```

---

### 2.1.4 Min Cost Climbing Stairs

**Problem**: Array `cost` where `cost[i]` is the cost of the ith step. Start at index 0 or 1. Each time climb 1 or 2 steps. Find minimum cost to reach the top.

**LeetCode**: #746

#### Analysis

**State**: `dp[i]` = minimum cost to reach step i

**Recurrence**: 
- To reach step i, you must pay `cost[i]`
- You can come from step `i-1` or `i-2`
- `dp[i] = cost[i] + min(dp[i-1], dp[i-2])`

**Base Cases**:
- `dp[0] = cost[0]`
- `dp[1] = cost[1]`

**Important**: The top is BEYOND the last step!

```python
def minCostClimbingStairs(cost):
    n = len(cost)
    if n == 2:
        return min(cost)
    
    dp = [0] * n
    dp[0] = cost[0]
    dp[1] = cost[1]
    
    for i in range(2, n):
        dp[i] = cost[i] + min(dp[i - 1], dp[i - 2])
    
    # Can reach top from last or second-last step
    return min(dp[n - 1], dp[n - 2])

# Space Optimized
def minCostClimbingStairs_optimized(cost):
    n = len(cost)
    prev2 = cost[0]
    prev1 = cost[1]
    
    for i in range(2, n):
        curr = cost[i] + min(prev1, prev2)
        prev2, prev1 = prev1, curr
    
    return min(prev1, prev2)

# Test
cost = [10, 15, 20]
print(minCostClimbingStairs_optimized(cost))  # 15

cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
print(minCostClimbingStairs_optimized(cost))  # 6
# Path: 0 -> 2 -> 3 -> 4 -> 6 -> 7 -> 9 -> top (1+1+1+1+1+1=6)
```

---

### 2.1.5 Decode Ways

**Problem**: 'A'->1, 'B'->2, ..., 'Z'->26. Given string of digits, count number of ways to decode it.

**LeetCode**: #91

#### Analysis

**State**: `dp[i]` = number of ways to decode string up to index i

**Recurrence**: At position i, you can:
1. **Decode single digit**: If `s[i] != '0'`, add `dp[i-1]` ways
2. **Decode two digits**: If `10 <= int(s[i-1:i+1]) <= 26`, add `dp[i-2]` ways

**Base Cases**:
- `dp[0] = 1` (empty string)
- `dp[1] = 0 if s[0] == '0' else 1`

**Edge Cases**:
- Leading zeros are invalid
- "00", "30", etc. are invalid

```python
def numDecodings(s):
    if not s or s[0] == '0':
        return 0
    
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1  # Empty string
    dp[1] = 1  # First character (already checked not '0')
    
    for i in range(2, n + 1):
        # Single digit decode
        one_digit = int(s[i - 1])
        if one_digit >= 1:
            dp[i] += dp[i - 1]
        
        # Two digit decode
        two_digits = int(s[i - 2:i])
        if 10 <= two_digits <= 26:
            dp[i] += dp[i - 2]
    
    return dp[n]

# Space Optimized
def numDecodings_optimized(s):
    if not s or s[0] == '0':
        return 0
    
    n = len(s)
    prev2 = 1  # dp[i-2]
    prev1 = 1  # dp[i-1]
    
    for i in range(2, n + 1):
        curr = 0
        
        # Single digit
        if int(s[i - 1]) >= 1:
            curr += prev1
        
        # Two digits
        if 10 <= int(s[i - 2:i]) <= 26:
            curr += prev2
        
        prev2, prev1 = prev1, curr
    
    return prev1

# Test
print(numDecodings_optimized("12"))    # 2: "AB" or "L"
print(numDecodings_optimized("226"))   # 3: "BZ", "VF", "BBF"
print(numDecodings_optimized("06"))    # 0: Invalid
print(numDecodings_optimized("27"))    # 1: "BG" only (27 > 26)
```

**Visualization for "226"**:
```
String: "226"
Index:  0 1 2 3

dp[0] = 1 (empty)
dp[1] = 1 ("2" -> B)
dp[2] = 2 ("22" -> "BB" or "V")
dp[3] = 3 ("226" -> "BBF", "BZ", "VF")
```

---

## 2.2 Key Techniques

### Technique 1: Understanding State Definition

**Critical Distinction**: What does `dp[i]` represent?

#### Option A: Solution AT position i
```python
# Example: Maximum value AT position i
dp[i] = max_value_at_position_i
```

#### Option B: Solution UP TO position i
```python
# Example: Maximum value considering elements 0 to i
dp[i] = max_value_from_0_to_i
```

**Example Problem**: Find maximum sum subarray

```python
# Kadane's Algorithm - Solution AT position i
def maxSubArray(nums):
    if not nums:
        return 0
    
    # dp[i] = maximum sum of subarray ENDING at i
    max_ending_here = nums[0]
    max_so_far = nums[0]
    
    for i in range(1, len(nums)):
        # Either extend previous subarray or start new
        max_ending_here = max(nums[i], max_ending_here + nums[i])
        max_so_far = max(max_so_far, max_ending_here)
    
    return max_so_far

# Test
print(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]))  # 6 (subarray [4,-1,2,1])
```

### Technique 2: Include/Exclude Decisions

Many 1D DP problems involve choosing whether to include current element.

**Template**:
```python
# At position i, make a decision:
dp[i] = max(
    include_current + dp[prev_if_included],
    exclude_current + dp[prev_if_excluded]
)
```

**Example**: House Robber fits this pattern perfectly!

### Technique 3: State Compression

When current state only depends on last few states, use variables instead of array.

```python
# Instead of:
dp = [0] * n
for i in range(n):
    dp[i] = dp[i-1] + dp[i-2]

# Use:
prev2, prev1 = 0, 1
for i in range(n):
    curr = prev1 + prev2
    prev2, prev1 = prev1, curr
```

---

## 2.3 Variations and Extensions

### 2.3.1 House Robber II (Circular Array)

**Problem**: Same as House Robber, but houses are arranged in a circle (first and last are adjacent).

**LeetCode**: #213

#### Analysis

**Key Insight**: If we rob house 0, we CANNOT rob house n-1, and vice versa.

**Solution**: Solve twice:
1. Rob houses 0 to n-2 (exclude last)
2. Rob houses 1 to n-1 (exclude first)
Take maximum of both!

```python
def rob_linear(nums, start, end):
    """Helper: Rob houses from start to end (inclusive)"""
    prev2, prev1 = 0, 0
    
    for i in range(start, end + 1):
        curr = max(nums[i] + prev2, prev1)
        prev2, prev1 = prev1, curr
    
    return prev1

def rob_circular(nums):
    if len(nums) == 1:
        return nums[0]
    if len(nums) == 2:
        return max(nums)
    
    # Case 1: Rob houses 0 to n-2
    case1 = rob_linear(nums, 0, len(nums) - 2)
    
    # Case 2: Rob houses 1 to n-1
    case2 = rob_linear(nums, 1, len(nums) - 1)
    
    return max(case1, case2)

# Test
print(rob_circular([2, 3, 2]))     # 3
print(rob_circular([1, 2, 3, 1]))  # 4
```

---

### 2.3.2 Delete and Earn

**Problem**: Given array `nums`, you can delete `nums[i]` to earn `nums[i]` points. But you must delete all numbers equal to `nums[i]-1` and `nums[i]+1`. Maximize points.

**LeetCode**: #740

#### Analysis

**Key Insight**: This is House Robber in disguise!

1. Count frequency of each number
2. Transform to: `points[i] = i * frequency[i]`
3. If you take points[i], you can't take points[i-1] or points[i+1]
4. This is exactly House Robber!

```python
def deleteAndEarn(nums):
    if not nums:
        return 0
    
    max_num = max(nums)
    points = [0] * (max_num + 1)
    
    # Calculate points for each number
    for num in nums:
        points[num] += num
    
    # Now it's House Robber problem!
    prev2, prev1 = 0, 0
    
    for i in range(len(points)):
        curr = max(points[i] + prev2, prev1)
        prev2, prev1 = prev1, curr
    
    return prev1

# Test
print(deleteAndEarn([3, 4, 2]))      # 6 (delete 3 twice and 2 once)
print(deleteAndEarn([2, 2, 3, 3, 3, 4]))  # 9 (delete all 3's)
```

---

### 2.3.3 Maximum Product Subarray

**Problem**: Find contiguous subarray with maximum product.

**LeetCode**: #152

#### Analysis

**Challenge**: Unlike sum, product can flip sign with negative numbers!

**Key Insight**: Track both maximum AND minimum product (because negative × negative = positive)

**State**: 
- `max_prod[i]` = max product ending at i
- `min_prod[i]` = min product ending at i

**Recurrence**:
```python
max_prod[i] = max(nums[i], max_prod[i-1] * nums[i], min_prod[i-1] * nums[i])
min_prod[i] = min(nums[i], max_prod[i-1] * nums[i], min_prod[i-1] * nums[i])
```

```python
def maxProduct(nums):
    if not nums:
        return 0
    
    max_prod = min_prod = result = nums[0]
    
    for i in range(1, len(nums)):
        # If current number is negative, swap max and min
        if nums[i] < 0:
            max_prod, min_prod = min_prod, max_prod
        
        # Update max and min product ending at i
        max_prod = max(nums[i], max_prod * nums[i])
        min_prod = min(nums[i], min_prod * nums[i])
        
        result = max(result, max_prod)
    
    return result

# Alternative: Without swap
def maxProduct_v2(nums):
    if not nums:
        return 0
    
    max_prod = min_prod = result = nums[0]
    
    for i in range(1, len(nums)):
        temp_max = max(nums[i], max_prod * nums[i], min_prod * nums[i])
        min_prod = min(nums[i], max_prod * nums[i], min_prod * nums[i])
        max_prod = temp_max
        
        result = max(result, max_prod)
    
    return result

# Test
print(maxProduct([2, 3, -2, 4]))      # 6 (subarray [2,3])
print(maxProduct([-2, 0, -1]))        # 0
print(maxProduct([-2, 3, -4]))        # 24 (entire array)
```

**Visualization for [2, 3, -2, 4]**:
```
Index:     0   1    2   3
nums:      2   3   -2   4

         max min
i=0:      2   2
i=1:      6   3   (2*3=6, 2*3=6)
i=2:     -2  -12  (max(−2, 6*−2=−12, 3*−2=−6) = −2)
i=3:     24   -8  (max(4, −2*4=−8, −12*4=−48) = 24)

Result: 24
```

---

## 2.4 Edge Cases and Important Notes

### Common Edge Cases in Linear DP

1. **Empty array**: Always check `if not nums: return 0`
2. **Single element**: `if len(nums) == 1: return nums[0]`
3. **Two elements**: Sometimes need special handling
4. **All negative numbers**: Make sure your initialization handles this
5. **Zeros in array**: Can break product/division problems

### Critical Notes

#### Note 1: Index vs Position
```python
# WRONG - confusing indices
dp[i] represents solution for nums[i-1]

# RIGHT - clear relationship
dp[i] represents solution for nums[i]
# OR
dp[i] represents solution for first i elements
```

#### Note 2: Initialization Matters
```python
# For maximum problems
dp = [float('-inf')] * n
dp[0] = nums[0]  # Start with actual value

# For minimum problems
dp = [float('inf')] * n
dp[0] = nums[0]

# For counting problems
dp = [0] * n
dp[0] = 1  # Usually 1 way to handle base case
```

#### Note 3: Space Optimization Pattern
```python
# If recurrence is: dp[i] = f(dp[i-1], dp[i-2])
# You only need 2 variables

# If recurrence is: dp[i] = f(dp[i-1], dp[i-2], dp[i-3])
# You need 3 variables

# General rule: Keep as many previous states as needed
```

---

## Practice Problems Summary

### Beginner Level
1. Fibonacci Number (#509)
2. Climbing Stairs (#70)
3. Min Cost Climbing Stairs (#746)

### Intermediate Level
4. House Robber (#198)
5. House Robber II (#213)
6. Maximum Subarray (#53)
7. Decode Ways (#91)
8. Delete and Earn (#740)

### Advanced Level
9. Maximum Product Subarray (#152)
10. Word Break (#139)
11. Palindrome Partitioning II (#132)

---

## Key Takeaways

1. **Linear DP = 1D state**, usually `dp[i]`
2. **Most common recurrence**: `dp[i] = f(dp[i-1], dp[i-2], ...)`
3. **Include/exclude pattern** is very common
4. **Space optimization**: If `dp[i]` only depends on last k elements, use k variables
5. **Edge cases**: Empty array, single element, all negatives
6. **State definition clarity**: AT position i vs UP TO position i
7. **Negative numbers**: Some problems need to track both max and min

Master these patterns, and you'll recognize 1D DP problems instantly in interviews!