# Chapter 8: Special Interval Problems

## 8.1 Employee Free Time

### Problem Statement

**Given:** A list of employee schedules where each schedule is a list of **non-overlapping** intervals representing busy times

**Goal:** Find the common free time intervals for **all** employees

**Example:**
```
Input:  [
          [[1,3], [6,7]],     # Employee 1 busy times
          [[2,4]],            # Employee 2 busy times  
          [[2,5], [9,12]]     # Employee 3 busy times
        ]

Output: [[5,6], [7,9]]  # Common free times
```

### Visual Understanding

```
Timeline: 0--1--2--3--4--5--6--7--8--9--10-11-12

Employee 1: [===]     [=]
            1   3     6 7

Employee 2:   [===]
              2   4

Employee 3:   [====]         [======]
              2    5         9     12

All busy:  [=======]  [=]    [======]
           1       5  6 7    9     12
           (merged)

Free time:         [=] [===]
                   5 6 7   9

Common free intervals: [[5,6], [7,9]]
```

### Solution Strategy

**Key Insight:** 
1. Merge ALL busy intervals from ALL employees into one list
2. Sort and merge overlapping intervals
3. Find gaps between merged intervals

```python
def employeeFreeTime(schedule):
    """
    Find common free time for all employees
    
    Algorithm:
    1. Flatten all employee schedules into one list
    2. Sort and merge overlapping intervals (busy times)
    3. Find gaps between merged intervals (free times)
    
    Time Complexity: O(n log n) where n = total intervals
    Space Complexity: O(n)
    
    Args:
        schedule: List[List[List[int]]] - employee schedules
            schedule[i][j] = [start, end] for employee i's jth busy interval
    
    Returns:
        List[List[int]] - common free time intervals
    """
    # Step 1: Flatten all intervals into one list
    all_busy = []
    for employee_schedule in schedule:
        all_busy.extend(employee_schedule)
    
    # Step 2: Sort by start time
    all_busy.sort(key=lambda x: x[0])
    
    # Step 3: Merge overlapping busy intervals
    merged_busy = []
    for interval in all_busy:
        if not merged_busy or merged_busy[-1][1] < interval[0]:
            merged_busy.append(interval)
        else:
            merged_busy[-1][1] = max(merged_busy[-1][1], interval[1])
    
    # Step 4: Find gaps (free times)
    free_times = []
    for i in range(1, len(merged_busy)):
        # Gap between end of previous and start of current
        gap_start = merged_busy[i-1][1]
        gap_end = merged_busy[i][0]
        
        if gap_start < gap_end:
            free_times.append([gap_start, gap_end])
    
    return free_times


# Test
schedule = [
    [[1,3], [6,7]],     # Employee 1
    [[2,4]],            # Employee 2
    [[2,5], [9,12]]     # Employee 3
]

result = employeeFreeTime(schedule)
print(f"Common free times: {result}")
```

### Step-by-Step Execution

```
Input: [
  [[1,3], [6,7]],     # Employee 1
  [[2,4]],            # Employee 2
  [[2,5], [9,12]]     # Employee 3
]

═══════════════════════════════════════════════════════════
STEP 1: Flatten all busy intervals
═══════════════════════════════════════════════════════════

all_busy = [[1,3], [6,7], [2,4], [2,5], [9,12]]

═══════════════════════════════════════════════════════════
STEP 2: Sort by start time
═══════════════════════════════════════════════════════════

sorted = [[1,3], [2,4], [2,5], [6,7], [9,12]]

═══════════════════════════════════════════════════════════
STEP 3: Merge overlapping intervals
═══════════════════════════════════════════════════════════

merged_busy = []

Process [1,3]:
  merged_busy is empty → add [1,3]
  merged_busy = [[1,3]]

Process [2,4]:
  Last end: 3, Current start: 2
  3 < 2? NO → overlap!
  Merge: [1, max(3,4)] = [1,4]
  merged_busy = [[1,4]]

Process [2,5]:
  Last end: 4, Current start: 2
  4 < 2? NO → overlap!
  Merge: [1, max(4,5)] = [1,5]
  merged_busy = [[1,5]]

Process [6,7]:
  Last end: 5, Current start: 6
  5 < 6? YES → no overlap
  Add [6,7]
  merged_busy = [[1,5], [6,7]]

Process [9,12]:
  Last end: 7, Current start: 9
  7 < 9? YES → no overlap
  Add [9,12]
  merged_busy = [[1,5], [6,7], [9,12]]

═══════════════════════════════════════════════════════════
STEP 4: Find gaps (free times)
═══════════════════════════════════════════════════════════

Gap between [1,5] and [6,7]:
  gap_start = 5, gap_end = 6
  5 < 6? YES → Add [5,6]
  free_times = [[5,6]]

Gap between [6,7] and [9,12]:
  gap_start = 7, gap_end = 9
  7 < 9? YES → Add [7,9]
  free_times = [[5,6], [7,9]]

FINAL RESULT: [[5,6], [7,9]]
```

### Alternative Solution: Using Priority Queue

For very large datasets with many employees, we can use a heap:

```python
import heapq

def employeeFreeTime_heap(schedule):
    """
    Alternative using min heap for better space efficiency
    
    Time: O(n log k) where k is number of employees
    Space: O(k) for heap
    """
    # Min heap: (start, end, employee_id, interval_id)
    heap = []
    
    # Initialize heap with first interval from each employee
    for emp_id, emp_schedule in enumerate(schedule):
        if emp_schedule:
            start, end = emp_schedule[0]
            heapq.heappush(heap, (start, end, emp_id, 0))
    
    free_times = []
    prev_end = -1
    
    while heap:
        start, end, emp_id, interval_idx = heapq.heappop(heap)
        
        # If there's a gap after previous interval
        if prev_end != -1 and prev_end < start:
            free_times.append([prev_end, start])
        
        # Update prev_end to be the maximum end seen so far
        prev_end = max(prev_end, end) if prev_end != -1 else end
        
        # Add next interval from same employee
        if interval_idx + 1 < len(schedule[emp_id]):
            next_start, next_end = schedule[emp_id][interval_idx + 1]
            heapq.heappush(heap, (next_start, next_end, emp_id, interval_idx + 1))
    
    return free_times


# Test
schedule = [
    [[1,3], [6,7]],
    [[2,4]],
    [[2,5], [9,12]]
]

result = employeeFreeTime_heap(schedule)
print(f"Free times (heap method): {result}")
```

### Handling Working Hours Constraint

Often, we want free time only within business hours:

```python
def employeeFreeTime_withHours(schedule, work_start=0, work_end=24):
    """
    Find common free time within working hours
    
    Args:
        schedule: employee schedules
        work_start: start of working hours
        work_end: end of working hours
    
    Returns:
        List of free intervals within [work_start, work_end]
    """
    # Get all free times
    free_times = employeeFreeTime(schedule)
    
    # Filter to working hours
    result = []
    for start, end in free_times:
        # Clip to working hours
        clipped_start = max(start, work_start)
        clipped_end = min(end, work_end)
        
        if clipped_start < clipped_end:
            result.append([clipped_start, clipped_end])
    
    return result


# Example
schedule = [
    [[1,3], [6,7]],
    [[2,4]],
    [[2,5], [9,12]]
]

# Only consider 9am to 5pm (represented as hours)
free_during_work = employeeFreeTime_withHours(schedule, work_start=6, work_end=10)
print(f"Free times during 6-10: {free_during_work}")
```

## 8.2 My Calendar Problems Series

### My Calendar I: Single Booking Validation

**Problem:** Implement a calendar that can book new events if they don't cause a double booking.

```python
class MyCalendar:
    """
    Calendar that prevents double bookings
    
    A double booking happens when two events have some overlap
    """
    
    def __init__(self):
        self.bookings = []  # List of [start, end] intervals
    
    def book(self, start, end):
        """
        Try to book interval [start, end)
        
        Returns: True if booking succeeds, False if it causes double booking
        
        Time: O(n) per booking
        Space: O(n)
        """
        # Check if new booking overlaps with any existing booking
        for booking_start, booking_end in self.bookings:
            # Check overlap: max(starts) < min(ends)
            if max(start, booking_start) < min(end, booking_end):
                return False  # Double booking!
        
        # No conflicts, add the booking
        self.bookings.append([start, end])
        return True


# Test
calendar = MyCalendar()
print(calendar.book(10, 20))  # True
print(calendar.book(15, 25))  # False (overlaps with [10,20))
print(calendar.book(20, 30))  # True (starts when previous ends)

"""
Timeline: 10--15--20--25--30

Booking 1: [10,20):  [=====]
           Success! ✓

Booking 2: [15,25):      [=====]
           Overlaps with [10,20) ✗
           
Booking 3: [20,30):           [=====]
           No overlap, touches at 20 ✓
"""
```

### Optimized with Binary Search

```python
import bisect

class MyCalendar_Optimized:
    """
    Optimized calendar using sorted list and binary search
    
    Time: O(log n) per booking (if using balanced BST)
          O(n) with list (due to insertion)
    """
    
    def __init__(self):
        self.bookings = []  # Maintained in sorted order
    
    def book(self, start, end):
        """
        Book using binary search
        
        Time: O(n) due to list insertion, but O(log n) search
        """
        # Find where [start, end) would be inserted
        idx = bisect.bisect_left(self.bookings, [start, end])
        
        # Check previous booking (if exists)
        if idx > 0:
            prev_start, prev_end = self.bookings[idx - 1]
            if prev_end > start:
                return False  # Overlap with previous
        
        # Check next booking (if exists)
        if idx < len(self.bookings):
            next_start, next_end = self.bookings[idx]
            if next_start < end:
                return False  # Overlap with next
        
        # No conflicts, insert booking
        self.bookings.insert(idx, [start, end])
        return True
```

### My Calendar II: Double Booking Prevention

**Problem:** Allow single overlaps but prevent triple bookings.

```python
class MyCalendarTwo:
    """
    Calendar that allows single overlaps but prevents triple bookings
    
    Track both single bookings and double bookings separately
    """
    
    def __init__(self):
        self.bookings = []  # All bookings
        self.overlaps = []  # Regions with double bookings
    
    def book(self, start, end):
        """
        Try to book, allowing double bookings but not triple
        
        Returns: True if successful, False if causes triple booking
        
        Time: O(n²) worst case
        """
        # Check if this would create a triple booking
        for overlap_start, overlap_end in self.overlaps:
            if max(start, overlap_start) < min(end, overlap_end):
                return False  # Would create triple booking!
        
        # Check for new double bookings with existing bookings
        for booking_start, booking_end in self.bookings:
            overlap_start = max(start, booking_start)
            overlap_end = min(end, booking_end)
            
            if overlap_start < overlap_end:
                # New double booking region
                self.overlaps.append([overlap_start, overlap_end])
        
        # Add the booking
        self.bookings.append([start, end])
        return True


# Test
calendar = MyCalendarTwo()
print(calendar.book(10, 20))  # True (first booking)
print(calendar.book(50, 60))  # True (no overlap)
print(calendar.book(10, 40))  # True (creates double booking [10,20])
print(calendar.book(5, 15))   # False (would create triple booking [10,15])
print(calendar.book(5, 10))   # True (only creates double booking at boundary)

"""
After book(10, 20):
  bookings: [[10,20]]
  overlaps: []

After book(50, 60):
  bookings: [[10,20], [50,60]]
  overlaps: []

After book(10, 40):
  bookings: [[10,20], [50,60], [10,40]]
  overlaps: [[10,20]] (overlap between [10,20] and [10,40])

After book(5, 15) attempt:
  Would overlap with existing overlap [10,20] at [10,15]
  This creates triple booking → REJECT

After book(5, 10):
  Creates overlap [5,10] with first booking
  No triple booking → ACCEPT
"""
```

### My Calendar III: K-Booking Maximum

**Problem:** Find the maximum k-booking (maximum number of overlapping events).

```python
class MyCalendarThree:
    """
    Track the maximum k-booking (maximum concurrent events)
    
    Use sweep line algorithm
    """
    
    def __init__(self):
        self.timeline = {}  # time -> delta (start=+1, end=-1)
    
    def book(self, start, end):
        """
        Add booking and return maximum k-booking
        
        Returns: maximum number of concurrent bookings
        
        Time: O(n²) due to sorting on each call
        """
        # Add start and end events
        self.timeline[start] = self.timeline.get(start, 0) + 1
        self.timeline[end] = self.timeline.get(end, 0) - 1
        
        # Sweep through timeline
        max_k = 0
        current = 0
        
        for time in sorted(self.timeline.keys()):
            current += self.timeline[time]
            max_k = max(max_k, current)
        
        return max_k


# Test
calendar = MyCalendarThree()
print(calendar.book(10, 20))  # 1
print(calendar.book(50, 60))  # 1
print(calendar.book(10, 40))  # 2 (overlap at [10,20])
print(calendar.book(5, 15))   # 3 (overlap at [10,15])
print(calendar.book(5, 10))   # 3
print(calendar.book(25, 55))  # 3

"""
Timeline evolution:

After book(10, 20):
  Events: {10: +1, 20: -1}
  Max concurrent: 1

After book(10, 40):
  Events: {10: +2, 20: -1, 40: -1}
  At time 10: 2 events start
  Max concurrent: 2

After book(5, 15):
  Events: {5: +1, 10: +2, 15: -1, 20: -1, 40: -1}
  Sweep: 5→1, 10→3, 15→2, 20→1, 40→0
  Max concurrent: 3 (at time 10-15)
"""
```

## 8.3 Non-Overlapping Intervals (Minimum Removals)

### Problem Statement

**Given:** Array of intervals

**Goal:** Find minimum number of intervals to remove so remaining intervals are non-overlapping

**Example:**
```
Input:  [[1,2], [2,3], [3,4], [1,3]]
Output: 1

Explanation: Remove [1,3] or [2,3] to make rest non-overlapping
```

### Solution: Greedy Algorithm

**Key Insight:** This is the INVERSE of activity selection!
- Activity selection: maximize selected intervals
- This problem: minimize removed intervals

If we can select K intervals, we need to remove (N - K) intervals.

```python
def eraseOverlapIntervals(intervals):
    """
    Minimum number of intervals to remove for non-overlapping result
    
    Algorithm:
    1. Sort by END time (greedy choice)
    2. Select maximum non-overlapping intervals (activity selection)
    3. Return total - selected
    
    Time: O(n log n)
    Space: O(1)
    
    Args:
        intervals: List[List[int]]
    
    Returns:
        int - minimum removals needed
    """
    if not intervals:
        return 0
    
    # Sort by end time
    intervals.sort(key=lambda x: x[1])
    
    # Greedy selection of non-overlapping intervals
    selected = 1  # Select first interval
    last_end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        start, end = intervals[i]
        
        # If current doesn't overlap with last selected
        if start >= last_end:
            selected += 1
            last_end = end
    
    # Minimum removals = total - maximum selected
    return len(intervals) - selected


# Test
test_cases = [
    {
        'intervals': [[1,2], [2,3], [3,4], [1,3]],
        'expected': 1,
        'description': 'Remove one for non-overlapping'
    },
    {
        'intervals': [[1,2], [1,2], [1,2]],
        'expected': 2,
        'description': 'All identical - keep one, remove two'
    },
    {
        'intervals': [[1,2], [2,3]],
        'expected': 0,
        'description': 'Already non-overlapping'
    },
]

for test in test_cases:
    result = eraseOverlapIntervals(test['intervals'][:])
    status = "✓" if result == test['expected'] else "✗"
    print(f"{status} {test['description']}")
    print(f"  Expected: {test['expected']}, Got: {result}\n")
```

### Step-by-Step Execution

```
Input: [[1,2], [2,3], [3,4], [1,3]]

═══════════════════════════════════════════════════════════
STEP 1: Sort by end time
═══════════════════════════════════════════════════════════

Sorted: [[1,2], [2,3], [1,3], [3,4]]
         end:2   end:3   end:3   end:4

═══════════════════════════════════════════════════════════
STEP 2: Greedy selection (activity selection)
═══════════════════════════════════════════════════════════

Select [1,2] (first interval)
  selected = 1
  last_end = 2

Timeline:
Selected: [==]
          1  2

Check [2,3]:
  start = 2, last_end = 2
  2 >= 2? YES → Select it
  selected = 2
  last_end = 3

Timeline:
Selected: [==][==]
          1  2  3

Check [1,3]:
  start = 1, last_end = 3
  1 >= 3? NO → Skip (overlaps)

Timeline:
Selected: [==][==]
          1  2  3
Skipped:  [=====]
          1     3

Check [3,4]:
  start = 3, last_end = 3
  3 >= 3? YES → Select it
  selected = 3
  last_end = 4

Timeline:
Selected: [==][==][==]
          1  2  3  4

═══════════════════════════════════════════════════════════
STEP 3: Calculate removals
═══════════════════════════════════════════════════════════

Total intervals: 4
Selected: 3
Removals: 4 - 3 = 1

Answer: Remove 1 interval (which is [1,3])
```

### Why This Works

```
Greedy selection maximizes kept intervals:
- Sort by end time
- Always pick interval ending earliest
- This leaves maximum room for future intervals

If we can keep K intervals, we must remove (N - K).

Example:
Total: 4 intervals
Can keep: 3 intervals (using greedy)
Must remove: 4 - 3 = 1 interval

The removed interval is [1,3] which overlaps with [2,3].
```

## 8.4 Interval List Intersections with Constraints

### Problem: Intersection with Minimum Length

**Given:** Two interval lists and minimum length requirement

**Goal:** Find intersections with length ≥ minimum

```python
def intervalIntersection_minLength(list1, list2, min_length):
    """
    Find intersections with minimum length constraint
    
    Args:
        list1, list2: sorted interval lists
        min_length: minimum intersection length
    
    Returns:
        List of intersections with length ≥ min_length
    """
    result = []
    i = j = 0
    
    while i < len(list1) and j < len(list2):
        # Find intersection
        start = max(list1[i][0], list2[j][0])
        end = min(list1[i][1], list2[j][1])
        
        # Check if valid and meets length requirement
        if start <= end:
            length = end - start
            if length >= min_length:
                result.append([start, end])
        
        # Move pointer
        if list1[i][1] < list2[j][1]:
            i += 1
        else:
            j += 1
    
    return result


# Test
list1 = [[0,10], [15,20]]
list2 = [[5,8], [12,18]]
min_length = 3

result = intervalIntersection_minLength(list1, list2, min_length)
print(f"Intersections with length ≥ {min_length}: {result}")

"""
Intersections:
[0,10] ∩ [5,8] = [5,8] (length 3) ✓
[15,20] ∩ [12,18] = [15,18] (length 3) ✓

Both meet the minimum length requirement
"""
```

### Problem: Maximum Gap Between Intervals

**Given:** List of intervals

**Goal:** Find maximum gap between consecutive intervals

```python
def maxGap(intervals):
    """
    Find maximum gap between consecutive intervals
    
    Time: O(n log n)
    Space: O(1)
    """
    if len(intervals) < 2:
        return 0
    
    # Sort and merge overlapping intervals first
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    
    for interval in intervals[1:]:
        if interval[0] <= merged[-1][1]:
            merged[-1][1] = max(merged[-1][1], interval[1])
        else:
            merged.append(interval)
    
    # Find maximum gap
    max_gap = 0
    for i in range(1, len(merged)):
        gap = merged[i][0] - merged[i-1][1]
        max_gap = max(max_gap, gap)
    
    return max_gap


# Test
intervals = [[1,3], [6,9], [2,4], [15,20]]
result = maxGap(intervals)
print(f"Maximum gap: {result}")

"""
After merging: [[1,4], [6,9], [15,20]]

Gaps:
  Between [1,4] and [6,9]: 6 - 4 = 2
  Between [6,9] and [15,20]: 15 - 9 = 6

Maximum gap: 6
"""
```

## 8.5 Interval Covering Problems

### Problem: Minimum Intervals to Cover Target

**Given:** Array of intervals and target interval [start, end]

**Goal:** Minimum number of intervals needed to cover the target

```python
def minIntervalsToCover(intervals, target_start, target_end):
    """
    Minimum intervals to cover [target_start, target_end]
    
    Algorithm:
    1. Sort by start time
    2. Greedily extend coverage as far as possible
    3. Count intervals used
    
    Time: O(n log n)
    Space: O(1)
    
    Returns: number of intervals, or -1 if impossible
    """
    # Sort by start time
    intervals.sort()
    
    count = 0
    current_end = target_start
    i = 0
    
    while current_end < target_end:
        furthest_end = current_end
        
        # Look at all intervals that can extend current coverage
        while i < len(intervals) and intervals[i][0] <= current_end:
            furthest_end = max(furthest_end, intervals[i][1])
            i += 1
        
        # If we couldn't extend coverage
        if furthest_end == current_end:
            return -1  # Impossible to cover
        
        # Use this interval
        count += 1
        current_end = furthest_end
    
    return count


# Test
intervals = [[1,3], [2,6], [5,9], [10,15]]
target = (1, 12)

result = minIntervalsToCover(intervals, target[0], target[1])
print(f"Minimum intervals to cover {target}: {result}")

"""
Target: [1, 12]

Sorted: [[1,3], [2,6], [5,9], [10,15]]

Step 1: current_end = 1
  Check [1,3]: extends to 3
  Check [2,6]: extends to 6
  Use [2,6], count = 1, current_end = 6

Step 2: current_end = 6
  Check [5,9]: extends to 9
  Use [5,9], count = 2, current_end = 9

Step 3: current_end = 9
  Check [10,15]: starts at 10, but 10 > 9
  Gap! Need interval covering [9,10]
  Return -1 (impossible)

Note: In this example, there's a gap at [9,10]
"""
```

## Key Takeaways from Chapter 8

### Problem Pattern Recognition

| Pattern | Key Indicator | Algorithm |
|---------|---------------|-----------|
| Employee Free Time | Multiple schedules, find gaps | Merge all, find gaps |
| Calendar Booking | Add events, check conflicts | Overlap detection |
| Min Removals | Make non-overlapping | Activity selection inverse |
| Coverage | Cover target range | Greedy extension |

### Common Techniques

1. **Merge and Find Gaps**
   - Used in: Employee free time, max gap
   - Steps: Merge overlaps, find spaces between

2. **Overlap Tracking**
   - Used in: Calendar problems
   - Track single/double/k bookings separately

3. **Greedy Selection**
   - Used in: Min removals, max selection
   - Sort by end time, select greedily

4. **Sweep Line**
   - Used in: K-booking, max concurrent
   - Process events chronologically

### Interview Strategy

1. **Identify the core operation** - Merge, find gaps, count overlaps?
2. **Choose data structure** - List, heap, or balanced tree?
3. **Optimize for the operation** - Binary search when applicable
4. **Handle edge cases** - Empty input, no gaps, all overlap

### Practice Checklist

✓ Employee free time (merge and gap finding)  
✓ Calendar booking series (overlap detection)  
✓ Minimum removals (greedy selection)  
✓ Coverage problems (greedy extension)  
✓ Gap and distance problems  

### Next Steps

Chapter 9 will cover advanced data structures for interval operations including Interval Trees, Segment Trees, and efficient dynamic interval management!