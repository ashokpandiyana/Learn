# Chapter 9: Interval Tree & Advanced Data Structures

## 9.1 Interval Tree Construction

### What is an Interval Tree?

An **Interval Tree** is a balanced binary search tree designed for efficient interval queries:
- Store a set of intervals
- Quickly find all intervals that overlap with a query interval
- Support insertion and deletion

**Key Property:** Each node stores:
1. An interval [low, high]
2. The **maximum endpoint** in its subtree

### Structure Visualization

```
Example intervals: [15,20], [10,30], [17,19], [5,20], [12,15], [30,40]

Interval Tree:
                    [15,20] max=40
                   /                \
            [10,30] max=30      [30,40] max=40
           /          \                
      [5,20] max=20  [12,15] max=19
                           \
                        [17,19] max=19

Each node stores:
- Its interval
- Max endpoint in its subtree (used for search pruning)
```

### Why Store Max Endpoint?

The max endpoint allows us to **prune the search** efficiently:

```
Query: Find intervals overlapping [14,16]

At node [15,20] max=40:
  - Does [14,16] overlap [15,20]? NO
  - But max in subtree is 40, so subtrees might overlap
  - Must check both children

At node [10,30] max=30:
  - Does [14,16] overlap [10,30]? YES! Found one
  - Continue searching children

This pruning makes search O(log n + k) where k = results
```

### Implementation

```python
class Interval:
    """Represents an interval"""
    def __init__(self, low, high):
        self.low = low
        self.high = high
    
    def overlaps(self, other):
        """Check if this interval overlaps with another"""
        return self.low <= other.high and other.low <= self.high
    
    def __repr__(self):
        return f"[{self.low},{self.high}]"


class IntervalTreeNode:
    """Node in an interval tree"""
    def __init__(self, interval):
        self.interval = interval
        self.max_end = interval.high  # Max endpoint in subtree
        self.left = None
        self.right = None
        self.height = 1  # For AVL balancing


class IntervalTree:
    """
    Self-balancing interval tree (using AVL tree principles)
    
    Operations:
    - Insert: O(log n)
    - Delete: O(log n)
    - Search overlapping: O(log n + k) where k = number of results
    """
    
    def __init__(self):
        self.root = None
    
    def insert(self, low, high):
        """
        Insert new interval
        
        Time: O(log n)
        """
        interval = Interval(low, high)
        self.root = self._insert(self.root, interval)
    
    def _insert(self, node, interval):
        """Recursive insert with AVL balancing"""
        # Standard BST insertion
        if node is None:
            return IntervalTreeNode(interval)
        
        # Insert based on low endpoint (BST property)
        if interval.low < node.interval.low:
            node.left = self._insert(node.left, interval)
        else:
            node.right = self._insert(node.right, interval)
        
        # Update max endpoint
        node.max_end = max(
            node.interval.high,
            self._get_max(node.left),
            self._get_max(node.right)
        )
        
        # Update height
        node.height = 1 + max(
            self._get_height(node.left),
            self._get_height(node.right)
        )
        
        # Balance the node (AVL rotation)
        return self._balance(node)
    
    def _get_max(self, node):
        """Get max endpoint of subtree"""
        return node.max_end if node else float('-inf')
    
    def _get_height(self, node):
        """Get height of node"""
        return node.height if node else 0
    
    def _get_balance(self, node):
        """Get balance factor"""
        if not node:
            return 0
        return self._get_height(node.left) - self._get_height(node.right)
    
    def _balance(self, node):
        """Perform AVL rotations to balance"""
        balance = self._get_balance(node)
        
        # Left heavy
        if balance > 1:
            if self._get_balance(node.left) < 0:
                node.left = self._rotate_left(node.left)
            return self._rotate_right(node)
        
        # Right heavy
        if balance < -1:
            if self._get_balance(node.right) > 0:
                node.right = self._rotate_right(node.right)
            return self._rotate_left(node)
        
        return node
    
    def _rotate_right(self, z):
        """Right rotation"""
        y = z.left
        T3 = y.right
        
        y.right = z
        z.left = T3
        
        # Update heights
        z.height = 1 + max(self._get_height(z.left), self._get_height(z.right))
        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))
        
        # Update max endpoints
        z.max_end = max(z.interval.high, self._get_max(z.left), self._get_max(z.right))
        y.max_end = max(y.interval.high, self._get_max(y.left), self._get_max(y.right))
        
        return y
    
    def _rotate_left(self, z):
        """Left rotation"""
        y = z.right
        T2 = y.left
        
        y.left = z
        z.right = T2
        
        # Update heights
        z.height = 1 + max(self._get_height(z.left), self._get_height(z.right))
        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))
        
        # Update max endpoints
        z.max_end = max(z.interval.high, self._get_max(z.left), self._get_max(z.right))
        y.max_end = max(y.interval.high, self._get_max(y.left), self._get_max(y.right))
        
        return y
    
    def search_overlapping(self, low, high):
        """
        Find all intervals overlapping with [low, high]
        
        Time: O(log n + k) where k = number of results
        
        Returns: List of overlapping intervals
        """
        query = Interval(low, high)
        result = []
        self._search_overlapping(self.root, query, result)
        return result
    
    def _search_overlapping(self, node, query, result):
        """Recursive search for overlapping intervals"""
        if node is None:
            return
        
        # Check if current interval overlaps
        if node.interval.overlaps(query):
            result.append(node.interval)
        
        # Search left subtree if it might contain overlapping intervals
        # Left subtree might overlap if max endpoint >= query.low
        if node.left and node.left.max_end >= query.low:
            self._search_overlapping(node.left, query, result)
        
        # Search right subtree
        # Right subtree might overlap if node.interval.low <= query.high
        if node.right and node.interval.low <= query.high:
            self._search_overlapping(node.right, query, result)
    
    def inorder(self):
        """Return intervals in sorted order (by low endpoint)"""
        result = []
        self._inorder(self.root, result)
        return result
    
    def _inorder(self, node, result):
        """Inorder traversal"""
        if node:
            self._inorder(node.left, result)
            result.append(node.interval)
            self._inorder(node.right, result)
    
    def visualize(self):
        """Print tree structure"""
        self._visualize(self.root, "", True)
    
    def _visualize(self, node, prefix, is_tail):
        """Recursive visualization"""
        if node is None:
            return
        
        print(prefix + ("└── " if is_tail else "├── ") + 
              f"{node.interval} max={node.max_end}")
        
        if node.left or node.right:
            if node.right:
                self._visualize(node.right, 
                              prefix + ("    " if is_tail else "│   "), False)
            if node.left:
                self._visualize(node.left, 
                              prefix + ("    " if is_tail else "│   "), True)


# Example usage
tree = IntervalTree()

# Insert intervals
intervals_to_insert = [[15,20], [10,30], [17,19], [5,20], [12,15], [30,40]]
for low, high in intervals_to_insert:
    tree.insert(low, high)

print("Interval Tree Structure:")
tree.visualize()

print("\n\nSearch for overlaps with [14,16]:")
results = tree.search_overlapping(14, 16)
for interval in results:
    print(f"  {interval}")

print("\n\nSearch for overlaps with [25,35]:")
results = tree.search_overlapping(25, 35)
for interval in results:
    print(f"  {interval}")

"""
Output example:
Interval Tree Structure:
└── [15,20] max=40
    ├── [30,40] max=40
    └── [10,30] max=30
        ├── [12,15] max=19
        │   └── [17,19] max=19
        └── [5,20] max=20

Search for overlaps with [14,16]:
  [15,20]
  [10,30]
  [12,15]

Search for overlaps with [25,35]:
  [10,30]
  [30,40]
"""
```

### Step-by-Step Search Example

```
Tree structure:
                [15,20] max=40
               /              \
        [10,30] max=30    [30,40] max=40
       /          \
  [5,20]      [12,15] max=19
  max=20           \
                [17,19] max=19

Query: Find overlaps with [14,16]

═══════════════════════════════════════════════════════════
Visit root: [15,20] max=40
═══════════════════════════════════════════════════════════

Check overlap: [14,16] with [15,20]
  max(14,15)=15 <= min(16,20)=16? YES
  Add [15,20] to results ✓

Check left child:
  Left exists? YES
  Left max_end (30) >= query.low (14)? YES
  Recurse left ↓

Check right child:
  Right exists? YES
  Root interval.low (15) <= query.high (16)? YES
  Recurse right ↓

═══════════════════════════════════════════════════════════
Visit left child: [10,30] max=30
═══════════════════════════════════════════════════════════

Check overlap: [14,16] with [10,30]
  max(14,10)=14 <= min(16,30)=16? YES
  Add [10,30] to results ✓

Check left child:
  Left exists? YES ([5,20])
  Left max_end (20) >= query.low (14)? YES
  Recurse left ↓

Check right child:
  Right exists? YES ([12,15])
  Node interval.low (10) <= query.high (16)? YES
  Recurse right ↓

... (continues recursively)

Final results: [[15,20], [10,30], [12,15]]
```

## 9.2 Segment Tree for Intervals

### What is a Segment Tree?

A **Segment Tree** is used for:
- Range queries (sum, min, max)
- Range updates
- Interval coverage tracking

**Structure:** Binary tree where each node represents an interval/segment.

```
Example: Array [0, 1, 2, 3, 4, 5, 6, 7]

Segment Tree:
                  [0-7]
                /        \
            [0-3]          [4-7]
           /     \        /     \
        [0-1]   [2-3]  [4-5]   [6-7]
        /  \    /  \   /  \    /  \
      [0] [1] [2] [3][4] [5] [6] [7]

Each node represents a range and stores aggregate info
```

### Segment Tree for Interval Operations

```python
class SegmentTreeNode:
    """Node in segment tree"""
    def __init__(self, start, end):
        self.start = start
        self.end = end
        self.count = 0  # Number of intervals covering this segment
        self.left = None
        self.right = None


class SegmentTree:
    """
    Segment tree for interval operations
    
    Supports:
    - Add interval: O(log n)
    - Remove interval: O(log n)
    - Query coverage: O(log n)
    """
    
    def __init__(self, start, end):
        """
        Initialize segment tree for range [start, end]
        """
        self.root = self._build(start, end)
    
    def _build(self, start, end):
        """Build segment tree recursively"""
        node = SegmentTreeNode(start, end)
        
        if start == end:
            return node
        
        mid = (start + end) // 2
        node.left = self._build(start, mid)
        node.right = self._build(mid + 1, end)
        
        return node
    
    def add_interval(self, start, end):
        """
        Add interval [start, end] to the tree
        
        Time: O(log n)
        """
        self._add_interval(self.root, start, end)
    
    def _add_interval(self, node, start, end):
        """Recursive interval addition"""
        if node is None:
            return
        
        # If interval completely covers this node
        if start <= node.start and node.end <= end:
            node.count += 1
            return
        
        # If interval doesn't overlap this node
        if end < node.start or start > node.end:
            return
        
        # Partial overlap - recurse to children
        mid = (node.start + node.end) // 2
        if start <= mid:
            self._add_interval(node.left, start, end)
        if end > mid:
            self._add_interval(node.right, start, end)
    
    def remove_interval(self, start, end):
        """
        Remove interval [start, end]
        
        Time: O(log n)
        """
        self._remove_interval(self.root, start, end)
    
    def _remove_interval(self, node, start, end):
        """Recursive interval removal"""
        if node is None:
            return
        
        # If interval completely covers this node
        if start <= node.start and node.end <= end:
            node.count -= 1
            return
        
        # If interval doesn't overlap
        if end < node.start or start > node.end:
            return
        
        # Partial overlap - recurse
        mid = (node.start + node.end) // 2
        if start <= mid:
            self._remove_interval(node.left, start, end)
        if end > mid:
            self._remove_interval(node.right, start, end)
    
    def query_point(self, point):
        """
        Query how many intervals cover a specific point
        
        Time: O(log n)
        """
        return self._query_point(self.root, point)
    
    def _query_point(self, node, point):
        """Recursive point query"""
        if node is None:
            return 0
        
        # Accumulate count from ancestors
        total = node.count
        
        # If leaf node, return count
        if node.start == node.end:
            return total
        
        # Recurse to appropriate child
        mid = (node.start + node.end) // 2
        if point <= mid:
            total += self._query_point(node.left, point)
        else:
            total += self._query_point(node.right, point)
        
        return total
    
    def query_range_min_coverage(self, start, end):
        """
        Find minimum coverage in range [start, end]
        
        Time: O(log n)
        """
        return self._query_range_min(self.root, start, end)
    
    def _query_range_min(self, node, start, end):
        """Recursive range query for minimum"""
        if node is None:
            return float('inf')
        
        # Complete coverage
        if start <= node.start and node.end <= end:
            return self._get_min_in_subtree(node)
        
        # No overlap
        if end < node.start or start > node.end:
            return float('inf')
        
        # Partial overlap
        mid = (node.start + node.end) // 2
        left_min = self._query_range_min(node.left, start, end)
        right_min = self._query_range_min(node.right, start, end)
        
        return min(left_min, right_min)
    
    def _get_min_in_subtree(self, node):
        """Get minimum count in subtree"""
        if node is None:
            return float('inf')
        
        if node.start == node.end:
            return node.count
        
        return min(
            node.count + self._get_min_in_subtree(node.left),
            node.count + self._get_min_in_subtree(node.right)
        )


# Example usage
st = SegmentTree(0, 10)

# Add some intervals
st.add_interval(1, 5)
st.add_interval(3, 7)
st.add_interval(2, 4)

# Query points
print("Coverage at different points:")
for point in range(11):
    coverage = st.query_point(point)
    print(f"  Point {point}: {coverage} intervals")

"""
Output:
Coverage at different points:
  Point 0: 0 intervals
  Point 1: 1 intervals  ([1,5])
  Point 2: 2 intervals  ([1,5], [2,4])
  Point 3: 3 intervals  ([1,5], [3,7], [2,4])
  Point 4: 3 intervals  ([1,5], [3,7], [2,4])
  Point 5: 2 intervals  ([1,5], [3,7])
  Point 6: 1 intervals  ([3,7])
  Point 7: 1 intervals  ([3,7])
  Point 8: 0 intervals
  Point 9: 0 intervals
  Point 10: 0 intervals
"""
```

## 9.3 TreeMap-Based Solutions

### Using Ordered Map for Interval Management

Many interview problems can be solved efficiently using language-specific ordered maps:
- Python: `sortedcontainers.SortedDict`
- Java: `TreeMap`
- C++: `std::map`

```python
from sortedcontainers import SortedDict

class IntervalCollection:
    """
    Manage intervals dynamically using TreeMap
    
    Supports:
    - Add interval: O(log n)
    - Remove interval: O(log n)
    - Query overlaps: O(log n + k)
    """
    
    def __init__(self):
        # SortedDict: start -> end
        # Invariant: intervals are merged and non-overlapping
        self.intervals = SortedDict()
    
    def add_interval(self, start, end):
        """
        Add interval and merge with overlapping intervals
        
        Time: O(log n + k) where k = overlapping intervals
        """
        if start >= end:
            return
        
        # Find intervals that might overlap
        intervals_to_remove = []
        
        # Find leftmost potentially overlapping interval
        idx = self.intervals.bisect_right(start)
        if idx > 0:
            idx -= 1
            prev_start = self.intervals.iloc[idx]
            prev_end = self.intervals[prev_start]
            
            if prev_end >= start:
                # Extends into our new interval
                start = prev_start
                end = max(end, prev_end)
                intervals_to_remove.append(prev_start)
        
        # Find all intervals that overlap with [start, end]
        idx = self.intervals.bisect_left(start)
        while idx < len(self.intervals):
            curr_start = self.intervals.iloc[idx]
            if curr_start > end:
                break
            
            curr_end = self.intervals[curr_start]
            end = max(end, curr_end)
            intervals_to_remove.append(curr_start)
            idx += 1
        
        # Remove overlapping intervals
        for s in intervals_to_remove:
            del self.intervals[s]
        
        # Add merged interval
        self.intervals[start] = end
    
    def remove_interval(self, start, end):
        """
        Remove interval [start, end] from collection
        
        Time: O(log n + k)
        """
        if start >= end:
            return
        
        intervals_to_add = []
        intervals_to_remove = []
        
        # Find all overlapping intervals
        idx = self.intervals.bisect_right(start)
        if idx > 0:
            idx -= 1
        
        while idx < len(self.intervals):
            curr_start = self.intervals.iloc[idx]
            if curr_start >= end:
                break
            
            curr_end = self.intervals[curr_start]
            
            if curr_end <= start:
                idx += 1
                continue
            
            # This interval overlaps with [start, end]
            intervals_to_remove.append(curr_start)
            
            # Add left part if exists
            if curr_start < start:
                intervals_to_add.append((curr_start, start))
            
            # Add right part if exists
            if curr_end > end:
                intervals_to_add.append((end, curr_end))
            
            idx += 1
        
        # Remove affected intervals
        for s in intervals_to_remove:
            del self.intervals[s]
        
        # Add split intervals
        for s, e in intervals_to_add:
            self.intervals[s] = e
    
    def query_overlapping(self, start, end):
        """
        Find all intervals overlapping with [start, end]
        
        Time: O(log n + k)
        """
        result = []
        
        idx = self.intervals.bisect_right(start)
        if idx > 0:
            idx -= 1
        
        while idx < len(self.intervals):
            curr_start = self.intervals.iloc[idx]
            if curr_start >= end:
                break
            
            curr_end = self.intervals[curr_start]
            
            # Check overlap
            if curr_end > start:
                result.append([curr_start, curr_end])
            
            idx += 1
        
        return result
    
    def get_all_intervals(self):
        """Return all intervals"""
        return [[s, e] for s, e in self.intervals.items()]


# Example usage
collection = IntervalCollection()

# Add intervals
collection.add_interval(1, 5)
collection.add_interval(7, 10)
collection.add_interval(3, 8)  # Merges [1,5] and [7,10] to [1,10]

print("After adding [1,5], [7,10], [3,8]:")
print(collection.get_all_intervals())

# Query
overlaps = collection.query_overlapping(4, 9)
print(f"\nIntervals overlapping [4,9]: {overlaps}")

# Remove
collection.remove_interval(3, 6)
print(f"\nAfter removing [3,6]: {collection.get_all_intervals()}")

"""
Output:
After adding [1,5], [7,10], [3,8]:
[[1, 10]]

Intervals overlapping [4,9]:
[[1, 10]]

After removing [3,6]:
[[1, 3], [6, 10]]
"""
```

## 9.4 Comparison of Data Structures

### Performance Comparison

```python
def compare_data_structures():
    """Compare different interval data structures"""
    
    print("="*70)
    print("INTERVAL DATA STRUCTURES COMPARISON")
    print("="*70)
    
    structures = [
        {
            'name': 'Sorted List',
            'insert': 'O(n)',
            'delete': 'O(n)',
            'search': 'O(log n + k)',
            'space': 'O(n)',
            'use_case': 'Static intervals, mostly queries'
        },
        {
            'name': 'Interval Tree',
            'insert': 'O(log n)',
            'delete': 'O(log n)',
            'search': 'O(log n + k)',
            'space': 'O(n)',
            'use_case': 'Dynamic intervals, balanced operations'
        },
        {
            'name': 'Segment Tree',
            'insert': 'O(log n)',
            'delete': 'O(log n)',
            'search': 'O(log n)',
            'space': 'O(n)',
            'use_case': 'Range queries, interval coverage'
        },
        {
            'name': 'TreeMap/Ordered Map',
            'insert': 'O(log n)',
            'delete': 'O(log n)',
            'search': 'O(log n + k)',
            'space': 'O(n)',
            'use_case': 'Simple implementation, good all-around'
        },
    ]
    
    # Print comparison table
    print(f"\n{'Structure':<20} {'Insert':<12} {'Delete':<12} {'Search':<15} {'Space':<10}")
    print("-"*70)
    
    for struct in structures:
        print(f"{struct['name']:<20} {struct['insert']:<12} "
              f"{struct['delete']:<12} {struct['search']:<15} {struct['space']:<10}")
    
    print("\n" + "="*70)
    print("USE CASES")
    print("="*70)
    
    for struct in structures:
        print(f"\n{struct['name']}:")
        print(f"  Best for: {struct['use_case']}")


compare_data_structures()
```

### When to Use Each Structure

```
┌─────────────────────────────────────────────────────────────┐
│ DECISION TREE FOR INTERVAL DATA STRUCTURES                  │
└─────────────────────────────────────────────────────────────┘

Q: Are intervals mostly static (few updates)?
│
├─ YES → Use Sorted List
│         ✓ Simple implementation
│         ✓ Good for batch queries
│         ✗ Slow updates O(n)
│
└─ NO → Dynamic intervals...
    │
    Q: Need range aggregate queries (sum, min, max)?
    │
    ├─ YES → Use Segment Tree
    │         ✓ Efficient range queries
    │         ✓ Support range updates
    │         ✓ Good for coverage problems
    │
    └─ NO → Point/interval queries...
        │
        Q: Need to implement yourself or use library?
        │
        ├─ Implement → Use Interval Tree
        │              ✓ General purpose
        │              ✓ Educational value
        │              ✓ Balanced performance
        │
        └─ Use library → Use TreeMap/Ordered Map
                        ✓ Simple code
                        ✓ Reliable
                        ✓ Language built-in
```

## 9.5 Real-World Applications

### Application 1: Time Slot Booking System

```python
class TimeSlotBookingSystem:
    """
    Production-grade booking system using TreeMap
    """
    
    def __init__(self):
        self.booked = IntervalCollection()
    
    def book(self, start, end):
        """
        Book time slot [start, end]
        
        Returns: True if successful, False if conflict
        """
        # Check for conflicts
        conflicts = self.booked.query_overlapping(start, end)
        
        if conflicts:
            return False
        
        # Book the slot
        self.booked.add_interval(start, end)
        return True
    
    def cancel(self, start, end):
        """Cancel booking"""
        self.booked.remove_interval(start, end)
    
    def get_available_slots(self, start, end, duration):
        """
        Find available slots of given duration in range
        
        Returns: List of [start, end] for available slots
        """
        available = []
        current = start
        
        booked_intervals = self.booked.query_overlapping(start, end)
        booked_intervals.sort()
        
        for busy_start, busy_end in booked_intervals:
            # Check gap before this busy interval
            if current < busy_start:
                gap_duration = busy_start - current
                if gap_duration >= duration:
                    available.append([current, current + duration])
            
            current = max(current, busy_end)
        
        # Check final gap
        if current + duration <= end:
            available.append([current, current + duration])
        
        return available


# Example
booking_system = TimeSlotBookingSystem()
booking_system.book(10, 12)
booking_system.book(14, 16)

available = booking_system.get_available_slots(9, 18, duration=2)
print("Available 2-hour slots between 9-18:")
for slot in available:
    print(f"  {slot}")
```

### Application 2: Network Bandwidth Manager

```python
class BandwidthManager:
    """
    Manage network bandwidth allocation using segment tree
    """
    
    def __init__(self, max_time=100):
        self.segment_tree = SegmentTree(0, max_time)
        self.max_bandwidth = 100  # 100 Mbps
    
    def allocate(self, start, end, bandwidth):
        """
        Try to allocate bandwidth for time period
        
        Returns: True if successful
        """
        # Check if bandwidth available
        min_available = self._get_available_bandwidth(start, end)
        
        if min_available < bandwidth:
            return False
        
        # Allocate
        self.segment_tree.add_interval(start, end)
        return True
    
    def _get_available_bandwidth(self, start, end):
        """Get minimum available bandwidth in range"""
        used = self.segment_tree.query_range_min_coverage(start, end)
        return self.max_bandwidth - used


# Example
bw = BandwidthManager()
print(bw.allocate(0, 10, 50))   # True
print(bw.allocate(5, 15, 60))   # False (overlap at 5-10 would exceed)
```

## Key Takeaways from Chapter 9

### Data Structure Selection

| Need | Use | Why |
|------|-----|-----|
| Few updates, many queries | Sorted List | Simple, efficient queries |
| Balanced ops | Interval Tree | General purpose |
| Range queries | Segment Tree | Aggregate functions |
| Quick implementation | TreeMap | Library support |

### Complexity Cheat Sheet

```
Operation            Sorted List  Interval Tree  Segment Tree  TreeMap
─────────────────────────────────────────────────────────────────────
Insert                 O(n)         O(log n)       O(log n)      O(log n)
Delete                 O(n)         O(log n)       O(log n)      O(log n)
Search overlapping     O(log n+k)   O(log n+k)     N/A           O(log n+k)
Point query            O(log n)     O(log n)       O(log n)      O(log n)
Range query            O(n)         O(n)           O(log n)      O(n)
─────────────────────────────────────────────────────────────────────
Space                  O(n)         O(n)           O(n)          O(n)
```

### Implementation Tips

1. **Interval Tree**
   - Use AVL or Red-Black tree for balancing
   - Store max endpoint for pruning
   - Good for interview deep dives

2. **Segment Tree**
   - Build once for fixed range
   - Use lazy propagation for range updates
   - Perfect for coverage problems

3. **TreeMap**
   - Use language built-ins
   - Maintain merge invariant
   - Best for quick prototypes

### Interview Strategy

1. **Start simple** - Try sorted list first
2. **Identify bottleneck** - Is it updates or queries?
3. **Choose structure** - Based on operation frequency
4. **Implement incrementally** - Start with core operations
5. **Test edge cases** - Empty, single, all overlap

### Practice Problems

✓ Implement interval tree from scratch  
✓ Design calendar system with TreeMap  
✓ Range sum queries with segment tree  
✓ Dynamic interval merging  
✓ Interval coverage optimization  

Congratulations! You've completed the comprehensive guide to Interval Trees and Advanced Data Structures. You now have the tools to tackle any interval-related problem efficiently!