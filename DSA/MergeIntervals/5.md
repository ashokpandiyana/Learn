# Chapter 5: Meeting Rooms & Resource Allocation

## 5.1 Meeting Rooms I - Conflict Detection

### Problem Statement

**Given:** An array of meeting time intervals where `intervals[i] = [start_i, end_i]`

**Goal:** Determine if a person can attend all meetings (i.e., no two meetings overlap)

**Example:**
```
Input:  [[0,30], [5,10], [15,20]]
Output: false
Explanation: [0,30] overlaps with both [5,10] and [15,20]

Input:  [[7,10], [2,4]]
Output: true
Explanation: No overlaps
```

### Visual Understanding

```
Case 1: CAN attend all (no conflicts)
Timeline: 0--1--2--3--4--5--6--7--8--9--10

Meeting 1:    [===]
              2   4
Meeting 2:              [====]
                        7   10

No overlap → return true


Case 2: CANNOT attend all (conflicts exist)
Timeline: 0--1--2--3--4--5--6--7--8--9--10

Meeting 1: [====================]
           0                   10
Meeting 2:       [===]
                 5   7

Overlap → return false
```

### The Simple Sort-and-Check Algorithm

```python
def canAttendMeetings(intervals):
    """
    Check if a person can attend all meetings
    
    Approach: Sort by start time, check consecutive meetings
    
    Time Complexity: O(n log n) - dominated by sorting
    Space Complexity: O(1) - ignoring sort space
    
    Args:
        intervals: List[List[int]] - meeting intervals
    
    Returns:
        bool - True if can attend all, False otherwise
    """
    # Edge case: 0 or 1 meeting
    if len(intervals) <= 1:
        return True
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    # Check each consecutive pair
    for i in range(1, len(intervals)):
        # Previous meeting's end time
        prev_end = intervals[i-1][1]
        # Current meeting's start time
        curr_start = intervals[i][0]
        
        # If previous ends after current starts → overlap
        if prev_end > curr_start:
            return False
    
    # No overlaps found
    return True


# Test cases
test_cases = [
    ([[0,30], [5,10], [15,20]], False, "Multiple overlaps"),
    ([[7,10], [2,4]], True, "No overlaps"),
    ([[1,5], [6,10], [11,15]], True, "Adjacent, no overlaps"),
    ([[1,5], [5,10]], True, "Touch at boundary (no overlap)"),
    ([[1,5], [4,10]], False, "Partial overlap"),
    ([], True, "Empty list"),
    ([[1,5]], True, "Single meeting"),
]

for intervals, expected, desc in test_cases:
    result = canAttendMeetings(intervals[:])
    status = "✓" if result == expected else "✗"
    print(f"{status} {desc}")
    print(f"  Input: {intervals}")
    print(f"  Expected: {expected}, Got: {result}\n")
```

### Why Sorting Works

**Key Insight:** After sorting by start time, we only need to check consecutive pairs!

```
Without sorting - must check ALL pairs: O(n²)
Meeting 1 vs Meeting 2
Meeting 1 vs Meeting 3
Meeting 1 vs Meeting 4
Meeting 2 vs Meeting 3
Meeting 2 vs Meeting 4
Meeting 3 vs Meeting 4
...

With sorting - only check consecutive: O(n)
If Meeting 1 doesn't overlap Meeting 2,
and Meeting 2 doesn't overlap Meeting 3,
then Meeting 1 cannot overlap Meeting 3
(because starts are sorted!)

Sorted: [===]    [====]    [======]
          1 3    5    8    10     15

If [1,3] doesn't overlap [5,8], it cannot overlap [10,15]
```

### Step-by-Step Execution

```
Input: [[5,10], [0,30], [15,20]]

STEP 1: Sort by start time
Result: [[0,30], [5,10], [15,20]]

STEP 2: Check consecutive pairs

Check pair 1: [0,30] and [5,10]
  Previous end: 30
  Current start: 5
  Does 30 > 5? YES → OVERLAP FOUND
  Return false

Timeline visualization:
[0,30]:  [====================]
[5,10]:       [====]
              ↑
         Overlap at position 5-10
```

### Alternative Implementation: Strict vs Non-Strict

```python
def canAttendMeetings_strict(intervals):
    """
    Strict version: meetings that touch are also considered conflicts
    
    Example: [1,5] and [5,10] → conflict (both want time 5)
    """
    if len(intervals) <= 1:
        return True
    
    intervals.sort(key=lambda x: x[0])
    
    for i in range(1, len(intervals)):
        # Use >= instead of > for strict checking
        if intervals[i-1][1] >= intervals[i][0]:
            return False
    
    return True


def canAttendMeetings_lenient(intervals):
    """
    Lenient version: meetings can touch at boundaries
    
    Example: [1,5] and [5,10] → OK (meeting ends exactly when next begins)
    """
    if len(intervals) <= 1:
        return True
    
    intervals.sort(key=lambda x: x[0])
    
    for i in range(1, len(intervals)):
        # Use > for lenient checking
        if intervals[i-1][1] > intervals[i][0]:
            return False
    
    return True


# Compare both versions
test_intervals = [[1,5], [5,10]]
print("Intervals:", test_intervals)
print("Strict (can't touch):", canAttendMeetings_strict(test_intervals[:]))
print("Lenient (can touch):", canAttendMeetings_lenient(test_intervals[:]))

"""
Output:
Intervals: [[1,5], [5,10]]
Strict (can't touch): False
Lenient (can touch): True
"""
```

## 5.2 Meeting Rooms II - Minimum Resources

### Problem Statement

**Given:** An array of meeting time intervals

**Goal:** Find the **minimum number of meeting rooms** required to accommodate all meetings

**Example:**
```
Input:  [[0,30], [5,10], [15,20]]
Output: 2

Explanation:
Room 1: [0,30]
Room 2: [5,10], [15,20]
```

### Visual Understanding

```
Timeline: 0---5---10--15--20--25--30

[0,30]:   [========================]  Room 1
[5,10]:       [====]                  Room 2
[15,20]:             [====]           Room 2 (reused)

Maximum concurrent meetings: 2 (at time 5-10)
Minimum rooms needed: 2
```

### Approach 1: Chronological Ordering (Two Arrays)

The most intuitive and interview-friendly approach.

```python
def minMeetingRooms_chronological(intervals):
    """
    Minimum meeting rooms using chronological ordering
    
    Algorithm:
    1. Separate start and end times into two arrays
    2. Sort both arrays independently
    3. Use two pointers to track meetings starting/ending
    4. Track maximum concurrent meetings
    
    Time Complexity: O(n log n) - sorting
    Space Complexity: O(n) - two arrays
    
    Args:
        intervals: List[List[int]] - meeting intervals
    
    Returns:
        int - minimum number of rooms needed
    """
    if not intervals:
        return 0
    
    # Separate start and end times
    starts = sorted([interval[0] for interval in intervals])
    ends = sorted([interval[1] for interval in intervals])
    
    rooms_needed = 0
    max_rooms = 0
    start_pointer = 0
    end_pointer = 0
    
    # Process all events chronologically
    while start_pointer < len(starts):
        # If a meeting starts before earliest ending meeting
        if starts[start_pointer] < ends[end_pointer]:
            # We need a new room
            rooms_needed += 1
            start_pointer += 1
            
            # Update maximum
            max_rooms = max(max_rooms, rooms_needed)
        else:
            # A meeting ends, free up a room
            rooms_needed -= 1
            end_pointer += 1
    
    return max_rooms


# Test cases
test_cases = [
    ([[0,30], [5,10], [15,20]], 2, "Two concurrent at max"),
    ([[7,10], [2,4]], 1, "No overlap"),
    ([[1,5], [2,6], [3,7], [4,8]], 4, "All overlap"),
    ([[1,2], [2,3], [3,4]], 1, "Sequential meetings"),
    ([[1,10], [2,3], [4,5], [6,7]], 2, "Multiple within one"),
]

for intervals, expected, desc in test_cases:
    result = minMeetingRooms_chronological(intervals[:])
    status = "✓" if result == expected else "✗"
    print(f"{status} {desc}")
    print(f"  Input: {intervals}")
    print(f"  Expected: {expected}, Got: {result}\n")
```

### Deep Dive: How Chronological Ordering Works

```
Example: [[0,30], [5,10], [15,20]]

STEP 1: Separate and sort
starts = [0, 5, 15]  (sorted)
ends   = [10, 20, 30] (sorted)

STEP 2: Process chronologically
Timeline: 0---5---10--15--20--25--30
Events:   S   S   E   S   E       E
          ↓   ↓   ↓   ↓   ↓       ↓
        [0  [5  10] 15] 20]     30]

s_ptr = 0, e_ptr = 0, rooms = 0, max = 0

─────────────────────────────────────────────────
Iteration 1:
Compare starts[0]=0 with ends[0]=10
0 < 10? YES → Meeting starts
  rooms = 1
  max = 1
  s_ptr = 1

State: 1 room in use
Active: [0,...]

─────────────────────────────────────────────────
Iteration 2:
Compare starts[1]=5 with ends[0]=10
5 < 10? YES → Meeting starts
  rooms = 2
  max = 2
  s_ptr = 2

State: 2 rooms in use (peak!)
Active: [0,...] and [5,...]

─────────────────────────────────────────────────
Iteration 3:
Compare starts[2]=15 with ends[0]=10
15 < 10? NO → Meeting ends
  rooms = 1
  e_ptr = 1

State: 1 room in use
Active: [0,...], [5,10] ended

─────────────────────────────────────────────────
Iteration 4:
Compare starts[2]=15 with ends[1]=20
15 < 20? YES → Meeting starts
  rooms = 2
  max = 2 (unchanged)
  s_ptr = 3

State: 2 rooms in use
Active: [0,...] and [15,...]

─────────────────────────────────────────────────
All starts processed (s_ptr = 3)
Loop ends

Maximum rooms needed: 2
```

### Why This Algorithm is Brilliant

**Key Insight:** We don't need to track WHICH rooms are used, only HOW MANY are in use at any time!

```
Traditional approach (inefficient):
- Track each room explicitly
- Assign meetings to specific rooms
- Complex bookkeeping

Chronological approach (elegant):
- Only count rooms in use
- Treat starts as +1, ends as -1
- Maximum count = answer
```

### Approach 2: Priority Queue (Min Heap)

Explicitly track room end times.

```python
import heapq

def minMeetingRooms_heap(intervals):
    """
    Minimum meeting rooms using priority queue
    
    Algorithm:
    1. Sort meetings by start time
    2. Use min heap to track end times of ongoing meetings
    3. For each meeting, check if any room is free (earliest end time)
    4. Heap size = number of rooms needed
    
    Time Complexity: O(n log n)
    Space Complexity: O(n) - heap size
    
    Args:
        intervals: List[List[int]] - meeting intervals
    
    Returns:
        int - minimum number of rooms needed
    """
    if not intervals:
        return 0
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    # Min heap to track end times of meetings in progress
    # Heap contains end times of all currently allocated rooms
    rooms = []  # Min heap
    
    # Add first meeting
    heapq.heappush(rooms, intervals[0][1])
    
    # Process remaining meetings
    for i in range(1, len(intervals)):
        start, end = intervals[i]
        
        # If earliest ending meeting finishes before this one starts
        # We can reuse that room
        if rooms[0] <= start:
            heapq.heappop(rooms)  # Free up the room
        
        # Allocate room for current meeting
        # (either reused or new)
        heapq.heappush(rooms, end)
    
    # Number of rooms = heap size
    return len(rooms)


# Test with same cases
test_cases = [
    ([[0,30], [5,10], [15,20]], 2),
    ([[7,10], [2,4]], 1),
    ([[1,5], [2,6], [3,7], [4,8]], 4),
]

print("Testing Priority Queue Approach:")
for intervals, expected in test_cases:
    result = minMeetingRooms_heap(intervals[:])
    status = "✓" if result == expected else "✗"
    print(f"{status} Expected: {expected}, Got: {result}")
```

### Step-by-Step: Priority Queue Approach

```
Input: [[0,30], [5,10], [15,20]]

STEP 1: Sort by start time
Sorted: [[0,30], [5,10], [15,20]]

STEP 2: Process with heap

Initial: heap = []

─────────────────────────────────────────────────
Process [0,30]:
  Heap is empty, add first meeting
  heap = [30]
  Rooms in use: 1

Timeline:
Room 1: [========================]
        0                       30

─────────────────────────────────────────────────
Process [5,10]:
  Current start: 5
  Earliest end (heap[0]): 30
  Does 30 <= 5? NO → Can't reuse room
  
  Add new room
  heap = [10, 30]
  Rooms in use: 2

Timeline:
Room 1: [========================]
        0                       30
Room 2:     [====]
            5   10

─────────────────────────────────────────────────
Process [15,20]:
  Current start: 15
  Earliest end (heap[0]): 10
  Does 10 <= 15? YES → Can reuse room!
  
  Remove 10 from heap, add 20
  heap = [20, 30]
  Rooms in use: 2 (but reusing Room 2)

Timeline:
Room 1: [========================]
        0                       30
Room 2:     [====]      [====]
            5   10      15  20

─────────────────────────────────────────────────
Final: len(heap) = 2

Answer: 2 rooms needed
```

### Approach 3: Sweep Line Algorithm

Process all events (starts and ends) in chronological order.

```python
def minMeetingRooms_sweepline(intervals):
    """
    Minimum meeting rooms using sweep line
    
    Algorithm:
    1. Create events for all starts (+1) and ends (-1)
    2. Sort events by time
    3. Sweep through, tracking concurrent meetings
    
    Time Complexity: O(n log n)
    Space Complexity: O(n) - events list
    """
    if not intervals:
        return 0
    
    # Create events: (time, type)
    # type: 1 for start, -1 for end
    # Sort: if times equal, process end before start
    events = []
    for start, end in intervals:
        events.append((start, 1))     # Start event
        events.append((end, -1))      # End event
    
    # Sort by time, then by type (ends before starts)
    events.sort(key=lambda x: (x[0], x[1]))
    
    current_rooms = 0
    max_rooms = 0
    
    for time, event_type in events:
        current_rooms += event_type
        max_rooms = max(max_rooms, current_rooms)
    
    return max_rooms


# Test
intervals = [[0,30], [5,10], [15,20]]
result = minMeetingRooms_sweepline(intervals)
print(f"Sweep line result: {result}")

"""
Events after sorting:
(0, 1)   → Start, rooms = 1
(5, 1)   → Start, rooms = 2 (peak!)
(10, -1) → End, rooms = 1
(15, 1)  → Start, rooms = 2
(20, -1) → End, rooms = 1
(30, -1) → End, rooms = 0

Maximum: 2
"""
```

### Comparison of All Three Approaches

```python
def compare_approaches(intervals):
    """Compare all three approaches"""
    
    import time
    
    approaches = [
        ("Chronological", minMeetingRooms_chronological),
        ("Priority Queue", minMeetingRooms_heap),
        ("Sweep Line", minMeetingRooms_sweepline)
    ]
    
    print(f"Testing intervals: {intervals}\n")
    
    for name, func in approaches:
        start = time.time()
        result = func(intervals[:])
        elapsed = (time.time() - start) * 1000
        
        print(f"{name:20} Result: {result}, Time: {elapsed:.3f}ms")


# Test with different sizes
test_intervals = [[i, i+5] for i in range(0, 100, 2)]
compare_approaches(test_intervals)

"""
Which to use?

Interview (clarity):     Chronological ⭐
Production (efficiency): Priority Queue ⭐
Conceptual elegance:     Sweep Line ⭐

All have same complexity: O(n log n)
Choose based on:
- Code clarity
- Interviewer preference
- Your comfort level
"""
```

## 5.3 Extended Problems & Applications

### Problem 1: Description of Meeting Rooms Assignment

```python
def assignMeetingRooms(intervals):
    """
    Not only count rooms, but assign each meeting to a room
    
    Returns: List of room assignments for each meeting
    """
    if not intervals:
        return []
    
    # Add index to track original order
    indexed_intervals = [(interval, i) for i, interval in enumerate(intervals)]
    indexed_intervals.sort(key=lambda x: x[0][0])
    
    # rooms: list of (end_time, room_number)
    rooms = []
    assignments = [0] * len(intervals)
    next_room_id = 0
    
    for interval, original_idx in indexed_intervals:
        start, end = interval
        
        # Find room that ends earliest
        if rooms and rooms[0][0] <= start:
            # Reuse room
            end_time, room_id = heapq.heappop(rooms)
            assignments[original_idx] = room_id
            heapq.heappush(rooms, (end, room_id))
        else:
            # Allocate new room
            room_id = next_room_id
            next_room_id += 1
            assignments[original_idx] = room_id
            heapq.heappush(rooms, (end, room_id))
    
    return assignments


# Example
intervals = [[0,30], [5,10], [15,20]]
assignments = assignMeetingRooms(intervals)
print("Room assignments:", assignments)

"""
Output: [0, 1, 1]
Meeting [0,30] → Room 0
Meeting [5,10] → Room 1
Meeting [15,20] → Room 1 (reused)
"""
```

### Problem 2: Maximum Concurrent Meetings at Any Point

```python
def maxConcurrentMeetings(intervals):
    """
    Find the maximum number of concurrent meetings and when it occurs
    
    Returns: (max_count, time_point)
    """
    if not intervals:
        return (0, 0)
    
    events = []
    for start, end in intervals:
        events.append((start, 1))
        events.append((end, -1))
    
    events.sort()
    
    current = 0
    max_concurrent = 0
    max_time = 0
    
    for time, change in events:
        current += change
        if current > max_concurrent:
            max_concurrent = current
            max_time = time
    
    return (max_concurrent, max_time)


# Example
intervals = [[0,30], [5,10], [15,20]]
max_count, time = maxConcurrentMeetings(intervals)
print(f"Maximum {max_count} meetings at time {time}")
```

### Problem 3: Minimize Maximum Room Usage Time

```python
def minimizeMaxRoomUsage(intervals):
    """
    Distribute meetings to minimize maximum usage time of any single room
    
    This is a more complex scheduling problem
    """
    if not intervals:
        return []
    
    # Sort by duration (longest first) for better distribution
    intervals_with_idx = [(interval, i) for i, interval in enumerate(intervals)]
    intervals_with_idx.sort(key=lambda x: x[0][1] - x[0][0], reverse=True)
    
    # Track total time used per room
    rooms_usage = []  # List of (total_time_used, room_meetings)
    
    assignments = [0] * len(intervals)
    
    for interval, orig_idx in intervals_with_idx:
        start, end = interval
        duration = end - start
        
        if not rooms_usage:
            # First room
            heapq.heappush(rooms_usage, (duration, 0, [interval]))
            assignments[orig_idx] = 0
        else:
            # Add to room with least usage
            min_usage, room_id, meetings = heapq.heappop(rooms_usage)
            meetings.append(interval)
            heapq.heappush(rooms_usage, (min_usage + duration, room_id, meetings))
            assignments[orig_idx] = room_id
    
    return assignments
```

## Real-World Applications

### Application 1: Conference Room Booking System

```python
class ConferenceRoomSystem:
    """
    Real-world conference room booking system
    """
    def __init__(self, num_rooms):
        self.num_rooms = num_rooms
        self.bookings = []  # List of (start, end, room_id)
    
    def can_book(self, start, end):
        """Check if booking is possible"""
        # Add temporary booking
        temp_bookings = self.bookings + [(start, end, -1)]
        
        # Calculate rooms needed
        temp_bookings.sort()
        rooms_needed = self._min_rooms_needed([(s, e) for s, e, _ in temp_bookings])
        
        return rooms_needed <= self.num_rooms
    
    def book(self, start, end):
        """Book a meeting if possible"""
        if not self.can_book(start, end):
            return None
        
        # Find available room
        room_id = self._find_available_room(start, end)
        self.bookings.append((start, end, room_id))
        return room_id
    
    def _min_rooms_needed(self, intervals):
        """Helper to calculate minimum rooms"""
        if not intervals:
            return 0
        
        starts = sorted([s for s, e in intervals])
        ends = sorted([e for s, e in intervals])
        
        rooms = 0
        max_rooms = 0
        s_ptr = e_ptr = 0
        
        while s_ptr < len(starts):
            if starts[s_ptr] < ends[e_ptr]:
                rooms += 1
                max_rooms = max(max_rooms, rooms)
                s_ptr += 1
            else:
                rooms -= 1
                e_ptr += 1
        
        return max_rooms
    
    def _find_available_room(self, start, end):
        """Find which room is available"""
        used_rooms = set()
        
        for b_start, b_end, room_id in self.bookings:
            # Check if this booking conflicts
            if not (end <= b_start or start >= b_end):
                used_rooms.add(room_id)
        
        # Find first available room
        for room in range(self.num_rooms):
            if room not in used_rooms:
                return room
        
        return None


# Example usage
system = ConferenceRoomSystem(num_rooms=2)
print("Room 1:", system.book(0, 30))   # Room 0
print("Room 2:", system.book(5, 10))   # Room 1
print("Room 3:", system.book(15, 20))  # Room 1 (reused)
print("Room 4:", system.book(0, 5))    # None (no rooms available)
```

### Application 2: CPU Task Scheduling

```python
def scheduleTasks(tasks):
    """
    Schedule tasks on minimum number of CPUs
    tasks: list of (start, end, priority)
    
    Returns: (num_cpus, schedule)
    """
    if not tasks:
        return (0, [])
    
    # Sort by start time, then priority
    tasks.sort(key=lambda x: (x[0], -x[2]))
    
    cpus = []  # Min heap of (end_time, cpu_id, task_list)
    next_cpu = 0
    
    for start, end, priority in tasks:
        if cpus and cpus[0][0] <= start:
            # Reuse CPU
            end_time, cpu_id, task_list = heapq.heappop(cpus)
            task_list.append((start, end, priority))
            heapq.heappush(cpus, (end, cpu_id, task_list))
        else:
            # New CPU
            cpu_id = next_cpu
            next_cpu += 1
            heapq.heappush(cpus, (end, cpu_id, [(start, end, priority)]))
    
    num_cpus = len(cpus)
    schedule = [task_list for _, _, task_list in cpus]
    
    return (num_cpus, schedule)
```

## Key Takeaways from Chapter 5

### Algorithm Selection Guide

| Approach | Best For | Pros | Cons |
|----------|----------|------|------|
| Chronological | Interviews | Intuitive, easy to explain | Two arrays |
| Priority Queue | Production | Explicit room tracking | More complex |
| Sweep Line | Large datasets | Elegant, general | Less intuitive |

### Time Complexity Summary

All approaches: **O(n log n)** for sorting/heap operations

### Interview Strategy

**For Meeting Rooms I:**
1. Sort by start time
2. Check consecutive pairs
3. Return true/false

**For Meeting Rooms II:**
1. Choose chronological (easiest to explain)
2. Explain with timeline visualization
3. Walk through example step-by-step

### Common Interview Follow-ups

1. **"What if meetings can be rescheduled?"** → Greedy scheduling
2. **"Assign specific rooms"** → Track room IDs in heap
3. **"Minimize average wait time"** → Shortest-job-first scheduling
4. **"Priority meetings"** → Weighted interval scheduling (Chapter 6)
5. **"Real-time updates"** → Dynamic data structure (Segment Tree)

### Next Steps

Chapter 6 will cover Advanced Interval Patterns including interval scheduling maximization, weighted scheduling, and complex optimization problems!