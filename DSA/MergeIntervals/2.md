# Chapter 2: Core Merge Intervals Pattern

## 2.1 The Classic Merge Problem

### Problem Statement

**Given:** A collection of intervals that may overlap  
**Goal:** Merge all overlapping intervals to produce a collection of non-overlapping intervals

**Example:**
```
Input:  [[1,3], [2,6], [8,10], [15,18]]
Output: [[1,6], [8,10], [15,18]]

Explanation:
[1,3] and [2,6] overlap → merge to [1,6]
[8,10] stands alone
[15,18] stands alone
```

### Visual Walkthrough

```
Original intervals (unsorted):
Timeline: 0--1--2--3--4--5--6--7--8--9--10-11-12-13-14-15-16-17-18

[1,3]:       [===]
[2,6]:         [=========]
[8,10]:                       [===]
[15,18]:                                      [=====]

After merging:
[1,6]:       [===========]
[8,10]:                       [===]
[15,18]:                                      [=====]
```

### The Core Algorithm

The algorithm has **4 essential steps**:

1. **Sort** intervals by start time
2. **Initialize** result with the first interval
3. **Iterate** through remaining intervals
4. **Merge or Add**: Compare each interval with the last merged interval

```python
def merge_intervals(intervals):
    """
    Merge overlapping intervals
    
    Time Complexity: O(n log n) due to sorting
    Space Complexity: O(n) for output (or O(log n) if we ignore output)
    
    Args:
        intervals: List[List[int]] - list of intervals [[start, end], ...]
    
    Returns:
        List[List[int]] - merged intervals
    """
    # Edge case: empty or single interval
    if not intervals or len(intervals) <= 1:
        return intervals
    
    # Step 1: Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    # Step 2: Initialize result with first interval
    merged = [intervals[0]]
    
    # Step 3: Iterate through remaining intervals
    for current in intervals[1:]:
        # Get the last interval in merged list
        last_merged = merged[-1]
        
        # Step 4: Check if current overlaps with last merged
        if current[0] <= last_merged[1]:
            # Overlapping - merge by updating end time
            last_merged[1] = max(last_merged[1], current[1])
        else:
            # Non-overlapping - add as new interval
            merged.append(current)
    
    return merged

# Test cases
test_cases = [
    [[1,3], [2,6], [8,10], [15,18]],
    [[1,4], [4,5]],
    [[1,4], [2,3]],
    [[1,4], [0,4]],
    [[1,4], [0,1]]
]

for intervals in test_cases:
    print(f"Input:  {intervals}")
    print(f"Output: {merge_intervals(intervals)}")
    print()
```

### Step-by-Step Execution Example

Let's trace through the algorithm with input: `[[1,3], [2,6], [8,10], [15,18]]`

```
Initial: intervals = [[1,3], [2,6], [8,10], [15,18]]

STEP 1: Sort by start time
Already sorted: [[1,3], [2,6], [8,10], [15,18]]

STEP 2: Initialize merged list
merged = [[1,3]]

STEP 3 & 4: Iterate and merge/add

Iteration 1: current = [2,6]
  last_merged = [1,3]
  Check: 2 <= 3? YES (overlap)
  Action: Merge
  Update: [1,3] → [1, max(3,6)] = [1,6]
  merged = [[1,6]]
  
  Visual:
  [1,3]:  [===]
  [2,6]:    [=====]
  Result: [=======]

Iteration 2: current = [8,10]
  last_merged = [1,6]
  Check: 8 <= 6? NO (no overlap)
  Action: Add new interval
  merged = [[1,6], [8,10]]
  
  Visual:
  [1,6]:  [=======]
  [8,10]:            [===]
  Result: [=======]  [===]

Iteration 3: current = [15,18]
  last_merged = [8,10]
  Check: 15 <= 10? NO (no overlap)
  Action: Add new interval
  merged = [[1,6], [8,10], [15,18]]
  
  Visual:
  [8,10]:            [===]
  [15,18]:                      [=====]
  Result:            [===]      [=====]

FINAL: [[1,6], [8,10], [15,18]]
```

### Implementation in Multiple Languages

```java
// Java Implementation
import java.util.*;

class Solution {
    public int[][] merge(int[][] intervals) {
        // Edge case
        if (intervals.length <= 1) {
            return intervals;
        }
        
        // Step 1: Sort by start time
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        
        // Step 2: Use ArrayList for dynamic sizing
        List<int[]> merged = new ArrayList<>();
        merged.add(intervals[0]);
        
        // Step 3 & 4: Iterate and merge
        for (int i = 1; i < intervals.length; i++) {
            int[] current = intervals[i];
            int[] lastMerged = merged.get(merged.size() - 1);
            
            if (current[0] <= lastMerged[1]) {
                // Overlapping - merge
                lastMerged[1] = Math.max(lastMerged[1], current[1]);
            } else {
                // Non-overlapping - add
                merged.add(current);
            }
        }
        
        // Convert to array
        return merged.toArray(new int[merged.size()][]);
    }
}
```

```cpp
// C++ Implementation
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        // Edge case
        if (intervals.size() <= 1) {
            return intervals;
        }
        
        // Step 1: Sort by start time
        sort(intervals.begin(), intervals.end());
        
        // Step 2: Initialize result
        vector<vector<int>> merged;
        merged.push_back(intervals[0]);
        
        // Step 3 & 4: Iterate and merge
        for (int i = 1; i < intervals.size(); i++) {
            vector<int>& current = intervals[i];
            vector<int>& lastMerged = merged.back();
            
            if (current[0] <= lastMerged[1]) {
                // Overlapping - merge
                lastMerged[1] = max(lastMerged[1], current[1]);
            } else {
                // Non-overlapping - add
                merged.push_back(current);
            }
        }
        
        return merged;
    }
};
```

### Complexity Analysis

**Time Complexity: O(n log n)**
- Sorting: O(n log n)
- Single pass through intervals: O(n)
- Total: O(n log n) + O(n) = O(n log n)

**Space Complexity: O(n)**
- Result array: O(n) in worst case (no overlaps)
- Sorting: O(log n) extra space for recursion
- Total: O(n)

**Note:** If we don't count the output array, space is O(log n) for sorting.

## 2.2 Why Sorting is Essential

### The Problem Without Sorting

Without sorting, you'd need to compare each interval with ALL other intervals:

```python
def merge_without_sorting(intervals):
    """
    Inefficient approach without sorting
    Time: O(n²) - need to compare each with all others
    """
    if not intervals:
        return []
    
    merged = []
    used = [False] * len(intervals)
    
    for i in range(len(intervals)):
        if used[i]:
            continue
            
        current = intervals[i][:]
        used[i] = True
        
        # Must check ALL other intervals repeatedly
        changed = True
        while changed:
            changed = False
            for j in range(len(intervals)):
                if used[j]:
                    continue
                    
                if intervals[j][0] <= current[1] and intervals[j][1] >= current[0]:
                    # Merge
                    current[0] = min(current[0], intervals[j][0])
                    current[1] = max(current[1], intervals[j][1])
                    used[j] = True
                    changed = True
        
        merged.append(current)
    
    return merged

# This is much slower!
# Time: O(n²) vs O(n log n) with sorting
```

### Why Sorting Enables O(n) Merging

After sorting by start time, we get a crucial guarantee:

**Key Insight:** If interval A comes before interval B in the sorted list, and A doesn't overlap with B, then A won't overlap with any interval after B either.

```
Sorted intervals:
[1,4]:  [====]
[5,7]:         [===]
[8,9]:              [=]
[10,12]:               [===]

If [1,4] doesn't overlap with [5,7],
it can't possibly overlap with [8,9] or [10,12]!

Therefore, we only need to check the LAST merged interval.
```

### The Power of Sorting

```python
def demonstrate_sorting_power():
    """Show why sorting makes the algorithm work"""
    
    # Unsorted intervals
    unsorted = [[8,10], [1,3], [2,6], [15,18]]
    
    print("Unsorted intervals:")
    for interval in unsorted:
        print(f"  {interval}")
    
    # After sorting
    sorted_intervals = sorted(unsorted, key=lambda x: x[0])
    
    print("\nAfter sorting by start time:")
    for interval in sorted_intervals:
        print(f"  {interval}")
    
    print("\nNow we can merge in a single pass:")
    print("Compare each interval only with the LAST merged interval")
    
    # Without sorting: must compare [8,10] with [1,3], [2,6], [15,18]
    # With sorting: only need to track one "current merged" interval

demonstrate_sorting_power()
```

### Visualization: Sorted vs Unsorted

```
UNSORTED - Must check all pairs:
[8,10]  needs to check against → [1,3], [2,6], [15,18]
[1,3]   needs to check against → [8,10], [2,6], [15,18]
[2,6]   needs to check against → [8,10], [1,3], [15,18]
[15,18] needs to check against → [8,10], [1,3], [2,6]
Total comparisons: n * (n-1) / 2 = O(n²)

SORTED - Linear scan:
[1,3]   → Start first merged interval
[2,6]   → Compare with [1,3] only → Merge
[8,10]  → Compare with [1,6] only → Add new
[15,18] → Compare with [8,10] only → Add new
Total comparisons: n - 1 = O(n)
```

## 2.3 Merge Condition Variants

### Standard Merge: Overlapping Intervals

```python
def standard_overlap(last, current):
    """
    Standard overlap condition
    Merge if intervals overlap or touch
    """
    return current[0] <= last[1]

# Examples:
# [1,3] and [2,5] → 2 <= 3 → Merge to [1,5]
# [1,3] and [3,5] → 3 <= 3 → Merge to [1,5] (touching)
# [1,3] and [4,5] → 4 <= 3 → False → Don't merge
```

### Variant 1: Strict Overlap (No Touching)

Some problems require intervals to truly overlap, not just touch.

```python
def strict_overlap(last, current):
    """
    Strict overlap: Don't merge if only touching
    [1,3] and [3,5] should NOT merge
    """
    return current[0] < last[1]  # Strict inequality

def merge_strict(intervals):
    """Merge only strictly overlapping intervals"""
    if not intervals or len(intervals) <= 1:
        return intervals
    
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    
    for current in intervals[1:]:
        last = merged[-1]
        
        # Use strict inequality
        if current[0] < last[1]:  # Changed from <=
            last[1] = max(last[1], current[1])
        else:
            merged.append(current)
    
    return merged

# Test difference
print("Standard merge [[1,3], [3,5]]:")
print(merge_intervals([[1,3], [3,5]]))  # [[1,5]]

print("\nStrict merge [[1,3], [3,5]]:")
print(merge_strict([[1,3], [3,5]]))     # [[1,3], [3,5]]
```

### Variant 2: Merge Within Threshold

Some problems allow merging if intervals are within a certain distance.

```python
def merge_with_threshold(intervals, threshold=0):
    """
    Merge intervals within threshold distance
    
    threshold=0: standard merge
    threshold=1: merge if gap is <= 1
    threshold=2: merge if gap is <= 2
    """
    if not intervals or len(intervals) <= 1:
        return intervals
    
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    
    for current in intervals[1:]:
        last = merged[-1]
        
        # Merge if start is within threshold of last end
        if current[0] <= last[1] + threshold:
            last[1] = max(last[1], current[1])
        else:
            merged.append(current)
    
    return merged

# Examples
intervals = [[1,3], [5,7], [9,11]]

print("Original:", intervals)
print("Threshold 0:", merge_with_threshold(intervals, 0))  # No merge
print("Threshold 1:", merge_with_threshold(intervals, 1))  # No merge
print("Threshold 2:", merge_with_threshold(intervals, 2))  # Merge [1,3] & [5,7]
print("Threshold 4:", merge_with_threshold(intervals, 4))  # Merge all

"""
Visual with threshold=2:
[1,3]:  [===]
[5,7]:       ~~[===]    (gap of 2 units)
[9,11]:           ~~[===]

Threshold 2 allows merging [1,3] and [5,7] → [1,7]
But [7,9] gap is 2, so [5,7] and [9,11] also merge → [1,11]
"""
```

### Variant 3: Custom Merge Logic

Sometimes you need custom logic for specific problem requirements.

```python
def merge_with_custom_logic(intervals, should_merge):
    """
    Merge intervals using custom merge condition
    
    Args:
        intervals: list of intervals
        should_merge: function(last, current) -> bool
    """
    if not intervals or len(intervals) <= 1:
        return intervals
    
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    
    for current in intervals[1:]:
        last = merged[-1]
        
        if should_merge(last, current):
            last[1] = max(last[1], current[1])
        else:
            merged.append(current)
    
    return merged

# Example: Merge only if overlap is at least 2 units
def significant_overlap(last, current):
    """Merge only if overlap is at least 2 units"""
    overlap_start = max(last[0], current[0])
    overlap_end = min(last[1], current[1])
    overlap_size = max(0, overlap_end - overlap_start)
    return overlap_size >= 2

intervals = [[1,5], [3,6], [7,9], [8,10]]
result = merge_with_custom_logic(intervals, significant_overlap)
print(f"Significant overlap: {result}")

# [1,5] and [3,6] have overlap of 2 → merge to [1,6]
# [1,6] and [7,9] have no overlap → don't merge
# [7,9] and [8,10] have overlap of 1 → don't merge (need >= 2)
```

### Interview Clarification Checklist

**Always ask these questions:**

1. **Should touching intervals merge?**
   - `[1,3]` and `[3,5]` → `[1,5]` or keep separate?

2. **What about identical intervals?**
   - `[2,5]` and `[2,5]` → merge to `[2,5]`?

3. **Are intervals pre-sorted?**
   - Can skip sorting step if guaranteed sorted

4. **Can intervals have same start times?**
   - `[1,5]` and `[1,3]` → how to handle?

5. **What's the range of values?**
   - Important for optimization decisions

### Common Edge Cases

```python
def test_edge_cases():
    """Test all common edge cases"""
    
    test_cases = [
        # Case 1: Empty array
        ([], []),
        
        # Case 2: Single interval
        ([[1,3]], [[1,3]]),
        
        # Case 3: No overlaps
        ([[1,2], [3,4], [5,6]], [[1,2], [3,4], [5,6]]),
        
        # Case 4: All overlap into one
        ([[1,4], [2,5], [3,6]], [[1,6]]),
        
        # Case 5: Touching intervals
        ([[1,3], [3,5], [5,7]], [[1,7]]),
        
        # Case 6: One interval contains all others
        ([[1,10], [2,3], [4,5], [6,7]], [[1,10]]),
        
        # Case 7: Identical intervals
        ([[2,5], [2,5], [2,5]], [[2,5]]),
        
        # Case 8: Intervals with same start
        ([[1,5], [1,3], [1,7]], [[1,7]]),
        
        # Case 9: Intervals with same end
        ([[1,5], [3,5], [4,5]], [[1,5]]),
        
        # Case 10: Unsorted input
        ([[5,7], [1,3], [8,10], [2,6]], [[1,6], [8,10]]),
    ]
    
    for i, (input_intervals, expected) in enumerate(test_cases, 1):
        result = merge_intervals(input_intervals)
        status = "✓" if result == expected else "✗"
        print(f"Case {i}: {status}")
        print(f"  Input:    {input_intervals}")
        print(f"  Expected: {expected}")
        print(f"  Got:      {result}")
        print()

test_edge_cases()
```

## Key Takeaways from Chapter 2

### The Merge Intervals Recipe

1. **Always sort first** (unless already sorted)
2. **Compare with last merged interval** (not all previous)
3. **Update end time** when merging (use max)
4. **Add to result** when no overlap

### Time-Space Trade-offs

| Approach | Time | Space | When to Use |
|----------|------|-------|-------------|
| Sort + Merge | O(n log n) | O(n) | Standard approach |
| Without sorting | O(n²) | O(n) | Never use |
| In-place sort | O(n log n) | O(1) | When input can be modified |

### Critical Patterns to Remember

```python
# Pattern 1: Standard merge condition
if current[0] <= last[1]:
    last[1] = max(last[1], current[1])

# Pattern 2: Strict overlap
if current[0] < last[1]:
    last[1] = max(last[1], current[1])

# Pattern 3: Custom threshold
if current[0] <= last[1] + threshold:
    last[1] = max(last[1], current[1])
```

### Next Steps

Now that you've mastered basic merging, Chapter 3 will cover the **Insert Interval** pattern, which builds on these concepts for real-time interval management!