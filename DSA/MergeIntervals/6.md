# Chapter 6: Advanced Interval Patterns

## 6.1 Interval Scheduling Maximization (Activity Selection)

### Problem Statement

**Given:** A set of activities/intervals with start and end times

**Goal:** Select the **maximum number** of non-overlapping intervals

**Example:**
```
Input:  [[1,4], [3,5], [0,6], [5,7], [8,9], [5,9]]
Output: 3  (can select [1,4], [5,7], [8,9])
```

This is also known as the **Activity Selection Problem** - a classic greedy algorithm problem.

### Visual Understanding

```
Timeline: 0--1--2--3--4--5--6--7--8--9--10

[1,4]:     [====]
[3,5]:        [===]
[0,6]:  [===========]
[5,7]:            [===]
[8,9]:                  [=]
[5,9]:            [=======]

Greedy choice (sort by end time):
Pick [1,4]:     [====]
Pick [5,7]:            [===]
Pick [8,9]:                  [=]

Total: 3 intervals (maximum possible)
```

### The Greedy Algorithm: Sort by End Time

**Key Insight:** Always pick the interval that ends earliest! This leaves maximum room for future selections.

```python
def maxNonOverlappingIntervals(intervals):
    """
    Maximum number of non-overlapping intervals (Activity Selection)
    
    Greedy Algorithm:
    1. Sort by END time (not start time!)
    2. Greedily select intervals that don't overlap
    
    Time Complexity: O(n log n) - sorting
    Space Complexity: O(1)
    
    Args:
        intervals: List[List[int]] - activity intervals
    
    Returns:
        int - maximum number of non-overlapping intervals
    """
    if not intervals:
        return 0
    
    # CRITICAL: Sort by END time, not start time!
    intervals.sort(key=lambda x: x[1])
    
    count = 1  # Select first interval
    last_end = intervals[0][1]
    
    # Try to select remaining intervals
    for i in range(1, len(intervals)):
        start, end = intervals[i]
        
        # If current interval starts after last selected ends
        if start >= last_end:
            count += 1
            last_end = end
    
    return count


# Test cases
test_cases = [
    {
        'intervals': [[1,4], [3,5], [0,6], [5,7], [8,9], [5,9]],
        'expected': 3,
        'description': 'Classic example'
    },
    {
        'intervals': [[1,2], [2,3], [3,4], [1,3]],
        'expected': 3,
        'description': 'Sequential with one overlap'
    },
    {
        'intervals': [[1,2], [1,2], [1,2]],
        'expected': 1,
        'description': 'All identical'
    },
]

for test in test_cases:
    result = maxNonOverlappingIntervals(test['intervals'][:])
    status = "✓" if result == test['expected'] else "✗"
    print(f"{status} {test['description']}")
    print(f"  Expected: {test['expected']}, Got: {result}\n")
```

### Why Sort by End Time?

This is the **crucial insight** that makes the greedy algorithm work!

```
WRONG: Sort by start time
Intervals sorted by start:
[0,6]:  [===========]
[1,4]:   [====]
[3,5]:      [===]

If we pick [0,6] first (earliest start), we block [1,4] and [3,5]
Result: 1 interval (suboptimal!)

CORRECT: Sort by end time
Intervals sorted by end:
[1,4]:   [====]
[3,5]:      [===]
[0,6]:  [===========]

Pick [1,4] (earliest end) → Leaves room for [5,7], [8,9]
Result: 3 intervals (optimal!)
```

### Proof of Correctness

**Greedy Choice Property:** Choosing the interval that ends first is always safe.

**Proof by Exchange Argument:**
```
Let A be intervals sorted by end time: A1, A2, ..., An
Let OPT be an optimal solution
Let G be our greedy solution

Suppose OPT starts with some interval Aj where j > 1
We can replace Aj with A1 in OPT:
- A1 ends before Aj (by sorting)
- A1 doesn't conflict with intervals after Aj
- New solution is still valid and same size

Therefore, starting with A1 (earliest end) is optimal.
By induction, greedy choice at each step is optimal.
```

### Step-by-Step Execution

```
Input: [[1,4], [3,5], [0,6], [5,7], [8,9], [5,9]]

STEP 1: Sort by END time
Sorted: [[1,4], [3,5], [0,6], [5,7], [5,9], [8,9]]
         end:4   end:5   end:6   end:7   end:9   end:9

STEP 2: Greedy selection

Select [1,4] (first interval)
  count = 1
  last_end = 4

Timeline:
Selected: [====]
          1    4

─────────────────────────────────────────────────
Check [3,5]:
  start = 3
  Does 3 >= 4? NO
  Skip (overlaps with [1,4])

Timeline:
Selected: [====]
          1    4
Rejected:    [===]
             3   5

─────────────────────────────────────────────────
Check [0,6]:
  start = 0
  Does 0 >= 4? NO
  Skip (overlaps with [1,4])

Timeline:
Selected: [====]
          1    4
Rejected: [===========]
          0           6

─────────────────────────────────────────────────
Check [5,7]:
  start = 5
  Does 5 >= 4? YES
  Select it!
  count = 2
  last_end = 7

Timeline:
Selected: [====]  [===]
          1    4  5   7

─────────────────────────────────────────────────
Check [5,9]:
  start = 5
  Does 5 >= 7? NO
  Skip (overlaps with [5,7])

Timeline:
Selected: [====]  [===]
          1    4  5   7
Rejected:       [=======]
                5       9

─────────────────────────────────────────────────
Check [8,9]:
  start = 8
  Does 8 >= 7? YES
  Select it!
  count = 3
  last_end = 9

Timeline:
Selected: [====]  [===] [=]
          1    4  5   7 8 9

FINAL: count = 3
Selected intervals: [1,4], [5,7], [8,9]
```

### Returning the Actual Intervals

```python
def maxNonOverlappingIntervals_withSelection(intervals):
    """
    Return both count and the actual selected intervals
    """
    if not intervals:
        return (0, [])
    
    # Sort by end time
    intervals.sort(key=lambda x: x[1])
    
    selected = [intervals[0]]
    last_end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        start, end = intervals[i]
        
        if start >= last_end:
            selected.append([start, end])
            last_end = end
    
    return (len(selected), selected)


# Example
intervals = [[1,4], [3,5], [0,6], [5,7], [8,9], [5,9]]
count, selected = maxNonOverlappingIntervals_withSelection(intervals)
print(f"Maximum: {count}")
print(f"Selected: {selected}")
```

## 6.2 Weighted Interval Scheduling

### Problem Statement

**Given:** Intervals with associated weights/values

**Goal:** Select non-overlapping intervals to **maximize total weight**

**Example:**
```
Input:  [[1,3,50], [2,5,20], [4,6,30], [6,7,40], [5,8,10]]
        [start, end, weight]

Output: 120  (select [1,3,50], [4,6,30], [6,7,40])
```

This problem requires **Dynamic Programming** because greedy doesn't work!

### Why Greedy Fails for Weighted Scheduling

```
Example where greedy fails:

[1,10,weight=10]:  [=====================]
[2,3,weight=50]:    [=]
[4,5,weight=50]:        [=]

Greedy by end time:
  Pick [2,3,50] → blocks [1,10,10]
  Pick [4,5,50]
  Total: 100

Optimal:
  Pick [1,10,10]
  Total: 10... wait, that's worse!

Actually optimal:
  Pick [2,3,50] and [4,5,50]
  Total: 100

Let's try another example where greedy truly fails:

[1,4,weight=100]: [====]
[2,5,weight=50]:    [====]
[4,6,weight=75]:      [===]

Greedy by end time:
  Pick [1,4,100] → blocks [2,5,50]
  Pick [4,6,75]
  Total: 175

Optimal:
  Pick [2,5,50] and [4,6,75]
  Total: 125... No, greedy is better!

Real counterexample:

[1,4,weight=40]:  [====]
[2,5,weight=30]:    [====]
[5,8,weight=30]:        [====]
[6,9,weight=40]:          [====]

Greedy by end time + weight:
  Pick [1,4,40]
  Pick [5,8,30]
  Total: 70

Optimal:
  Pick [2,5,30] + [6,9,40]
  Total: 70... same!

Let me use a clearer example:

[1,10,weight=5]:  [====================]
[2,4,weight=6]:    [==]
[5,7,weight=6]:          [==]
[8,9,weight=6]:              [=]

Greedy (earliest end): [2,4], [5,7], [8,9] = 18
Optimal: Same = 18

Actual counterexample:

[1,5,weight=2]:   [=====]
[2,6,weight=5]:     [=====]
[4,8,weight=3]:       [=====]
[7,9,weight=5]:           [===]

Greedy: [1,5,2] + [7,9,5] = 7
Optimal: [2,6,5] + [7,9,5] = 10

NOW greedy fails!
```

### The Dynamic Programming Solution

```python
def weightedIntervalScheduling(intervals):
    """
    Maximum weight from non-overlapping weighted intervals
    
    DP Algorithm:
    1. Sort intervals by END time
    2. For each interval, decide: include it or exclude it
    3. Use binary search to find latest non-conflicting interval
    
    Time Complexity: O(n log n) - sorting + binary search
    Space Complexity: O(n) - DP array
    
    Args:
        intervals: List[List[int]] - [start, end, weight]
    
    Returns:
        int - maximum total weight
    """
    if not intervals:
        return 0
    
    # Sort by end time
    intervals.sort(key=lambda x: x[1])
    n = len(intervals)
    
    # dp[i] = maximum weight using intervals 0..i
    dp = [0] * n
    dp[0] = intervals[0][2]  # First interval's weight
    
    # For each interval
    for i in range(1, n):
        # Option 1: Exclude current interval
        exclude_weight = dp[i-1]
        
        # Option 2: Include current interval
        include_weight = intervals[i][2]  # Current weight
        
        # Find latest non-overlapping interval using binary search
        latest_non_conflict = findLatestNonConflicting(intervals, i)
        
        if latest_non_conflict != -1:
            include_weight += dp[latest_non_conflict]
        
        # Take maximum
        dp[i] = max(exclude_weight, include_weight)
    
    return dp[n-1]


def findLatestNonConflicting(intervals, current_idx):
    """
    Binary search to find latest interval that doesn't conflict
    with intervals[current_idx]
    
    Returns: index of latest non-conflicting interval, or -1
    """
    current_start = intervals[current_idx][0]
    
    # Binary search for latest interval that ends <= current_start
    left, right = 0, current_idx - 1
    result = -1
    
    while left <= right:
        mid = (left + right) // 2
        
        if intervals[mid][1] <= current_start:
            # This interval doesn't conflict
            result = mid
            left = mid + 1  # Try to find later one
        else:
            # This interval conflicts
            right = mid - 1
    
    return result


# Test
intervals = [
    [1, 5, 2],   # [start, end, weight]
    [2, 6, 5],
    [4, 8, 3],
    [7, 9, 5]
]

result = weightedIntervalScheduling(intervals)
print(f"Maximum weight: {result}")

"""
DP execution:
Sorted by end: [1,5,2], [2,6,5], [4,8,3], [7,9,5]

dp[0] = 2 (just [1,5,2])

dp[1]: 
  Exclude: dp[0] = 2
  Include: 5 + dp[find latest non-conflict]
    latest = -1 (no non-conflict before idx 1)
    Include: 5 + 0 = 5
  dp[1] = max(2, 5) = 5

dp[2]:
  Exclude: dp[1] = 5
  Include: 3 + dp[find latest non-conflict]
    latest = 0 ([1,5] ends at 5, [4,8] starts at 4, conflict!)
    Actually, need to check: 5 <= 4? NO, so -1
    Include: 3 + 0 = 3
  dp[2] = max(5, 3) = 5

dp[3]:
  Exclude: dp[2] = 5
  Include: 5 + dp[find latest non-conflict]
    latest = 1 ([2,6] ends at 6, [7,9] starts at 7: 6 <= 7? YES)
    Include: 5 + dp[1] = 5 + 5 = 10
  dp[3] = max(5, 10) = 10

Answer: 10 (select [2,6,5] and [7,9,5])
"""
```

### Step-by-Step DP Execution

```
Intervals: [[1,5,2], [2,6,5], [4,8,3], [7,9,5]]
After sorting by end: (already sorted)

Initialize dp array: [0, 0, 0, 0]

═══════════════════════════════════════════════════════════
Index 0: [1,5,2]
═══════════════════════════════════════════════════════════

dp[0] = weight = 2

Timeline:
[1,5,2]:  [=====]
dp[0] = 2

═══════════════════════════════════════════════════════════
Index 1: [2,6,5]
═══════════════════════════════════════════════════════════

Option 1 (Exclude): dp[0] = 2
Option 2 (Include): 5 + dp[latest non-conflict]
  
  Find latest non-conflict:
  [2,6,5] starts at 2
  Check [1,5,2]: ends at 5
  Does 5 <= 2? NO → conflict
  latest = -1
  
  Include: 5 + 0 = 5

dp[1] = max(2, 5) = 5

Decision: Include [2,6,5]

Timeline:
Best so far: [2,6,5]
             [=====]
dp[1] = 5

═══════════════════════════════════════════════════════════
Index 2: [4,8,3]
═══════════════════════════════════════════════════════════

Option 1 (Exclude): dp[1] = 5
Option 2 (Include): 3 + dp[latest non-conflict]
  
  Find latest non-conflict:
  [4,8,3] starts at 4
  Check [2,6,5]: ends at 6
  Does 6 <= 4? NO → conflict
  Check [1,5,2]: ends at 5
  Does 5 <= 4? NO → conflict
  latest = -1
  
  Include: 3 + 0 = 3

dp[2] = max(5, 3) = 5

Decision: Exclude [4,8,3], keep [2,6,5]

Timeline:
Best so far: [2,6,5]
             [=====]
dp[2] = 5

═══════════════════════════════════════════════════════════
Index 3: [7,9,5]
═══════════════════════════════════════════════════════════

Option 1 (Exclude): dp[2] = 5
Option 2 (Include): 5 + dp[latest non-conflict]
  
  Find latest non-conflict:
  [7,9,5] starts at 7
  Check [4,8,3]: ends at 8
  Does 8 <= 7? NO → conflict
  Check [2,6,5]: ends at 6
  Does 6 <= 7? YES → no conflict! ✓
  latest = 1
  
  Include: 5 + dp[1] = 5 + 5 = 10

dp[3] = max(5, 10) = 10

Decision: Include [7,9,5] + previous best ending at idx 1

Timeline:
Best solution: [2,6,5] + [7,9,5]
               [=====]   [===]
dp[3] = 10

FINAL ANSWER: 10
```

### Reconstructing the Solution

```python
def weightedIntervalScheduling_withSelection(intervals):
    """
    Return both max weight and the selected intervals
    """
    if not intervals:
        return (0, [])
    
    intervals.sort(key=lambda x: x[1])
    n = len(intervals)
    
    dp = [0] * n
    dp[0] = intervals[0][2]
    
    # Track decisions
    parent = [-1] * n  # parent[i] = latest non-conflict for interval i
    
    for i in range(1, n):
        exclude_weight = dp[i-1]
        include_weight = intervals[i][2]
        
        latest = findLatestNonConflicting(intervals, i)
        parent[i] = latest
        
        if latest != -1:
            include_weight += dp[latest]
        
        dp[i] = max(exclude_weight, include_weight)
    
    # Reconstruct solution
    selected = []
    i = n - 1
    
    while i >= 0:
        # Did we include interval i?
        include_val = intervals[i][2]
        if parent[i] != -1:
            include_val += dp[parent[i]]
        
        exclude_val = dp[i-1] if i > 0 else 0
        
        if include_val >= exclude_val:
            # We included this interval
            selected.append(intervals[i])
            i = parent[i]
        else:
            # We excluded this interval
            i -= 1
    
    selected.reverse()
    return (dp[n-1], selected)


# Test
intervals = [[1,5,2], [2,6,5], [4,8,3], [7,9,5]]
max_weight, selected = weightedIntervalScheduling_withSelection(intervals)
print(f"Maximum weight: {max_weight}")
print(f"Selected intervals: {selected}")
```

## 6.3 Minimum Arrows to Burst Balloons

### Problem Statement

**Given:** Balloons represented as intervals [start, end]

**Goal:** Find minimum number of arrows (points) to burst all balloons

**Example:**
```
Input:  [[10,16], [2,8], [1,6], [7,12]]
Output: 2

Explanation:
Arrow at x=6 bursts [2,8] and [1,6]
Arrow at x=11 bursts [10,16] and [7,12]
```

### The Greedy Solution

**Key Insight:** This is the INVERSE of activity selection - we want minimum points to cover all intervals.

```python
def findMinArrowShots(points):
    """
    Minimum arrows to burst all balloons
    
    Algorithm:
    1. Sort by END position
    2. Place arrow at end of first balloon
    3. This arrow bursts all balloons that contain this point
    4. Repeat for remaining balloons
    
    Time Complexity: O(n log n)
    Space Complexity: O(1)
    
    Args:
        points: List[List[int]] - balloon intervals
    
    Returns:
        int - minimum number of arrows
    """
    if not points:
        return 0
    
    # Sort by END position
    points.sort(key=lambda x: x[1])
    
    arrows = 1
    arrow_pos = points[0][1]  # Place first arrow at end of first balloon
    
    for i in range(1, len(points)):
        start, end = points[i]
        
        # If current balloon starts after arrow position
        if start > arrow_pos:
            # Need new arrow
            arrows += 1
            arrow_pos = end  # Place arrow at end of this balloon
    
    return arrows


# Test
balloons = [[10,16], [2,8], [1,6], [7,12]]
result = findMinArrowShots(balloons)
print(f"Minimum arrows: {result}")

"""
Execution:
Sorted by end: [1,6], [2,8], [7,12], [10,16]

Arrow 1 at position 6:
  Bursts [1,6] ✓
  Bursts [2,8] ✓ (contains 6)

Check [7,12]:
  Starts at 7 > 6
  Need new arrow!

Arrow 2 at position 12:
  Bursts [7,12] ✓
  Bursts [10,16] ✓ (contains 12)

Total: 2 arrows
"""
```

### Visual Walkthrough

```
Balloons: [[10,16], [2,8], [1,6], [7,12]]

After sorting by end:
[1,6]:   [======]
[2,8]:     [=======]
[7,12]:               [======]
[10,16]:                 [=======]

Step 1: Place arrow at end of [1,6]
Arrow 1 at position 6:
[1,6]:   [======]↓
[2,8]:     [=======]
Both burst by arrow at 6!

Step 2: Check [7,12]
[7,12]:               [======]
Starts at 7, arrow at 6
7 > 6, so need new arrow

Arrow 2 at position 12:
[7,12]:               [======]↓
[10,16]:                 [=======]
Both burst by arrow at 12!

Result: 2 arrows
```

### Why Sort by End Position?

```
Sorting by end ensures we place arrows optimally:

Timeline: 1--2--3--4--5--6--7--8--9--10-11-12-13-14-15-16

If we place arrow at END of first balloon:
- We burst that balloon ✓
- We burst maximum other balloons that overlap ✓
- We leave maximum room for future arrows ✓

This is the SAME PRINCIPLE as activity selection!
```

## 6.4 Video Stitching / Minimum Patches

### Problem Statement

**Given:** 
- Video clips with start and end times
- Target duration [0, T]

**Goal:** Minimum number of clips to cover [0, T]

**Example:**
```
Input:  clips = [[0,2], [4,6], [8,10], [1,9], [1,5], [5,9]]
        T = 10

Output: 3  (use [0,2], [1,9], [8,10])
```

### The Greedy Algorithm

```python
def videoStitching(clips, T):
    """
    Minimum clips to cover [0, T]
    
    Greedy Strategy:
    1. Sort by start time
    2. At each position, choose clip that extends furthest
    
    Time Complexity: O(n log n)
    Space Complexity: O(1)
    
    Args:
        clips: List[List[int]] - video clips
        T: int - target duration
    
    Returns:
        int - minimum clips needed, or -1 if impossible
    """
    # Sort by start time
    clips.sort()
    
    clips_used = 0
    current_end = 0  # Current coverage
    next_end = 0     # Furthest we can reach with one more clip
    i = 0
    
    while current_end < T:
        # Look at all clips that start at or before current_end
        while i < len(clips) and clips[i][0] <= current_end:
            # Among these, find the one that extends furthest
            next_end = max(next_end, clips[i][1])
            i += 1
        
        # If we can't extend coverage, impossible
        if next_end == current_end:
            return -1
        
        # Use the best clip found
        clips_used += 1
        current_end = next_end
        
        # If we've reached T, done!
        if current_end >= T:
            return clips_used
    
    return clips_used


# Test
clips = [[0,2], [4,6], [8,10], [1,9], [1,5], [5,9]]
T = 10
result = videoStitching(clips, T)
print(f"Minimum clips: {result}")

"""
Sorted clips: [0,2], [1,5], [1,9], [4,6], [5,9], [8,10]

Timeline: 0--1--2--3--4--5--6--7--8--9--10

Step 1: current_end = 0
  Check clips starting at/before 0:
    [0,2] extends to 2
  Best: next_end = 2
  Use clip [0,2]
  clips_used = 1, current_end = 2

Step 2: current_end = 2
  Check clips starting at/before 2:
    [1,5] extends to 5
    [1,9] extends to 9
  Best: next_end = 9
  Use clip [1,9]
  clips_used = 2, current_end = 9

Step 3: current_end = 9
  Check clips starting at/before 9:
    [4,6] extends to 6 (worse than 9)
    [5,9] extends to 9 (same as 9)
    [8,10] extends to 10
  Best: next_end = 10
  Use clip [8,10]
  clips_used = 3, current_end = 10

current_end >= T, done!
Answer: 3
"""
```

### Visual Execution

```
Clips: [[0,2], [4,6], [8,10], [1,9], [1,5], [5,9]]
Target: Cover [0, 10]

Sorted: [0,2], [1,5], [1,9], [4,6], [5,9], [8,10]

Timeline: 0--1--2--3--4--5--6--7--8--9--10
Coverage: ↑
          0

═══════════════════════════════════════════
Iteration 1: Cover from 0
═══════════════════════════════════════════

Available clips starting at/before 0:
[0,2]: [===]
       0   2

Choose [0,2] (only option)

Coverage: [===]
          0   2

═══════════════════════════════════════════
Iteration 2: Cover from 2
═══════════════════════════════════════════

Available clips starting at/before 2:
[1,5]: [=====]
       1     5
[1,9]: [=============]
       1             9

Choose [1,9] (extends furthest)

Coverage: [===][=========]
          0   2           9

═══════════════════════════════════════════
Iteration 3: Cover from 9
═══════════════════════════════════════════

Available clips starting at/before 9:
[4,6]:       [===]
             4   6
[5,9]:         [=====]
               5     9
[8,10]:              [===]
                     8  10

Choose [8,10] (extends to 10)

Coverage: [===][=========][=]
          0   2           9 10

Done! 10 >= target 10

Answer: 3 clips
```

## 6.5 Range Module - Dynamic Interval Management

### Problem Statement

Design a data structure that:
- `addRange(left, right)` - adds interval [left, right)
- `removeRange(left, right)` - removes interval [left, right)
- `queryRange(left, right)` - returns true if [left, right) is fully tracked

### Implementation with Ordered Map

```python
from sortedcontainers import SortedDict

class RangeModule:
    """
    Dynamic range management using balanced tree (SortedDict)
    
    Operations: O(log n) per operation
    """
    
    def __init__(self):
        # SortedDict: start -> end
        # Maintains non-overlapping intervals
        self.intervals = SortedDict()
    
    def addRange(self, left, right):
        """Add interval [left, right)"""
        
        # Find intervals that overlap with [left, right)
        # Merge all overlapping intervals
        
        # Find leftmost interval that could affect [left, right)
        idx = self.intervals.bisect_right(left)
        if idx > 0:
            idx -= 1
            prev_start = self.intervals.iloc[idx]
            prev_end = self.intervals[prev_start]
            
            if prev_end >= left:
                # Previous interval overlaps, extend from it
                left = prev_start
                right = max(right, prev_end)
                del self.intervals[prev_start]
        
        # Remove all intervals completely contained in [left, right)
        while True:
            idx = self.intervals.bisect_left(left)
            if idx >= len(self.intervals):
                break
            
            start = self.intervals.iloc[idx]
            if start >= right:
                break
            
            end = self.intervals[start]
            right = max(right, end)
            del self.intervals[start]
        
        # Add merged interval
        self.intervals[left] = right
    
    def removeRange(self, left, right):
        """Remove interval [left, right)"""
        
        # Find intervals that overlap with [left, right)
        # Split them as necessary
        
        intervals_to_add = []
        intervals_to_remove = []
        
        idx = self.intervals.bisect_right(left)
        if idx > 0:
            idx -= 1
        
        while idx < len(self.intervals):
            start = self.intervals.iloc[idx]
            if start >= right:
                break
            
            end = self.intervals[start]
            
            # If interval completely before left, skip
            if end <= left:
                idx += 1
                continue
            
            # Mark for removal
            intervals_to_remove.append(start)
            
            # Add left part if exists
            if start < left:
                intervals_to_add.append((start, left))
            
            # Add right part if exists
            if end > right:
                intervals_to_add.append((right, end))
            
            idx += 1
        
        # Remove affected intervals
        for start in intervals_to_remove:
            del self.intervals[start]
        
        # Add split intervals
        for start, end in intervals_to_add:
            self.intervals[start] = end
    
    def queryRange(self, left, right):
        """Check if [left, right) is fully covered"""
        
        idx = self.intervals.bisect_right(left)
        if idx == 0:
            return False
        
        idx -= 1
        start = self.intervals.iloc[idx]
        end = self.intervals[start]
        
        # Check if this interval covers [left, right)
        return start <= left and end >= right


# Usage example
rm = RangeModule()
rm.addRange(10, 20)
rm.removeRange(14, 16)
print(rm.queryRange(10, 14))  # True
print(rm.queryRange(13, 15))  # False
print(rm.queryRange(16, 17))  # True

"""
After addRange(10, 20):
  intervals = {10: 20}
  
  Timeline: 10-----------20
            [============]

After removeRange(14, 16):
  intervals = {10: 14, 16: 20}
  
  Timeline: 10-----14  16---20
            [======]    [====]

queryRange(10, 14): Covered by [10, 14] ✓
queryRange(13, 15): Spans gap [14, 16] ✗
queryRange(16, 17): Covered by [16, 20] ✓
"""
```

## Key Takeaways from Chapter 6

### Algorithm Selection Guide

| Problem Type | Algorithm | Time | Key Insight |
|--------------|-----------|------|-------------|
| Max Non-Overlapping | Greedy (sort by end) | O(n log n) | Earliest end leaves room |
| Weighted Intervals | Dynamic Programming | O(n log n) | Greedy fails! |
| Min Coverage Points | Greedy (sort by end) | O(n log n) | Inverse of max selection |
| Cover Target Range | Greedy (extend furthest) | O(n log n) | Jump game variant |
| Dynamic Range Ops | Balanced Tree | O(log n) | Maintain sorted intervals |

### Patterns Summary

**Pattern 1: Activity Selection**
- Sort by END time
- Greedily select non-overlapping
- Proof by exchange argument

**Pattern 2: Weighted Scheduling**
- DP with binary search
- Must try include/exclude
- Track best at each step

**Pattern 3: Coverage Problems**
- Greedy extension
- Choose interval extending furthest
- Jump game thinking

**Pattern 4: Dynamic Updates**
- Balanced tree structure
- Maintain invariants
- Handle splits/merges

### Common Mistakes

❌ Sorting by start time for activity selection  
❌ Using greedy for weighted problems  
❌ Not considering impossible cases  
❌ Forgetting to handle gaps in coverage  
❌ Incorrect merging logic in range modules

### Interview Tips

1. **Identify the pattern** - Selection vs coverage vs weighted
2. **Choose algorithm** - Greedy vs DP vs data structure
3. **Prove correctness** - Especially for greedy choices
4. **Handle edge cases** - Empty input, impossible cases
5. **Optimize** - Binary search, balanced trees

### Mastery Checklist

✓ Understand why greedy works for unweighted problems  
✓ Know when DP is necessary (weighted intervals)  
✓ Can implement binary search for DP optimization  
✓ Can design data structures for dynamic updates  
✓ Recognize problem variants quickly  

Congratulations! You've completed the comprehensive guide to Merge Intervals patterns from beginner to advanced level!