# Chapter 1: Fundamentals of Interval Data Structure

## 1.1 Understanding Intervals

### What is an Interval?

An interval represents a continuous range between two points. In computer science and algorithmic problems, an interval is typically represented as a pair of integers `[start, end]` where `start ≤ end`.

**Visual Representation:**
```
Timeline:  0----1----2----3----4----5----6----7----8----9----10
Interval:       [----2, 5----]
                     ↑    ↑
                   start end
```

### Types of Intervals

#### 1. Closed Interval [a, b]
Both endpoints are included in the interval.
```
[2, 5] includes: 2, 3, 4, 5
Visual: [=====]
```

#### 2. Open Interval (a, b)
Neither endpoint is included.
```
(2, 5) includes: 3, 4 (not 2 or 5)
Visual: (=====)
```

#### 3. Half-Open Intervals
- [a, b) - includes a, excludes b
- (a, b] - excludes a, includes b

```
[2, 5) includes: 2, 3, 4 (not 5)
Visual: [=====)
```

### Interval Representation in Code

```python
# Python - Using list or tuple
interval = [1, 5]  # List (mutable)
interval = (1, 5)  # Tuple (immutable, preferred)

# Using a class for better semantics
class Interval:
    def __init__(self, start, end):
        self.start = start
        self.end = end
    
    def __repr__(self):
        return f"[{self.start}, {self.end}]"

# Creating an interval
interval = Interval(1, 5)
```

```java
// Java - Using array or custom class
int[] interval = {1, 5};  // Array representation

// Custom class (recommended)
class Interval {
    int start;
    int end;
    
    public Interval(int start, int end) {
        this.start = start;
        this.end = end;
    }
}

// LeetCode often provides this class
Interval interval = new Interval(1, 5);
```

```cpp
// C++ - Using pair or struct
pair<int, int> interval = {1, 5};  // Using STL pair

// Using vector
vector<int> interval = {1, 5};

// Using struct (most readable)
struct Interval {
    int start;
    int end;
    
    Interval(int s, int e) : start(s), end(e) {}
};

Interval interval(1, 5);
```

### Important Notes for Interviews

1. **Always Clarify Endpoint Inclusion:** The first question you should ask in an interval problem is whether endpoints are inclusive or exclusive.

2. **Default Assumption:** Unless stated otherwise, most interview problems use closed intervals [a, b] where both endpoints are included.

3. **Validity Check:** A valid interval must satisfy `start ≤ end`. Some problems may give you invalid intervals to handle.

```python
def is_valid_interval(interval):
    """Check if an interval is valid"""
    start, end = interval
    return start <= end

# Examples
print(is_valid_interval([2, 5]))   # True
print(is_valid_interval([5, 2]))   # False
print(is_valid_interval([3, 3]))   # True (single point)
```

## 1.2 Interval Relationships

### The Six Basic Relationships

Two intervals can relate to each other in exactly six ways (plus their inverses):

```
Timeline: 0---1---2---3---4---5---6---7---8---9---10

1. BEFORE (disjoint, no overlap)
   A: [1,2]
   B:         [5,7]
   Visual: [==]   [====]

2. MEETS (adjacent, touching)
   A: [1,3]
   B:     [3,5]
   Visual: [===][===]

3. OVERLAPS (partial overlap)
   A: [1,4]
   B:     [3,6]
   Visual: [====]
             [====]

4. FINISHED-BY (ends together)
   A: [1,5]
   B:     [3,5]
   Visual: [======]
             [===]

5. CONTAINS (A contains B)
   A: [1,7]
   B:   [3,5]
   Visual: [========]
             [==]

6. STARTS (begins together)
   A: [1,5]
   B: [1,3]
   Visual: [======]
           [==]

7. EQUALS (identical)
   A: [2,5]
   B: [2,5]
   Visual: [===]
           [===]
```

### Detecting Interval Relationships

```python
def get_relationship(interval_a, interval_b):
    """
    Determine the relationship between two intervals
    Returns: 'before', 'meets', 'overlaps', 'finished_by', 
             'contains', 'starts', 'equals', or their inverses
    """
    a_start, a_end = interval_a
    b_start, b_end = interval_b
    
    # Equal
    if a_start == b_start and a_end == b_end:
        return 'equals'
    
    # Before
    if a_end < b_start:
        return 'before'
    if b_end < a_start:
        return 'after'
    
    # Meets (touching)
    if a_end == b_start:
        return 'meets'
    if b_end == a_start:
        return 'met_by'
    
    # Starts (same start, different end)
    if a_start == b_start:
        if a_end < b_end:
            return 'starts'
        else:
            return 'started_by'
    
    # Finishes (same end, different start)
    if a_end == b_end:
        if a_start > b_start:
            return 'finishes'
        else:
            return 'finished_by'
    
    # Contains
    if a_start < b_start and a_end > b_end:
        return 'contains'
    if b_start < a_start and b_end > a_end:
        return 'during'
    
    # Overlaps
    if a_start < b_start and a_end > b_start and a_end < b_end:
        return 'overlaps'
    if b_start < a_start and b_end > a_start and b_end < a_end:
        return 'overlapped_by'
    
    return 'unknown'

# Test examples
print(get_relationship([1, 3], [5, 7]))      # before
print(get_relationship([1, 3], [3, 5]))      # meets
print(get_relationship([1, 4], [3, 6]))      # overlaps
print(get_relationship([1, 7], [3, 5]))      # contains
```

### The Crucial Overlap Detection

**For most interview problems, you only need to know IF intervals overlap, not the specific relationship type.**

#### Overlap Detection Formula

Two intervals `[a, b]` and `[c, d]` overlap if and only if:
```
max(a, c) <= min(b, d)
```

**Why this works:**
- `max(a, c)` is the latest start point
- `min(b, d)` is the earliest end point
- If the latest start is before or equal to the earliest end, they must overlap

```python
def do_intervals_overlap(interval1, interval2):
    """
    Check if two intervals overlap
    Time: O(1), Space: O(1)
    """
    a, b = interval1
    c, d = interval2
    
    # Method 1: Using max and min (most intuitive)
    return max(a, c) <= min(b, d)

# Alternative implementations

def do_intervals_overlap_v2(interval1, interval2):
    """Method 2: Check non-overlap conditions"""
    a, b = interval1
    c, d = interval2
    
    # They don't overlap if one ends before the other starts
    # So they overlap if this is NOT true
    return not (b < c or d < a)

def do_intervals_overlap_v3(interval1, interval2):
    """Method 3: Direct overlap check"""
    a, b = interval1
    c, d = interval2
    
    # Start of one is within the range of the other
    return (a <= c <= b) or (c <= a <= d)

# Test all methods
intervals_pair = [([1, 4], [3, 6]),    # True - overlap
                  ([1, 3], [4, 6]),    # False - no overlap
                  ([1, 5], [5, 7]),    # True - touch at 5
                  ([2, 5], [3, 4])]    # True - contains

for pair in intervals_pair:
    print(f"{pair[0]} and {pair[1]}: {do_intervals_overlap(*pair)}")
```

**Visual Examples:**
```
Overlap: YES
[1, 4]:  [====]
[3, 6]:      [====]
max(1,3)=3, min(4,6)=4, 3<=4 ✓

Overlap: NO
[1, 3]:  [===]
[4, 6]:       [===]
max(1,4)=4, min(3,6)=3, 4<=3 ✗

Overlap: YES (touching)
[1, 5]:  [=====]
[5, 7]:       [===]
max(1,5)=5, min(5,7)=5, 5<=5 ✓

Overlap: YES (contains)
[2, 5]:  [====]
[3, 4]:   [=]
max(2,3)=3, min(5,4)=4, 3<=4 ✓
```

### Special Cases in Overlap Detection

```python
def test_special_cases():
    """Test edge cases for overlap detection"""
    
    # 1. Intervals touch at a point
    print("Touching intervals [1,3] and [3,5]:")
    print(do_intervals_overlap([1, 3], [3, 5]))  # True
    # Note: Change to b < c and d < a for strict overlap (no touching)
    
    # 2. Point interval (start == end)
    print("\nPoint interval [3,3] and [2,5]:")
    print(do_intervals_overlap([3, 3], [2, 5]))  # True
    
    # 3. One interval contains the other
    print("\nContains: [1,10] and [3,5]:")
    print(do_intervals_overlap([1, 10], [3, 5]))  # True
    
    # 4. Identical intervals
    print("\nIdentical: [2,5] and [2,5]:")
    print(do_intervals_overlap([2, 5], [2, 5]))  # True
    
    # 5. Zero-length intervals
    print("\nZero-length: [0,0] and [0,0]:")
    print(do_intervals_overlap([0, 0], [0, 0]))  # True

test_special_cases()
```

## 1.3 Basic Interval Operations

### Operation 1: Merge Two Intervals

Merging combines two overlapping or adjacent intervals into a single interval.

**Merge Condition:** Only merge if intervals overlap or touch.

```python
def merge_two_intervals(interval1, interval2):
    """
    Merge two intervals if they overlap or touch
    Returns: merged interval or None if they don't overlap
    Time: O(1), Space: O(1)
    """
    a, b = interval1
    c, d = interval2
    
    # Check if they overlap or touch
    if max(a, c) <= min(b, d):
        # They overlap or touch, merge them
        return [min(a, c), max(b, d)]
    else:
        # They don't overlap, can't merge
        return None

# Examples
print(merge_two_intervals([1, 4], [3, 6]))   # [1, 6]
print(merge_two_intervals([1, 3], [3, 5]))   # [1, 5]
print(merge_two_intervals([1, 3], [5, 7]))   # None
print(merge_two_intervals([2, 8], [3, 5]))   # [2, 8]
```

**Visual Examples:**
```
Merge [1,4] and [3,6]:
Before: [====]
            [====]
After:  [========]  -> [1, 6]

Merge [1,3] and [3,5] (touching):
Before: [===][===]
After:  [========]  -> [1, 5]

Can't merge [1,3] and [5,7]:
Before: [===] [===]
After:  [===] [===]  -> No change (return None)
```

### Operation 2: Intersection of Two Intervals

The intersection is the overlapping portion of two intervals.

```python
def intersect_two_intervals(interval1, interval2):
    """
    Find the intersection of two intervals
    Returns: intersection interval or None if no overlap
    Time: O(1), Space: O(1)
    """
    a, b = interval1
    c, d = interval2
    
    # Calculate intersection boundaries
    start = max(a, c)  # Latest start point
    end = min(b, d)    # Earliest end point
    
    # Check if valid intersection exists
    if start <= end:
        return [start, end]
    else:
        return None

# Examples
print(intersect_two_intervals([1, 5], [3, 7]))   # [3, 5]
print(intersect_two_intervals([1, 3], [5, 7]))   # None
print(intersect_two_intervals([2, 8], [3, 5]))   # [3, 5]
print(intersect_two_intervals([1, 5], [5, 7]))   # [5, 5]
```

**Visual Examples:**
```
Intersect [1,5] and [3,7]:
A:      [=====]
B:          [=====]
Result:     [==]      -> [3, 5]

Intersect [1,3] and [5,7]:
A:      [===]
B:            [===]
Result: (none)        -> None

Intersect [2,8] and [3,5]:
A:      [========]
B:        [==]
Result:   [==]        -> [3, 5]
```

### Operation 3: Union of Intervals

Union combines intervals, keeping separate intervals if they don't overlap.

```python
def union_two_intervals(interval1, interval2):
    """
    Find the union of two intervals
    Returns: list of intervals (1 if merged, 2 if separate)
    Time: O(1), Space: O(1)
    """
    a, b = interval1
    c, d = interval2
    
    # Check if they overlap or touch
    if max(a, c) <= min(b, d):
        # They overlap, return single merged interval
        return [[min(a, c), max(b, d)]]
    else:
        # They don't overlap, return both (sorted)
        if a < c:
            return [[a, b], [c, d]]
        else:
            return [[c, d], [a, b]]

# Examples
print(union_two_intervals([1, 4], [3, 6]))   # [[1, 6]]
print(union_two_intervals([1, 3], [5, 7]))   # [[1, 3], [5, 7]]
print(union_two_intervals([5, 7], [1, 3]))   # [[1, 3], [5, 7]]
```

### Operation 4: Difference of Intervals

Difference removes the second interval from the first.

```python
def difference_intervals(interval1, interval2):
    """
    Find A - B (parts of A not in B)
    Returns: list of remaining interval(s) after subtraction
    Time: O(1), Space: O(1)
    """
    a, b = interval1
    c, d = interval2
    
    result = []
    
    # If no overlap, return original interval
    if b < c or d < a:
        return [[a, b]]
    
    # Left part: [a, c-1] if a < c
    if a < c:
        result.append([a, c])
    
    # Right part: [d+1, b] if d < b
    if d < b:
        result.append([d, b])
    
    # If result is empty, interval2 completely covers interval1
    return result if result else []

# Examples
print(difference_intervals([1, 8], [3, 5]))   # [[1, 3], [5, 8]]
print(difference_intervals([1, 5], [3, 7]))   # [[1, 3]]
print(difference_intervals([1, 3], [5, 7]))   # [[1, 3]]
print(difference_intervals([3, 5], [1, 7]))   # []
```

**Visual Examples:**
```
Difference [1,8] - [3,5]:
A:      [=========]
B:        [==]
Result: [=]   [==]  -> [[1, 3], [5, 8]]

Difference [1,5] - [3,7]:
A:      [=====]
B:          [=====]
Result: [==]        -> [[1, 3]]

Difference [3,5] - [1,7]:
A:        [==]
B:      [=========]
Result: (none)      -> []
```

### Complete Example: Combining All Operations

```python
class IntervalOperations:
    """A complete class for basic interval operations"""
    
    @staticmethod
    def overlap(i1, i2):
        """Check if intervals overlap"""
        return max(i1[0], i2[0]) <= min(i1[1], i2[1])
    
    @staticmethod
    def merge(i1, i2):
        """Merge if possible, return merged or None"""
        if IntervalOperations.overlap(i1, i2):
            return [min(i1[0], i2[0]), max(i1[1], i2[1])]
        return None
    
    @staticmethod
    def intersect(i1, i2):
        """Return intersection or None"""
        start = max(i1[0], i2[0])
        end = min(i1[1], i2[1])
        return [start, end] if start <= end else None
    
    @staticmethod
    def union(i1, i2):
        """Return union as list of intervals"""
        if IntervalOperations.overlap(i1, i2):
            return [[min(i1[0], i2[0]), max(i1[1], i2[1])]]
        return sorted([i1, i2])
    
    @staticmethod
    def difference(i1, i2):
        """Return i1 - i2 as list of intervals"""
        if not IntervalOperations.overlap(i1, i2):
            return [i1]
        
        result = []
        if i1[0] < i2[0]:
            result.append([i1[0], i2[0]])
        if i2[1] < i1[1]:
            result.append([i2[1], i1[1]])
        return result

# Test the class
ops = IntervalOperations()
i1, i2 = [1, 8], [3, 5]

print(f"Intervals: {i1} and {i2}")
print(f"Overlap: {ops.overlap(i1, i2)}")
print(f"Merge: {ops.merge(i1, i2)}")
print(f"Intersect: {ops.intersect(i1, i2)}")
print(f"Union: {ops.union(i1, i2)}")
print(f"Difference: {ops.difference(i1, i2)}")
```

## Key Takeaways from Chapter 1

1. **Intervals are pairs**: Represented as [start, end] with start ≤ end
2. **Overlap detection is fundamental**: Use `max(a, c) <= min(b, d)`
3. **Operations are O(1)**: All basic operations on two intervals are constant time
4. **Always clarify endpoint semantics**: Closed, open, or half-open intervals
5. **Master these four operations**: Merge, Intersect, Union, Difference

These fundamentals form the foundation for all advanced interval problems!