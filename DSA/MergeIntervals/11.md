# Chapter 11: Common Edge Cases & Pitfalls

## 11.1 Comprehensive Edge Case Testing

### The Complete Edge Case Checklist

Every interval problem should be tested against these categories:

```python
class EdgeCaseCategories:
    """
    Comprehensive categorization of interval edge cases
    """
    
    @staticmethod
    def get_all_edge_cases():
        """Return all edge case categories with examples"""
        return {
            'empty_and_single': [
                ([], "Empty input"),
                ([[1, 3]], "Single interval"),
            ],
            
            'overlapping_patterns': [
                ([[1, 3], [2, 4], [3, 5]], "Sequential overlaps"),
                ([[1, 10], [2, 3], [4, 5]], "Complete containment"),
                ([[1, 3], [1, 3], [1, 3]], "Identical intervals"),
                ([[1, 5], [2, 6], [3, 7]], "Staircase overlaps"),
            ],
            
            'boundary_cases': [
                ([[1, 3], [3, 5]], "Touch at point"),
                ([[1, 3], [4, 6]], "Gap of 1"),
                ([[1, 2], [2, 3], [3, 4]], "Consecutive touching"),
            ],
            
            'start_end_variations': [
                ([[1, 5], [1, 3]], "Same start, different end"),
                ([[1, 5], [3, 5]], "Different start, same end"),
                ([[1, 5], [1, 5]], "Identical"),
                ([[5, 5], [3, 7]], "Zero-length interval"),
            ],
            
            'ordering_issues': [
                ([[5, 7], [1, 3], [9, 11]], "Unsorted input"),
                ([[1, 3], [5, 7], [2, 4]], "Partially sorted"),
            ],
            
            'extreme_values': [
                ([[0, 1000000000]], "Very large coordinates"),
                ([[-1000000000, 0]], "Very small (negative)"),
                ([[1, 2], [1000000000, 1000000001]], "Huge gap"),
            ],
            
            'invalid_inputs': [
                ([[3, 1]], "Reversed interval (start > end)"),
                ([[1, 1]], "Point interval (start == end)"),
            ]
        }


# Display all categories
categories = EdgeCaseCategories.get_all_edge_cases()
for category, cases in categories.items():
    print(f"\n{category.upper().replace('_', ' ')}:")
    for intervals, description in cases:
        print(f"  {description:30} {intervals}")
```

### Visual Representation of Edge Cases

```
1. EMPTY AND SINGLE
   Empty:           (no intervals)
   Single:          [===]

2. OVERLAPPING PATTERNS
   Sequential:      [===]
                      [===]
                        [===]
   
   Containment:     [===========]
                      [=] [=]
   
   Identical:       [===]
                    [===]
                    [===]
   
   Staircase:       [=====]
                      [=====]
                        [=====]

3. BOUNDARY CASES
   Touch:           [===][===]
   
   Gap:             [===] [===]
   
   Consecutive:     [=][=][=]

4. START/END VARIATIONS
   Same start:      [=====]
                    [===]
   
   Same end:        [=====]
                      [===]
   
   Zero-length:     [=======]
                        |

5. INVALID INPUTS
   Reversed:        end → [===] ← start
   Point:           [=] (single point)
```

## 11.2 Testing Framework

### Comprehensive Test Suite

```python
class IntervalTestSuite:
    """
    Complete testing framework for interval algorithms
    """
    
    def __init__(self, algorithm_func):
        """
        algorithm_func: the function to test
        Expected signature: func(intervals) -> result
        """
        self.algorithm = algorithm_func
        self.test_results = []
    
    def run_all_tests(self):
        """Run comprehensive test suite"""
        print("="*70)
        print(f"TESTING: {self.algorithm.__name__}")
        print("="*70)
        
        # Get all edge cases
        categories = EdgeCaseCategories.get_all_edge_cases()
        
        total_tests = 0
        passed_tests = 0
        
        for category, cases in categories.items():
            print(f"\n{category.replace('_', ' ').title()}:")
            
            for intervals, description in cases:
                total_tests += 1
                
                try:
                    result = self.algorithm(intervals[:])  # Copy to avoid mutation
                    status = "✓ PASS"
                    passed_tests += 1
                    error_msg = None
                except Exception as e:
                    status = "✗ FAIL"
                    error_msg = str(e)
                
                print(f"  {status} - {description:30}", end='')
                
                if error_msg:
                    print(f" ERROR: {error_msg}")
                else:
                    print()
                
                self.test_results.append({
                    'category': category,
                    'description': description,
                    'input': intervals,
                    'passed': error_msg is None,
                    'error': error_msg
                })
        
        print("\n" + "="*70)
        print(f"RESULTS: {passed_tests}/{total_tests} tests passed")
        print("="*70)
        
        return passed_tests == total_tests
    
    def get_failed_tests(self):
        """Return list of failed test cases"""
        return [test for test in self.test_results if not test['passed']]


# Example usage with merge intervals
def merge_intervals(intervals):
    """Standard merge intervals implementation"""
    if not intervals:
        return []
    
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    
    for current in intervals[1:]:
        last = merged[-1]
        if current[0] <= last[1]:
            last[1] = max(last[1], current[1])
        else:
            merged.append(current)
    
    return merged


# Run comprehensive tests
test_suite = IntervalTestSuite(merge_intervals)
all_passed = test_suite.run_all_tests()

if not all_passed:
    print("\nFailed Tests:")
    for test in test_suite.get_failed_tests():
        print(f"  {test['description']}: {test['error']}")
```

## 11.3 Common Pitfalls and How to Avoid Them

### Pitfall 1: Forgetting to Sort

```python
# ❌ WRONG: Forgetting to sort
def merge_intervals_wrong(intervals):
    if not intervals:
        return []
    
    merged = [intervals[0]]  # Assumes already sorted!
    
    for current in intervals[1:]:
        last = merged[-1]
        if current[0] <= last[1]:
            last[1] = max(last[1], current[1])
        else:
            merged.append(current)
    
    return merged


# ✅ CORRECT: Always sort first
def merge_intervals_correct(intervals):
    if not intervals:
        return []
    
    intervals.sort(key=lambda x: x[0])  # ← CRITICAL!
    merged = [intervals[0]]
    
    for current in intervals[1:]:
        last = merged[-1]
        if current[0] <= last[1]:
            last[1] = max(last[1], current[1])
        else:
            merged.append(current)
    
    return merged


# Test with unsorted input
unsorted = [[5, 7], [1, 3], [2, 4]]

print("Unsorted input:", unsorted)
print("Without sorting:", merge_intervals_wrong(unsorted[:]))
print("With sorting:", merge_intervals_correct(unsorted[:]))

"""
Output:
Unsorted input: [[5, 7], [1, 3], [2, 4]]
Without sorting: [[5, 7], [1, 3], [2, 4]]  ← WRONG! No merging
With sorting: [[1, 4], [5, 7]]  ← CORRECT! Properly merged
"""
```

### Pitfall 2: Not Handling Touching Intervals Correctly

```python
def demonstrate_touching_intervals():
    """Show common mistakes with touching intervals"""
    
    touching = [[1, 3], [3, 5], [5, 7]]
    
    # ❌ WRONG: Using < instead of <=
    def merge_strict(intervals):
        intervals.sort(key=lambda x: x[0])
        merged = [intervals[0]]
        
        for current in intervals[1:]:
            last = merged[-1]
            if current[0] < last[1]:  # ← BUG! Should be <=
                last[1] = max(last[1], current[1])
            else:
                merged.append(current)
        
        return merged
    
    # ✅ CORRECT: Using <=
    def merge_lenient(intervals):
        intervals.sort(key=lambda x: x[0])
        merged = [intervals[0]]
        
        for current in intervals[1:]:
            last = merged[-1]
            if current[0] <= last[1]:  # ← CORRECT!
                last[1] = max(last[1], current[1])
            else:
                merged.append(current)
        
        return merged
    
    print("Touching intervals:", touching)
    print("Strict merge (<):", merge_strict(touching[:]))
    print("Lenient merge (<=):", merge_lenient(touching[:]))
    
    """
    Timeline visualization:
    [1,3]:  [===]
    [3,5]:      [===]
    [5,7]:          [===]
    
    Question: Should [1,3] and [3,5] merge?
    
    Depends on problem definition:
    - If intervals are CLOSED [a,b], they touch at 3 → merge
    - If intervals are HALF-OPEN [a,b), they don't overlap → don't merge
    
    ALWAYS CLARIFY WITH INTERVIEWER!
    """

demonstrate_touching_intervals()
```

### Pitfall 3: Off-by-One Errors in Difference Arrays

```python
class DifferenceArrayPitfalls:
    """Common mistakes with difference arrays"""
    
    @staticmethod
    def wrong_implementation():
        """❌ WRONG: Incorrect boundary handling"""
        diff = [0] * 10
        
        # Add 5 to range [2, 5]
        diff[2] += 5
        diff[5] -= 5  # ← BUG! Should be diff[6] -= 5
        
        # Build array
        values = [0] * 10
        values[0] = diff[0]
        for i in range(1, 10):
            values[i] = values[i-1] + diff[i]
        
        return values
    
    @staticmethod
    def correct_implementation():
        """✅ CORRECT: Proper boundary handling"""
        diff = [0] * 11  # ← Extra space for boundary!
        
        # Add 5 to range [2, 5]
        diff[2] += 5
        diff[6] -= 5  # ← CORRECT! End + 1
        
        # Build array
        values = [0] * 10
        values[0] = diff[0]
        for i in range(1, 10):
            values[i] = values[i-1] + diff[i]
        
        return values
    
    @staticmethod
    def demonstrate():
        print("Adding 5 to range [2, 5]:")
        print()
        
        print("❌ Wrong implementation:")
        wrong = DifferenceArrayPitfalls.wrong_implementation()
        print(f"Result: {wrong}")
        print(f"Range [2,5]: {wrong[2:6]}")
        print("Problem: Value at index 5 is still affected!")
        print()
        
        print("✅ Correct implementation:")
        correct = DifferenceArrayPitfalls.correct_implementation()
        print(f"Result: {correct}")
        print(f"Range [2,5]: {correct[2:6]}")
        print("Correct: Only indices 2,3,4,5 have value 5")

DifferenceArrayPitfalls.demonstrate()

"""
Visual explanation:
Target: Add 5 to indices [2, 3, 4, 5]

Wrong: diff[2]+=5, diff[5]-=5
       [0, 0, +5, 0, 0, -5, 0, ...]
Prefix: [0, 0,  5, 5, 5,  0, 0, ...]
                ↑           ↑
             starts at 2  should end at 5, but ends at 4!

Correct: diff[2]+=5, diff[6]-=5
         [0, 0, +5, 0, 0, 0, -5, ...]
Prefix:  [0, 0,  5, 5, 5, 5,  0, ...]
                 ↑           ↑
              starts at 2  ends at 5 ✓
"""
```

### Pitfall 4: Not Updating the End Time Correctly

```python
def demonstrate_end_time_pitfall():
    """Common mistake in merge logic"""
    
    intervals = [[1, 5], [2, 3], [4, 7]]
    
    # ❌ WRONG: Not using max() to update end
    def merge_wrong(intervals):
        intervals.sort(key=lambda x: x[0])
        merged = [intervals[0]]
        
        for current in intervals[1:]:
            last = merged[-1]
            if current[0] <= last[1]:
                last[1] = current[1]  # ← BUG! Should use max()
            else:
                merged.append(current)
        
        return merged
    
    # ✅ CORRECT: Use max() when merging
    def merge_correct(intervals):
        intervals.sort(key=lambda x: x[0])
        merged = [intervals[0]]
        
        for current in intervals[1:]:
            last = merged[-1]
            if current[0] <= last[1]:
                last[1] = max(last[1], current[1])  # ← CORRECT!
            else:
                merged.append(current)
        
        return merged
    
    print("Intervals:", intervals)
    print("Wrong merge:", merge_wrong(intervals[:]))
    print("Correct merge:", merge_correct(intervals[:]))
    
    """
    Step-by-step for wrong implementation:
    
    Start: [[1,5]]
    
    Merge [2,3]:
      [2,3] overlaps [1,5]
      Wrong: last[1] = 3 → [[1,3]]  ← Lost information!
    
    Try merge [4,7]:
      [4,7] doesn't overlap [1,3]
      Result: [[1,3], [4,7]]  ← WRONG! Should be [[1,7]]
    
    Correct implementation:
    
    Start: [[1,5]]
    
    Merge [2,3]:
      [2,3] overlaps [1,5]
      Correct: last[1] = max(5,3) = 5 → [[1,5]]
    
    Merge [4,7]:
      [4,7] overlaps [1,5]
      Correct: last[1] = max(5,7) = 7 → [[1,7]]
    """

demonstrate_end_time_pitfall()
```

### Pitfall 5: Modifying Input While Iterating

```python
def demonstrate_iteration_pitfall():
    """Modifying list during iteration - dangerous!"""
    
    intervals = [[1, 3], [2, 4], [5, 7], [6, 8]]
    
    # ❌ WRONG: Modifying list while iterating
    def merge_dangerous(intervals):
        intervals.sort(key=lambda x: x[0])
        
        i = 0
        while i < len(intervals) - 1:
            if intervals[i][1] >= intervals[i+1][0]:
                # Merge and remove
                intervals[i][1] = max(intervals[i][1], intervals[i+1][1])
                intervals.pop(i+1)  # ← DANGEROUS! Changes list size
                # Don't increment i, check same position again
            else:
                i += 1
        
        return intervals
    
    # ✅ CORRECT: Build new list
    def merge_safe(intervals):
        intervals.sort(key=lambda x: x[0])
        merged = [intervals[0]]
        
        for current in intervals[1:]:
            last = merged[-1]
            if current[0] <= last[1]:
                last[1] = max(last[1], current[1])
            else:
                merged.append(current)
        
        return merged
    
    print("Original intervals:", intervals)
    print()
    
    # The "dangerous" version can work but is error-prone
    result1 = merge_dangerous(intervals[:])
    print("Dangerous version:", result1)
    
    # The safe version is clearer and less error-prone
    result2 = merge_safe(intervals[:])
    print("Safe version:", result2)
    
    """
    Why dangerous version is risky:
    
    1. Hard to reason about loop invariants
    2. Easy to make off-by-one errors
    3. Difficult to debug
    4. Can cause index out of bounds errors
    
    Best practice: CREATE NEW LIST instead of modifying in-place
    (unless explicitly asked to optimize space)
    """

demonstrate_iteration_pitfall()
```

### Pitfall 6: Integer Overflow with Large Coordinates

```python
def demonstrate_overflow_pitfall():
    """Potential integer overflow issues"""
    
    # ❌ POTENTIAL PROBLEM: Large coordinate calculations
    def calculate_coverage_area_risky(intervals):
        """Calculate total area covered by intervals"""
        intervals.sort(key=lambda x: x[0])
        
        total_area = 0
        current_start = intervals[0][0]
        current_end = intervals[0][1]
        
        for start, end in intervals[1:]:
            if start <= current_end:
                current_end = max(current_end, end)
            else:
                # Calculate area
                area = current_end - current_start  # ← Could overflow!
                total_area += area
                current_start = start
                current_end = end
        
        # Add last segment
        total_area += current_end - current_start
        
        return total_area
    
    # ✅ SAFER: Use appropriate data types
    def calculate_coverage_area_safe(intervals):
        """Use explicit handling for large numbers"""
        intervals.sort(key=lambda x: x[0])
        
        # In Python, integers auto-promote, but in C++/Java need care
        total_area = 0  # Python handles big integers automatically
        current_start = intervals[0][0]
        current_end = intervals[0][1]
        
        for start, end in intervals[1:]:
            if start <= current_end:
                current_end = max(current_end, end)
            else:
                area = current_end - current_start
                total_area += area
                current_start = start
                current_end = end
        
        total_area += current_end - current_start
        
        return total_area
    
    # Test with very large coordinates
    large_intervals = [
        [1, 1000000000],
        [2000000000, 3000000000]
    ]
    
    result = calculate_coverage_area_safe(large_intervals)
    print(f"Coverage area: {result}")
    print(f"(1B - 1) + (1B - 2B) = {result}")
    
    """
    In C++ or Java, this could overflow:
    
    int area = 1000000000 - 1;  // OK
    int area2 = 3000000000 - 2000000000;  // OK
    int total = area + area2;  // Potential overflow!
    
    Solution:
    - Use long/long long in C++
    - Use long in Java
    - Python handles automatically
    """

demonstrate_overflow_pitfall()
```

### Pitfall 7: Not Handling Negative Coordinates

```python
def demonstrate_negative_coordinates():
    """Edge cases with negative coordinates"""
    
    # Works fine with negative coordinates
    intervals = [[-5, -2], [-4, 0], [1, 3]]
    
    def merge_intervals(intervals):
        if not intervals:
            return []
        
        intervals.sort(key=lambda x: x[0])
        merged = [intervals[0]]
        
        for current in intervals[1:]:
            last = merged[-1]
            if current[0] <= last[1]:
                last[1] = max(last[1], current[1])
            else:
                merged.append(current)
        
        return merged
    
    result = merge_intervals(intervals)
    print("Intervals with negatives:", intervals)
    print("Merged:", result)
    
    """
    Timeline with negatives:
    -5 -4 -3 -2 -1  0  1  2  3
    
    [-5,-2]:  [======]
    [-4,0]:      [=========]
    [1,3]:                  [===]
    
    Merged:   [==============] [===]
              -5            0  1  3
    
    Key point: Sorting and comparison work the same!
    No special handling needed for negative coordinates.
    """

demonstrate_negative_coordinates()
```

## 11.4 Debugging Strategies

### Strategy 1: Visualize the Timeline

```python
def visualize_intervals(intervals, width=50):
    """
    Create ASCII visualization of intervals
    
    Helps debug by seeing what's actually happening
    """
    if not intervals:
        print("No intervals to visualize")
        return
    
    # Find range
    min_val = min(interval[0] for interval in intervals)
    max_val = max(interval[1] for interval in intervals)
    range_val = max_val - min_val
    
    print(f"\nTimeline: [{min_val}, {max_val}]")
    print("-" * width)
    
    for i, (start, end) in enumerate(intervals):
        # Calculate positions
        start_pos = int((start - min_val) / range_val * (width - 1))
        end_pos = int((end - min_val) / range_val * (width - 1))
        
        # Build visualization
        line = [' '] * width
        for j in range(start_pos, end_pos + 1):
            line[j] = '='
        line[start_pos] = '['
        line[end_pos] = ']'
        
        print(f"I{i}: {''.join(line)}")
    
    print("-" * width)


# Example usage
intervals = [[1, 4], [2, 6], [8, 10], [3, 5]]
print("Intervals:", intervals)
visualize_intervals(intervals)

"""
Output visualization helps see:
- Which intervals overlap
- Where gaps exist
- Relative sizes
- Potential merge points
"""
```

### Strategy 2: Step-by-Step Trace

```python
def merge_with_trace(intervals):
    """
    Merge intervals with detailed trace output
    
    Helps understand exactly what's happening at each step
    """
    if not intervals:
        return []
    
    print("="*60)
    print("DETAILED EXECUTION TRACE")
    print("="*60)
    
    print(f"\nInput: {intervals}")
    
    intervals.sort(key=lambda x: x[0])
    print(f"After sorting: {intervals}")
    
    merged = [intervals[0][:]]  # Copy first interval
    print(f"\nInitialize merged: {merged}")
    print()
    
    for i, current in enumerate(intervals[1:], 1):
        print(f"Step {i}: Processing {current}")
        last = merged[-1]
        print(f"  Current merged: {merged}")
        print(f"  Last merged interval: {last}")
        
        if current[0] <= last[1]:
            print(f"  Check: {current[0]} <= {last[1]}? YES (overlap)")
            old_end = last[1]
            last[1] = max(last[1], current[1])
            print(f"  Action: Merge - update end from {old_end} to {last[1]}")
        else:
            print(f"  Check: {current[0]} <= {last[1]}? NO (no overlap)")
            print(f"  Action: Add new interval {current}")
            merged.append(current[:])
        
        print(f"  Result: {merged}")
        print()
    
    print("="*60)
    print(f"FINAL RESULT: {merged}")
    print("="*60)
    
    return merged


# Run with trace
intervals = [[1, 3], [2, 6], [8, 10], [4, 7]]
result = merge_with_trace(intervals)
```

### Strategy 3: Invariant Checking

```python
def merge_with_invariant_checks(intervals):
    """
    Merge intervals with runtime invariant checking
    
    Catches bugs by asserting expected properties
    """
    if not intervals:
        return []
    
    def check_invariants(merged, message=""):
        """Check that merged list maintains invariants"""
        assert len(merged) > 0, f"{message}: merged list is empty"
        
        for i in range(len(merged)):
            # Each interval valid
            assert merged[i][0] <= merged[i][1], \
                f"{message}: Invalid interval {merged[i]}"
            
            # Intervals are sorted
            if i > 0:
                assert merged[i-1][0] <= merged[i][0], \
                    f"{message}: Not sorted: {merged[i-1]} before {merged[i]}"
                
                # No overlaps in merged list
                assert merged[i-1][1] < merged[i][0], \
                    f"{message}: Overlapping intervals: {merged[i-1]} and {merged[i]}"
    
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0][:]]
    
    check_invariants(merged, "After initialization")
    
    for current in intervals[1:]:
        last = merged[-1]
        
        if current[0] <= last[1]:
            last[1] = max(last[1], current[1])
        else:
            merged.append(current[:])
        
        check_invariants(merged, f"After processing {current}")
    
    return merged


# Test with invariant checking
try:
    result = merge_with_invariant_checks([[1, 3], [2, 4], [5, 7]])
    print("All invariants satisfied!")
    print(f"Result: {result}")
except AssertionError as e:
    print(f"Invariant violation: {e}")
```

## 11.5 Edge Case Generator

```python
import random

class IntervalEdgeCaseGenerator:
    """
    Generate edge cases for testing
    """
    
    @staticmethod
    def generate_empty():
        """Generate empty input"""
        return []
    
    @staticmethod
    def generate_single():
        """Generate single interval"""
        start = random.randint(0, 100)
        end = start + random.randint(1, 50)
        return [[start, end]]
    
    @staticmethod
    def generate_no_overlaps(n=5):
        """Generate n non-overlapping intervals"""
        intervals = []
        current = 0
        for _ in range(n):
            start = current + random.randint(1, 10)
            end = start + random.randint(1, 10)
            intervals.append([start, end])
            current = end + random.randint(1, 5)
        return intervals
    
    @staticmethod
    def generate_all_overlapping(n=5):
        """Generate n intervals that all overlap"""
        base_start = random.randint(0, 50)
        base_end = base_start + 20
        
        intervals = []
        for _ in range(n):
            start = random.randint(base_start, base_end - 5)
            end = random.randint(start + 1, base_end + 10)
            intervals.append([start, end])
        
        return intervals
    
    @staticmethod
    def generate_touching(n=5):
        """Generate n touching intervals"""
        intervals = []
        current = random.randint(0, 50)
        
        for _ in range(n):
            start = current
            end = current + random.randint(1, 10)
            intervals.append([start, end])
            current = end  # Next starts where this ends
        
        return intervals
    
    @staticmethod
    def generate_nested(depth=5):
        """Generate nested intervals (Russian doll)"""
        intervals = []
        start = 0
        end = depth * 10
        
        for i in range(depth):
            intervals.append([start + i, end - i])
        
        return intervals
    
    @staticmethod
    def generate_random(n=10, max_coord=100):
        """Generate random intervals"""
        intervals = []
        for _ in range(n):
            start = random.randint(0, max_coord)
            end = random.randint(start, max_coord + 20)
            intervals.append([start, end])
        return intervals


# Generate and test various edge cases
generator = IntervalEdgeCaseGenerator()

print("Generated Edge Cases:\n")

test_cases = [
    ("Empty", generator.generate_empty()),
    ("Single", generator.generate_single()),
    ("No overlaps", generator.generate_no_overlaps(5)),
    ("All overlapping", generator.generate_all_overlapping(5)),
    ("Touching", generator.generate_touching(5)),
    ("Nested", generator.generate_nested(5)),
    ("Random", generator.generate_random(8)),
]

for name, intervals in test_cases:
    print(f"{name}:")
    print(f"  {intervals}")
    if intervals:
        visualize_intervals(intervals, width=40)
    print()
```

## Key Takeaways from Chapter 11

### The Edge Case Testing Checklist

Before submitting any interval solution, verify:

- [ ] Empty input (`[]`)
- [ ] Single interval (`[[1,3]]`)
- [ ] Touching intervals (`[[1,3], [3,5]]`)
- [ ] Identical intervals (`[[2,5], [2,5]]`)
- [ ] Complete containment (`[[1,10], [3,5]]`)
- [ ] No overlaps (`[[1,2], [4,5]]`)
- [ ] All overlap (`[[1,5], [2,6], [3,7]]`)
- [ ] Unsorted input
- [ ] Negative coordinates
- [ ] Very large coordinates (10^9)
- [ ] Zero-length intervals (`[[3,3]]`)
- [ ] Reversed intervals (`[[5,1]]` - invalid)

### Top 5 Most Common Bugs

1. **Forgetting to sort** - Always sort unless guaranteed sorted
2. **Wrong comparison** - Use `<=` for touching, `<` for strict
3. **Not using max()** - Must use `max(last[1], current[1])` when merging
4. **Off-by-one in difference array** - Use `end + 1`, not `end`
5. **Modifying while iterating** - Build new list instead

### Debugging Workflow

```
1. Visualize with ASCII timeline
2. Add detailed trace output
3. Check invariants at each step
4. Test with edge case generator
5. Verify with multiple test cases
```

### Interview Strategy for Edge Cases

1. **Ask clarifying questions** before coding
2. **State assumptions** explicitly
3. **Test with small examples** during coding
4. **Walk through edge cases** after coding
5. **Mention time/space trade-offs**

Remember: **Handling edge cases correctly** is what separates good solutions from great ones in interviews!