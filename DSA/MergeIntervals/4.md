# Chapter 4: Interval Intersection Patterns

## 4.1 Two-List Intersection

### Problem Statement

**Given:** Two lists of **closed** intervals where each list is **sorted** and **non-overlapping**

**Goal:** Find the intersection of these two lists (intervals that overlap in both lists)

**Example:**
```
List A: [[0,2], [5,10], [13,23], [24,25]]
List B: [[1,5], [8,12], [15,24], [25,26]]

Output: [[1,2], [5,5], [8,10], [15,23], [24,24], [25,25]]
```

### Visual Understanding

```
Timeline: 0--1--2--3--4--5--6--7--8--9--10-11-12-13-14-15-16-17-18-19-20-21-22-23-24-25-26

List A:   [===]     [=========]         [======================] [=]
          0   2     5         10        13                    23 24 25

List B:     [=======]         [======]       [==================]  [==]
            1       5         8      12      15                24  25 26

Overlaps: [=]     [=]         [===]          [================] [=][=]
          1 2     5 5         8   10         15              23 24 25 25
```

### The Two-Pointer Algorithm

The key insight: Use two pointers to traverse both lists simultaneously, similar to merging sorted arrays.

```python
def intervalIntersection(firstList, secondList):
    """
    Find intersection of two interval lists using two pointers
    
    Time Complexity: O(m + n) where m, n are list lengths
    Space Complexity: O(1) ignoring output space
    
    Args:
        firstList: List[List[int]] - sorted intervals
        secondList: List[List[int]] - sorted intervals
    
    Returns:
        List[List[int]] - intersection intervals
    """
    result = []
    i = j = 0
    
    # Two pointers: one for each list
    while i < len(firstList) and j < len(secondList):
        # Get current intervals from both lists
        a_start, a_end = firstList[i]
        b_start, b_end = secondList[j]
        
        # Calculate intersection boundaries
        # Intersection exists if overlap occurs
        intersect_start = max(a_start, b_start)  # Latest start
        intersect_end = min(a_end, b_end)        # Earliest end
        
        # Check if valid intersection exists
        if intersect_start <= intersect_end:
            result.append([intersect_start, intersect_end])
        
        # Move pointer for interval that ends first
        # This ensures we don't miss any potential intersections
        if a_end < b_end:
            i += 1  # A ends first, move to next A interval
        else:
            j += 1  # B ends first (or equal), move to next B interval
    
    return result


# Test with example
A = [[0,2], [5,10], [13,23], [24,25]]
B = [[1,5], [8,12], [15,24], [25,26]]

result = intervalIntersection(A, B)
print("List A:", A)
print("List B:", B)
print("Intersection:", result)
```

### Why the Algorithm Works

**Key Principle:** At each step, we find the intersection of current intervals from both lists, then advance the pointer for whichever interval ends first.

**Why move the pointer that ends first?**
- If interval A ends before B, then A cannot intersect with any interval after B (since all intervals are sorted)
- Therefore, we must move to the next A interval
- The B interval might still intersect with the next A interval, so we keep B

### Step-by-Step Execution

```
Lists: A = [[0,2], [5,10], [13,23], [24,25]]
       B = [[1,5], [8,12], [15,24], [25,26]]

Initial: i=0, j=0, result=[]

═══════════════════════════════════════════════════════════
ITERATION 1: i=0, j=0
═══════════════════════════════════════════════════════════
A[0] = [0,2]    [===]
B[0] = [1,5]      [=====]

Intersection:
  start = max(0, 1) = 1
  end   = min(2, 5) = 2
  Valid? 1 <= 2? YES → Add [1,2]

result = [[1,2]]

Which ends first? A[0] ends at 2, B[0] ends at 5
  → A ends first, so i++
  
New state: i=1, j=0

═══════════════════════════════════════════════════════════
ITERATION 2: i=1, j=0
═══════════════════════════════════════════════════════════
A[1] = [5,10]       [=========]
B[0] = [1,5]    [=====]

Intersection:
  start = max(5, 1) = 5
  end   = min(10, 5) = 5
  Valid? 5 <= 5? YES → Add [5,5]

result = [[1,2], [5,5]]

Which ends first? A[1] ends at 10, B[0] ends at 5
  → B ends first, so j++
  
New state: i=1, j=1

═══════════════════════════════════════════════════════════
ITERATION 3: i=1, j=1
═══════════════════════════════════════════════════════════
A[1] = [5,10]       [=========]
B[1] = [8,12]              [======]

Intersection:
  start = max(5, 8) = 8
  end   = min(10, 12) = 10
  Valid? 8 <= 10? YES → Add [8,10]

result = [[1,2], [5,5], [8,10]]

Which ends first? A[1] ends at 10, B[1] ends at 12
  → A ends first, so i++
  
New state: i=2, j=1

═══════════════════════════════════════════════════════════
ITERATION 4: i=2, j=1
═══════════════════════════════════════════════════════════
A[2] = [13,23]                  [======================]
B[1] = [8,12]              [======]

Intersection:
  start = max(13, 8) = 13
  end   = min(23, 12) = 12
  Valid? 13 <= 12? NO → No intersection, skip

Which ends first? A[2] ends at 23, B[1] ends at 12
  → B ends first, so j++
  
New state: i=2, j=2

═══════════════════════════════════════════════════════════
ITERATION 5: i=2, j=2
═══════════════════════════════════════════════════════════
A[2] = [13,23]                  [======================]
B[2] = [15,24]                        [==================]

Intersection:
  start = max(13, 15) = 15
  end   = min(23, 24) = 23
  Valid? 15 <= 23? YES → Add [15,23]

result = [[1,2], [5,5], [8,10], [15,23]]

Which ends first? A[2] ends at 23, B[2] ends at 24
  → A ends first, so i++
  
New state: i=3, j=2

═══════════════════════════════════════════════════════════
ITERATION 6: i=3, j=2
═══════════════════════════════════════════════════════════
A[3] = [24,25]                                          [=]
B[2] = [15,24]                        [==================]

Intersection:
  start = max(24, 15) = 24
  end   = min(25, 24) = 24
  Valid? 24 <= 24? YES → Add [24,24]

result = [[1,2], [5,5], [8,10], [15,23], [24,24]]

Which ends first? A[3] ends at 25, B[2] ends at 24
  → B ends first, so j++
  
New state: i=3, j=3

═══════════════════════════════════════════════════════════
ITERATION 7: i=3, j=3
═══════════════════════════════════════════════════════════
A[3] = [24,25]                                          [=]
B[3] = [25,26]                                            [==]

Intersection:
  start = max(24, 25) = 25
  end   = min(25, 26) = 25
  Valid? 25 <= 25? YES → Add [25,25]

result = [[1,2], [5,5], [8,10], [15,23], [24,24], [25,25]]

Which ends first? A[3] ends at 25, B[3] ends at 26
  → A ends first, so i++
  
New state: i=4, j=3

═══════════════════════════════════════════════════════════
LOOP ENDS: i=4 >= len(A)

FINAL RESULT: [[1,2], [5,5], [8,10], [15,23], [24,24], [25,25]]
```

### Alternative Implementation with Clearer Logic

```python
def intervalIntersection_v2(A, B):
    """
    Alternative implementation with explicit overlap check
    """
    result = []
    i = j = 0
    
    while i < len(A) and j < len(B):
        # Check if intervals overlap
        # Two intervals [a,b] and [c,d] overlap if:
        # max(a,c) <= min(b,d)
        
        a_start, a_end = A[i]
        b_start, b_end = B[j]
        
        # Check overlap explicitly
        if a_start <= b_end and b_start <= a_end:
            # They overlap - compute intersection
            result.append([
                max(a_start, b_start),
                min(a_end, b_end)
            ])
        
        # Move pointer for interval that ends first
        if a_end < b_end:
            i += 1
        else:
            j += 1
    
    return result
```

### Java Implementation

```java
class Solution {
    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {
        List<int[]> result = new ArrayList<>();
        int i = 0, j = 0;
        
        while (i < firstList.length && j < secondList.length) {
            // Get current intervals
            int aStart = firstList[i][0];
            int aEnd = firstList[i][1];
            int bStart = secondList[j][0];
            int bEnd = secondList[j][1];
            
            // Calculate intersection
            int intersectStart = Math.max(aStart, bStart);
            int intersectEnd = Math.min(aEnd, bEnd);
            
            // Check if valid intersection
            if (intersectStart <= intersectEnd) {
                result.add(new int[]{intersectStart, intersectEnd});
            }
            
            // Move pointer for interval that ends first
            if (aEnd < bEnd) {
                i++;
            } else {
                j++;
            }
        }
        
        // Convert to array
        return result.toArray(new int[result.size()][]);
    }
}
```

### C++ Implementation

```cpp
class Solution {
public:
    vector<vector<int>> intervalIntersection(
        vector<vector<int>>& firstList, 
        vector<vector<int>>& secondList
    ) {
        vector<vector<int>> result;
        int i = 0, j = 0;
        
        while (i < firstList.size() && j < secondList.size()) {
            // Calculate intersection
            int intersectStart = max(firstList[i][0], secondList[j][0]);
            int intersectEnd = min(firstList[i][1], secondList[j][1]);
            
            // Add if valid
            if (intersectStart <= intersectEnd) {
                result.push_back({intersectStart, intersectEnd});
            }
            
            // Move pointer
            if (firstList[i][1] < secondList[j][1]) {
                i++;
            } else {
                j++;
            }
        }
        
        return result;
    }
};
```

### Edge Cases

```python
def test_edge_cases():
    """Test all edge cases for interval intersection"""
    
    test_cases = [
        # Case 1: Empty lists
        {
            'A': [],
            'B': [[1,5]],
            'expected': [],
            'description': 'Empty first list'
        },
        {
            'A': [[1,5]],
            'B': [],
            'expected': [],
            'description': 'Empty second list'
        },
        
        # Case 2: No overlaps
        {
            'A': [[1,2], [3,4]],
            'B': [[5,6], [7,8]],
            'expected': [],
            'description': 'No overlaps - completely separate'
        },
        
        # Case 3: Complete overlap
        {
            'A': [[1,10]],
            'B': [[1,10]],
            'expected': [[1,10]],
            'description': 'Identical intervals'
        },
        
        # Case 4: One contains the other
        {
            'A': [[1,10]],
            'B': [[3,5]],
            'expected': [[3,5]],
            'description': 'A contains B'
        },
        {
            'A': [[3,5]],
            'B': [[1,10]],
            'expected': [[3,5]],
            'description': 'B contains A'
        },
        
        # Case 5: Touch at boundary
        {
            'A': [[1,3]],
            'B': [[3,5]],
            'expected': [[3,3]],
            'description': 'Touch at single point'
        },
        
        # Case 6: Adjacent but not touching
        {
            'A': [[1,2]],
            'B': [[3,4]],
            'expected': [],
            'description': 'Adjacent with gap'
        },
        
        # Case 7: Multiple intersections
        {
            'A': [[1,3], [5,7], [9,11]],
            'B': [[2,4], [6,8], [10,12]],
            'expected': [[2,3], [6,7], [10,11]],
            'description': 'Multiple overlapping pairs'
        },
        
        # Case 8: Staggered intervals
        {
            'A': [[1,5], [10,15]],
            'B': [[3,7], [12,17]],
            'expected': [[3,5], [12,15]],
            'description': 'Staggered overlaps'
        },
    ]
    
    print("="*70)
    print("INTERVAL INTERSECTION - EDGE CASE TESTING")
    print("="*70)
    
    for i, test in enumerate(test_cases, 1):
        result = intervalIntersection(test['A'], test['B'])
        passed = result == test['expected']
        
        print(f"\nTest {i}: {'✓ PASS' if passed else '✗ FAIL'}")
        print(f"Description: {test['description']}")
        print(f"A:        {test['A']}")
        print(f"B:        {test['B']}")
        print(f"Expected: {test['expected']}")
        if not passed:
            print(f"Got:      {result}")

test_edge_cases()
```

## 4.2 Multiple List Intersections

### Problem Statement

**Given:** N lists of intervals (where N > 2)

**Goal:** Find intervals that appear in ALL lists

**Example:**
```
List 1: [[1,7], [10,15]]
List 2: [[3,8], [12,14]]
List 3: [[4,6], [11,16]]

Output: [[4,6], [12,14]]
```

### Approach 1: Pairwise Intersection

Apply the two-list intersection repeatedly.

```python
def intersect_multiple_lists_pairwise(intervals_lists):
    """
    Find intersection of multiple interval lists using pairwise approach
    
    Time: O(n * m) where n = number of lists, m = avg intervals per list
    Space: O(m) for intermediate results
    """
    if not intervals_lists:
        return []
    
    # Start with first list
    result = intervals_lists[0]
    
    # Intersect with each subsequent list
    for i in range(1, len(intervals_lists)):
        result = intervalIntersection(result, intervals_lists[i])
        
        # Early termination: if result becomes empty, no common intervals
        if not result:
            return []
    
    return result


# Test
lists = [
    [[1,7], [10,15]],
    [[3,8], [12,14]],
    [[4,6], [11,16]]
]

result = intersect_multiple_lists_pairwise(lists)
print("Multiple lists:", lists)
print("Common intervals:", result)

"""
Step-by-step:
1. Start: [[1,7], [10,15]]
2. Intersect with [[3,8], [12,14]]:
   Result: [[3,7], [12,14]]
3. Intersect with [[4,6], [11,16]]:
   Result: [[4,6], [12,14]]
"""
```

### Visualization of Pairwise Intersection

```
List 1: [=======]      [======]
        1       7      10    15

List 2:     [======]       [===]
            3      8       12 14

After intersecting List 1 & 2:
Result:     [===]          [===]
            3   7          12 14

List 3:       [===]     [=======]
              4   6     11      16

After intersecting with List 3:
Final:        [===]        [==]
              4   6        12 14
```

### Approach 2: N-Way Merge with Priority Queue

More efficient for many lists with large number of intervals.

```python
import heapq

def intersect_multiple_lists_heap(intervals_lists):
    """
    Find intersection using heap (priority queue)
    
    Time: O(n * m * log n) where n = lists, m = intervals per list
    Space: O(n) for heap
    
    Better for many lists with many intervals each
    """
    if not intervals_lists or not all(intervals_lists):
        return []
    
    result = []
    
    # Min heap: (start, end, list_index, interval_index)
    heap = []
    indices = [0] * len(intervals_lists)  # Track position in each list
    
    # Initialize heap with first interval from each list
    for i in range(len(intervals_lists)):
        if intervals_lists[i]:
            start, end = intervals_lists[i][0]
            heapq.heappush(heap, (start, end, i, 0))
    
    while len(heap) == len(intervals_lists):
        # Get all current intervals (one from each list)
        current_intervals = []
        temp_heap = []
        
        while heap:
            interval = heapq.heappop(heap)
            current_intervals.append(interval)
        
        # Find intersection of all current intervals
        # Intersection = [max of all starts, min of all ends]
        max_start = max(interval[0] for interval in current_intervals)
        min_end = min(interval[1] for interval in current_intervals)
        
        if max_start <= min_end:
            result.append([max_start, min_end])
        
        # Advance the interval(s) that end earliest
        min_end_value = min(interval[1] for interval in current_intervals)
        
        for start, end, list_idx, interval_idx in current_intervals:
            if end == min_end_value:
                # Move to next interval in this list
                indices[list_idx] += 1
                if indices[list_idx] < len(intervals_lists[list_idx]):
                    next_interval = intervals_lists[list_idx][indices[list_idx]]
                    heapq.heappush(heap, (next_interval[0], next_interval[1], 
                                         list_idx, indices[list_idx]))
            else:
                # Keep this interval for next iteration
                heapq.heappush(heap, (start, end, list_idx, interval_idx))
    
    return result
```

### Approach 3: Sweep Line for Multiple Lists

```python
def intersect_multiple_sweep_line(intervals_lists):
    """
    Use sweep line algorithm for multiple list intersection
    
    Time: O(n * m * log(n*m))
    Space: O(n * m)
    """
    if not intervals_lists:
        return []
    
    # Create events: (position, type, list_id)
    # type: 1 = start, -1 = end
    events = []
    
    for list_id, intervals in enumerate(intervals_lists):
        for start, end in intervals:
            events.append((start, 1, list_id))    # Start event
            events.append((end + 1, -1, list_id)) # End event (exclusive)
    
    # Sort events
    events.sort()
    
    result = []
    active_lists = set()
    intersection_start = None
    
    for pos, event_type, list_id in events:
        if event_type == 1:
            # Start event
            active_lists.add(list_id)
            
            # If all lists are now active, start intersection
            if len(active_lists) == len(intervals_lists):
                intersection_start = pos
        else:
            # End event
            # If all lists were active, end intersection
            if len(active_lists) == len(intervals_lists):
                result.append([intersection_start, pos - 1])
            
            active_lists.discard(list_id)
    
    return result
```

## Practical Applications

### Application 1: Finding Common Free Time Slots

```python
def find_common_free_time(schedules, work_hours=[9, 17]):
    """
    Find time slots when all people are free
    
    Args:
        schedules: List[List[List[int]]] - busy times for each person
        work_hours: [start, end] - working hours
    
    Returns:
        List[List[int]] - common free time slots
    """
    # First, find busy intervals for each person
    busy_intervals = []
    for schedule in schedules:
        if schedule:
            busy_intervals.append(schedule)
    
    # Find intersection of busy times (times when at least one is busy)
    # Then invert to find free times
    
    # Merge all busy times together
    all_busy = []
    for schedule in busy_intervals:
        all_busy.extend(schedule)
    
    # Sort and merge
    all_busy.sort()
    merged_busy = []
    
    for interval in all_busy:
        if not merged_busy or merged_busy[-1][1] < interval[0]:
            merged_busy.append(interval)
        else:
            merged_busy[-1][1] = max(merged_busy[-1][1], interval[1])
    
    # Find gaps (free times)
    free_times = []
    current_time = work_hours[0]
    
    for busy_start, busy_end in merged_busy:
        if current_time < busy_start:
            free_times.append([current_time, busy_start])
        current_time = max(current_time, busy_end)
    
    if current_time < work_hours[1]:
        free_times.append([current_time, work_hours[1]])
    
    return free_times


# Example
schedules = [
    [[9,11], [13,15]],  # Person 1 busy times
    [[10,12], [14,16]], # Person 2 busy times
    [[9,10], [15,17]]   # Person 3 busy times
]

free_times = find_common_free_time(schedules)
print("Common free times:", free_times)

"""
Visual:
Person 1: [==]   [==]
          9  11  13 15

Person 2:   [==]   [==]
            10 12  14 16

Person 3: [=]        [==]
          9 10       15 17

All busy: [====] [======]
          9   12 13    17

Free:          [=]
               12 13
"""
```

### Application 2: Meeting Room Availability Across Buildings

```python
def find_available_rooms_all_buildings(building_schedules, duration):
    """
    Find time slots when rooms are available in ALL buildings
    
    Args:
        building_schedules: List[List[List[int]]] - busy times per building
        duration: int - required duration
    
    Returns:
        List[List[int]] - time slots of required duration
    """
    # Convert busy times to available times for each building
    all_available = []
    
    for busy_times in building_schedules:
        # Find gaps in busy times (available times)
        available = []
        if not busy_times:
            available = [[0, 24]]  # All day available
        else:
            busy_times.sort()
            current = 0
            
            for start, end in busy_times:
                if current < start:
                    available.append([current, start])
                current = max(current, end)
            
            if current < 24:
                available.append([current, 24])
        
        all_available.append(available)
    
    # Find intersection of all available times
    common_available = intersect_multiple_lists_pairwise(all_available)
    
    # Filter by duration
    result = []
    for start, end in common_available:
        if end - start >= duration:
            result.append([start, start + duration])
    
    return result
```

## Key Takeaways from Chapter 4

### Intersection Patterns Summary

| Pattern | Use Case | Time | Space |
|---------|----------|------|-------|
| Two-List | Basic intersection | O(m+n) | O(1) |
| Pairwise | Multiple lists (small N) | O(N*m) | O(m) |
| Heap | Multiple lists (large N) | O(N*m*log N) | O(N) |
| Sweep Line | Dense overlaps | O(N*m*log(N*m)) | O(N*m) |

### Core Formulas

```python
# Intersection of two intervals [a,b] and [c,d]
intersection_start = max(a, c)
intersection_end = min(b, d)
has_intersection = (intersection_start <= intersection_end)

# Which pointer to advance?
if interval_a_end < interval_b_end:
    advance_pointer_a()
else:
    advance_pointer_b()
```

### Interview Tips

1. **Clarify if lists are sorted** - affects algorithm choice
2. **Ask about overlaps within lists** - may need preprocessing
3. **Consider early termination** - if result becomes empty
4. **Think about memory constraints** - pairwise vs heap
5. **Verify endpoint inclusion** - [a,b] vs [a,b) vs (a,b]

### Common Mistakes

❌ Forgetting to advance pointers  
❌ Not handling equal end times correctly  
❌ Missing edge case of empty lists  
❌ Assuming intervals within a list don't overlap  
❌ Not considering single-point intersections [3,3]

### Next Steps

Chapter 5 will apply these intersection concepts to real-world scheduling problems like Meeting Rooms and Resource Allocation!