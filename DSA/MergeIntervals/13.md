# Chapter 13: Practice Problem Categories

## 13.1 Basic Merging (Easy-Medium)

### Problem 1: Merge Intervals ⭐⭐

**Difficulty:** Medium | **Pattern:** Basic Merge

**Problem Statement:**
Given an array of intervals where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals and return an array of the non-overlapping intervals.

**Example:**
```
Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]

Input: [[1,4],[4,5]]
Output: [[1,5]]
```

**Complete Solution:**

```python
def merge(intervals):
    """
    Merge overlapping intervals
    
    Time: O(n log n) - sorting dominates
    Space: O(n) - output array
    
    Approach:
    1. Sort by start time
    2. Compare each interval with last merged
    3. Merge if overlapping, otherwise add new
    """
    if not intervals:
        return []
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    merged = [intervals[0]]
    
    for current in intervals[1:]:
        last = merged[-1]
        
        # Check overlap: current starts before last ends
        if current[0] <= last[1]:
            # Merge by extending end time
            last[1] = max(last[1], current[1])
        else:
            # No overlap, add as new interval
            merged.append(current)
    
    return merged


# Test cases
test_cases = [
    {
        'input': [[1,3],[2,6],[8,10],[15,18]],
        'expected': [[1,6],[8,10],[15,18]],
        'description': 'Standard merge'
    },
    {
        'input': [[1,4],[4,5]],
        'expected': [[1,5]],
        'description': 'Touching intervals'
    },
    {
        'input': [[1,4],[0,4]],
        'expected': [[0,4]],
        'description': 'Reverse order'
    },
    {
        'input': [[1,4],[2,3]],
        'expected': [[1,4]],
        'description': 'Complete containment'
    }
]

print("Problem 1: Merge Intervals")
print("="*60)
for i, test in enumerate(test_cases, 1):
    result = merge(test['input'][:])
    status = "✓" if result == test['expected'] else "✗"
    print(f"\nTest {i} [{status}]: {test['description']}")
    print(f"  Input:    {test['input']}")
    print(f"  Expected: {test['expected']}")
    print(f"  Got:      {result}")
```

**Key Insights:**
- Always sort first (unless guaranteed sorted)
- Use `<=` for overlapping check (touching counts as overlap)
- Use `max()` when updating end time
- Single pass after sorting is sufficient

---

### Problem 2: Insert Interval ⭐⭐

**Difficulty:** Medium | **Pattern:** Insert Interval

**Problem Statement:**
Insert `newInterval` into sorted non-overlapping intervals, merging if necessary.

**Example:**
```
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]

Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
```

**Complete Solution:**

```python
def insert(intervals, newInterval):
    """
    Insert interval into sorted non-overlapping list
    
    Time: O(n) - single pass, no sorting needed
    Space: O(n) - output array
    
    Three-phase approach:
    1. Add all intervals before new interval
    2. Merge all overlapping intervals
    3. Add all intervals after new interval
    """
    result = []
    i = 0
    n = len(intervals)
    
    # Phase 1: Add intervals that end before new interval starts
    while i < n and intervals[i][1] < newInterval[0]:
        result.append(intervals[i])
        i += 1
    
    # Phase 2: Merge all overlapping intervals
    while i < n and intervals[i][0] <= newInterval[1]:
        newInterval[0] = min(newInterval[0], intervals[i][0])
        newInterval[1] = max(newInterval[1], intervals[i][1])
        i += 1
    result.append(newInterval)
    
    # Phase 3: Add remaining intervals
    while i < n:
        result.append(intervals[i])
        i += 1
    
    return result


# Test cases with visual explanations
test_cases = [
    {
        'intervals': [[1,3],[6,9]],
        'newInterval': [2,5],
        'expected': [[1,5],[6,9]],
        'visual': """
        Before:  [===]      [=====]
                 1   3      6     9
        Insert:    [=====]
                   2     5
        After:   [=========] [=====]
                 1         5 6     9
        """
    },
    {
        'intervals': [[1,2],[3,5],[6,7],[8,10],[12,16]],
        'newInterval': [4,8],
        'expected': [[1,2],[3,10],[12,16]],
        'visual': """
        Before:  [=] [===] [=] [===] [=====]
        Insert:        [=========]
        After:   [=] [=============] [=====]
        """
    }
]

print("\nProblem 2: Insert Interval")
print("="*60)
for i, test in enumerate(test_cases, 1):
    result = insert(test['intervals'][:], test['newInterval'][:])
    status = "✓" if result == test['expected'] else "✗"
    print(f"\nTest {i} [{status}]:")
    print(test['visual'])
    print(f"  Result: {result}")
```

**Key Insights:**
- Leverages pre-sorted, non-overlapping property
- Three distinct phases - before, merge, after
- O(n) time - faster than merge intervals
- Don't need to sort!

---

### Problem 3: Non-overlapping Intervals ⭐⭐

**Difficulty:** Medium | **Pattern:** Activity Selection

**Problem Statement:**
Given intervals, return minimum number of intervals you need to remove to make the rest non-overlapping.

**Example:**
```
Input: [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: Remove [1,3], leaving [[1,2],[2,3],[3,4]]

Input: [[1,2],[1,2],[1,2]]
Output: 2
Explanation: Remove 2 identical intervals
```

**Complete Solution:**

```python
def eraseOverlapIntervals(intervals):
    """
    Minimum removals to make non-overlapping
    
    Time: O(n log n) - sorting
    Space: O(1) - excluding output
    
    Greedy approach (activity selection):
    1. Sort by END time
    2. Keep intervals that end earliest
    3. Count how many we KEEP, subtract from total
    """
    if not intervals:
        return 0
    
    # Sort by end time (critical for greedy to work!)
    intervals.sort(key=lambda x: x[1])
    
    keep_count = 1  # Keep first interval
    last_end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        # If current starts at/after last kept interval ends
        if intervals[i][0] >= last_end:
            keep_count += 1
            last_end = intervals[i][1]
    
    # Return how many to remove
    return len(intervals) - keep_count


# Detailed example walkthrough
def eraseOverlapIntervals_with_trace(intervals):
    """Version with detailed trace"""
    if not intervals:
        return 0
    
    print("\nDetailed Execution Trace:")
    print("-" * 60)
    
    intervals.sort(key=lambda x: x[1])
    print(f"After sorting by end: {intervals}")
    
    keep_count = 1
    last_end = intervals[0][1]
    kept = [intervals[0]]
    
    print(f"\nKeep: {intervals[0]} (first interval)")
    
    for i in range(1, len(intervals)):
        current = intervals[i]
        print(f"\nCheck: {current}")
        print(f"  Current start ({current[0]}) >= Last end ({last_end})?", end=" ")
        
        if current[0] >= last_end:
            print("YES - Keep it!")
            keep_count += 1
            last_end = current[1]
            kept.append(current)
        else:
            print("NO - Remove it")
    
    print(f"\nKept intervals: {kept}")
    print(f"Kept count: {keep_count}")
    print(f"Remove count: {len(intervals) - keep_count}")
    
    return len(intervals) - keep_count


# Test
intervals = [[1,2],[2,3],[3,4],[1,3]]
print("Problem 3: Non-overlapping Intervals")
print("="*60)
print(f"Input: {intervals}")
result = eraseOverlapIntervals_with_trace(intervals)
print(f"\nAnswer: {result}")

"""
Why sort by END time?

Greedy choice: Always keep interval that ends earliest
This leaves maximum room for future intervals

Visual proof:
Timeline: 1---2---3---4---5

Option A (sort by start):
[1,3]:   [=====]
[1,2]:   [===]
[2,3]:     [===]
If we pick [1,2] first (earliest start), we can also pick [2,3] and [3,4]
Keep 3, remove 1

Option B (sort by end):
[1,2]:   [===]
[2,3]:     [===]
[3,4]:       [===]
[1,3]:   [=====]
Pick [1,2] (ends earliest), then [2,3], then [3,4]
Keep 3, remove 1

Both work here, but END time is provably optimal for all cases!
"""
```

**Key Insights:**
- This is the inverse of activity selection
- Sort by END time (not start!)
- Greedy: keep intervals that end earliest
- Count kept intervals, then subtract from total

---

## 13.2 Resource Allocation (Medium)

### Problem 4: Meeting Rooms II ⭐⭐⭐

**Difficulty:** Medium | **Pattern:** Concurrent Events

**Problem Statement:**
Given meeting time intervals, find minimum number of conference rooms required.

**Example:**
```
Input: [[0,30],[5,10],[15,20]]
Output: 2

Input: [[7,10],[2,4]]
Output: 1
```

**Complete Solution with All 3 Approaches:**

```python
# Approach 1: Chronological Ordering (RECOMMENDED)
def minMeetingRooms_chronological(intervals):
    """
    Most intuitive approach using start/end arrays
    
    Time: O(n log n) - sorting
    Space: O(n) - two arrays
    
    Algorithm:
    1. Separate starts and ends
    2. Sort both independently
    3. Process chronologically with two pointers
    """
    if not intervals:
        return 0
    
    starts = sorted([i[0] for i in intervals])
    ends = sorted([i[1] for i in intervals])
    
    rooms = 0
    max_rooms = 0
    start_ptr = 0
    end_ptr = 0
    
    while start_ptr < len(starts):
        if starts[start_ptr] < ends[end_ptr]:
            # Meeting starts, need a room
            rooms += 1
            start_ptr += 1
            max_rooms = max(max_rooms, rooms)
        else:
            # Meeting ends, free a room
            rooms -= 1
            end_ptr += 1
    
    return max_rooms


# Approach 2: Priority Queue (Heap)
import heapq

def minMeetingRooms_heap(intervals):
    """
    Using min heap to track room end times
    
    Time: O(n log n) - sorting and heap ops
    Space: O(n) - heap size
    """
    if not intervals:
        return 0
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    # Heap stores end times of ongoing meetings
    heap = [intervals[0][1]]
    
    for i in range(1, len(intervals)):
        # If earliest meeting ends before current starts
        if heap[0] <= intervals[i][0]:
            heapq.heappop(heap)  # Reuse that room
        
        # Allocate room (new or reused)
        heapq.heappush(heap, intervals[i][1])
    
    return len(heap)


# Approach 3: Sweep Line
def minMeetingRooms_sweepline(intervals):
    """
    Event-based sweep line approach
    
    Time: O(n log n) - sorting events
    Space: O(n) - events array
    """
    events = []
    for start, end in intervals:
        events.append((start, 1))    # +1 for start
        events.append((end, -1))     # -1 for end
    
    events.sort()
    
    current_rooms = 0
    max_rooms = 0
    
    for time, delta in events:
        current_rooms += delta
        max_rooms = max(max_rooms, current_rooms)
    
    return max_rooms


# Comprehensive comparison
def compare_all_approaches(intervals):
    """Compare all three approaches"""
    print("\nProblem 4: Meeting Rooms II")
    print("="*60)
    print(f"Input: {intervals}\n")
    
    approaches = [
        ("Chronological", minMeetingRooms_chronological),
        ("Priority Queue", minMeetingRooms_heap),
        ("Sweep Line", minMeetingRooms_sweepline)
    ]
    
    for name, func in approaches:
        result = func(intervals[:])
        print(f"{name:20} → {result} rooms")
    
    # Detailed trace for chronological
    print("\n" + "="*60)
    print("DETAILED TRACE (Chronological Approach)")
    print("="*60)
    
    intervals = [[0,30],[5,10],[15,20]]
    starts = sorted([i[0] for i in intervals])
    ends = sorted([i[1] for i in intervals])
    
    print(f"Starts: {starts}")
    print(f"Ends:   {ends}")
    print("\nTimeline:")
    print("Time:  0  5  10  15  20  30")
    print("Event: S  S  E   S   E   E")
    print("              ↓")
    print("Rooms: 1  2  1   2   1   0")
    print("          ↑ Max = 2")


# Test
compare_all_approaches([[0,30],[5,10],[15,20]])
```

**Key Insights:**
- Three valid approaches, all O(n log n)
- Chronological is most intuitive for interviews
- Priority queue explicitly tracks room usage
- Think of it as "how many concurrent events at peak?"

---

### Problem 5: Car Pooling ⭐⭐

**Difficulty:** Medium | **Pattern:** Capacity Management

**Problem Statement:**
You're driving a car with `capacity` empty seats. Given trips `[numPassengers, from, to]`, return true if you can pick up and drop off all passengers.

**Example:**
```
Input: trips = [[2,1,5],[3,3,7]], capacity = 4
Output: false

Input: trips = [[2,1,5],[3,3,7]], capacity = 5
Output: true
```

**Complete Solution:**

```python
def carPooling(trips, capacity):
    """
    Check if car can handle all trips
    
    Time: O(n log n) - sorting
    Space: O(n) - events
    
    Approach: Sweep line with capacity tracking
    """
    events = []
    
    # Create events for pickups and dropoffs
    for passengers, start, end in trips:
        events.append((start, passengers))    # Pickup
        events.append((end, -passengers))     # Dropoff
    
    # Sort by location
    events.sort()
    
    current_passengers = 0
    
    for location, change in events:
        current_passengers += change
        
        # Check if over capacity
        if current_passengers > capacity:
            return False
    
    return True


# Visual solution
def carPooling_visual(trips, capacity):
    """Version with visualization"""
    print("\nProblem 5: Car Pooling")
    print("="*60)
    print(f"Trips: {trips}")
    print(f"Capacity: {capacity}\n")
    
    events = []
    for passengers, start, end in trips:
        events.append((start, passengers, 'pickup'))
        events.append((end, -passengers, 'dropoff'))
    
    events.sort()
    
    print("Timeline:")
    print("-"*60)
    
    current = 0
    for location, change, action in events:
        current += change
        status = "✓" if current <= capacity else "✗ OVER CAPACITY"
        print(f"Location {location:2d}: {action:8} {change:+3d} → "
              f"{current:2d}/{capacity} {status}")
    
    result = current <= capacity and all(
        sum(e[1] for e in events[:i+1]) <= capacity 
        for i in range(len(events))
    )
    
    return result


# Test cases
test_cases = [
    {
        'trips': [[2,1,5],[3,3,7]],
        'capacity': 4,
        'expected': False
    },
    {
        'trips': [[2,1,5],[3,3,7]],
        'capacity': 5,
        'expected': True
    },
    {
        'trips': [[2,1,5],[3,5,7]],
        'capacity': 3,
        'expected': True
    }
]

for i, test in enumerate(test_cases, 1):
    print(f"\nTest {i}:")
    result = carPooling_visual(test['trips'], test['capacity'])
    expected = test['expected']
    print(f"\nResult: {result}, Expected: {expected} "
          f"[{'✓' if result == expected else '✗'}]")

"""
Visual Example:

Trips: [[2,1,5],[3,3,7]], Capacity: 5

Timeline:
Location  1: pickup    +2 →  2/5 ✓
Location  3: pickup    +3 →  5/5 ✓ (exactly at capacity)
Location  5: dropoff   -2 →  3/5 ✓
Location  7: dropoff   -3 →  0/5 ✓

Possible! Never exceed capacity.

With Capacity: 4
Location  1: pickup    +2 →  2/4 ✓
Location  3: pickup    +3 →  5/4 ✗ OVER CAPACITY

Impossible! Exceeds capacity at location 3.
"""
```

**Key Insights:**
- Treat pickups as +passengers, dropoffs as -passengers
- Use sweep line to process events chronologically
- Check capacity at each event
- Similar to meeting rooms but with weighted capacity

---

## 13.3 Optimization Problems (Medium-Hard)

### Problem 6: Minimum Arrows to Burst Balloons ⭐⭐⭐

**Difficulty:** Medium | **Pattern:** Greedy Coverage

**Problem Statement:**
Balloons are represented as intervals `[start, end]`. An arrow shot at position `x` bursts all balloons where `start <= x <= end`. Find minimum arrows needed.

**Example:**
```
Input: [[10,16],[2,8],[1,6],[7,12]]
Output: 2
Explanation: Shoot at x=6 and x=11
```

**Complete Solution:**

```python
def findMinArrowShots(points):
    """
    Minimum arrows to burst all balloons
    
    Time: O(n log n) - sorting
    Space: O(1)
    
    Greedy strategy:
    1. Sort by END position
    2. Shoot arrow at end of first balloon
    3. This bursts all balloons containing that point
    4. Repeat for remaining balloons
    """
    if not points:
        return 0
    
    # Sort by end position
    points.sort(key=lambda x: x[1])
    
    arrows = 1
    arrow_pos = points[0][1]  # Shoot at end of first balloon
    
    for i in range(1, len(points)):
        # If this balloon starts after arrow position
        if points[i][0] > arrow_pos:
            # Need new arrow
            arrows += 1
            arrow_pos = points[i][1]  # Shoot at end of this balloon
    
    return arrows


# Detailed visualization
def findMinArrowShots_visual(points):
    """Version with detailed visualization"""
    if not points:
        return 0
    
    print("\nProblem 6: Minimum Arrows to Burst Balloons")
    print("="*60)
    print(f"Balloons: {points}\n")
    
    # Sort and visualize
    points.sort(key=lambda x: x[1])
    print(f"After sorting by END: {points}\n")
    
    arrows = 1
    arrow_pos = points[0][1]
    bursted_by_current_arrow = [points[0]]
    all_arrows = [(arrow_pos, bursted_by_current_arrow[:])]
    
    print(f"Arrow 1 at position {arrow_pos}:")
    print(f"  Bursts: {points[0]}")
    
    for i in range(1, len(points)):
        current = points[i]
        
        if current[0] > arrow_pos:
            # Need new arrow
            arrows += 1
            arrow_pos = current[1]
            bursted_by_current_arrow = [current]
            all_arrows.append((arrow_pos, bursted_by_current_arrow[:]))
            print(f"\nArrow {arrows} at position {arrow_pos}:")
            print(f"  Bursts: {current}")
        else:
            # Current arrow bursts this too
            bursted_by_current_arrow.append(current)
            all_arrows[-1] = (arrow_pos, bursted_by_current_arrow[:])
            print(f"  Also bursts: {current}")
    
    print(f"\nTotal arrows needed: {arrows}")
    
    # ASCII visualization
    print("\nVisualization:")
    print("-"*60)
    min_pos = min(p[0] for p in points)
    max_pos = max(p[1] for p in points)
    
    for idx, balloon in enumerate(points):
        start, end = balloon
        line = [' '] * 50
        start_scaled = int((start - min_pos) / (max_pos - min_pos) * 40)
        end_scaled = int((end - min_pos) / (max_pos - min_pos) * 40)
        
        for j in range(start_scaled, end_scaled + 1):
            line[j] = '='
        line[start_scaled] = '['
        line[end_scaled] = ']'
        
        print(f"B{idx}: {''.join(line)} [{start},{end}]")
    
    print("\nArrows:")
    for i, (pos, balloons) in enumerate(all_arrows, 1):
        pos_scaled = int((pos - min_pos) / (max_pos - min_pos) * 40)
        line = [' '] * 50
        line[pos_scaled] = '↓'
        print(f"A{i}: {''.join(line)} at {pos}")
    
    return arrows


# Test
balloons = [[10,16],[2,8],[1,6],[7,12]]
findMinArrowShots_visual(balloons)

"""
Why sort by END?

Greedy choice: Shoot arrow at END of first balloon
This maximizes the number of balloons burst by this arrow

Timeline: 1--2--3--4--5--6--7--8--9-10-11-12-13-14-15-16

Sorted by end:
[1,6]:   [======]
[2,8]:     [=======]
[7,12]:           [=======]
[10,16]:              [========]

Arrow 1 at position 6:
  Bursts [1,6] ✓
  Bursts [2,8] ✓ (contains 6)

Arrow 2 at position 12:
  Bursts [7,12] ✓
  Bursts [10,16] ✓ (contains 12)

Total: 2 arrows

If we sorted by START instead:
[1,6]:   [======]
[2,8]:     [=======]
[7,12]:           [=======]
[10,16]:              [========]

Arrow at 6 still bursts [1,6] and [2,8]
Arrow at 12 still bursts [7,12] and [10,16]

Same result! But END sorting is provably optimal in general.
"""
```

**Key Insights:**
- Greedy works: shoot at end of first balloon
- Sort by END position (like activity selection)
- Count groups that can be burst by single arrow
- Inverse of "select maximum non-overlapping"

---

### Problem 7: Video Stitching ⭐⭐⭐

**Difficulty:** Medium | **Pattern:** Greedy Jump

**Problem Statement:**
Given video clips and target time T, return minimum clips needed to cover [0, T].

**Example:**
```
Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10
Output: 3
Explanation: Use [0,2], [1,9], [8,10]
```

**Complete Solution:**

```python
def videoStitching(clips, T):
    """
    Minimum clips to cover [0, T]
    
    Time: O(n log n) - sorting
    Space: O(1)
    
    Greedy strategy (jump game):
    1. Sort by start time
    2. At each position, choose clip extending furthest
    3. Jump to new furthest position
    """
    clips.sort()
    
    clips_used = 0
    current_end = 0  # Current coverage
    next_end = 0     # Furthest reachable with one more clip
    i = 0
    
    while current_end < T:
        # Check all clips starting at or before current_end
        while i < len(clips) and clips[i][0] <= current_end:
            next_end = max(next_end, clips[i][1])
            i += 1
        
        # If can't extend coverage, impossible
        if next_end == current_end:
            return -1
        
        # Use best clip found
        clips_used += 1
        current_end = next_end
        
        # Early exit if reached target
        if current_end >= T:
            return clips_used
    
    return clips_used


# Version with detailed trace
def videoStitching_visual(clips, T):
    """Visualize the greedy selection process"""
    print("\nProblem 7: Video Stitching")
    print("="*60)
    print(f"Clips: {clips}")
    print(f"Target: [0, {T}]\n")
    
    clips.sort()
    print(f"After sorting: {clips}\n")
    
    clips_used = 0
    current_end = 0
    next_end = 0
    i = 0
    selected_clips = []
    
    print("Greedy Selection Process:")
    print("-"*60)
    
    while current_end < T:
        print(f"\nCurrent coverage: [0, {current_end}]")
        print(f"Need to cover: [{current_end}, {T}]")
        
        candidates = []
        start_i = i
        
        # Find all clips starting at or before current_end
        while i < len(clips) and clips[i][0] <= current_end:
            candidates.append(clips[i])
            next_end = max(next_end, clips[i][1])
            i += 1
        
        if next_end == current_end:
            print("✗ Cannot extend coverage - IMPOSSIBLE")
            return -1
        
        # Show candidates
        print(f"Candidates starting ≤ {current_end}: {candidates}")
        
        # Find which one extends furthest
        best_clip = max(candidates, key=lambda x: x[1]) if candidates else None
        
        if best_clip:
            print(f"Choose: {best_clip} (extends to {next_end})")
            selected_clips.append(best_clip)
            clips_used += 1
            current_end = next_end
    
    print(f"\n{'='*60}")
    print(f"Selected clips: {selected_clips}")
    print(f"Total clips used: {clips_used}")
    
    # Visualize timeline
    print("\nTimeline Visualization:")
    print("-"*60)
    print(f"Target: [{'='*T}] 0-{T}")
    
    for clip in selected_clips:
        start, end = clip
        line = [' '] * (T + 5)
        for j in range(start, min(end, T)):
            line[j] = '='
        line[start] = '['
        line[min(end-1, T-1)] = ']'
        print(f"Clip:   {''.join(line[:T+1])} {clip}")
    
    return clips_used


# Test
clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]]
T = 10
result = videoStitching_visual(clips, T)

"""
Step-by-step example:

Sorted: [[0,2],[1,5],[1,9],[4,6],[5,9],[8,10]]

Step 1: Cover [0, ?]
  Current: [0, 0]
  Candidates starting ≤ 0: [[0,2]]
  Choose: [0,2] → Coverage: [0, 2]

Step 2: Cover [2, 10]
  Current: [0, 2]
  Candidates starting ≤ 2: [[1,5],[1,9]]
  Choose: [1,9] → Coverage: [0, 9]

Step 3: Cover [9, 10]
  Current: [0, 9]
  Candidates starting ≤ 9: [[4,6],[5,9],[8,10]]
  Choose: [8,10] → Coverage: [0, 10] ✓

Result: 3 clips
"""
```

**Key Insights:**
- Similar to "Jump Game" problem
- At each position, jump to furthest reachable spot
- Greedy: always extend coverage as much as possible
- If can't extend, impossible to cover target

---

## 13.4 Data Structure Design (Hard)

### Problem 8: Range Module ⭐⭐⭐

**Difficulty:** Hard | **Pattern:** Dynamic Range Management

**Problem Statement:**
Design a data structure supporting:
- `addRange(left, right)`: Add [left, right)
- `removeRange(left, right)`: Remove [left, right)
- `queryRange(left, right)`: Returns true if every real number in [left, right) is tracked

**Example:**
```
rm.addRange(10, 20)
rm.removeRange(14, 16)
rm.queryRange(10, 14)  → true
rm.queryRange(13, 15)  → false (gap at 14-16)
rm.queryRange(16, 17)  → true
```

**Complete Solution:**

```python
class RangeModule:
    """
    Track ranges with dynamic add/remove operations
    
    Uses sorted dictionary (TreeMap in Java, SortedDict in Python)
    to maintain non-overlapping intervals
    
    All operations: O(n) worst case, O(log n) average
    """
    
    def __init__(self):
        # Key: interval start, Value: interval end
        # Maintains non-overlapping sorted intervals
        self.intervals = {}  # In production, use SortedDict
    
    def addRange(self, left, right):
        """
        Add interval [left, right)
        Merge with existing intervals as needed
        """
        # Find intervals that might overlap
        to_merge = []
        for start, end in list(self.intervals.items()):
            # Check if [start, end) overlaps with [left, right)
            if end >= left and start <= right:
                to_merge.append(start)
                left = min(left, start)
                right = max(right, end)
        
        # Remove intervals that were merged
        for start in to_merge:
            del self.intervals[start]
        
        # Add merged interval
        self.intervals[left] = right
    
    def removeRange(self, left, right):
        """
        Remove interval [left, right)
        Split existing intervals as needed
        """
        to_update = []
        
        for start, end in list(self.intervals.items()):
            # Check if [start, end) overlaps with [left, right)
            if end > left and start < right:
                # This interval is affected
                to_update.append((start, end))
        
        # Remove affected intervals
        for start, end in to_update:
            del self.intervals[start]
            
            # Add back left part if exists
            if start < left:
                self.intervals[start] = left
            
            # Add back right part if exists
            if end > right:
                self.intervals[right] = end
    
    def queryRange(self, left, right):
        """
        Check if [left, right) is fully tracked
        Returns true if covered by single interval
        """
        for start, end in self.intervals.items():
            if start <= left and end >= right:
                return True
        return False
    
    def __str__(self):
        """String representation for visualization"""
        sorted_intervals = sorted(self.intervals.items())
        return str([[s, e] for s, e in sorted_intervals])


# Interactive demonstration
def demonstrate_range_module():
    """Complete walkthrough of RangeModule operations"""
    print("\nProblem 8: Range Module")
    print("="*60)
    
    rm = RangeModule()
    
    operations = [
        ("addRange", 10, 20),
        ("removeRange", 14, 16),
        ("queryRange", 10, 14),
        ("queryRange", 13, 15),
        ("queryRange", 16, 17),
        ("addRange", 14, 16),
        ("queryRange", 10, 20),
    ]
    
    print("Operations:")
    print("-"*60)
    
    for op in operations:
        op_name = op[0]
        args = op[1:]
        
        print(f"\n{op_name}{args}")
        
        if op_name == "addRange":
            rm.addRange(*args)
            print(f"  Intervals: {rm}")
        elif op_name == "removeRange":
            rm.removeRange(*args)
            print(f"  Intervals: {rm}")
        else:  # queryRange
            result = rm.queryRange(*args)
            print(f"  Result: {result}")
            print(f"  Intervals: {rm}")
        
        # Visualize
        visualize_range_module(rm, args if op_name == "queryRange" else None)


def visualize_range_module(rm, query_range=None):
    """ASCII visualization of tracked ranges"""
    if not rm.intervals:
        return
    
    min_pos = min(rm.intervals.keys())
    max_pos = max(rm.intervals.values())
    width = 50
    
    line = ['-'] * width
    
    # Draw tracked ranges
    for start, end in rm.intervals.items():
        start_scaled = int((start - min_pos) / (max_pos - min_pos) * (width - 1))
        end_scaled = int((end - min_pos) / (max_pos - min_pos) * (width - 1))
        
        for i in range(start_scaled, end_scaled + 1):
            line[i] = '█'
    
    print(f"  Visual: {''.join(line)}")
    print(f"          {min_pos}{' '*(width-len(str(min_pos))-len(str(max_pos)))}{max_pos}")
    
    # Show query range if provided
    if query_range:
        query_line = [' '] * width
        q_start, q_end = query_range
        if min_pos <= q_start < max_pos:
            q_start_scaled = int((q_start - min_pos) / (max_pos - min_pos) * (width - 1))
            q_end_scaled = int((q_end - min_pos) / (max_pos - min_pos) * (width - 1))
            for i in range(q_start_scaled, min(q_end_scaled + 1, width)):
                query_line[i] = '?'
            print(f"  Query:  {''.join(query_line)}")


demonstrate_range_module()

"""
Complete execution trace:

1. addRange(10, 20)
   Intervals: [[10, 20]]
   Visual: ██████████████████████
           10                   20

2. removeRange(14, 16)
   Intervals: [[10, 14], [16, 20]]
   Visual: ████████    ████████
           10      14  16     20

3. queryRange(10, 14)
   Query covers: [10, 14]
   Covered by: [10, 14]
   Result: True

4. queryRange(13, 15)
   Query covers: [13, 15]
   Gap at: [14, 16]
   Result: False

5. queryRange(16, 17)
   Query covers: [16, 17]
   Covered by: [16, 20]
   Result: True

6. addRange(14, 16)
   Before: [[10, 14], [16, 20]]
   Merge all overlapping: [10, 14] + [14, 16] + [16, 20]
   After: [[10, 20]]

7. queryRange(10, 20)
   Query covers: [10, 20]
   Covered by: [10, 20]
   Result: True
"""
```

**Key Insights:**
- Maintain non-overlapping sorted intervals
- Add: merge all overlapping intervals
- Remove: split intervals as needed
- Query: check if covered by single interval
- Use TreeMap/SortedDict for O(log n) operations

---

## Key Takeaways from Chapter 13

### Pattern Recognition Summary

| Category | Key Patterns | Complexity | Approach |
|----------|-------------|------------|----------|
| Basic Merging | Sort + Compare | O(n log n) | Greedy merge |
| Resource Allocation | Concurrent tracking | O(n log n) | Sweep line |
| Optimization | Max/Min selection | O(n log n) | Greedy/DP |
| Data Structure | Dynamic updates | O(log n) | TreeMap |

### Problem-Solving Checklist

Before coding any interval problem:

1. **Identify the pattern** - Which category does it fit?
2. **Choose the algorithm** - Sort, heap, greedy, or DP?
3. **Consider edge cases** - Empty, single, touching intervals
4. **Optimize if needed** - Can we do better than O(n log n)?
5. **Test thoroughly** - Use provided test framework

### Practice Strategy

**Week 1-2:** Master basic patterns
- Solve 10+ merge/insert problems
- Focus on getting O(n log n) solutions correct

**Week 3-4:** Resource allocation
- Solve meeting rooms variations
- Practice sweep line technique

**Week 5-6:** Optimization problems
- Activity selection variants
- Greedy proofs

**Week 7-8:** Hard problems
- Dynamic range management
- Complex DP problems

**Ready for interviews after 8 weeks of focused practice!**