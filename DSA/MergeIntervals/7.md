# Chapter 7: Interval Partitioning & Coloring

## 7.1 Interval Partitioning Problem

### Problem Statement

**Given:** A set of intervals

**Goal:** Partition intervals into the **minimum number of groups** such that no two intervals in the same group overlap

**Key Insight:** This is equivalent to Meeting Rooms II! The minimum number of groups = maximum depth of overlapping intervals.

**Example:**
```
Input:  [[1,4], [2,5], [3,6], [7,10], [8,11]]
Output: 3 groups

Group 1: [1,4], [7,10]
Group 2: [2,5], [8,11]
Group 3: [3,6]
```

### Visual Understanding

```
Timeline: 0--1--2--3--4--5--6--7--8--9--10-11

[1,4]:     [====]
[2,5]:       [====]
[3,6]:         [=====]
[7,10]:                 [====]
[8,11]:                   [=====]

At time 3: Three intervals overlap
  [1,4], [2,5], [3,6] → Need 3 groups minimum

Partitioning:
Group 1: [====]         [====]
         1   4          7   10

Group 2:   [====]         [=====]
           2   5          8    11

Group 3:     [=====]
             3     6

No overlaps within each group ✓
```

### The Algorithm: Same as Meeting Rooms II

```python
def partitionIntervals(intervals):
    """
    Partition intervals into minimum groups with no overlaps
    
    This is IDENTICAL to Meeting Rooms II!
    The number of groups = maximum concurrent intervals
    
    Time Complexity: O(n log n)
    Space Complexity: O(n)
    
    Args:
        intervals: List[List[int]] - intervals to partition
    
    Returns:
        int - minimum number of groups needed
    """
    if not intervals:
        return 0
    
    # Separate start and end times
    starts = sorted([interval[0] for interval in intervals])
    ends = sorted([interval[1] for interval in intervals])
    
    groups_needed = 0
    max_groups = 0
    start_ptr = 0
    end_ptr = 0
    
    while start_ptr < len(starts):
        if starts[start_ptr] < ends[end_ptr]:
            groups_needed += 1
            start_ptr += 1
            max_groups = max(max_groups, groups_needed)
        else:
            groups_needed -= 1
            end_ptr += 1
    
    return max_groups


# Test
intervals = [[1,4], [2,5], [3,6], [7,10], [8,11]]
result = partitionIntervals(intervals)
print(f"Minimum groups needed: {result}")
```

### Returning the Actual Partition

To actually assign intervals to groups (not just count them):

```python
import heapq

def partitionIntervalsWithAssignment(intervals):
    """
    Partition intervals and return group assignments
    
    Returns: (num_groups, assignments)
        assignments[i] = group number for intervals[i]
    
    Time: O(n log n)
    Space: O(n)
    """
    if not intervals:
        return (0, [])
    
    # Track original indices
    indexed = [(interval, i) for i, interval in enumerate(intervals)]
    indexed.sort(key=lambda x: x[0][0])  # Sort by start time
    
    # Min heap: (end_time, group_id)
    groups = []
    assignments = [0] * len(intervals)
    next_group_id = 0
    
    for interval, original_idx in indexed:
        start, end = interval
        
        # Try to reuse a group
        if groups and groups[0][0] <= start:
            # Reuse this group
            _, group_id = heapq.heappop(groups)
            assignments[original_idx] = group_id
            heapq.heappush(groups, (end, group_id))
        else:
            # Need new group
            group_id = next_group_id
            next_group_id += 1
            assignments[original_idx] = group_id
            heapq.heappush(groups, (end, group_id))
    
    return (next_group_id, assignments)


# Test with assignment
intervals = [[1,4], [2,5], [3,6], [7,10], [8,11]]
num_groups, assignments = partitionIntervalsWithAssignment(intervals)

print(f"Number of groups: {num_groups}")
print(f"Assignments: {assignments}")

# Show the partition
for group_id in range(num_groups):
    group_intervals = [intervals[i] for i in range(len(intervals)) 
                       if assignments[i] == group_id]
    print(f"Group {group_id}: {group_intervals}")

"""
Output:
Number of groups: 3
Assignments: [0, 1, 2, 0, 1]

Group 0: [[1,4], [7,10]]
Group 1: [[2,5], [8,11]]
Group 2: [[3,6]]
"""
```

### Step-by-Step Execution

```
Input: [[1,4], [2,5], [3,6], [7,10], [8,11]]

Sorted by start: [[1,4], [2,5], [3,6], [7,10], [8,11]]

heap = []  (tracks (end_time, group_id))
next_group_id = 0
assignments = [0, 0, 0, 0, 0]

═══════════════════════════════════════════════════════════
Process [1,4]:
═══════════════════════════════════════════════════════════

heap is empty → need new group
Assign to group 0
heap = [(4, 0)]
assignments = [0, 0, 0, 0, 0]

Groups:
  Group 0: [1,4] ends at 4

═══════════════════════════════════════════════════════════
Process [2,5]:
═══════════════════════════════════════════════════════════

Current start: 2
Earliest end: 4 (from heap[0])
Does 4 <= 2? NO → can't reuse

Need new group
Assign to group 1
heap = [(4, 0), (5, 1)]
assignments = [0, 1, 0, 0, 0]

Groups:
  Group 0: [1,4] ends at 4
  Group 1: [2,5] ends at 5

═══════════════════════════════════════════════════════════
Process [3,6]:
═══════════════════════════════════════════════════════════

Current start: 3
Earliest end: 4
Does 4 <= 3? NO → can't reuse

Need new group
Assign to group 2
heap = [(4, 0), (5, 1), (6, 2)]
assignments = [0, 1, 2, 0, 0]

Groups:
  Group 0: [1,4] ends at 4
  Group 1: [2,5] ends at 5
  Group 2: [3,6] ends at 6

Peak: 3 groups! (at time 3-4)

═══════════════════════════════════════════════════════════
Process [7,10]:
═══════════════════════════════════════════════════════════

Current start: 7
Earliest end: 4
Does 4 <= 7? YES → can reuse!

Pop (4, 0), reuse group 0
heap = [(5, 1), (6, 2), (10, 0)]
assignments = [0, 1, 2, 0, 0]

Groups:
  Group 0: [1,4], [7,10] ends at 10
  Group 1: [2,5] ends at 5
  Group 2: [3,6] ends at 6

═══════════════════════════════════════════════════════════
Process [8,11]:
═══════════════════════════════════════════════════════════

Current start: 8
Earliest end: 5
Does 5 <= 8? YES → can reuse!

Pop (5, 1), reuse group 1
heap = [(6, 2), (10, 0), (11, 1)]
assignments = [0, 1, 2, 0, 1]

Final Groups:
  Group 0: [1,4], [7,10]
  Group 1: [2,5], [8,11]
  Group 2: [3,6]

Total: 3 groups
```

## 7.2 Interval Graph Coloring

### Problem Statement

**Given:** Intervals represent activities/tasks

**Goal:** Assign colors (resources) such that overlapping intervals have different colors, using minimum total colors

**This is the SAME as interval partitioning!** A "color" = a "group"

### Why It's Called Graph Coloring

We can model intervals as a graph:
- Each interval is a **vertex**
- Two vertices are **connected** if intervals overlap
- Graph coloring: assign colors such that adjacent vertices have different colors

```
Interval overlap graph:

Intervals: [1,4], [2,5], [3,6], [7,10]

Graph representation:
    [1,4] ─── [2,5] ─── [3,6]
              ╱
         [3,6]            [7,10] (isolated)

Edges exist between:
- [1,4] and [2,5] (overlap)
- [1,4] and [3,6] (overlap)
- [2,5] and [3,6] (overlap)
- No edges to [7,10] (no overlaps)

Chromatic number = 3 (minimum colors needed)
```

### The Coloring Algorithm

```python
class IntervalColoring:
    """
    Assign colors to intervals using greedy coloring
    """
    
    def __init__(self):
        self.color_map = {}  # interval_id -> color
    
    def colorIntervals(self, intervals):
        """
        Assign colors to intervals
        
        Algorithm:
        1. Sort intervals by start time
        2. For each interval, find minimum available color
        3. A color is available if no overlapping interval uses it
        
        Time: O(n²) worst case (checking all colors)
              O(n log n) average with proper optimization
        Space: O(n)
        
        Returns: (num_colors, color_assignments)
        """
        if not intervals:
            return (0, {})
        
        # Sort by start time
        indexed = [(interval, i) for i, interval in enumerate(intervals)]
        indexed.sort(key=lambda x: x[0][0])
        
        # Track which colors are in use at current time
        # color_end_times[color] = last end time for this color
        color_end_times = []  # Min heap: (end_time, color)
        color_assignments = {}
        next_color = 0
        
        for interval, idx in indexed:
            start, end = interval
            
            # Find if any color is available (has finished)
            available_color = None
            
            if color_end_times and color_end_times[0][0] <= start:
                # Reuse a color
                _, available_color = heapq.heappop(color_end_times)
            else:
                # Need new color
                available_color = next_color
                next_color += 1
            
            # Assign color to this interval
            color_assignments[idx] = available_color
            heapq.heappush(color_end_times, (end, available_color))
        
        return (next_color, color_assignments)


# Test
coloring = IntervalColoring()
intervals = [[1,4], [2,5], [3,6], [7,10], [8,11]]
num_colors, assignments = coloring.colorIntervals(intervals)

print(f"Chromatic number (min colors): {num_colors}")
print(f"Color assignments: {assignments}")

# Visualize coloring
color_names = ['Red', 'Blue', 'Green', 'Yellow', 'Purple']
for i, interval in enumerate(intervals):
    color = color_names[assignments[i]] if assignments[i] < len(color_names) else f"Color{assignments[i]}"
    print(f"Interval {interval}: {color}")

"""
Output:
Chromatic number: 3
Color assignments: {0: 0, 1: 1, 2: 2, 3: 0, 4: 1}

Interval [1,4]: Red
Interval [2,5]: Blue
Interval [3,6]: Green
Interval [7,10]: Red (reused)
Interval [8,11]: Blue (reused)
"""
```

### Visual Representation of Coloring

```
Timeline: 0--1--2--3--4--5--6--7--8--9--10-11

Red:       [====]         [====]
           1   4          7   10

Blue:        [====]         [=====]
             2   5          8    11

Green:         [=====]
               3     6

No two intervals with same color overlap ✓
```

### Greedy Color Selection Algorithm

An alternative approach that explicitly finds the minimum available color:

```python
def greedyColoring(intervals):
    """
    Explicit greedy coloring - finds minimum available color
    
    Time: O(n² k) where k is number of colors
    Space: O(n)
    """
    if not intervals:
        return (0, {})
    
    n = len(intervals)
    colors = [-1] * n  # -1 means uncolored
    
    # Sort by start time
    indexed = [(interval, i) for i, interval in enumerate(intervals)]
    indexed.sort(key=lambda x: x[0][0])
    
    # Assign colors
    for interval, idx in indexed:
        start, end = interval
        
        # Find which colors are unavailable (used by overlapping intervals)
        unavailable = set()
        
        for other_interval, other_idx in indexed:
            if colors[other_idx] == -1:
                continue
            
            # Check if intervals overlap
            other_start, other_end = other_interval
            if not (end <= other_start or start >= other_end):
                # They overlap
                unavailable.add(colors[other_idx])
        
        # Find minimum available color
        color = 0
        while color in unavailable:
            color += 1
        
        colors[idx] = color
    
    max_color = max(colors) if colors else 0
    return (max_color + 1, {i: colors[i] for i in range(n)})


# Test
intervals = [[1,4], [2,5], [3,6], [7,10]]
num_colors, assignments = greedyColoring(intervals)
print(f"Colors needed: {num_colors}")
print(f"Assignments: {assignments}")
```

## 7.3 Graph Coloring Visualization and Applications

### Building the Interval Graph

```python
class IntervalGraph:
    """
    Represent intervals as a graph for coloring
    """
    
    def __init__(self, intervals):
        self.intervals = intervals
        self.n = len(intervals)
        self.adj_matrix = [[False] * self.n for _ in range(self.n)]
        self._build_graph()
    
    def _build_graph(self):
        """Build adjacency matrix - edge if intervals overlap"""
        for i in range(self.n):
            for j in range(i + 1, self.n):
                if self._overlaps(i, j):
                    self.adj_matrix[i][j] = True
                    self.adj_matrix[j][i] = True
    
    def _overlaps(self, i, j):
        """Check if intervals i and j overlap"""
        a = self.intervals[i]
        b = self.intervals[j]
        return not (a[1] <= b[0] or b[1] <= a[0])
    
    def get_neighbors(self, vertex):
        """Get all neighbors of a vertex"""
        return [j for j in range(self.n) if self.adj_matrix[vertex][j]]
    
    def chromatic_coloring(self):
        """
        Graph coloring using greedy algorithm
        
        Returns: (chromatic_number, coloring)
        """
        colors = [-1] * self.n
        
        # Color first vertex with color 0
        colors[0] = 0
        
        # Color remaining vertices
        for vertex in range(1, self.n):
            # Find colors used by neighbors
            neighbor_colors = set()
            for neighbor in self.get_neighbors(vertex):
                if colors[neighbor] != -1:
                    neighbor_colors.add(colors[neighbor])
            
            # Find minimum available color
            color = 0
            while color in neighbor_colors:
                color += 1
            
            colors[vertex] = color
        
        chromatic_number = max(colors) + 1 if colors else 0
        return (chromatic_number, colors)
    
    def visualize_graph(self):
        """Print the interval graph"""
        print("Interval Graph:")
        print("Vertices (intervals):")
        for i, interval in enumerate(self.intervals):
            print(f"  v{i}: {interval}")
        
        print("\nEdges (overlaps):")
        for i in range(self.n):
            for j in range(i + 1, self.n):
                if self.adj_matrix[i][j]:
                    print(f"  v{i} -- v{j}  ({self.intervals[i]} overlaps {self.intervals[j]})")
        
        print()


# Example usage
intervals = [[1,4], [2,5], [3,6], [5,7]]
graph = IntervalGraph(intervals)
graph.visualize_graph()

chromatic_num, coloring = graph.chromatic_coloring()
print(f"Chromatic Number: {chromatic_num}")
print(f"Coloring: {coloring}")

"""
Output:
Interval Graph:
Vertices (intervals):
  v0: [1,4]
  v1: [2,5]
  v2: [3,6]
  v3: [5,7]

Edges (overlaps):
  v0 -- v1  ([1,4] overlaps [2,5])
  v0 -- v2  ([1,4] overlaps [3,6])
  v1 -- v2  ([2,5] overlaps [3,6])
  v1 -- v3  ([2,5] overlaps [5,7])
  v2 -- v3  ([3,6] overlaps [5,7])

Chromatic Number: 3
Coloring: [0, 1, 2, 0]
"""
```

### Visual Graph Representation

```
Interval overlap graph for [[1,4], [2,5], [3,6], [5,7]]:

        v0 [1,4]
       /  \
      /    \
    v1 ---- v2
  [2,5]    [3,6]
     \      /
      \    /
       v3 [5,7]

This forms a cycle: v0-v1-v2-v0
Plus v3 connected to v1 and v2

Coloring:
v0: Color 0 (Red)
v1: Color 1 (Blue) - can't use 0 (adjacent to v0)
v2: Color 2 (Green) - can't use 0 or 1 (adjacent to v0, v1)
v3: Color 0 (Red) - can reuse 0 (not adjacent to v0)

Chromatic number: 3
```

## 7.4 Real-World Applications

### Application 1: Class Scheduling

```python
class ClassScheduler:
    """
    Schedule classes in minimum number of time slots
    Overlapping classes must be in different slots
    """
    
    def __init__(self):
        self.classes = []
    
    def add_class(self, name, start, end):
        """Add a class with time range"""
        self.classes.append({
            'name': name,
            'start': start,
            'end': end
        })
    
    def schedule(self):
        """
        Schedule all classes in minimum time slots
        
        Returns: (num_slots, schedule)
            schedule[slot] = list of classes in that slot
        """
        if not self.classes:
            return (0, {})
        
        # Extract intervals
        intervals = [[c['start'], c['end']] for c in self.classes]
        
        # Get coloring (time slots)
        num_slots, coloring = partitionIntervalsWithAssignment(intervals)
        
        # Build schedule
        schedule = {slot: [] for slot in range(num_slots)}
        for i, color in enumerate(coloring):
            schedule[color].append(self.classes[i]['name'])
        
        return (num_slots, schedule)


# Example: University course scheduling
scheduler = ClassScheduler()
scheduler.add_class("Math 101", 9, 10)
scheduler.add_class("Physics 201", 9, 11)
scheduler.add_class("CS 301", 10, 12)
scheduler.add_class("English 101", 14, 16)
scheduler.add_class("History 201", 15, 17)

num_slots, schedule = scheduler.schedule()

print(f"Minimum time slots needed: {num_slots}")
print("\nSchedule:")
for slot, classes in schedule.items():
    print(f"Slot {slot}: {', '.join(classes)}")

"""
Output:
Minimum time slots needed: 3

Schedule:
Slot 0: Math 101, English 101
Slot 1: Physics 201, History 201
Slot 2: CS 301
"""
```

### Application 2: Warehouse Storage Allocation

```python
class WarehouseAllocator:
    """
    Allocate warehouse zones for time-based storage
    Items with overlapping time requirements need different zones
    """
    
    def __init__(self, num_zones):
        self.num_zones = num_zones
        self.items = []
    
    def add_item(self, item_id, arrival, departure):
        """Add item with arrival and departure times"""
        self.items.append({
            'id': item_id,
            'arrival': arrival,
            'departure': departure
        })
    
    def allocate(self):
        """
        Allocate zones to items
        
        Returns: (success, allocation)
            success: True if all items fit in available zones
            allocation: dict mapping item_id -> zone
        """
        if not self.items:
            return (True, {})
        
        # Extract time intervals
        intervals = [[item['arrival'], item['departure']] 
                     for item in self.items]
        
        # Get zone assignments
        zones_needed, assignments = partitionIntervalsWithAssignment(intervals)
        
        if zones_needed > self.num_zones:
            return (False, None)
        
        # Build allocation map
        allocation = {self.items[i]['id']: assignments[i] 
                     for i in range(len(self.items))}
        
        return (True, allocation)


# Example
warehouse = WarehouseAllocator(num_zones=3)
warehouse.add_item("Item_A", arrival=1, departure=5)
warehouse.add_item("Item_B", arrival=2, departure=6)
warehouse.add_item("Item_C", arrival=3, departure=7)
warehouse.add_item("Item_D", arrival=8, departure=12)

success, allocation = warehouse.allocate()

if success:
    print("Allocation successful!")
    print("Item -> Zone:")
    for item_id, zone in allocation.items():
        print(f"  {item_id}: Zone {zone}")
else:
    print("Not enough zones available!")
```

### Application 3: Register Allocation in Compilers

```python
class RegisterAllocator:
    """
    Allocate CPU registers to variables (interval coloring in compilers)
    Variables with overlapping live ranges need different registers
    """
    
    def __init__(self, num_registers):
        self.num_registers = num_registers
        self.variables = []
    
    def add_variable(self, var_name, live_start, live_end):
        """Add variable with its live range"""
        self.variables.append({
            'name': var_name,
            'start': live_start,
            'end': live_end
        })
    
    def allocate_registers(self):
        """
        Allocate registers to variables
        
        Returns: (success, allocation, spilled)
            success: True if all variables fit in registers
            allocation: dict mapping variable -> register
            spilled: list of variables that need to be spilled to memory
        """
        if not self.variables:
            return (True, {}, [])
        
        # Extract live ranges
        intervals = [[var['start'], var['end']] 
                     for var in self.variables]
        
        # Perform coloring
        registers_needed, assignments = partitionIntervalsWithAssignment(intervals)
        
        allocation = {}
        spilled = []
        
        for i, var in enumerate(self.variables):
            register = assignments[i]
            if register < self.num_registers:
                # Fits in register
                allocation[var['name']] = f"R{register}"
            else:
                # Needs to be spilled to memory
                spilled.append(var['name'])
                allocation[var['name']] = "MEMORY"
        
        success = len(spilled) == 0
        return (success, allocation, spilled)


# Example: Simplified compiler register allocation
allocator = RegisterAllocator(num_registers=4)

# Variables and their live ranges (instruction indices)
allocator.add_variable("a", live_start=1, live_end=5)
allocator.add_variable("b", live_start=2, live_end=8)
allocator.add_variable("c", live_start=3, live_end=6)
allocator.add_variable("d", live_start=7, live_end=10)
allocator.add_variable("e", live_start=4, live_end=9)

success, allocation, spilled = allocator.allocate_registers()

print("Register Allocation:")
for var, reg in allocation.items():
    print(f"  {var}: {reg}")

if not success:
    print(f"\nSpilled variables (to memory): {spilled}")
else:
    print("\nAll variables successfully allocated to registers!")
```

## 7.5 Comparison: Partitioning vs Coloring

### Conceptual Equivalence

```python
def compare_partitioning_and_coloring():
    """
    Demonstrate that partitioning and coloring are the same problem
    """
    
    intervals = [[1,4], [2,5], [3,6], [7,10]]
    
    # Method 1: Interval Partitioning
    num_groups, group_assignments = partitionIntervalsWithAssignment(intervals)
    
    # Method 2: Graph Coloring
    graph = IntervalGraph(intervals)
    num_colors, color_assignments = graph.chromatic_coloring()
    
    print("Method 1: Interval Partitioning")
    print(f"  Groups needed: {num_groups}")
    print(f"  Assignments: {group_assignments}")
    
    print("\nMethod 2: Graph Coloring")
    print(f"  Colors needed: {num_colors}")
    print(f"  Assignments: {color_assignments}")
    
    print("\n" + "="*50)
    print("Both methods give the same result!")
    print(f"Minimum groups/colors: {num_groups}")
    
    # Verify they're equivalent
    assert num_groups == num_colors, "Should be equal!"
    
    # Show the mapping
    print("\nTerminology mapping:")
    print("  Partition Group ≡ Graph Color")
    print("  No overlaps in group ≡ No edges between same color")
    print("  Min groups ≡ Chromatic number")


compare_partitioning_and_coloring()
```

### When to Use Each Terminology

| Context | Use Term | Example |
|---------|----------|---------|
| Scheduling | Partitioning | Time slots, shifts |
| Resource Allocation | Coloring | Registers, frequencies |
| Mathematics | Graph Coloring | Theory, proofs |
| Interviews | Either | Clarify with interviewer |

## Key Takeaways from Chapter 7

### Core Concepts

1. **Interval Partitioning = Graph Coloring**
   - Same problem, different terminology
   - Minimum partitions = Chromatic number

2. **Algorithm Complexity**
   - Greedy with heap: O(n log n)
   - Best possible for this problem
   - Can't do better than sorting

3. **Key Insight**
   - Maximum depth of overlaps = minimum groups/colors
   - This is a fundamental property of interval graphs

### Implementation Strategies

```python
# Strategy 1: Heap-based (Best for interviews)
def heap_based_coloring(intervals):
    # Use min heap to track available colors
    # Time: O(n log n), Space: O(n)
    pass

# Strategy 2: Explicit graph (Best for understanding)
def graph_based_coloring(intervals):
    # Build interval graph explicitly
    # Use graph coloring algorithm
    # Time: O(n²), Space: O(n²)
    pass

# Strategy 3: Sweep line (Alternative)
def sweep_line_coloring(intervals):
    # Process start/end events
    # Track concurrent intervals
    # Time: O(n log n), Space: O(n)
    pass
```

### Interview Tips

1. **Recognize the pattern** - "minimum groups" or "assign colors"
2. **Know the equivalence** - Partitioning ≡ Coloring ≡ Meeting Rooms II
3. **Choose best approach** - Heap-based is clearest for interviews
4. **Explain graph interpretation** - Shows deeper understanding
5. **Handle edge cases** - Empty input, single interval, all overlap

### Practice Problems

✓ Schedule classes with minimum time slots  
✓ Allocate meeting rooms with room constraints  
✓ Register allocation in compiler optimization  
✓ Frequency assignment in wireless networks  
✓ Task assignment with resource constraints  

### Next Steps

Chapter 8 will cover special interval problems including employee free time, balloon bursting variations, and complex real-world scenarios!