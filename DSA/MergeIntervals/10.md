# Chapter 10: Optimization Techniques

## 10.1 Coordinate Compression

### What is Coordinate Compression?

**Problem:** When intervals have very large coordinate values (e.g., up to 10^9), array-based solutions become impractical.

**Solution:** Map large coordinates to a smaller, dense range while preserving relative ordering.

### When to Use Coordinate Compression

```
Scenario 1: Without Compression (IMPRACTICAL)
Intervals: [[1, 1000000000], [500000000, 1000000000]]
Array needed: 1 billion elements
Memory: ~4 GB for int array

Scenario 2: With Compression (PRACTICAL)
Unique coordinates: [1, 500000000, 1000000000]
Compressed: [0, 1, 2]
Array needed: 3 elements
Memory: ~12 bytes
```

### Basic Coordinate Compression Algorithm

```python
def coordinate_compression(intervals):
    """
    Compress coordinates to smaller range
    
    Time: O(n log n) for sorting
    Space: O(n) for mapping
    
    Args:
        intervals: List[List[int]] - intervals with large coordinates
    
    Returns:
        compressed_intervals: intervals with compressed coordinates
        coord_map: mapping from compressed to original
        reverse_map: mapping from original to compressed
    """
    # Step 1: Collect all unique coordinates
    coords = set()
    for start, end in intervals:
        coords.add(start)
        coords.add(end)
    
    # Step 2: Sort coordinates
    sorted_coords = sorted(coords)
    
    # Step 3: Create mappings
    # compressed -> original
    coord_map = {i: coord for i, coord in enumerate(sorted_coords)}
    
    # original -> compressed
    reverse_map = {coord: i for i, coord in enumerate(sorted_coords)}
    
    # Step 4: Compress intervals
    compressed_intervals = []
    for start, end in intervals:
        compressed_start = reverse_map[start]
        compressed_end = reverse_map[end]
        compressed_intervals.append([compressed_start, compressed_end])
    
    return compressed_intervals, coord_map, reverse_map


# Example
intervals = [[1, 1000000000], [500000000, 750000000], [1, 500000000]]
compressed, coord_map, reverse_map = coordinate_compression(intervals)

print("Original intervals:", intervals)
print("\nCompressed intervals:", compressed)
print("\nCoordinate mapping:")
for comp, orig in coord_map.items():
    print(f"  {comp} -> {orig}")

"""
Output:
Original intervals: [[1, 1000000000], [500000000, 750000000], [1, 500000000]]

Compressed intervals: [[0, 3], [1, 2], [0, 1]]

Coordinate mapping:
  0 -> 1
  1 -> 500000000
  2 -> 750000000
  3 -> 1000000000
  
Visual:
Original scale:
[1                                                    1000000000]
           [500000000    750000000]
[1              500000000]

Compressed scale:
[0      1       2       3]
        [=======]
[============]
"""
```

### Step-by-Step Execution

```
Input: [[1, 1000000000], [500000000, 750000000], [1, 500000000]]

STEP 1: Collect unique coordinates
From [1, 1000000000]: add 1, 1000000000
From [500000000, 750000000]: add 500000000, 750000000
From [1, 500000000]: add 1 (already exists), 500000000 (already exists)

Unique coords: {1, 500000000, 750000000, 1000000000}

STEP 2: Sort coordinates
Sorted: [1, 500000000, 750000000, 1000000000]

STEP 3: Create mappings
Index 0 -> 1
Index 1 -> 500000000
Index 2 -> 750000000
Index 3 -> 1000000000

STEP 4: Compress intervals
[1, 1000000000] -> [0, 3]
[500000000, 750000000] -> [1, 2]
[1, 500000000] -> [0, 1]

Result: [[0, 3], [1, 2], [0, 1]]
```

### Application: Range Sum Queries with Coordinate Compression

```python
class RangeSumWithCompression:
    """
    Handle range sum queries with large coordinates
    using coordinate compression
    """
    
    def __init__(self, intervals_with_values):
        """
        intervals_with_values: List[Tuple[int, int, int]]
                              [(start, end, value), ...]
        """
        self.intervals_with_values = intervals_with_values
        self._compress()
        self._build_array()
    
    def _compress(self):
        """Compress coordinates"""
        coords = set()
        for start, end, _ in self.intervals_with_values:
            coords.add(start)
            coords.add(end)
            coords.add(end + 1)  # Add right boundary + 1
        
        self.sorted_coords = sorted(coords)
        self.coord_to_idx = {coord: i for i, coord in enumerate(self.sorted_coords)}
        
        # Compressed intervals
        self.compressed = []
        for start, end, value in self.intervals_with_values:
            comp_start = self.coord_to_idx[start]
            comp_end = self.coord_to_idx[end]
            self.compressed.append((comp_start, comp_end, value))
    
    def _build_array(self):
        """Build difference array on compressed coordinates"""
        size = len(self.sorted_coords)
        self.diff = [0] * size
        
        # Apply all interval additions
        for comp_start, comp_end, value in self.compressed:
            self.diff[comp_start] += value
            if comp_end + 1 < size:
                self.diff[comp_end + 1] -= value
        
        # Build prefix sum
        self.prefix_sum = [0] * size
        self.prefix_sum[0] = self.diff[0]
        for i in range(1, size):
            self.prefix_sum[i] = self.prefix_sum[i-1] + self.diff[i]
    
    def query_range(self, start, end):
        """Query sum in range [start, end]"""
        # Find compressed coordinates
        # Use binary search or direct lookup
        result = 0
        
        for i in range(len(self.sorted_coords) - 1):
            coord_start = self.sorted_coords[i]
            coord_end = self.sorted_coords[i + 1]
            
            # Check if this segment overlaps with query range
            overlap_start = max(start, coord_start)
            overlap_end = min(end + 1, coord_end)
            
            if overlap_start < overlap_end:
                # This segment overlaps
                length = overlap_end - overlap_start
                result += self.prefix_sum[i] * length
        
        return result


# Example
intervals_vals = [
    (1, 1000000000, 5),
    (500000000, 750000000, 10),
    (1, 500000000, 3)
]

rs = RangeSumWithCompression(intervals_vals)

print("Query [1, 499999999]:")
print(rs.query_range(1, 499999999))

print("\nQuery [500000000, 750000000]:")
print(rs.query_range(500000000, 750000000))

"""
Segments after compression:
[1, 500000000): value = 5 + 3 = 8
[500000000, 750000000]: value = 5 + 10 + 3 = 18
[750000000 + 1, 1000000000]: value = 5

Query [1, 499999999]:
  Length: 499999999 - 1 + 1 = 499999999
  Value per unit: 8
  Sum: 8 * 499999999 = 3999999992
"""
```

### Advanced: Coordinate Compression with Events

```python
class EventBasedCompression:
    """
    Coordinate compression using event processing
    Useful for sweep line algorithms
    """
    
    def __init__(self, intervals):
        self.intervals = intervals
        self.events = []
        self._create_events()
        self._process_events()
    
    def _create_events(self):
        """Create events from intervals"""
        event_set = set()
        
        for start, end in self.intervals:
            event_set.add(start)
            event_set.add(end)
            event_set.add(end + 1)  # Right boundary
        
        self.sorted_events = sorted(event_set)
        self.event_to_idx = {event: i for i, event in enumerate(self.sorted_events)}
    
    def _process_events(self):
        """Process events to build compressed representation"""
        n = len(self.sorted_events)
        self.segments = []
        
        # Each segment is between consecutive events
        for i in range(n - 1):
            start = self.sorted_events[i]
            end = self.sorted_events[i + 1] - 1
            self.segments.append((start, end, i))
    
    def get_compressed_intervals(self):
        """Get intervals in compressed space"""
        compressed = []
        
        for start, end in self.intervals:
            comp_start = self.event_to_idx[start]
            comp_end = self.event_to_idx[end]
            compressed.append((comp_start, comp_end))
        
        return compressed
    
    def get_segment_info(self, segment_idx):
        """Get original coordinates for compressed segment"""
        if segment_idx < len(self.segments):
            return self.segments[segment_idx]
        return None


# Example
intervals = [[1, 5], [2, 7], [4, 10]]
ebc = EventBasedCompression(intervals)

print("Original intervals:", intervals)
print("\nCompressed intervals:", ebc.get_compressed_intervals())
print("\nSegments:")
for i, (start, end, idx) in enumerate(ebc.segments):
    print(f"  Segment {i}: [{start}, {end}] (compressed idx {idx})")

"""
Original intervals: [[1, 5], [2, 7], [4, 10]]

Events: [1, 2, 4, 5, 6, 7, 8, 10, 11]
         0  1  2  3  4  5  6  7   8

Compressed intervals: [(0, 3), (1, 5), (2, 7)]

Segments:
  Segment 0: [1, 1] (compressed idx 0)    - covers [1,1]
  Segment 1: [2, 3] (compressed idx 1)    - covers [2,3]
  Segment 2: [4, 4] (compressed idx 2)    - covers [4,4]
  Segment 3: [5, 5] (compressed idx 3)    - covers [5,5]
  Segment 4: [6, 6] (compressed idx 4)    - covers [6,6]
  Segment 5: [7, 7] (compressed idx 5)    - covers [7,7]
  Segment 6: [8, 9] (compressed idx 6)    - covers [8,9]
  Segment 7: [10, 10] (compressed idx 7)  - covers [10,10]
"""
```

## 10.2 Difference Array Technique

### What is a Difference Array?

**Concept:** Instead of updating ranges directly, we mark start and end points of changes. A final sweep computes actual values.

**Key Advantage:** Convert O(n) range updates to O(1) updates!

### Basic Difference Array

```python
class DifferenceArray:
    """
    Efficient range updates using difference array
    
    Without diff array: O(n) per range update
    With diff array: O(1) per range update + O(n) final build
    """
    
    def __init__(self, size):
        self.size = size
        self.diff = [0] * (size + 1)  # Extra space for boundary
        self.values = None
    
    def add_range(self, left, right, value):
        """
        Add value to range [left, right] inclusive
        
        Time: O(1)
        """
        self.diff[left] += value
        self.diff[right + 1] -= value
    
    def build(self):
        """
        Build final array after all updates
        
        Time: O(n)
        """
        self.values = [0] * self.size
        self.values[0] = self.diff[0]
        
        for i in range(1, self.size):
            self.values[i] = self.values[i-1] + self.diff[i]
        
        return self.values
    
    def get_value(self, index):
        """Get value at index (must call build first)"""
        if self.values is None:
            self.build()
        return self.values[index]


# Example
da = DifferenceArray(10)

# Multiple range updates
da.add_range(1, 5, 10)   # Add 10 to [1,5]
da.add_range(3, 7, 5)    # Add 5 to [3,7]
da.add_range(0, 2, -3)   # Add -3 to [0,2]

# Build final array
result = da.build()

print("Final array:", result)
print("\nVisualization:")
for i in range(10):
    print(f"Index {i}: {result[i]:3d} {'█' * max(0, result[i])}")

"""
Updates:
[1,5] +10:    [10,10,10,10,10]
[3,7] +5:        [5, 5, 5, 5, 5]
[0,2] -3:  [-3,-3,-3]

Final:     [-3, 7, 7,15,15,15, 5, 5]
Index 0:  -3
Index 1:   7 ███████
Index 2:   7 ███████
Index 3:  15 ███████████████
Index 4:  15 ███████████████
Index 5:  15 ███████████████
Index 6:   5 █████
Index 7:   5 █████
Index 8:   0
Index 9:   0
"""
```

### How Difference Array Works

```
Example: Add 5 to range [2, 5] in array of size 8

Step 1: Mark boundaries
diff[2] += 5    (start of range)
diff[6] -= 5    (end + 1 of range)

diff array: [0, 0, +5, 0, 0, 0, -5, 0, 0]
index:       0  1   2  3  4  5   6  7  8

Step 2: Compute prefix sum
values[0] = 0
values[1] = 0 + 0 = 0
values[2] = 0 + 5 = 5    ← starts here
values[3] = 5 + 0 = 5
values[4] = 5 + 0 = 5
values[5] = 5 + 0 = 5
values[6] = 5 - 5 = 0    ← ends here
values[7] = 0 + 0 = 0

Final: [0, 0, 5, 5, 5, 5, 0, 0]
              [==========]  ← range [2,5] has value 5
```

### Application: Meeting Room Bookings with Difference Array

```python
def meeting_room_bookings(bookings, n):
    """
    Given bookings = [[start, end, rooms], ...]
    Find maximum rooms needed at any time in [0, n)
    
    Time: O(m + n) where m = number of bookings
    Space: O(n)
    
    Args:
        bookings: List[List[int]] - [start, end, num_rooms]
        n: int - time range [0, n)
    
    Returns:
        int - maximum rooms needed at any point
    """
    diff = [0] * (n + 1)
    
    # Apply all bookings using difference array
    for start, end, rooms in bookings:
        diff[start] += rooms
        diff[end + 1] -= rooms
    
    # Find maximum during sweep
    current_rooms = 0
    max_rooms = 0
    
    for i in range(n):
        current_rooms += diff[i]
        max_rooms = max(max_rooms, current_rooms)
    
    return max_rooms


# Example
bookings = [
    [1, 5, 2],    # 2 rooms from time 1-5
    [3, 7, 3],    # 3 rooms from time 3-7
    [2, 4, 1],    # 1 room from time 2-4
]

result = meeting_room_bookings(bookings, 10)
print(f"Maximum rooms needed: {result}")

"""
Timeline visualization:
Time: 0  1  2  3  4  5  6  7  8  9
      ────────────────────────────
      0  2  3  5  5  2  3  3  0  0
         └─┬─┴─┬─┬─┘  └─┬─┘
           2  3 5 5     3 3
           
Maximum: 5 rooms at time 3-4

Step by step:
diff[1] += 2  → booking 1 starts
diff[6] -= 2  → booking 1 ends
diff[3] += 3  → booking 2 starts
diff[8] -= 3  → booking 2 ends
diff[2] += 1  → booking 3 starts
diff[5] -= 1  → booking 3 ends

Sweep:
time 0: 0 rooms
time 1: 0 + 2 = 2 rooms
time 2: 2 + 1 = 3 rooms
time 3: 3 + 3 = 6 rooms  ← WRONG, let me recalculate
time 4: 6 + 0 = 6 rooms
time 5: 6 - 1 = 5 rooms
time 6: 5 - 2 = 3 rooms
time 7: 3 + 0 = 3 rooms
time 8: 3 - 3 = 0 rooms

Actually the calculation should be:
diff array after all updates:
[0, 2, 1, 3, 0, -1, -2, 0, -3, 0]

Prefix sum:
0→0, 1→2, 2→3, 3→6, 4→6, 5→5, 6→3, 7→3, 8→0

Maximum: 6 (but wait, this doesn't match our bookings!)

Let me recalculate:
Booking [1,5,2]: diff[1]+=2, diff[6]-=2
Booking [3,7,3]: diff[3]+=3, diff[8]-=3
Booking [2,4,1]: diff[2]+=1, diff[5]-=1

diff: [0, 2, 1, 3, 0, -1, -2, 0, -3, 0]
Prefix: [0, 2, 3, 6, 6, 5, 3, 3, 0, 0]

At time 3-4: 6 rooms total
  From booking 1: 2 rooms
  From booking 2: 3 rooms
  From booking 3: 1 room
  Total: 6 ✓
"""
```

### Difference Array for 2D Ranges

```python
class DifferenceArray2D:
    """
    2D difference array for rectangular range updates
    
    Update rectangle: O(1)
    Build final array: O(rows * cols)
    """
    
    def __init__(self, rows, cols):
        self.rows = rows
        self.cols = cols
        # Extra padding for boundaries
        self.diff = [[0] * (cols + 1) for _ in range(rows + 1)]
    
    def add_rectangle(self, r1, c1, r2, c2, value):
        """
        Add value to rectangle [r1,c1] to [r2,c2] inclusive
        
        Time: O(1)
        """
        # Top-left corner: add value
        self.diff[r1][c1] += value
        
        # Bottom-left corner: subtract (below rectangle)
        self.diff[r2 + 1][c1] -= value
        
        # Top-right corner: subtract (right of rectangle)
        self.diff[r1][c2 + 1] -= value
        
        # Bottom-right corner: add back (doubly subtracted)
        self.diff[r2 + 1][c2 + 1] += value
    
    def build(self):
        """
        Build final 2D array
        
        Time: O(rows * cols)
        """
        # Compute prefix sum in 2D
        result = [[0] * self.cols for _ in range(self.rows)]
        
        for i in range(self.rows):
            for j in range(self.cols):
                result[i][j] = self.diff[i][j]
                
                if i > 0:
                    result[i][j] += result[i-1][j]
                if j > 0:
                    result[i][j] += result[i][j-1]
                if i > 0 and j > 0:
                    result[i][j] -= result[i-1][j-1]
        
        return result


# Example
da2d = DifferenceArray2D(5, 5)

# Add values to rectangles
da2d.add_rectangle(1, 1, 3, 3, 10)  # Center square
da2d.add_rectangle(0, 0, 1, 4, 5)   # Top rows

result = da2d.build()

print("2D Difference Array Result:")
for row in result:
    print([f"{val:3d}" for val in row])

"""
Output visualization:
[ 5,  5,  5,  5,  5]
[ 5, 15, 15, 15,  5]
[ 0, 10, 10, 10,  0]
[ 0, 10, 10, 10,  0]
[ 0,  0,  0,  0,  0]

Rectangle [1,1] to [3,3] has +10
Rectangle [0,0] to [1,4] has +5
Overlap [1,1] to [1,3] has 10+5=15
"""
```

## 10.3 Two-Pointer Optimization

### When to Use Two Pointers with Intervals

**Pattern Recognition:**
- Processing two sorted sequences
- Finding pairs/combinations
- Merging operations
- Minimizing time complexity from O(n²) to O(n)

### Classic Two-Pointer Pattern for Intervals

```python
def two_pointer_template(list1, list2):
    """
    Template for two-pointer approach on sorted interval lists
    
    Time: O(n + m)
    Space: O(1) excluding output
    """
    i = 0  # Pointer for list1
    j = 0  # Pointer for list2
    result = []
    
    while i < len(list1) and j < len(list2):
        interval1 = list1[i]
        interval2 = list2[j]
        
        # Process current intervals
        # ... problem-specific logic ...
        
        # Decide which pointer to advance
        if should_advance_i(interval1, interval2):
            i += 1
        elif should_advance_j(interval1, interval2):
            j += 1
        else:
            # Advance both or handle specially
            i += 1
            j += 1
    
    # Handle remaining elements
    while i < len(list1):
        # Process remaining from list1
        i += 1
    
    while j < len(list2):
        # Process remaining from list2
        j += 1
    
    return result
```

### Application 1: Merge Sorted Interval Lists

```python
def merge_two_sorted_interval_lists(list1, list2):
    """
    Merge two sorted, non-overlapping interval lists
    
    Time: O(n + m)
    Space: O(1) excluding output
    """
    i = j = 0
    result = []
    
    # Get first interval
    if not list1 and not list2:
        return []
    elif not list1:
        return list2[:]
    elif not list2:
        return list1[:]
    
    current = None
    
    while i < len(list1) or j < len(list2):
        # Determine next interval to process
        if i >= len(list1):
            next_interval = list2[j]
            j += 1
        elif j >= len(list2):
            next_interval = list1[i]
            i += 1
        elif list1[i][0] <= list2[j][0]:
            next_interval = list1[i]
            i += 1
        else:
            next_interval = list2[j]
            j += 1
        
        # Merge with current or add to result
        if current is None:
            current = next_interval[:]
        elif current[1] >= next_interval[0]:
            # Merge
            current[1] = max(current[1], next_interval[1])
        else:
            # No overlap, add current and start new
            result.append(current)
            current = next_interval[:]
    
    if current:
        result.append(current)
    
    return result


# Example
list1 = [[1, 3], [5, 7], [9, 11]]
list2 = [[2, 4], [6, 8], [10, 12]]

merged = merge_two_sorted_interval_lists(list1, list2)
print("Merged intervals:", merged)

"""
Timeline:
List1: [==]  [==]  [==]
       1  3  5  7  9 11

List2:   [==]  [==]  [==]
         2  4  6  8 10 12

Merged: [====][====][=====]
        1   4 5   8 9    12

Process:
1. Pick [1,3] (list1[0])
2. Pick [2,4] (list2[0]) → merges to [1,4]
3. Pick [5,7] (list1[1])
4. Pick [6,8] (list2[1]) → merges to [5,8]
5. Pick [9,11] (list1[2])
6. Pick [10,12] (list2[2]) → merges to [9,12]

Result: [[1,4], [5,8], [9,12]]
"""
```

### Application 2: Employee Free Time (Advanced Two-Pointer)

```python
def employee_free_time(schedules):
    """
    Find common free time across all employees
    
    schedules: List[List[Interval]] - each employee's busy times
    
    Time: O(n log n) where n = total intervals
    Space: O(n)
    """
    # Flatten and sort all intervals
    all_intervals = []
    for schedule in schedules:
        all_intervals.extend(schedule)
    
    all_intervals.sort(key=lambda x: x[0])
    
    # Merge overlapping intervals
    merged = []
    for interval in all_intervals:
        if not merged or merged[-1][1] < interval[0]:
            merged.append(interval[:])
        else:
            merged[-1][1] = max(merged[-1][1], interval[1])
    
    # Find gaps (free times)
    free_times = []
    for i in range(len(merged) - 1):
        free_start = merged[i][1]
        free_end = merged[i + 1][0]
        if free_start < free_end:
            free_times.append([free_start, free_end])
    
    return free_times


# Example
schedules = [
    [[1, 3], [6, 7]],      # Employee 1
    [[2, 4]],              # Employee 2
    [[2, 5], [9, 12]]      # Employee 3
]

free_times = employee_free_time(schedules)
print("Common free times:", free_times)

"""
Timeline: 0-1-2-3-4-5-6-7-8-9-10-11-12

Emp 1:    [==]    [=]
          1  3    6 7

Emp 2:      [===]
            2   4

Emp 3:      [======]      [======]
            2      5      9      12

All busy: [========]  [=] [======]
          1        5  6 7 9      12

Free:              [=] [=]
                   5 6 7 9

Free times: [[5, 6], [7, 9]]
"""
```

### Optimization: Skip Non-Overlapping Intervals Fast

```python
def optimize_with_binary_search(intervals, target_interval):
    """
    Use binary search to skip intervals that definitely don't overlap
    
    Useful when one list is much longer than the other
    
    Time: O(m log n) where m = shorter list, n = longer list
    """
    import bisect
    
    # Extract start and end times
    starts = [interval[0] for interval in intervals]
    ends = [interval[1] for interval in intervals]
    
    target_start, target_end = target_interval
    
    # Find first interval that could overlap
    # First interval where end >= target_start
    left_bound = bisect.bisect_left(ends, target_start)
    
    # Find last interval that could overlap
    # Last interval where start <= target_end
    right_bound = bisect.bisect_right(starts, target_end)
    
    # Only check intervals in range [left_bound, right_bound)
    overlapping = []
    for i in range(max(0, left_bound), min(len(intervals), right_bound)):
        if intervals[i][1] >= target_start and intervals[i][0] <= target_end:
            overlapping.append(intervals[i])
    
    return overlapping


# Example with large list
large_list = [[i*10, i*10+5] for i in range(1000)]  # 1000 intervals
target = [250, 280]

overlapping = optimize_with_binary_search(large_list, target)
print(f"Found {len(overlapping)} overlapping intervals")
print("Overlapping:", overlapping[:5])  # Show first 5

"""
Without optimization: Check all 1000 intervals = O(n)
With binary search: Jump directly to relevant range = O(log n) + O(k)
where k = number of overlapping intervals

For sparse overlaps, this is much faster!
"""
```

## Performance Comparison

```python
import time
import random

def benchmark_optimizations():
    """Compare performance of different optimization techniques"""
    
    # Generate large dataset
    n = 100000
    intervals = [[i, i + random.randint(1, 100)] for i in range(0, n*10, 10)]
    
    print("="*60)
    print("PERFORMANCE COMPARISON")
    print("="*60)
    print(f"Dataset size: {n} intervals")
    print()
    
    # Test 1: Coordinate Compression
    print("1. Coordinate Compression")
    start = time.time()
    compressed, _, _ = coordinate_compression(intervals[:1000])
    elapsed = time.time() - start
    print(f"   Time: {elapsed*1000:.2f}ms")
    print(f"   Compressed from {max(intervals[999])} to {len(compressed)} coordinates")
    print()
    
    # Test 2: Difference Array vs Direct Updates
    print("2. Difference Array vs Direct Updates")
    
    # Direct updates
    start = time.time()
    arr = [0] * 10000
    for i in range(1000):
        left, right = random.randint(0, 9000), random.randint(0, 9999)
        if left > right:
            left, right = right, left
        for j in range(left, right + 1):
            arr[j] += 1
    elapsed_direct = time.time() - start
    
    # Difference array
    start = time.time()
    da = DifferenceArray(10000)
    for i in range(1000):
        left, right = random.randint(0, 9000), random.randint(0, 9999)
        if left > right:
            left, right = right, left
        da.add_range(left, right, 1)
    da.build()
    elapsed_diff = time.time() - start
    
    print(f"   Direct updates: {elapsed_direct*1000:.2f}ms")
    print(f"   Difference array: {elapsed_diff*1000:.2f}ms")
    print(f"   Speedup: {elapsed_direct/elapsed_diff:.2f}x")
    print()
    
    # Test 3: Two-Pointer Efficiency
    print("3. Two-Pointer Merge Efficiency")
    list1 = [[i*2, i*2+1] for i in range(5000)]
    list2 = [[i*2+1, i*2+2] for i in range(5000)]
    
    start = time.time()
    merged = merge_two_sorted_interval_lists(list1, list2)
    elapsed = time.time() - start
    
    print(f"   Merged {len(list1)} + {len(list2)} = {len(merged)} intervals")
    print(f"   Time: {elapsed*1000:.2f}ms")
    print(f"   Complexity: O(n+m) = O({len(list1)+len(list2)})")

# Run benchmark
benchmark_optimizations()
```

## Key Takeaways from Chapter 10

### Optimization Decision Tree

```
Large coordinates (>10^6)?
├─ YES → Use Coordinate Compression
└─ NO → Continue

Multiple range updates?
├─ YES → Use Difference Array
└─ NO → Continue

Two sorted sequences?
├─ YES → Use Two-Pointer
└─ NO → Continue

Need fast lookups?
├─ YES → Use Binary Search
└─ NO → Standard approach
```

### Complexity Improvements

| Technique | Before | After | Use Case |
|-----------|--------|-------|----------|
| Coordinate Compression | O(max_coord) | O(n) | Large sparse ranges |
| Difference Array | O(n*m) updates | O(n+m) | Multiple range updates |
| Two-Pointer | O(n*m) | O(n+m) | Sorted sequences |
| Binary Search | O(n) search | O(log n) | Finding boundaries |

### When NOT to Use These Optimizations

❌ **Coordinate Compression:** Small coordinate range (<10^5)  
❌ **Difference Array:** Few range updates (<10), small ranges  
❌ **Two-Pointer:** Unsorted data, random access needed  
❌ **Binary Search:** Unsorted data, very small datasets

### Interview Strategy

1. **Identify bottleneck** - what's making it slow?
2. **Choose optimization** - which technique applies?
3. **Implement carefully** - off-by-one errors are common
4. **Test edge cases** - boundaries, empty inputs
5. **Explain trade-offs** - space vs time, simplicity vs optimization

Master these techniques and you'll handle any interval optimization problem in interviews!