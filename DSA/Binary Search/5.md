# Chapter 5: Advanced Binary Search Patterns - In-Depth Guide

## Table of Contents
1. [Search in Rotated Sorted Array](#search-in-rotated-sorted-array)
2. [Find Minimum in Rotated Array](#find-minimum-in-rotated-array)
3. [Find Peak Element](#find-peak-element)
4. [Search in 2D Matrix](#search-in-2d-matrix)
5. [Median of Two Sorted Arrays](#median-of-two-sorted-arrays)

---

## Search in Rotated Sorted Array

### Concept Overview

A **rotated sorted array** is a sorted array that has been rotated at some pivot point.

**Visual Example:**
```
Original sorted: [0, 1, 2, 4, 5, 6, 7]
                           ‚Üì Rotate at index 4
Rotated result:  [4, 5, 6, 7, 0, 1, 2]
                  ‚Üêsorted‚Üí  ‚Üêsorted‚Üí
```

**Key Insight:** Even though the array is rotated, **at least one half is always properly sorted**.

### Why One Half is Always Sorted

```
Array: [4, 5, 6, 7, 0, 1, 2]
         L       M       R

Case 1: Left half sorted (nums[L] <= nums[M])
  [4, 5, 6, 7] is sorted ‚úÖ
  [7, 0, 1, 2] is not sorted

Case 2: Right half sorted (nums[M] <= nums[R])
  Would happen in: [5, 6, 7, 0, 1, 2, 4]
                        L   M       R
  [5, 6, 7, 0] is not sorted
  [0, 1, 2, 4] is sorted ‚úÖ
```

### The Algorithm Strategy

**Step-by-step approach:**
1. Find middle element
2. Determine which half is sorted
3. Check if target is in the sorted half
4. If yes, search in sorted half
5. If no, search in the other half

**Decision Tree:**
```
        Find mid
           |
    Is left half sorted?
    /              \
  YES              NO (right half is sorted)
   |                |
Target in         Target in
sorted range?     sorted range?
 /    \            /    \
YES   NO         YES   NO
 |     |          |     |
Go    Go         Go    Go
left  right      right left
```

### Complete Implementation with Detailed Comments

```python
def search_rotated_array(nums, target):
    """
    Search for target in rotated sorted array.
    
    Time: O(log n)
    Space: O(1)
    
    Example:
    nums = [4, 5, 6, 7, 0, 1, 2], target = 0
    Output: 4
    """
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Found target
        if nums[mid] == target:
            return mid
        
        # Determine which half is sorted
        # Check if LEFT half is sorted
        if nums[left] <= nums[mid]:
            # Left half [left...mid] is sorted
            # Check if target is in this sorted range
            if nums[left] <= target < nums[mid]:
                # Target is in sorted left half
                right = mid - 1
            else:
                # Target is in unsorted right half
                left = mid + 1
        else:
            # Right half [mid...right] is sorted
            # Check if target is in this sorted range
            if nums[mid] < target <= nums[right]:
                # Target is in sorted right half
                left = mid + 1
            else:
                # Target is in unsorted left half
                right = mid - 1
    
    return -1  # Target not found


# Visual trace function
def search_with_trace(nums, target):
    """Search with step-by-step visualization."""
    print(f"Array: {nums}")
    print(f"Target: {target}\n")
    
    left, right = 0, len(nums) - 1
    iteration = 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        print(f"Iteration {iteration}:")
        print(f"  Range: [{left}:{right}] ‚Üí {nums[left:right+1]}")
        print(f"  Mid index: {mid}, value: {nums[mid]}")
        
        if nums[mid] == target:
            print(f"  ‚úÖ Found target at index {mid}!\n")
            return mid
        
        # Check which half is sorted
        if nums[left] <= nums[mid]:
            print(f"  Left half sorted: {nums[left:mid+1]}")
            if nums[left] <= target < nums[mid]:
                print(f"  Target {target} in left sorted range")
                right = mid - 1
            else:
                print(f"  Target {target} in right half")
                left = mid + 1
        else:
            print(f"  Right half sorted: {nums[mid:right+1]}")
            if nums[mid] < target <= nums[right]:
                print(f"  Target {target} in right sorted range")
                left = mid + 1
            else:
                print(f"  Target {target} in left half")
                right = mid - 1
        
        print()
        iteration += 1
    
    print("  ‚ùå Target not found\n")
    return -1


# Test cases
test_cases = [
    ([4, 5, 6, 7, 0, 1, 2], 0),
    ([4, 5, 6, 7, 0, 1, 2], 3),
    ([1], 0),
]

for nums, target in test_cases:
    search_with_trace(nums, target)
```

### Example Output:
```
Array: [4, 5, 6, 7, 0, 1, 2]
Target: 0

Iteration 1:
  Range: [0:6] ‚Üí [4, 5, 6, 7, 0, 1, 2]
  Mid index: 3, value: 7
  Left half sorted: [4, 5, 6, 7]
  Target 0 in right half

Iteration 2:
  Range: [4:6] ‚Üí [0, 1, 2]
  Mid index: 5, value: 1
  Right half sorted: [1, 2]
  Target 0 in left half

Iteration 3:
  Range: [4:4] ‚Üí [0]
  Mid index: 4, value: 0
  ‚úÖ Found target at index 4!
```

### Handling Duplicates (LeetCode 81)

**Problem:** What if array has duplicates?

**Issue:** When `nums[left] == nums[mid] == nums[right]`, we can't determine which half is sorted.

**Example:**
```
nums = [1, 0, 1, 1, 1], target = 0
         L     M     R
nums[L] = nums[M] = nums[R] = 1
Can't determine which half is sorted!
```

**Solution:** Skip duplicates from boundaries

```python
def search_rotated_with_duplicates(nums, target):
    """
    Search in rotated array with duplicates.
    
    Time: O(log n) average, O(n) worst case
    Space: O(1)
    """
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if nums[mid] == target:
            return True
        
        # Handle duplicates: can't determine which half is sorted
        if nums[left] == nums[mid] == nums[right]:
            # Skip duplicates from both ends
            left += 1
            right -= 1
        elif nums[left] <= nums[mid]:
            # Left half is sorted
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            # Right half is sorted
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return False


# Test with duplicates
print(search_rotated_with_duplicates([2, 5, 6, 0, 0, 1, 2], 0))  # True
print(search_rotated_with_duplicates([2, 5, 6, 0, 0, 1, 2], 3))  # False
```

---

## Find Minimum in Rotated Array

### Concept Overview

Find the minimum element in a rotated sorted array. This is essentially finding the **rotation pivot point**.

**Visual Understanding:**
```
Original: [0, 1, 2, 4, 5, 6, 7]
Rotated:  [4, 5, 6, 7, 0, 1, 2]
                      ‚Üë
                   minimum (pivot point)
```

### Key Insights

**Property 1:** The minimum element is the only element where `nums[i] < nums[i-1]`

**Property 2:** All elements to the left of minimum are greater than the rightmost element

```
[4, 5, 6, 7, 0, 1, 2]
 ‚Üë       ‚Üë  ‚Üë     ‚Üë
 >7      >7 min   <7

nums[i] > nums[-1] ‚Üí minimum is to the right
nums[i] ‚â§ nums[-1] ‚Üí minimum is here or to the left
```

### Algorithm Strategy

Compare `nums[mid]` with `nums[right]`:
- If `nums[mid] > nums[right]`: Minimum is in right half (exclude mid)
- If `nums[mid] ‚â§ nums[right]`: Minimum is in left half (include mid)

### Complete Implementation

```python
def find_min_rotated(nums):
    """
    Find minimum element in rotated sorted array.
    
    Time: O(log n)
    Space: O(1)
    
    Example:
    nums = [4, 5, 6, 7, 0, 1, 2]
    Output: 0
    """
    left, right = 0, len(nums) - 1
    
    # Edge case: array not rotated (already sorted)
    if nums[left] <= nums[right]:
        return nums[left]
    
    while left < right:
        mid = left + (right - left) // 2
        
        # Compare mid with right to determine which side has minimum
        if nums[mid] > nums[right]:
            # Minimum is in right half
            # Example: [4, 5, 6, 7, 0, 1, 2]
            #              L   M       R
            # nums[M]=6 > nums[R]=2, so min is to the right
            left = mid + 1
        else:
            # Minimum is in left half or at mid
            # Example: [6, 7, 0, 1, 2, 4, 5]
            #              L   M       R
            # nums[M]=1 < nums[R]=5, so min is at mid or left
            right = mid
    
    return nums[left]


# Visual trace
def find_min_with_trace(nums):
    """Find minimum with visualization."""
    print(f"Array: {nums}\n")
    
    left, right = 0, len(nums) - 1
    iteration = 1
    
    # Check if array is already sorted
    if nums[left] <= nums[right]:
        print("Array is not rotated (already sorted)")
        print(f"Minimum: {nums[left]}\n")
        return nums[left]
    
    while left < right:
        mid = left + (right - left) // 2
        
        print(f"Iteration {iteration}:")
        print(f"  Range: [{left}:{right}] ‚Üí {nums[left:right+1]}")
        print(f"  Mid: index {mid}, value {nums[mid]}")
        print(f"  Right: index {right}, value {nums[right]}")
        
        if nums[mid] > nums[right]:
            print(f"  {nums[mid]} > {nums[right]} ‚Üí search right half")
            left = mid + 1
        else:
            print(f"  {nums[mid]} ‚â§ {nums[right]} ‚Üí search left half (include mid)")
            right = mid
        
        print()
        iteration += 1
    
    print(f"‚úÖ Minimum found: {nums[left]} at index {left}\n")
    return nums[left]


# Test cases
test_arrays = [
    [4, 5, 6, 7, 0, 1, 2],
    [3, 4, 5, 1, 2],
    [11, 13, 15, 17],  # Not rotated
]

for arr in test_arrays:
    find_min_with_trace(arr)
```

### Handling Duplicates

```python
def find_min_with_duplicates(nums):
    """
    Find minimum in rotated array with duplicates.
    
    Time: O(log n) average, O(n) worst case
    Space: O(1)
    """
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = left + (right - left) // 2
        
        if nums[mid] > nums[right]:
            # Minimum in right half
            left = mid + 1
        elif nums[mid] < nums[right]:
            # Minimum in left half or at mid
            right = mid
        else:
            # nums[mid] == nums[right]
            # Can't determine, reduce search space
            # Example: [2, 2, 2, 0, 2, 2]
            right -= 1
    
    return nums[left]


print(find_min_with_duplicates([2, 2, 2, 0, 1]))  # Output: 0
```

---

## Find Peak Element

### Concept Overview

A **peak element** is an element that is greater than its neighbors.

**Definitions:**
- Peak: `nums[i] > nums[i-1]` AND `nums[i] > nums[i+1]`
- For edge elements: only one neighbor to compare

**Visual Examples:**
```
Example 1: [1, 2, 3, 1]
              ‚Üë peak at index 2

Example 2: [1, 2, 1, 3, 5, 6, 4]
              ‚Üë peak      ‚Üë peak
           (index 1 or 5, either is valid)
```

### Key Insights

**Critical Property:** If we're at position `mid`:
- If `nums[mid] < nums[mid+1]`: There MUST be a peak to the right
- If `nums[mid] > nums[mid+1]`: There MUST be a peak to the left (or at mid)

**Why this works:**
```
Case 1: nums[mid] < nums[mid+1]
  [... mid, mid+1 ...]
       ‚Üì    ‚Üë
  Going upward! Peak must be ahead
  - Either continues going up to a peak
  - Or goes down later (mid+1 is the peak)

Case 2: nums[mid] > nums[mid+1]
  [... mid, mid+1 ...]
       ‚Üë    ‚Üì
  Going downward! Peak must be behind or here
  - mid might be the peak
  - Or there's a higher peak to the left
```

### Algorithm Strategy

Always move towards the **higher neighboring element**. A peak is guaranteed in that direction.

### Complete Implementation

```python
def find_peak_element(nums):
    """
    Find a peak element and return its index.
    
    Time: O(log n)
    Space: O(1)
    
    Note: Multiple peaks may exist, any one is acceptable.
    
    Example:
    nums = [1, 2, 3, 1]
    Output: 2 (element 3 is a peak)
    """
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = left + (right - left) // 2
        
        # Compare with right neighbor
        if nums[mid] < nums[mid + 1]:
            # Going upward, peak is to the right
            left = mid + 1
        else:
            # Going downward, peak is at mid or to the left
            right = mid
    
    # left == right, this is a peak
    return left


# Detailed visualization
def find_peak_with_visualization(nums):
    """Find peak with step-by-step visualization."""
    print(f"Array: {nums}")
    
    # Visual representation
    print("\nVisual (approximate):")
    for i, val in enumerate(nums):
        print(f"  {i}: " + "‚ñà" * val + f" ({val})")
    
    print("\nSearch process:")
    
    left, right = 0, len(nums) - 1
    iteration = 1
    
    while left < right:
        mid = left + (right - left) // 2
        
        print(f"\nIteration {iteration}:")
        print(f"  Range: [{left}:{right}]")
        print(f"  Mid: index {mid}, value {nums[mid]}")
        print(f"  Next: index {mid+1}, value {nums[mid+1]}")
        
        if nums[mid] < nums[mid + 1]:
            print(f"  {nums[mid]} < {nums[mid+1]} ‚Üí Going up, search right")
            left = mid + 1
        else:
            print(f"  {nums[mid]} ‚â• {nums[mid+1]} ‚Üí Going down, search left")
            right = mid
        
        iteration += 1
    
    print(f"\n‚úÖ Peak found at index {left}: value = {nums[left]}")
    
    # Verify it's a peak
    is_peak = True
    if left > 0 and nums[left] <= nums[left-1]:
        is_peak = False
    if left < len(nums)-1 and nums[left] <= nums[left+1]:
        is_peak = False
    
    print(f"   Verification: {'‚úÖ Valid peak' if is_peak else '‚ùå Not a peak'}\n")
    return left


# Test cases
test_arrays = [
    [1, 2, 3, 1],
    [1, 2, 1, 3, 5, 6, 4],
    [1, 2, 3, 4, 5],  # Monotonically increasing
    [5, 4, 3, 2, 1],  # Monotonically decreasing
]

for arr in test_arrays:
    find_peak_with_visualization(arr)
```

### Finding All Peaks (Bonus)

```python
def find_all_peaks(nums):
    """
    Find all peak elements in the array.
    
    Time: O(n) - must check all elements
    Space: O(k) where k is number of peaks
    """
    if len(nums) < 1:
        return []
    
    peaks = []
    
    # Check first element
    if len(nums) == 1 or nums[0] > nums[1]:
        peaks.append(0)
    
    # Check middle elements
    for i in range(1, len(nums) - 1):
        if nums[i] > nums[i-1] and nums[i] > nums[i+1]:
            peaks.append(i)
    
    # Check last element
    if len(nums) > 1 and nums[-1] > nums[-2]:
        peaks.append(len(nums) - 1)
    
    return peaks


# Example
nums = [1, 2, 1, 3, 5, 6, 4]
peaks = find_all_peaks(nums)
print(f"Array: {nums}")
print(f"All peaks at indices: {peaks}")
print(f"Peak values: {[nums[i] for i in peaks]}")
# Output: All peaks at indices: [1, 5]
#         Peak values: [2, 6]
```

---

## Search in 2D Matrix

### Two Variations

#### Variation 1: Treat as 1D Sorted Array (LeetCode 74)

**Properties:**
- Each row is sorted left to right
- First element of each row > last element of previous row
- Essentially a **sorted 1D array** wrapped into 2D

**Example:**
```
matrix = [
  [1,  3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 60]
]

Flattened: [1, 3, 5, 7, 10, 11, 16, 20, 23, 30, 34, 60]
```

**Strategy:** Convert 2D coordinates to 1D index

```python
def search_matrix_as_1d(matrix, target):
    """
    Search in matrix that can be treated as 1D sorted array.
    
    Time: O(log(m√ón))
    Space: O(1)
    """
    if not matrix or not matrix[0]:
        return False
    
    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, rows * cols - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        # Convert 1D index to 2D coordinates
        row = mid // cols
        col = mid % cols
        mid_value = matrix[row][col]
        
        if mid_value == target:
            return True
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return False


# Example with coordinates
def search_matrix_with_coords(matrix, target):
    """Search with coordinate tracking."""
    if not matrix or not matrix[0]:
        return False
    
    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, rows * cols - 1
    
    print(f"Matrix:")
    for row in matrix:
        print(f"  {row}")
    print(f"\nSearching for: {target}\n")
    
    iteration = 1
    while left <= right:
        mid = left + (right - left) // 2
        row = mid // cols
        col = mid % cols
        mid_value = matrix[row][col]
        
        print(f"Iteration {iteration}:")
        print(f"  1D range: [{left}, {right}]")
        print(f"  Mid 1D index: {mid}")
        print(f"  2D coordinates: ({row}, {col})")
        print(f"  Value: {mid_value}")
        
        if mid_value == target:
            print(f"  ‚úÖ Found at ({row}, {col})!\n")
            return True
        elif mid_value < target:
            print(f"  {mid_value} < {target}, search right")
            left = mid + 1
        else:
            print(f"  {mid_value} > {target}, search left")
            right = mid - 1
        
        print()
        iteration += 1
    
    print("  ‚ùå Not found\n")
    return False


# Test
matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]
search_matrix_with_coords(matrix, 3)
```

#### Variation 2: Rows and Columns Sorted (LeetCode 240)

**Properties:**
- Each row is sorted left to right
- Each column is sorted top to bottom
- BUT: First element of row may be < last element of previous row

**Example:**
```
matrix = [
  [1,  4,  7,  11, 15],
  [2,  5,  8,  12, 19],
  [3,  6,  9,  16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

target = 5 ‚Üí True (at row 1, col 1)
```

**Strategy:** Start from **top-right** or **bottom-left** corner

**Why top-right works:**
```
Start at top-right (value = 15)
  ‚Üê All values to LEFT are SMALLER
  ‚Üì All values BELOW are LARGER

If target < current: move LEFT
If target > current: move DOWN
If target == current: FOUND!
```

```python
def search_matrix_2d(matrix, target):
    """
    Search in matrix where rows and columns are sorted.
    
    Time: O(m + n) where m=rows, n=cols
    Space: O(1)
    
    Strategy: Start from top-right corner
    """
    if not matrix or not matrix[0]:
        return False
    
    rows, cols = len(matrix), len(matrix[0])
    row, col = 0, cols - 1  # Start at top-right
    
    while row < rows and col >= 0:
        current = matrix[row][col]
        
        if current == target:
            return True
        elif current > target:
            # Target is smaller, move left
            col -= 1
        else:
            # Target is larger, move down
            row += 1
    
    return False


# Visualization
def search_matrix_2d_visual(matrix, target):
    """Search with path visualization."""
    if not matrix or not matrix[0]:
        return False
    
    print(f"Matrix:")
    for i, row in enumerate(matrix):
        print(f"  Row {i}: {row}")
    print(f"\nTarget: {target}")
    print(f"Starting at: top-right corner\n")
    
    rows, cols = len(matrix), len(matrix[0])
    row, col = 0, cols - 1
    path = []
    
    while row < rows and col >= 0:
        current = matrix[row][col]
        path.append((row, col, current))
        
        print(f"Position ({row}, {col}): value = {current}")
        
        if current == target:
            print(f"  ‚úÖ Found target!\n")
            print_path(matrix, path)
            return True
        elif current > target:
            print(f"  {current} > {target}, move LEFT")
            col -= 1
        else:
            print(f"  {current} < {target}, move DOWN")
            row += 1
        print()
    
    print("  ‚ùå Not found\n")
    print_path(matrix, path)
    return False


def print_path(matrix, path):
    """Visualize the search path."""
    print("Search path:")
    rows, cols = len(matrix), len(matrix[0])
    
    # Create visualization grid
    grid = [[' . ' for _ in range(cols)] for _ in range(rows)]
    
    for i, (r, c, val) in enumerate(path):
        grid[r][c] = f'{val:2d}*'
    
    for row in grid:
        print('  ' + ' '.join(row))
    print()


# Test
matrix = [
    [1,  4,  7,  11, 15],
    [2,  5,  8,  12, 19],
    [3,  6,  9,  16, 22],
    [10, 13, 14, 17, 24],
    [18, 21, 23, 26, 30]
]
search_matrix_2d_visual(matrix, 5)
```

---

## Median of Two Sorted Arrays

### Problem Overview

Find the median of two sorted arrays. The overall run time complexity should be O(log(min(m,n))).

**What is a Median?**
```
Odd length:  [1, 2, 3, 4, 5] ‚Üí median = 3 (middle element)
Even length: [1, 2, 3, 4] ‚Üí median = (2 + 3) / 2 = 2.5 (average of two middle)
```

### Key Insight: Partitioning

The core idea is to **partition** both arrays such that:
1. Left side has same number of elements as right side (or one more)
2. All elements in left ‚â§ all elements in right

**Visual:**
```
nums1: [1, 3, 8, 9, 15]
              ‚Üë partition
       [1, 3] | [8, 9, 15]

nums2: [7, 11, 18, 19, 21, 25]
                ‚Üë partition
       [7, 11, 18, 19] | [21, 25]

Combined left: [1, 3, 7, 11, 18, 19]  (6 elements)
Combined right: [8, 9, 15, 21, 25]     (5 elements)

For median:
- maxLeft = max(3, 19) = 19
- minRight = min(8, 21) = 8
- Since maxLeft ‚â§ minRight ‚ùå not valid!
```

### The Algorithm

**Binary search on the smaller array's partition:**
1. Try partition in nums1
2. Calculate corresponding partition in nums2
3. Check if partition is valid
4. Adjust binary search based on validation

**Valid Partition Conditions:**
```
maxLeft1 ‚â§ minRight2  AND  maxLeft2 ‚â§ minRight1

Where:
- maxLeft1: largest element in left partition of nums1
- minRight1: smallest element in right partition of nums1
- maxLeft2: largest element in left partition of nums2
- minRight2: smallest element in right partition of nums2
```

### Complete Implementation with Detailed Comments

```python
def find_median_sorted_arrays(nums1, nums2):
    """
    Find median of two sorted arrays.
    
    Time: O(log(min(m,n)))
    Space: O(1)
    
    Example:
    nums1 = [1, 3], nums2 = [2]
    Output: 2.0
    
    nums1 = [1, 2], nums2 = [3, 4]
    Output: 2.5
    """
    # Ensure nums1 is the smaller array
    # This guarantees O(log(min(m,n)))
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1
    
    m, n = len(nums1), len(nums2))
    
    # Binary search on nums1
    left, right = 0, m
    
    while left <= right:
        # Partition nums1
        partition1 = (left + right) // 2
        
        # Calculate partition for nums2
        # Total elements in left half should be (m+n+1)//2
        partition2 = (m + n + 1) // 2 - partition1
        
        # Get the four critical values
        # Handle edge cases: partition at boundaries
        maxLeft1 = float('-inf') if partition1 == 0 else nums1[partition1 - 1]
        minRight1 = float('inf') if partition1 == m else nums1[partition1]
        
        maxLeft2 = float('-inf') if partition2 == 0 else nums2[partition2 - 1]
        minRight2 = float('inf') if partition2 == n else nums2[partition2]
        
        # Check if we found the correct partition
        if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:
            # Correct partition found!
            
            # Calculate median based on odd/even total length
            if (m + n) % 2 == 0:
                # Even: average of two middle elements
                return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2.0
            else:
                # Odd: the larger of two maxLeft values
                return float(max(maxLeft1, maxLeft2))
        
        elif maxLeft1 > minRight2:
            # nums1 partition too far right, move left
            right = partition1 - 1
        else:
            # nums1 partition too far left, move right
            left = partition1 + 1
    
    # Should never reach here if inputs are valid
    raise ValueError("Input arrays are not sorted")


# Detailed trace function
def find_median_with_trace(nums1, nums2):
    """Find median with detailed trace."""
    print(f"nums1: {nums1}")
    print(f"nums2: {nums2}")
    print(f"Total elements: {len(nums1) + len(nums2)}\n")
    
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1
        print("Swapped to ensure nums1 is smaller\n")
    
    m, n = len(nums1), len(nums2)
    left, right = 0, m
    iteration = 1
    
    while left <= right:
        partition1 = (left + right) // 2
        partition2 = (m + n + 1) // 2 - partition1
        
        print(f"Iteration {iteration}:")
        print(f"  Binary search range in nums1: [{left}, {right}]")
        print(f"  Partition nums1 at index: {partition1}")
        print(f"  Partition nums2 at index: {partition2}")
        
        # Visualize partitions
        if partition1 > 0:
            print(f"  nums1 left: {nums1[:partition1]}")
        else:
            print(f"  nums1 left: []")
        
        if partition1 < m:
            print(f"  nums1 right: {nums1[partition1:]}")
        else:
            print(f"  nums1 right: []")
        
        if partition2 > 0:
            print(f"  nums2 left: {nums2[:partition2]}")
        else:
            print(f"  nums2 left: []")
        
        if partition2 < n:
            print(f"  nums2 right: {nums2[partition2:]}")
        else:
            print(f"  nums2 right: []")
        
        # Get critical values
        maxLeft1 = float('-inf') if partition1 == 0 else nums1[partition1 - 1]
        minRight1 = float('inf') if partition1 == m else nums1[partition1]
        maxLeft2 = float('-inf') if partition2 == 0 else nums2[partition2 - 1]
        minRight2 = float('inf') if partition2 == n else nums2[partition2]
        
        print(f"  maxLeft1: {maxLeft1}, minRight1: {minRight1}")
        print(f"  maxLeft2: {maxLeft2}, minRight2: {minRight2}")
        
        # Check validity
        if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:
            print(f"  ‚úÖ Valid partition found!")
            
            if (m + n) % 2 == 0:
                median = (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2.0
                print(f"  Even total: median = ({max(maxLeft1, maxLeft2)} + {min(minRight1, minRight2)}) / 2 = {median}")
            else:
                median = max(maxLeft1, maxLeft2)
                print(f"  Odd total: median = {median}")
            
            print()
            return median
        elif maxLeft1 > minRight2:
            print(f"  ‚ùå maxLeft1 ({maxLeft1}) > minRight2 ({minRight2})")
            print(f"  nums1 partition too far right, search left")
            right = partition1 - 1
        else:
            print(f"  ‚ùå maxLeft2 ({maxLeft2}) > minRight1 ({minRight1})")
            print(f"  nums1 partition too far left, search right")
            left = partition1 + 1
        
        print()
        iteration += 1


# Test cases
test_cases = [
    ([1, 3], [2]),
    ([1, 2], [3, 4]),
    ([0, 0], [0, 0]),
    ([], [1]),
]

for nums1, nums2 in test_cases:
    find_median_with_trace(nums1, nums2)
```

### Why This Works - Intuitive Explanation

**Think of it as a seesaw:**
```
Left side      |      Right side
(smaller half) | (larger half)

We want:
1. Both sides balanced (equal elements)
2. max(left) ‚â§ min(right)
```

**Binary search finds the balance point:**
- Too much from nums1 on left? Move partition left
- Too little from nums1 on left? Move partition right

---

## Summary: Advanced Patterns

### Quick Reference

| Pattern | Key Idea | Time | When to Use |
|---------|----------|------|-------------|
| **Rotated Array** | One half always sorted | O(log n) | Array rotated at unknown pivot |
| **Find Minimum** | Compare mid with right | O(log n) | Find pivot in rotated array |
| **Peak Element** | Move toward higher value | O(log n) | Find local maximum |
| **2D Matrix (1D)** | Convert coordinates | O(log(m√ón)) | Matrix is fully sorted |
| **2D Matrix (Corner)** | Start from corner | O(m+n) | Rows & columns sorted |
| **Median Two Arrays** | Partition with binary search | O(log(min(m,n))) | Two sorted arrays |

### Practice Tips

1. **Draw diagrams** - Visualize the array state
2. **Identify the invariant** - What property is maintained?
3. **Test edge cases** - Empty, single element, duplicates
4. **Trace manually** - Walk through with pen and paper
5. **Understand the "why"** - Don't memorize, understand the logic

These advanced patterns unlock the hardest binary search problems! üöÄ