# Chapter 3: Binary Search Variants - In-Depth Guide

## Table of Contents
1. [Overview of Variants](#overview-of-variants)
2. [Find First Occurrence (Left Boundary)](#find-first-occurrence-left-boundary)
3. [Find Last Occurrence (Right Boundary)](#find-last-occurrence-right-boundary)
4. [Find Insert Position (Lower Bound)](#find-insert-position-lower-bound)
5. [Upper Bound](#upper-bound)
6. [Count Occurrences](#count-occurrences)
7. [Comparison and Pattern Recognition](#comparison-and-pattern-recognition)

---

## 1. Overview of Variants

### 1.1 Why Do We Need Variants?

The classic binary search answers: **"Is this element in the array?"**

But real-world problems often ask:
- **First occurrence**: "Where does this value *first* appear?" (for duplicates)
- **Last occurrence**: "Where does this value *last* appear?"
- **Insert position**: "Where *should* this value be inserted?"
- **Range queries**: "How many times does this value appear?"

```python
def demonstrate_variant_needs():
    """
    Show why we need different binary search variants.
    """
    arr = [1, 2, 2, 2, 2, 3, 4, 5]
    target = 2
    
    print("Array with duplicates:", arr)
    print(f"Target: {target}\n")
    
    # Classic binary search - returns ANY occurrence
    def classic_search(arr, target):
        left, right = 0, len(arr) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if arr[mid] == target:
                return mid  # Could be any index with value 2!
            elif arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1
    
    result = classic_search(arr, target)
    print(f"Classic search: Found at index {result}")
    print(f"  But which occurrence is this? We don't know!")
    print(f"  Actual occurrences: indices 1, 2, 3, 4")
    
    print("\nWhat we really need:")
    print("  â“ First occurrence: index 1")
    print("  â“ Last occurrence: index 4")
    print("  â“ Count: 4 occurrences")
    print("  â“ Insert position for value 2: index 1")
    print("  â“ Insert position for value 2.5: index 5")
    print("\nâ†’ We need specialized variants!")

demonstrate_variant_needs()
```

### 1.2 Variant Comparison Table

```python
def show_variant_comparison():
    """
    Compare different variant behaviors.
    """
    arr = [1, 2, 2, 2, 2, 3, 4, 5]
    target = 2
    target_missing = 2.5
    
    print("="*80)
    print("BINARY SEARCH VARIANTS COMPARISON")
    print("="*80)
    print(f"\nArray: {arr}")
    print(f"Indices: {list(range(len(arr)))}\n")
    
    variants = [
        ("Classic Search", "Any occurrence", "index 2 or 3 (undefined)"),
        ("First Occurrence", "Leftmost occurrence", "index 1"),
        ("Last Occurrence", "Rightmost occurrence", "index 4"),
        ("Lower Bound", "First position â‰¥ target", "index 1"),
        ("Upper Bound", "First position > target", "index 5"),
    ]
    
    print(f"For target = {target}:")
    print("-" * 80)
    for name, description, result in variants:
        print(f"{name:20s} | {description:30s} | Result: {result}")
    
    print(f"\nFor target = {target_missing} (not in array):")
    print("-" * 80)
    print(f"{'Lower Bound':20s} | {'Insert position':30s} | Result: index 5")
    print(f"{'Upper Bound':20s} | {'Same as lower bound':30s} | Result: index 5")

show_variant_comparison()
```

---

## 2. Find First Occurrence (Left Boundary)

### 2.1 Concept and Visualization

**Goal**: Find the leftmost (first) occurrence of target in an array with duplicates.

**Key Insight**: When we find the target, don't stop! Continue searching left to see if there's an earlier occurrence.

```python
def visualize_first_occurrence():
    """
    Visual demonstration of finding first occurrence.
    """
    arr = [1, 2, 2, 2, 2, 3, 4, 5]
    target = 2
    
    print("="*80)
    print("FINDING FIRST OCCURRENCE - VISUALIZATION")
    print("="*80)
    print(f"\nArray: {arr}")
    print(f"Target: {target}")
    print(f"All occurrences at indices: 1, 2, 3, 4")
    print(f"Goal: Find index 1 (first occurrence)\n")
    
    left, right = 0, len(arr) - 1
    result = -1
    step = 0
    
    while left <= right:
        step += 1
        mid = left + (right - left) // 2
        
        # Visual representation
        visual = [' ' for _ in range(len(arr))]
        for i in range(left, right + 1):
            visual[i] = 'â”€'
        visual[mid] = 'M'
        visual[left] = 'L'
        visual[right] = 'R'
        
        print(f"Step {step}:")
        print(f"  Values:  {arr}")
        print(f"  Search:  {visual}")
        print(f"  Check arr[{mid}] = {arr[mid]}")
        
        if arr[mid] == target:
            print(f"  âœ“ Found target at {mid}!")
            print(f"  ðŸ’¡ But continue searching LEFT for earlier occurrence")
            result = mid  # Save this position
            right = mid - 1  # Keep searching left
        elif arr[mid] < target:
            print(f"  arr[{mid}] < target, search right")
            left = mid + 1
        else:
            print(f"  arr[{mid}] > target, search left")
            right = mid - 1
        
        if result != -1:
            print(f"  Current best result: index {result}")
        print()
    
    print(f"Final result: First occurrence at index {result}")

visualize_first_occurrence()
```

### 2.2 Implementation and Detailed Walkthrough

```python
def find_first_occurrence(arr, target):
    """
    Find the first (leftmost) occurrence of target.
    
    Pattern: When found, save result and continue searching LEFT.
    
    Args:
        arr: Sorted array (may contain duplicates)
        target: Value to find
    
    Returns:
        Index of first occurrence, or -1 if not found
    
    Time: O(log n)
    Space: O(1)
    """
    left, right = 0, len(arr) - 1
    result = -1  # Store the best result found so far
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            # Found it! But there might be earlier occurrences
            result = mid          # Save this position
            right = mid - 1       # Continue searching left
            
        elif arr[mid] < target:
            left = mid + 1        # Target is in right half
        else:
            right = mid - 1       # Target is in left half
    
    return result

# Comprehensive testing
def test_first_occurrence():
    """Test cases for first occurrence."""
    print("\n" + "="*80)
    print("TESTING FIRST OCCURRENCE")
    print("="*80 + "\n")
    
    test_cases = [
        ([1, 2, 2, 2, 2, 3, 4, 5], 2, 1, "Multiple duplicates in middle"),
        ([2, 2, 2, 3, 4, 5], 2, 0, "Duplicates at start"),
        ([1, 2, 3, 4, 5, 5, 5], 5, 4, "Duplicates at end"),
        ([1, 2, 3, 4, 5], 3, 2, "No duplicates"),
        ([1, 2, 3, 4, 5], 0, -1, "Target not in array"),
        ([5, 5, 5, 5, 5], 5, 0, "All same value"),
        ([1], 1, 0, "Single element - found"),
        ([1], 2, -1, "Single element - not found"),
    ]
    
    for arr, target, expected, description in test_cases:
        result = find_first_occurrence(arr, target)
        status = "âœ“" if result == expected else "âœ—"
        print(f"{status} {description}")
        print(f"  Array: {arr}")
        print(f"  Target: {target}")
        print(f"  Expected: {expected}, Got: {result}")
        if result != -1:
            print(f"  Value at result: arr[{result}] = {arr[result]}")
        print()

test_first_occurrence()
```

### 2.3 Step-by-Step Trace

```python
def trace_first_occurrence():
    """
    Detailed trace of algorithm execution.
    """
    arr = [1, 2, 2, 2, 2, 3, 4, 5]
    target = 2
    
    print("\n" + "="*80)
    print("STEP-BY-STEP TRACE: FIRST OCCURRENCE")
    print("="*80 + "\n")
    
    left, right = 0, len(arr) - 1
    result = -1
    step = 0
    
    print(f"Initial state:")
    print(f"  left={left}, right={right}, result={result}")
    print(f"  Search space: {arr[left:right+1]}")
    print()
    
    while left <= right:
        step += 1
        mid = left + (right - left) // 2
        
        print(f"â”â”â” Step {step} â”â”â”")
        print(f"left={left}, right={right}, mid={mid}")
        print(f"arr[mid]={arr[mid]}, target={target}")
        
        if arr[mid] == target:
            print(f"âœ“ arr[mid] == target")
            print(f"  Action: Save mid={mid} as result")
            print(f"  Then: Continue searching left (right = mid - 1 = {mid - 1})")
            result = mid
            right = mid - 1
            
        elif arr[mid] < target:
            print(f"arr[mid] < target")
            print(f"  Action: Search right half (left = mid + 1 = {mid + 1})")
            left = mid + 1
        else:
            print(f"arr[mid] > target")
            print(f"  Action: Search left half (right = mid - 1 = {mid - 1})")
            right = mid - 1
        
        print(f"After step: left={left}, right={right}, result={result}")
        if result != -1:
            print(f"Current best: arr[{result}] = {arr[result]}")
        print()
    
    print(f"Final result: First occurrence at index {result}")
    print(f"Verification: arr[{result}] = {arr[result]}")

trace_first_occurrence()
```

---

## 3. Find Last Occurrence (Right Boundary)

### 3.1 Concept and Implementation

**Goal**: Find the rightmost (last) occurrence of target.

**Key Insight**: Mirror of first occurrence - when found, continue searching RIGHT.

```python
def find_last_occurrence(arr, target):
    """
    Find the last (rightmost) occurrence of target.
    
    Pattern: When found, save result and continue searching RIGHT.
    
    Time: O(log n)
    Space: O(1)
    """
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            result = mid          # Save this position
            left = mid + 1        # Continue searching RIGHT (opposite of first)
            
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result

# Visual demonstration
def visualize_last_occurrence():
    """
    Visual demonstration of finding last occurrence.
    """
    arr = [1, 2, 2, 2, 2, 3, 4, 5]
    target = 2
    
    print("\n" + "="*80)
    print("FINDING LAST OCCURRENCE - VISUALIZATION")
    print("="*80)
    print(f"\nArray: {arr}")
    print(f"Target: {target}\n")
    
    left, right = 0, len(arr) - 1
    result = -1
    step = 0
    
    while left <= right:
        step += 1
        mid = left + (right - left) // 2
        
        print(f"Step {step}: Check arr[{mid}] = {arr[mid]}")
        
        if arr[mid] == target:
            print(f"  âœ“ Found! But continue searching RIGHT")
            result = mid
            left = mid + 1  # Search right
        elif arr[mid] < target:
            print(f"  Search right")
            left = mid + 1
        else:
            print(f"  Search left")
            right = mid - 1
        
        if result != -1:
            print(f"  Current best: index {result}")
        print()
    
    print(f"Final: Last occurrence at index {result}")

visualize_last_occurrence()
```

### 3.2 First vs Last: Side-by-Side Comparison

```python
def compare_first_vs_last():
    """
    Compare first and last occurrence algorithms side by side.
    """
    print("\n" + "="*80)
    print("FIRST vs LAST OCCURRENCE - SIDE BY SIDE")
    print("="*80 + "\n")
    
    print("FIRST OCCURRENCE          â”‚  LAST OCCURRENCE")
    print("â”€"*80)
    print("When found:               â”‚  When found:")
    print("  result = mid            â”‚    result = mid")
    print("  right = mid - 1   â†LEFT â”‚    left = mid + 1   RIGHTâ†’")
    print("                          â”‚")
    print("Continue searching LEFT   â”‚  Continue searching RIGHT")
    print()
    
    # Code comparison
    arr = [1, 2, 2, 2, 2, 3, 4, 5]
    target = 2
    
    print(f"Testing with array: {arr}, target: {target}")
    print()
    
    first = find_first_occurrence(arr, target)
    last = find_last_occurrence(arr, target)
    
    print(f"First occurrence: index {first} â†’ arr[{first}] = {arr[first]}")
    print(f"Last occurrence:  index {last} â†’ arr[{last}] = {arr[last]}")
    print(f"Range of occurrences: [{first}, {last}]")
    print(f"Total count: {last - first + 1}")

compare_first_vs_last()
```

---

## 4. Find Insert Position (Lower Bound)

### 4.1 Concept and Visualization

**Goal**: Find the index where target should be inserted to maintain sorted order.

**Lower Bound Definition**: First index i where arr[i] >= target

```python
def visualize_insert_position():
    """
    Visualize finding insert position.
    """
    arr = [1, 3, 5, 7, 9, 11, 13]
    test_values = [0, 2, 6, 10, 15]
    
    print("="*80)
    print("FINDING INSERT POSITION (LOWER BOUND)")
    print("="*80 + "\n")
    
    print(f"Original array: {arr}")
    print(f"Indices:        {list(range(len(arr)))}\n")
    
    for target in test_values:
        print(f"Insert {target}:")
        
        # Find position
        left, right = 0, len(arr)
        while left < right:
            mid = left + (right - left) // 2
            if arr[mid] < target:
                left = mid + 1
            else:
                right = mid
        
        # Show insertion
        new_arr = arr[:left] + [target] + arr[left:]
        visual = [' '] * len(new_arr)
        visual[left] = 'â†‘'
        
        print(f"  Position: index {left}")
        print(f"  Result:   {new_arr}")
        print(f"  Marker:   {visual}")
        print()

visualize_insert_position()
```

### 4.2 Implementation with Critical Details

```python
def find_insert_position(arr, target):
    """
    Find the index where target should be inserted (lower bound).
    
    CRITICAL DIFFERENCES from exact search:
    1. Use 'left < right' (not <=)
    2. Initialize right = len(arr) (not len(arr) - 1)
    3. Return left at the end
    4. Update: right = mid (not mid - 1)
    
    Returns: Index where target should be inserted
    
    Time: O(log n)
    Space: O(1)
    """
    left, right = 0, len(arr)  # âš ï¸ right = len(arr), not len(arr) - 1
    
    while left < right:  # âš ï¸ Use <, not <=
        mid = left + (right - left) // 2
        
        if arr[mid] < target:
            left = mid + 1      # Target should be after mid
        else:
            right = mid         # âš ï¸ right = mid, not mid - 1
    
    return left  # âš ï¸ Return left (which equals right)

# Detailed explanation of differences
def explain_insert_position_differences():
    """
    Explain why insert position uses different template.
    """
    print("\n" + "="*80)
    print("WHY INSERT POSITION IS DIFFERENT")
    print("="*80 + "\n")
    
    print("1. WHY 'left < right' instead of 'left <= right'?")
    print("   â€¢ We want left and right to converge to same point")
    print("   â€¢ That point is the insert position")
    print("   â€¢ left == right is our termination condition")
    print()
    
    print("2. WHY 'right = len(arr)' instead of 'len(arr) - 1'?")
    print("   â€¢ Target might need to be inserted AFTER last element")
    print("   â€¢ Need position len(arr) to represent 'append to end'")
    print()
    
    print("3. WHY 'right = mid' instead of 'right = mid - 1'?")
    print("   â€¢ mid could be the insert position itself")
    print("   â€¢ Don't want to exclude it from search space")
    print()
    
    # Demonstration
    arr = [1, 3, 5, 7, 9]
    
    print("Example: Insert 10 into [1, 3, 5, 7, 9]")
    print("  â€¢ 10 > all elements")
    print("  â€¢ Must insert at index 5 (after last element)")
    print("  â€¢ Only possible if right starts at len(arr) = 5")
    print()
    
    result = find_insert_position(arr, 10)
    print(f"Result: Insert at index {result}")
    print(f"New array: {arr[:result] + [10] + arr[result:]}")

explain_insert_position_differences()
```

### 4.3 Complete Test Suite

```python
def test_insert_position():
    """
    Comprehensive testing of insert position.
    """
    print("\n" + "="*80)
    print("TESTING INSERT POSITION")
    print("="*80 + "\n")
    
    arr = [1, 3, 5, 7, 9, 11, 13]
    
    test_cases = [
        (0, 0, "Before first element"),
        (2, 1, "Between 1 and 3"),
        (3, 1, "Exact match (insert before duplicate)"),
        (6, 3, "Between 5 and 7"),
        (10, 5, "Between 9 and 11"),
        (15, 7, "After last element"),
    ]
    
    print(f"Array: {arr}\n")
    
    for target, expected, description in test_cases:
        result = find_insert_position(arr, target)
        new_arr = arr[:result] + [target] + arr[result:]
        
        status = "âœ“" if result == expected else "âœ—"
        print(f"{status} {description}")
        print(f"  Target: {target}")
        print(f"  Insert at: index {result}")
        print(f"  Result: {new_arr}")
        print(f"  Still sorted: {new_arr == sorted(new_arr)} âœ“")
        print()

test_insert_position()
```

---

## 5. Upper Bound

### 5.1 Concept and Difference from Lower Bound

**Upper Bound Definition**: First index i where arr[i] > target (strictly greater)

```python
def upper_bound(arr, target):
    """
    Find the first index where arr[i] > target.
    
    DIFFERENCE from lower bound:
    â€¢ Lower bound: first index where arr[i] >= target
    â€¢ Upper bound: first index where arr[i] > target
    
    Only one character changes: < becomes <=
    
    Time: O(log n)
    Space: O(1)
    """
    left, right = 0, len(arr)
    
    while left < right:
        mid = left + (right - left) // 2
        
        if arr[mid] <= target:  # âš ï¸ <= instead of < (only change!)
            left = mid + 1
        else:
            right = mid
    
    return left

# Lower bound vs Upper bound comparison
def compare_bounds():
    """
    Compare lower bound and upper bound side by side.
    """
    print("\n" + "="*80)
    print("LOWER BOUND vs UPPER BOUND")
    print("="*80 + "\n")
    
    arr = [1, 2, 2, 2, 2, 3, 4, 5]
    target = 2
    
    print(f"Array:  {arr}")
    print(f"Target: {target}\n")
    
    # Lower bound
    lower = find_insert_position(arr, target)
    print(f"Lower Bound (first index where arr[i] >= {target}):")
    print(f"  Result: index {lower}")
    print(f"  Meaning: First occurrence of {target}")
    print(f"  Value: arr[{lower}] = {arr[lower]}")
    print()
    
    # Upper bound
    upper = upper_bound(arr, target)
    print(f"Upper Bound (first index where arr[i] > {target}):")
    print(f"  Result: index {upper}")
    print(f"  Meaning: Position after last occurrence of {target}")
    print(f"  Value: arr[{upper}] = {arr[upper]}")
    print()
    
    print(f"Range of {target}: [{lower}, {upper})")
    print(f"Count of {target}: {upper - lower}")
    
    # Visual comparison
    print("\nVISUAL REPRESENTATION:")
    print(f"Array:       {arr}")
    markers = [' '] * len(arr)
    markers[lower] = 'L'
    if upper < len(arr):
        markers[upper] = 'U'
    else:
        markers.append('U')
    print(f"Markers:     {markers}")
    print(f"             L = Lower bound")
    print(f"             U = Upper bound")

compare_bounds()
```

### 5.2 Use Cases for Bounds

```python
def demonstrate_bound_use_cases():
    """
    Show practical use cases for lower and upper bounds.
    """
    print("\n" + "="*80)
    print("PRACTICAL USE CASES FOR BOUNDS")
    print("="*80 + "\n")
    
    arr = [10, 20, 20, 20, 30, 40, 50, 60]
    
    print(f"Sorted array: {arr}\n")
    
    # Use case 1: Count occurrences
    print("Use Case 1: Count occurrences of 20")
    target = 20
    lower = find_insert_position(arr, target)
    upper = upper_bound(arr, target)
    count = upper - lower
    print(f"  Lower bound: {lower}")
    print(f"  Upper bound: {upper}")
    print(f"  Count: {count} occurrences")
    print()
    
    # Use case 2: Find range
    print("Use Case 2: Find all values in range [20, 40)")
    lower = find_insert_position(arr, 20)
    upper = upper_bound(arr, 40)
    range_values = arr[lower:upper]
    print(f"  Values: {range_values}")
    print()
    
    # Use case 3: Check if value exists
    print("Use Case 3: Check if 25 exists")
    target = 25
    lower = find_insert_position(arr, target)
    exists = lower < len(arr) and arr[lower] == target
    print(f"  Lower bound: {lower}")
    print(f"  Exists: {exists}")
    print()
    
    # Use case 4: Find closest values
    print("Use Case 4: Find values closest to 35")
    target = 35
    pos = find_insert_position(arr, target)
    before = arr[pos - 1] if pos > 0 else None
    after = arr[pos] if pos < len(arr) else None
    print(f"  Insert position: {pos}")
    print(f"  Value before: {before}")
    print(f"  Value after: {after}")

demonstrate_bound_use_cases()
```

---

## 6. Count Occurrences

### 6.1 Implementation Using First and Last

```python
def count_occurrences(arr, target):
    """
    Count occurrences of target using binary search.
    
    Method 1: Using first and last occurrence
    Time: O(log n) - two binary searches
    
    Alternative: Upper bound - Lower bound
    """
    first = find_first_occurrence(arr, target)
    
    if first == -1:  # Not found
        return 0
    
    last = find_last_occurrence(arr, target)
    return last - first + 1

def count_occurrences_bounds(arr, target):
    """
    Count occurrences using lower and upper bounds.
    
    Method 2: Upper bound - Lower bound
    Time: O(log n)
    """
    lower = find_insert_position(arr, target)
    upper = upper_bound(arr, target)
    return upper - lower

# Comprehensive demonstration
def demonstrate_count_methods():
    """
    Show both methods for counting occurrences.
    """
    print("\n" + "="*80)
    print("COUNTING OCCURRENCES - TWO METHODS")
    print("="*80 + "\n")
    
    arr = [1, 2, 2, 2, 2, 3, 3, 4, 5, 5, 5, 5]
    
    print(f"Array: {arr}\n")
    
    test_targets = [2, 3, 5, 6]
    
    for target in test_targets:
        # Method 1: First and Last
        first = find_first_occurrence(arr, target)
        last = find_last_occurrence(arr, target)
        count1 = 0 if first == -1 else last - first + 1
        
        # Method 2: Bounds
        count2 = count_occurrences_bounds(arr, target)
        
        print(f"Target: {target}")
        print(f"  Method 1 (First + Last):")
        if first != -1:
            print(f"    First: {first}, Last: {last}")
            print(f"    Count: {last} - {first} + 1 = {count1}")
        else:
            print(f"    Not found, Count: 0")
        
        print(f"  Method 2 (Bounds):")
        lower = find_insert_position(arr, target)
        upper = upper_bound(arr, target)
        print(f"    Lower bound: {lower}, Upper bound: {upper}")
        print(f"    Count: {upper} - {lower} = {count2}")
        
        print(f"  âœ“ Both methods agree: {count1} == {count2}")
        print()

demonstrate_count_methods()
```

---

## 7. Comparison and Pattern Recognition

### 7.1 Complete Comparison Table

```python
def create_comparison_table():
    """
    Create comprehensive comparison of all variants.
    """
    print("\n" + "="*80)
    print("BINARY SEARCH VARIANTS - COMPLETE COMPARISON")
    print("="*80 + "\n")
    
    variants = [
        {
            "name": "Classic Search",
            "goal": "Find exact value",
            "loop": "left <= right",
            "return": "mid or -1",
            "when_found": "return immediately",
            "use_case": "Single occurrence"
        },
        {
            "name": "First Occurrence",
            "goal": "Find leftmost match",
            "loop": "left <= right",
            "return": "result",
            "when_found": "right = mid - 1",
            "use_case": "Start of range"
        },
        {
            "name": "Last Occurrence",
            "goal": "Find rightmost match",
            "loop": "left <= right",
            "return": "result",
            "when_found": "left = mid + 1",
            "use_case": "End of range"
        },
        {
            "name": "Lower Bound",
            "goal": "First >= target",
            "loop": "left < right",
            "return": "left",
            "when_found": "N/A (no exact check)",
            "use_case": "Insert position"
        },
        {
            "name": "Upper Bound",
            "goal": "First > target",
            "loop": "left < right",
            "return": "left",
            "when_found": "N/A (no exact check)",
            "use_case": "After all matches"
        },
    ]
    
    for v in variants:
        print(f"{v['name']}")
        print(f"  Goal:       {v['goal']}")
        print(f"  Loop:       {v['loop']}")
        print(f"  Return:     {v['return']}")
        print(f"  When found: {v['when_found']}")
        print(f"  Use case:   {v['use_case']}")
        print()

create_comparison_table()
```

### 7.2 Pattern Recognition Guide

```python
def pattern_recognition_guide():
    """
    Help recognize which variant to use.
    """
    print("="*80)
    print("PATTERN RECOGNITION: WHICH VARIANT TO USE?")
    print("="*80 + "\n")
    
    patterns = [
        ("Find an element", "Classic Search"),
        ("Find first position of X", "First Occurrence"),
        ("Find last position of X", "Last Occurrence"),
        ("Count how many X", "First + Last OR Bounds"),
        ("Where to insert X", "Lower Bound"),
        ("Find range [X, Y)", "Lower(X) to Upper(Y)"),
        ("Check if X exists", "Lower Bound + check"),
        ("Find closest value", "Lower Bound + compare neighbors"),
    ]
    
    print("Problem Pattern â†’ Use This Variant")
    print("-" * 80)
    for pattern, variant in patterns:
        print(f"{pattern:40s} â†’ {variant}")
    print()
    
    # Example problems
    print("\nEXAMPLE PROBLEMS:\n")
    
    problems = [
        (
            "LeetCode 34: Find First and Last Position",
            "Use: First Occurrence + Last Occurrence"
        ),
        (
            "LeetCode 35: Search Insert Position",
            "Use: Lower Bound"
        ),
        (
            "Count elements in range [L, R]",
            "Use: Upper(R) - Lower(L)"
        ),
        (
            "Find k closest elements to X",
            "Use: Lower Bound to find starting position"
        ),
    ]
    
    for problem, solution in problems:
        print(f"â€¢ {problem}")
        print(f"  {solution}")
        print()

pattern_recognition_guide()
```

### 7.3 Unified Template System

```python
def show_unified_templates():
    """
    Show how all variants fit into template patterns.
    """
    print("\n" + "="*80)
    print("UNIFIED TEMPLATE SYSTEM")
    print("="*80 + "\n")
    
    print("TEMPLATE 1: Exact/Boundary Search (left <= right)")
    print("-" * 80)
    print("""
def variant(arr, target):
    left, right = 0, len(arr) - 1
    result = -1  # For boundary searches
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            # Classic: return mid
            # First: result = mid; right = mid - 1
            # Last:  result = mid; left = mid + 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result  # Or -1 for classic
    """)
    
    print("\nTEMPLATE 2: Bound Search (left < right)")
    print("-" * 80)
    print("""
def bound(arr, target):
    left, right = 0, len(arr)
    
    while left < right:
        mid = left + (right - left) // 2
        
        if arr[mid] < target:   # Lower bound
        # if arr[mid] <= target:  # Upper bound (only difference!)
            left = mid + 1
        else:
            right = mid
    
    return left
    """)

show_unified_templates()
```

---

## Summary: Quick Reference

### When to Use Each Variant

```python
def quick_reference():
    """
    Quick reference for all variants.
    """
    print("\n" + "="*80)
    print("QUICK REFERENCE CARD")
    print("="*80 + "\n")
    
    print("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
    print("â”‚ What You Need       â”‚ Use This Variant   â”‚ Key Pattern         â”‚")
    print("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")
    print("â”‚ Any occurrence      â”‚ Classic Search     â”‚ return mid          â”‚")
    print("â”‚ First occurrence    â”‚ First Occurrence   â”‚ right = mid - 1     â”‚")
    print("â”‚ Last occurrence     â”‚ Last Occurrence    â”‚ left = mid + 1      â”‚")
    print("â”‚ Insert position     â”‚ Lower Bound        â”‚ left < right        â”‚")
    print("â”‚ After all matches   â”‚ Upper Bound        â”‚ arr[mid] <= target  â”‚")
    print("â”‚ Count occurrences   â”‚ Last - First + 1   â”‚ Or upper - lower    â”‚")
    print("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
    print()
    
    print("LOOP CONDITIONS:")
    print("  â€¢ left <= right  â†’ For exact/boundary searches")
    print("  â€¢ left < right   â†’ For bound searches")
    print()
    
    print("INITIALIZATION:")
    print("  â€¢ right = len(arr) - 1  â†’ For exact/boundary")
    print("  â€¢ right = len(arr)      â†’ For bounds")
    print()
    
    print("COMPLEXITY:")
    print("  â€¢ All variants: O(log n) time, O(1) space")

quick_reference()
```

### Practice Checklist

âœ… **Master These Skills:**
- [ ] Implement all 5 variants from memory
- [ ] Know when to use `<=` vs `<`
- [ ] Understand why bounds use different template
- [ ] Can count occurrences in O(log n)
- [ ] Recognize which variant from problem description

**Next:** Chapter 4 introduces Binary Search on Answer Space - searching for optimal values rather than array indices!

---

*These variants are your binary search toolkit - master them all!* ðŸŽ¯