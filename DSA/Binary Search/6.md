# Chapter 6: Common Pitfalls & Edge Cases - In-Depth Guide

## Table of Contents
1. [Integer Overflow Issues](#integer-overflow-issues)
2. [Infinite Loop Traps](#infinite-loop-traps)
3. [Boundary Condition Errors](#boundary-condition-errors)
4. [Off-by-One Errors](#off-by-one-errors)
5. [Edge Cases Checklist](#edge-cases-checklist)
6. [Debugging Strategies](#debugging-strategies)

---

## Integer Overflow Issues

### The Problem

In many programming languages (C++, Java), adding two large integers can cause **overflow**.

**Example in Java:**
```java
int left = Integer.MAX_VALUE - 5;  // 2147483642
int right = Integer.MAX_VALUE;     // 2147483647
int mid = (left + right) / 2;      // OVERFLOW! Becomes negative
```

### Why It Happens

```
Mathematical Calculation:
left + right = 2147483642 + 2147483647 = 4294967289

But in 32-bit signed integer:
Maximum value: 2,147,483,647
Result wraps around to: -2,147,483,607 (negative!)
```

### The Solution

```python
# ‚ùå WRONG (can overflow in other languages)
mid = (left + right) // 2

# ‚úÖ CORRECT (prevents overflow)
mid = left + (right - left) // 2
```

### Mathematical Proof

Both formulas are equivalent:
```
mid = left + (right - left) // 2
mid = left + right // 2 - left // 2
mid = (left + right) // 2  ‚Üê Same result!

But the safe version never creates a large intermediate value.
```

### Python-Specific Note

**Good news:** Python has **arbitrary precision integers**, so overflow isn't an issue!

```python
# Python handles this fine
left = 10**100
right = 10**101
mid = (left + right) // 2  # No overflow!
```

**However:** Use the safe formula as **best practice**:
- Transfers to other languages
- Better for interviews (shows awareness)
- Slightly more efficient (one less operation)

### Complete Examples

```python
def demo_overflow_safety():
    """Demonstrate safe mid calculation."""
    
    # Test with large numbers
    left = 2**60
    right = 2**61
    
    # Both methods work in Python
    mid1 = (left + right) // 2
    mid2 = left + (right - left) // 2
    
    print(f"left:  {left:,}")
    print(f"right: {right:,}")
    print(f"\nMethod 1 (left + right) // 2: {mid1:,}")
    print(f"Method 2 left + (right - left) // 2: {mid2:,}")
    print(f"Results equal: {mid1 == mid2}")
    
    # Visualize the difference
    print(f"\nüìä Intermediate Values:")
    print(f"Method 1 creates: left + right = {left + right:,}")
    print(f"Method 2 creates: right - left = {right - left:,}")
    print(f"Method 2 is safer (smaller intermediate value)")


demo_overflow_safety()
```

### Alternative: Bit Shift Method

```python
# Another safe method (useful in some contexts)
mid = (left + right) >> 1  # Right shift by 1 = divide by 2

# Equivalent to:
mid = (left + right) // 2

# Example
left, right = 10, 20
print((left + right) >> 1)  # Output: 15
```

---

## Infinite Loop Traps

### The Danger

Incorrect loop update logic can cause **infinite loops** where `left` and `right` never converge.

### Case 1: Using `left = mid` with `left < right`

**The Problem:**
```python
# ‚ùå DANGER: Can cause infinite loop!
while left < right:
    mid = left + (right - left) // 2
    if condition(mid):
        left = mid  # ‚ö†Ô∏è PROBLEM!
    else:
        right = mid - 1
```

**Why it fails:**
```
Example: left = 5, right = 6

Iteration 1:
  mid = 5 + (6 - 5) // 2 = 5 + 0 = 5
  Suppose condition(5) is True
  left = mid = 5  ‚Üê No progress!
  
Iteration 2:
  Same as Iteration 1 ‚Üí INFINITE LOOP!
```

**Visual:**
```
left=5, right=6
    ‚Üì      ‚Üì
    [5, 6]
     ‚Üë
    mid=5

If we set left=mid, we get:
left=5, right=6  ‚Üê Same state! Infinite loop!
```

### The Fix: Always Make Progress

**Option 1: Use `left = mid + 1`**
```python
# ‚úÖ SAFE
while left < right:
    mid = left + (right - left) // 2
    if condition(mid):
        left = mid + 1  # Always progresses
    else:
        right = mid
```

**Option 2: Use `left <= right` with proper updates**
```python
# ‚úÖ SAFE
while left <= right:
    mid = left + (right - left) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        left = mid + 1  # Always progresses
    else:
        right = mid - 1  # Always progresses
```

### Case 2: Wrong Combination of Condition and Update

**The Problem:**
```python
# ‚ùå WRONG: Inconsistent logic
while left <= right:  # Using <=
    mid = left + (right - left) // 2
    if condition(mid):
        right = mid  # ‚ö†Ô∏è Should be mid - 1 with <=
    else:
        left = mid + 1
```

### Decision Matrix: Avoiding Infinite Loops

| Loop Condition | Update Pattern | Safe? | Use Case |
|----------------|----------------|-------|----------|
| `left < right` | `left = mid + 1`, `right = mid` | ‚úÖ | Insert position, boundaries |
| `left < right` | `left = mid`, `right = mid - 1` | ‚ùå | INFINITE LOOP RISK! |
| `left <= right` | `left = mid + 1`, `right = mid - 1` | ‚úÖ | Exact match search |
| `left <= right` | `left = mid`, `right = mid` | ‚ùå | INFINITE LOOP! |

### Complete Example: Detecting Infinite Loops

```python
def detect_infinite_loop_demo():
    """Demonstrate infinite loop detection."""
    
    def bad_binary_search(arr, target):
        """BROKEN: Demonstrates infinite loop."""
        left, right = 0, len(arr) - 1
        iterations = 0
        max_iterations = 100  # Safety limit
        
        print(f"Searching for {target} in {arr}")
        print("‚ö†Ô∏è  WARNING: This code has infinite loop potential!\n")
        
        while left < right and iterations < max_iterations:
            mid = left + (right - left) // 2
            iterations += 1
            
            print(f"Iteration {iterations}: left={left}, mid={mid}, right={right}")
            
            if arr[mid] >= target:
                left = mid  # ‚ùå PROBLEM: No progress when left+1=right
                print(f"  Set left = mid = {mid}")
            else:
                right = mid - 1
                print(f"  Set right = mid - 1 = {mid - 1}")
            
            print(f"  New range: [{left}, {right}]\n")
            
            # Detect stuck condition
            if iterations > 10 and left == mid:
                print("üö® INFINITE LOOP DETECTED!")
                print(f"   Stuck at left={left}, right={right}")
                return -1
        
        return left if arr[left] == target else -1
    
    
    def good_binary_search(arr, target):
        """CORRECT: No infinite loop."""
        left, right = 0, len(arr) - 1
        
        print(f"Searching for {target} in {arr}")
        print("‚úÖ This code is safe!\n")
        
        iterations = 0
        while left < right:
            mid = left + (right - left) // 2
            iterations += 1
            
            print(f"Iteration {iterations}: left={left}, mid={mid}, right={right}")
            
            if arr[mid] >= target:
                right = mid  # ‚úÖ SAFE
                print(f"  Set right = mid = {mid}")
            else:
                left = mid + 1  # ‚úÖ SAFE: Always progresses
                print(f"  Set left = mid + 1 = {mid + 1}")
            
            print(f"  New range: [{left}, {right}]\n")
        
        return left if arr[left] == target else -1
    
    # Test with case that exposes the bug
    arr = [1, 2, 3, 4, 5]
    target = 5
    
    print("=" * 60)
    print("BAD VERSION (Infinite Loop Risk):")
    print("=" * 60)
    bad_binary_search(arr, target)
    
    print("\n" + "=" * 60)
    print("GOOD VERSION (Safe):")
    print("=" * 60)
    good_binary_search(arr, target)


detect_infinite_loop_demo()
```

### The Golden Rules

**Rule 1:** With `left < right`:
- MUST use: `left = mid + 1` OR `right = mid - 1`
- One side MUST have `+1` or `-1`

**Rule 2:** With `left <= right`:
- MUST use: `left = mid + 1` AND `right = mid - 1`
- BOTH sides need `+1` and `-1`

**Rule 3:** Test with two-element array:
```python
# Always test your code with:
arr = [1, 2]
# Does it terminate? Or infinite loop?
```

---

## Boundary Condition Errors

### Types of Boundary Errors

#### 1. Array Index Out of Bounds

**The Problem:**
```python
# ‚ùå WRONG: Accessing arr[mid+1] without checking
while left <= right:
    mid = left + (right - left) // 2
    if arr[mid] < arr[mid + 1]:  # ‚ö†Ô∏è What if mid == len(arr)-1?
        left = mid + 1
```

**The Fix:**
```python
# ‚úÖ CORRECT: Check boundaries
while left < len(arr) - 1:  # Ensure mid+1 is valid
    mid = left + (right - left) // 2
    if arr[mid] < arr[mid + 1]:
        left = mid + 1
```

#### 2. Empty Array Handling

**The Problem:**
```python
# ‚ùå WRONG: Doesn't handle empty array
def binary_search(arr, target):
    left, right = 0, len(arr) - 1  # right = -1 if arr is empty!
    # ... rest of code
```

**The Fix:**
```python
# ‚úÖ CORRECT: Check first
def binary_search(arr, target):
    if not arr:  # or len(arr) == 0
        return -1
    
    left, right = 0, len(arr) - 1
    # ... rest of code
```

#### 3. Single Element Edge Case

**The Problem:**
```python
# Some algorithms fail on single-element arrays
arr = [5]
# Does your binary search handle this correctly?
```

**The Fix:**
```python
def robust_binary_search(arr, target):
    """Handle all edge cases."""
    # Empty array
    if not arr:
        return -1
    
    # Single element
    if len(arr) == 1:
        return 0 if arr[0] == target else -1
    
    # Now safe to do standard binary search
    left, right = 0, len(arr) - 1
    # ...
```

### Complete Edge Case Handler

```python
def binary_search_with_all_edge_cases(arr, target):
    """Binary search with comprehensive edge case handling."""
    
    # Edge Case 1: Empty array
    if not arr:
        print("Edge case: Empty array")
        return -1
    
    # Edge Case 2: Single element
    if len(arr) == 1:
        print("Edge case: Single element")
        return 0 if arr[0] == target else -1
    
    # Edge Case 3: Target out of range
    if target < arr[0]:
        print("Edge case: Target smaller than smallest element")
        return -1
    if target > arr[-1]:
        print("Edge case: Target larger than largest element")
        return -1
    
    # Edge Case 4: Target at boundaries
    if arr[0] == target:
        print("Edge case: Target at start")
        return 0
    if arr[-1] == target:
        print("Edge case: Target at end")
        return len(arr) - 1
    
    # Standard binary search
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1


# Test all edge cases
test_cases = [
    ([], 5, "Empty array"),
    ([5], 5, "Single element - found"),
    ([5], 3, "Single element - not found"),
    ([1, 2, 3, 4, 5], 0, "Target below range"),
    ([1, 2, 3, 4, 5], 10, "Target above range"),
    ([1, 2, 3, 4, 5], 1, "Target at start"),
    ([1, 2, 3, 4, 5], 5, "Target at end"),
    ([1, 2, 3, 4, 5], 3, "Target in middle"),
]

print("Testing All Edge Cases:\n")
for arr, target, description in test_cases:
    print(f"Test: {description}")
    print(f"  Array: {arr}, Target: {target}")
    result = binary_search_with_all_edge_cases(arr, target)
    print(f"  Result: {result}\n")
```

---

## Off-by-One Errors

### What Are Off-by-One Errors?

Errors where the index is **one position off** from where it should be.

### Common Scenarios

#### Scenario 1: Wrong Initial Values

```python
# ‚ùå WRONG: Should be len(arr) - 1, not len(arr)
right = len(arr)
while left <= right:  # Will access arr[len(arr)] ‚Üí ERROR!
    mid = left + (right - left) // 2
    if arr[mid] == target:
        return mid

# ‚úÖ CORRECT
right = len(arr) - 1
```

#### Scenario 2: Boundary Search Errors

```python
# Finding first occurrence
def find_first_wrong(arr, target):
    # ‚ùå WRONG: Missing result initialization
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            right = mid - 1  # Continue searching left
        # ...
    
    return right  # ‚ùå WRONG: Should return right + 1 or use result variable


def find_first_correct(arr, target):
    # ‚úÖ CORRECT: Use result variable
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            result = mid  # Save result
            right = mid - 1
        # ...
    
    return result  # Return saved result
```

#### Scenario 3: Insert Position Errors

```python
# ‚ùå WRONG: Off by one
def search_insert_wrong(arr, target):
    left, right = 0, len(arr) - 1  # Should be len(arr)
    
    while left < right:
        mid = left + (right - left) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid
    
    return left

# Test:
# arr = [1, 3, 5], target = 6
# Expected: 3 (insert at end)
# Wrong code returns: 2 (off by one)


# ‚úÖ CORRECT
def search_insert_correct(arr, target):
    left, right = 0, len(arr)  # Notice: len(arr), not len(arr)-1
    
    while left < right:
        mid = left + (right - left) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid
    
    return left
```

### Debugging Off-by-One Errors

```python
def debug_off_by_one():
    """Demonstrate how to catch off-by-one errors."""
    
    def test_insert_position(func, arr, target):
        """Test insert position function."""
        result = func(arr, target)
        
        # Manual verification
        expected = 0
        for i, val in enumerate(arr):
            if val < target:
                expected = i + 1
        
        # Check if result is correct
        status = "‚úÖ" if result == expected else "‚ùå"
        print(f"{status} arr={arr}, target={target}")
        print(f"   Got: {result}, Expected: {expected}")
        
        # Visualize the insertion
        if result == expected:
            arr_copy = arr.copy()
            arr_copy.insert(result, target)
            print(f"   After insert: {arr_copy}")
        else:
            print(f"   ERROR: Off by {abs(result - expected)}")
        print()
    
    # Test both versions
    def wrong_version(arr, target):
        left, right = 0, len(arr) - 1  # Wrong!
        while left < right:
            mid = left + (right - left) // 2
            if arr[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left
    
    def correct_version(arr, target):
        left, right = 0, len(arr)  # Correct!
        while left < right:
            mid = left + (right - left) // 2
            if arr[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left
    
    # Edge cases that expose off-by-one errors
    test_cases = [
        ([1, 3, 5], 6),   # Insert at end
        ([1, 3, 5], 0),   # Insert at start
        ([1, 3, 5], 4),   # Insert in middle
        ([], 1),          # Empty array
    ]
    
    print("Testing WRONG version (off by one):")
    print("=" * 50)
    for arr, target in test_cases:
        test_insert_position(wrong_version, arr, target)
    
    print("\nTesting CORRECT version:")
    print("=" * 50)
    for arr, target in test_cases:
        test_insert_position(correct_version, arr, target)


debug_off_by_one()
```

---

## Edge Cases Checklist

### Comprehensive Testing Checklist

```python
class BinarySearchTester:
    """Comprehensive edge case tester for binary search."""
    
    def __init__(self, search_func):
        self.search_func = search_func
        self.passed = 0
        self.failed = 0
    
    def test(self, arr, target, expected, description):
        """Run single test."""
        result = self.search_func(arr, target)
        status = "‚úÖ" if result == expected else "‚ùå"
        
        if result == expected:
            self.passed += 1
        else:
            self.failed += 1
        
        print(f"{status} {description}")
        if result != expected:
            print(f"   Array: {arr}, Target: {target}")
            print(f"   Expected: {expected}, Got: {result}")
        return result == expected
    
    def run_all_tests(self):
        """Run comprehensive test suite."""
        print("Running Comprehensive Binary Search Tests")
        print("=" * 60)
        
        # Category 1: Size edge cases
        print("\nüìè Size Edge Cases:")
        self.test([], 5, -1, "Empty array")
        self.test([5], 5, 0, "Single element - found")
        self.test([5], 3, -1, "Single element - not found")
        self.test([1, 2], 1, 0, "Two elements - first")
        self.test([1, 2], 2, 1, "Two elements - second")
        
        # Category 2: Position edge cases
        print("\nüìç Position Edge Cases:")
        arr = [1, 2, 3, 4, 5]
        self.test(arr, 1, 0, "Target at start")
        self.test(arr, 5, 4, "Target at end")
        self.test(arr, 3, 2, "Target in middle")
        
        # Category 3: Not found cases
        print("\nüîç Not Found Cases:")
        self.test(arr, 0, -1, "Target before start")
        self.test(arr, 6, -1, "Target after end")
        self.test(arr, 2.5, -1, "Target between elements")
        
        # Category 4: Duplicates (if applicable)
        print("\nüîÅ Duplicate Cases:")
        arr_dup = [1, 2, 2, 2, 3, 4, 5]
        self.test(arr_dup, 2, 1, "First occurrence of duplicate")
        
        # Category 5: All same elements
        print("\nüîÑ Uniform Array Cases:")
        arr_same = [5, 5, 5, 5, 5]
        self.test(arr_same, 5, 0, "All elements same - found")
        self.test(arr_same, 3, -1, "All elements same - not found")
        
        # Category 6: Negative numbers
        print("\n‚ûñ Negative Number Cases:")
        arr_neg = [-5, -3, -1, 0, 2, 4]
        self.test(arr_neg, -3, 1, "Negative target found")
        self.test(arr_neg, -4, -1, "Negative target not found")
        
        # Category 7: Large numbers
        print("\nüíØ Large Number Cases:")
        arr_large = [10**6, 10**7, 10**8]
        self.test(arr_large, 10**7, 1, "Large numbers")
        
        # Summary
        print("\n" + "=" * 60)
        print(f"Tests Passed: {self.passed}")
        print(f"Tests Failed: {self.failed}")
        print(f"Success Rate: {self.passed / (self.passed + self.failed) * 100:.1f}%")


# Example usage
def standard_binary_search(arr, target):
    """Standard binary search implementation."""
    if not arr:
        return -1
    
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1


tester = BinarySearchTester(standard_binary_search)
tester.run_all_tests()
```

---

## Debugging Strategies

### Strategy 1: Print-Based Debugging

```python
def binary_search_debug(arr, target):
    """Binary search with detailed debugging output."""
    print(f"\n{'='*60}")
    print(f"Searching for {target} in {arr}")
    print(f"{'='*60}")
    
    left, right = 0, len(arr) - 1
    iteration = 0
    
    while left <= right:
        iteration += 1
        mid = left + (right - left) // 2
        
        # Print current state
        print(f"\nIteration {iteration}:")
        print(f"  left={left}, mid={mid}, right={right}")
        print(f"  arr[left]={arr[left]}, arr[mid]={arr[mid]}, arr[right]={arr[right]}")
        
        # Visualize current range
        visual = ['¬∑'] * len(arr)
        visual[left] = 'L'
        visual[right] = 'R'
        visual[mid] = 'M'
        print(f"  Position: {' '.join(visual)}")
        print(f"  Values:   {' '.join(str(x) for x in arr)}")
        
        # Decision logic
        if arr[mid] == target:
            print(f"  ‚úÖ Found at index {mid}!")
            return mid
        elif arr[mid] < target:
            print(f"  {arr[mid]} < {target}, search right half")
            left = mid + 1
        else:
            print(f"  {arr[mid]} > {target}, search left half")
            right = mid - 1
    
    print(f"  ‚ùå Target not found")
    return -1


# Test
binary_search_debug([1, 3, 5, 7, 9, 11, 13], 7)
```

### Strategy 2: Assertion-Based Debugging

```python
def binary_search_with_assertions(arr, target):
    """Binary search with runtime assertions."""
    assert isinstance(arr, list), "Input must be a list"
    assert all(arr[i] <= arr[i+1] for i in range(len(arr)-1)), "Array must be sorted"
    
    left, right = 0, len(arr) - 1
    
    while left <= right:
        # Invariant: if target exists, it's in [left, right]
        assert 0 <= left <= len(arr), f"Left out of bounds: {left}"
        assert -1 <= right < len(arr), f"Right out of bounds: {right}"
        assert left <= right + 1, f"Invalid range: left={left}, right={right}"
        
        mid = left + (right - left) // 2
        
        # Check mid is in valid range
        assert left <= mid <= right, f"Mid out of range: {mid}"
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1
```

### Strategy 3: Unit Test Framework

```python
import unittest

class TestBinarySearch(unittest.TestCase):
    """Comprehensive unit tests."""
    
    def setUp(self):
        """Set up test fixtures."""
        self.search = standard_binary_search
    
    def test_empty_array(self):
        self.assertEqual(self.search([], 5), -1)
    
    def test_single_element_found(self):
        self.assertEqual(self.search([5], 5), 0)
    
    def test_single_element_not_found(self):
        self.assertEqual(self.search([5], 3), -1)
    
    def test_target_at_start(self):
        self.assertEqual(self.search([1, 2, 3, 4, 5], 1), 0)
    
    def test_target_at_end(self):
        self.assertEqual(self.search([1, 2, 3, 4, 5], 5), 4)
    
    def test_target_in_middle(self):
        self.assertEqual(self.search([1, 2, 3, 4, 5], 3), 2)
    
    def test_target_not_present(self):
        self.assertEqual(self.search([1, 2, 3, 4, 5], 6), -1)
    
    def test_negative_numbers(self):
        self.assertEqual(self.search([-5, -3, -1, 0, 2], -3), 1)
    
    def test_all_same_elements(self):
        result = self.search([5, 5, 5, 5], 5)
        self.assertIn(result, [0, 1, 2, 3])  # Any position is valid


# Run tests
if __name__ == '__main__':
    unittest.main(argv=[''], exit=False, verbosity=2)
```

---

## Summary: Avoiding Pitfalls

### Quick Reference Table

| Pitfall | ‚ùå Wrong | ‚úÖ Correct |
|---------|---------|-----------|
| **Overflow** | `mid = (left + right) // 2` | `mid = left + (right - left) // 2` |
| **Infinite Loop** | `left = mid` with `left < right` | `left = mid + 1` |
| **Empty Array** | No check | `if not arr: return -1` |
| **Boundaries** | `right = len(arr)` with `<=` | `right = len(arr) - 1` |
| **Off-by-One** | `right = len(arr) - 1` for insert | `right = len(arr)` for insert |

### Pre-Coding Checklist

Before implementing binary search:
- [ ] What's the search space?
- [ ] What loop condition to use? (`<` or `<=`)
- [ ] How to update left/right?
- [ ] What to return?
- [ ] Edge cases handled?

### Debugging Checklist

When code doesn't work:
- [ ] Test with 0, 1, 2 elements
- [ ] Check boundary updates
- [ ] Verify loop termination
- [ ] Print intermediate values
- [ ] Test all edge cases

### The Golden Rule

**"When in doubt, trace it out!"** 

Run your code manually with a small example on paper. This catches 90% of bugs! üêõüîç