# Chapter 7: Interview Problem Patterns - In-Depth Guide

## Table of Contents
1. [Pattern Recognition Framework](#pattern-recognition-framework)
2. [Interview Strategy](#interview-strategy)
3. [Problem-Solving Workflow](#problem-solving-workflow)
4. [Complete Problem Solutions](#complete-problem-solutions)
5. [Interview Simulation](#interview-simulation)
6. [Time Management](#time-management)

---

## Pattern Recognition Framework

### The Decision Tree

Use this flowchart in interviews to quickly identify the right approach:

```
START: Read problem
    |
    ‚Üì
Is data sorted or monotonic?
    |
    ‚îú‚îÄNO‚îÄ‚îÄ‚Üí Can you make it sorted?
    |       ‚îú‚îÄYES‚îÄ‚Üí Sort first (O(n log n)), then binary search
    |       ‚îî‚îÄNO‚îÄ‚îÄ‚Üí Binary search probably not applicable
    |
    ‚ÜìYES
    |
What are you searching for?
    |
    ‚îú‚îÄSpecific VALUE in array
    |   ‚îú‚îÄExact match? ‚Üí Classic Binary Search (Template 1)
    |   ‚îú‚îÄFirst occurrence? ‚Üí Left Boundary Search (Template 2)
    |   ‚îú‚îÄLast occurrence? ‚Üí Right Boundary Search (Template 3)
    |   ‚îî‚îÄInsert position? ‚Üí Lower Bound Search (Template 4)
    |
    ‚îú‚îÄA POSITION/INDEX with property
    |   ‚îú‚îÄPeak element? ‚Üí Peak Finding Pattern
    |   ‚îú‚îÄMinimum in rotated? ‚Üí Rotated Array Pattern
    |   ‚îî‚îÄTarget in rotated? ‚Üí Rotated Array Search Pattern
    |
    ‚îî‚îÄAn OPTIMAL VALUE (min/max)
        ‚îî‚îÄCan you verify answer? ‚Üí Binary Search on Answer (Template 5)
```

### Pattern Recognition Questions

Ask yourself these questions when you see a problem:

#### Question 1: "Is there a sorted property?"
```python
# Obvious sorting:
arr = [1, 2, 3, 4, 5]  # ‚úÖ Clearly sorted

# Hidden sorting:
arr = [4, 5, 6, 7, 0, 1, 2]  # ‚úÖ Rotated sorted array

# Monotonic property:
answer_space = [1, 2, 3, ..., 100]  # ‚úÖ Can binary search on answer
```

#### Question 2: "What am I looking for?"
```python
# Looking for an element
"Find 7 in array" ‚Üí Classic binary search

# Looking for a boundary
"Find first/last occurrence" ‚Üí Boundary search

# Looking for optimal value
"Minimize maximum sum" ‚Üí Binary search on answer
```

#### Question 3: "Can I check if answer X works?"
```python
# If you can write this function:
def is_valid(x):
    # Check if x satisfies constraints
    return True/False

# Then you can binary search on x!
```

### Pattern Identification Examples

```python
def identify_pattern(problem_description):
    """
    Analyze problem and suggest pattern.
    This is the mental process during interviews.
    """
    
    patterns = {
        "exact_match": [
            "find target in sorted array",
            "search for value",
            "does element exist"
        ],
        "boundary": [
            "first occurrence",
            "last occurrence",
            "leftmost position",
            "rightmost position"
        ],
        "insert_position": [
            "insert position",
            "where to insert",
            "maintain sorted order"
        ],
        "rotated_array": [
            "rotated sorted array",
            "array rotated at pivot",
            "find in rotated"
        ],
        "peak_finding": [
            "peak element",
            "local maximum",
            "greater than neighbors"
        ],
        "answer_space": [
            "minimize the maximum",
            "maximize the minimum",
            "minimum capacity",
            "can finish in time"
        ],
        "2d_matrix": [
            "2D matrix",
            "rows and columns sorted",
            "matrix search"
        ]
    }
    
    problem_lower = problem_description.lower()
    
    print(f"Problem: {problem_description}\n")
    print("Pattern Analysis:")
    
    for pattern, keywords in patterns.items():
        if any(keyword in problem_lower for keyword in keywords):
            print(f"  ‚úÖ Matches: {pattern.upper().replace('_', ' ')}")
            return pattern
    
    print("  ‚ö†Ô∏è  No clear binary search pattern detected")
    return None


# Test pattern recognition
problems = [
    "Find target in sorted array",
    "Find first occurrence of target with duplicates",
    "Search in rotated sorted array",
    "Minimize the largest sum when splitting array",
    "Find peak element in array",
]

for problem in problems:
    identify_pattern(problem)
    print()
```

---

## Interview Strategy

### The 4-Step Framework

#### Step 1: Understand & Clarify (2-3 minutes)

```python
def step1_clarify():
    """Questions to ask interviewer."""
    
    questions = [
        "Input Properties:",
        "  - Is the array sorted?",
        "  - Can array have duplicates?",
        "  - What's the size range? (Empty array possible?)",
        "  - Any constraints on values? (negative numbers?)",
        "",
        "Output Requirements:",
        "  - Return index or value?",
        "  - If multiple answers exist, which one?",
        "  - What to return if not found?",
        "",
        "Edge Cases:",
        "  - How to handle empty input?",
        "  - What if target doesn't exist?",
    ]
    
    return "\n".join(questions)

print("Step 1 - Questions to Ask:")
print("=" * 60)
print(step1_clarify())
```

#### Step 2: Examples & Edge Cases (2-3 minutes)

```python
def step2_examples():
    """Work through examples before coding."""
    
    print("Step 2 - Work Through Examples:")
    print("=" * 60)
    
    print("\n1. Standard case:")
    print("   arr = [1, 3, 5, 7, 9], target = 7")
    print("   Expected: 3")
    
    print("\n2. Edge case - Empty:")
    print("   arr = [], target = 5")
    print("   Expected: -1")
    
    print("\n3. Edge case - Single element:")
    print("   arr = [5], target = 5")
    print("   Expected: 0")
    
    print("\n4. Edge case - Not found:")
    print("   arr = [1, 3, 5], target = 4")
    print("   Expected: -1")
    
    print("\n5. Edge case - Boundaries:")
    print("   arr = [1, 3, 5], target = 1  (first)")
    print("   arr = [1, 3, 5], target = 5  (last)")

step2_examples()
```

#### Step 3: Explain Approach (2-3 minutes)

```python
def step3_explain_approach(problem_type):
    """
    Explain your approach before coding.
    This shows structured thinking!
    """
    
    approaches = {
        "exact_match": """
        Approach: Classic Binary Search
        
        1. Initialize left=0, right=len(arr)-1
        2. While left <= right:
           - Calculate mid
           - If arr[mid] == target: return mid
           - If arr[mid] < target: search right (left = mid+1)
           - Else: search left (right = mid-1)
        3. Return -1 if not found
        
        Time: O(log n), Space: O(1)
        """,
        
        "answer_space": """
        Approach: Binary Search on Answer Space
        
        1. Define answer range [min_answer, max_answer]
           - min_answer = max(array) [must fit largest]
           - max_answer = sum(array) [worst case]
        
        2. Write validation function is_valid(x):
           - Check if answer x satisfies constraints
           - Should run in O(n) time
        
        3. Binary search on answer:
           - If is_valid(mid): try smaller (right = mid-1)
           - Else: need larger (left = mid+1)
        
        Time: O(n log(max_answer)), Space: O(1)
        """
    }
    
    return approaches.get(problem_type, "Approach explanation")

print("\n" + step3_explain_approach("exact_match"))
```

#### Step 4: Code & Test (15-20 minutes)

```python
def step4_code_and_test():
    """Coding best practices."""
    
    practices = """
    Step 4 - Coding Best Practices:
    ================================
    
    1. START WITH EDGE CASES:
       - Handle empty array first
       - Handle single element
       - Check boundary conditions
    
    2. USE CLEAR VARIABLE NAMES:
       ‚úÖ left, right, mid
       ‚ùå l, r, m (too cryptic)
       ‚úÖ max_sum, capacity, speed
       ‚ùå x, y, z (unclear meaning)
    
    3. ADD COMMENTS FOR TRICKY PARTS:
       - Why using specific formula
       - What invariant is maintained
       - Edge case handling
    
    4. TEST AS YOU CODE:
       - After each function, trace through example
       - Test edge cases verbally
       - Walk through one iteration
    
    5. VERIFY COMPLEXITY:
       - State time and space complexity
       - Explain why it's O(log n)
    """
    
    return practices

print(step4_code_and_test())
```

---

## Problem-Solving Workflow

### Real Interview Simulation

Let's simulate a complete interview with problem-solving workflow:

```python
class InterviewSimulation:
    """Simulate solving a problem in an interview."""
    
    def __init__(self, problem):
        self.problem = problem
        self.time_elapsed = 0
    
    def phase1_understand(self):
        """Phase 1: Understanding (2-3 min)."""
        print("\n" + "="*70)
        print("PHASE 1: UNDERSTANDING THE PROBLEM (2-3 minutes)")
        print("="*70)
        
        print(f"\nüìã Problem: {self.problem['description']}")
        
        print("\nü§î Clarifying Questions:")
        for q in self.problem['clarifications']:
            print(f"  Q: {q['question']}")
            print(f"  A: {q['answer']}")
        
        self.time_elapsed += 3
        print(f"\n‚è±Ô∏è  Time elapsed: {self.time_elapsed} min")
    
    def phase2_examples(self):
        """Phase 2: Examples (2-3 min)."""
        print("\n" + "="*70)
        print("PHASE 2: WORKING THROUGH EXAMPLES (2-3 minutes)")
        print("="*70)
        
        print("\nüìù Test Cases:")
        for i, example in enumerate(self.problem['examples'], 1):
            print(f"\n  Example {i}:")
            print(f"    Input: {example['input']}")
            print(f"    Output: {example['output']}")
            print(f"    Explanation: {example['explanation']}")
        
        self.time_elapsed += 3
        print(f"\n‚è±Ô∏è  Time elapsed: {self.time_elapsed} min")
    
    def phase3_approach(self):
        """Phase 3: Explain approach (2-3 min)."""
        print("\n" + "="*70)
        print("PHASE 3: EXPLAINING APPROACH (2-3 minutes)")
        print("="*70)
        
        print("\nüí° Approach:")
        print(self.problem['approach'])
        
        print("\nüìä Complexity Analysis:")
        print(f"  Time: {self.problem['time_complexity']}")
        print(f"  Space: {self.problem['space_complexity']}")
        
        self.time_elapsed += 3
        print(f"\n‚è±Ô∏è  Time elapsed: {self.time_elapsed} min")
    
    def phase4_code(self):
        """Phase 4: Coding (15-20 min)."""
        print("\n" + "="*70)
        print("PHASE 4: CODING SOLUTION (15-20 minutes)")
        print("="*70)
        
        print("\nüíª Implementation:")
        print(self.problem['code'])
        
        self.time_elapsed += 15
        print(f"\n‚è±Ô∏è  Time elapsed: {self.time_elapsed} min")
    
    def phase5_test(self):
        """Phase 5: Testing (3-5 min)."""
        print("\n" + "="*70)
        print("PHASE 5: TESTING (3-5 minutes)")
        print("="*70)
        
        print("\nüß™ Running Test Cases:")
        for i, test in enumerate(self.problem['tests'], 1):
            print(f"\n  Test {i}: {test['name']}")
            print(f"    Input: {test['input']}")
            result = test['function'](*test['input'])
            expected = test['expected']
            status = "‚úÖ PASS" if result == expected else "‚ùå FAIL"
            print(f"    Expected: {expected}")
            print(f"    Got: {result}")
            print(f"    {status}")
        
        self.time_elapsed += 5
        print(f"\n‚è±Ô∏è  Total time: {self.time_elapsed} min")
    
    def run(self):
        """Run complete interview simulation."""
        self.phase1_understand()
        self.phase2_examples()
        self.phase3_approach()
        self.phase4_code()
        self.phase5_test()
        
        print("\n" + "="*70)
        print("INTERVIEW COMPLETE!")
        print("="*70)
        print(f"Total time: {self.time_elapsed} minutes")
        print("Expected: 30-40 minutes")
        if self.time_elapsed <= 40:
            print("‚úÖ Good time management!")
        else:
            print("‚ö†Ô∏è  Over time - practice for speed!")


# Example problem for simulation
problem_ship_packages = {
    'description': """
    Capacity To Ship Packages Within D Days (LeetCode 1011)
    
    A conveyor belt has packages that must be shipped within D days.
    The ith package weighs weights[i]. Each day, we load packages
    in order on a ship with weight capacity. Find minimum capacity
    to ship all packages within D days.
    """,
    
    'clarifications': [
        {
            'question': "Can packages be split or reordered?",
            'answer': "No, must ship in order, cannot split packages."
        },
        {
            'question': "What's the range of weights?",
            'answer': "1 <= weights[i] <= 500, 1 <= len(weights) <= 50000"
        },
        {
            'question': "What's the range of days?",
            'answer': "1 <= D <= len(weights)"
        }
    ],
    
    'examples': [
        {
            'input': "weights = [1,2,3,4,5,6,7,8,9,10], D = 5",
            'output': "15",
            'explanation': "Ship [1,2,3,4,5], [6,7], [8], [9], [10] in 5 days with capacity 15"
        },
        {
            'input': "weights = [3,2,2,4,1,4], D = 3",
            'output': "6",
            'explanation': "Ship [3,2], [2,4], [1,4] in 3 days with capacity 6"
        }
    ],
    
    'approach': """
    This is a "Binary Search on Answer Space" problem.
    
    Key Insight:
    - If capacity X works, then X+1, X+2, etc. also work (monotonic)
    - We can verify any capacity in O(n) time
    - Binary search on capacity: [max(weights), sum(weights)]
    
    Algorithm:
    1. Define range: [max(weights), sum(weights)]
    2. Write can_ship(capacity) function (greedy simulation)
    3. Binary search to find minimum capacity
    """,
    
    'time_complexity': "O(n √ó log(sum(weights)))",
    'space_complexity': "O(1)",
    
    'code': '''
def ship_within_days(weights, days):
    def can_ship(capacity):
        days_needed = 1
        current_load = 0
        
        for weight in weights:
            if current_load + weight > capacity:
                days_needed += 1
                current_load = weight
                if days_needed > days:
                    return False
            else:
                current_load += weight
        
        return True
    
    left, right = max(weights), sum(weights)
    result = right
    
    while left <= right:
        mid = left + (right - left) // 2
        if can_ship(mid):
            result = mid
            right = mid - 1
        else:
            left = mid + 1
    
    return result
''',
    
    'tests': []  # Will add actual test functions
}

# Add actual test functions
def ship_within_days_solution(weights, days):
    def can_ship(capacity):
        days_needed = 1
        current_load = 0
        for weight in weights:
            if current_load + weight > capacity:
                days_needed += 1
                current_load = weight
                if days_needed > days:
                    return False
            else:
                current_load += weight
        return True
    
    left, right = max(weights), sum(weights)
    result = right
    while left <= right:
        mid = left + (right - left) // 2
        if can_ship(mid):
            result = mid
            right = mid - 1
        else:
            left = mid + 1
    return result

problem_ship_packages['tests'] = [
    {
        'name': 'Example 1',
        'input': ([1,2,3,4,5,6,7,8,9,10], 5),
        'expected': 15,
        'function': ship_within_days_solution
    },
    {
        'name': 'Example 2',
        'input': ([3,2,2,4,1,4], 3),
        'expected': 6,
        'function': ship_within_days_solution
    },
    {
        'name': 'Edge case - 1 day',
        'input': ([1,2,3,4,5], 1),
        'expected': 15,
        'function': ship_within_days_solution
    }
]

# Run simulation
simulation = InterviewSimulation(problem_ship_packages)
simulation.run()
```

---

## Complete Problem Solutions

### Problem Pattern Reference

Here's a comprehensive mapping of common interview problems to patterns:

```python
PROBLEM_PATTERNS = {
    "Easy": {
        "Binary Search (LC 704)": "exact_match",
        "Search Insert Position (LC 35)": "insert_position",
        "First Bad Version (LC 278)": "answer_space",
        "Sqrt(x) (LC 69)": "answer_space",
        "Valid Perfect Square (LC 367)": "answer_space",
    },
    
    "Medium": {
        "Find First and Last Position (LC 34)": "boundary",
        "Search in Rotated Array (LC 33)": "rotated_array",
        "Find Peak Element (LC 162)": "peak_finding",
        "Find Minimum in Rotated Array (LC 153)": "rotated_array",
        "Koko Eating Bananas (LC 875)": "answer_space",
        "Capacity to Ship Packages (LC 1011)": "answer_space",
        "Split Array Largest Sum (LC 410)": "answer_space",
        "Search 2D Matrix (LC 74)": "2d_matrix",
        "Search 2D Matrix II (LC 240)": "2d_matrix",
        "Find K Closest Elements (LC 658)": "boundary",
    },
    
    "Hard": {
        "Median of Two Sorted Arrays (LC 4)": "median",
        "Find Minimum in Rotated Array II (LC 154)": "rotated_array",
        "Count of Smaller Numbers After Self (LC 315)": "complex",
        "Divide Chocolate (LC 1231)": "answer_space",
        "Minimize Max Distance to Gas Station (LC 774)": "answer_space",
    }
}


def show_problem_map():
    """Display problem-to-pattern mapping."""
    print("\nüìö BINARY SEARCH PROBLEM PATTERNS")
    print("="*70)
    
    for difficulty, problems in PROBLEM_PATTERNS.items():
        print(f"\n{difficulty} Problems:")
        print("-" * 70)
        for problem, pattern in problems.items():
            print(f"  ‚Ä¢ {problem:45} ‚Üí {pattern}")


show_problem_map()
```

### Template Selector

```python
def select_template(problem_keywords):
    """
    Help select the right template based on problem keywords.
    Use this as a quick reference during interviews!
    """
    
    templates = {
        "Template 1 - Exact Match": {
            "keywords": ["find target", "search for", "does exist"],
            "loop": "while left <= right",
            "return": "mid if found, -1 otherwise",
            "use_case": "Finding exact value in sorted array"
        },
        
        "Template 2 - Left Boundary": {
            "keywords": ["first occurrence", "leftmost", "lower bound"],
            "loop": "while left <= right",
            "return": "result variable (saved position)",
            "use_case": "Finding first/leftmost position"
        },
        
        "Template 3 - Right Boundary": {
            "keywords": ["last occurrence", "rightmost", "upper bound"],
            "loop": "while left <= right",
            "return": "result variable (saved position)",
            "use_case": "Finding last/rightmost position"
        },
        
        "Template 4 - Insert Position": {
            "keywords": ["insert", "lower bound", "where to place"],
            "loop": "while left < right",
            "return": "left (insertion point)",
            "use_case": "Finding position to maintain sorted order"
        },
        
        "Template 5 - Answer Space": {
            "keywords": ["minimize maximum", "maximize minimum", "minimum capacity"],
            "loop": "while left <= right",
            "return": "result variable (optimal answer)",
            "use_case": "Searching for optimal value with verification"
        }
    }
    
    print("\nüîç TEMPLATE SELECTOR")
    print("="*70)
    print(f"Problem keywords: {problem_keywords}\n")
    
    matches = []
    keywords_lower = problem_keywords.lower()
    
    for template_name, info in templates.items():
        if any(kw in keywords_lower for kw in info['keywords']):
            matches.append((template_name, info))
    
    if matches:
        print("‚úÖ Recommended Templates:\n")
        for name, info in matches:
            print(f"{name}")
            print(f"  Loop: {info['loop']}")
            print(f"  Return: {info['return']}")
            print(f"  Use: {info['use_case']}\n")
    else:
        print("‚ö†Ô∏è  No exact match. Consider:")
        print("  ‚Ä¢ Is the array sorted? ‚Üí Use Template 1")
        print("  ‚Ä¢ Looking for boundary? ‚Üí Use Template 2/3")
        print("  ‚Ä¢ Can verify answer? ‚Üí Use Template 5")


# Test template selector
select_template("Find first occurrence of target")
select_template("Minimize the maximum load")
```

---

## Time Management

### 45-Minute Interview Breakdown

```python
def show_time_breakdown():
    """Ideal time allocation for 45-minute interview."""
    
    phases = [
        ("Understanding & Clarification", 3, [
            "Read problem carefully",
            "Ask clarifying questions",
            "Confirm inputs/outputs",
            "Check constraints"
        ]),
        
        ("Examples & Edge Cases", 3, [
            "Work through 2-3 examples",
            "Identify edge cases",
            "Verify understanding",
        ]),
        
        ("Approach Explanation", 3, [
            "Explain high-level approach",
            "Justify why binary search",
            "State time/space complexity",
            "Get interviewer buy-in"
        ]),
        
        ("Coding", 20, [
            "Handle edge cases first",
            "Write main logic",
            "Add comments for clarity",
            "Keep code clean and readable"
        ]),
        
        ("Testing & Debugging", 5, [
            "Trace through example",
            "Test edge cases",
            "Fix any bugs",
            "Verify correctness"
        ]),
        
        ("Discussion & Optimization", 5, [
            "Discuss time/space tradeoffs",
            "Alternative approaches",
            "Follow-up questions",
            "Edge case handling"
        ]),
        
        ("Buffer", 6, [
            "Handle unexpected issues",
            "Extra clarification",
            "Complex debugging"
        ])
    ]
    
    print("\n‚è±Ô∏è  45-MINUTE INTERVIEW TIME BREAKDOWN")
    print("="*70)
    
    total = 0
    for phase, minutes, tasks in phases:
        total += minutes
        print(f"\n{phase} ({minutes} min):")
        for task in tasks:
            print(f"  ‚Ä¢ {task}")
        print(f"  Cumulative: {total} min")
    
    print("\n" + "="*70)
    print(f"Total: {total} minutes")
    print("\nüí° Tips:")
    print("  ‚Ä¢ Spend more time on understanding/approach if complex")
    print("  ‚Ä¢ It's okay to code slower if logic is clear")
    print("  ‚Ä¢ Communicate throughout the process")
    print("  ‚Ä¢ Don't rush - accuracy > speed")


show_time_breakdown()
```

### Common Time Traps

```python
def avoid_time_traps():
    """Common mistakes that waste time in interviews."""
    
    traps = {
        "Starting to code too quickly": {
            "Problem": "Rushing into coding without full understanding",
            "Solution": "Spend 5-6 minutes on understanding and approach",
            "Sign": "Having to restart or major refactor mid-coding"
        },
        
        "Over-optimizing edge cases": {
            "Problem": "Spending too much time on rare edge cases",
            "Solution": "Handle common edge cases, mention rare ones",
            "Sign": "Stuck on handling NULL after NULL after NULL"
        },
        
        "Perfectionist coding": {
            "Problem": "Trying to write perfect variable names, comments",
            "Solution": "Write working code first, refine if time permits",
            "Sign": "Spent 5 min debating variable names"
        },
        
        "Silent debugging": {
            "Problem": "Debugging in silence when stuck",
            "Solution": "Think out loud, ask for hints",
            "Sign": "Staring at code for 3+ minutes without speaking"
        },
        
        "Not using examples": {
            "Problem": "Trying to verify logic purely mentally",
            "Solution": "Walk through concrete example with values",
            "Sign": "Code 'looks right' but fails test cases"
        }
    }
    
    print("\n‚ö†Ô∏è  COMMON TIME TRAPS TO AVOID")
    print("="*70)
    
    for trap, details in traps.items():
        print(f"\n‚ùå {trap}")
        print(f"   Problem: {details['Problem']}")
        print(f"   ‚úÖ Solution: {details['Solution']}")
        print(f"   üö® Warning sign: {details['Sign']}")


avoid_time_traps()
```

---

## Interview Tips Checklist

### Before the Interview

```python
def pre_interview_checklist():
    """Things to prepare before interview."""
    
    checklist = """
    üìã PRE-INTERVIEW CHECKLIST
    ========================
    
    Technical Preparation:
    ‚òê Memorized all 5 binary search templates
    ‚òê Practiced 15+ problems from each difficulty
    ‚òê Can recognize patterns quickly
    ‚òê Know time/space complexity formulas
    ‚òê Comfortable explaining approach
    
    Problem-Solving Practice:
    ‚òê Practiced thinking out loud
    ‚òê Done mock interviews
    ‚òê Timed problem-solving (30-45 min)
    ‚òê Explained solutions to others
    ‚òê Debugged code efficiently
    
    Mental Preparation:
    ‚òê Well-rested
    ‚òê Reviewed common mistakes
    ‚òê Have scratch paper ready
    ‚òê Test setup (internet, IDE) working
    ‚òê Positive mindset
    
    Communication:
    ‚òê Practice asking clarifying questions
    ‚òê Comfortable admitting when stuck
    ‚òê Can explain trade-offs clearly
    ‚òê Know how to ask for hints
    """
    
    return checklist

print(pre_interview_checklist())
```

### During the Interview

```python
def interview_dos_and_donts():
    """Do's and Don'ts during the interview."""
    
    guidelines = """
    ‚úÖ DO:
    ======
    ‚Ä¢ Think out loud constantly
    ‚Ä¢ Ask clarifying questions
    ‚Ä¢ Start with brute force if needed
    ‚Ä¢ Write clean, readable code
    ‚Ä¢ Test your code with examples
    ‚Ä¢ Communicate time/space complexity
    ‚Ä¢ Admit when you're stuck
    ‚Ä¢ Take hints gracefully
    ‚Ä¢ Explain your reasoning
    ‚Ä¢ Stay positive and engaged
    
    ‚ùå DON'T:
    =========
    ‚Ä¢ Jump straight to coding
    ‚Ä¢ Write messy, uncommented code
    ‚Ä¢ Go silent when thinking
    ‚Ä¢ Argue with interviewer
    ‚Ä¢ Give up easily
    ‚Ä¢ Ignore edge cases
    ‚Ä¢ Assume interviewer knows your thought process
    ‚Ä¢ Panic when stuck
    ‚Ä¢ Rush through explanations
    ‚Ä¢ Forget to verify solution
    
    üí° POWER PHRASES:
    ================
    "Let me clarify the constraints..."
    "I'm thinking of using binary search because..."
    "The time complexity would be O(log n) because..."
    "Let me verify this works for edge cases..."
    "I'm considering two approaches: ... and ..."
    "Can I trace through an example to verify?"
    "I'm stuck on this part, could you give me a hint?"
    """
    
    return guidelines

print(interview_dos_and_donts())
```

---

## Final Summary

### The Binary Search Master Checklist

```python
def master_checklist():
    """Complete binary search mastery checklist."""
    
    checklist = """
    üéØ BINARY SEARCH MASTERY CHECKLIST
    ==================================
    
    FUNDAMENTALS:
    ‚òê Can implement classic binary search from memory
    ‚òê Understand why time complexity is O(log n)
    ‚òê Know how to avoid integer overflow
    ‚òê Can explain loop invariants
    
    TEMPLATES:
    ‚òê Memorized Template 1: Exact Match
    ‚òê Memorized Template 2: Left Boundary
    ‚òê Memorized Template 3: Right Boundary
    ‚òê Memorized Template 4: Insert Position
    ‚òê Memorized Template 5: Answer Space
    
    PATTERN RECOGNITION:
    ‚òê Can identify when to use binary search
    ‚òê Distinguish between different patterns
    ‚òê Know when NOT to use binary search
    ‚òê Can transform problems to binary search
    
    ADVANCED TOPICS:
    ‚òê Rotated array search (with/without duplicates)
    ‚òê Find minimum in rotated array
    ‚òê Peak element finding
    ‚òê 2D matrix search (both variations)
    ‚òê Median of two sorted arrays
    ‚òê Binary search on answer space
    
    PROBLEM SOLVING:
    ‚òê Solved 5+ easy problems
    ‚òê Solved 10+ medium problems
    ‚òê Solved 3+ hard problems
    ‚òê Can solve new problems in 30-40 min
    ‚òê Comfortable explaining solutions
    
    ERROR PREVENTION:
    ‚òê Know common infinite loop traps
    ‚òê Handle all edge cases systematically
    ‚òê Avoid off-by-one errors
    ‚òê Test with 0, 1, 2 element arrays
    
    INTERVIEW SKILLS:
    ‚òê Can think out loud clearly
    ‚òê Ask good clarifying questions
    ‚òê Explain time/space complexity
    ‚òê Test code with examples
    ‚òê Handle being stuck gracefully
    
    Ready for interviews? ‚úÖ
    """
    
    return checklist

print(master_checklist())
```

### Your Study Plan

```python
def create_study_plan(weeks_available):
    """Generate personalized study plan."""
    
    plans = {
        1: {  # 1 week crash course
            "Day 1-2": "Master basic binary search + boundaries",
            "Day 3-4": "Rotated arrays + peak finding",
            "Day 5": "Binary search on answer space (5 problems)",
            "Day 6": "2D matrix + hard problems",
            "Day 7": "Mock interviews + review"
        },
        2: {  # 2 week normal
            "Week 1 Day 1-2": "Fundamentals + exact match (10 problems)",
            "Week 1 Day 3-4": "Boundaries + insert position (10 problems)",
            "Week 1 Day 5-6": "Binary search on answer (10 problems)",
            "Week 1 Day 7": "Review + weak areas",
            "Week 2 Day 1-2": "Rotated arrays (8 problems)",
            "Week 2 Day 3-4": "2D matrix + peak (8 problems)",
            "Week 2 Day 5-6": "Hard problems (5 problems)",
            "Week 2 Day 7": "Mock interviews"
        },
        4: {  # 4 week comprehensive
            "Week 1": "Fundamentals + 30 easy problems",
            "Week 2": "All patterns + 30 medium problems",
            "Week 3": "Advanced topics + 20 medium/hard problems",
            "Week 4": "Hard problems + mock interviews + review"
        }
    }
    
    plan = plans.get(weeks_available, plans[2])
    
    print(f"\nüìÖ {weeks_available}-WEEK STUDY PLAN")
    print("="*70)
    for day, tasks in plan.items():
        print(f"{day:20} ‚Üí {tasks}")
    
    print("\nüí° Daily Routine:")
    print("  ‚Ä¢ Morning: Learn new concepts (1-2 hours)")
    print("  ‚Ä¢ Afternoon: Practice problems (2-3 hours)")
    print("  ‚Ä¢ Evening: Review mistakes (30 min)")
    print("\nüéØ Goal: 50+ problems total before interviews")

create_study_plan(2)
```

---

## Conclusion

You've now learned:
- ‚úÖ How to recognize binary search patterns
- ‚úÖ Complete interview strategy (4 steps)
- ‚úÖ Time management for 45-min interviews
- ‚úÖ Problem-solving workflow with simulation
- ‚úÖ All templates and when to use them
- ‚úÖ Common pitfalls and how to avoid them

**Remember:** The key to interview success isn't just knowing the algorithms‚Äîit's about:
1. **Pattern Recognition**: Quickly identifying which template to use
2. **Clear Communication**: Explaining your thought process
3. **Structured Approach**: Following the 4-step framework
4. **Practice**: Solving 50+ problems across all patterns

**You're now ready to ace binary search interviews! üöÄ**

Good luck! üí™