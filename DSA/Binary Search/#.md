# Master Binary Search Patterns: Complete Interview Guide

## Table of Contents
1. [Foundation Concepts](#1-foundation-concepts)
2. [Classic Binary Search](#2-classic-binary-search)
3. [Binary Search Variants](#3-binary-search-variants)
4. [Binary Search on Answer Space](#4-binary-search-on-answer-space)
5. [Advanced Patterns](#5-advanced-patterns)
6. [Common Pitfalls & Edge Cases](#6-common-pitfalls--edge-cases)
7. [Interview Problem Patterns](#7-interview-problem-patterns)

---

## 1. Foundation Concepts

### 1.1 Core Prerequisites
- **Sorted Data**: Binary search requires monotonicity (sorted or partially sorted data)
- **Search Space**: Understand what you're searching in (array indices, answer range, etc.)
- **Invariant**: Maintain loop invariant throughout execution

### 1.2 Time & Space Complexity
- **Time**: O(log n) - halves search space each iteration
- **Space**: O(1) iterative, O(log n) recursive (call stack)

### 1.3 When to Use Binary Search
‚úÖ **Use when:**
- Data is sorted or monotonic
- Need O(log n) time complexity
- Looking for a boundary/threshold
- Searching in a solution space

‚ùå **Don't use when:**
- Data is unsorted (unless you can sort first)
- Need to examine all elements
- Linear search is simpler and sufficient

---

## 2. Classic Binary Search

### 2.1 Standard Template (Find Exact Value)

**‚ö†Ô∏è Important Notes:**
- Use `left <= right` for exact match
- Return -1 if not found
- `mid = left + (right - left) // 2` prevents overflow

```python
def binary_search(arr, target):
    """
    Find exact position of target in sorted array.
    Returns index if found, -1 otherwise.
    """
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2  # Prevent overflow
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1  # Search right half
        else:
            right = mid - 1  # Search left half
    
    return -1  # Not found

# Example usage
arr = [1, 3, 5, 7, 9, 11, 13]
print(binary_search(arr, 7))   # Output: 3
print(binary_search(arr, 6))   # Output: -1
```

### 2.2 Recursive Implementation

```python
def binary_search_recursive(arr, target, left, right):
    """Recursive binary search implementation."""
    if left > right:
        return -1
    
    mid = left + (right - left) // 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)

# Example usage
arr = [1, 3, 5, 7, 9, 11, 13]
print(binary_search_recursive(arr, 7, 0, len(arr) - 1))  # Output: 3
```

---

## 3. Binary Search Variants

### 3.1 Find First Occurrence (Left Boundary)

**üîë Key Pattern:** When found, continue searching left
**Use Case:** Find first occurrence in array with duplicates

```python
def find_first_occurrence(arr, target):
    """
    Find the first (leftmost) occurrence of target.
    Returns index if found, -1 otherwise.
    """
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            result = mid
            right = mid - 1  # Continue searching left
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result

# Example usage
arr = [1, 2, 2, 2, 3, 4, 5]
print(find_first_occurrence(arr, 2))  # Output: 1
```

### 3.2 Find Last Occurrence (Right Boundary)

**üîë Key Pattern:** When found, continue searching right
**Use Case:** Find last occurrence in array with duplicates

```python
def find_last_occurrence(arr, target):
    """
    Find the last (rightmost) occurrence of target.
    Returns index if found, -1 otherwise.
    """
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            result = mid
            left = mid + 1  # Continue searching right
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result

# Example usage
arr = [1, 2, 2, 2, 3, 4, 5]
print(find_last_occurrence(arr, 2))  # Output: 3
```

### 3.3 Find Insert Position (Lower Bound)

**üîë Key Pattern:** Find smallest index where arr[i] >= target
**Use Case:** Insert position to maintain sorted order

```python
def find_insert_position(arr, target):
    """
    Find the index where target should be inserted.
    Also known as lower_bound in C++ STL.
    """
    left, right = 0, len(arr)
    
    while left < right:  # Note: left < right, not <=
        mid = left + (right - left) // 2
        
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid  # Don't exclude mid
    
    return left

# Example usage
arr = [1, 3, 5, 7, 9]
print(find_insert_position(arr, 6))  # Output: 3 (between 5 and 7)
print(find_insert_position(arr, 0))  # Output: 0 (at beginning)
print(find_insert_position(arr, 10)) # Output: 5 (at end)
```

### 3.4 Upper Bound

**üîë Key Pattern:** Find smallest index where arr[i] > target
**Use Case:** Find position after all occurrences

```python
def upper_bound(arr, target):
    """
    Find the first index where arr[i] > target.
    """
    left, right = 0, len(arr)
    
    while left < right:
        mid = left + (right - left) // 2
        
        if arr[mid] <= target:  # Note: <= instead of <
            left = mid + 1
        else:
            right = mid
    
    return left

# Example usage
arr = [1, 2, 2, 2, 3, 4, 5]
print(upper_bound(arr, 2))  # Output: 4 (first index > 2)
```

### 3.5 Count Occurrences

```python
def count_occurrences(arr, target):
    """
    Count number of occurrences using binary search.
    Time: O(log n)
    """
    first = find_first_occurrence(arr, target)
    if first == -1:
        return 0
    
    last = find_last_occurrence(arr, target)
    return last - first + 1

# Example usage
arr = [1, 2, 2, 2, 3, 4, 5]
print(count_occurrences(arr, 2))  # Output: 3
```

---

## 4. Binary Search on Answer Space

**üí° Concept:** When you can verify if an answer works in O(n), use binary search to find optimal answer.

### 4.1 Pattern Recognition
**How to identify:**
1. Problem asks for "minimum/maximum value that satisfies condition"
2. Can write a function `is_valid(x)` that checks if x works
3. If x works, all values in one direction also work (monotonic)

### 4.2 Template for Binary Search on Answer

```python
def binary_search_on_answer(arr, condition):
    """
    General template for binary search on answer space.
    
    Args:
        arr: input array
        condition: function that checks if mid value works
    
    Returns:
        The optimal answer
    """
    left, right = min_possible_answer, max_possible_answer
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if condition(mid, arr):
            result = mid
            # Minimize: right = mid - 1
            # Maximize: left = mid + 1
        else:
            # Adjust search space
            pass
    
    return result
```

### 4.3 Problem: Split Array Largest Sum (LeetCode 410)

**Problem:** Split array into m subarrays to minimize the largest subarray sum.

**üîë Insight:** Binary search on the answer (largest sum)
- If we can split with max_sum = X, we can also split with X+1, X+2, etc.
- Search for minimum X that allows valid split

```python
def split_array(nums, m):
    """
    Split array into m subarrays minimizing largest sum.
    
    Example: nums = [7,2,5,10,8], m = 2
    Output: 18 (split: [7,2,5] and [10,8])
    """
    def can_split(max_sum):
        """Check if we can split into m parts with max_sum limit."""
        count = 1
        current_sum = 0
        
        for num in nums:
            if current_sum + num > max_sum:
                count += 1
                current_sum = num
                if count > m:
                    return False
            else:
                current_sum += num
        
        return True
    
    # Answer range: [max(nums), sum(nums)]
    left, right = max(nums), sum(nums)
    result = right
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if can_split(mid):
            result = mid
            right = mid - 1  # Try smaller max_sum
        else:
            left = mid + 1
    
    return result

# Example usage
print(split_array([7, 2, 5, 10, 8], 2))  # Output: 18
```

### 4.4 Problem: Capacity to Ship Packages (LeetCode 1011)

```python
def ship_within_days(weights, days):
    """
    Find minimum ship capacity to ship all packages within days.
    
    Example: weights = [1,2,3,4,5,6,7,8,9,10], days = 5
    Output: 15
    """
    def can_ship(capacity):
        """Check if we can ship all packages within days."""
        days_needed = 1
        current_load = 0
        
        for weight in weights:
            if current_load + weight > capacity:
                days_needed += 1
                current_load = weight
            else:
                current_load += weight
        
        return days_needed <= days
    
    left, right = max(weights), sum(weights)
    result = right
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if can_ship(mid):
            result = mid
            right = mid - 1
        else:
            left = mid + 1
    
    return result

# Example usage
print(ship_within_days([1,2,3,4,5,6,7,8,9,10], 5))  # Output: 15
```

### 4.5 Problem: Koko Eating Bananas (LeetCode 875)

```python
import math

def min_eating_speed(piles, h):
    """
    Find minimum eating speed k such that all bananas are eaten in h hours.
    
    Example: piles = [3,6,7,11], h = 8
    Output: 4
    """
    def can_eat_all(speed):
        """Check if all piles can be eaten at this speed."""
        hours = 0
        for pile in piles:
            hours += math.ceil(pile / speed)
        return hours <= h
    
    left, right = 1, max(piles)
    result = right
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if can_eat_all(mid):
            result = mid
            right = mid - 1  # Try slower speed
        else:
            left = mid + 1
    
    return result

# Example usage
print(min_eating_speed([3, 6, 7, 11], 8))  # Output: 4
```

---

## 5. Advanced Patterns

### 5.1 Search in Rotated Sorted Array

**üîë Key Insight:** At least one half is always sorted
**Pattern:** Determine which half is sorted, then decide where to search

```python
def search_rotated_array(nums, target):
    """
    Search in rotated sorted array.
    
    Example: nums = [4,5,6,7,0,1,2], target = 0
    Output: 4
    """
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if nums[mid] == target:
            return mid
        
        # Determine which half is sorted
        if nums[left] <= nums[mid]:  # Left half is sorted
            if nums[left] <= target < nums[mid]:
                right = mid - 1  # Target in left half
            else:
                left = mid + 1   # Target in right half
        else:  # Right half is sorted
            if nums[mid] < target <= nums[right]:
                left = mid + 1   # Target in right half
            else:
                right = mid - 1  # Target in left half
    
    return -1

# Example usage
print(search_rotated_array([4, 5, 6, 7, 0, 1, 2], 0))  # Output: 4
```

### 5.2 Find Minimum in Rotated Sorted Array

```python
def find_min_rotated(nums):
    """
    Find minimum in rotated sorted array.
    
    Example: nums = [4,5,6,7,0,1,2]
    Output: 0
    """
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = left + (right - left) // 2
        
        # If mid element is greater than right element,
        # minimum is in right half
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid  # mid could be the minimum
    
    return nums[left]

# Example usage
print(find_min_rotated([4, 5, 6, 7, 0, 1, 2]))  # Output: 0
```

### 5.3 Find Peak Element

**üîë Insight:** Always move towards higher elements

```python
def find_peak_element(nums):
    """
    Find a peak element (greater than neighbors).
    
    Example: nums = [1,2,3,1]
    Output: 2 (index of element 3)
    """
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = left + (right - left) // 2
        
        if nums[mid] < nums[mid + 1]:
            # Peak is in right half
            left = mid + 1
        else:
            # Peak is in left half or at mid
            right = mid
    
    return left

# Example usage
print(find_peak_element([1, 2, 3, 1]))  # Output: 2
```

### 5.4 Search in 2D Matrix (Sorted Rows & Columns)

**Pattern:** Start from top-right or bottom-left corner

```python
def search_matrix(matrix, target):
    """
    Search in 2D matrix where each row and column is sorted.
    
    Example:
    matrix = [[1,4,7,11],
              [2,5,8,12],
              [3,6,9,16],
              [10,13,14,17]]
    target = 5
    Output: True
    """
    if not matrix or not matrix[0]:
        return False
    
    rows, cols = len(matrix), len(matrix[0])
    row, col = 0, cols - 1  # Start from top-right
    
    while row < rows and col >= 0:
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] > target:
            col -= 1  # Move left
        else:
            row += 1  # Move down
    
    return False

# Example usage
matrix = [[1,4,7,11],[2,5,8,12],[3,6,9,16],[10,13,14,17]]
print(search_matrix(matrix, 5))   # Output: True
print(search_matrix(matrix, 20))  # Output: False
```

### 5.5 Median of Two Sorted Arrays (Hard)

**üîë Insight:** Binary search on the smaller array's partition

```python
def find_median_sorted_arrays(nums1, nums2):
    """
    Find median of two sorted arrays in O(log(min(m,n))).
    
    Example: nums1 = [1,3], nums2 = [2]
    Output: 2.0
    """
    # Ensure nums1 is the smaller array
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1
    
    m, n = len(nums1), len(nums2)
    left, right = 0, m
    
    while left <= right:
        partition1 = (left + right) // 2
        partition2 = (m + n + 1) // 2 - partition1
        
        # Handle edge cases
        maxLeft1 = float('-inf') if partition1 == 0 else nums1[partition1 - 1]
        minRight1 = float('inf') if partition1 == m else nums1[partition1]
        
        maxLeft2 = float('-inf') if partition2 == 0 else nums2[partition2 - 1]
        minRight2 = float('inf') if partition2 == n else nums2[partition2]
        
        # Check if we found the correct partition
        if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:
            # Found correct partition
            if (m + n) % 2 == 0:
                return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2
            else:
                return max(maxLeft1, maxLeft2)
        elif maxLeft1 > minRight2:
            right = partition1 - 1
        else:
            left = partition1 + 1
    
    raise ValueError("Arrays are not sorted")

# Example usage
print(find_median_sorted_arrays([1, 3], [2]))     # Output: 2.0
print(find_median_sorted_arrays([1, 2], [3, 4]))  # Output: 2.5
```

---

## 6. Common Pitfalls & Edge Cases

### 6.1 Integer Overflow
```python
# ‚ùå WRONG: Can overflow in other languages
mid = (left + right) // 2

# ‚úÖ CORRECT: Prevents overflow
mid = left + (right - left) // 2
```

### 6.2 Infinite Loops

**Problem:** Using `left < right` with wrong update

```python
# ‚ùå WRONG: Infinite loop possible
while left < right:
    mid = left + (right - left) // 2
    if condition(mid):
        left = mid  # ‚ö†Ô∏è Can cause infinite loop!
    else:
        right = mid - 1

# ‚úÖ CORRECT: Update properly
while left < right:
    mid = left + (right - left) // 2
    if condition(mid):
        left = mid + 1  # Always make progress
    else:
        right = mid
```

### 6.3 Edge Cases Checklist

**Always test:**
- ‚úÖ Empty array: `[]`
- ‚úÖ Single element: `[5]`
- ‚úÖ Two elements: `[3, 5]`
- ‚úÖ Target at start: `arr[0]`
- ‚úÖ Target at end: `arr[-1]`
- ‚úÖ Target not in array
- ‚úÖ All elements same: `[5, 5, 5, 5]`
- ‚úÖ Duplicates present

### 6.4 Boundary Conditions

```python
def handle_edge_cases(arr, target):
    """Always handle edge cases first."""
    # Empty array
    if not arr:
        return -1
    
    # Single element
    if len(arr) == 1:
        return 0 if arr[0] == target else -1
    
    # Target out of range
    if target < arr[0] or target > arr[-1]:
        return -1
    
    # Now do binary search...
```

---

## 7. Interview Problem Patterns

### 7.1 Pattern Recognition Guide

| Pattern | When to Use | Template |
|---------|-------------|----------|
| **Exact Match** | Find specific value | `left <= right`, return index |
| **Left Boundary** | First occurrence | Save result, `right = mid - 1` |
| **Right Boundary** | Last occurrence | Save result, `left = mid + 1` |
| **Insert Position** | Where to insert | `left < right`, return `left` |
| **Search Answer** | Min/max with condition | Binary search on answer range |
| **Rotated Array** | Array rotated | Check which half is sorted |
| **Peak Finding** | Find local maximum | Move toward higher values |
| **2D Matrix** | Sorted 2D search | Start corner, eliminate row/col |

### 7.2 Quick Decision Tree

```
Is the data sorted?
‚îú‚îÄ Yes
‚îÇ  ‚îú‚îÄ Find exact value? ‚Üí Classic Binary Search
‚îÇ  ‚îú‚îÄ Find boundary? ‚Üí Left/Right Boundary Search
‚îÇ  ‚îú‚îÄ Array rotated? ‚Üí Rotated Array Search
‚îÇ  ‚îî‚îÄ 2D matrix? ‚Üí Matrix Search
‚îÇ
‚îî‚îÄ No, but can check condition?
   ‚îî‚îÄ Searching for optimal value? ‚Üí Binary Search on Answer
```

### 7.3 Practice Problems Roadmap

**Easy:**
1. Binary Search (LeetCode 704)
2. Search Insert Position (LeetCode 35)
3. First Bad Version (LeetCode 278)
4. Square Root (LeetCode 69)

**Medium:**
5. Find First and Last Position (LeetCode 34)
6. Search in Rotated Array (LeetCode 33)
7. Find Peak Element (LeetCode 162)
8. Koko Eating Bananas (LeetCode 875)
9. Capacity to Ship Packages (LeetCode 1011)
10. Split Array Largest Sum (LeetCode 410)

**Hard:**
11. Median of Two Sorted Arrays (LeetCode 4)
12. Find K Closest Elements (LeetCode 658)
13. Minimum in Rotated Array II (LeetCode 154) - with duplicates
14. Count of Smaller Numbers After Self (LeetCode 315)

### 7.4 Interview Tips

**‚úÖ DO:**
- Draw diagrams to visualize the search space
- State your assumptions clearly
- Test with edge cases verbally
- Explain why binary search applies
- Mention time/space complexity

**‚ùå DON'T:**
- Jump into coding without clarification
- Forget to handle edge cases
- Use `left < right` and `left <= right` inconsistently
- Forget to check for empty input
- Assume array has no duplicates (clarify first)

### 7.5 Template Selection Guide

```python
# Use this for EXACT MATCH
while left <= right:
    # ...
    if arr[mid] == target: return mid
    # ...

# Use this for BOUNDARY SEARCH
while left <= right:
    # ...
    if arr[mid] == target:
        result = mid
        right = mid - 1  # or left = mid + 1
    # ...

# Use this for INSERT POSITION
while left < right:
    # ...
    if arr[mid] < target:
        left = mid + 1
    else:
        right = mid
    # ...
return left
```

---

## Summary: Master Checklist

**Before coding:**
- [ ] Identify if problem needs binary search
- [ ] Determine search space (array, answer range, etc.)
- [ ] Choose correct template (exact, boundary, insert, answer)
- [ ] Consider edge cases

**While coding:**
- [ ] Use `mid = left + (right - left) // 2`
- [ ] Correctly update `left` and `right`
- [ ] Maintain loop invariant
- [ ] Handle array bounds

**After coding:**
- [ ] Test with edge cases
- [ ] Verify time complexity: O(log n)
- [ ] Check for off-by-one errors
- [ ] Ensure no infinite loops

**Key Takeaway:** Binary search isn't just about finding elements in sorted arrays‚Äîit's a powerful technique for finding optimal answers in any monotonic search space. Master the templates, understand the patterns, and you'll be ready for any interview challenge!

---

*Good luck with your interviews! üöÄ*