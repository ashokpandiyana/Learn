# Chapter 2: Classic Binary Search - In-Depth Guide

## Table of Contents
1. [The Standard Template](#the-standard-template)
2. [Step-by-Step Execution](#step-by-step-execution)
3. [Understanding the Middle Point Calculation](#understanding-the-middle-point-calculation)
4. [Iterative vs Recursive Implementation](#iterative-vs-recursive-implementation)
5. [Common Mistakes and How to Avoid Them](#common-mistakes-and-how-to-avoid-them)
6. [Variations of the Classic Search](#variations-of-the-classic-search)

---

## 1. The Standard Template

### 1.1 The Core Algorithm

The classic binary search finds the **exact position** of a target value in a sorted array.

```python
def binary_search(arr, target):
    """
    Standard binary search template for finding exact match.
    
    Args:
        arr: Sorted array of comparable elements
        target: Value to search for
    
    Returns:
        Index of target if found, -1 otherwise
    
    Time: O(log n)
    Space: O(1)
    """
    left, right = 0, len(arr) - 1
    
    # Use <= because we want to check when left == right
    while left <= right:
        # Calculate middle (overflow-safe method)
        mid = left + (right - left) // 2
        
        # Three cases to handle
        if arr[mid] == target:
            return mid              # Found target
        elif arr[mid] < target:
            left = mid + 1          # Target is in right half
        else:
            right = mid - 1         # Target is in left half
    
    return -1                       # Target not found

# Test cases
if __name__ == "__main__":
    arr = [1, 3, 5, 7, 9, 11, 13, 15]
    
    print("Array:", arr)
    print(f"Search for 7: index {binary_search(arr, 7)}")    # Found: 3
    print(f"Search for 1: index {binary_search(arr, 1)}")    # Found: 0 (first)
    print(f"Search for 15: index {binary_search(arr, 15)}")  # Found: 7 (last)
    print(f"Search for 6: index {binary_search(arr, 6)}")    # Not found: -1
```

### 1.2 Anatomy of the Template

Let's break down each component:

```python
def binary_search_annotated(arr, target):
    """Fully annotated binary search with explanations."""
    
    # INITIALIZATION PHASE
    # ===================
    # left: leftmost boundary of search space
    # right: rightmost boundary of search space
    # Invariant: if target exists, it's in arr[left:right+1]
    left, right = 0, len(arr) - 1
    print(f"Initial search space: indices [{left}, {right}]")
    print(f"Initial search space: values {arr[left:right+1]}\n")
    
    step = 0
    # SEARCH PHASE
    # ============
    # Continue while search space is valid (left <= right)
    while left <= right:
        step += 1
        print(f"--- Step {step} ---")
        
        # CALCULATE MIDDLE
        # This prevents integer overflow in other languages
        # In Python, integers don't overflow, but it's best practice
        mid = left + (right - left) // 2
        print(f"Checking middle: index {mid}, value {arr[mid]}")
        
        # DECISION MAKING
        # ===============
        
        # Case 1: Found the target!
        if arr[mid] == target:
            print(f"‚úì Target found at index {mid}!\n")
            return mid
        
        # Case 2: Target is in right half
        # arr[mid] < target means target > arr[mid]
        # So target can't be in left half or at mid
        elif arr[mid] < target:
            print(f"arr[{mid}]={arr[mid]} < {target}")
            print(f"Eliminate left half: arr[{left}:{mid}]")
            left = mid + 1  # Search right half, excluding mid
            print(f"New search space: [{left}, {right}]")
        
        # Case 3: Target is in left half
        # arr[mid] > target means target < arr[mid]
        # So target can't be in right half or at mid
        else:
            print(f"arr[{mid}]={arr[mid]} > {target}")
            print(f"Eliminate right half: arr[{mid}:{right+1}]")
            right = mid - 1  # Search left half, excluding mid
            print(f"New search space: [{left}, {right}]")
        
        print()
    
    # TERMINATION PHASE
    # =================
    # If we exit the loop, left > right (search space exhausted)
    print(f"Search space exhausted: left={left} > right={right}")
    print("‚úó Target not found\n")
    return -1

# Demonstration
arr = [1, 3, 5, 7, 9, 11, 13, 15]
print("="*60)
print("FINDING TARGET THAT EXISTS")
print("="*60)
binary_search_annotated(arr, 11)

print("\n" + "="*60)
print("FINDING TARGET THAT DOESN'T EXIST")
print("="*60)
binary_search_annotated(arr, 10)
```

---

## 2. Step-by-Step Execution

### 2.1 Visual Walkthrough - Target Found

```python
def visual_binary_search(arr, target):
    """
    Visual representation of binary search execution.
    """
    left, right = 0, len(arr) - 1
    step = 0
    
    print(f"Searching for: {target}")
    print(f"Array: {arr}")
    print(f"Indices: {list(range(len(arr)))}\n")
    
    while left <= right:
        step += 1
        mid = left + (right - left) // 2
        
        # Create visual representation
        visual = ['.' for _ in range(len(arr))]
        visual[left] = 'L'
        visual[right] = 'R'
        visual[mid] = 'M'
        
        print(f"Step {step}:")
        print(f"  Values:  {arr}")
        print(f"  Pointers: {visual}")
        print(f"  Indices: {list(range(len(arr)))}")
        print(f"  left={left}, mid={mid}, right={right}")
        print(f"  arr[mid]={arr[mid]}")
        
        if arr[mid] == target:
            print(f"  ‚úì FOUND at index {mid}!\n")
            return mid
        elif arr[mid] < target:
            print(f"  arr[mid] < target ‚Üí search right")
            left = mid + 1
        else:
            print(f"  arr[mid] > target ‚Üí search left")
            right = mid - 1
        print()
    
    print(f"  ‚úó NOT FOUND\n")
    return -1

# Example 1: Target exists
arr = [2, 5, 8, 12, 16, 23, 38, 45, 56, 67, 78]
print("="*70)
print("EXAMPLE 1: Target EXISTS in array")
print("="*70)
visual_binary_search(arr, 23)

print("\n" + "="*70)
print("EXAMPLE 2: Target DOESN'T EXIST in array")
print("="*70)
visual_binary_search(arr, 25)
```

### 2.2 Search Space Evolution

```python
def track_search_space(arr, target):
    """
    Track how the search space shrinks at each step.
    """
    left, right = 0, len(arr) - 1
    step = 0
    
    print(f"Target: {target}")
    print(f"Initial search space size: {len(arr)} elements")
    print(f"Initial range: {arr}\n")
    
    while left <= right:
        step += 1
        space_size = right - left + 1
        mid = left + (right - left) // 2
        current_space = arr[left:right+1]
        
        print(f"Step {step}:")
        print(f"  Space size: {space_size} elements")
        print(f"  Space: {current_space}")
        print(f"  Middle value: {arr[mid]}")
        print(f"  Reduction: {100 * (len(arr) - space_size) / len(arr):.1f}% eliminated")
        
        if arr[mid] == target:
            print(f"  ‚úì Found!")
            break
        elif arr[mid] < target:
            left = mid + 1
            print(f"  ‚Üí Eliminate left half")
        else:
            right = mid - 1
            print(f"  ‚Üí Eliminate right half")
        print()

arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31]
track_search_space(arr, 25)
```

---

## 3. Understanding the Middle Point Calculation

### 3.1 Why `mid = left + (right - left) // 2`?

```python
def compare_mid_calculations():
    """
    Compare different ways to calculate mid point.
    """
    print("="*70)
    print("COMPARING MID CALCULATION METHODS")
    print("="*70 + "\n")
    
    # Test case 1: Normal range
    left, right = 5, 10
    
    print(f"Case 1: left={left}, right={right}")
    
    # Method 1: Direct average (can overflow in other languages)
    mid1 = (left + right) // 2
    print(f"  Method 1: (left + right) // 2 = ({left} + {right}) // 2 = {mid1}")
    
    # Method 2: Safe method (prevents overflow)
    mid2 = left + (right - left) // 2
    print(f"  Method 2: left + (right - left) // 2 = {left} + ({right} - {left}) // 2 = {mid2}")
    
    print(f"  Result: Both give {mid1} ‚úì")
    print()
    
    # Test case 2: Large numbers (would overflow in 32-bit integer systems)
    print("Case 2: With large numbers (demonstrating overflow prevention)")
    left, right = 2_000_000_000, 2_100_000_000
    
    print(f"  left={left:,}, right={right:,}")
    
    # In Python, this works fine, but in C++/Java with 32-bit ints:
    total = left + right
    print(f"  left + right = {total:,}")
    print(f"  (This would overflow in 32-bit integer systems!)")
    
    mid1 = (left + right) // 2
    mid2 = left + (right - left) // 2
    
    print(f"  Method 1 result: {mid1:,}")
    print(f"  Method 2 result: {mid2:,}")
    print(f"  Both match: {mid1 == mid2} ‚úì")
    print()
    
    # Why Method 2 is safer
    print("Why Method 2 is better:")
    print("  ‚Ä¢ Prevents integer overflow in languages with fixed-size integers")
    print("  ‚Ä¢ Same result, safer calculation")
    print("  ‚Ä¢ Industry standard practice")
    print("  ‚Ä¢ Good habit even in Python")

compare_mid_calculations()
```

### 3.2 Rounding Behavior

```python
def demonstrate_rounding():
    """
    Show how integer division rounds in mid calculation.
    """
    print("="*70)
    print("MID CALCULATION ROUNDING BEHAVIOR")
    print("="*70 + "\n")
    
    test_cases = [
        (0, 1),   # 2 elements
        (0, 2),   # 3 elements
        (0, 3),   # 4 elements
        (0, 4),   # 5 elements
        (5, 10),  # 6 elements
        (5, 11),  # 7 elements
    ]
    
    for left, right in test_cases:
        mid = left + (right - left) // 2
        size = right - left + 1
        
        print(f"Range: [{left}, {right}], Size: {size}")
        print(f"  Calculation: {left} + ({right} - {left}) // 2")
        print(f"  = {left} + {right - left} // 2")
        print(f"  = {left} + {(right - left) // 2}")
        print(f"  = {mid}")
        
        if size % 2 == 0:
            print(f"  Note: Even size, mid is lower-middle element")
        else:
            print(f"  Note: Odd size, mid is exact center")
        print()

demonstrate_rounding()
```

---

## 4. Iterative vs Recursive Implementation

### 4.1 Iterative Implementation (Preferred)

```python
def binary_search_iterative(arr, target):
    """
    Iterative binary search - uses a loop.
    
    Advantages:
    ‚Ä¢ O(1) space complexity
    ‚Ä¢ No risk of stack overflow
    ‚Ä¢ Generally faster (no function call overhead)
    ‚Ä¢ Easier to debug
    
    This is the PREFERRED implementation.
    """
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1

# Test
arr = [1, 3, 5, 7, 9, 11, 13, 15]
print("Iterative Implementation:")
print(f"Find 7: {binary_search_iterative(arr, 7)}")
print(f"Find 10: {binary_search_iterative(arr, 10)}")
```

### 4.2 Recursive Implementation

```python
def binary_search_recursive(arr, target, left=None, right=None):
    """
    Recursive binary search - calls itself.
    
    Advantages:
    ‚Ä¢ More elegant/concise code
    ‚Ä¢ Natural divide-and-conquer expression
    ‚Ä¢ Easier to understand conceptually
    
    Disadvantages:
    ‚Ä¢ O(log n) space complexity (call stack)
    ‚Ä¢ Risk of stack overflow with deep recursion
    ‚Ä¢ Function call overhead
    """
    # Initialize on first call
    if left is None:
        left = 0
    if right is None:
        right = len(arr) - 1
    
    # Base case: search space exhausted
    if left > right:
        return -1
    
    # Calculate middle
    mid = left + (right - left) // 2
    
    # Three recursive cases
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        # Recursively search right half
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        # Recursively search left half
        return binary_search_recursive(arr, target, left, mid - 1)

# Test
arr = [1, 3, 5, 7, 9, 11, 13, 15]
print("\nRecursive Implementation:")
print(f"Find 7: {binary_search_recursive(arr, 7)}")
print(f"Find 10: {binary_search_recursive(arr, 10)}")
```

### 4.3 Side-by-Side Comparison

```python
def compare_implementations():
    """
    Compare iterative and recursive implementations.
    """
    import sys
    
    # Helper to trace recursive calls
    def binary_search_recursive_traced(arr, target, left, right, depth=0):
        indent = "  " * depth
        print(f"{indent}Call depth {depth}: search({left}, {right})")
        
        if left > right:
            print(f"{indent}‚Üí Base case: not found")
            return -1
        
        mid = left + (right - left) // 2
        print(f"{indent}‚Üí Check mid={mid}, value={arr[mid]}")
        
        if arr[mid] == target:
            print(f"{indent}‚Üí Found!")
            return mid
        elif arr[mid] < target:
            print(f"{indent}‚Üí Recurse right")
            return binary_search_recursive_traced(arr, target, mid + 1, right, depth + 1)
        else:
            print(f"{indent}‚Üí Recurse left")
            return binary_search_recursive_traced(arr, target, left, mid - 1, depth + 1)
    
    arr = [1, 3, 5, 7, 9, 11, 13, 15]
    target = 13
    
    print("="*70)
    print("RECURSIVE CALL STACK VISUALIZATION")
    print("="*70)
    print(f"Array: {arr}")
    print(f"Target: {target}\n")
    
    result = binary_search_recursive_traced(arr, target, 0, len(arr) - 1)
    print(f"\nResult: index {result}")
    
    print("\n" + "="*70)
    print("COMPARISON SUMMARY")
    print("="*70)
    print("\nIterative:")
    print("  ‚úì Space: O(1) - only uses variables")
    print("  ‚úì Speed: Faster (no function call overhead)")
    print("  ‚úì Safety: No stack overflow risk")
    print("  ‚Ä¢ Recommended for production code")
    
    print("\nRecursive:")
    print("  ‚úó Space: O(log n) - uses call stack")
    print("  ‚úó Speed: Slower (function call overhead)")
    print("  ‚úó Safety: Can stack overflow with very large arrays")
    print("  ‚úì Clarity: More intuitive conceptually")

compare_implementations()
```

---

## 5. Common Mistakes and How to Avoid Them

### 5.1 Mistake #1: Wrong Loop Condition

```python
def mistake_loop_condition():
    """
    Common mistake: Using wrong loop condition.
    """
    arr = [1, 3, 5, 7, 9]
    target = 1  # First element
    
    print("="*70)
    print("MISTAKE #1: Wrong Loop Condition")
    print("="*70 + "\n")
    
    # WRONG: Using left < right
    print("‚ùå WRONG: while left < right")
    left, right = 0, len(arr) - 1
    
    while left < right:  # ‚ùå BUG: Exits too early
        mid = left + (right - left) // 2
        if arr[mid] == target:
            print(f"Found at {mid}")
            break
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    else:
        print(f"Not found (but target IS at index 0!)")
        print(f"Final: left={left}, right={right}")
        print(f"Bug: Loop exited when left==right, didn't check arr[0]")
    
    print("\n‚úÖ CORRECT: while left <= right")
    left, right = 0, len(arr) - 1
    
    while left <= right:  # ‚úÖ Checks all elements including when left==right
        mid = left + (right - left) // 2
        if arr[mid] == target:
            print(f"Found at {mid} ‚úì")
            break
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

mistake_loop_condition()
```

### 5.2 Mistake #2: Incorrect Boundary Updates

```python
def mistake_boundary_updates():
    """
    Common mistake: Not excluding the middle element.
    """
    arr = [1, 3, 5, 7, 9, 11, 13]
    target = 10  # Doesn't exist
    
    print("\n" + "="*70)
    print("MISTAKE #2: Incorrect Boundary Updates")
    print("="*70 + "\n")
    
    # WRONG: Not excluding mid
    print("‚ùå WRONG: left = mid or right = mid (can cause infinite loop)")
    left, right = 0, len(arr) - 1
    iterations = 0
    max_iter = 20
    
    while left <= right and iterations < max_iter:
        iterations += 1
        mid = left + (right - left) // 2
        print(f"Iter {iterations}: left={left}, mid={mid}, right={right}, arr[mid]={arr[mid]}")
        
        if arr[mid] == target:
            break
        elif arr[mid] < target:
            left = mid  # ‚ùå BUG: Doesn't exclude mid
        else:
            right = mid - 1
    
    if iterations >= max_iter:
        print(f"‚ö†Ô∏è Infinite loop! Stopped after {max_iter} iterations")
        print("Problem: Not excluding mid when updating left")
    
    print("\n‚úÖ CORRECT: left = mid + 1 or right = mid - 1")
    left, right = 0, len(arr) - 1
    iterations = 0
    
    while left <= right:
        iterations += 1
        mid = left + (right - left) // 2
        print(f"Iter {iterations}: left={left}, mid={mid}, right={right}, arr[mid]={arr[mid]}")
        
        if arr[mid] == target:
            break
        elif arr[mid] < target:
            left = mid + 1  # ‚úÖ Excludes mid
        else:
            right = mid - 1  # ‚úÖ Excludes mid
    
    print(f"Completed in {iterations} iterations ‚úì")

mistake_boundary_updates()
```

### 5.3 Mistake #3: Off-by-One Errors

```python
def mistake_off_by_one():
    """
    Common mistake: Off-by-one errors in initialization or return.
    """
    arr = [1, 3, 5, 7, 9]
    
    print("\n" + "="*70)
    print("MISTAKE #3: Off-by-One Errors")
    print("="*70 + "\n")
    
    # WRONG: Incorrect initialization
    print("‚ùå WRONG: right = len(arr) (should be len(arr) - 1)")
    left, right = 0, len(arr)  # ‚ùå BUG: right is out of bounds
    
    try:
        while left <= right:
            mid = left + (right - left) // 2
            print(f"Checking mid={mid}")
            # This could cause IndexError!
            if mid < len(arr) and arr[mid] == 5:
                print(f"Found at {mid}")
                break
            elif mid >= len(arr) or arr[mid] < 5:
                left = mid + 1
            else:
                right = mid - 1
    except IndexError as e:
        print(f"‚ùå IndexError: {e}")
    
    print("\n‚úÖ CORRECT: right = len(arr) - 1")
    left, right = 0, len(arr) - 1  # ‚úÖ Correct bounds
    
    while left <= right:
        mid = left + (right - left) // 2
        print(f"Checking mid={mid}")
        if arr[mid] == 5:
            print(f"Found at {mid} ‚úì")
            break
        elif arr[mid] < 5:
            left = mid + 1
        else:
            right = mid - 1

mistake_off_by_one()
```

### 5.4 Mistake #4: Not Handling Edge Cases

```python
def mistake_edge_cases():
    """
    Common mistake: Not handling edge cases.
    """
    print("\n" + "="*70)
    print("MISTAKE #4: Not Handling Edge Cases")
    print("="*70 + "\n")
    
    def binary_search_no_check(arr, target):
        """Binary search without edge case handling."""
        left, right = 0, len(arr) - 1  # ‚ùå Crashes if arr is empty!
        
        while left <= right:
            mid = left + (right - left) // 2
            if arr[mid] == target:
                return mid
            elif arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1
    
    def binary_search_with_checks(arr, target):
        """Binary search WITH edge case handling."""
        # ‚úÖ Handle edge cases first
        if not arr:  # Empty array
            return -1
        if len(arr) == 1:  # Single element
            return 0 if arr[0] == target else -1
        
        # Now do normal binary search
        left, right = 0, len(arr) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if arr[mid] == target:
                return mid
            elif arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1
    
    # Test cases
    test_cases = [
        ([], 5, "Empty array"),
        ([5], 5, "Single element - found"),
        ([5], 3, "Single element - not found"),
        ([1, 2, 3], 1, "First element"),
        ([1, 2, 3], 3, "Last element"),
    ]
    
    print("Testing WITHOUT edge case handling:")
    for arr, target, desc in test_cases:
        try:
            result = binary_search_no_check(arr, target)
            print(f"  {desc}: {result}")
        except Exception as e:
            print(f"  {desc}: ‚ùå ERROR - {e}")
    
    print("\nTesting WITH edge case handling:")
    for arr, target, desc in test_cases:
        result = binary_search_with_checks(arr, target)
        print(f"  {desc}: {result} ‚úì")

mistake_edge_cases()
```

---

## 6. Variations of the Classic Search

### 6.1 Binary Search with Custom Comparator

```python
def binary_search_custom_comparator():
    """
    Binary search with custom comparison function.
    """
    print("\n" + "="*70)
    print("VARIATION: Custom Comparator")
    print("="*70 + "\n")
    
    # Example 1: Search by object property
    class Person:
        def __init__(self, name, age):
            self.name = name
            self.age = age
        
        def __repr__(self):
            return f"Person({self.name}, {self.age})"
    
    people = [
        Person("Alice", 25),
        Person("Bob", 30),
        Person("Charlie", 35),
        Person("David", 40),
        Person("Eve", 45)
    ]
    
    def search_by_age(people, target_age):
        """Binary search for person by age."""
        left, right = 0, len(people) - 1
        
        while left <= right:
            mid = left + (right - left) // 2
            
            if people[mid].age == target_age:
                return mid
            elif people[mid].age < target_age:
                left = mid + 1
            else:
                right = mid - 1
        
        return -1
    
    print("People sorted by age:", people)
    target_age = 35
    idx = search_by_age(people, target_age)
    if idx != -1:
        print(f"Found person aged {target_age}: {people[idx]}")
    
    # Example 2: Case-insensitive string search
    print("\n" + "-"*70)
    
    words = ["apple", "banana", "cherry", "date", "elderberry"]
    
    def search_case_insensitive(words, target):
        """Binary search ignoring case."""
        target_lower = target.lower()
        left, right = 0, len(words) - 1
        
        while left <= right:
            mid = left + (right - left) // 2
            mid_lower = words[mid].lower()
            
            if mid_lower == target_lower:
                return mid
            elif mid_lower < target_lower:
                left = mid + 1
            else:
                right = mid - 1
        
        return -1
    
    print("Words:", words)
    target = "CHERRY"
    idx = search_case_insensitive(words, target)
    if idx != -1:
        print(f"Found '{target}' at index {idx}: '{words[idx]}'")

binary_search_custom_comparator()
```

### 6.2 Binary Search on Rotated Array (Preview)

```python
def binary_search_rotated_preview():
    """
    Preview of search in rotated sorted array (advanced topic).
    """
    print("\n" + "="*70)
    print("PREVIEW: Search in Rotated Sorted Array")
    print("="*70 + "\n")
    
    def search_rotated(arr, target):
        """
        Modified binary search for rotated sorted array.
        """
        left, right = 0, len(arr) - 1
        
        while left <= right:
            mid = left + (right - left) // 2
            
            if arr[mid] == target:
                return mid
            
            # Determine which half is sorted
            if arr[left] <= arr[mid]:  # Left half is sorted
                if arr[left] <= target < arr[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:  # Right half is sorted
                if arr[mid] < target <= arr[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        
        return -1
    
    arr = [4, 5, 6, 7, 0, 1, 2]
    print(f"Rotated array: {arr}")
    print("(Originally: [0, 1, 2, 4, 5, 6, 7], rotated right)")
    
    test_targets = [0, 4, 7, 3]
    for target in test_targets:
        idx = search_rotated(arr, target)
        if idx != -1:
            print(f"  Target {target}: found at index {idx}")
        else:
            print(f"  Target {target}: not found")
    
    print("\n(Full explanation in Chapter 5: Advanced Patterns)")

binary_search_rotated_preview()
```

---

## Summary: Key Takeaways

### The Standard Template (Memorize This!)

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:                      # Use <=
        mid = left + (right - left) // 2      # Overflow-safe
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1                    # Exclude mid
        else:
            right = mid - 1                   # Exclude mid
    
    return -1
```

### Critical Points

‚úÖ **DO:**
- Use `while left <= right` for exact search
- Calculate `mid = left + (right - left) // 2`
- Update with `left = mid + 1` or `right = mid - 1`
- Handle edge cases (empty array, single element)
- Test with targets at boundaries

‚ùå **DON'T:**
- Use `while left < right` for exact search
- Forget to exclude mid in updates (`left = mid`)
- Use `mid = (left + right) // 2` in other languages (overflow risk)
- Forget to handle edge cases
- Assume array has no duplicates

### Complexity Review

| Aspect | Iterative | Recursive |
|--------|-----------|-----------|
| Time | O(log n) | O(log n) |
| Space | O(1) | O(log n) |
| Stack Overflow Risk | No | Yes |
| Preferred | ‚úì Yes | Only for learning |

**Next:** Chapter 3 will explore powerful variants like finding first/last occurrence, insert positions, and more!

---

*Practice the standard template until it becomes second nature!* üéØ