# Chapter 2: Core Operations on Trie

## 2.1 Insertion Operation

### Conceptual Understanding

Insertion in a Trie is like creating a path through a maze - if the path exists, we follow it; if not, we build it as we go.

**Algorithm Flow:**
```
1. Start at root
2. For each character in word:
   a. Check if child node exists for this character
   b. If NO â†’ create new child node
   c. If YES â†’ move to existing child
3. Mark the final node as end-of-word
```

### Visual Example: Step-by-Step Insertion

Let's insert "cat" into an empty trie:

```
Step 0: Empty trie
    ROOT

Step 1: Insert 'c'
    ROOT
     |
     c

Step 2: Insert 'a'
    ROOT
     |
     c
     |
     a

Step 3: Insert 't' and mark end
    ROOT
     |
     c
     |
     a
     |
     t*
```

Now insert "car" (shares prefix "ca"):
```
    ROOT
     |
     c
     |
     a
    / \
   t*  r*
   
Notice: We reused 'c' and 'a' nodes!
```

### Complete Implementation

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False
        self.frequency = 0  # How many times this word was inserted

class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word: str) -> None:
        """
        Insert word into trie
        Time: O(m) where m = len(word)
        Space: O(m) worst case (when no prefix sharing)
        """
        # Validate input
        if not word:
            return
        
        current = self.root
        
        # Traverse/build path for each character
        for char in word:
            # Create node if doesn't exist
            if char not in current.children:
                current.children[char] = TrieNode()
            
            # Move to child node
            current = current.children[char]
        
        # Mark end of word and update frequency
        current.is_end_of_word = True
        current.frequency += 1
    
    def insert_batch(self, words: list) -> None:
        """Insert multiple words efficiently"""
        for word in words:
            self.insert(word)
```

### Edge Cases & Handling

#### Case 1: Empty String Insertion
```python
def insert(self, word: str) -> None:
    if not word:  # Edge case
        self.root.is_end_of_word = True  # Empty string is valid word
        return
    # ... rest of insertion
```

#### Case 2: Duplicate Insertion
```python
# First insertion of "cat"
trie.insert("cat")  # frequency = 1

# Second insertion of "cat"
trie.insert("cat")  # frequency = 2
# No new nodes created, just frequency updated
```

#### Case 3: Case Sensitivity
```python
def insert(self, word: str, case_sensitive: bool = True) -> None:
    if not case_sensitive:
        word = word.lower()  # Normalize
    # ... rest of insertion
```

### Time & Space Complexity Analysis

**Time Complexity: O(m)**
- m = length of word
- Each character processed exactly once
- Dictionary lookup/insertion: O(1) average

**Space Complexity:**
- **Worst case**: O(m) - completely new word with no shared prefixes
- **Best case**: O(1) - word already exists completely
- **Average case**: O(k) - k new nodes needed

**Memory Overhead per Node:**
```python
# HashMap-based
node_size = sys.getsizeof(dict()) + sys.getsizeof(bool())
# â‰ˆ 240 + 28 = 268 bytes per node

# For word "hello" (no sharing): 5 nodes Ã— 268 = 1,340 bytes
```

---

## 2.2 Search Operations

### 2.2.1 Exact Word Search

**Goal**: Determine if exact word exists in Trie

```python
def search(self, word: str) -> bool:
    """
    Search for exact word match
    Time: O(m) where m = len(word)
    Space: O(1) - no extra space needed
    
    Returns: True if word exists, False otherwise
    """
    if not word:
        return self.root.is_end_of_word
    
    current = self.root
    
    # Try to traverse the path
    for char in word:
        if char not in current.children:
            return False  # Path doesn't exist
        current = current.children[char]
    
    # Path exists, but is it marked as a word?
    return current.is_end_of_word


# Example usage
trie = Trie()
trie.insert("cat")
trie.insert("cats")

print(trie.search("cat"))   # True - exact word exists
print(trie.search("cats"))  # True - exact word exists
print(trie.search("ca"))    # False - prefix exists but not a word
print(trie.search("caterpillar"))  # False - doesn't exist
```

**Key Insight:** The function returns `True` ONLY if:
1. The path exists (all characters found)
2. AND the final node is marked as end-of-word

### 2.2.2 Prefix Search

**Goal**: Check if ANY word starts with given prefix

```python
def starts_with(self, prefix: str) -> bool:
    """
    Check if any word has this prefix
    Time: O(p) where p = len(prefix)
    Space: O(1)
    
    Returns: True if prefix exists, False otherwise
    """
    if not prefix:
        return True  # Empty prefix always exists
    
    current = self.root
    
    # Try to traverse the prefix path
    for char in prefix:
        if char not in current.children:
            return False  # Path doesn't exist
        current = current.children[char]
    
    # Path exists (don't need to check is_end_of_word)
    return True


# Example
trie.insert("apple")
trie.insert("application")

print(trie.starts_with("app"))    # True
print(trie.starts_with("appl"))   # True
print(trie.starts_with("apply"))  # False - no word starts with "apply"
```

**Difference from Exact Search:**
- Don't check `is_end_of_word`
- Only verify path exists
- Used for autocomplete, typeahead features

### 2.2.3 Advanced Search: Wildcard Support

**Problem**: Search with '.' as wildcard matching any character

```python
def search_with_wildcard(self, word: str) -> bool:
    """
    Search with '.' as wildcard (matches any single character)
    Example: "b.t" matches "bat", "bit", "but"
    
    Time: O(26^w Ã— m) worst case where w = wildcards, m = word length
    Space: O(m) for recursion stack
    """
    def dfs(node, index):
        # Base case: reached end of word
        if index == len(word):
            return node.is_end_of_word
        
        char = word[index]
        
        if char == '.':
            # Try all possible children
            for child in node.children.values():
                if dfs(child, index + 1):
                    return True
            return False
        else:
            # Normal character
            if char not in node.children:
                return False
            return dfs(node.children[char], index + 1)
    
    return dfs(self.root, 0)


# Example
trie = Trie()
trie.insert("bad")
trie.insert("dad")
trie.insert("mad")

print(trie.search_with_wildcard("bad"))   # True
print(trie.search_with_wildcard(".ad"))   # True - matches bad, dad, mad
print(trie.search_with_wildcard("b.."))   # True - matches bad
print(trie.search_with_wildcard("..."))   # True - matches all 3-letter words
```

### 2.2.4 Get All Words with Prefix

**Problem**: Return all words starting with given prefix

```python
def find_all_words_with_prefix(self, prefix: str) -> list:
    """
    Return all words starting with prefix
    Time: O(p + n) where p = prefix length, n = total nodes in subtree
    Space: O(n) for storing results
    """
    result = []
    
    # First, navigate to the prefix node
    current = self.root
    for char in prefix:
        if char not in current.children:
            return []  # Prefix doesn't exist
        current = current.children[char]
    
    # DFS to collect all words from this point
    def dfs(node, path):
        if node.is_end_of_word:
            result.append(prefix + path)
        
        for char, child in node.children.items():
            dfs(child, path + char)
    
    dfs(current, "")
    return result


# Example
trie = Trie()
words = ["apple", "app", "application", "apply", "ape", "apricot"]
for word in words:
    trie.insert(word)

print(trie.find_all_words_with_prefix("app"))
# Output: ['app', 'apple', 'application', 'apply']

print(trie.find_all_words_with_prefix("apr"))
# Output: ['apricot']
```

---

## 2.3 Deletion Operation

### Why Deletion is Complex

Unlike insertion, deletion must handle several cases:
1. Word is unique (delete entire path)
2. Word is prefix of another word (just unmark)
3. Word has a prefix that's also a word (partial deletion)
4. Word shares prefix with others (partial deletion)

### Visual Examples of Deletion Cases

#### Case 1: Delete "cat" (unique word)
```
Before:                    After:
    ROOT                      ROOT
     |                         |
     c                         d
    / \                        |
   a   d                       o
   |   |                       |
   t*  o                       g*
       |
       g*

Result: Entire "c-a-t" branch removed
```

#### Case 2: Delete "car" when "card" exists
```
Before:                    After:
    ROOT                      ROOT
     |                         |
     c                         c
     |                         |
     a                         a
     |                         |
     r*                        r (unmarked)
     |                         |
     d*                        d*

Result: Just unmark 'r', keep structure
```

#### Case 3: Delete "card" when "car" exists
```
Before:                    After:
    ROOT                      ROOT
     |                         |
     c                         c
     |                         |
     a                         a
     |                         |
     r*                        r*
     |
     d*

Result: Remove 'd' node only
```

### Implementation: Recursive Deletion

```python
def delete(self, word: str) -> bool:
    """
    Delete word from trie
    Time: O(m) where m = len(word)
    Space: O(m) for recursion stack
    
    Returns: True if word was deleted, False if word didn't exist
    """
    def _delete_helper(node, word, index):
        # Base case: reached end of word
        if index == len(word):
            # Word doesn't exist
            if not node.is_end_of_word:
                return False
            
            # Unmark as end of word
            node.is_end_of_word = False
            
            # Return True if node has no children (can be deleted)
            return len(node.children) == 0
        
        char = word[index]
        
        # Character doesn't exist
        if char not in node.children:
            return False
        
        child = node.children[char]
        should_delete_child = _delete_helper(child, word, index + 1)
        
        # Delete child if needed
        if should_delete_child:
            del node.children[char]
            
            # Return True if current node can also be deleted
            # Can delete if: no children AND not end of another word
            return len(node.children) == 0 and not node.is_end_of_word
        
        return False
    
    return _delete_helper(self.root, word, 0)


# Example usage
trie = Trie()
trie.insert("car")
trie.insert("card")
trie.insert("care")
trie.insert("cat")

print(trie.delete("card"))      # True - deleted successfully
print(trie.search("card"))      # False
print(trie.search("car"))       # True - still exists
print(trie.delete("cat"))       # True
print(trie.delete("dog"))       # False - didn't exist
```

### Iterative Deletion (Alternative)

```python
def delete_iterative(self, word: str) -> bool:
    """
    Iterative approach to deletion
    Builds path, then deletes from bottom up
    """
    if not word:
        return False
    
    # Step 1: Build path and validate word exists
    path = []
    current = self.root
    
    for char in word:
        if char not in current.children:
            return False  # Word doesn't exist
        path.append((current, char))
        current = current.children[char]
    
    if not current.is_end_of_word:
        return False  # Not a complete word
    
    # Step 2: Unmark end of word
    current.is_end_of_word = False
    
    # Step 3: Delete nodes bottom-up if they're now useless
    # A node is useless if: no children AND not end of word
    if len(current.children) == 0:
        for node, char in reversed(path):
            del node.children[char]
            
            # Stop if node is useful (has children or is end of word)
            if len(node.children) > 0 or node.is_end_of_word:
                break
    
    return True
```

### Lazy Deletion Strategy

For systems where deletion is rare, lazy deletion can be more efficient:

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False
        self.is_deleted = False  # Soft delete flag

def delete_lazy(self, word: str) -> bool:
    """
    Mark word as deleted without restructuring
    Good for: frequent insertions, rare deletions
    """
    node = self._find_node(word)
    if node and node.is_end_of_word and not node.is_deleted:
        node.is_deleted = True
        return True
    return False

def search(self, word: str) -> bool:
    """Search must now check deletion flag"""
    node = self._find_node(word)
    return (node and 
            node.is_end_of_word and 
            not node.is_deleted)
```

---

## 2.4 Helper Operations

### Count Total Words

```python
def count_words(self) -> int:
    """
    Count total unique words in trie
    Time: O(n) where n = total nodes
    """
    def dfs(node):
        count = 1 if node.is_end_of_word else 0
        for child in node.children.values():
            count += dfs(child)
        return count
    
    return dfs(self.root)
```

### Get Longest Word

```python
def get_longest_word(self) -> str:
    """
    Find the longest word in trie
    Time: O(n)
    """
    longest = ""
    
    def dfs(node, path):
        nonlocal longest
        
        if node.is_end_of_word and len(path) > len(longest):
            longest = path
        
        for char, child in node.children.items():
            dfs(child, path + char)
    
    dfs(self.root, "")
    return longest
```

### Print All Words (Sorted)

```python
def get_all_words(self) -> list:
    """
    Get all words in lexicographic order
    Time: O(n)
    """
    words = []
    
    def dfs(node, path):
        if node.is_end_of_word:
            words.append(path)
        
        # Dictionary iteration is unordered, sort for lexicographic order
        for char in sorted(node.children.keys()):
            dfs(node.children[char], path + char)
    
    dfs(self.root, "")
    return words
```

---

## 2.5 Complete Trie Class with All Operations

```python
class CompleteTrie:
    """Production-ready Trie implementation"""
    
    def __init__(self):
        self.root = TrieNode()
        self.size = 0
    
    def insert(self, word: str) -> None:
        """Insert word - O(m)"""
        if not word:
            return
        
        current = self.root
        for char in word:
            if char not in current.children:
                current.children[char] = TrieNode()
            current = current.children[char]
        
        if not current.is_end_of_word:
            self.size += 1
        current.is_end_of_word = True
    
    def search(self, word: str) -> bool:
        """Exact search - O(m)"""
        node = self._find_node(word)
        return node is not None and node.is_end_of_word
    
    def starts_with(self, prefix: str) -> bool:
        """Prefix search - O(p)"""
        return self._find_node(prefix) is not None
    
    def delete(self, word: str) -> bool:
        """Delete word - O(m)"""
        def _delete_helper(node, word, index):
            if index == len(word):
                if not node.is_end_of_word:
                    return False
                node.is_end_of_word = False
                return len(node.children) == 0
            
            char = word[index]
            if char not in node.children:
                return False
            
            should_delete = _delete_helper(node.children[char], word, index + 1)
            
            if should_delete:
                del node.children[char]
                return len(node.children) == 0 and not node.is_end_of_word
            
            return False
        
        if _delete_helper(self.root, word, 0):
            self.size -= 1
            return True
        return False
    
    def _find_node(self, prefix):
        """Helper to find node at end of prefix"""
        current = self.root
        for char in prefix:
            if char not in current.children:
                return None
            current = current.children[char]
        return current
    
    def __len__(self):
        return self.size
    
    def __contains__(self, word):
        return self.search(word)
```

---

## ðŸ§  Practice Problems

Test your understanding with these exercises:

1. **Modification**: Extend the Trie to store the insertion timestamp for each word. How would you retrieve the 5 most recently added words?

2. **Edge Case**: What happens if you delete "car" when the trie only contains "card"? Trace through the deletion algorithm.

3. **Optimization**: In the wildcard search, how can you optimize when there are multiple consecutive wildcards (e.g., "a...")?

4. **Design**: How would you modify the Trie to support case-insensitive search while preserving the original case for retrieval?

5. **Challenge**: Implement a `get_shortest_unique_prefix(word)` function that returns the shortest prefix that uniquely identifies a word in the Trie.

Ready for Chapter 3 on Space Optimization? ðŸš€
