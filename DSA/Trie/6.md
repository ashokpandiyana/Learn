# Chapter 6: Problem-Solving Strategies with Tries

## 6.1 When to Use Trie - Decision Framework

### 6.1.1 The Trie Decision Tree

```
Question: Should I use a Trie?
│
├─ Are you working with strings? ─NO→ Probably not a Trie
│  YES
│  ↓
├─ Do you need prefix-based operations? ─NO→ Consider HashSet/HashMap
│  YES
│  ↓
├─ Multiple queries on same dataset? ─NO→ Overhead might not be worth it
│  YES
│  ↓
├─ Is memory a severe constraint? ─YES→ Consider alternatives (HashSet, Compressed Trie)
│  NO
│  ↓
└─ ✅ Trie is likely a good choice!
```

### 6.1.2 Strong Signals to Use Trie

#### Signal 1: "Find all words starting with..."
```python
# Problem: Autocomplete - given prefix, return all matching words

# ❌ Without Trie: O(N × M) for each query
def autocomplete_naive(words, prefix):
    return [word for word in words if word.startswith(prefix)]

# ✅ With Trie: O(P + K) where P=prefix length, K=results
# Build once: O(N × M), Query: O(P + K)
```

#### Signal 2: Dictionary of words with repeated prefix checks
```python
# Problem: Word validation system (Scrabble, Boggle, etc.)

# Scenario: Check if 1000s of strings are valid words
# If you query each one against a list → O(queries × N × M)
# If you use Trie → Build O(N × M), Query O(queries × M)

# Example: Boggle solver needs to check thousands of paths
```

#### Signal 3: Pattern "search multiple words in a matrix/grid"
```python
# Problem: Word Search II (LeetCode 212)

# Without Trie: For each word, DFS entire grid
# With Trie: Single DFS pass, pruning with trie structure
# Performance difference: 100x+ faster with large word lists
```

#### Signal 4: IP Routing, URL routing, Autocomplete
```python
# Real-world applications:
# - IP routing tables (prefix matching)
# - URL routing in web servers
# - DNS lookups
# - Command-line completion
# - IDE code completion
```

### 6.1.3 When NOT to Use Trie

#### Anti-Pattern 1: Single Query
```python
# ❌ BAD: Building trie for one-time use
def is_word_in_list_once(word, word_list):
    trie = Trie()
    for w in word_list:
        trie.insert(w)
    return trie.search(word)  # Waste of time!

# ✅ GOOD: Just use a set
def is_word_in_list_once(word, word_list):
    return word in set(word_list)  # O(N) build, O(1) lookup
```

#### Anti-Pattern 2: Small Dataset
```python
# ❌ BAD: Trie for 10 words
words = ["cat", "dog", "bird", "fish", "hamster"]
# Overhead of trie structure > benefit

# ✅ GOOD: HashSet is simpler and faster
word_set = set(words)
```

#### Anti-Pattern 3: No Prefix Relationships
```python
# Problem: Check if a number exists in array
# ❌ BAD: Use trie for numbers
# ✅ GOOD: Use HashSet or Binary Search Tree

# Unless... you're doing bit-level operations (Binary Trie for XOR)
```

#### Anti-Pattern 4: Extreme Memory Constraints
```python
# Scenario: Embedded system with 1MB memory
# Word list: 100,000 English words
# 
# Trie space: ~10-20MB (with pointers/objects)
# HashSet space: ~2-3MB
# 
# Decision: Use HashSet or compressed trie
```

### 6.1.4 Comparative Analysis

```python
# Example: Implement autocomplete with 100K words, 1M queries

# Approach 1: Linear Search
# Build: O(1), Query: O(100K × M) × 1M = Too slow!

# Approach 2: Binary Search (sorted array)
# Build: O(100K × log 100K), Query: O(log 100K) × 1M = Acceptable
# Problem: Can't efficiently get all words with prefix

# Approach 3: HashMap of all prefixes
# Build: O(100K × M²), Space: O(100K × M²) = Too much!
# Query: O(1) but insane memory

# Approach 4: Trie
# Build: O(100K × M), Query: O(M + K) × 1M = Optimal!
# Space: O(100K × M) = Reasonable
```

### 6.1.5 Decision Matrix

| Criteria | HashSet | Binary Search | Trie |
|----------|---------|---------------|------|
| Exact Match | ⭐⭐⭐ | ⭐⭐ | ⭐⭐ |
| Prefix Match | ❌ | ⚠️ | ⭐⭐⭐ |
| Memory | ⭐⭐⭐ | ⭐⭐⭐ | ⭐ |
| Build Time | ⭐⭐⭐ | ⭐⭐ | ⭐⭐ |
| Multiple Queries | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| Implementation | ⭐⭐⭐ | ⭐⭐ | ⭐ |

---

## 6.2 Common Combinations with Other Data Structures

### 6.2.1 Trie + DFS (Depth-First Search)

**Use Case**: Explore all words in trie, word search in grid

```python
# Pattern: Generate all words, collect words, path finding

class TrieDFS:
    def get_all_words(self, max_length=None):
        """Collect all words using DFS"""
        result = []
        self._dfs(self.root, "", result, max_length)
        return result
    
    def _dfs(self, node, path, result, max_length):
        # Base case: max length reached
        if max_length and len(path) >= max_length:
            return
        
        # Add word if found
        if node.isEnd:
            result.append(path)
        
        # Explore all children
        for char, child in sorted(node.children.items()):
            self._dfs(child, path + char, result, max_length)

# Application: Word Ladder, Generate all valid words
```

**Interview Problem: Generate Words with Pattern**
```python
def find_words_matching_pattern(trie, pattern):
    """
    Find words matching pattern with wildcards
    Example: "c.t" matches "cat", "cot", "cut"
    """
    result = []
    
    def dfs(node, pattern, idx, path):
        if idx == len(pattern):
            if node.isEnd:
                result.append(path)
            return
        
        if pattern[idx] == '.':
            # Wildcard: try all children
            for char, child in node.children.items():
                dfs(child, pattern, idx + 1, path + char)
        else:
            # Specific character
            char = pattern[idx]
            if char in node.children:
                dfs(node.children[char], pattern, idx + 1, path + char)
    
    dfs(trie.root, pattern, 0, "")
    return result

# LeetCode 211: Design Add and Search Words Data Structure
```

### 6.2.2 Trie + BFS (Breadth-First Search)

**Use Case**: Level-order traversal, shortest path, closest matches

```python
from collections import deque

class TrieBFS:
    def words_by_length(self):
        """Get words grouped by length (BFS level order)"""
        result = []
        queue = deque([(self.root, "", 0)])  # (node, path, level)
        
        current_level = 0
        level_words = []
        
        while queue:
            node, path, level = queue.popleft()
            
            # New level reached
            if level > current_level:
                result.append(level_words)
                level_words = []
                current_level = level
            
            if node.isEnd:
                level_words.append(path)
            
            # Add children to queue
            for char, child in node.children.items():
                queue.append((child, path + char, level + 1))
        
        if level_words:
            result.append(level_words)
        
        return result
    
    def shortest_word_with_prefix(self, prefix):
        """Find shortest word with given prefix using BFS"""
        node = self.root
        
        # Navigate to prefix
        for char in prefix:
            if char not in node.children:
                return None
            node = node.children[char]
        
        # BFS from prefix node
        queue = deque([(node, prefix)])
        
        while queue:
            node, path = queue.popleft()
            
            if node.isEnd:
                return path  # First word found is shortest
            
            for char, child in node.children.items():
                queue.append((child, path + char))
        
        return None

# Application: Shortest transformation, closest match
```

### 6.2.3 Trie + Dynamic Programming

**Use Case**: Word Break problems, optimization problems

```python
# Problem: Word Break I - Can string be segmented?

def word_break_dp_trie(s, word_dict):
    """
    DP + Trie combination
    dp[i] = True if s[0:i] can be segmented
    """
    # Build trie
    trie = Trie()
    for word in word_dict:
        trie.insert(word)
    
    n = len(s)
    dp = [False] * (n + 1)
    dp[0] = True  # Empty string
    
    # For each position
    for i in range(1, n + 1):
        # Try all possible last words ending at i
        node = trie.root
        
        for j in range(i - 1, -1, -1):
            char = s[j]
            
            if char not in node.children:
                break  # No word possible
            
            node = node.children[char]
            
            # Found a word and prefix is valid
            if node.isEnd and dp[j]:
                dp[i] = True
                break  # Can stop early
    
    return dp[n]

# Why Trie helps:
# - Without Trie: Check each substring against word_dict → O(n² × W)
# - With Trie: Prefix-based early termination → O(n² × L)
# - L typically << W (average word length vs dictionary size)
```

**Advanced: Minimum Cost Word Break**
```python
def min_cost_word_break(s, word_dict_with_costs):
    """
    Each word has a cost. Find minimum cost to break string.
    word_dict_with_costs: {"cat": 2, "cats": 5, "and": 3, ...}
    """
    trie = TrieWithCost()
    for word, cost in word_dict_with_costs.items():
        trie.insert(word, cost)
    
    n = len(s)
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    
    for i in range(1, n + 1):
        node = trie.root
        
        for j in range(i - 1, -1, -1):
            char = s[j]
            
            if char not in node.children:
                break
            
            node = node.children[char]
            
            if node.isEnd and dp[j] != float('inf'):
                dp[i] = min(dp[i], dp[j] + node.cost)
    
    return dp[n] if dp[n] != float('inf') else -1
```

### 6.2.4 Trie + Heap (Priority Queue)

**Use Case**: Top K problems, ranking, prioritization

```python
import heapq

class TrieWithHeap:
    """Get top K suggestions by frequency"""
    
    def top_k_frequent(self, prefix, k):
        """Get top K most frequent words with prefix"""
        node = self.root
        
        # Navigate to prefix
        for char in prefix:
            if char not in node.children:
                return []
            node = node.children[char]
        
        # Use max heap (negative frequencies for min heap)
        heap = []
        
        def dfs(node, path):
            if node.isEnd:
                # Use negative for max heap behavior
                heapq.heappush(heap, (-node.frequency, path))
                
                # Keep only top k
                if len(heap) > k:
                    heapq.heappop(heap)
            
            for char, child in node.children.items():
                dfs(child, path + char)
        
        dfs(node, prefix)
        
        # Extract and reverse sort
        result = [word for _, word in sorted(heap, reverse=True)]
        return result
    
    def k_closest_words(self, target, k):
        """Find k words with minimum edit distance to target"""
        all_words = []
        
        def collect(node, path):
            if node.isEnd:
                distance = self._edit_distance(path, target)
                all_words.append((distance, path))
            
            for char, child in node.children.items():
                collect(child, path + char)
        
        collect(self.root, "")
        
        # Use heap to get k smallest
        return [word for _, word in heapq.nsmallest(k, all_words)]
    
    def _edit_distance(self, s1, s2):
        """Calculate edit distance"""
        m, n = len(s1), len(s2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(m + 1):
            dp[i][0] = i
        for j in range(n + 1):
            dp[0][j] = j
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i-1] == s2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
        
        return dp[m][n]

# Application: Search suggestions, spell checker
```

### 6.2.5 Trie + Backtracking

**Use Case**: Combination/permutation problems with constraints

```python
# Problem: Generate all valid words from letters with constraints

def generate_valid_words(letters, trie, min_length=3):
    """
    Generate all valid dictionary words from given letters
    Each letter can be used at most once
    """
    result = []
    
    def backtrack(node, path, remaining_letters):
        if len(path) >= min_length and node.isEnd:
            result.append(path)
        
        for i, letter in enumerate(remaining_letters):
            if letter in node.children:
                # Use this letter
                new_remaining = remaining_letters[:i] + remaining_letters[i+1:]
                backtrack(
                    node.children[letter],
                    path + letter,
                    new_remaining
                )
    
    backtrack(trie.root, "", letters)
    return result

# Application: Scrabble word generator, anagram finder
```

### 6.2.6 Trie + Sliding Window

**Use Case**: Stream processing, rolling pattern matching

```python
class StreamWordDetector:
    """
    Detect dictionary words in a stream of characters
    Using trie + sliding window
    """
    def __init__(self, word_dict, max_word_length):
        self.trie = Trie()
        for word in word_dict:
            self.trie.insert(word)
        
        self.max_word_length = max_word_length
        self.window = []
        self.found_words = []
    
    def process_char(self, char):
        """Process one character from stream"""
        self.window.append(char)
        
        # Maintain window size
        if len(self.window) > self.max_word_length:
            self.window.pop(0)
        
        # Check all possible words ending at current position
        node = self.trie.root
        for i in range(len(self.window) - 1, -1, -1):
            c = self.window[i]
            
            if c not in node.children:
                break
            
            node = node.children[c]
            
            if node.isEnd:
                word = ''.join(self.window[i:])
                self.found_words.append(word)
        
        return self.found_words[-1] if self.found_words else None

# Example: Malware detection, log analysis
```

---

## 6.3 Debugging & Testing Strategies

### 6.3.1 Visualization Techniques

```python
class DebugTrie:
    """Trie with debugging utilities"""
    
    def visualize(self, node=None, prefix="", is_tail=True):
        """Print tree structure"""
        if node is None:
            node = self.root
            print("Root")
        
        items = list(node.children.items())
        
        for i, (char, child) in enumerate(items):
            is_last = (i == len(items) - 1)
            
            # Draw branches
            connector = "└── " if is_last else "├── "
            extension = "    " if is_last else "│   "
            
            # Mark end of word
            end_marker = " (END)" if child.isEnd else ""
            
            print(f"{prefix}{connector}{char}{end_marker}")
            
            # Recursively visualize children
            self.visualize(child, prefix + extension, is_last)
    
    def print_paths(self):
        """Print all root-to-leaf paths"""
        def dfs(node, path, paths):
            if node.isEnd:
                paths.append(path)
            
            if not node.children:  # Leaf node
                if path:  # Only print non-empty
                    paths.append(f"{path} (leaf)")
            
            for char, child in node.children.items():
                dfs(child, path + char, paths)
        
        paths = []
        dfs(self.root, "", paths)
        
        for p in paths:
            print(p)
    
    def validate_structure(self):
        """Check trie integrity"""
        issues = []
        
        def check(node, path):
            # Check 1: End node without word stored
            if node.isEnd and not hasattr(node, 'word'):
                issues.append(f"End node at '{path}' missing word attribute")
            
            # Check 2: Circular reference
            visited = set()
            if id(node) in visited:
                issues.append(f"Circular reference detected at '{path}'")
            visited.add(id(node))
            
            # Check 3: Invalid children
            if not isinstance(node.children, dict):
                issues.append(f"Invalid children type at '{path}'")
            
            # Recurse
            for char, child in node.children.items():
                check(child, path + char)
        
        check(self.root, "")
        
        if issues:
            print("⚠️ Issues found:")
            for issue in issues:
                print(f"  - {issue}")
        else:
            print("✅ Trie structure is valid")
        
        return len(issues) == 0

# Usage
debug_trie = DebugTrie()
debug_trie.insert("cat")
debug_trie.insert("car")
debug_trie.insert("card")
debug_trie.visualize()

# Output:
# Root
# └── c
#     └── a
#         ├── t (END)
#         └── r (END)
#             └── d (END)
```

### 6.3.2 Common Bugs and How to Catch Them

#### Bug 1: Forgetting isEndOfWord flag
```python
# ❌ WRONG: Searching without checking isEnd
def search_wrong(self, word):
    node = self.root
    for char in word:
        if char not in node.children:
            return False
        node = node.children[char]
    return True  # BUG: Returns true even for prefixes!

# ✅ CORRECT:
def search_correct(self, word):
    node = self.root
    for char in word:
        if char not in node.children:
            return False
        node = node.children[char]
    return node.isEnd  # Check flag!

# Test case that catches this:
# Insert "app", search("ap") should return False
```

#### Bug 2: Not handling empty strings
```python
# Test case
trie = Trie()
trie.insert("")  # Should handle gracefully
assert trie.search("") == True

# Fix: Special case at start
def insert(self, word):
    if not word:
        self.root.isEnd = True
        return
    # ... rest of code
```

#### Bug 3: Memory leaks in deletion
```python
# ❌ WRONG: Not removing empty branches
def delete_wrong(self, word):
    # Just marks isEnd = False
    # Leaves orphaned nodes!

# ✅ CORRECT: Remove empty paths
def delete_correct(self, word):
    def helper(node, word, index):
        if index == len(word):
            if not node.isEnd:
                return False
            node.isEnd = False
            return len(node.children) == 0
        
        char = word[index]
        if char not in node.children:
            return False
        
        should_delete = helper(node.children[char], word, index + 1)
        
        if should_delete:
            del node.children[char]
            return len(node.children) == 0 and not node.isEnd
        
        return False
    
    helper(self.root, word, 0)
```

### 6.3.3 Test Case Template

```python
class TrieTestSuite:
    """Comprehensive test suite for Trie"""
    
    def __init__(self, trie_class):
        self.TrieClass = trie_class
    
    def run_all_tests(self):
        """Run all test categories"""
        tests = [
            self.test_basic_operations,
            self.test_edge_cases,
            self.test_prefix_operations,
            self.test_deletion,
            self.test_performance
        ]
        
        for test in tests:
            try:
                test()
                print(f"✅ {test.__name__} passed")
            except AssertionError as e:
                print(f"❌ {test.__name__} failed: {e}")
    
    def test_basic_operations(self):
        """Test insert and search"""
        trie = self.TrieClass()
        
        # Basic insert
        trie.insert("hello")
        assert trie.search("hello") == True
        assert trie.search("hell") == False
        
        # Multiple inserts
        trie.insert("world")
        assert trie.search("hello") == True
        assert trie.search("world") == True
    
    def test_edge_cases(self):
        """Test boundary conditions"""
        trie = self.TrieClass()
        
        # Empty string
        trie.insert("")
        assert trie.search("") == True
        
        # Single character
        trie.insert("a")
        assert trie.search("a") == True
        
        # Very long word
        long_word = "a" * 1000
        trie.insert(long_word)
        assert trie.search(long_word) == True
        
        # Special characters
        trie.insert("hello-world")
        assert trie.search("hello-world") == True
    
    def test_prefix_operations(self):
        """Test prefix-related functionality"""
        trie = self.TrieClass()
        
        words = ["app", "apple", "application"]
        for word in words:
            trie.insert(word)
        
        # Prefix vs word
        assert trie.search("app") == True  # Is a word
        assert trie.starts_with("app") == True  # Is a prefix
        assert trie.starts_with("appl") == True  # Prefix only
        assert trie.search("appl") == False  # Not a complete word
    
    def test_deletion(self):
        """Test deletion scenarios"""
        trie = self.TrieClass()
        
        # Case 1: Delete leaf
        trie.insert("cat")
        trie.delete("cat")
        assert trie.search("cat") == False
        
        # Case 2: Word is prefix of another
        trie.insert("app")
        trie.insert("apple")
        trie.delete("app")
        assert trie.search("app") == False
        assert trie.search("apple") == True
        
        # Case 3: Delete non-existent word
        try:
            trie.delete("xyz")  # Should handle gracefully
        except:
            pass
    
    def test_performance(self):
        """Basic performance sanity check"""
        import time
        
        trie = self.TrieClass()
        
        # Insert 10K words
        start = time.time()
        for i in range(10000):
            trie.insert(f"word{i}")
        insert_time = time.time() - start
        
        # Search 10K words
        start = time.time()
        for i in range(10000):
            trie.search(f"word{i}")
        search_time = time.time() - start
        
        print(f"  Insert 10K words: {insert_time:.3f}s")
        print(f"  Search 10K words: {search_time:.3f}s")
        
        assert insert_time < 1.0  # Should be under 1 second
        assert search_time < 1.0

# Usage
test_suite = TrieTestSuite(Trie)
test_suite.run_all_tests()
```

### 6.3.4 Performance Profiling

```python
import time
import tracemalloc

class TrieProfiler:
    """Profile trie operations"""
    
    @staticmethod
    def profile_operation(func, *args, **kwargs):
        """Measure time and memory"""
        # Start memory tracking
        tracemalloc.start()
        start_time = time.time()
        
        # Execute
        result = func(*args, **kwargs)
        
        # Measure
        end_time = time.time()
        current, peak = tracemalloc.get_traced_memory()
        tracemalloc.stop()
        
        print(f"Time: {end_time - start_time:.4f}s")
        print(f"Memory: {current / 1024 / 1024:.2f} MB (peak: {peak / 1024 / 1024:.2f} MB)")
        
        return result
    
    @staticmethod
    def compare_implementations(impl1, impl2, test_data):
        """Compare two trie implementations"""
        print("Implementation 1:")
        TrieProfiler.profile_operation(impl1, test_data)
        
        print("\nImplementation 2:")
        TrieProfiler.profile_operation(impl2, test_data)

# Usage
def test_array_trie():
    trie = ArrayTrie()  # Fixed-size array children
    for i in range(10000):
        trie.insert(f"word{i}")

def test_hashmap_trie():
    trie = HashMapTrie()  # HashMap children
    for i in range(10000):
        trie.insert(f"word{i}")

TrieProfiler.compare_implementations(test_array_trie, test_hashmap_trie, None)
```

---

## 6.4 Interview Pattern Recognition

### 6.4.1 Keyword Detection Table

| Keywords in Problem | Likely Pattern | Data Structure |
|---------------------|----------------|----------------|
| "prefix", "starts with" | Autocomplete | Standard Trie |
| "words in matrix", "board" | Word Search | Trie + DFS |
| "stream of characters" | Real-time matching | Reverse Trie |
| "maximum XOR" | Bit manipulation | Binary Trie |
| "palindrome pairs" | Reverse combinations | Trie + DFS |
| "word break" | Segmentation | Trie + DP |
| "replace words", "root" | Shortest prefix | Trie |
| "suggestions", "top K" | Ranking | Trie + Heap |

### 6.4.2 Problem-Solving Checklist

```
Before implementing:
☐ Can I use a simpler data structure (HashSet)?
☐ Will there be multiple queries?
☐ Is prefix matching required?
☐ What's the alphabet size?
☐ Are there memory constraints?

During implementation:
☐ Did I add isEndOfWord flag?
☐ Did I handle empty strings?
☐ Did I consider case sensitivity?
☐ Do I need to store complete words?
☐ Should I track frequencies/metadata?

After implementation:
☐ Test with overlapping words ("app", "apple")
☐ Test with empty strings
☐ Test prefix vs complete word
☐ Test deletion if implemented
☐ Verify no memory leaks
```

### 6.4.3 Quick Reference: Time Complexities

```python
# Let:
# N = number of words
# M = average word length
# K = number of results
# P = prefix length

# Operations:
trie.insert(word)              # O(M)
trie.search(word)              # O(M)
trie.startsWith(prefix)        # O(P)
trie.getAllWordsWithPrefix()   # O(P + K×M)
trie.delete(word)              # O(M)

# Building trie from N words: O(N×M)
# Space: O(N×M) worst case, better with shared prefixes
```

---

## Summary: Key Takeaways for Interviews

### The Three Golden Rules

1. **Use Trie when you need prefix operations on multiple queries**
   - Not for one-time lookups
   - Not when HashSet suffices

2. **Combine Trie with other techniques strategically**
   - DFS for exploration
   - DP for optimization
   - Heap for ranking

3. **Test thoroughly with edge cases**
   - Empty strings
   - Prefixes vs complete words
   - Overlapping words

### Interview Red Flags to Avoid

❌ Building trie without clear benefit over HashSet
❌ Forgetting isEndOfWord flag
❌ Not handling empty string edge case
❌ Over-engineering when problem doesn't need trie
❌ Not explaining WHY you chose trie

### Green Flags That Impress

✅ Explaining tradeoffs (trie vs alternatives)
✅ Optimizing with pruning (Word Search II)
✅ Handling edge cases proactively
✅ Discussing space complexity openly
✅ Offering multiple solutions and comparing

### Final Checklist for Hard Problems

1. ✅ Identified that trie is needed
2. ✅ Chose right variant (standard/binary/reverse)
3. ✅ Combined with appropriate algorithm
4. ✅ Optimized (pruning, early termination)
5. ✅ Handled all edge cases
6. ✅ Analyzed complexity correctly
7. ✅ Can explain alternative approaches

**Remember**: Trie is a tool, not a solution. The key is knowing when to use it and how to combine it with other techniques to solve complex problems efficiently.
