# Chapter 4: Advanced Trie Patterns for Interviews

## 4.1 Pattern: Autocomplete/Prefix Matching

### Core Concept
Autocomplete is one of the most natural applications of Trie. When a user types a prefix, we need to quickly find all words starting with that prefix.

### Visual Representation
```
Input: ["apple", "app", "apricot", "application"]
Query: "app"

Root
 |
 a
 |
 p
 |
 p (END: "app")
 ├─ l
 │  ├─ e (END: "apple")
 │  └─ i
 │     └─ c
 │        └─ a
 │           └─ t
 │              └─ i
 │                 └─ o
 │                    └─ n (END: "application")
 └─ r
    └─ i
       └─ c
          └─ o
             └─ t (END: "apricot")
```

### Basic Implementation

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.isEnd = False
        self.word = None  # Store complete word for easy retrieval

class AutocompleteTrie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        """Insert word into trie - O(m) where m is word length"""
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.isEnd = True
        node.word = word
    
    def search_prefix(self, prefix):
        """Find all words with given prefix - O(p + n)"""
        node = self.root
        
        # Navigate to prefix node - O(p)
        for char in prefix:
            if char not in node.children:
                return []
            node = node.children[char]
        
        # Collect all words from this point - O(n)
        results = []
        self._dfs_collect(node, results)
        return results
    
    def _dfs_collect(self, node, results):
        """DFS to collect all words from current node"""
        if node.isEnd:
            results.append(node.word)
        
        for child in node.children.values():
            self._dfs_collect(child, results)
```

### Advanced: Top K Frequent Words

```python
import heapq
from collections import Counter

class TrieNodeWithFreq:
    def __init__(self):
        self.children = {}
        self.isEnd = False
        self.word = None
        self.frequency = 0  # Track how often this word appears

class AutocompleteWithRanking:
    def __init__(self):
        self.root = TrieNodeWithFreq()
    
    def insert(self, word, frequency=1):
        """Insert word with frequency"""
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNodeWithFreq()
            node = node.children[char]
        node.isEnd = True
        node.word = word
        node.frequency += frequency
    
    def top_k_suggestions(self, prefix, k):
        """Get top k most frequent words with given prefix"""
        node = self.root
        
        # Navigate to prefix
        for char in prefix:
            if char not in node.children:
                return []
            node = node.children[char]
        
        # Use min heap to maintain top k
        results = []
        self._dfs_collect_with_freq(node, results)
        
        # Sort by frequency (descending) then lexicographically
        results.sort(key=lambda x: (-x[1], x[0]))
        return [word for word, freq in results[:k]]
    
    def _dfs_collect_with_freq(self, node, results):
        if node.isEnd:
            results.append((node.word, node.frequency))
        
        for child in node.children.values():
            self._dfs_collect_with_freq(child, results)

# Example usage
ac = AutocompleteWithRanking()
ac.insert("apple", 10)
ac.insert("app", 15)
ac.insert("application", 5)
ac.insert("apricot", 3)

print(ac.top_k_suggestions("app", 2))  # ["app", "apple"]
```

### Interview Variations
1. **Real-time Ranking**: Update frequencies as users click suggestions
2. **Personalized**: Different rankings per user
3. **Fuzzy Matching**: Allow typos (requires edit distance)

---

## 4.2 Pattern: Word Search in Matrix/Grid

### Problem Statement
Given a 2D board and a list of words, find all words that exist in the board. Words can be constructed from letters of sequentially adjacent cells (horizontally or vertically).

**Classic: LeetCode 212 - Word Search II**

### Why Trie is Essential
- **Without Trie**: For each word, do DFS on entire board → O(W × M × N × 4^L)
- **With Trie**: Single DFS traversal with pruning → O(M × N × 4^L)

### Visual Example
```
Board:
[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]

Words: ["oath", "pea", "eat", "rain"]

Trie Built from Words:
     root
    /  |  \
   o   p   e   r
   |   |   |   |
   a   e   a   a
   |   |   |   |
   t   a   t   i
   |           |
   h           n
(END)       (END)
```

### Implementation

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.word = None  # Store complete word at end node

class WordSearchTrie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.word = word
    
    def findWords(self, board, words):
        """Find all words from dictionary that exist in board"""
        # Build trie from word list
        for word in words:
            self.insert(word)
        
        result = []
        rows, cols = len(board), len(board[0])
        
        # Start DFS from each cell
        for r in range(rows):
            for c in range(cols):
                self._dfs(board, r, c, self.root, result)
        
        return result
    
    def _dfs(self, board, r, c, node, result):
        """DFS with backtracking and trie pruning"""
        # Boundary checks
        if r < 0 or r >= len(board) or c < 0 or c >= len(board[0]):
            return
        
        char = board[r][c]
        
        # Already visited or not in trie
        if char == '#' or char not in node.children:
            return
        
        node = node.children[char]
        
        # Found a word!
        if node.word:
            result.append(node.word)
            node.word = None  # Avoid duplicate results
        
        # Mark as visited
        board[r][c] = '#'
        
        # Explore all 4 directions
        directions = [(0,1), (1,0), (0,-1), (-1,0)]
        for dr, dc in directions:
            self._dfs(board, r + dr, c + dc, node, result)
        
        # Backtrack: restore original character
        board[r][c] = char
        
        # OPTIMIZATION: Prune leaf nodes
        # If this node has no children and no word, we can remove it
        if not node.children:
            del node.children

# Example usage
board = [
    ['o','a','a','n'],
    ['e','t','a','e'],
    ['i','h','k','r'],
    ['i','f','l','v']
]
words = ["oath", "pea", "eat", "rain"]

trie = WordSearchTrie()
print(trie.findWords(board, words))  # ["oath", "eat"]
```

### Key Optimizations
1. **Store word at end node**: Avoid reconstructing path
2. **Set word to None after finding**: Prevent duplicates
3. **Prune trie branches**: Remove found words to reduce search space
4. **In-place marking**: Use board itself for visited tracking

### Time Complexity Analysis
- Building Trie: O(W × L) where W = number of words, L = avg length
- DFS: O(M × N × 4^L) but heavily pruned by trie structure
- **Practical**: Much faster than worst case due to pruning

---

## 4.3 Pattern: Longest Common Prefix

### Concept
Find the longest string that is a prefix of all strings in an array.

### Trie Approach
Build a trie and traverse until:
1. We hit a node with multiple children (branching), OR
2. We hit an end-of-word node (one string is prefix of others)

### Visual Example
```
Input: ["flower", "flow", "flight"]

Trie:
root
 |
 f
 |
 l
 ├─ o
 │  └─ w (END: "flow")
 │     └─ e
 │        └─ r (END: "flower")
 └─ i
    └─ g
       └─ h
          └─ t (END: "flight")

LCP = "fl" (stops at branching point)
```

### Implementation

```python
class LongestCommonPrefix:
    def __init__(self):
        self.root = TrieNode()
    
    def longestCommonPrefix(self, strs):
        if not strs:
            return ""
        
        # Build trie
        for word in strs:
            self._insert(word)
        
        # Traverse to find LCP
        lcp = []
        node = self.root
        
        while True:
            # Stop if branching (more than 1 child)
            if len(node.children) != 1:
                break
            
            # Stop if we hit end of a word
            if node.isEnd:
                break
            
            # Move to the only child
            char, next_node = next(iter(node.children.items()))
            lcp.append(char)
            node = next_node
        
        return ''.join(lcp)
    
    def _insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.isEnd = True

# Example
lcp_finder = LongestCommonPrefix()
print(lcp_finder.longestCommonPrefix(["flower", "flow", "flight"]))  # "fl"
```

### Alternative: Without Building Full Trie
```python
def longestCommonPrefixOptimized(strs):
    """Use trie logic without building entire structure"""
    if not strs:
        return ""
    
    # Start with first string
    prefix = strs[0]
    
    for string in strs[1:]:
        # Reduce prefix until it matches
        while not string.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    
    return prefix
```

---

## 4.4 Pattern: Replace Words (LeetCode 648)

### Problem
Given a dictionary of root words and a sentence, replace all successors with the root forming it.

**Example**: 
- Dictionary: `["cat", "bat", "rat"]`
- Sentence: `"the cattle was rattled by the battery"`
- Output: `"the cat was rat by the bat"`

### Trie Solution

```python
class ReplaceWords:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.isEnd = True
        node.word = word
    
    def find_shortest_root(self, word):
        """Find shortest root that matches prefix of word"""
        node = self.root
        
        for char in word:
            if char not in node.children:
                return word  # No root found, return original
            
            node = node.children[char]
            
            # Found a root! Return it (shortest due to first match)
            if node.isEnd:
                return node.word
        
        return word  # No root found
    
    def replaceWords(self, dictionary, sentence):
        # Build trie from dictionary
        for root in dictionary:
            self.insert(root)
        
        # Process each word in sentence
        words = sentence.split()
        result = [self.find_shortest_root(word) for word in words]
        
        return ' '.join(result)

# Example usage
rw = ReplaceWords()
dictionary = ["cat", "bat", "rat"]
sentence = "the cattle was rattled by the battery"
print(rw.replaceWords(dictionary, sentence))
# Output: "the cat was rat by the bat"
```

### Why Trie is Optimal
- **Without Trie**: Check each word against all dictionary roots → O(N × M × K)
- **With Trie**: Single pass per word → O(N × L) where L is avg word length
- **Key**: We find the **shortest** root automatically by stopping at first `isEnd`

---

## 4.5 Pattern: Word Break Problems

### Problem Types
1. **Word Break I**: Can string be segmented into dictionary words?
2. **Word Break II**: Return all possible segmentations

### Word Break I - DP + Trie

```python
class WordBreak:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.isEnd = True
    
    def wordBreak(self, s, wordDict):
        """DP approach with Trie for O(1) prefix checking"""
        # Build trie
        for word in wordDict:
            self.insert(word)
        
        n = len(s)
        dp = [False] * (n + 1)
        dp[0] = True  # Empty string
        
        for i in range(1, n + 1):
            # Try all possible last words ending at position i
            node = self.root
            
            for j in range(i - 1, -1, -1):
                char = s[j]
                
                # No path in trie
                if char not in node.children:
                    break
                
                node = node.children[char]
                
                # Found a word and prefix is valid
                if node.isEnd and dp[j]:
                    dp[i] = True
                    break
        
        return dp[n]

# Example
wb = WordBreak()
s = "leetcode"
wordDict = ["leet", "code"]
print(wb.wordBreak(s, wordDict))  # True
```

### Word Break II - Backtracking + Trie

```python
class WordBreakII:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.isEnd = True
        node.word = word
    
    def wordBreak(self, s, wordDict):
        """Return all possible segmentations"""
        for word in wordDict:
            self.insert(word)
        
        result = []
        self._backtrack(s, 0, [], result)
        return result
    
    def _backtrack(self, s, start, path, result):
        if start == len(s):
            result.append(' '.join(path))
            return
        
        # Try to match words starting from 'start'
        node = self.root
        
        for i in range(start, len(s)):
            char = s[i]
            
            if char not in node.children:
                break
            
            node = node.children[char]
            
            if node.isEnd:
                # Found a word, recurse for rest of string
                path.append(node.word)
                self._backtrack(s, i + 1, path, result)
                path.pop()

# Example
wb2 = WordBreakII()
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
print(wb2.wordBreak(s, wordDict))
# ["cats and dog", "cat sand dog"]
```

### Memoization Optimization
```python
def wordBreakMemo(self, s, wordDict):
    """With memoization to avoid redundant computation"""
    for word in wordDict:
        self.insert(word)
    
    memo = {}
    
    def helper(start):
        if start == len(s):
            return [[]]
        
        if start in memo:
            return memo[start]
        
        result = []
        node = self.root
        
        for i in range(start, len(s)):
            char = s[i]
            if char not in node.children:
                break
            
            node = node.children[char]
            
            if node.isEnd:
                # Get all solutions for remaining string
                sub_results = helper(i + 1)
                for sub in sub_results:
                    result.append([node.word] + sub)
        
        memo[start] = result
        return result
    
    solutions = helper(0)
    return [' '.join(words) for words in solutions]
```

---

## 4.6 Pattern: Palindrome Pairs (LeetCode 336)

### Problem
Given a list of unique words, find all pairs `(i, j)` such that concatenation of `words[i] + words[j]` is a palindrome.

### Why This is Tricky
For word "abc", we need to check:
1. Reverse of entire word: "cba"
2. Reverse of suffix + palindrome prefix: "c" + "ba" (if "ab" is palindrome)
3. Palindrome suffix + reverse of prefix: "abc" + "" (if "abc" is palindrome)

### Trie Solution

```python
class PalindromePairs:
    def __init__(self):
        self.root = TrieNode()
    
    def insert_reverse(self, word, index):
        """Insert reversed word with original index"""
        node = self.root
        for char in reversed(word):
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.isEnd = True
        node.index = index
    
    def is_palindrome(self, s, start, end):
        """Check if substring is palindrome"""
        while start < end:
            if s[start] != s[end]:
                return False
            start += 1
            end -= 1
        return True
    
    def palindromePairs(self, words):
        result = []
        
        # Build trie with reversed words
        for i, word in enumerate(words):
            self.insert_reverse(word, i)
        
        # For each word, search for valid pairs
        for i, word in enumerate(words):
            self._search(word, i, result)
        
        return result
    
    def _search(self, word, word_index, result):
        """Search for all palindrome pairs with this word"""
        node = self.root
        
        for j, char in enumerate(word):
            # Case 1: Found complete match + remaining is palindrome
            if node.isEnd and node.index != word_index:
                if self.is_palindrome(word, j, len(word) - 1):
                    result.append([word_index, node.index])
            
            if char not in node.children:
                return
            
            node = node.children[char]
        
        # Case 2: Exhausted word, now check all branches
        self._dfs_palindrome(node, word_index, result)
    
    def _dfs_palindrome(self, node, word_index, result):
        """Find all words in trie that form palindromes"""
        if node.isEnd and node.index != word_index:
            result.append([word_index, node.index])
        
        for child in node.children.values():
            self._dfs_palindrome(child, word_index, result)

# Example
pp = PalindromePairs()
words = ["abcd", "dcba", "lls", "s", "sssll"]
print(pp.palindromePairs(words))
# [[0,1], [1,0], [3,2], [2,4]]
```

### Visual Example
```
Words: ["bat", "tab", "cat"]

Reverse Trie (store indices):
     root
    /  |  \
   t   b   t
   |   |   |
   a   a   a
   |   |   |
   b   t   c
 (idx:0)(idx:1)(idx:2)

For word "bat" (index 0):
- Look for "bat" in reverse trie → finds "tab" at index 1
- "bat" + "tab" = "battab" ❌ not palindrome
- "tab" + "bat" = "tabbat" ❌ not palindrome

For word "tab" (index 1):
- Look for "tab" in reverse trie → finds "bat" at index 0
- "tab" + "bat" = "tabbat" ❌
- Check... eventually finds valid pairs
```

---

## 4.7 Pattern: Maximum XOR Problems

### Concept
Use **Binary Trie** to find maximum XOR efficiently.

### Why Binary Trie?
- Store numbers as binary representations
- Each node has 0 or 1 child
- For maximum XOR: greedily choose opposite bit

### Visual Example
```
Numbers: [3, 10, 5, 25, 2]
Binary:  [011, 1010, 0101, 11001, 010]

Binary Trie (5 bits):
                root
               /    \
              0      1
             / \      \
            0   1      1
           /   / \      \
          1   0   0      0
         /   /     \      \
        1   1       1      0
       /           /        \
      1           0          1
   (3=011)    (5=0101)   (25=11001)
```

### Implementation: Maximum XOR of Two Numbers

```python
class BinaryTrieNode:
    def __init__(self):
        self.children = {}  # 0 or 1

class MaximumXOR:
    def __init__(self):
        self.root = BinaryTrieNode()
    
    def insert(self, num, bits=32):
        """Insert number as binary path"""
        node = self.root
        for i in range(bits - 1, -1, -1):
            bit = (num >> i) & 1
            if bit not in node.children:
                node.children[bit] = BinaryTrieNode()
            node = node.children[bit]
    
    def find_max_xor(self, num, bits=32):
        """Find maximum XOR with any number in trie"""
        node = self.root
        max_xor = 0
        
        for i in range(bits - 1, -1, -1):
            bit = (num >> i) & 1
            # Try to go opposite direction for maximum XOR
            toggle_bit = 1 - bit
            
            if toggle_bit in node.children:
                max_xor |= (1 << i)  # Set this bit in result
                node = node.children[toggle_bit]
            else:
                # Must take same bit
                node = node.children[bit]
        
        return max_xor
    
    def findMaximumXOR(self, nums):
        """LeetCode 421: Maximum XOR of Two Numbers"""
        if len(nums) < 2:
            return 0
        
        max_result = 0
        
        # Insert first number
        self.insert(nums[0])
        
        # For each subsequent number, find max XOR before inserting
        for num in nums[1:]:
            max_result = max(max_result, self.find_max_xor(num))
            self.insert(num)
        
        return max_result

# Example
mx = MaximumXOR()
nums = [3, 10, 5, 25, 2, 8]
print(mx.findMaximumXOR(nums))  # 28 (from 5 XOR 25 = 28)
```

### Step-by-Step Trace
```
For nums = [3, 10, 5, 25]:

1. Insert 3 (011):        root → 0 → 1 → 1
2. Check 10 (1010):       Try opposite: root → 0 → 0 → 0 → 1
   Max XOR so far = ?     10 XOR 3 = 9
3. Insert 10
4. Check 5 (0101):        Try opposite path
   Max XOR so far = ?     5 XOR 10 = 15
5. Insert 5
6. Check 25 (11001):      Try opposite path
   Max XOR = ?            25 XOR 5 = 28 ✓
```

### Advanced: Maximum XOR with Bound (LeetCode 1707)

```python
class MaxXORWithBound:
    def maximizeXor(self, nums, queries):
        """
        queries[i] = [xi, mi]
        Find max XOR of xi with any num <= mi
        """
        # Sort both arrays
        nums.sort()
        queries = [(x, m, i) for i, (x, m) in enumerate(queries)]
        queries.sort(key=lambda q: q[1])  # Sort by bound
        
        trie = MaximumXOR()
        result = [-1] * len(queries)
        idx = 0
        
        for x, m, original_idx in queries:
            # Insert all numbers <= m
            while idx < len(nums) and nums[idx] <= m:
                trie.insert(nums[idx])
                idx += 1
            
            # Find max XOR if trie is not empty
            if idx > 0:
                result[original_idx] = trie.find_max_xor(x)
        
        return result
```

---

## 4.8 Pattern: Stream of Characters (LeetCode 1032)

### Problem
Design algorithm that:
1. Accepts stream of characters
2. Checks if any suffix of stream matches a word from dictionary

### Key Insight
Build a **reverse trie** from all words, then match from end of stream backwards.

### Implementation

```python
class StreamChecker:
    def __init__(self, words):
        self.root = TrieNode()
        self.stream = []
        self.max_len = 0
        
        # Build reverse trie
        for word in words:
            self._insert_reverse(word)
            self.max_len = max(self.max_len, len(word))
    
    def _insert_reverse(self, word):
        """Insert word in reverse order"""
        node = self.root
        for char in reversed(word):
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.isEnd = True
    
    def query(self, letter):
        """Return true if any suffix matches a word"""
        self.stream.append(letter)
        
        # Only keep last max_len characters for efficiency
        if len(self.stream) > self.max_len:
            self.stream.pop(0)
        
        # Check from end backwards
        node = self.root
        for i in range(len(self.stream) - 1, -1, -1):
            char = self.stream[i]
            
            if char not in node.children:
                return False
            
            node = node.children[char]
            
            if node.isEnd:
                return True
        
        return False

# Example usage
words = ["cd", "f", "kl"]
sc = StreamChecker(words)

print(sc.query('a'))  # False
print(sc.query('b'))  # False
print(sc.query('c'))  # False
print(sc.query('d'))  # True  (stream = "abcd", suffix "cd" matches)
print(sc.query('e'))  # False
print(sc.query('f'))  # True  (stream = "abcdef", suffix "f" matches)
```

### Why Reverse Trie?
```
Words: ["cd", "f"]
Stream: a b c d

Normal Trie:          Reverse Trie:
    root                  root
   /    \                /    \
  c      f              d      f
  |     (END)           |     (END)
  d                     c
(END)                 (END)

When 'd' arrives:
- Normal: Need to track all possible starting points
- Reverse: Just traverse backwards from 'd'
```

### Complexity
- **Space**: O(total characters in all words)
- **Query**: O(max word length) per character
- **Optimization**: Only keep last `max_len` characters in stream

---

## Summary: When to Use Each Pattern

| Pattern | Key Indicator | Complexity | Common Variations |
|---------|--------------|------------|-------------------|
| Autocomplete | Prefix queries, suggestions | O(p + n) | With ranking, real-time |
| Word Search Grid | Multi-word search in 2D | O(M×N×4^L) | Pruning critical |
| LCP | All strings share prefix | O(total chars) | Can optimize without trie |
| Replace Words | Shortest prefix match | O(n×L) | Dictionary-based |
| Word Break | String segmentation | O(n²) with trie | DP or backtracking |
| Palindrome Pairs | Reverse + palindrome check | O(n×k²) | Reverse trie trick |
| Max XOR | Bit manipulation optimization | O(n×32) | Binary trie |
| Stream Matching | Real-time suffix matching | O(L) per query | Reverse trie |

### Pattern Recognition Tips
1. **Multiple prefix queries** → Basic Trie
2. **2D grid + word list** → Word Search pattern
3. **Concatenation/Segmentation** → Word Break pattern
4. **XOR optimization** → Binary Trie
5. **Real-time stream** → Reverse Trie
6. **Palindrome combinations** → Reverse Trie + DFS
