# Chapter 3: Space Optimization Techniques

## 3.1 The Space Problem in Standard Tries

### Understanding the Memory Overhead

**Standard Trie Memory Analysis:**

For a standard trie with lowercase English alphabet:
```
Per Node Memory:
- 26 pointers (8 bytes each on 64-bit) = 208 bytes
- 1 boolean flag = 1 byte
- Object overhead = ~16 bytes
Total: â‰ˆ 225 bytes per node
```

**Real-World Example:**
```
Dictionary: 100,000 words
Average word length: 7 characters
Total characters: 700,000

Worst case (no sharing): 700,000 nodes Ã— 225 bytes = 157.5 MB
Best case (50% sharing): 350,000 nodes Ã— 225 bytes = 78.75 MB
```

**The Core Issue:**
- Most nodes have very few children (typically 1-3)
- Storing 26 pointers when only 2 are used = 92% waste
- Memory grows rapidly with alphabet size

---

## 3.2 Compressed Trie (Radix Tree / Patricia Trie)

### Concept: Compress Single-Child Chains

**Standard Trie Problem:**
```
Word: "testing"

Standard Trie (7 levels):
    t
    |
    e
    |
    s
    |
    t
    |
    i
    |
    n
    |
    g*

7 nodes, mostly single children - wasteful!
```

**Compressed Trie Solution:**
```
Compressed (1 node):
    "testing"*

1 node with full string - efficient!
```

### Rules for Compression

1. **Merge single-child chains** into one node with string label
2. **Stop at branches** (multiple children)
3. **Stop at word endings** (marked nodes)

### Visual Example: Building Compressed Trie

**Insert: "test", "testing", "tester", "team"**

```
Step 1: Insert "test"
    "test"*

Step 2: Insert "testing" (shares prefix "test")
    "test"*
       |
      "ing"*

Step 3: Insert "tester" (shares prefix "test")
    "test"*
      / \
  "ing"* "er"*

Step 4: Insert "team" (shares prefix "te")
      "te"
      /  \
   "st"* "am"*
    / \
"ing"* "er"*
```

### Implementation: Compressed Trie

```python
class CompressedTrieNode:
    def __init__(self, label=""):
        self.label = label  # String stored at this node
        self.children = {}  # Map: first_char -> child_node
        self.is_end_of_word = False

class CompressedTrie:
    def __init__(self):
        self.root = CompressedTrieNode()
    
    def insert(self, word: str) -> None:
        """
        Insert with path compression
        More complex than standard trie due to splitting
        """
        if not word:
            return
        
        node = self.root
        remaining = word
        
        while remaining:
            first_char = remaining[0]
            
            # No child with this character
            if first_char not in node.children:
                node.children[first_char] = CompressedTrieNode(remaining)
                node.children[first_char].is_end_of_word = True
                return
            
            child = node.children[first_char]
            
            # Find common prefix length
            common_len = 0
            min_len = min(len(remaining), len(child.label))
            
            while common_len < min_len and remaining[common_len] == child.label[common_len]:
                common_len += 1
            
            # Case 1: Remaining matches child label exactly
            if common_len == len(child.label):
                if common_len == len(remaining):
                    # Word already exists or is prefix
                    child.is_end_of_word = True
                    return
                else:
                    # Continue with remaining part
                    node = child
                    remaining = remaining[common_len:]
            
            # Case 2: Need to split the node
            else:
                # Create new intermediate node with common prefix
                new_node = CompressedTrieNode(child.label[:common_len])
                
                # Adjust old child
                old_label_remaining = child.label[common_len:]
                child.label = old_label_remaining
                new_node.children[old_label_remaining[0]] = child
                
                # Create new branch for our word
                if common_len < len(remaining):
                    new_remaining = remaining[common_len:]
                    new_child = CompressedTrieNode(new_remaining)
                    new_child.is_end_of_word = True
                    new_node.children[new_remaining[0]] = new_child
                else:
                    new_node.is_end_of_word = True
                
                # Replace old child with new node
                node.children[first_char] = new_node
                return
    
    def search(self, word: str) -> bool:
        """Search in compressed trie"""
        node = self.root
        remaining = word
        
        while remaining:
            first_char = remaining[0]
            
            if first_char not in node.children:
                return False
            
            child = node.children[first_char]
            
            # Check if remaining matches child's label
            if not remaining.startswith(child.label):
                return False
            
            remaining = remaining[len(child.label):]
            node = child
        
        return node.is_end_of_word
    
    def starts_with(self, prefix: str) -> bool:
        """Check if prefix exists"""
        node = self.root
        remaining = prefix
        
        while remaining:
            first_char = remaining[0]
            
            if first_char not in node.children:
                return False
            
            child = node.children[first_char]
            
            # Check if child's label is compatible with remaining
            min_len = min(len(remaining), len(child.label))
            if remaining[:min_len] != child.label[:min_len]:
                return False
            
            if len(remaining) <= len(child.label):
                return True
            
            remaining = remaining[len(child.label):]
            node = child
        
        return True


# Example usage
trie = CompressedTrie()
words = ["test", "testing", "tester", "team", "toast"]

for word in words:
    trie.insert(word)

print(trie.search("test"))      # True
print(trie.search("testing"))   # True
print(trie.starts_with("te"))   # True
```

### Space Savings Analysis

**Standard Trie:**
```
"testing" = 7 nodes Ã— 225 bytes = 1,575 bytes
```

**Compressed Trie:**
```
"testing" = 1 node with string
- Node overhead: 225 bytes
- String: 7 bytes
Total: 232 bytes

Savings: 85% reduction!
```

**Trade-offs:**
- âœ… Massive space savings (typically 40-60% reduction)
- âœ… Better cache performance (fewer nodes)
- âŒ More complex implementation
- âŒ Splitting nodes during insertion is expensive
- âŒ String comparisons add overhead

---

## 3.3 Ternary Search Tree (TST)

### Concept: Three-Way Branching

Instead of storing 26 pointers, each node has exactly 3 pointers:
- **Left**: Characters lexicographically smaller
- **Equal**: Current character matches, go deeper
- **Right**: Characters lexicographically larger

### Structure Visualization

**Standard Trie** (for "cat", "cut", "dog"):
```
      ROOT
     /  |  \
    c   d   ...
   / \  |
  a   u o
  |   | |
  t   t g
```

**Ternary Search Tree:**
```
           c
          /|\
         / | \
     [<c] a [>c]
          |
          t --------- d
                      |
                      o
                      |
                      g
```

Each node stores:
- One character
- Three pointers (left, middle, right)
- End-of-word flag

### Implementation

```python
class TSTNode:
    def __init__(self, char):
        self.char = char
        self.left = None    # Less than this char
        self.middle = None  # Equal, go deeper
        self.right = None   # Greater than this char
        self.is_end = False

class TernarySearchTree:
    def __init__(self):
        self.root = None
    
    def insert(self, word: str) -> None:
        """
        Insert into TST
        Time: O(m) average, O(m log n) worst case
        """
        if not word:
            return
        self.root = self._insert_helper(self.root, word, 0)
    
    def _insert_helper(self, node, word, index):
        char = word[index]
        
        # Create node if doesn't exist
        if node is None:
            node = TSTNode(char)
        
        # Navigate based on character comparison
        if char < node.char:
            node.left = self._insert_helper(node.left, word, index)
        elif char > node.char:
            node.right = self._insert_helper(node.right, word, index)
        else:  # char == node.char
            if index + 1 < len(word):
                # More characters to process
                node.middle = self._insert_helper(node.middle, word, index + 1)
            else:
                # End of word
                node.is_end = True
        
        return node
    
    def search(self, word: str) -> bool:
        """
        Search in TST
        Time: O(m) average, O(m log n) worst case
        """
        if not word:
            return False
        return self._search_helper(self.root, word, 0)
    
    def _search_helper(self, node, word, index):
        if node is None:
            return False
        
        char = word[index]
        
        if char < node.char:
            return self._search_helper(node.left, word, index)
        elif char > node.char:
            return self._search_helper(node.right, word, index)
        else:  # char == node.char
            if index + 1 == len(word):
                return node.is_end
            else:
                return self._search_helper(node.middle, word, index + 1)
    
    def starts_with(self, prefix: str) -> bool:
        """Check if prefix exists"""
        if not prefix:
            return True
        return self._prefix_helper(self.root, prefix, 0)
    
    def _prefix_helper(self, node, prefix, index):
        if node is None:
            return False
        
        char = prefix[index]
        
        if char < node.char:
            return self._prefix_helper(node.left, prefix, index)
        elif char > node.char:
            return self._prefix_helper(node.right, prefix, index)
        else:
            if index + 1 == len(prefix):
                return True
            return self._prefix_helper(node.middle, prefix, index + 1)
    
    def get_all_words(self) -> list:
        """Collect all words (returns sorted list)"""
        words = []
        self._collect_words(self.root, "", words)
        return words
    
    def _collect_words(self, node, prefix, words):
        if node is None:
            return
        
        # Traverse in order for sorted output
        self._collect_words(node.left, prefix, words)
        
        current = prefix + node.char
        if node.is_end:
            words.append(current)
        
        self._collect_words(node.middle, current, words)
        self._collect_words(node.right, prefix, words)


# Example usage
tst = TernarySearchTree()
words = ["cat", "cats", "dog", "dogs", "car", "card"]

for word in words:
    tst.insert(word)

print(tst.search("cat"))        # True
print(tst.search("ca"))         # False
print(tst.starts_with("ca"))    # True
print(tst.get_all_words())      # ['car', 'card', 'cat', 'cats', 'dog', 'dogs']
```

### Memory Comparison

**For 100,000 words with 26-letter alphabet:**

| Structure | Memory per Node | Total Nodes | Total Memory |
|-----------|----------------|-------------|--------------|
| Standard Trie | 225 bytes | ~400,000 | 90 MB |
| TST | 40 bytes | ~700,000 | 28 MB |
| Compressed Trie | 225 bytes | ~150,000 | 33.75 MB |

**TST Analysis:**
- âœ… Much better than standard trie (69% reduction)
- âœ… More nodes but smaller nodes
- âœ… Naturally balanced (like BST)
- âœ… Still maintains string locality
- âŒ Slightly slower than standard trie (log factor)

### When to Use TST

**Prefer TST when:**
- Alphabet is large (Unicode, mixed case)
- Memory is constrained
- Need reasonable performance
- Willing to trade some speed for space

**Prefer Standard Trie when:**
- Alphabet is small (26 letters)
- Speed is critical
- Memory is plentiful
- Need O(1) per character guarantee

---

## 3.4 Bit-wise Trie Optimization

### Concept: Binary Tries for Bit Strings

For data that's naturally binary (IP addresses, binary strings, integers), use binary trie:
- Each node has only 2 children (0 and 1)
- Dramatically reduced space

### Structure

```
Example: Storing binary numbers [101, 110, 111]

        ROOT
       /    \
      0      1
            / \
           0   1
          /   / \
         1   0   1
```

### Implementation for Integer Storage

```python
class BinaryTrieNode:
    def __init__(self):
        self.children = [None, None]  # 0 and 1
        self.is_end = False

class BinaryTrie:
    def __init__(self, max_bits=32):
        self.root = BinaryTrieNode()
        self.max_bits = max_bits
    
    def insert(self, num: int) -> None:
        """
        Insert integer as binary representation
        Time: O(max_bits)
        """
        node = self.root
        
        # Process from MSB to LSB
        for i in range(self.max_bits - 1, -1, -1):
            bit = (num >> i) & 1
            
            if node.children[bit] is None:
                node.children[bit] = BinaryTrieNode()
            
            node = node.children[bit]
        
        node.is_end = True
    
    def search(self, num: int) -> bool:
        """Search for integer"""
        node = self.root
        
        for i in range(self.max_bits - 1, -1, -1):
            bit = (num >> i) & 1
            
            if node.children[bit] is None:
                return False
            
            node = node.children[bit]
        
        return node.is_end
    
    def find_max_xor(self, num: int) -> int:
        """
        Find maximum XOR of num with any number in trie
        Classic interview problem!
        Time: O(max_bits)
        """
        if self.root.children[0] is None and self.root.children[1] is None:
            return 0
        
        node = self.root
        max_xor = 0
        
        # For maximum XOR, choose opposite bit when possible
        for i in range(self.max_bits - 1, -1, -1):
            bit = (num >> i) & 1
            opposite = 1 - bit
            
            # Try to go opposite direction
            if node.children[opposite] is not None:
                max_xor |= (1 << i)
                node = node.children[opposite]
            else:
                node = node.children[bit]
        
        return max_xor


# Example: Maximum XOR problem
trie = BinaryTrie(8)  # 8-bit numbers
nums = [3, 10, 5, 25, 2]

for num in nums:
    trie.insert(num)

# Find max XOR for each number
for num in nums:
    print(f"Max XOR of {num}: {trie.find_max_xor(num)}")

# Output:
# Max XOR of 3: 28 (3 ^ 25 = 28)
# Max XOR of 10: 31 (10 ^ 25 = 31)
# Max XOR of 5: 30 (5 ^ 25 = 30)
# Max XOR of 25: 31 (25 ^ 10 = 31)
# Max XOR of 2: 29 (2 ^ 25 = 29)
```

### Binary Trie Applications

1. **Maximum XOR Problems** (LeetCode 421, 1707)
2. **IP Routing Tables**
3. **Network Prefix Matching**
4. **Bit manipulation problems**

---

## 3.5 Hybrid Approaches

### Combining Techniques

Real-world systems often combine multiple optimizations:

```python
class HybridTrieNode:
    """
    Hybrid approach:
    - Common characters: Array (a-z)
    - Special characters: HashMap
    - Single child chains: Compressed
    """
    def __init__(self):
        self.common = [None] * 26  # a-z
        self.special = {}          # Other characters
        self.label = ""            # For compression
        self.is_end = False
    
    def get_child(self, char):
        if 'a' <= char <= 'z':
            return self.common[ord(char) - ord('a')]
        else:
            return self.special.get(char)
    
    def add_child(self, char, node):
        if 'a' <= char <= 'z':
            self.common[ord(char) - ord('a')] = node
        else:
            self.special[char] = node
```

---

## 3.6 Practical Optimization Tips

### 1. Lazy Node Creation
```python
def get_or_create_child(self, char):
    """Only create nodes when actually needed"""
    if char not in self.children:
        self.children[char] = TrieNode()
    return self.children[char]
```

### 2. Reference Counting for Deletion
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False
        self.ref_count = 0  # Count of words passing through
    
    def can_delete(self):
        return self.ref_count == 0 and not self.is_end
```

### 3. Memory Pooling
```python
class TrieNodePool:
    """Reuse deleted nodes instead of creating new ones"""
    def __init__(self):
        self.pool = []
    
    def allocate(self):
        if self.pool:
            node = self.pool.pop()
            node.reset()
            return node
        return TrieNode()
    
    def deallocate(self, node):
        self.pool.append(node)
```

### 4. Compact Boolean Storage
```python
class CompactTrieNode:
    """Use bit flags instead of separate booleans"""
    def __init__(self):
        self.children = {}
        self.flags = 0
        # Bit 0: is_end_of_word
        # Bit 1: is_frequent
        # Bit 2-7: reserved
    
    @property
    def is_end_of_word(self):
        return bool(self.flags & 1)
    
    @is_end_of_word.setter
    def is_end_of_word(self, value):
        if value:
            self.flags |= 1
        else:
            self.flags &= ~1
```

---

## 3.7 Comparison Table: All Optimization Techniques

| Technique | Space Saving | Implementation Complexity | Speed Impact | Best Use Case |
|-----------|--------------|--------------------------|--------------|---------------|
| **Standard Trie** | Baseline | Simple | Fastest O(m) | Small fixed alphabet, speed critical |
| **Compressed Trie** | 40-60% | High | Slight slowdown | Lots of unique suffixes |
| **TST** | 60-70% | Medium | O(m log n) | Large alphabet, balanced needs |
| **Binary Trie** | 90%+ | Simple | Fast O(bits) | Binary data, XOR problems |
| **HashMap Children** | 30-50% | Simple | O(1) avg | Unknown alphabet, sparse |
| **Hybrid** | 50-70% | Very High | Variable | Production systems |

---

## 3.8 Choosing the Right Structure

### Decision Tree

```
                    Start Here
                        |
              What's your alphabet size?
                   /          \
              Small (â‰¤128)    Large (Unicode)
               /                    \
        Is speed critical?      TST or HashMap
          /         \
        Yes          No
         |            |
    Standard      Compressed
      Trie            Trie
         |
    Is memory
    constrained?
      /     \
    Yes      No
     |        |
   TST    Standard
```

### Real-World Examples

**Google Search Autocomplete:**
- Uses compressed trie + caching
- Stores millions of queries
- Optimized for prefix matching

**IP Routing:**
- Binary trie (CIDR matching)
- Extremely fast lookups
- Network prefix hierarchy

**Spell Checker:**
- Standard trie for speed
- Memory acceptable for dictionary size
- Need fast existence checks

**Database Indexes:**
- B-tree (generalized trie)
- Disk-based, optimized for I/O
- Prefix compression

---

## ðŸ§  Mastery Check

Test your deep understanding:

1. **Analysis**: You have 1 million English words. Calculate the exact memory savings of using TST vs standard trie. Show your work.

2. **Design Challenge**: Design a trie variant for storing DNA sequences (alphabet: A, C, G, T) that minimizes memory. What's your approach?

3. **Trade-off Question**: When would a compressed trie actually use MORE memory than a standard trie?

4. **Implementation**: Modify the binary trie to support deletion with proper cleanup of unused nodes.

5. **Real-World**: You're building autocomplete for a code editor. Which trie variant would you choose and why? Consider: variable names, keywords, large codebases.

6. **Optimization**: The binary trie's `find_max_xor` greedily chooses the opposite bit. Prove why this greedy approach gives the maximum XOR.

---

## What's Next?

You've mastered the foundations! Now you're ready for:
- **Chapter 4**: Advanced interview patterns (Word Search II, Palindrome Pairs, etc.)
- **Chapter 5**: Complex applications (Aho-Corasick, Suffix Trees)
- **Real problems**: Time to tackle LeetCode Hard problems! ðŸš€

Which direction would you like to explore?
