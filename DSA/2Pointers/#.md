# Master Two Pointer Pattern: Complete Interview Guide
## From Beginner to Advanced

---

# Chapter 1: Foundation

## 1.1 What is Two Pointer Technique?
A technique where two pointers iterate through a data structure (usually array/string) until a condition is met, reducing time complexity from O(n¬≤) to O(n).

## 1.2 When to Use Two Pointers
- Array/string is **sorted** or has some **order**
- Finding pairs, triplets, or subarrays with specific properties
- In-place operations with O(1) space requirement
- Comparing elements from different positions
- Palindrome-related problems

## 1.3 Core Prerequisites
- Array traversal and manipulation
- Basic sorting algorithms
- Hash maps (for comparison/alternative approaches)
- Sliding window basics

> **üí° Key Insight:** Two pointers work because sorted data has predictable behavior‚Äîmoving a pointer changes the result in a known direction.

---

# Chapter 2: Two Pointer Categories

## 2.1 Opposite Direction (Converging Pointers)
Pointers start at opposite ends and move toward each other.

```
[1, 2, 3, 4, 5, 6, 7]
 ‚Üë                 ‚Üë
left             right
```

**Use Cases:**
- Two Sum (sorted array)
- Container with Most Water
- Trapping Rain Water
- Valid Palindrome
- Reverse operations

**Template:**
```python
left, right = 0, len(arr) - 1
while left < right:
    if condition_met:
        return result
    elif need_larger_sum:
        left += 1
    else:
        right -= 1
```

> **‚ö†Ô∏è Important:** Always handle the `left < right` vs `left <= right` boundary carefully based on problem requirements.

---

## 2.2 Same Direction (Fast & Slow Pointers)
Both pointers start from the same position, moving at different speeds or conditions.

```
[1, 2, 3, 4, 5, 6, 7]
 ‚Üë  ‚Üë
slow fast
```

**Use Cases:**
- Remove duplicates in-place
- Move zeros
- Cycle detection (Floyd's algorithm)
- Finding middle element
- Remove element

**Template:**
```python
slow = 0
for fast in range(len(arr)):
    if condition:
        arr[slow] = arr[fast]
        slow += 1
return slow
```

---

## 2.3 Sliding Window (Special Two Pointer)
Window defined by two pointers that expand/contract.

```
[1, 2, 3, 4, 5, 6, 7]
    ‚Üë     ‚Üë
  left   right (window)
```

**Use Cases:**
- Maximum/minimum subarray of size k
- Longest substring without repeating characters
- Minimum window substring
- Subarray with given sum

---

## 2.4 Multiple Arrays/Strings
Pointers on different data structures simultaneously.

```
Array1: [1, 3, 5]    Array2: [2, 4, 6]
         ‚Üë                   ‚Üë
         i                   j
```

**Use Cases:**
- Merge sorted arrays
- Intersection of arrays
- Compare version numbers
- Backspace string compare

---

# Chapter 3: Pattern Deep Dive

## 3.1 Pattern: Pair Sum Variants

### Basic: Two Sum II (Sorted Array)
```python
def two_sum(nums, target):
    l, r = 0, len(nums) - 1
    while l < r:
        curr_sum = nums[l] + nums[r]
        if curr_sum == target:
            return [l + 1, r + 1]
        elif curr_sum < target:
            l += 1
        else:
            r -= 1
```

### Extension: Three Sum
```python
def three_sum(nums):
    nums.sort()
    result = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i-1]:  # Skip duplicates
            continue
        l, r = i + 1, len(nums) - 1
        while l < r:
            total = nums[i] + nums[l] + nums[r]
            if total == 0:
                result.append([nums[i], nums[l], nums[r]])
                while l < r and nums[l] == nums[l+1]: l += 1  # Skip dupes
                while l < r and nums[r] == nums[r-1]: r -= 1
                l += 1; r -= 1
            elif total < 0:
                l += 1
            else:
                r -= 1
    return result
```

> **üí° Duplicate Handling:** In problems requiring unique results, always skip duplicates after finding a valid answer AND at the outer loop level.

### Advanced: Four Sum, K-Sum Generalization
- Reduce to (k-1) Sum recursively
- Base case: Two Sum with two pointers
- Time: O(n^(k-1)) for k-sum

---

## 3.2 Pattern: Partitioning

### Dutch National Flag (3-way Partition)
```python
def sort_colors(nums):
    low, mid, high = 0, 0, len(nums) - 1
    while mid <= high:
        if nums[mid] == 0:
            nums[low], nums[mid] = nums[mid], nums[low]
            low += 1; mid += 1
        elif nums[mid] == 1:
            mid += 1
        else:
            nums[mid], nums[high] = nums[high], nums[mid]
            high -= 1
```

> **‚ö†Ô∏è Critical:** Don't increment `mid` when swapping with `high`‚Äîthe swapped element hasn't been examined yet!

### Quick Select Partition
```python
def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1
```

---

## 3.3 Pattern: In-Place Modification

### Remove Duplicates from Sorted Array
```python
def remove_duplicates(nums):
    if not nums: return 0
    slow = 1
    for fast in range(1, len(nums)):
        if nums[fast] != nums[fast - 1]:
            nums[slow] = nums[fast]
            slow += 1
    return slow
```

### Remove Duplicates II (Allow K duplicates)
```python
def remove_duplicates_k(nums, k=2):
    if len(nums) <= k: return len(nums)
    slow = k
    for fast in range(k, len(nums)):
        if nums[fast] != nums[slow - k]:
            nums[slow] = nums[fast]
            slow += 1
    return slow
```

> **üí° Generalization:** For "allow at most k duplicates," compare `nums[fast]` with `nums[slow - k]`.

---

## 3.4 Pattern: Linked List Cycle & Middle

### Floyd's Cycle Detection
```python
def has_cycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

### Find Cycle Start
```python
def detect_cycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            # Reset one pointer to head
            slow = head
            while slow != fast:
                slow = slow.next
                fast = fast.next
            return slow
    return None
```

> **üìê Math Behind It:** If cycle starts at distance `a` from head, and meeting point is `b` steps into cycle, then `a = c` where `c` is remaining cycle length from meeting point.

### Find Middle Element
```python
def find_middle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow  # For odd: exact middle; For even: second middle
```

---

## 3.5 Pattern: Palindrome Checks

### Valid Palindrome (with cleaning)
```python
def is_palindrome(s):
    l, r = 0, len(s) - 1
    while l < r:
        while l < r and not s[l].isalnum(): l += 1
        while l < r and not s[r].isalnum(): r -= 1
        if s[l].lower() != s[r].lower():
            return False
        l += 1; r -= 1
    return True
```

### Valid Palindrome II (Allow one deletion)
```python
def valid_palindrome(s):
    def is_pali(l, r):
        while l < r:
            if s[l] != s[r]: return False
            l += 1; r -= 1
        return True
    
    l, r = 0, len(s) - 1
    while l < r:
        if s[l] != s[r]:
            return is_pali(l + 1, r) or is_pali(l, r - 1)
        l += 1; r -= 1
    return True
```

---

# Chapter 4: Advanced Techniques

## 4.1 Container Problems

### Container With Most Water
```python
def max_area(height):
    l, r = 0, len(height) - 1
    max_water = 0
    while l < r:
        width = r - l
        h = min(height[l], height[r])
        max_water = max(max_water, width * h)
        if height[l] < height[r]:
            l += 1
        else:
            r -= 1
    return max_water
```

> **üí° Why It Works:** Moving the shorter line is the only way to potentially find a larger area. Moving the taller line can only decrease or maintain area (width decreases, height bounded by shorter).

### Trapping Rain Water
```python
def trap(height):
    if not height: return 0
    l, r = 0, len(height) - 1
    left_max = right_max = 0
    water = 0
    while l < r:
        if height[l] < height[r]:
            if height[l] >= left_max:
                left_max = height[l]
            else:
                water += left_max - height[l]
            l += 1
        else:
            if height[r] >= right_max:
                right_max = height[r]
            else:
                water += right_max - height[r]
            r -= 1
    return water
```

---

## 4.2 Subarray/Substring Problems

### Minimum Size Subarray Sum
```python
def min_sub_array_len(target, nums):
    left = curr_sum = 0
    min_len = float('inf')
    for right in range(len(nums)):
        curr_sum += nums[right]
        while curr_sum >= target:
            min_len = min(min_len, right - left + 1)
            curr_sum -= nums[left]
            left += 1
    return min_len if min_len != float('inf') else 0
```

### Longest Substring with At Most K Distinct Characters
```python
def length_of_longest_substring_k_distinct(s, k):
    from collections import defaultdict
    char_count = defaultdict(int)
    left = max_len = 0
    for right in range(len(s)):
        char_count[s[right]] += 1
        while len(char_count) > k:
            char_count[s[left]] -= 1
            if char_count[s[left]] == 0:
                del char_count[s[left]]
            left += 1
        max_len = max(max_len, right - left + 1)
    return max_len
```

---

## 4.3 Binary Search + Two Pointers

### Find K Closest Elements
```python
def find_closest_elements(arr, k, x):
    left, right = 0, len(arr) - k
    while left < right:
        mid = (left + right) // 2
        if x - arr[mid] > arr[mid + k] - x:
            left = mid + 1
        else:
            right = mid
    return arr[left:left + k]
```

### Kth Smallest Element in Sorted Matrix
- Binary search on value range
- Two pointers to count elements ‚â§ mid

---

## 4.4 Advanced: Multiple Pointers

### 4Sum
```python
def four_sum(nums, target):
    nums.sort()
    result = []
    n = len(nums)
    for i in range(n - 3):
        if i > 0 and nums[i] == nums[i-1]: continue
        for j in range(i + 1, n - 2):
            if j > i + 1 and nums[j] == nums[j-1]: continue
            l, r = j + 1, n - 1
            while l < r:
                total = nums[i] + nums[j] + nums[l] + nums[r]
                if total == target:
                    result.append([nums[i], nums[j], nums[l], nums[r]])
                    while l < r and nums[l] == nums[l+1]: l += 1
                    while l < r and nums[r] == nums[r-1]: r -= 1
                    l += 1; r -= 1
                elif total < target:
                    l += 1
                else:
                    r -= 1
    return result
```

---

# Chapter 5: Hard-Level Problems

## 5.1 Subarrays with Bounded Maximum
```python
def num_subarray_bounded_max(nums, left, right):
    def count(bound):
        ans = curr = 0
        for num in nums:
            curr = curr + 1 if num <= bound else 0
            ans += curr
        return ans
    return count(right) - count(left - 1)
```

## 5.2 Shortest Unsorted Continuous Subarray
```python
def find_unsorted_subarray(nums):
    n = len(nums)
    max_seen, min_seen = float('-inf'), float('inf')
    left, right = 0, -1
    for i in range(n):
        if nums[i] < max_seen:
            right = i
        else:
            max_seen = nums[i]
        if nums[n - 1 - i] > min_seen:
            left = n - 1 - i
        else:
            min_seen = nums[n - 1 - i]
    return right - left + 1
```

## 5.3 Longest Mountain in Array
```python
def longest_mountain(arr):
    n = len(arr)
    if n < 3: return 0
    max_len = 0
    i = 1
    while i < n - 1:
        if arr[i - 1] < arr[i] > arr[i + 1]:  # Peak found
            left = right = i
            while left > 0 and arr[left - 1] < arr[left]:
                left -= 1
            while right < n - 1 and arr[right] > arr[right + 1]:
                right += 1
            max_len = max(max_len, right - left + 1)
            i = right
        else:
            i += 1
    return max_len
```

---

# Chapter 6: Important Notes & Tips

## 6.1 Common Mistakes to Avoid

| Mistake | Solution |
|---------|----------|
| Off-by-one errors | Carefully decide `<` vs `<=` based on overlap needs |
| Infinite loops | Ensure at least one pointer moves each iteration |
| Not handling empty input | Add base case checks |
| Wrong duplicate skipping | Skip AFTER processing, not before |
| Forgetting to sort | Many two-pointer solutions require sorted input |

## 6.2 Optimization Checklist

- [ ] Can brute force O(n¬≤) be reduced to O(n)?
- [ ] Is input sorted? If not, is O(n log n) sort acceptable?
- [ ] Are there duplicates? Handle appropriately
- [ ] What happens at boundaries (first/last elements)?
- [ ] Can this combine with binary search?

## 6.3 Interview Strategy

1. **Identify the pattern** - Is it pair sum, partitioning, or window?
2. **Clarify constraints** - Sorted? Duplicates? Space complexity?
3. **Choose pointer direction** - Same direction or opposite?
4. **Define movement conditions** - When does each pointer move?
5. **Handle edge cases** - Empty, single element, all same

## 6.4 Time & Space Complexity Summary

| Pattern | Time | Space |
|---------|------|-------|
| Two Sum (sorted) | O(n) | O(1) |
| Three Sum | O(n¬≤) | O(1)* |
| Four Sum | O(n¬≥) | O(1)* |
| Cycle Detection | O(n) | O(1) |
| Sliding Window | O(n) | O(1) to O(k) |
| Merge Arrays | O(n + m) | O(1) in-place |

*Excluding output storage

---

# Chapter 7: Practice Problem List

## Beginner
1. Two Sum II - Input Array Is Sorted
2. Valid Palindrome
3. Merge Sorted Array
4. Move Zeroes
5. Remove Duplicates from Sorted Array

## Intermediate
6. 3Sum
7. Container With Most Water
8. Sort Colors (Dutch National Flag)
9. Linked List Cycle II
10. Longest Substring Without Repeating Characters
11. Minimum Size Subarray Sum
12. Palindrome Linked List

## Advanced
13. 4Sum
14. Trapping Rain Water
15. Minimum Window Substring
16. Subarrays with K Different Integers
17. Shortest Unsorted Continuous Subarray
18. 3Sum Closest
19. Longest Mountain in Array
20. Smallest Range Covering Elements from K Lists

---

# Quick Reference Card

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              TWO POINTER DECISION TREE                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                         ‚îÇ
‚îÇ  Is input sorted/needs comparison from both ends?       ‚îÇ
‚îÇ     YES ‚Üí OPPOSITE DIRECTION (converging)               ‚îÇ
‚îÇ     NO  ‚Üí Is it about finding/removing in-place?        ‚îÇ
‚îÇ           YES ‚Üí SAME DIRECTION (fast/slow)              ‚îÇ
‚îÇ           NO  ‚Üí Is it about contiguous subarray?        ‚îÇ
‚îÇ                 YES ‚Üí SLIDING WINDOW                    ‚îÇ
‚îÇ                 NO  ‚Üí Multiple arrays?                  ‚îÇ
‚îÇ                       YES ‚Üí PARALLEL POINTERS           ‚îÇ
‚îÇ                       NO  ‚Üí Consider other approach     ‚îÇ
‚îÇ                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

> **üéØ Final Tip:** Master the basic patterns first. Hard problems are usually combinations or variations of these fundamental patterns!
