# Chapter 6: Important Notes, Tips & Practice Problems

## The Complete Interview Preparation Guide

---

# Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                    CHAPTER 6 ROADMAP                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  6.1 COMMON MISTAKES TO AVOID                                  │
│      └── Off-by-one, Infinite loops, Edge cases, Duplicates    │
│                                                                 │
│  6.2 OPTIMIZATION TECHNIQUES                                   │
│      └── Early termination, Space optimization, Code patterns  │
│                                                                 │
│  6.3 INTERVIEW STRATEGY                                        │
│      └── Problem identification, Communication, Time mgmt      │
│                                                                 │
│  6.4 TIME & SPACE COMPLEXITY REFERENCE                         │
│      └── Complete complexity chart for all patterns            │
│                                                                 │
│  6.5 QUICK REFERENCE CARD                                      │
│      └── Decision trees, Templates, Cheat sheets               │
│                                                                 │
│  6.6 CURATED PRACTICE PROBLEMS                                 │
│      └── 50+ problems organized by pattern and difficulty      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# 6.1 Common Mistakes to Avoid

## 6.1.1 Off-by-One Errors

### The Most Common Bug in Two Pointer Problems

```
┌─────────────────────────────────────────────────────────────────┐
│  OFF-BY-ONE ERROR SCENARIOS                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  MISTAKE 1: Wrong loop condition                               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  while left < right    vs    while left <= right        │   │
│  │                                                          │   │
│  │  Use < when:                                             │   │
│  │  • Pointers should NOT meet (pairs must be different)   │   │
│  │  • Example: Two Sum, Container problems                  │   │
│  │                                                          │   │
│  │  Use <= when:                                            │   │
│  │  • Pointers CAN be at same position                     │   │
│  │  • Example: Binary search, single element check          │   │
│  │  • Dutch National Flag (mid <= high)                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  MISTAKE 2: Wrong initialization                               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  right = len(arr)      vs    right = len(arr) - 1       │   │
│  │                                                          │   │
│  │  Use len(arr) - 1 when:                                  │   │
│  │  • Accessing arr[right] directly                        │   │
│  │                                                          │   │
│  │  Use len(arr) when:                                      │   │
│  │  • Using as exclusive bound in slicing                  │   │
│  │  • Binary search with exclusive right bound             │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  MISTAKE 3: Wrong window size calculation                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Window size = right - left        ❌ (off by one)      │   │
│  │  Window size = right - left + 1    ✓ (correct)         │   │
│  │                                                          │   │
│  │  Example: left=2, right=5                               │   │
│  │  Elements: arr[2], arr[3], arr[4], arr[5] = 4 elements  │   │
│  │  5 - 2 + 1 = 4 ✓                                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Code Examples: Right vs Wrong

```python
# ❌ WRONG: Off-by-one in window size
def max_sum_subarray_wrong(arr, k):
    left = 0
    max_sum = float('-inf')
    window_sum = 0
    
    for right in range(len(arr)):
        window_sum += arr[right]
        
        if right - left == k:  # ❌ Should be right - left + 1 == k
            max_sum = max(max_sum, window_sum)
            window_sum -= arr[left]
            left += 1
    
    return max_sum

# ✓ CORRECT: Proper window size check
def max_sum_subarray_correct(arr, k):
    left = 0
    max_sum = float('-inf')
    window_sum = 0
    
    for right in range(len(arr)):
        window_sum += arr[right]
        
        if right - left + 1 == k:  # ✓ Correct window size
            max_sum = max(max_sum, window_sum)
            window_sum -= arr[left]
            left += 1
    
    return max_sum

# ❌ WRONG: Accessing out of bounds
def two_sum_wrong(nums, target):
    left, right = 0, len(nums)  # ❌ right is out of bounds
    while left < right:
        total = nums[left] + nums[right]  # IndexError!
        # ...

# ✓ CORRECT: Proper initialization
def two_sum_correct(nums, target):
    left, right = 0, len(nums) - 1  # ✓ Valid index
    while left < right:
        total = nums[left] + nums[right]  # Works!
        # ...
```

---

## 6.1.2 Infinite Loop Traps

### Ensuring Progress in Every Iteration

```
┌─────────────────────────────────────────────────────────────────┐
│  INFINITE LOOP CAUSES                                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  CAUSE 1: Forgetting to move pointers                          │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  while left < right:                                     │   │
│  │      if condition:                                       │   │
│  │          process()                                       │   │
│  │          # ❌ Forgot to move left or right!              │   │
│  │      else:                                               │   │
│  │          left += 1                                       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  CAUSE 2: Conditional movement that never triggers             │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  while left < right:                                     │   │
│  │      if arr[left] < arr[right]:                         │   │
│  │          left += 1                                       │   │
│  │      # ❌ What if arr[left] >= arr[right] always?        │   │
│  │      # Need else clause to move right!                   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  CAUSE 3: Sliding window shrink condition never met            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  while window_sum > target:  # What if sum never > target?│  │
│  │      window_sum -= arr[left]                             │   │
│  │      left += 1                                           │   │
│  │  # This is actually fine - while just doesn't execute    │   │
│  │                                                          │   │
│  │  # ❌ REAL PROBLEM:                                      │   │
│  │  while left < right and arr[left] == arr[left]:         │   │
│  │      pass  # Always true, infinite loop!                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### The Golden Rule

```python
"""
GOLDEN RULE: At least ONE pointer must move in every iteration!

Verify your code by checking:
1. In EVERY branch of your if/elif/else, does a pointer move?
2. If using while loops inside, do they have proper termination?
3. Are there any conditions that could always be true/false?
"""

# ❌ WRONG: Pointer might not move
def find_pair_wrong(arr, target):
    left, right = 0, len(arr) - 1
    while left < right:
        total = arr[left] + arr[right]
        if total == target:
            return [left, right]
        elif total < target:
            left += 1
        # ❌ Missing else: right never decrements if total >= target!
    return []

# ✓ CORRECT: Pointer always moves
def find_pair_correct(arr, target):
    left, right = 0, len(arr) - 1
    while left < right:
        total = arr[left] + arr[right]
        if total == target:
            return [left, right]
        elif total < target:
            left += 1
        else:  # ✓ Explicit else ensures right moves
            right -= 1
    return []
```

---

## 6.1.3 Edge Case Failures

### Comprehensive Edge Case Checklist

```
┌─────────────────────────────────────────────────────────────────┐
│  EDGE CASES EVERY SOLUTION MUST HANDLE                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  INPUT SIZE EDGE CASES:                                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  □ Empty array/string: []  ""                           │   │
│  │  □ Single element: [5]  "a"                             │   │
│  │  □ Two elements: [1, 2]  "ab"                           │   │
│  │  □ Array smaller than k (for window problems)           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  VALUE EDGE CASES:                                              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  □ All same elements: [5, 5, 5, 5]                      │   │
│  │  □ All zeros: [0, 0, 0]                                 │   │
│  │  □ Negative numbers: [-3, -1, 0, 2]                     │   │
│  │  □ Very large/small values: [10^9, -10^9]              │   │
│  │  □ Sorted ascending: [1, 2, 3, 4, 5]                    │   │
│  │  □ Sorted descending: [5, 4, 3, 2, 1]                   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  RESULT EDGE CASES:                                             │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  □ No solution exists                                    │   │
│  │  □ Multiple valid solutions (return any vs all)         │   │
│  │  □ Answer at beginning or end of array                  │   │
│  │  □ Answer spans entire array                            │   │
│  │  □ Answer is empty (return 0, [], or "")               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  DUPLICATE EDGE CASES:                                          │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  □ All duplicates: [2, 2, 2, 2]                         │   │
│  │  □ Duplicates at target positions                       │   │
│  │  □ Consecutive duplicates: [1, 1, 2, 2, 3, 3]          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Edge Case Handling Template

```python
def two_pointer_template(arr, *args):
    """Template with comprehensive edge case handling."""
    
    # ========== EDGE CASE CHECKS ==========
    # Empty input
    if not arr:
        return default_empty_result()
    
    # Single element
    if len(arr) == 1:
        return handle_single_element(arr[0])
    
    # Input too small for problem (e.g., k > len(arr))
    if len(arr) < required_size:
        return default_invalid_result()
    
    # ========== MAIN ALGORITHM ==========
    left, right = 0, len(arr) - 1
    result = initial_result()
    
    while left < right:  # or left <= right based on problem
        # Process current state
        current = process(arr, left, right)
        
        # Update result
        result = update_result(result, current)
        
        # Move pointers (ALWAYS move at least one!)
        if condition_move_left:
            left += 1
        else:
            right -= 1
    
    # ========== HANDLE NO SOLUTION ==========
    if result == initial_result():
        return no_solution_result()
    
    return result

# Example: Two Sum with edge cases
def two_sum_safe(numbers, target):
    # Edge cases
    if not numbers or len(numbers) < 2:
        return []
    
    left, right = 0, len(numbers) - 1
    
    while left < right:
        current_sum = numbers[left] + numbers[right]
        
        if current_sum == target:
            return [left + 1, right + 1]  # 1-indexed
        elif current_sum < target:
            left += 1
        else:
            right -= 1
    
    return []  # No solution
```

---

## 6.1.4 Duplicate Handling Mistakes

### The Three Levels of Duplicate Handling

```
┌─────────────────────────────────────────────────────────────────┐
│  DUPLICATE HANDLING IN TWO POINTER PROBLEMS                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  LEVEL 1: Skip duplicates at OUTER loop (first element)        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  for i in range(n - 2):                                  │   │
│  │      if i > 0 and nums[i] == nums[i-1]:                 │   │
│  │          continue  # Skip duplicate first element        │   │
│  │      # ... two pointer search                            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  LEVEL 2: Skip duplicates at INNER level (second/third elem)   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  if current_sum == target:                               │   │
│  │      result.append([...])                                │   │
│  │      # Skip duplicates AFTER adding result               │   │
│  │      while left < right and nums[left] == nums[left+1]: │   │
│  │          left += 1                                       │   │
│  │      while left < right and nums[right] == nums[right-1]:│   │
│  │          right -= 1                                      │   │
│  │      left += 1                                           │   │
│  │      right -= 1                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  COMMON MISTAKE: Skipping BEFORE checking                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  # ❌ WRONG: Might skip the first valid answer!         │   │
│  │  while left < right and nums[left] == nums[left+1]:     │   │
│  │      left += 1                                           │   │
│  │  # Now check if it's a match...                         │   │
│  │                                                          │   │
│  │  # ✓ CORRECT: Skip AFTER finding a match                │   │
│  │  if is_match:                                            │   │
│  │      add_to_result()                                     │   │
│  │      while left < right and nums[left] == nums[left+1]: │   │
│  │          left += 1                                       │   │
│  │      left += 1  # Move past the duplicate group         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Complete 3Sum with Proper Duplicate Handling

```python
def three_sum(nums: list[int]) -> list[list[int]]:
    """
    3Sum with comprehensive duplicate handling.
    Returns all unique triplets summing to zero.
    """
    nums.sort()  # Required for two pointers and duplicate handling
    result = []
    n = len(nums)
    
    for i in range(n - 2):
        # LEVEL 1: Skip duplicates for first element
        # Note: i > 0, not i >= 0, to not skip first element
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        
        # Early termination: smallest possible sum > 0
        if nums[i] > 0:
            break
        
        left, right = i + 1, n - 1
        
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            
            if total == 0:
                result.append([nums[i], nums[left], nums[right]])
                
                # LEVEL 2: Skip duplicates for second and third elements
                # AFTER adding the result
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                
                # Move both pointers past the duplicates
                left += 1
                right -= 1
                
            elif total < 0:
                left += 1
            else:
                right -= 1
    
    return result
```

---

## 6.1.5 Dutch National Flag Specific Mistake

### The Classic Mid Pointer Bug

```
┌─────────────────────────────────────────────────────────────────┐
│  DUTCH NATIONAL FLAG - THE MID POINTER TRAP                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ❌ WRONG: Incrementing mid when swapping with high            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  if nums[mid] == 2:                                      │   │
│  │      nums[mid], nums[high] = nums[high], nums[mid]      │   │
│  │      high -= 1                                           │   │
│  │      mid += 1  # ❌ BUG! Haven't examined swapped value! │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  WHY IT'S WRONG:                                                │
│  • When we swap with high, we get an UNEXAMINED element        │
│  • This element could be 0, 1, or 2                            │
│  • If we increment mid, we skip examining it!                  │
│                                                                 │
│  Example: [2, 0, 1]                                            │
│  mid=0, high=2: nums[0]=2, swap with nums[2]                  │
│  Array becomes: [1, 0, 2]                                      │
│  If we do mid++, we're now at mid=1                           │
│  But nums[0]=1 was never properly processed!                   │
│                                                                 │
│  ✓ CORRECT: Don't increment mid when swapping with high        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  if nums[mid] == 2:                                      │   │
│  │      nums[mid], nums[high] = nums[high], nums[mid]      │   │
│  │      high -= 1                                           │   │
│  │      # Don't increment mid! Will examine swapped value   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# 6.2 Optimization Techniques

## 6.2.1 Early Termination

### When and How to Terminate Early

```python
"""
EARLY TERMINATION PATTERNS

These optimizations can significantly improve average-case performance
without affecting worst-case complexity.
"""

# PATTERN 1: Impossible range termination
def three_sum_optimized(nums, target=0):
    nums.sort()
    n = len(nums)
    result = []
    
    for i in range(n - 2):
        # Skip duplicates
        if i > 0 and nums[i] == nums[i-1]:
            continue
        
        # OPTIMIZATION 1: If smallest > 0, no more solutions
        if nums[i] > 0:
            break
        
        # OPTIMIZATION 2: If current + two largest < target, skip
        if nums[i] + nums[n-2] + nums[n-1] < target:
            continue
        
        # OPTIMIZATION 3: If current + two smallest > target, break
        if nums[i] + nums[i+1] + nums[i+2] > target:
            break
        
        # ... rest of two pointer logic
    
    return result

# PATTERN 2: Found exact match
def binary_search_first(arr, target):
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            result = mid
            right = mid - 1  # Continue searching left for first occurrence
            # Could early terminate if we only need ANY occurrence:
            # return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result

# PATTERN 3: Target achieved in sliding window
def min_length_subarray(nums, target):
    left = 0
    current_sum = 0
    min_len = float('inf')
    
    for right in range(len(nums)):
        current_sum += nums[right]
        
        while current_sum >= target:
            min_len = min(min_len, right - left + 1)
            
            # OPTIMIZATION: Can't get shorter than 1!
            if min_len == 1:
                return 1
            
            current_sum -= nums[left]
            left += 1
    
    return min_len if min_len != float('inf') else 0
```

---

## 6.2.2 Space Optimization

### Reducing O(n) to O(1) Space

```
┌─────────────────────────────────────────────────────────────────┐
│  SPACE OPTIMIZATION TECHNIQUES                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  TECHNIQUE 1: In-place modification instead of new array       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  # O(n) space                                            │   │
│  │  result = []                                             │   │
│  │  for num in nums:                                        │   │
│  │      if num != val:                                      │   │
│  │          result.append(num)                              │   │
│  │                                                          │   │
│  │  # O(1) space - two pointers                            │   │
│  │  slow = 0                                                │   │
│  │  for fast in range(len(nums)):                          │   │
│  │      if nums[fast] != val:                              │   │
│  │          nums[slow] = nums[fast]                        │   │
│  │          slow += 1                                       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  TECHNIQUE 2: Two pointers instead of hash set                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  # O(n) space with hash set                             │   │
│  │  seen = set()                                            │   │
│  │  for num in nums:                                        │   │
│  │      if target - num in seen:                           │   │
│  │          return True                                     │   │
│  │      seen.add(num)                                       │   │
│  │                                                          │   │
│  │  # O(1) space with two pointers (if sorted allowed)     │   │
│  │  nums.sort()                                             │   │
│  │  left, right = 0, len(nums) - 1                         │   │
│  │  while left < right:                                     │   │
│  │      # ... two pointer logic                            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  TECHNIQUE 3: Constant space for character counts              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  # O(k) where k = unique chars, but k ≤ 26 for lowercase│   │
│  │  # So it's effectively O(1)!                            │   │
│  │  count = [0] * 26  # Instead of Counter()               │   │
│  │  for char in s:                                          │   │
│  │      count[ord(char) - ord('a')] += 1                   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Space Optimization Examples

```python
# Example 1: Reverse words in string - O(1) space
def reverse_words_in_place(s: list[str]) -> None:
    """
    Reverse words in-place using two pointers.
    s is a list of characters for in-place modification.
    """
    def reverse(left, right):
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
    
    # Step 1: Reverse entire string
    reverse(0, len(s) - 1)
    
    # Step 2: Reverse each word
    n = len(s)
    left = 0
    for right in range(n + 1):
        if right == n or s[right] == ' ':
            reverse(left, right - 1)
            left = right + 1

# Example 2: Check palindrome - O(1) space
def is_palindrome_optimized(s: str) -> bool:
    """No extra space for filtered string."""
    left, right = 0, len(s) - 1
    
    while left < right:
        # Skip non-alphanumeric (no extra string created)
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
        
        if s[left].lower() != s[right].lower():
            return False
        
        left += 1
        right -= 1
    
    return True
```

---

## 6.2.3 Code Patterns for Clean Implementation

### Template 1: Converging Two Pointers

```python
def converging_template(arr, target):
    """Clean template for opposite-direction two pointers."""
    # Handle edge cases
    if not arr or len(arr) < 2:
        return default_result()
    
    left, right = 0, len(arr) - 1
    result = initial_value()
    
    while left < right:
        current = compute(arr[left], arr[right])
        
        if current == target:
            return found_result(left, right)
        elif current < target:
            left += 1
        else:
            right -= 1
    
    return not_found_result()
```

### Template 2: Sliding Window (Dynamic)

```python
def sliding_window_template(arr, condition):
    """Clean template for variable-size sliding window."""
    if not arr:
        return default_result()
    
    left = 0
    window_state = initial_state()  # sum, count, dict, etc.
    result = initial_result()
    
    for right in range(len(arr)):
        # EXPAND: Add arr[right] to window
        update_window_add(window_state, arr[right])
        
        # SHRINK: While window is invalid
        while is_invalid(window_state, condition):
            update_window_remove(window_state, arr[left])
            left += 1
        
        # UPDATE: Record result
        result = update_result(result, left, right, window_state)
    
    return result
```

### Template 3: Fast-Slow Pointers

```python
def fast_slow_template(arr, condition):
    """Clean template for same-direction two pointers."""
    if not arr:
        return default_result()
    
    slow = 0  # Write position / slow pointer
    
    for fast in range(len(arr)):
        if meets_condition(arr[fast], condition):
            arr[slow] = arr[fast]  # or process
            slow += 1
    
    return slow  # New length or result
```

---

# 6.3 Interview Strategy

## 6.3.1 Problem Identification Framework

### Step-by-Step Recognition Process

```
┌─────────────────────────────────────────────────────────────────┐
│  TWO POINTER IDENTIFICATION FRAMEWORK                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  STEP 1: Check if LINEAR data structure                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  □ Array?                                                │   │
│  │  □ String?                                               │   │
│  │  □ Linked List?                                          │   │
│  │                                                          │   │
│  │  If NO → Consider BFS, DFS, or other approaches         │   │
│  │  If YES → Continue to Step 2                            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  STEP 2: Check if data is SORTED or can be SORTED             │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  □ Already sorted?                                       │   │
│  │  □ Can we sort without losing information?              │   │
│  │  □ Does sorting help (pair sums, etc.)?                 │   │
│  │                                                          │   │
│  │  If YES → Strong candidate for two pointers             │   │
│  │  If NO → Consider sliding window or hash map            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  STEP 3: Identify the PATTERN keywords                         │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Keywords suggesting TWO POINTERS:                       │   │
│  │  • "pair", "two numbers", "sum to target"               │   │
│  │  • "palindrome", "reverse"                              │   │
│  │  • "in-place", "O(1) space"                             │   │
│  │  • "sorted array", "merge"                              │   │
│  │  • "container", "trapping"                              │   │
│  │                                                          │   │
│  │  Keywords suggesting SLIDING WINDOW:                     │   │
│  │  • "subarray", "substring", "contiguous"                │   │
│  │  • "maximum/minimum length"                             │   │
│  │  • "at most K", "exactly K", "distinct"                 │   │
│  │  • "window", "consecutive"                              │   │
│  │                                                          │   │
│  │  Keywords suggesting FAST-SLOW:                          │   │
│  │  • "cycle", "middle", "nth from end"                    │   │
│  │  • "remove duplicates", "in-place"                      │   │
│  │  • "partition"                                           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Quick Decision Tree

```
                    START
                      │
         ┌────────────┴────────────┐
         │  Is input linear        │
         │  (array/string/list)?   │
         └────────────┬────────────┘
                      │
              YES     │     NO
         ┌────────────┴────────────┐
         │                         │
         ▼                         ▼
┌─────────────────┐      Consider other algorithms
│ Looking for     │      (trees, graphs, DP)
│ pair/triplet?   │
└────────┬────────┘
    YES  │  NO
         │   │
    ┌────┘   └────┐
    ▼             ▼
┌─────────┐  ┌─────────────────┐
│ SORTED? │  │ Contiguous      │
│         │  │ subarray/substr?│
└────┬────┘  └────────┬────────┘
YES  │  NO       YES  │  NO
     │   │            │   │
     ▼   ▼            ▼   ▼
   TWO   HASH      SLIDING  Consider
POINTERS  MAP      WINDOW   FAST-SLOW
                           or other
```

---

## 6.3.2 Communication During Interview

### The STAR Method for Algorithm Problems

```
┌─────────────────────────────────────────────────────────────────┐
│  INTERVIEW COMMUNICATION FRAMEWORK                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  S - STATE the problem in your own words                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  "So I need to find two numbers in this sorted array    │   │
│  │   that add up to the target, and return their indices." │   │
│  │                                                          │   │
│  │  ASK CLARIFYING QUESTIONS:                              │   │
│  │  • Is the array sorted?                                  │   │
│  │  • Can I modify the input array?                         │   │
│  │  • What if there's no solution?                          │   │
│  │  • Are there duplicates?                                 │   │
│  │  • What are the constraints (size, values)?             │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  T - THINK out loud about approaches                           │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  "I can think of a few approaches:                      │   │
│  │   1. Brute force: Check all pairs - O(n²)              │   │
│  │   2. Hash map: One pass with complement lookup - O(n)   │   │
│  │   3. Two pointers: Since it's sorted - O(n), O(1) space│   │
│  │                                                          │   │
│  │   Since the array is sorted and we want O(1) space,    │   │
│  │   I'll use two pointers."                               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  A - APPROACH explanation                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  "I'll use two pointers starting at both ends.          │   │
│  │   - If sum < target: move left pointer right            │   │
│  │   - If sum > target: move right pointer left            │   │
│  │   - If sum == target: found the answer                  │   │
│  │                                                          │   │
│  │   This works because the array is sorted, so moving     │   │
│  │   left increases the sum and moving right decreases it."│   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  R - RESULT with complexity analysis                           │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  After coding: "Let me trace through an example..."     │   │
│  │                                                          │   │
│  │  "Time complexity is O(n) because each pointer moves    │   │
│  │   at most n times, and we do O(1) work per move."      │   │
│  │                                                          │   │
│  │  "Space complexity is O(1) because we only use          │   │
│  │   two pointers regardless of input size."               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 6.3.3 Time Management

### 45-Minute Interview Breakdown

```
┌─────────────────────────────────────────────────────────────────┐
│  OPTIMAL TIME ALLOCATION (45 min interview)                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  0:00 - 0:05  (5 min)  │  UNDERSTAND                           │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  • Read/listen to problem                                │   │
│  │  • Ask clarifying questions                              │   │
│  │  • Confirm constraints and edge cases                   │   │
│  │  • Write down examples                                   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  0:05 - 0:10  (5 min)  │  PLAN                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  • Discuss brute force approach                         │   │
│  │  • Identify optimization (two pointers!)                │   │
│  │  • Explain your approach clearly                        │   │
│  │  • Get interviewer's agreement before coding            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  0:10 - 0:30  (20 min) │  CODE                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  • Write clean, readable code                           │   │
│  │  • Talk through your logic                              │   │
│  │  • Handle edge cases                                     │   │
│  │  • Use meaningful variable names                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  0:30 - 0:40  (10 min) │  TEST                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  • Trace through with example                           │   │
│  │  • Test edge cases (empty, single, all same)            │   │
│  │  • Fix any bugs                                          │   │
│  │  • Analyze time/space complexity                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  0:40 - 0:45  (5 min)  │  OPTIMIZE & DISCUSS                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  • Discuss potential optimizations                       │   │
│  │  • Handle follow-up questions                           │   │
│  │  • Ask your own questions about the role/team           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# 6.4 Time & Space Complexity Reference

## Complete Complexity Chart

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    TIME & SPACE COMPLEXITY REFERENCE                    │
├─────────────────────────────┬──────────────┬──────────────┬─────────────┤
│         PATTERN             │    TIME      │    SPACE     │    NOTES    │
├─────────────────────────────┼──────────────┼──────────────┼─────────────┤
│ TWO SUM (sorted)            │    O(n)      │    O(1)      │ Linear scan │
│ TWO SUM (unsorted)          │    O(n)      │    O(n)      │ Hash map    │
├─────────────────────────────┼──────────────┼──────────────┼─────────────┤
│ THREE SUM                   │    O(n²)     │    O(1)*     │ Sort + 2ptr │
│ THREE SUM CLOSEST           │    O(n²)     │    O(1)*     │ Track best  │
│ THREE SUM SMALLER           │    O(n²)     │    O(1)*     │ Count pairs │
├─────────────────────────────┼──────────────┼──────────────┼─────────────┤
│ FOUR SUM                    │    O(n³)     │    O(1)*     │ 2 loops+2ptr│
│ FOUR SUM II (4 arrays)      │    O(n²)     │    O(n²)     │ Hash map    │
│ K-SUM                       │   O(n^(k-1)) │    O(k)      │ Recursive   │
├─────────────────────────────┼──────────────┼──────────────┼─────────────┤
│ CONTAINER WITH MOST WATER   │    O(n)      │    O(1)      │ Greedy move │
│ TRAPPING RAIN WATER         │    O(n)      │    O(1)      │ Two pointer │
│ TRAPPING RAIN WATER (DP)    │    O(n)      │    O(n)      │ Precompute  │
├─────────────────────────────┼──────────────┼──────────────┼─────────────┤
│ REMOVE DUPLICATES           │    O(n)      │    O(1)      │ Fast-slow   │
│ REMOVE ELEMENT              │    O(n)      │    O(1)      │ Fast-slow   │
│ MOVE ZEROS                  │    O(n)      │    O(1)      │ Fast-slow   │
│ SORT COLORS                 │    O(n)      │    O(1)      │ Dutch flag  │
├─────────────────────────────┼──────────────┼──────────────┼─────────────┤
│ VALID PALINDROME            │    O(n)      │    O(1)      │ Two ends    │
│ PALINDROME II (1 delete)    │    O(n)      │    O(1)      │ Try both    │
│ LONGEST PALINDROMIC SUBSTR  │    O(n²)     │    O(1)      │ Expand      │
├─────────────────────────────┼──────────────┼──────────────┼─────────────┤
│ SLIDING WINDOW MAX          │    O(n)      │    O(k)      │ Monotonic Q │
│ SLIDING WINDOW MEDIAN       │   O(n log k) │    O(k)      │ Two heaps   │
│ MIN SIZE SUBARRAY SUM       │    O(n)      │    O(1)      │ Shrink-expand│
│ LONGEST SUBSTR K DISTINCT   │    O(n)      │    O(k)      │ Hash + window│
│ MIN WINDOW SUBSTRING        │    O(n)      │    O(m)      │ Formed count│
├─────────────────────────────┼──────────────┼──────────────┼─────────────┤
│ CYCLE DETECTION             │    O(n)      │    O(1)      │ Floyd's     │
│ FIND CYCLE START            │    O(n)      │    O(1)      │ Phase 2     │
│ FIND MIDDLE                 │    O(n)      │    O(1)      │ Fast-slow   │
│ NTH FROM END                │    O(n)      │    O(1)      │ Gap pointers│
├─────────────────────────────┼──────────────┼──────────────┼─────────────┤
│ MERGE SORTED ARRAYS         │   O(m + n)   │    O(1)**    │ From end    │
│ MERGE K SORTED LISTS        │  O(N log k)  │   O(log k)   │ D&C         │
│ MERGE K SORTED LISTS        │  O(N log k)  │    O(k)      │ Heap        │
├─────────────────────────────┼──────────────┼──────────────┼─────────────┤
│ MEDIAN OF TWO SORTED        │ O(log min)   │    O(1)      │ Binary srch │
│ KTH SMALLEST IN MATRIX      │ O(n log W)   │    O(1)      │ BS + count  │
│ KTH SMALLEST PAIR DISTANCE  │ O(n log W)   │    O(1)      │ BS + 2ptr   │
└─────────────────────────────┴──────────────┴──────────────┴─────────────┘

* Excluding output storage
** In-place modification
W = value range
```

---

# 6.5 Quick Reference Card

## Master Decision Tree

```
┌─────────────────────────────────────────────────────────────────┐
│                WHICH TWO POINTER PATTERN?                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                    YOUR PROBLEM                          │  │
│  └──────────────────────────────────────────────────────────┘  │
│                              │                                  │
│           ┌──────────────────┼──────────────────┐              │
│           ▼                  ▼                  ▼              │
│    ┌────────────┐    ┌─────────────┐    ┌─────────────┐       │
│    │  SORTED    │    │ CONTIGUOUS  │    │  LINKED     │       │
│    │  ARRAY?    │    │ SUBARRAY?   │    │  LIST?      │       │
│    └─────┬──────┘    └──────┬──────┘    └──────┬──────┘       │
│          │                  │                   │              │
│          ▼                  ▼                   ▼              │
│    ┌───────────┐     ┌───────────┐      ┌───────────┐         │
│    │ OPPOSITE  │     │ SLIDING   │      │ FAST-SLOW │         │
│    │ DIRECTION │     │ WINDOW    │      │ POINTERS  │         │
│    └───────────┘     └───────────┘      └───────────┘         │
│          │                  │                   │              │
│          ▼                  ▼                   ▼              │
│    • Two Sum         • Min/Max length     • Cycle detect      │
│    • Three Sum       • At most K          • Find middle       │
│    • Container       • Exactly K          • Nth from end      │
│    • Palindrome      • Distinct chars     • Palindrome LL     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## Pattern Templates Cheat Sheet

```python
# ═══════════════════════════════════════════════════════════════
# TEMPLATE 1: OPPOSITE DIRECTION (Converging)
# ═══════════════════════════════════════════════════════════════
def opposite_direction(arr, target):
    left, right = 0, len(arr) - 1
    while left < right:
        curr = arr[left] + arr[right]  # or other computation
        if curr == target:
            return [left, right]
        elif curr < target:
            left += 1
        else:
            right -= 1
    return []

# ═══════════════════════════════════════════════════════════════
# TEMPLATE 2: SAME DIRECTION (Fast-Slow for Arrays)
# ═══════════════════════════════════════════════════════════════
def same_direction(arr):
    slow = 0
    for fast in range(len(arr)):
        if is_valid(arr[fast]):
            arr[slow] = arr[fast]
            slow += 1
    return slow

# ═══════════════════════════════════════════════════════════════
# TEMPLATE 3: SLIDING WINDOW (Dynamic Size)
# ═══════════════════════════════════════════════════════════════
def sliding_window(arr, k):
    left = 0
    window = {}  # or sum, count, etc.
    result = 0
    
    for right in range(len(arr)):
        # Expand
        add_to_window(window, arr[right])
        
        # Shrink while invalid
        while is_invalid(window, k):
            remove_from_window(window, arr[left])
            left += 1
        
        # Update result
        result = max(result, right - left + 1)
    
    return result

# ═══════════════════════════════════════════════════════════════
# TEMPLATE 4: LINKED LIST (Cycle Detection)
# ═══════════════════════════════════════════════════════════════
def floyd_cycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True  # Cycle found
    return False

# ═══════════════════════════════════════════════════════════════
# TEMPLATE 5: MULTIPLE ARRAYS (Merge)
# ═══════════════════════════════════════════════════════════════
def merge_arrays(arr1, arr2):
    i, j = 0, 0
    result = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] <= arr2[j]:
            result.append(arr1[i])
            i += 1
        else:
            result.append(arr2[j])
            j += 1
    result.extend(arr1[i:])
    result.extend(arr2[j:])
    return result
```

---

# 6.6 Curated Practice Problems

## Organized by Difficulty and Pattern

### 🟢 BEGINNER LEVEL (Start Here)

```
┌─────────────────────────────────────────────────────────────────┐
│  BEGINNER PROBLEMS (15 problems)                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  OPPOSITE DIRECTION:                                            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  1. Two Sum II (LC 167) ⭐ START HERE                   │   │
│  │     Pattern: Basic converging pointers                   │   │
│  │     Key: Sum too small → move left, too big → move right│   │
│  │                                                          │   │
│  │  2. Valid Palindrome (LC 125)                           │   │
│  │     Pattern: Compare from both ends                      │   │
│  │     Key: Skip non-alphanumeric characters               │   │
│  │                                                          │   │
│  │  3. Reverse String (LC 344)                             │   │
│  │     Pattern: Swap from ends toward middle               │   │
│  │     Key: Basic swap operation                           │   │
│  │                                                          │   │
│  │  4. Squares of a Sorted Array (LC 977)                  │   │
│  │     Pattern: Largest squares at ends                     │   │
│  │     Key: Fill result from back                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  SAME DIRECTION (Fast-Slow):                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  5. Remove Duplicates from Sorted Array (LC 26)         │   │
│  │     Pattern: slow=writer, fast=reader                   │   │
│  │     Key: Write when new value found                      │   │
│  │                                                          │   │
│  │  6. Remove Element (LC 27)                              │   │
│  │     Pattern: Skip unwanted elements                      │   │
│  │     Key: Only write elements != val                     │   │
│  │                                                          │   │
│  │  7. Move Zeroes (LC 283)                                │   │
│  │     Pattern: Move non-zeros forward                      │   │
│  │     Key: Swap to maintain relative order                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  LINKED LIST:                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  8. Middle of Linked List (LC 876)                      │   │
│  │     Pattern: Slow goes 1x, fast goes 2x                 │   │
│  │     Key: When fast reaches end, slow is at middle       │   │
│  │                                                          │   │
│  │  9. Linked List Cycle (LC 141)                          │   │
│  │     Pattern: Floyd's cycle detection                     │   │
│  │     Key: If cycle exists, fast catches slow             │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  MULTIPLE ARRAYS:                                               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  10. Merge Sorted Array (LC 88)                         │   │
│  │      Pattern: Merge from end to avoid overwriting       │   │
│  │      Key: Largest elements placed first                 │   │
│  │                                                          │   │
│  │  11. Intersection of Two Arrays II (LC 350)             │   │
│  │      Pattern: Two pointers on sorted arrays             │   │
│  │      Key: Move pointer with smaller value               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  SLIDING WINDOW (Basic):                                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  12. Maximum Average Subarray I (LC 643)                │   │
│  │      Pattern: Fixed-size sliding window                 │   │
│  │      Key: Add right, remove left                        │   │
│  │                                                          │   │
│  │  13. Longest Substring Without Repeating (LC 3)         │   │
│  │      Pattern: Dynamic sliding window                    │   │
│  │      Key: Shrink when duplicate found                   │   │
│  │                                                          │   │
│  │  14. Minimum Size Subarray Sum (LC 209)                 │   │
│  │      Pattern: Shrink while valid                        │   │
│  │      Key: Expand first, then shrink to minimize         │   │
│  │                                                          │   │
│  │  15. Max Consecutive Ones III (LC 1004)                 │   │
│  │      Pattern: At most k zeros allowed                   │   │
│  │      Key: Shrink when zeros > k                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 🟡 INTERMEDIATE LEVEL

```
┌─────────────────────────────────────────────────────────────────┐
│  INTERMEDIATE PROBLEMS (20 problems)                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  SUM PROBLEMS:                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  16. 3Sum (LC 15) ⭐ MUST MASTER                        │   │
│  │      Key: Fix one + two pointers, handle duplicates     │   │
│  │                                                          │   │
│  │  17. 3Sum Closest (LC 16)                               │   │
│  │      Key: Track closest difference                       │   │
│  │                                                          │   │
│  │  18. 4Sum (LC 18)                                       │   │
│  │      Key: Fix two + two pointers                        │   │
│  │                                                          │   │
│  │  19. Two Sum Less Than K (LC 1099)                      │   │
│  │      Key: Track maximum sum < k                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  CONTAINER PROBLEMS:                                            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  20. Container With Most Water (LC 11) ⭐               │   │
│  │      Key: Move shorter line (greedy proof)              │   │
│  │                                                          │   │
│  │  21. Trapping Rain Water (LC 42) ⭐                     │   │
│  │      Key: Process from side with smaller max            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  PARTITIONING:                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  22. Sort Colors (LC 75) ⭐ Dutch National Flag         │   │
│  │      Key: Don't increment mid when swapping with high   │   │
│  │                                                          │   │
│  │  23. Partition Labels (LC 763)                          │   │
│  │      Key: Track last occurrence of each char            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  LINKED LIST:                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  24. Linked List Cycle II (LC 142) ⭐                   │   │
│  │      Key: Reset one pointer to head after meeting       │   │
│  │                                                          │   │
│  │  25. Remove Nth Node From End (LC 19)                   │   │
│  │      Key: Fast pointer gets n-step head start           │   │
│  │                                                          │   │
│  │  26. Palindrome Linked List (LC 234)                    │   │
│  │      Key: Find middle, reverse second half, compare     │   │
│  │                                                          │   │
│  │  27. Reorder List (LC 143)                              │   │
│  │      Key: Split, reverse second half, merge alternating │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  SLIDING WINDOW (Advanced):                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  28. Longest Substring with At Most K Distinct (LC 340) │   │
│  │      Key: Shrink when distinct > k                      │   │
│  │                                                          │   │
│  │  29. Fruit Into Baskets (LC 904)                        │   │
│  │      Key: At most 2 types = at most 2 distinct          │   │
│  │                                                          │   │
│  │  30. Permutation in String (LC 567)                     │   │
│  │      Key: Fixed window, compare char counts             │   │
│  │                                                          │   │
│  │  31. Find All Anagrams (LC 438)                         │   │
│  │      Key: Fixed window, track "formed" chars            │   │
│  │                                                          │   │
│  │  32. Subarray Product Less Than K (LC 713)              │   │
│  │      Key: Count subarrays ending at each position       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  STRING PROBLEMS:                                               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  33. Valid Palindrome II (LC 680)                       │   │
│  │      Key: Try deleting either char on mismatch          │   │
│  │                                                          │   │
│  │  34. Longest Repeating Character Replacement (LC 424)   │   │
│  │      Key: window - max_count ≤ k                        │   │
│  │                                                          │   │
│  │  35. Backspace String Compare (LC 844)                  │   │
│  │      Key: Process from right, count backspaces          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 🔴 ADVANCED LEVEL

```
┌─────────────────────────────────────────────────────────────────┐
│  ADVANCED PROBLEMS (15 problems)                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  HARD SLIDING WINDOW:                                           │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  36. Minimum Window Substring (LC 76) ⭐⭐ MUST KNOW    │   │
│  │      Key: Track "formed" count, shrink while valid      │   │
│  │                                                          │   │
│  │  37. Sliding Window Maximum (LC 239) ⭐⭐               │   │
│  │      Key: Monotonic decreasing deque                    │   │
│  │                                                          │   │
│  │  38. Sliding Window Median (LC 480)                     │   │
│  │      Key: Two heaps with lazy removal                   │   │
│  │                                                          │   │
│  │  39. Subarrays with K Different Integers (LC 992)       │   │
│  │      Key: exactly(k) = atMost(k) - atMost(k-1)         │   │
│  │                                                          │   │
│  │  40. Minimum Number of K Consecutive Bit Flips (LC 995) │   │
│  │      Key: Track flips with queue                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  SORTED ARRAY HARD:                                             │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  41. Median of Two Sorted Arrays (LC 4) ⭐⭐ CLASSIC    │   │
│  │      Key: Binary search on partition position           │   │
│  │                                                          │   │
│  │  42. Find K-th Smallest Pair Distance (LC 719)          │   │
│  │      Key: Binary search on value + two pointer count    │   │
│  │                                                          │   │
│  │  43. Kth Smallest in Sorted Matrix (LC 378)             │   │
│  │      Key: Binary search + zigzag counting               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  LINKED LIST HARD:                                              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  44. Reverse Nodes in k-Group (LC 25) ⭐⭐              │   │
│  │      Key: Reverse k nodes, connect groups               │   │
│  │                                                          │   │
│  │  45. Merge k Sorted Lists (LC 23)                       │   │
│  │      Key: Divide and conquer or min-heap                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  COMPLEX COUNTING:                                              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  46. Count of Smaller Numbers After Self (LC 315)       │   │
│  │      Key: Merge sort with index tracking                │   │
│  │                                                          │   │
│  │  47. Count of Range Sum (LC 327)                        │   │
│  │      Key: Merge sort on prefix sums                     │   │
│  │                                                          │   │
│  │  48. Max Sum of 3 Non-Overlapping Subarrays (LC 689)    │   │
│  │      Key: Left best + current + right best              │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  MISCELLANEOUS HARD:                                            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  49. Substring with Concatenation of All Words (LC 30)  │   │
│  │      Key: Sliding window for each offset                │   │
│  │                                                          │   │
│  │  50. Smallest Range Covering Elements from K Lists      │   │
│  │      (LC 632)                                            │   │
│  │      Key: k pointers with min-heap                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Study Plan

### Week 1-2: Foundation

```
Day 1-2:   Two Sum II, Valid Palindrome, Reverse String
Day 3-4:   Remove Duplicates, Remove Element, Move Zeroes
Day 5-6:   Merge Sorted Array, Squares of Sorted Array
Day 7-8:   Middle of LL, Linked List Cycle
Day 9-10:  Max Average Subarray, Longest Substring Without Repeating
Day 11-14: Review + practice variations
```

### Week 3-4: Intermediate

```
Day 1-3:   3Sum, 3Sum Closest (master duplicates handling)
Day 4-5:   Container With Most Water, Trapping Rain Water
Day 6-7:   Sort Colors, Partition problems
Day 8-10:  LL Cycle II, Remove Nth Node, Palindrome LL
Day 11-14: Sliding window problems (340, 438, 567)
```

### Week 5-6: Advanced

```
Day 1-3:   Minimum Window Substring (master this!)
Day 4-5:   Sliding Window Maximum
Day 6-7:   Median of Two Sorted Arrays
Day 8-10:  Hard counting problems
Day 11-14: Mock interviews + review all patterns
```

---

## Final Checklist Before Interview

```
┌─────────────────────────────────────────────────────────────────┐
│                   PRE-INTERVIEW CHECKLIST                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  PATTERN RECOGNITION:                                           │
│  □ Can identify when to use two pointers vs hash map           │
│  □ Can identify opposite vs same direction patterns            │
│  □ Can identify sliding window problems                        │
│  □ Know when sorting is required/allowed                        │
│                                                                 │
│  CORE PROBLEMS MASTERED:                                        │
│  □ Two Sum (sorted) - write in 2 minutes                       │
│  □ 3Sum - handle duplicates correctly                          │
│  □ Container With Most Water - explain proof                   │
│  □ Trapping Rain Water - explain two pointer approach          │
│  □ Minimum Window Substring - implement with formed counter    │
│  □ Floyd's Cycle Detection - explain the math                  │
│                                                                 │
│  EDGE CASES:                                                    │
│  □ Always check empty input                                    │
│  □ Always check single element                                 │
│  □ Know when to use < vs <=                                    │
│  □ Handle duplicates at all levels (3Sum)                      │
│                                                                 │
│  COMPLEXITY ANALYSIS:                                           │
│  □ Can explain why two pointers is O(n)                        │
│  □ Know complexity of all major patterns                       │
│  □ Can justify space complexity                                │
│                                                                 │
│  COMMUNICATION:                                                 │
│  □ Can explain approach before coding                          │
│  □ Can trace through examples                                  │
│  □ Can discuss tradeoffs between approaches                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# Key Takeaways

```
┌─────────────────────────────────────────────────────────────────┐
│                    MASTER TWO POINTERS                          │
│                    FINAL SUMMARY                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  🎯 THE CORE INSIGHT:                                          │
│     Two pointers reduce O(n²) to O(n) by making INTELLIGENT    │
│     decisions about which pointer to move, eliminating the     │
│     need to check all pairs.                                    │
│                                                                 │
│  🔑 THE FOUR PATTERNS:                                         │
│     1. Opposite Direction: Converge from ends                  │
│     2. Same Direction: Fast-slow for modification/detection    │
│     3. Sliding Window: Expand-shrink for subarrays            │
│     4. Multiple Arrays: Parallel traversal for merging         │
│                                                                 │
│  ⚠️ THE COMMON MISTAKES:                                       │
│     • Off-by-one in loop conditions and window size           │
│     • Infinite loops from forgetting to move pointers         │
│     • Wrong duplicate handling (skip AFTER, not before)        │
│     • Dutch Flag: Don't increment mid when swapping with high │
│                                                                 │
│  📈 THE OPTIMIZATION MINDSET:                                  │
│     • Always look for early termination opportunities          │
│     • Consider if O(n) space can be reduced to O(1)           │
│     • Sort if it enables two pointers (check if allowed)       │
│                                                                 │
│  💡 THE INTERVIEW APPROACH:                                    │
│     • Clarify → Plan → Code → Test → Optimize                 │
│     • Think out loud, explain your reasoning                   │
│     • Always analyze time and space complexity                 │
│                                                                 │
│  🏆 MASTER THESE AND YOU'LL EXCEL:                             │
│     • 3Sum (with duplicate handling)                           │
│     • Minimum Window Substring                                 │
│     • Trapping Rain Water                                      │
│     • Floyd's Cycle Detection                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

     Good luck with your interviews! 🚀
```
