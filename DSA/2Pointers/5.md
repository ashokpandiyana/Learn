# Chapter 5: Hard-Level Problems

## Mastering Interview-Level Challenges

---

# Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                    CHAPTER 5 ROADMAP                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  5.1 COMPLEX SUBARRAY PROBLEMS                                 │
│      └── Bounded Maximum, Count Subarrays, Range Sum           │
│                                                                 │
│  5.2 ADVANCED STRING PROBLEMS                                  │
│      └── Minimum Window Variants, Distinct Characters          │
│                                                                 │
│  5.3 SORTED ARRAY CHALLENGES                                   │
│      └── Median of Two Arrays, Kth Smallest Pairs              │
│                                                                 │
│  5.4 COMPLEX LINKED LIST PROBLEMS                              │
│      └── Reverse in K-Groups, Merge K Lists                    │
│                                                                 │
│  5.5 MULTI-DIMENSIONAL PROBLEMS                                │
│      └── 3Sum Smaller, 4Sum II, Array Partitioning             │
│                                                                 │
│  5.6 SLIDING WINDOW HARD PROBLEMS                              │
│      └── Sliding Window Maximum, Median, Longest Repeating     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# 5.1 Complex Subarray Problems

## 5.1.1 Subarrays with Bounded Maximum

### Problem
Count subarrays where the maximum element is between left and right (inclusive).

### Key Insight

```
┌─────────────────────────────────────────────────────────────────┐
│  BOUNDED MAXIMUM STRATEGY                                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  count(max in [L, R]) = count(max ≤ R) - count(max ≤ L-1)     │
│                                                                 │
│  For count(max ≤ bound):                                        │
│  • Subarray is valid if ALL elements ≤ bound                   │
│  • When element > bound: break the subarray                    │
│  • When element ≤ bound: extend current valid streak           │
│                                                                 │
│  Example: nums = [2, 1, 4, 3], left = 2, right = 3             │
│                                                                 │
│  count(max ≤ 3):                                               │
│    [2] [2,1] [1] [3] = contributions: 1 + 2 + 1 + 1           │
│    (4 breaks streak)                                            │
│    Total = 5                                                    │
│                                                                 │
│  count(max ≤ 1):                                               │
│    [1] only = 1                                                 │
│    Total = 1                                                    │
│                                                                 │
│  Result = 5 - 1 = 4                                            │
│  Subarrays: [2], [2,1], [3], [4,3]? No!                        │
│  Actually: [2], [2,1], [3], [1,4,3]? Let me recalculate...     │
│                                                                 │
│  Valid subarrays with max in [2,3]:                            │
│  [2], [2,1], [3], [4,3] - wait, [4,3] has max=4 > 3            │
│  [2], [2,1], [3] = 3? Let me trace more carefully.             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Detailed Trace

```
nums = [2, 1, 4, 3]    left = 2, right = 3

┌────────────────────────────────────────────────────────────────┐
│  COUNTING max ≤ bound                                          │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  For bound = 3 (right):                                        │
│  ┌─────┬───────┬────────┬─────────┬───────────────────────┐   │
│  │  i  │ num   │ ≤ 3?   │ streak  │ subarrays ending at i │   │
│  ├─────┼───────┼────────┼─────────┼───────────────────────┤   │
│  │  0  │  2    │  Yes   │   1     │   [2] = 1             │   │
│  │  1  │  1    │  Yes   │   2     │   [1], [2,1] = 2      │   │
│  │  2  │  4    │  No    │   0     │   none = 0            │   │
│  │  3  │  3    │  Yes   │   1     │   [3] = 1             │   │
│  └─────┴───────┴────────┴─────────┴───────────────────────┘   │
│  Total count(≤3) = 1 + 2 + 0 + 1 = 4                          │
│                                                                │
│  For bound = 1 (left - 1):                                     │
│  ┌─────┬───────┬────────┬─────────┬───────────────────────┐   │
│  │  i  │ num   │ ≤ 1?   │ streak  │ subarrays ending at i │   │
│  ├─────┼───────┼────────┼─────────┼───────────────────────┤   │
│  │  0  │  2    │  No    │   0     │   none = 0            │   │
│  │  1  │  1    │  Yes   │   1     │   [1] = 1             │   │
│  │  2  │  4    │  No    │   0     │   none = 0            │   │
│  │  3  │  3    │  No    │   0     │   none = 0            │   │
│  └─────┴───────┴────────┴─────────┴───────────────────────┘   │
│  Total count(≤1) = 0 + 1 + 0 + 0 = 1                          │
│                                                                │
│  Result = 4 - 1 = 3                                            │
│                                                                │
│  Valid subarrays: [2], [2,1], [3]                             │
│  (max=2), (max=2), (max=3) - all in range [2,3] ✓             │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def num_subarray_bounded_max(nums: list[int], left: int, right: int) -> int:
    """
    Count subarrays where max element is in [left, right].
    
    Time: O(n), Space: O(1)
    
    Strategy: count(max ≤ right) - count(max ≤ left-1)
    """
    def count_at_most(bound: int) -> int:
        """Count subarrays where all elements ≤ bound."""
        count = 0
        streak = 0  # Length of current valid streak
        
        for num in nums:
            if num <= bound:
                streak += 1  # Extend streak
            else:
                streak = 0   # Break streak
            
            # All subarrays ending at current position
            count += streak
        
        return count
    
    return count_at_most(right) - count_at_most(left - 1)

# Alternative: Single pass approach
def num_subarray_bounded_max_v2(nums: list[int], left: int, right: int) -> int:
    """
    Single pass solution tracking three states.
    
    States:
    - num < left: continues valid subarrays but doesn't start new ones
    - left ≤ num ≤ right: valid, can start/extend
    - num > right: invalid, resets everything
    """
    result = 0
    valid_start = -1   # Last position where num > right
    count_start = -1   # Last position where num >= left
    
    for i, num in enumerate(nums):
        if num > right:
            valid_start = i  # Reset: can't include this
        if num >= left:
            count_start = i  # Last valid max position
        
        # Subarrays from valid_start+1 to i that include count_start
        result += count_start - valid_start
    
    return result
```

---

## 5.1.2 Count of Smaller Numbers After Self

### Problem
For each element, count how many elements to its right are smaller.

### Strategy: Merge Sort with Counting

```
┌─────────────────────────────────────────────────────────────────┐
│  MERGE SORT COUNTING STRATEGY                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  During merge, when element from RIGHT goes before LEFT:       │
│  All remaining LEFT elements have this RIGHT element smaller!  │
│                                                                 │
│  nums = [5, 2, 6, 1]                                           │
│                                                                 │
│  Split: [5, 2] | [6, 1]                                        │
│         ↓         ↓                                             │
│       [2, 5]   [1, 6]  (with indices tracked)                  │
│                                                                 │
│  Merge [2, 5] and [1, 6]:                                      │
│  Compare 2 and 1: 1 < 2                                         │
│    → 1 goes first                                               │
│    → 2 remaining in left, so count[index_of_2] += 1            │
│    → 5 remaining in left, so count[index_of_5] += 1            │
│                                                                 │
│  Result: [2, 1, 1, 0]                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def count_smaller(nums: list[int]) -> list[int]:
    """
    Count smaller elements to the right.
    
    Time: O(n log n), Space: O(n)
    """
    n = len(nums)
    counts = [0] * n
    # Pair each number with its original index
    indexed = [[num, i] for i, num in enumerate(nums)]
    
    def merge_sort(arr):
        if len(arr) <= 1:
            return arr
        
        mid = len(arr) // 2
        left = merge_sort(arr[:mid])
        right = merge_sort(arr[mid:])
        
        return merge(left, right)
    
    def merge(left, right):
        result = []
        i = j = 0
        right_count = 0  # Elements from right that went before
        
        while i < len(left) and j < len(right):
            if left[i][0] > right[j][0]:
                # Right element goes first
                right_count += 1
                result.append(right[j])
                j += 1
            else:
                # Left element goes
                # All right elements before j are smaller
                counts[left[i][1]] += right_count
                result.append(left[i])
                i += 1
        
        # Remaining left elements
        while i < len(left):
            counts[left[i][1]] += right_count
            result.append(left[i])
            i += 1
        
        # Remaining right elements
        while j < len(right):
            result.append(right[j])
            j += 1
        
        return result
    
    merge_sort(indexed)
    return counts
```

---

## 5.1.3 Count of Range Sum

### Problem
Count range sums that lie in [lower, upper].

### Strategy: Merge Sort on Prefix Sums

```
┌─────────────────────────────────────────────────────────────────┐
│  RANGE SUM AS PREFIX DIFFERENCE                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Range sum [i, j] = prefix[j+1] - prefix[i]                    │
│                                                                 │
│  We want: lower ≤ prefix[j+1] - prefix[i] ≤ upper              │
│           for all i < j+1                                       │
│                                                                 │
│  Rearranging: prefix[j+1] - upper ≤ prefix[i] ≤ prefix[j+1] - lower │
│                                                                 │
│  During merge sort:                                             │
│  For each element in RIGHT, count elements in LEFT             │
│  that fall in the valid range.                                  │
│                                                                 │
│  Both LEFT and RIGHT are sorted, so use TWO POINTERS!          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def count_range_sum(nums: list[int], lower: int, upper: int) -> int:
    """
    Count range sums in [lower, upper].
    
    Time: O(n log n), Space: O(n)
    """
    n = len(nums)
    
    # Compute prefix sums
    prefix = [0] * (n + 1)
    for i in range(n):
        prefix[i + 1] = prefix[i] + nums[i]
    
    count = [0]  # Use list to allow modification in nested function
    
    def merge_sort(arr):
        if len(arr) <= 1:
            return arr
        
        mid = len(arr) // 2
        left = merge_sort(arr[:mid])
        right = merge_sort(arr[mid:])
        
        # Count valid pairs before merging
        # For each r in right, find elements in left where:
        # lower ≤ r - l ≤ upper
        # i.e., r - upper ≤ l ≤ r - lower
        
        j = k = 0  # Two pointers for left array
        for r in right:
            # Find first l where l >= r - upper
            while j < len(left) and left[j] < r - upper:
                j += 1
            # Find first l where l > r - lower
            while k < len(left) and left[k] <= r - lower:
                k += 1
            # Count elements in [j, k)
            count[0] += k - j
        
        # Standard merge
        return merge(left, right)
    
    def merge(left, right):
        result = []
        i = j = 0
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        result.extend(left[i:])
        result.extend(right[j:])
        return result
    
    merge_sort(prefix)
    return count[0]
```

---

## 5.1.4 Maximum Sum of 3 Non-Overlapping Subarrays

### Problem
Find three non-overlapping subarrays of length k with maximum total sum.

### Strategy

```
┌─────────────────────────────────────────────────────────────────┐
│  THREE NON-OVERLAPPING SUBARRAYS STRATEGY                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Compute all k-length subarray sums                         │
│  2. For each middle subarray position j:                       │
│     - Best left subarray ending before j                       │
│     - Best right subarray starting after j+k-1                 │
│                                                                 │
│  Precompute:                                                    │
│  - left_best[i]: index of best k-sum ending at or before i     │
│  - right_best[i]: index of best k-sum starting at or after i   │
│                                                                 │
│  For middle starting at j:                                      │
│  Total = sums[left_best[j-1]] + sums[j] + sums[right_best[j+k]]│
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def max_sum_of_three_subarrays(nums: list[int], k: int) -> list[int]:
    """
    Find indices of three non-overlapping subarrays with max sum.
    
    Time: O(n), Space: O(n)
    """
    n = len(nums)
    
    # Compute k-length subarray sums
    # sums[i] = sum of nums[i:i+k]
    window_sum = sum(nums[:k])
    sums = [window_sum]
    for i in range(k, n):
        window_sum += nums[i] - nums[i - k]
        sums.append(window_sum)
    
    m = len(sums)  # Number of possible k-length subarrays
    
    # left_best[i] = index of max sum k-subarray in [0, i]
    left_best = [0] * m
    best_idx = 0
    for i in range(m):
        if sums[i] > sums[best_idx]:
            best_idx = i
        left_best[i] = best_idx
    
    # right_best[i] = index of max sum k-subarray in [i, m-1]
    right_best = [0] * m
    best_idx = m - 1
    for i in range(m - 1, -1, -1):
        if sums[i] >= sums[best_idx]:  # >= for leftmost in ties
            best_idx = i
        right_best[i] = best_idx
    
    # Find best combination
    max_sum = 0
    result = [0, 0, 0]
    
    # Middle subarray starts at j, ends at j+k-1
    # Left must end before j: starts at most at j-k, index j-k
    # Right must start after j+k-1: starts at j+k, index j+k
    for j in range(k, m - k):
        left_idx = left_best[j - 1]
        right_idx = right_best[j + k]
        total = sums[left_idx] + sums[j] + sums[right_idx]
        
        if total > max_sum:
            max_sum = total
            result = [left_idx, j, right_idx]
    
    return result
```

---

# 5.2 Advanced String Problems

## 5.2.1 Longest Substring with At Most K Distinct Characters

### Problem
Find longest substring with at most K distinct characters.

### Visualization

```
s = "eceba"    k = 2

┌────────────────────────────────────────────────────────────────┐
│  SLIDING WINDOW TRACE                                          │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  R=0: [e]ceba        chars={e:1}         dist=1 ≤2  len=1     │
│  R=1: [ec]eba        chars={e:1,c:1}     dist=2 ≤2  len=2     │
│  R=2: [ece]ba        chars={e:2,c:1}     dist=2 ≤2  len=3 ✓   │
│  R=3: [eceb]a        chars={e:2,c:1,b:1} dist=3 >2  SHRINK!   │
│                                                                │
│  Shrink: remove 'e'                                            │
│       e[ceb]a        chars={e:1,c:1,b:1} dist=3 >2  SHRINK!   │
│                                                                │
│  Shrink: remove 'c'                                            │
│       ec[eb]a        chars={e:1,b:1}     dist=2 ≤2  len=2     │
│                                                                │
│  R=4: ec[eba]        chars={e:1,b:1,a:1} dist=3 >2  SHRINK!   │
│                                                                │
│  Shrink: remove 'e'                                            │
│       ece[ba]        chars={b:1,a:1}     dist=2 ≤2  len=2     │
│                                                                │
│  Result: max_len = 3 ("ece")                                   │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
from collections import defaultdict

def length_of_longest_substring_k_distinct(s: str, k: int) -> int:
    """
    Longest substring with at most k distinct characters.
    
    Time: O(n), Space: O(k)
    """
    if k == 0:
        return 0
    
    char_count = defaultdict(int)
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        # Expand: add character
        char_count[s[right]] += 1
        
        # Shrink: while more than k distinct
        while len(char_count) > k:
            char_count[s[left]] -= 1
            if char_count[s[left]] == 0:
                del char_count[s[left]]
            left += 1
        
        # Update max
        max_length = max(max_length, right - left + 1)
    
    return max_length

# Variant: Longest with EXACTLY k distinct
def longest_with_exactly_k_distinct(s: str, k: int) -> int:
    """
    Longest substring with exactly k distinct characters.
    Uses: exactly(k) = at_most(k) - at_most(k-1)
    """
    def at_most(k):
        if k < 0:
            return 0
        char_count = defaultdict(int)
        left = result = 0
        for right in range(len(s)):
            char_count[s[right]] += 1
            while len(char_count) > k:
                char_count[s[left]] -= 1
                if char_count[s[left]] == 0:
                    del char_count[s[left]]
                left += 1
            result = max(result, right - left + 1)
        return result
    
    return at_most(k) - at_most(k - 1)
```

---

## 5.2.2 Minimum Window Substring (Deep Dive)

### Complete Algorithm Breakdown

```
┌─────────────────────────────────────────────────────────────────┐
│  MINIMUM WINDOW SUBSTRING - DETAILED ANALYSIS                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  s = "ADOBECODEBANC"    t = "ABC"                              │
│                                                                 │
│  need = {A:1, B:1, C:1}                                        │
│  required = 3 (unique characters to satisfy)                    │
│  formed = 0 (characters currently satisfied)                    │
│                                                                 │
│  TRACKING MECHANISM:                                            │
│  - window[char]: count of char in current window               │
│  - formed++: when window[char] EQUALS need[char]               │
│  - formed--: when window[char] DROPS BELOW need[char]          │
│                                                                 │
│  This avoids comparing entire dictionaries at each step!       │
│                                                                 │
│  WINDOW VALIDITY:                                               │
│  Window is valid when formed == required                        │
│  (all required characters have sufficient count)                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Step-by-Step Execution

```
s = "ADOBECODEBANC"    t = "ABC"

┌────────────────────────────────────────────────────────────────────────┐
│ R │ Char│    Window State    │formed│ Valid │   Action      │  Best   │
├───┼─────┼────────────────────┼──────┼───────┼───────────────┼─────────┤
│ 0 │  A  │ {A:1}              │  1   │  No   │ Expand        │    -    │
│ 1 │  D  │ {A:1,D:1}          │  1   │  No   │ Expand        │    -    │
│ 2 │  O  │ {A:1,D:1,O:1}      │  1   │  No   │ Expand        │    -    │
│ 3 │  B  │ {A:1,D:1,O:1,B:1}  │  2   │  No   │ Expand        │    -    │
│ 4 │  E  │ {...,E:1}          │  2   │  No   │ Expand        │    -    │
│ 5 │  C  │ {...,C:1}          │  3   │  Yes! │ Shrink        │ [0,5]=6 │
│   │     │                    │      │       │               │         │
│   │ L=1 │ {D:1,O:1,B:1,E:1,  │  2   │  No   │ Expand (A     │ [0,5]=6 │
│   │     │  C:1}              │      │       │ removed)      │         │
│ 6 │  O  │ {...,O:2}          │  2   │  No   │ Expand        │ [0,5]=6 │
│ 7 │  D  │ {...,D:2}          │  2   │  No   │ Expand        │ [0,5]=6 │
│ 8 │  E  │ {...,E:2}          │  2   │  No   │ Expand        │ [0,5]=6 │
│ 9 │  B  │ {...,B:2}          │  2   │  No   │ Expand        │ [0,5]=6 │
│10 │  A  │ {...,A:1}          │  3   │  Yes! │ Shrink        │ [0,5]=6 │
│   │     │                    │      │       │               │         │
│   │ L=2 │ {O:2,B:2,E:2,C:1,  │  3   │  Yes! │ Shrink        │ [1,10]=10│
│   │     │  A:1,D:1}          │      │       │               │ worse   │
│   │ ...keep shrinking...     │      │       │               │         │
│   │ L=6 │ {D:1,E:1,B:1,A:1,  │  3   │  Yes! │ Shrink        │ [5,10]=6│
│   │     │  C:1}              │      │       │               │ same    │
│   │ ...                      │      │       │               │         │
│11 │  N  │ {...}              │  2   │  No   │ Expand        │         │
│12 │  C  │ {...,C:1}          │  3   │  Yes! │ Shrink        │ [9,12]=4│
│   │     │                    │      │       │               │ BEST!   │
└───┴─────┴────────────────────┴──────┴───────┴───────────────┴─────────┘

Result: "BANC" (indices 9-12, length 4)
```

### Optimized Implementation

```python
from collections import Counter

def min_window(s: str, t: str) -> str:
    """
    Find minimum window substring containing all of t.
    
    Time: O(|s| + |t|), Space: O(|s| + |t|)
    
    Optimization: Track 'formed' count instead of comparing dicts.
    """
    if not s or not t or len(s) < len(t):
        return ""
    
    need = Counter(t)
    required = len(need)
    
    window = {}
    formed = 0
    
    # Result: (length, left, right)
    result = (float('inf'), 0, 0)
    
    left = 0
    
    for right, char in enumerate(s):
        # Expand
        window[char] = window.get(char, 0) + 1
        
        # Check if this character is now satisfied
        if char in need and window[char] == need[char]:
            formed += 1
        
        # Shrink while valid
        while formed == required:
            # Update result
            if right - left + 1 < result[0]:
                result = (right - left + 1, left, right)
            
            # Remove leftmost
            left_char = s[left]
            window[left_char] -= 1
            
            if left_char in need and window[left_char] < need[left_char]:
                formed -= 1
            
            left += 1
    
    length, start, end = result
    return "" if length == float('inf') else s[start:end + 1]

# Follow-up: What if s and t contain Unicode characters?
# Answer: Same algorithm works! Counter and dict handle Unicode.

# Follow-up: What if t has duplicate characters?
# Answer: Already handled! need = Counter(t) counts duplicates.
```

---

## 5.2.3 Longest Repeating Character Replacement

### Problem
Find longest substring where you can replace at most k characters to make all characters same.

### Key Insight

```
┌─────────────────────────────────────────────────────────────────┐
│  LONGEST REPEATING CHARACTER REPLACEMENT                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Window is valid if:                                            │
│  (window_size - max_count) ≤ k                                 │
│                                                                 │
│  where max_count = count of most frequent char in window       │
│                                                                 │
│  INTUITION:                                                     │
│  - Keep the most frequent character                             │
│  - Replace all others                                           │
│  - Replacements needed = window_size - max_count               │
│                                                                 │
│  OPTIMIZATION:                                                  │
│  We don't need to DECREASE max_count when shrinking!           │
│  Why? We're looking for MAXIMUM length.                        │
│  A window with invalid max_count can't be longer than          │
│  a previously valid window anyway.                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Visualization

```
s = "AABABBA"    k = 1

┌────────────────────────────────────────────────────────────────┐
│ R │  Char │   Window    │ Counts  │max_cnt│ size-max │ Valid? │
├───┼───────┼─────────────┼─────────┼───────┼──────────┼────────┤
│ 0 │   A   │ [A]         │ A:1     │   1   │  1-1=0   │  0≤1 ✓│
│ 1 │   A   │ [AA]        │ A:2     │   2   │  2-2=0   │  0≤1 ✓│
│ 2 │   B   │ [AAB]       │ A:2,B:1 │   2   │  3-2=1   │  1≤1 ✓│
│ 3 │   A   │ [AABA]      │ A:3,B:1 │   3   │  4-3=1   │  1≤1 ✓│
│ 4 │   B   │ [AABAB]     │ A:3,B:2 │   3   │  5-3=2   │  2>1 ✗│
│   │       │             │         │       │          │ Shrink │
│   │ L=1   │ [ABAB]      │ A:2,B:2 │   3*  │  4-3=1   │  1≤1 ✓│
│ 5 │   B   │ [ABABB]     │ A:2,B:3 │   3   │  5-3=2   │  2>1 ✗│
│   │ L=2   │ [BABB]      │ A:1,B:3 │   3   │  4-3=1   │  1≤1 ✓│
│ 6 │   A   │ [BABBA]     │ A:2,B:3 │   3   │  5-3=2   │  2>1 ✗│
│   │ L=3   │ [ABBA]      │ A:2,B:2 │   3*  │  4-3=1   │  1≤1 ✓│
└───┴───────┴─────────────┴─────────┴───────┴──────────┴────────┘

* max_count not decreased when character removed (optimization)

Result: max_length = 4 ("AABA" or "ABBA")
```

### Implementation

```python
def character_replacement(s: str, k: int) -> int:
    """
    Longest substring with at most k replacements.
    
    Time: O(n), Space: O(26) = O(1)
    
    Key: Window valid if (size - max_count) <= k
    """
    count = {}
    max_count = 0  # Max frequency of any char in current window
    max_length = 0
    left = 0
    
    for right in range(len(s)):
        # Add character
        count[s[right]] = count.get(s[right], 0) + 1
        max_count = max(max_count, count[s[right]])
        
        # Window size - max_count = chars to replace
        window_size = right - left + 1
        
        # If invalid, shrink (but don't decrease max_count!)
        if window_size - max_count > k:
            count[s[left]] -= 1
            left += 1
        
        # Update max length
        max_length = max(max_length, right - left + 1)
    
    return max_length

# Why not decrease max_count?
# 
# When we shrink, we might decrease the count of what was the max.
# But we don't update max_count because:
# 1. We're looking for MAXIMUM length
# 2. A new max window must have higher max_count than before
# 3. If max_count is "stale" (too high), window just stays same size
# 4. This only helps when we find a BETTER max_count
```

---

# 5.3 Sorted Array Challenges

## 5.3.1 Median of Two Sorted Arrays

### Problem
Find median of two sorted arrays in O(log(min(m,n))) time.

### Strategy

```
┌─────────────────────────────────────────────────────────────────┐
│  BINARY SEARCH ON PARTITION                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  nums1 = [1, 3, 8, 9, 15]                                      │
│  nums2 = [7, 11, 18, 19, 21, 25]                               │
│                                                                 │
│  Total = 11 elements, median is element at position 5 (0-idx)  │
│                                                                 │
│  GOAL: Partition both arrays such that:                        │
│  - Left half has (m + n + 1) / 2 elements                      │
│  - All left elements ≤ all right elements                      │
│                                                                 │
│  PARTITION EXAMPLE:                                             │
│  nums1: [1, 3] | [8, 9, 15]       (partition at index 2)       │
│  nums2: [7, 11, 18, 19] | [21, 25] (partition at index 4)     │
│                                                                 │
│  Left half: [1, 3, 7, 11, 18, 19]  (6 elements)               │
│  Right half: [8, 9, 15, 21, 25]    (5 elements)               │
│                                                                 │
│  Valid if: max(left1, left2) ≤ min(right1, right2)            │
│            max(3, 19) ≤ min(8, 21)?                            │
│            19 ≤ 8? NO! Invalid partition.                      │
│                                                                 │
│  Binary search to find correct partition in smaller array.     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def find_median_sorted_arrays(nums1: list[int], nums2: list[int]) -> float:
    """
    Find median of two sorted arrays.
    
    Time: O(log(min(m, n))), Space: O(1)
    """
    # Ensure nums1 is smaller
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1
    
    m, n = len(nums1), len(nums2)
    total = m + n
    half = (total + 1) // 2  # Left half size (ceiling for odd total)
    
    left, right = 0, m  # Binary search on nums1's partition
    
    while left <= right:
        partition1 = (left + right) // 2  # Elements from nums1 in left half
        partition2 = half - partition1     # Elements from nums2 in left half
        
        # Edge values (use -inf/inf for out of bounds)
        left1 = nums1[partition1 - 1] if partition1 > 0 else float('-inf')
        right1 = nums1[partition1] if partition1 < m else float('inf')
        left2 = nums2[partition2 - 1] if partition2 > 0 else float('-inf')
        right2 = nums2[partition2] if partition2 < n else float('inf')
        
        # Check if valid partition
        if left1 <= right2 and left2 <= right1:
            # Valid! Calculate median
            if total % 2 == 1:
                return max(left1, left2)  # Odd: max of left half
            else:
                return (max(left1, left2) + min(right1, right2)) / 2
        
        elif left1 > right2:
            # Too many from nums1, move left
            right = partition1 - 1
        else:
            # Too few from nums1, move right
            left = partition1 + 1
    
    return 0.0  # Should never reach here for valid input
```

### Visual Trace

```
nums1 = [1, 3]        m = 2
nums2 = [2]           n = 1
total = 3, half = 2

┌────────────────────────────────────────────────────────────────┐
│ Iter │ left │right│ p1 │ p2 │ left1│right1│left2│right2│Valid?│
├──────┼──────┼─────┼────┼────┼──────┼──────┼─────┼──────┼──────┤
│  1   │  0   │  2  │  1 │  1 │   1  │   3  │  -∞ │   2  │  ✓   │
│      │      │     │    │    │      │      │     │      │      │
│ Partition:                                                     │
│ nums1: [1] | [3]                                               │
│ nums2: [] | [2]                                                │
│ Left half: [1]       Right half: [3, 2]                       │
│                                                                │
│ Odd total: median = max(left1, left2) = max(1, -∞) = 1       │
│ Wait, that's wrong! Let me recalculate...                     │
│                                                                │
│ Actually with half = 2:                                        │
│ p1 = 1, p2 = 2-1 = 1                                          │
│ left1=nums1[0]=1, right1=nums1[1]=3                           │
│ left2=nums2[0]=2, right2=+∞                                   │
│                                                                │
│ Check: left1(1) ≤ right2(∞)? Yes                              │
│        left2(2) ≤ right1(3)? Yes                              │
│ Valid!                                                         │
│                                                                │
│ Median = max(1, 2) = 2 ✓                                      │
└────────────────────────────────────────────────────────────────┘
```

---

## 5.3.2 Find K-th Smallest Pair Distance

### Problem
Given array nums, find k-th smallest distance among all pairs.

### Strategy: Binary Search + Two Pointers

```
┌─────────────────────────────────────────────────────────────────┐
│  BINARY SEARCH ON DISTANCE VALUE                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  nums = [1, 3, 1] → sorted: [1, 1, 3]                         │
│  All distances: |1-1|=0, |1-3|=2, |1-3|=2                     │
│  Sorted distances: [0, 2, 2]                                   │
│                                                                 │
│  k = 1 → answer is 0 (1st smallest)                           │
│                                                                 │
│  STRATEGY:                                                      │
│  1. Binary search on distance value [0, max-min]               │
│  2. For each mid, count pairs with distance ≤ mid              │
│  3. Use two pointers to count efficiently                      │
│                                                                 │
│  Counting pairs with distance ≤ mid:                           │
│  For each j, find smallest i where nums[j] - nums[i] ≤ mid    │
│  Count = j - i pairs ending at j                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def smallest_distance_pair(nums: list[int], k: int) -> int:
    """
    Find k-th smallest pair distance.
    
    Time: O(n log n + n log W) where W = max - min
    Space: O(1) excluding sort
    """
    nums.sort()
    n = len(nums)
    
    def count_pairs_at_most(mid: int) -> int:
        """Count pairs with distance ≤ mid using two pointers."""
        count = 0
        left = 0
        
        for right in range(n):
            # Move left until distance is within mid
            while nums[right] - nums[left] > mid:
                left += 1
            # All pairs (left, right), (left+1, right), ..., (right-1, right)
            count += right - left
        
        return count
    
    # Binary search on distance value
    left, right = 0, nums[-1] - nums[0]
    
    while left < right:
        mid = (left + right) // 2
        
        if count_pairs_at_most(mid) < k:
            left = mid + 1
        else:
            right = mid
    
    return left
```

---

## 5.3.3 Kth Smallest Element in Sorted Matrix

### Deep Dive Implementation

```python
def kth_smallest(matrix: list[list[int]], k: int) -> int:
    """
    Find k-th smallest in row-column sorted matrix.
    
    Time: O(n * log(max - min)), Space: O(1)
    
    Key insight: Binary search on VALUE, not index.
    Count elements ≤ mid using matrix properties.
    """
    n = len(matrix)
    
    def count_less_equal(target: int) -> int:
        """
        Count elements ≤ target.
        Start from bottom-left corner.
        
        If matrix[row][col] ≤ target:
            All elements above in this column are also ≤ target
            Add (row + 1) to count, move right
        Else:
            Move up
        """
        count = 0
        row, col = n - 1, 0  # Bottom-left
        
        while row >= 0 and col < n:
            if matrix[row][col] <= target:
                count += row + 1  # All elements in this column up to row
                col += 1
            else:
                row -= 1
        
        return count
    
    left, right = matrix[0][0], matrix[n-1][n-1]
    
    while left < right:
        mid = (left + right) // 2
        
        if count_less_equal(mid) < k:
            left = mid + 1
        else:
            right = mid
    
    return left

# Visualization of count_less_equal:
#
# matrix = [[1,  5,  9],
#           [10, 11, 13],
#           [12, 13, 15]]
#
# target = 11
#
# Start at (2, 0) = 12 > 11 → move up
# At (1, 0) = 10 ≤ 11 → count += 2, move right
# At (1, 1) = 11 ≤ 11 → count += 2, move right (count = 4)
# At (1, 2) = 13 > 11 → move up
# At (0, 2) = 9 ≤ 11 → count += 1 (count = 5)
#
# Elements ≤ 11: [1, 5, 9, 10, 11] = 5 ✓
```

---

# 5.4 Complex Linked List Problems

## 5.4.1 Reverse Nodes in k-Group

### Problem
Reverse nodes in groups of k. If remaining nodes < k, leave them as is.

### Visualization

```
Input: 1 → 2 → 3 → 4 → 5    k = 2

┌────────────────────────────────────────────────────────────────┐
│  STEP-BY-STEP REVERSAL                                         │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  Initial:  1 → 2 → 3 → 4 → 5                                  │
│                                                                │
│  Group 1 (nodes 1,2):                                          │
│  Before: prev → 1 → 2 → 3 → 4 → 5                             │
│  After:  prev → 2 → 1 → 3 → 4 → 5                             │
│                       ↑                                        │
│                    new prev                                    │
│                                                                │
│  Group 2 (nodes 3,4):                                          │
│  Before: 2 → 1 → 3 → 4 → 5                                    │
│              prev ↑                                            │
│  After:  2 → 1 → 4 → 3 → 5                                    │
│                       ↑                                        │
│                    new prev                                    │
│                                                                │
│  Remaining (node 5): Less than k=2, leave as is               │
│                                                                │
│  Result: 2 → 1 → 4 → 3 → 5                                    │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_k_group(head: ListNode, k: int) -> ListNode:
    """
    Reverse nodes in k-groups.
    
    Time: O(n), Space: O(1)
    """
    # Count total nodes
    count = 0
    node = head
    while node:
        count += 1
        node = node.next
    
    dummy = ListNode(0)
    dummy.next = head
    prev_group_end = dummy
    
    while count >= k:
        # Reverse k nodes starting from prev_group_end.next
        group_start = prev_group_end.next
        
        # Reverse k nodes
        prev = None
        curr = group_start
        for _ in range(k):
            next_node = curr.next
            curr.next = prev
            prev = curr
            curr = next_node
        
        # Connect with rest of list
        prev_group_end.next = prev  # prev is new group start
        group_start.next = curr     # group_start is now group end
        
        # Move to next group
        prev_group_end = group_start
        count -= k
    
    return dummy.next

# Recursive solution (more elegant, but O(n/k) space)
def reverse_k_group_recursive(head: ListNode, k: int) -> ListNode:
    """Recursive approach."""
    # Check if we have k nodes
    node = head
    for i in range(k):
        if not node:
            return head  # Less than k nodes, don't reverse
        node = node.next
    
    # Reverse first k nodes
    prev = reverse_k_group_recursive(node, k)  # Recursively process rest
    curr = head
    for _ in range(k):
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node
    
    return prev
```

---

## 5.4.2 Merge K Sorted Lists

### Strategy Comparison

```
┌─────────────────────────────────────────────────────────────────┐
│  MERGE K SORTED LISTS - APPROACHES                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  APPROACH 1: Merge one by one                                  │
│  Time: O(kN) where N = total nodes                             │
│  First merge takes N/k, second takes 2N/k, ...                 │
│  Total: N/k + 2N/k + ... + (k-1)N/k = O(kN)                   │
│                                                                 │
│  APPROACH 2: Min Heap                                           │
│  Time: O(N log k)                                              │
│  Each of N nodes: push/pop from heap of size k = O(log k)      │
│  Space: O(k) for heap                                          │
│                                                                 │
│  APPROACH 3: Divide and Conquer (recommended)                  │
│  Time: O(N log k)                                              │
│  log k levels, each level processes N nodes                    │
│  Space: O(log k) for recursion                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation: Divide and Conquer

```python
def merge_k_lists(lists: list[ListNode]) -> ListNode:
    """
    Merge k sorted linked lists.
    
    Time: O(N log k), Space: O(log k)
    """
    if not lists:
        return None
    
    def merge_two(l1: ListNode, l2: ListNode) -> ListNode:
        """Merge two sorted lists."""
        dummy = ListNode(0)
        curr = dummy
        
        while l1 and l2:
            if l1.val <= l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        
        curr.next = l1 or l2
        return dummy.next
    
    def divide_and_conquer(lists: list, left: int, right: int) -> ListNode:
        """Recursively merge lists[left:right+1]."""
        if left == right:
            return lists[left]
        if left > right:
            return None
        
        mid = (left + right) // 2
        left_merged = divide_and_conquer(lists, left, mid)
        right_merged = divide_and_conquer(lists, mid + 1, right)
        
        return merge_two(left_merged, right_merged)
    
    return divide_and_conquer(lists, 0, len(lists) - 1)

# Min Heap approach
import heapq

def merge_k_lists_heap(lists: list[ListNode]) -> ListNode:
    """Using min heap."""
    # Custom comparison for ListNode
    heap = []
    for i, node in enumerate(lists):
        if node:
            heapq.heappush(heap, (node.val, i, node))
    
    dummy = ListNode(0)
    curr = dummy
    
    while heap:
        val, i, node = heapq.heappop(heap)
        curr.next = node
        curr = curr.next
        
        if node.next:
            heapq.heappush(heap, (node.next.val, i, node.next))
    
    return dummy.next
```

---

# 5.5 Multi-Dimensional Problems

## 5.5.1 3Sum Smaller

### Problem
Count triplets with sum < target.

### Strategy

```
┌─────────────────────────────────────────────────────────────────┐
│  3SUM SMALLER STRATEGY                                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  For fixed i, find pairs (j, k) where j < k and               │
│  nums[i] + nums[j] + nums[k] < target                          │
│                                                                 │
│  When nums[i] + nums[j] + nums[k] < target:                    │
│  ALL pairs (j, j+1), (j, j+2), ..., (j, k) are valid!         │
│  Count = k - j pairs                                           │
│                                                                 │
│  Example: sorted = [-2, 0, 1, 3], target = 2                   │
│                                                                 │
│  i=0 (nums[i]=-2):                                             │
│    j=1, k=3: -2 + 0 + 3 = 1 < 2 ✓                             │
│    Valid pairs: (1,2), (1,3) → count = 3-1 = 2                │
│    j++                                                          │
│    j=2, k=3: -2 + 1 + 3 = 2 = 2, not < 2                      │
│    k--                                                          │
│    j=2, k=2: j >= k, done                                      │
│                                                                 │
│  Total for i=0: 2                                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def three_sum_smaller(nums: list[int], target: int) -> int:
    """
    Count triplets with sum < target.
    
    Time: O(n²), Space: O(1)
    """
    nums.sort()
    count = 0
    n = len(nums)
    
    for i in range(n - 2):
        j, k = i + 1, n - 1
        
        while j < k:
            total = nums[i] + nums[j] + nums[k]
            
            if total < target:
                # All pairs (j, j+1), (j, j+2), ..., (j, k) are valid
                count += k - j
                j += 1
            else:
                k -= 1
    
    return count

# Variant: 3Sum Closest
def three_sum_closest(nums: list[int], target: int) -> int:
    """Find triplet sum closest to target."""
    nums.sort()
    closest = float('inf')
    
    for i in range(len(nums) - 2):
        j, k = i + 1, len(nums) - 1
        
        while j < k:
            total = nums[i] + nums[j] + nums[k]
            
            if abs(total - target) < abs(closest - target):
                closest = total
            
            if total < target:
                j += 1
            elif total > target:
                k -= 1
            else:
                return target  # Exact match
    
    return closest
```

---

## 5.5.2 4Sum II

### Problem
Count tuples (i, j, k, l) where A[i] + B[j] + C[k] + D[l] = 0.

### Strategy: Hash Map Optimization

```
┌─────────────────────────────────────────────────────────────────┐
│  4SUM II - DIVIDE INTO TWO GROUPS                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Brute force: O(n⁴)                                            │
│  Optimized: O(n²)                                              │
│                                                                 │
│  Strategy:                                                      │
│  1. Compute all sums A[i] + B[j] and store counts              │
│  2. For each C[k] + D[l], find -(C[k] + D[l]) in hash map     │
│                                                                 │
│  A[i] + B[j] + C[k] + D[l] = 0                                │
│  A[i] + B[j] = -(C[k] + D[l])                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
from collections import Counter

def four_sum_count(A: list[int], B: list[int], 
                   C: list[int], D: list[int]) -> int:
    """
    Count 4-tuples summing to zero from four arrays.
    
    Time: O(n²), Space: O(n²)
    """
    # Count all A[i] + B[j] sums
    ab_sums = Counter()
    for a in A:
        for b in B:
            ab_sums[a + b] += 1
    
    # For each C[k] + D[l], find complement
    count = 0
    for c in C:
        for d in D:
            target = -(c + d)
            count += ab_sums[target]
    
    return count

# Generalization: kSum II for even k
def k_sum_count(arrays: list[list[int]]) -> int:
    """
    Generalized for any even number of arrays.
    Split into two halves, hash first half.
    """
    k = len(arrays)
    assert k % 2 == 0
    
    def all_sums(arrs):
        """Compute all possible sums from given arrays."""
        sums = Counter([0])
        for arr in arrs:
            new_sums = Counter()
            for s, cnt in sums.items():
                for val in arr:
                    new_sums[s + val] += cnt
            sums = new_sums
        return sums
    
    first_half = all_sums(arrays[:k//2])
    count = 0
    
    # Count from second half
    second = all_sums(arrays[k//2:])
    for s, cnt in second.items():
        count += first_half[-s] * cnt
    
    return count
```

---

# 5.6 Sliding Window Hard Problems

## 5.6.1 Sliding Window Maximum

### Problem
Find maximum in each sliding window of size k.

### Strategy: Monotonic Deque

```
┌─────────────────────────────────────────────────────────────────┐
│  MONOTONIC DECREASING DEQUE                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Maintain deque of indices where values are DECREASING.        │
│  Front of deque = index of maximum in current window.          │
│                                                                 │
│  nums = [1, 3, -1, -3, 5, 3, 6, 7]    k = 3                    │
│                                                                 │
│  Window [1,3,-1]: deque = [1] (index of 3)                     │
│  Max = nums[1] = 3                                              │
│                                                                 │
│  Add -3: deque = [1, 2, 3] (values: 3, -1, -3)                 │
│  But index 1 is outside window! Remove.                        │
│  deque = [2, 3], but we need to add 3 first...                 │
│                                                                 │
│  Let me trace more carefully:                                   │
│                                                                 │
│  i=0: deque=[], add 0 → deque=[0]                              │
│  i=1: nums[1]=3 > nums[0]=1, pop 0, add 1 → deque=[1]         │
│  i=2: nums[2]=-1 < nums[1]=3, add 2 → deque=[1,2]             │
│       Window complete! Max = nums[1] = 3                        │
│                                                                 │
│  i=3: nums[3]=-3 < nums[2]=-1, add 3 → deque=[1,2,3]          │
│       Remove front if outside window: 1 is in [1,3]? Yes       │
│       Max = nums[1] = 3                                         │
│                                                                 │
│  i=4: nums[4]=5, pop 3,2,1 (all smaller), add 4 → deque=[4]   │
│       Max = nums[4] = 5                                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
from collections import deque

def max_sliding_window(nums: list[int], k: int) -> list[int]:
    """
    Find maximum in each window of size k.
    
    Time: O(n) - each element pushed/popped at most once
    Space: O(k) - deque size
    """
    result = []
    dq = deque()  # Store indices, values are monotonically decreasing
    
    for i in range(len(nums)):
        # Remove indices outside current window
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # Remove smaller elements (they'll never be max)
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        
        dq.append(i)
        
        # Add to result once window is complete
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result

# Trace for nums = [1,3,-1,-3,5,3,6,7], k = 3:
#
# i=0: dq=[0], window incomplete
# i=1: pop 0 (1<3), dq=[1], window incomplete
# i=2: dq=[1,2], result=[3]
# i=3: dq=[1,2,3], remove 1? 1 < 3-3+1=1? No. result=[3,3]
# i=4: pop all (5>all), dq=[4], result=[3,3,5]
# i=5: dq=[4,5], result=[3,3,5,5]
# i=6: pop 5 (6>3), dq=[4,6], remove 4? 4<6-3+1=4? No. result=[3,3,5,5,6]
# i=7: pop 6 (7>6), dq=[7], remove 4? 4<7-3+1=5? Yes! dq=[7]
#      result=[3,3,5,5,6,7]
#
# Result: [3, 3, 5, 5, 6, 7]
```

---

## 5.6.2 Sliding Window Median

### Problem
Find median in each sliding window of size k.

### Strategy: Two Heaps

```
┌─────────────────────────────────────────────────────────────────┐
│  TWO HEAPS APPROACH                                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Maintain two heaps:                                            │
│  - max_heap: smaller half of elements                          │
│  - min_heap: larger half of elements                           │
│                                                                 │
│  Balancing: |max_heap| == |min_heap| or |max_heap| + 1        │
│                                                                 │
│  Median:                                                        │
│  - Odd k: top of max_heap                                      │
│  - Even k: (top of max_heap + top of min_heap) / 2            │
│                                                                 │
│  Challenge: Removing arbitrary elements from heap is O(n)      │
│  Solution: Lazy removal - mark as deleted, clean when at top   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
import heapq
from collections import defaultdict

def median_sliding_window(nums: list[int], k: int) -> list[float]:
    """
    Find median of each window of size k.
    
    Time: O(n log k), Space: O(k)
    """
    # max_heap for smaller half (negate values for max behavior)
    # min_heap for larger half
    max_heap = []  # Stores negative values
    min_heap = []
    
    # Track elements to be lazily deleted
    to_remove = defaultdict(int)
    
    result = []
    
    def add_num(num):
        """Add number to appropriate heap."""
        if not max_heap or num <= -max_heap[0]:
            heapq.heappush(max_heap, -num)
        else:
            heapq.heappush(min_heap, num)
    
    def balance():
        """Balance heap sizes."""
        # Clean tops first
        while max_heap and to_remove[-max_heap[0]] > 0:
            to_remove[-max_heap[0]] -= 1
            heapq.heappop(max_heap)
        while min_heap and to_remove[min_heap[0]] > 0:
            to_remove[min_heap[0]] -= 1
            heapq.heappop(min_heap)
        
        # Balance sizes
        while len(max_heap) > len(min_heap) + 1:
            heapq.heappush(min_heap, -heapq.heappop(max_heap))
        while len(min_heap) > len(max_heap):
            heapq.heappush(max_heap, -heapq.heappop(min_heap))
    
    def get_median():
        """Get current median."""
        if k % 2 == 1:
            return float(-max_heap[0])
        return (-max_heap[0] + min_heap[0]) / 2
    
    # Process first window
    for i in range(k):
        add_num(nums[i])
        balance()
    
    result.append(get_median())
    
    # Slide window
    for i in range(k, len(nums)):
        # Add new element
        add_num(nums[i])
        
        # Mark element leaving window for removal
        to_remove[nums[i - k]] += 1
        
        balance()
        result.append(get_median())
    
    return result
```

---

## 5.6.3 Longest Substring with At Least K Repeating Characters

### Problem
Find longest substring where every character appears at least k times.

### Strategy: Divide and Conquer

```
┌─────────────────────────────────────────────────────────────────┐
│  DIVIDE AND CONQUER STRATEGY                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Key insight: Characters with count < k CANNOT be in answer!   │
│  They act as "split points".                                   │
│                                                                 │
│  s = "aaabb"    k = 3                                          │
│                                                                 │
│  Counts: a=3, b=2                                               │
│  'b' appears < 3 times, can't be in answer                     │
│  Split at 'b' positions: ["aaa", ""]                           │
│  Recursively solve each part                                    │
│                                                                 │
│  "aaa": a=3 >= 3, entire string valid! Length = 3              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
from collections import Counter

def longest_substring(s: str, k: int) -> int:
    """
    Longest substring with each char appearing at least k times.
    
    Time: O(n * 26) = O(n), Space: O(n)
    """
    if len(s) < k:
        return 0
    
    # Count characters
    count = Counter(s)
    
    # Find a character with count < k
    for char, cnt in count.items():
        if cnt < k:
            # Split by this character and recurse
            return max(longest_substring(part, k) 
                      for part in s.split(char))
    
    # All characters appear >= k times
    return len(s)

# Alternative: Sliding window with fixed unique count
def longest_substring_v2(s: str, k: int) -> int:
    """
    For each possible number of unique characters (1 to 26),
    find longest valid substring using sliding window.
    """
    def longest_with_n_unique(n: int) -> int:
        """Longest substring with exactly n unique chars, each >= k times."""
        count = defaultdict(int)
        left = 0
        max_len = 0
        unique = 0      # Unique chars in window
        at_least_k = 0  # Chars with count >= k
        
        for right in range(len(s)):
            # Add right character
            if count[s[right]] == 0:
                unique += 1
            count[s[right]] += 1
            if count[s[right]] == k:
                at_least_k += 1
            
            # Shrink while too many unique chars
            while unique > n:
                if count[s[left]] == k:
                    at_least_k -= 1
                count[s[left]] -= 1
                if count[s[left]] == 0:
                    unique -= 1
                left += 1
            
            # Check if valid
            if unique == n == at_least_k:
                max_len = max(max_len, right - left + 1)
        
        return max_len
    
    # Try all possible unique counts
    return max(longest_with_n_unique(n) for n in range(1, 27))
```

---

# Chapter 5: Master Summary

```
┌─────────────────────────────────────────────────────────────────┐
│              HARD PROBLEMS - KEY TECHNIQUES                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  SUBARRAY PROBLEMS:                                             │
│  • Bounded max: count(≤R) - count(≤L-1)                        │
│  • Count smaller after: Merge sort with counting               │
│  • Range sum: Merge sort on prefix sums                        │
│                                                                 │
│  STRING PROBLEMS:                                               │
│  • Minimum window: "formed" counter optimization               │
│  • K distinct: at_most(k) - at_most(k-1)                      │
│  • Repeating chars: window_size - max_count ≤ k               │
│                                                                 │
│  SORTED ARRAYS:                                                 │
│  • Median: Binary search on partition position                 │
│  • Kth pair distance: Binary search + two pointer count        │
│  • Matrix kth: Binary search on value, count with zigzag       │
│                                                                 │
│  LINKED LISTS:                                                  │
│  • Reverse k-group: Process k nodes, connect groups           │
│  • Merge k lists: Divide & conquer or min-heap                │
│                                                                 │
│  MULTI-DIMENSIONAL:                                             │
│  • 3Sum smaller: count = k - j when sum < target              │
│  • 4Sum II: Hash first half, query second half                │
│                                                                 │
│  SLIDING WINDOW:                                                │
│  • Maximum: Monotonic decreasing deque                         │
│  • Median: Two heaps with lazy deletion                        │
│  • K repeating: Divide and conquer by invalid chars           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# Interview Tips for Hard Problems

```
┌─────────────────────────────────────────────────────────────────┐
│              HARD PROBLEM SOLVING STRATEGY                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. IDENTIFY THE PATTERN                                        │
│     • Is it subarray/substring? → Sliding window               │
│     • Is it sorted arrays? → Binary search + two pointers      │
│     • Is it counting? → Consider merge sort or hash            │
│                                                                 │
│  2. REDUCE COMPLEXITY                                           │
│     • O(n³) → O(n²): Fix one, two-pointer for rest            │
│     • O(n²) → O(n log n): Binary search / divide & conquer    │
│     • O(n²) → O(n): Sliding window / hash map                 │
│                                                                 │
│  3. HANDLE EDGE CASES                                           │
│     • Empty input                                               │
│     • Single element                                            │
│     • All same elements                                         │
│     • k larger than array size                                  │
│                                                                 │
│  4. OPTIMIZE SPACE                                              │
│     • Can hash map be replaced with array?                     │
│     • Can we use pointers instead of extra space?              │
│     • Can we modify input array?                                │
│                                                                 │
│  5. TEST YOUR SOLUTION                                          │
│     • Small examples by hand                                    │
│     • Edge cases                                                │
│     • Time/space complexity analysis                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

**Next Chapter:** Chapter 6 will cover Important Notes, Common Mistakes, and a curated Practice Problem List.
