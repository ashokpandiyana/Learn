# Chapter 12: Sliding Window on Circular Arrays

## 12.1 Introduction: The Circular Challenge

### What is a Circular Array?

```
CIRCULAR ARRAY CONCEPT:
════════════════════════════════════════════════════════════════

In a circular array, the last element connects back to the first.

Linear Array:
┌───┬───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │ 5 │ → END
└───┴───┴───┴───┴───┘

Circular Array:
        ┌───────────────────┐
        ↓                   │
┌───┬───┬───┬───┬───┐       │
│ 1 │ 2 │ 3 │ 4 │ 5 │ ──────┘
└───┴───┴───┴───┴───┘
  ↑                 │
  └─────────────────┘

Valid "subarrays" can wrap around:
  • [3, 4, 5]      - normal
  • [4, 5, 1]      - wraps around!
  • [5, 1, 2]      - wraps around!
  • [5, 1, 2, 3]   - wraps around!
```

### The Challenge

```
WHY CIRCULAR ARRAYS ARE TRICKY:
════════════════════════════════════════════════════════════════

Standard sliding window assumes:
  • Window starts at index i
  • Window ends at index j where j >= i
  • Indices are always left-to-right

Circular arrays allow:
  • Window that starts at index 4 and ends at index 1
  • Window that wraps around the boundary
  • More possible subarrays to consider!

Example: arr = [1, 2, 3, 4, 5], find max sum of 3 elements

Linear subarrays:
  [1,2,3], [2,3,4], [3,4,5]

Circular subarrays:
  [1,2,3], [2,3,4], [3,4,5], [4,5,1], [5,1,2]
                             ↑        ↑
                         wrapping  wrapping
```

---

## 12.2 Technique 1: Double the Array

### Concept

```
THE DOUBLING TRICK:
════════════════════════════════════════════════════════════════

Concatenate the array with itself!

Original:  [1, 2, 3, 4, 5]

Doubled:   [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]
            └─────────────┘ └─────────────┘
               original        copy

Now a "circular" window is just a normal window in doubled array!

Circular [4, 5, 1] becomes:
  Doubled:  [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]
                     └────────┘
                    indices 3-5

IMPORTANT: Window size must not exceed n (original length)
           Otherwise we'd count elements twice!
```

### Template: Circular Fixed Window

```python
def max_sum_circular_fixed_k(arr, k):
    """
    Find maximum sum of k consecutive elements in circular array.
    
    Approach: Double the array, apply standard sliding window,
    but ensure window doesn't exceed original array length.
    """
    n = len(arr)
    if k > n:
        return sum(arr)  # Window is entire array
    
    # Double the array
    doubled = arr + arr
    
    # Standard fixed-size sliding window
    window_sum = sum(doubled[:k])
    max_sum = window_sum
    
    for i in range(k, len(doubled)):
        # Don't let window span more than n elements
        if i >= n + k:
            break  # Would wrap more than once
        
        window_sum += doubled[i] - doubled[i - k]
        max_sum = max(max_sum, window_sum)
    
    return max_sum
```

### Visual Example

```
arr = [5, -3, 5], k = 2
n = 3

doubled = [5, -3, 5, 5, -3, 5]
           0   1  2  3   4  5

═══════════════════════════════════════════════════════════════
Standard windows in doubled array (size 2):
═══════════════════════════════════════════════════════════════

Window [0,1]: [5, -3] = 2
Window [1,2]: [-3, 5] = 2
Window [2,3]: [5, 5] = 10  ← This wraps around! [5, 5] in circular
Window [3,4]: [5, -3] = 2   (same as [0,1] - stop here!)

We stop at i = n + k - 1 = 3 + 2 - 1 = 4
Actually we process up to i = 3 (window [2,3])

═══════════════════════════════════════════════════════════════
Maximum circular sum: 10 (elements at indices 2 and 0)

In original circular array: [5, 5] wrapping from index 2 to 0
```

### When Doubling Works Best

```
USE DOUBLING WHEN:
════════════════════════════════════════════════════════════════

✓ Fixed-size window problems
✓ Finding specific patterns that might wrap
✓ Window size is small relative to array
✓ Simple implementation is preferred

CAUTION:
─────────────────────────────────────────────────────────────
• Space complexity doubles: O(2n) = O(n)
• Must limit window to avoid counting elements twice
• For very large arrays, consider other techniques
```

---

## 12.3 Technique 2: Complement Approach (Maximum Circular Subarray Sum)

### The Brilliant Insight

```
THE COMPLEMENT INSIGHT:
════════════════════════════════════════════════════════════════

A circular subarray that WRAPS AROUND is the COMPLEMENT of
a non-wrapping subarray in the middle!

┌───────────────────────────────────────────────────────────────┐
│                                                               │
│  Array: [a, b, c, d, e, f, g, h]                              │
│                                                               │
│  Wrapping subarray (what we want):                            │
│  [■, ■, □, □, □, □, ■, ■]                                     │
│   ↑  ↑              ↑  ↑                                      │
│   included          included                                  │
│                                                               │
│  Non-wrapping middle (complement):                            │
│  [□, □, ■, ■, ■, ■, □, □]                                     │
│         ↑  ↑  ↑  ↑                                            │
│         excluded (middle part)                                │
│                                                               │
│  KEY FORMULA:                                                 │
│  ─────────────────────────────────────────────────────────── │
│  sum(wrapping) = total_sum - sum(middle)                      │
│                                                               │
│  To MAXIMIZE sum(wrapping):                                   │
│  MINIMIZE sum(middle)!                                        │
│                                                               │
│  max_circular_sum = total_sum - min_subarray_sum              │
│                                                               │
└───────────────────────────────────────────────────────────────┘
```

### Implementation: Maximum Circular Subarray Sum

```python
def max_subarray_sum_circular(nums):
    """
    LeetCode 918: Maximum Sum Circular Subarray
    
    Find maximum sum of a non-empty subarray in circular array.
    
    Two cases:
    1. Max subarray doesn't wrap → standard Kadane's
    2. Max subarray wraps → total - min_subarray
    
    Answer: max(case1, case2)
    
    Time: O(n)
    Space: O(1)
    """
    total = 0
    max_sum = float('-inf')
    min_sum = float('inf')
    current_max = 0
    current_min = 0
    
    for num in nums:
        total += num
        
        # Kadane's for maximum subarray
        current_max = max(current_max + num, num)
        max_sum = max(max_sum, current_max)
        
        # Kadane's for minimum subarray
        current_min = min(current_min + num, num)
        min_sum = min(min_sum, current_min)
    
    # Edge case: all negative numbers
    # If min_sum == total, then max wrapping = 0 (empty, invalid)
    # We must take at least one element
    if min_sum == total:
        return max_sum
    
    return max(max_sum, total - min_sum)
```

### Visual Walkthrough

```
nums = [5, -3, 5]

═══════════════════════════════════════════════════════════════
STEP 1: Calculate all values in one pass
═══════════════════════════════════════════════════════════════

total = 5 + (-3) + 5 = 7

Kadane's for MAX:
  i=0: current_max = max(0+5, 5) = 5, max_sum = 5
  i=1: current_max = max(5-3, -3) = 2, max_sum = 5
  i=2: current_max = max(2+5, 5) = 7, max_sum = 7

Kadane's for MIN:
  i=0: current_min = min(0+5, 5) = 5, min_sum = 5
  i=1: current_min = min(5-3, -3) = -3, min_sum = -3
  i=2: current_min = min(-3+5, 5) = 2, min_sum = -3

═══════════════════════════════════════════════════════════════
STEP 2: Compare cases
═══════════════════════════════════════════════════════════════

Case 1 (non-wrapping): max_sum = 7
  Subarray: [5, -3, 5] (entire array)

Case 2 (wrapping): total - min_sum = 7 - (-3) = 10
  Middle (min) subarray: [-3] at index 1
  Wrapping subarray: [5] + [5] = indices 2 and 0

═══════════════════════════════════════════════════════════════
STEP 3: Return maximum
═══════════════════════════════════════════════════════════════

Answer = max(7, 10) = 10

The circular subarray [5, 5] (wrapping) has sum 10.

VERIFICATION:
  ┌───┬────┬───┐
  │ 5 │ -3 │ 5 │
  └───┴────┴───┘
    ↑        ↑
    └────────┘
   Circular: [5, 5] = 10 ✓
```

### Edge Case: All Negative Numbers

```
SPECIAL CASE: ALL NEGATIVE
════════════════════════════════════════════════════════════════

nums = [-3, -2, -5]

total = -10
max_sum = -2 (best single element)
min_sum = -10 (entire array)

Case 2: total - min_sum = -10 - (-10) = 0

But 0 means EMPTY subarray (we excluded everything)!
We MUST take at least one element.

So when min_sum == total:
  Return max_sum (the least negative element)

Answer: -2
```

---

## 12.4 Technique 3: Modular Indexing

### Concept

```
MODULAR INDEX APPROACH:
════════════════════════════════════════════════════════════════

Instead of doubling the array, use modular arithmetic:

index % n gives circular position

For window starting at position start with size k:
  Positions: start, (start+1)%n, (start+2)%n, ..., (start+k-1)%n

Example: arr = [A, B, C, D, E], n=5, k=3

Start=3: positions 3, 4, 0 → [D, E, A]
Start=4: positions 4, 0, 1 → [E, A, B]

No need to create doubled array!
```

### Implementation

```python
def max_sum_circular_modular(arr, k):
    """
    Find maximum sum of k consecutive elements using modular indexing.
    
    Space efficient: O(1) extra space.
    """
    n = len(arr)
    if k > n:
        return sum(arr)
    
    # Calculate sum of first window
    window_sum = sum(arr[i % n] for i in range(k))
    max_sum = window_sum
    
    # Slide the window n times (to cover all circular positions)
    for start in range(1, n):
        # Remove element leaving window
        window_sum -= arr[(start - 1) % n]
        # Add element entering window
        window_sum += arr[(start + k - 1) % n]
        
        max_sum = max(max_sum, window_sum)
    
    return max_sum
```

### Visual: Modular Indexing

```
arr = [1, 2, 3, 4, 5], n=5, k=3

═══════════════════════════════════════════════════════════════
start=0: window at indices 0,1,2
─────────────────────────────────────────────────────────────
  [1] [2] [3]  4   5
   ↑   ↑   ↑
  sum = 6

═══════════════════════════════════════════════════════════════
start=1: window at indices 1,2,3
─────────────────────────────────────────────────────────────
   1  [2] [3] [4]  5
       ↑   ↑   ↑
  Remove: arr[0] = 1
  Add: arr[(1+3-1)%5] = arr[3] = 4
  sum = 6 - 1 + 4 = 9

═══════════════════════════════════════════════════════════════
start=2: window at indices 2,3,4
─────────────────────────────────────────────────────────────
   1   2  [3] [4] [5]
           ↑   ↑   ↑
  Remove: arr[1] = 2
  Add: arr[4] = 5
  sum = 9 - 2 + 5 = 12

═══════════════════════════════════════════════════════════════
start=3: window at indices 3,4,0 (WRAPPING!)
─────────────────────────────────────────────────────────────
  [1]  2   3  [4] [5]
   ↑           ↑   ↑
  Remove: arr[2] = 3
  Add: arr[(3+3-1)%5] = arr[0] = 1
  sum = 12 - 3 + 1 = 10

═══════════════════════════════════════════════════════════════
start=4: window at indices 4,0,1 (WRAPPING!)
─────────────────────────────────────────────────────────────
  [1] [2]  3   4  [5]
   ↑   ↑           ↑
  Remove: arr[3] = 4
  Add: arr[(4+3-1)%5] = arr[1] = 2
  sum = 10 - 4 + 2 = 8

═══════════════════════════════════════════════════════════════
Maximum: 12 at start=2, window [3,4,5]
```

---

## 12.5 Circular Array Problems Catalog

### Problem 1: Maximum Sum Circular Subarray

```python
# Already covered above - use complement approach
# Time: O(n), Space: O(1)
```

### Problem 2: Next Greater Element in Circular Array

```python
def next_greater_circular(nums):
    """
    LeetCode 503: Next Greater Element II
    
    For each element, find next greater element (circularly).
    
    Approach: Process array twice using monotonic stack.
    """
    n = len(nums)
    result = [-1] * n
    stack = []  # Stores indices
    
    # Process array twice for circular
    for i in range(2 * n):
        idx = i % n
        
        while stack and nums[stack[-1]] < nums[idx]:
            result[stack.pop()] = nums[idx]
        
        # Only push indices from first pass
        if i < n:
            stack.append(idx)
    
    return result
```

### Problem 3: Minimum Swaps to Group 1s Together (Circular)

```python
def min_swaps_circular(nums):
    """
    LeetCode 2134: Minimum Swaps to Group All 1's Together II
    
    Circular version of grouping 1s.
    
    Approach: Sliding window of size = count of 1s
    Track minimum 0s in any such window.
    """
    ones = sum(nums)
    if ones == 0 or ones == len(nums):
        return 0
    
    n = len(nums)
    # Count zeros in first window
    zeros = sum(1 for i in range(ones) if nums[i] == 0)
    min_zeros = zeros
    
    # Slide window circularly
    for i in range(n):
        # Remove element leaving window
        if nums[i] == 0:
            zeros -= 1
        # Add element entering window
        if nums[(i + ones) % n] == 0:
            zeros += 1
        
        min_zeros = min(min_zeros, zeros)
    
    return min_zeros
```

---

## 12.6 Technique Comparison

```
CHOOSING THE RIGHT TECHNIQUE:
════════════════════════════════════════════════════════════════

┌───────────────────┬─────────────────────────────────────────┐
│ Technique         │ Best For                                │
├───────────────────┼─────────────────────────────────────────┤
│ Double Array      │ • Simple fixed-size windows             │
│                   │ • Pattern matching                      │
│                   │ • When space isn't critical             │
├───────────────────┼─────────────────────────────────────────┤
│ Complement        │ • Maximum/minimum sum subarray          │
│                   │ • When answer is either wrap or no-wrap │
│                   │ • O(1) space solutions                  │
├───────────────────┼─────────────────────────────────────────┤
│ Modular Index     │ • Space-efficient solutions             │
│                   │ • When array is very large              │
│                   │ • Fixed-size window with O(1) space     │
├───────────────────┼─────────────────────────────────────────┤
│ Two-Pass (Stack)  │ • Next greater/smaller element          │
│                   │ • Monotonic stack problems              │
│                   │ • Problems needing to "see ahead"       │
└───────────────────┴─────────────────────────────────────────┘
```

---

## 12.7 Common Patterns and Templates

### Template 1: Fixed Window Circular

```python
def fixed_window_circular(arr, k):
    """Template for fixed-size window on circular array."""
    n = len(arr)
    
    # Method 1: Double array
    doubled = arr + arr
    # Apply standard sliding window, limit to n windows
    
    # Method 2: Modular indexing
    for start in range(n):
        window_indices = [(start + i) % n for i in range(k)]
        # Process window
```

### Template 2: Variable Window Circular

```python
def variable_window_circular(arr, condition):
    """
    Variable window on circular is tricky!
    Usually converted to non-circular problem.
    """
    # Often use complement approach:
    # circular_answer = transform(non_circular_answer)
    pass
```

### Template 3: Complement for Max/Min

```python
def max_circular_subarray(arr):
    """Template for max sum using complement."""
    total = sum(arr)
    max_normal = kadane_max(arr)
    min_normal = kadane_min(arr)
    
    max_circular = total - min_normal
    
    # Handle all-negative case
    if max_circular == 0:
        return max_normal
    
    return max(max_normal, max_circular)
```

---

## 12.8 Chapter Summary

```
┌─────────────────────────────────────────────────────────────┐
│            CIRCULAR ARRAYS KEY POINTS                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. THREE MAIN TECHNIQUES                                   │
│     • Double array: Simple, O(n) extra space                │
│     • Complement: Elegant, O(1) space for max/min           │
│     • Modular index: Space efficient, uses i % n            │
│                                                             │
│  2. COMPLEMENT INSIGHT                                      │
│     • Wrapping subarray = Total - Middle subarray           │
│     • Max wrapping = Total - Min middle                     │
│     • Handle edge case: all negative numbers                │
│                                                             │
│  3. DOUBLING APPROACH                                       │
│     • doubled = arr + arr                                   │
│     • Limit windows to not exceed n elements                │
│     • Simple but uses extra space                           │
│                                                             │
│  4. MODULAR INDEXING                                        │
│     • Use index % n for circular access                     │
│     • No extra space needed                                 │
│     • Slightly more complex logic                           │
│                                                             │
│  5. COMMON PITFALLS                                         │
│     • Counting elements twice in doubled array              │
│     • All-negative edge case in complement                  │
│     • Off-by-one errors in modular arithmetic               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 12.9 Practice Problems

| Problem | Technique | Difficulty |
|---------|-----------|------------|
| Maximum Sum Circular Subarray (LC 918) | Complement | Medium |
| Next Greater Element II (LC 503) | Two-Pass Stack | Medium |
| Minimum Swaps to Group 1s II (LC 2134) | Modular Window | Medium |
| Circular Array Loop (LC 457) | Two Pointer | Medium |
| Maximum Gap (LC 164) | Bucket/Radix | Hard |
| Josephus Problem | Modular | Medium |
