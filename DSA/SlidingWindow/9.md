# Chapter 9: Minimum Window Pattern

## 9.1 Introduction: The Classic Hard Problem

### What is the Minimum Window Pattern?

The **Minimum Window** pattern finds the smallest window in a string/array that satisfies certain conditions (usually containing all required elements).

```
THE MINIMUM WINDOW PROBLEM:
════════════════════════════════════════════════════════════════

Given: String S and String T
Find:  Smallest substring of S that contains ALL characters of T

Example:
S = "ADOBECODEBANC"
T = "ABC"

Answer: "BANC" (contains A, B, C with length 4)

┌─────────────────────────────────────────────────────────────┐
│  A   D   O   B   E   C   O   D   E   B   A   N   C         │
│                                      └───────────┘         │
│                                         "BANC"             │
│                                                            │
│  Contains: A(1), B(1), C(1) - all characters from T        │
│  Length: 4 - minimum possible                              │
└─────────────────────────────────────────────────────────────┘
```

### Why This Pattern is Important

```
MINIMUM WINDOW IS FOUNDATIONAL:
════════════════════════════════════════════════════════════════

This pattern teaches:
1. Variable window with TWO conditions
   - Expand to find a VALID window
   - Contract to find the MINIMUM valid window

2. The "have/need" tracking mechanism
   - What we need: requirements from T
   - What we have: current window contents

3. Optimal O(1) validity checking
   - Using "formed" counter instead of map comparison

4. Proper result tracking
   - Update result WHILE contracting (inside while loop)

Many other problems are variations:
• Minimum Window Substring (LC 76)
• Minimum Window Subsequence (LC 727)
• Smallest Range Covering Elements (LC 632)
• Minimum Size Subarray Sum (LC 209)
```

---

## 9.2 Core Algorithm: The Have/Need Framework

### Conceptual Framework

```
THE HAVE/NEED MENTAL MODEL:
════════════════════════════════════════════════════════════════

┌─────────────────┐         ┌─────────────────┐
│      NEED       │         │      HAVE       │
│   (from T)      │         │   (in window)   │
├─────────────────┤         ├─────────────────┤
│  A: 1           │         │  A: ?           │
│  B: 1           │  ───►   │  B: ?           │
│  C: 1           │ compare │  C: ?           │
│                 │         │  ...            │
└─────────────────┘         └─────────────────┘
        │                           │
        │                           │
        ▼                           ▼
  required = 3              formed = ? 
  (unique chars)            (chars satisfied)

GOAL: formed == required (all needed chars are satisfied)
```

### The "Formed" Counter Logic

```
WHEN IS A CHARACTER "FORMED" (SATISFIED)?
════════════════════════════════════════════════════════════════

A character is SATISFIED when:
  have[char] >= need[char]

But we only want to count each character ONCE toward "formed":
  - Increment formed when have[char] BECOMES equal to need[char]
  - Decrement formed when have[char] DROPS below need[char]

Example: need['A'] = 2

have['A'] = 0 → 1:  Still need more (1 < 2)
have['A'] = 1 → 2:  NOW satisfied! formed++ (2 == 2)
have['A'] = 2 → 3:  Already satisfied, don't increment again
have['A'] = 3 → 2:  Still satisfied (2 >= 2)
have['A'] = 2 → 1:  No longer satisfied! formed-- (1 < 2)
```

---

## 9.3 Complete Implementation

### The Standard Template

```python
from collections import Counter, defaultdict

def min_window(s, t):
    """
    LeetCode 76: Minimum Window Substring
    
    Find the minimum window in s which contains all characters of t.
    
    Time: O(|S| + |T|)
    Space: O(|S| + |T|) worst case for result string
    
    The pattern:
    1. Expand right to find a valid window
    2. Contract left to minimize while still valid
    3. Record the minimum valid window found
    """
    if not s or not t or len(s) < len(t):
        return ""
    
    # NEED: Character frequencies required from T
    need = Counter(t)
    required = len(need)  # Number of unique characters we need
    
    # HAVE: Character frequencies in current window
    have = defaultdict(int)
    formed = 0  # Number of unique characters satisfied
    
    # Window pointers
    left = 0
    
    # Result tracking
    min_len = float('inf')
    result_left = 0
    result_right = 0
    
    # Expand with right pointer
    for right in range(len(s)):
        char = s[right]
        
        # Add character to window
        have[char] += 1
        
        # Check if this character is now satisfied
        if char in need and have[char] == need[char]:
            formed += 1
        
        # Contract while window is valid
        while formed == required:
            # Update result if this is smaller
            window_len = right - left + 1
            if window_len < min_len:
                min_len = window_len
                result_left = left
                result_right = right
            
            # Remove character from left
            left_char = s[left]
            have[left_char] -= 1
            
            # Check if we lost a satisfied character
            if left_char in need and have[left_char] < need[left_char]:
                formed -= 1
            
            left += 1
    
    return "" if min_len == float('inf') else s[result_left:result_right + 1]
```

---

## 9.4 Detailed Visual Walkthrough

```
s = "ADOBECODEBANC", t = "ABC"

INITIALIZATION:
═══════════════════════════════════════════════════════════════
need = {'A': 1, 'B': 1, 'C': 1}
required = 3
have = {}
formed = 0
min_len = ∞

═══════════════════════════════════════════════════════════════
right=0, char='A'
─────────────────────────────────────────────────────────────
  [A]  D   O   B   E   C   O   D   E   B   A   N   C
   ↑
  left=0
  
  have = {'A': 1}
  'A' in need and have['A']==need['A'] → formed = 1
  
  formed(1) ≠ required(3), don't contract

═══════════════════════════════════════════════════════════════
right=1, char='D'
─────────────────────────────────────────────────────────────
  [A   D]  O   B   E   C   O   D   E   B   A   N   C
       ↑
  left=0
  
  have = {'A': 1, 'D': 1}
  'D' not in need, formed stays 1
  
  formed(1) ≠ required(3)

═══════════════════════════════════════════════════════════════
right=2, char='O'
─────────────────────────────────────────────────────────────
  [A   D   O]  B   E   C   O   D   E   B   A   N   C
           ↑
  left=0
  
  have = {'A': 1, 'D': 1, 'O': 1}
  'O' not in need, formed = 1

═══════════════════════════════════════════════════════════════
right=3, char='B'
─────────────────────────────────────────────────────────────
  [A   D   O   B]  E   C   O   D   E   B   A   N   C
               ↑
  left=0
  
  have = {'A': 1, 'D': 1, 'O': 1, 'B': 1}
  'B' in need and have['B']==need['B'] → formed = 2

═══════════════════════════════════════════════════════════════
right=4, char='E'
─────────────────────────────────────────────────────────────
  [A   D   O   B   E]  C   O   D   E   B   A   N   C
                   ↑
  left=0
  
  have = {'A': 1, 'D': 1, 'O': 1, 'B': 1, 'E': 1}
  'E' not in need, formed = 2

═══════════════════════════════════════════════════════════════
right=5, char='C'    ★ FIRST VALID WINDOW! ★
─────────────────────────────────────────────────────────────
  [A   D   O   B   E   C]  O   D   E   B   A   N   C
                       ↑
  left=0
  
  have = {'A': 1, 'D': 1, 'O': 1, 'B': 1, 'E': 1, 'C': 1}
  'C' in need and have['C']==need['C'] → formed = 3
  
  formed(3) == required(3)! ★ VALID WINDOW ★
  
  ┌─────────────────────────────────────────────────────────┐
  │ CONTRACT PHASE BEGINS                                   │
  └─────────────────────────────────────────────────────────┘
  
  ITERATION 1:
  window_len = 5-0+1 = 6, "ADOBEC"
  6 < ∞ → Update: min_len=6, result="ADOBEC"
  
  Remove s[0]='A': have['A'] = 0
  'A' in need and have['A'](0) < need['A'](1) → formed = 2
  left = 1
  
  formed(2) ≠ required(3), EXIT contraction

═══════════════════════════════════════════════════════════════
right=6, char='O'
─────────────────────────────────────────────────────────────
   A  [D   O   B   E   C   O]  D   E   B   A   N   C
                           ↑
  left=1
  
  have['O'] = 2
  formed = 2 (still need 'A')

═══════════════════════════════════════════════════════════════
right=7,8,9: chars='D','E','B'
─────────────────────────────────────────────────────────────
   A  [D   O   B   E   C   O   D   E   B]  A   N   C
                                       ↑
  left=1
  
  have = {..., 'B': 2}
  formed = 2 (still missing 'A')

═══════════════════════════════════════════════════════════════
right=10, char='A'    ★ VALID WINDOW AGAIN! ★
─────────────────────────────────────────────────────────────
   A  [D   O   B   E   C   O   D   E   B   A]  N   C
                                           ↑
  left=1
  
  have['A'] = 1, formed = 3
  
  CONTRACT PHASE:
  
  ITERATION 1:
  window = "DOBECODEBA" (length 10)
  10 > 6 (current min), don't update
  Remove 'D': formed stays 3 (D not in need)
  left = 2
  
  ITERATION 2:
  window = "OBECODEBA" (length 9)
  9 > 6, don't update
  Remove 'O': formed stays 3
  left = 3
  
  ITERATION 3:
  window = "BECODEBA" (length 8)
  8 > 6, don't update
  Remove 'B': have['B']=1, still >= need['B']=1, formed stays 3
  left = 4
  
  ITERATION 4:
  window = "ECODEBA" (length 7)
  7 > 6, don't update
  Remove 'E': formed stays 3
  left = 5
  
  ITERATION 5:
  window = "CODEBA" (length 6)
  6 = 6, don't update (not smaller)
  Remove 'C': have['C']=0 < need['C']=1, formed = 2
  left = 6
  
  EXIT contraction

═══════════════════════════════════════════════════════════════
right=11, char='N'
─────────────────────────────────────────────────────────────
   ...  C  [O   D   E   B   A   N]  C
                                ↑
  left=6
  
  'N' not in need, formed = 2

═══════════════════════════════════════════════════════════════
right=12, char='C'    ★ VALID WINDOW! ★
─────────────────────────────────────────────────────────────
   ...  C  [O   D   E   B   A   N   C]
                                    ↑
  left=6
  
  have['C'] = 1, formed = 3
  
  CONTRACT PHASE:
  
  ITERATION 1:
  window = "ODEBANC" (length 7)
  7 > 6, don't update
  Remove 'O': formed stays 3
  left = 7
  
  ITERATION 2:
  window = "DEBANC" (length 6)
  6 = 6, don't update
  Remove 'D': formed stays 3
  left = 8
  
  ITERATION 3:
  window = "EBANC" (length 5)
  5 < 6 → Update: min_len=5, result="EBANC"
  Remove 'E': formed stays 3
  left = 9
  
  ITERATION 4:
  window = "BANC" (length 4)
  4 < 5 → Update: min_len=4, result="BANC"
  Remove 'B': have['B']=0 < need['B']=1, formed = 2
  left = 10
  
  EXIT contraction

═══════════════════════════════════════════════════════════════
END OF STRING

FINAL RESULT: "BANC" (length 4)
```

---

## 9.5 Key Insights and Gotchas

### Insight 1: Why Update Inside While Loop?

```
┌─────────────────────────────────────────────────────────────┐
│  FOR MINIMUM PROBLEMS: Update result INSIDE the while loop  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  The while loop condition: formed == required               │
│  This means the window is VALID                             │
│                                                             │
│  We contract to find the SMALLEST valid window              │
│  Each iteration might give us a smaller valid window        │
│  So we check and update at EACH iteration                   │
│                                                             │
│  while formed == required:   # Window is valid              │
│      update_result()         # Might be minimum             │
│      contract()              # Try to make smaller          │
│                                                             │
│  After while loop, window is INVALID (too small)            │
│  So we DON'T update after the loop                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Insight 2: The Formed Counter Conditions

```
PRECISE CONDITIONS FOR formed UPDATES:
════════════════════════════════════════════════════════════════

WHEN ADDING A CHARACTER (have[char]++):
─────────────────────────────────────────────────────────────
Check AFTER incrementing:
  if char in need and have[char] == need[char]:
      formed += 1
      
Why "== need[char]"?
  • have[char] < need[char]: Not yet satisfied
  • have[char] == need[char]: JUST became satisfied (increment!)
  • have[char] > need[char]: Was already satisfied (don't double count)


WHEN REMOVING A CHARACTER (have[char]--):
─────────────────────────────────────────────────────────────
Check AFTER decrementing:
  if char in need and have[char] < need[char]:
      formed -= 1
      
Why "< need[char]"?
  • Before removal: have[char] >= need[char] (was satisfied)
  • After removal: have[char] < need[char] means we JUST lost it
  
Alternative (check BEFORE decrementing):
  if char in need and have[char] == need[char]:
      formed -= 1
  have[char] -= 1
```

### Insight 3: Handling Characters Not in T

```
OPTIMIZATION: Only track characters in need
════════════════════════════════════════════════════════════════

Characters not in T don't affect "formed" count.
We can either:

1. Track all (simpler, slightly more memory):
   have[char] += 1
   if char in need and have[char] == need[char]:
       formed += 1

2. Only track needed chars (more efficient):
   if char in need:
       have[char] += 1
       if have[char] == need[char]:
           formed += 1

Both work! Method 1 is cleaner, Method 2 is slightly faster.
```

---

## 9.6 Variations of Minimum Window

### Variation 1: Minimum Window with Unique Characters

```python
def min_window_unique(s, t):
    """
    Variation: Each character in T appears exactly once.
    Simpler because we don't need to track counts.
    """
    need = set(t)
    have = set()
    
    left = 0
    min_len = float('inf')
    result = ""
    
    for right in range(len(s)):
        if s[right] in need:
            have.add(s[right])
        
        while len(have) == len(need):
            if right - left + 1 < min_len:
                min_len = right - left + 1
                result = s[left:right + 1]
            
            if s[left] in need:
                have.remove(s[left])
            left += 1
    
    return result
```

### Variation 2: Minimum Window Subsequence

```python
def min_window_subsequence(s, t):
    """
    LeetCode 727: Minimum Window Subsequence
    
    Find minimum window in S that contains T as a SUBSEQUENCE.
    Characters must appear in ORDER (but not necessarily contiguous).
    
    Example: S = "abcdebdde", T = "bde"
    Answer: "bcde" (b...d...e in order)
    
    This requires a different approach - DP or two-pass.
    """
    # Find ending position of subsequence
    def find_end(s, t, start):
        t_idx = 0
        for i in range(start, len(s)):
            if s[i] == t[t_idx]:
                t_idx += 1
                if t_idx == len(t):
                    return i
        return -1
    
    # Find starting position (scan backwards)
    def find_start(s, t, end):
        t_idx = len(t) - 1
        for i in range(end, -1, -1):
            if s[i] == t[t_idx]:
                t_idx -= 1
                if t_idx < 0:
                    return i
        return -1
    
    min_len = float('inf')
    result = ""
    start = 0
    
    while start < len(s):
        # Find where T ends as subsequence starting from 'start'
        end = find_end(s, t, start)
        if end == -1:
            break
        
        # Find where this subsequence actually starts
        new_start = find_start(s, t, end)
        
        # Update result if smaller
        if end - new_start + 1 < min_len:
            min_len = end - new_start + 1
            result = s[new_start:end + 1]
        
        # Move to next potential start
        start = new_start + 1
    
    return result
```

### Variation 3: Minimum Window with Sum Constraint

```python
def min_subarray_sum(nums, target):
    """
    LeetCode 209: Minimum Size Subarray Sum
    
    Find minimum length subarray with sum >= target.
    Same pattern, different condition!
    """
    left = 0
    current_sum = 0
    min_len = float('inf')
    
    for right in range(len(nums)):
        current_sum += nums[right]
        
        # Contract while valid (sum >= target)
        while current_sum >= target:
            min_len = min(min_len, right - left + 1)
            current_sum -= nums[left]
            left += 1
    
    return min_len if min_len != float('inf') else 0
```

---

## 9.7 Common Mistakes

### Mistake 1: Wrong Formed Counter Update

```python
# ❌ WRONG: Incrementing formed for every add
have[char] += 1
if char in need:
    formed += 1  # Wrong! Might count same char multiple times

# ✅ CORRECT: Only when count becomes exactly equal
have[char] += 1
if char in need and have[char] == need[char]:
    formed += 1
```

### Mistake 2: Updating Result in Wrong Place

```python
# ❌ WRONG: Update after while loop
while formed == required:
    # contract
    pass
update_result()  # Window is now INVALID!

# ✅ CORRECT: Update inside while loop
while formed == required:
    update_result()  # Window is still VALID
    contract()
```

### Mistake 3: Off-by-One in Result String

```python
# ❌ WRONG: 
result = s[left:right]  # Missing the character at 'right'

# ✅ CORRECT:
result = s[left:right + 1]  # Include character at 'right'
```

### Mistake 4: Not Handling Edge Cases

```python
# ✅ CORRECT: Check edge cases first
if not s or not t:
    return ""
if len(s) < len(t):
    return ""  # S too short to contain T
```

---

## 9.8 Time and Space Complexity

```
COMPLEXITY ANALYSIS:
════════════════════════════════════════════════════════════════

TIME: O(|S| + |T|)
─────────────────────────────────────────────────────────────
• Building need map: O(|T|)
• Each character in S is visited at most twice:
  - Once when right pointer adds it
  - Once when left pointer removes it
• Total: O(|S| + |T|)

SPACE: O(|S| + |T|)
─────────────────────────────────────────────────────────────
• need map: O(|T|) for unique characters
• have map: O(|S|) worst case
• Result string: O(|S|) worst case

Note: If only lowercase letters, space is O(52) = O(1) for maps
```

---

## 9.9 Chapter Summary

```
┌─────────────────────────────────────────────────────────────┐
│           MINIMUM WINDOW PATTERN KEY POINTS                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. HAVE/NEED FRAMEWORK                                     │
│     • need: requirements from target                        │
│     • have: current window contents                         │
│     • formed: count of satisfied unique characters          │
│     • required: total unique characters needed              │
│                                                             │
│  2. TWO-PHASE ALGORITHM                                     │
│     • EXPAND: Add chars until formed == required            │
│     • CONTRACT: Remove chars while formed == required       │
│                                                             │
│  3. RESULT UPDATE                                           │
│     • Update INSIDE while loop (window is valid)            │
│     • Track both length AND positions                       │
│                                                             │
│  4. FORMED COUNTER LOGIC                                    │
│     • Add: formed++ when have[c] BECOMES equal to need[c]   │
│     • Remove: formed-- when have[c] DROPS below need[c]     │
│                                                             │
│  5. COMPLEXITY                                              │
│     • Time: O(|S| + |T|)                                    │
│     • Space: O(|S| + |T|) or O(1) for fixed charset         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 9.10 Practice Problems

| Problem | Variation | Difficulty |
|---------|-----------|------------|
| Minimum Window Substring (LC 76) | Classic | Hard |
| Minimum Size Subarray Sum (LC 209) | Sum-based | Medium |
| Minimum Window Subsequence (LC 727) | Subsequence | Hard |
| Smallest Range Covering Elements (LC 632) | Multi-list | Hard |
| Shortest Subarray with Sum ≥ K (LC 862) | With negatives | Hard |
| Minimum Operations to Reduce X to Zero (LC 1658) | Inverse | Medium |
