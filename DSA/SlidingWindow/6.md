# Chapter 6: Two Sliding Windows

## 6.1 Introduction: When One Window Isn't Enough

### The Problem

Some problems require tracking **multiple constraints** simultaneously that can't be handled by a single window or data structure.

```
SCENARIOS REQUIRING TWO WINDOWS:
════════════════════════════════════════════════════════════════

1. TRACKING MIN AND MAX TOGETHER
   "Find longest subarray where max - min ≤ limit"
   → Need both maximum and minimum in O(1)
   → Use two monotonic deques

2. TWO RELATED CONDITIONS
   "Find subarray where sum ≥ X AND length ≤ Y"
   → Two different constraints
   → May need two pointers with different logic

3. COMPARING TWO RANGES
   "Find if pattern exists in text"
   → One window on pattern, one on text
   → Track both simultaneously

4. NESTED WINDOW PROBLEMS
   "For each window of size K, find max of minimums"
   → Inner window for local property
   → Outer window for aggregation
```

---

## 6.2 Pattern 1: Dual Monotonic Deques

### When to Use

When you need to track **both maximum AND minimum** of a window efficiently.

### Core Concept

```
DUAL DEQUE ARCHITECTURE:
════════════════════════════════════════════════════════════════

                    WINDOW: [a, b, c, d, e]
                           │           │
           ┌───────────────┴───────────┴───────────────┐
           │                                           │
           ▼                                           ▼
    ┌─────────────────┐                     ┌─────────────────┐
    │   MAX DEQUE     │                     │   MIN DEQUE     │
    │   (Decreasing)  │                     │   (Increasing)  │
    │                 │                     │                 │
    │   Front = MAX   │                     │   Front = MIN   │
    └─────────────────┘                     └─────────────────┘
           │                                           │
           └─────────────────┬─────────────────────────┘
                             │
                             ▼
                    max - min = difference
                    
    If difference > limit → contract window
```

### Complete Example: Longest Subarray with Bounded Difference

```python
from collections import deque

def longest_subarray(nums, limit):
    """
    LeetCode 1438: Longest Continuous Subarray With 
    Absolute Diff Less Than or Equal to Limit
    
    Find the longest subarray where:
    max(subarray) - min(subarray) <= limit
    
    Time: O(n) - each element added/removed from each deque once
    Space: O(n) - worst case both deques hold all elements
    """
    max_dq = deque()  # Stores indices, values in decreasing order
    min_dq = deque()  # Stores indices, values in increasing order
    left = 0
    result = 0
    
    for right in range(len(nums)):
        # Maintain MAX deque (decreasing order)
        # Remove smaller elements - they can never be max
        while max_dq and nums[max_dq[-1]] <= nums[right]:
            max_dq.pop()
        max_dq.append(right)
        
        # Maintain MIN deque (increasing order)
        # Remove larger elements - they can never be min
        while min_dq and nums[min_dq[-1]] >= nums[right]:
            min_dq.pop()
        min_dq.append(right)
        
        # Contract while constraint violated
        while nums[max_dq[0]] - nums[min_dq[0]] > limit:
            left += 1
            # Remove elements outside window
            if max_dq[0] < left:
                max_dq.popleft()
            if min_dq[0] < left:
                min_dq.popleft()
        
        # Update result (window is valid now)
        result = max(result, right - left + 1)
    
    return result
```

### Visual Walkthrough

```
nums = [10, 1, 2, 4, 7, 2], limit = 5

═══════════════════════════════════════════════════════════════
i=0: num=10
─────────────────────────────────────────────────────────────
  [10]  1   2   4   7   2
    ↑
  left=0
  
  max_dq = [0] → max = 10
  min_dq = [0] → min = 10
  
  diff = 10 - 10 = 0 ≤ 5 ✓
  result = 1

═══════════════════════════════════════════════════════════════
i=1: num=1
─────────────────────────────────────────────────────────────
  [10   1]  2   4   7   2
        ↑
  left=0
  
  max_dq: 10 > 1, keep front → [0, 1] → max = 10
  min_dq: 10 > 1, pop, add   → [1]    → min = 1
  
  diff = 10 - 1 = 9 > 5 ✗
  
  CONTRACT: left = 1
  max_dq[0]=0 < left=1 → popleft → max_dq = [1]
  
  diff = 1 - 1 = 0 ≤ 5 ✓
  result = max(1, 1) = 1

═══════════════════════════════════════════════════════════════
i=2: num=2
─────────────────────────────────────────────────────────────
       [1   2]  4   7   2
            ↑
  left=1
  
  max_dq: 1 < 2, pop, add → [2] → max = 2
  min_dq: 1 < 2, keep     → [1, 2] → min = 1
  
  diff = 2 - 1 = 1 ≤ 5 ✓
  result = max(1, 2) = 2

═══════════════════════════════════════════════════════════════
i=3: num=4
─────────────────────────────────────────────────────────────
       [1   2   4]  7   2
                ↑
  left=1
  
  max_dq: 2 < 4, pop, add → [3] → max = 4
  min_dq: 2 < 4, keep     → [1, 2, 3] → min = 1
  
  diff = 4 - 1 = 3 ≤ 5 ✓
  result = max(2, 3) = 3

═══════════════════════════════════════════════════════════════
i=4: num=7
─────────────────────────────────────────────────────────────
       [1   2   4   7]  2
                    ↑
  left=1
  
  max_dq: 4 < 7, pop, add → [4] → max = 7
  min_dq: 4 < 7, keep     → [1, 2, 3, 4] → min = 1
  
  diff = 7 - 1 = 6 > 5 ✗
  
  CONTRACT: left = 2
  min_dq[0]=1 < left=2 → popleft → min_dq = [2, 3, 4]
  
  diff = 7 - 2 = 5 ≤ 5 ✓
  result = max(3, 3) = 3

═══════════════════════════════════════════════════════════════
i=5: num=2
─────────────────────────────────────────────────────────────
           [2   4   7   2]
                        ↑
  left=2
  
  max_dq: 7 > 2, keep → [4, 5] → max = 7
  min_dq: maintain increasing:
          nums[4]=7 > 2, pop → [2, 3]
          nums[3]=4 > 2, pop → [2]
          nums[2]=2 = 2, pop → []
          add 5 → [5] → min = 2
  
  diff = 7 - 2 = 5 ≤ 5 ✓
  result = max(3, 4) = 4

═══════════════════════════════════════════════════════════════
FINAL: 4

Window [2, 4, 7, 2]: max=7, min=2, diff=5 ≤ 5 ✓
```

---

## 6.3 Pattern 2: Two HashMaps for Pattern Matching

### When to Use

When comparing **character frequencies** between a pattern and a window in the text.

### Example: Minimum Window Substring

```python
from collections import Counter, defaultdict

def min_window(s, t):
    """
    LeetCode 76: Minimum Window Substring
    
    Find minimum window in s that contains all characters in t.
    
    Uses TWO frequency maps:
    1. 'need' - what we need from pattern t
    2. 'have' - what we currently have in window
    
    Plus a counter to track how many characters are satisfied.
    """
    if not s or not t:
        return ""
    
    # Map 1: What we need (from pattern)
    need = Counter(t)
    required = len(need)  # Number of unique chars we need
    
    # Map 2: What we have (in current window)
    have = defaultdict(int)
    formed = 0  # How many unique chars are satisfied
    
    left = 0
    min_len = float('inf')
    result = ""
    
    for right in range(len(s)):
        char = s[right]
        have[char] += 1
        
        # Check if this character is now satisfied
        if char in need and have[char] == need[char]:
            formed += 1
        
        # Contract while we have all required characters
        while formed == required:
            # Update result
            if right - left + 1 < min_len:
                min_len = right - left + 1
                result = s[left:right + 1]
            
            # Remove left character
            left_char = s[left]
            have[left_char] -= 1
            
            # Check if we lost a satisfied character
            if left_char in need and have[left_char] < need[left_char]:
                formed -= 1
            
            left += 1
    
    return result
```

### Visual: Two HashMap State

```
s = "ADOBECODEBANC", t = "ABC"

INITIAL STATE:
═══════════════════════════════════════════════════════════════
need = {'A': 1, 'B': 1, 'C': 1}
required = 3 (need 3 unique characters)
have = {}
formed = 0

═══════════════════════════════════════════════════════════════
Building window until formed == required:
─────────────────────────────────────────────────────────────

right=0 'A': have={'A':1}, 'A' satisfied! formed=1
right=1 'D': have={'A':1,'D':1}, formed=1
right=2 'O': have={'A':1,'D':1,'O':1}, formed=1
right=3 'B': have={'A':1,'D':1,'O':1,'B':1}, 'B' satisfied! formed=2
right=4 'E': have={'A':1,'D':1,'O':1,'B':1,'E':1}, formed=2
right=5 'C': have={'A':1,'D':1,'O':1,'B':1,'E':1,'C':1}, 'C' satisfied! formed=3

Window: "ADOBEC" (length 6)

═══════════════════════════════════════════════════════════════
Contracting (formed == 3):
─────────────────────────────────────────────────────────────

  A   D   O   B   E   C   O   D   E   B   A   N   C
  └───────────────────┘
        "ADOBEC"

Save result: "ADOBEC" (length 6)

Remove 'A': have['A']=0 < need['A']=1, formed=2
Can't contract more (formed < required)

═══════════════════════════════════════════════════════════════
Continue expanding:
─────────────────────────────────────────────────────────────

right=6 'O': formed=2
right=7 'D': formed=2
right=8 'E': formed=2
right=9 'B': formed=2
right=10 'A': have['A']=1 == need['A']=1, formed=3!

Window: "DOBECODEBANC" → Contract!

Remove 'D': formed=3 (D not in need)
Remove 'O': formed=3
Remove 'B': have['B']=1 < 2? No, still have 1. 
            But need['B']=1, have['B'] was 2, now 1. Still satisfied!
... continue contracting ...

Eventually find: "BANC" (length 4) - OPTIMAL!
```

---

## 6.4 Pattern 3: Shrinkable vs Non-Shrinkable Window

### The Non-Shrinkable Optimization

Sometimes we don't need to shrink the window - just maintain its maximum size.

```
SHRINKABLE (Standard):
════════════════════════════════════════════════════════════════
while invalid():
    contract()
    
Window size goes up and down.
Finds ALL valid windows.


NON-SHRINKABLE (Optimized):
════════════════════════════════════════════════════════════════
if invalid():
    contract_once()
    
Window size only grows or stays same.
Finds MAXIMUM window size only (not all windows).
```

### Comparison

```python
# SHRINKABLE VERSION
def longest_repeating_shrinkable(s, k):
    """Standard approach - window shrinks as needed"""
    freq = {}
    left = 0
    max_len = 0
    max_freq = 0
    
    for right in range(len(s)):
        freq[s[right]] = freq.get(s[right], 0) + 1
        max_freq = max(max_freq, freq[s[right]])
        
        # Shrink WHILE invalid
        while (right - left + 1) - max_freq > k:
            freq[s[left]] -= 1
            left += 1
        
        max_len = max(max_len, right - left + 1)
    
    return max_len


# NON-SHRINKABLE VERSION
def longest_repeating_nonshrinkable(s, k):
    """
    Optimized - window never shrinks, only grows or slides.
    
    Key insight: We only care about the MAXIMUM window.
    If current window is invalid, we don't need a smaller window
    (we already found one that big or bigger before).
    """
    freq = {}
    left = 0
    max_freq = 0
    
    for right in range(len(s)):
        freq[s[right]] = freq.get(s[right], 0) + 1
        max_freq = max(max_freq, freq[s[right]])
        
        # Move left IF invalid (not WHILE)
        # Window maintains its size or grows
        if (right - left + 1) - max_freq > k:
            freq[s[left]] -= 1
            left += 1
        
        # No need to track max_len - final window size IS the answer
    
    return len(s) - left  # or right - left + 1 at the end
```

### Visual: Shrinkable vs Non-Shrinkable

```
s = "AABABBA", k = 1

═══════════════════════════════════════════════════════════════
SHRINKABLE:
─────────────────────────────────────────────────────────────

Window sizes over time:
  
  [A] → [AA] → [AAB] → [AABA] → contract to [ABA] → [ABAB] 
  → contract to [BAB] → [BABB] → [BABBA] → contract to [ABBA]
  
  Size: 1 → 2 → 3 → 4 → 3 → 4 → 3 → 4 → 5 → 4
              ↑           ↑           ↑
          contracts   contracts   contracts

═══════════════════════════════════════════════════════════════
NON-SHRINKABLE:
─────────────────────────────────────────────────────────────

Window sizes over time:

  [A] → [AA] → [AAB] → [AABA] → [_ABAB] → [__BABB] → [___ABBA]
  
  Size: 1 → 2 → 3 → 4 → 4 → 4 → 4
  
  Window SLIDES but never shrinks below 4!
  Final size = 4 (answer)
```

---

## 6.5 Pattern 4: Two Separate Windows

### When to Use

When dealing with **non-overlapping** windows or comparing **distant parts** of the array.

### Example: Maximum Sum of Two Non-Overlapping Subarrays

```python
def max_sum_two_no_overlap(nums, firstLen, secondLen):
    """
    LeetCode 1031: Maximum Sum of Two Non-Overlapping Subarrays
    
    Find max sum of two non-overlapping subarrays of lengths
    firstLen and secondLen.
    
    Strategy: Try both orderings (first before second, second before first)
    """
    
    def max_sum_with_order(L, M):
        """
        Find max sum where L-length subarray comes before M-length subarray.
        """
        n = len(nums)
        
        # Prefix sums for O(1) range sum queries
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i + 1] = prefix[i] + nums[i]
        
        def get_sum(i, j):
            """Sum of nums[i:j+1]"""
            return prefix[j + 1] - prefix[i]
        
        # max_L[i] = max sum of L-length subarray ending at or before i
        max_L = [0] * n
        for i in range(L - 1, n):
            curr_sum = get_sum(i - L + 1, i)
            max_L[i] = curr_sum if i == L - 1 else max(max_L[i - 1], curr_sum)
        
        # Find max: max_L[i-1] + M_sum starting at i
        result = 0
        for i in range(L + M - 1, n):
            m_sum = get_sum(i - M + 1, i)
            l_max = max_L[i - M]  # Best L-subarray before M starts
            result = max(result, l_max + m_sum)
        
        return result
    
    # Try both orderings
    return max(
        max_sum_with_order(firstLen, secondLen),
        max_sum_with_order(secondLen, firstLen)
    )
```

### Visual: Two Windows

```
nums = [0, 6, 5, 2, 2, 5, 1, 9, 4], firstLen=1, secondLen=2

═══════════════════════════════════════════════════════════════
Order 1: firstLen(1) BEFORE secondLen(2)
─────────────────────────────────────────────────────────────

  [0]  [6]  [5]  [2]  [2]  [5]  [1]  [9]  [4]
   │         └─────────────────────────────┘
   │                     ↑
   │              secondLen=2 slides here
   │
   └── firstLen=1 must be BEFORE secondLen

Best combination:
  firstLen at [6]:     6
  secondLen at [9,4]: 13
  Total: 19? No, they overlap!

Actually:
  firstLen at [6]:     6
  secondLen at [1,9]: 10
  Total: 16? Still looking...

Best: firstLen=[9], secondLen=[5,2] or similar...

═══════════════════════════════════════════════════════════════
Order 2: secondLen(2) BEFORE firstLen(1)
─────────────────────────────────────────────────────────────

  [0]  [6]  [5]  [2]  [2]  [5]  [1]  [9]  [4]
        └──────────────┘              │
               ↑                      │
         secondLen=2 here        firstLen=1 at [9]

Best: secondLen=[6,5]=11, firstLen=[9]=9
Total: 20 ✓

═══════════════════════════════════════════════════════════════
FINAL: max(Order1, Order2) = 20
```

---

## 6.6 Pattern 5: Nested Windows (Window within Window)

### Example: Number of Subarrays with Bounded Maximum

```python
def num_subarray_bounded_max(nums, left, right):
    """
    LeetCode 795: Number of Subarrays with Bounded Maximum
    
    Count subarrays where max element is in [left, right].
    
    This uses the counting pattern with boundary tracking.
    """
    
    def count_at_most(bound):
        """Count subarrays with max <= bound"""
        count = 0
        current_length = 0
        
        for num in nums:
            if num <= bound:
                current_length += 1
                count += current_length
            else:
                current_length = 0
        
        return count
    
    # Subarrays with max in [left, right]
    # = at_most(right) - at_most(left - 1)
    return count_at_most(right) - count_at_most(left - 1)
```

---

## 6.7 Chapter Summary

```
┌─────────────────────────────────────────────────────────────┐
│              TWO WINDOWS KEY POINTS                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. DUAL DEQUES: For tracking min AND max together          │
│     • Max deque (decreasing) + Min deque (increasing)       │
│     • Both store indices, not values                        │
│     • Contract when max - min > limit                       │
│                                                             │
│  2. DUAL HASHMAPS: For pattern matching                     │
│     • 'need' map for pattern requirements                   │
│     • 'have' map for current window contents                │
│     • Track 'formed' counter for efficiency                 │
│                                                             │
│  3. SHRINKABLE vs NON-SHRINKABLE:                           │
│     • Shrinkable: while invalid() → contract()              │
│     • Non-shrinkable: if invalid() → contract_once()        │
│     • Use non-shrinkable when only max size matters         │
│                                                             │
│  4. SEPARATE WINDOWS:                                       │
│     • For non-overlapping subarray problems                 │
│     • Often combined with prefix sums                       │
│     • May need to try multiple orderings                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 6.8 Practice Problems

| Problem | Pattern | Difficulty |
|---------|---------|------------|
| Longest Subarray with Limit (LC 1438) | Dual Deques | Medium |
| Minimum Window Substring (LC 76) | Dual HashMaps | Hard |
| Longest Repeating Character Replacement (LC 424) | Non-Shrinkable | Medium |
| Max Sum of Two Non-Overlapping Subarrays (LC 1031) | Two Windows | Medium |
| Subarrays with Bounded Maximum (LC 795) | Counting | Medium |
| Sliding Window Median (LC 480) | Two Heaps | Hard |
