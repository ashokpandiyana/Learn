# Chapter 1: Introduction to Sliding Window

## 1.1 What is Sliding Window?

### Definition
The **Sliding Window** technique is an algorithmic pattern that reduces the time complexity of problems involving contiguous sequences (subarrays or substrings) from O(n²) or O(n³) to O(n) by maintaining a "window" that slides over the data structure.

### The Core Idea
Instead of recalculating everything from scratch for each position, we **reuse the computation** from the previous window by:
1. **Adding** the new element entering the window
2. **Removing** the element leaving the window

### Visual Metaphor
Think of it like looking through a train window. As the train moves:
- New scenery enters your view from one side
- Old scenery exits from the other side
- You don't need to "restart" your observation each time

```
Imagine a physical sliding window on an array:

Array: [ 2 | 5 | 1 | 8 | 3 | 9 | 4 ]
        ─────────────────────────────
        
Window of size 3 sliding right:

Step 1:  ┌─────────┐
         │ 2   5   1 │ 8   3   9   4     Sum = 8
         └─────────┘
         
Step 2:      ┌─────────┐
           2 │ 5   1   8 │ 3   9   4     Sum = 8 - 2 + 8 = 14
             └─────────┘
             
Step 3:          ┌─────────┐
           2   5 │ 1   8   3 │ 9   4     Sum = 14 - 5 + 3 = 12
                 └─────────┘
                 
Step 4:              ┌─────────┐
           2   5   1 │ 8   3   9 │ 4     Sum = 12 - 1 + 9 = 20
                     └─────────┘
                     
Step 5:                  ┌─────────┐
           2   5   1   8 │ 3   9   4 │   Sum = 20 - 8 + 4 = 16
                         └─────────┘
```

---

## 1.2 Why Sliding Window? The Efficiency Gain

### The Brute Force Problem

**Problem:** Find the maximum sum of any contiguous subarray of size 3.

```python
# BRUTE FORCE APPROACH - O(n × k)
def max_sum_brute_force(arr, k):
    n = len(arr)
    max_sum = float('-inf')
    
    for i in range(n - k + 1):          # O(n) iterations
        current_sum = 0
        for j in range(i, i + k):        # O(k) for each iteration
            current_sum += arr[j]
        max_sum = max(max_sum, current_sum)
    
    return max_sum

# For each starting position, we recalculate the ENTIRE sum
# This is wasteful!
```

**Visualization of Redundant Work:**
```
Array: [2, 5, 1, 8, 3]   k = 3

Window 1: Calculate 2 + 5 + 1 = 8       (3 additions)
Window 2: Calculate 5 + 1 + 8 = 14      (3 additions) ← 5+1 already computed!
Window 3: Calculate 1 + 8 + 3 = 12      (3 additions) ← 1+8 already computed!

Total: 9 additions for 3 windows
```

### The Sliding Window Solution

```python
# SLIDING WINDOW APPROACH - O(n)
def max_sum_sliding_window(arr, k):
    n = len(arr)
    
    # Calculate sum of first window
    window_sum = sum(arr[:k])
    max_sum = window_sum
    
    # Slide the window
    for i in range(k, n):
        window_sum = window_sum + arr[i] - arr[i - k]
        #                         ^^^^^^   ^^^^^^^^^^
        #                         Add new   Remove old
        max_sum = max(max_sum, window_sum)
    
    return max_sum
```

**Visualization of Optimized Work:**
```
Array: [2, 5, 1, 8, 3]   k = 3

Window 1: Calculate 2 + 5 + 1 = 8       (3 additions - initial)
Window 2: 8 - 2 + 8 = 14                (1 subtraction + 1 addition)
Window 3: 14 - 5 + 3 = 12               (1 subtraction + 1 addition)

Total: 3 + 2 + 2 = 7 operations (and scales as O(n), not O(n×k))
```

### Complexity Comparison

| Approach | Time Complexity | Space Complexity |
|----------|-----------------|------------------|
| Brute Force | O(n × k) | O(1) |
| Sliding Window | O(n) | O(1) |

For n = 1,000,000 and k = 1,000:
- Brute Force: ~1,000,000,000 operations
- Sliding Window: ~1,000,000 operations
- **1000x faster!**

---

## 1.3 When to Use Sliding Window

### Key Indicators (Memorize These!)

Look for these signals in problem statements:

```
┌─────────────────────────────────────────────────────────────┐
│                    SLIDING WINDOW SIGNALS                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. CONTIGUOUS REQUIREMENT                                  │
│     • "subarray" or "substring"                             │
│     • "consecutive elements"                                │
│     • "contiguous sequence"                                 │
│                                                             │
│  2. OPTIMIZATION KEYWORDS                                   │
│     • "maximum" / "minimum"                                 │
│     • "longest" / "shortest"                                │
│     • "largest" / "smallest"                                │
│                                                             │
│  3. CONSTRAINT KEYWORDS                                     │
│     • "of size k" (fixed window)                            │
│     • "with sum equal to"                                   │
│     • "containing at most k distinct"                       │
│     • "without repeating"                                   │
│                                                             │
│  4. COUNTING PATTERNS                                       │
│     • "count all subarrays where..."                        │
│     • "number of substrings with..."                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Decision Tree

```
                    Is the problem about a
                   contiguous sequence/range?
                            │
              ┌─────────────┴─────────────┐
              │                           │
             YES                          NO
              │                           │
              ▼                           ▼
    Does it ask for optimal          Consider other
    (max/min/longest/shortest)       techniques
    or counting subarrays?           (DP, Greedy, etc.)
              │
              ▼
     ┌────────────────┐
     │ SLIDING WINDOW │
     │   is likely    │
     │   applicable   │
     └────────────────┘
              │
              ▼
       Fixed or Variable?
              │
    ┌─────────┴─────────┐
    │                   │
"size k" mentioned    Size depends on
    │                 content/condition
    ▼                       ▼
 FIXED SIZE           VARIABLE SIZE
  WINDOW                WINDOW
```

### Example Problem Recognition

| Problem Statement | Sliding Window? | Type |
|-------------------|-----------------|------|
| "Find max sum subarray of size k" | ✅ Yes | Fixed |
| "Find longest substring without repeating characters" | ✅ Yes | Variable |
| "Find if any two elements in array sum to k" | ❌ No | Two Pointers / Hash |
| "Find minimum window containing all characters" | ✅ Yes | Variable |
| "Find longest increasing subsequence" | ❌ No | DP (not contiguous!) |
| "Maximum of all subarrays of size k" | ✅ Yes | Fixed |

---

## 1.4 Core Concept Deep Dive

### The Window as a Data Structure

Think of the window as maintaining a **state** that can be:
- **Updated incrementally** (not recalculated from scratch)
- **Queried** for the answer at any position

```
┌──────────────────────────────────────────────────────────┐
│                     WINDOW STATE                          │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  The "state" depends on what we're tracking:             │
│                                                          │
│  • Sum problems      → state = running sum               │
│  • Count problems    → state = frequency map/counter     │
│  • Max/Min problems  → state = deque or current max/min  │
│  • Unique problems   → state = set of elements           │
│  • Anagram problems  → state = character frequency map   │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

### The Two Fundamental Operations

Every sliding window implementation has exactly two core operations:

```python
"""
OPERATION 1: EXPAND (Add element to window)
─────────────────────────────────────────────
When: Right pointer moves forward
What: Include new element in window state
"""
def expand(element):
    window_sum += element           # For sum
    frequency[element] += 1         # For counting
    window_set.add(element)         # For uniqueness

"""
OPERATION 2: CONTRACT (Remove element from window)
─────────────────────────────────────────────
When: Left pointer moves forward  
What: Exclude old element from window state
"""
def contract(element):
    window_sum -= element           # For sum
    frequency[element] -= 1         # For counting
    if frequency[element] == 0:
        del frequency[element]
    window_set.remove(element)      # For uniqueness (if no duplicates)
```

### Window Boundaries

```
Array indices:    0    1    2    3    4    5    6
Array values:   [ 4 ][ 2 ][ 1 ][ 7 ][ 8 ][ 3 ][ 6 ]
                      ↑              ↑
                     left          right
                     
Window = arr[left : right + 1] = [2, 1, 7, 8]
Window size = right - left + 1 = 4

┌─────────────────────────────────────────────────────┐
│  CRITICAL FORMULA:                                  │
│                                                     │
│  Window Size = right - left + 1                     │
│                                                     │
│  This is the most common source of off-by-one      │
│  errors! Always remember the "+1"                   │
└─────────────────────────────────────────────────────┘
```

---

## 1.5 Basic Template Structure

### Universal Sliding Window Template

```python
def sliding_window_template(arr):
    """
    Universal template for sliding window problems.
    Customize the marked sections based on the specific problem.
    """
    
    # 1. INITIALIZE
    left = 0
    result = 0  # or float('inf'), float('-inf'), "", etc.
    window_state = ...  # sum, hashmap, set, deque, etc.
    
    # 2. ITERATE with right pointer
    for right in range(len(arr)):
        
        # 3. EXPAND: Add arr[right] to window
        # [CUSTOMIZE THIS SECTION]
        window_state.add(arr[right])
        
        # 4. CONTRACT: Shrink window if needed (for variable window)
        # [CUSTOMIZE THIS CONDITION]
        while window_is_invalid():
            # Remove arr[left] from window
            window_state.remove(arr[left])
            left += 1
        
        # 5. UPDATE RESULT
        # [CUSTOMIZE: might be inside or outside the while loop]
        result = update(result, window_state)
    
    # 6. RETURN
    return result
```

---

## 1.6 Chapter Summary

```
┌─────────────────────────────────────────────────────────────┐
│                    KEY TAKEAWAYS                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ✓ Sliding Window converts O(n²) → O(n) for contiguous     │
│    subarray/substring problems                              │
│                                                             │
│  ✓ Core idea: Reuse computation by adding new element      │
│    and removing old element incrementally                   │
│                                                             │
│  ✓ Look for: "contiguous", "subarray", "substring",        │
│    "maximum", "minimum", "longest", "shortest"              │
│                                                             │
│  ✓ Two types: Fixed-size (k given) and Variable-size       │
│    (size depends on condition)                              │
│                                                             │
│  ✓ Window size formula: right - left + 1                   │
│                                                             │
│  ✓ Every element is processed at most twice:               │
│    once when added (right moves), once when removed         │
│    (left moves)                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Practice Exercise

Before moving to Chapter 2, try to identify which problems can use sliding window:

1. Find the maximum element in an array ❓
2. Find the maximum sum of k consecutive elements ❓
3. Find the longest palindromic substring ❓
4. Find the smallest subarray with sum ≥ target ❓
5. Find pairs that sum to target ❓

<details>
<summary>Click to see answers</summary>

1. ❌ No - Not about subarrays, just finding max
2. ✅ Yes - Fixed window of size k
3. ❌ No - Palindrome needs center expansion, not sliding window
4. ✅ Yes - Variable window with sum condition
5. ❌ No - Pairs aren't contiguous, use Two Pointers or Hash

</details>
