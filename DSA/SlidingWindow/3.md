# Chapter 3: Variable-Size (Dynamic) Sliding Window

## 3.1 Definition and Core Concept

### What is a Variable-Size Window?

A **Variable-Size Sliding Window** has a window that expands or contracts dynamically based on certain conditions. The window size is NOT fixed—it adapts to find optimal solutions.

```
FIXED vs VARIABLE WINDOW:
════════════════════════════════════════════════════════════════

FIXED WINDOW (Chapter 2):
─────────────────────────
    "Find max sum of subarray of SIZE 3"
    
    Window size is predetermined (k=3).
    Both pointers move together.
    
    [■][■][■][ ][ ][ ]     →     [ ][■][■][■][ ][ ]
    └───────┘                        └───────┘
      size=3                           size=3


VARIABLE WINDOW (This Chapter):
───────────────────────────────
    "Find smallest subarray with sum ≥ target"
    
    Window size changes based on content.
    Pointers move independently.
    
    [■][■][ ][ ][ ][ ]     →     [ ][■][■][■][■][ ]
    └───┘                            └─────────┘
    size=2                              size=4
    (maybe too small)                (expanded to meet condition)
```

### The Two-Pointer Nature

Variable-size windows use **two independent pointers**:

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│   LEFT pointer (start of window):                           │
│   • Moves right to CONTRACT the window                      │
│   • Used to shrink when constraint is violated              │
│                                                             │
│   RIGHT pointer (end of window):                            │
│   • Moves right to EXPAND the window                        │
│   • Iterates through every element once                     │
│                                                             │
│                                                             │
│        left                    right                        │
│          ↓                       ↓                          │
│   [ ][ ][■][■][■][■][■][ ][ ][ ]                            │
│          └─────────────┘                                    │
│             WINDOW                                          │
│                                                             │
│   Window = arr[left : right + 1]                            │
│   Size = right - left + 1                                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 3.2 The Expand-Contract Pattern

### Core Algorithm Flow

```
THE EXPAND-CONTRACT CYCLE:
════════════════════════════════════════════════════════════════

    ┌─────────────────┐
    │  Start: left=0  │
    └────────┬────────┘
             │
             ▼
    ┌─────────────────┐     ┌─────────────────────┐
    │ EXPAND: Move    │     │ For each position   │
    │ right pointer   │◄────│ right = 0 to n-1    │
    │ Add arr[right]  │     └─────────────────────┘
    └────────┬────────┘
             │
             ▼
    ┌─────────────────┐
    │ Is window       │
    │ INVALID/need    │
    │ to shrink?      │
    └────────┬────────┘
             │
        ┌────┴────┐
        │         │
       YES        NO
        │         │
        ▼         │
    ┌─────────────┐   │
    │ CONTRACT:   │   │
    │ Remove      │   │
    │ arr[left]   │   │
    │ Move left++ │   │
    └──────┬──────┘   │
           │          │
           └──►───────┤
                      │
                      ▼
              ┌───────────────┐
              │ UPDATE RESULT │
              │ (if valid     │
              │  window)      │
              └───────────────┘
```

### The Critical Question: When to Contract?

```
CONTRACTION CONDITIONS (Problem-Dependent):
════════════════════════════════════════════════════════════════

Problem Type              │ Contract When...
──────────────────────────┼─────────────────────────────────────
Sum ≥ target              │ current_sum >= target (valid!)
                          │ → Contract to find minimum length
──────────────────────────┼─────────────────────────────────────
At most K distinct        │ distinct_count > k (invalid!)
                          │ → Contract until valid again
──────────────────────────┼─────────────────────────────────────
No repeating chars        │ have duplicate (invalid!)
                          │ → Contract until no duplicate
──────────────────────────┼─────────────────────────────────────
Product < target          │ product >= target (invalid!)
                          │ → Contract until valid again
──────────────────────────┼─────────────────────────────────────
```

---

## 3.3 Two Categories: Finding Minimum vs Maximum

### ⚠️ CRITICAL: When to Update Result

This is the **most common source of bugs** in variable window problems!

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  FINDING MINIMUM LENGTH (e.g., smallest subarray)           │
│  ─────────────────────────────────────────────────          │
│  Update result INSIDE the while loop (when window is        │
│  valid/satisfies condition)                                 │
│                                                             │
│  FINDING MAXIMUM LENGTH (e.g., longest substring)           │
│  ─────────────────────────────────────────────────          │
│  Update result OUTSIDE/AFTER the while loop (when           │
│  window just became valid again)                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Template for MINIMUM Length

```python
def find_minimum_length(arr, target):
    """
    Find the MINIMUM/SHORTEST window satisfying a condition.
    
    Examples:
    - Minimum Size Subarray Sum
    - Minimum Window Substring
    - Smallest subarray with sum ≥ target
    """
    left = 0
    current_state = 0  # sum, count, etc.
    min_length = float('inf')  # Start with infinity
    
    for right in range(len(arr)):
        # EXPAND: Add arr[right] to window
        current_state += arr[right]
        
        # CONTRACT while window is VALID (satisfies condition)
        # We want to shrink valid windows to find minimum
        while is_valid(current_state, target):  # e.g., current_state >= target
            # ★ UPDATE HERE - window is valid, might be minimum
            min_length = min(min_length, right - left + 1)
            
            # Remove arr[left] and shrink
            current_state -= arr[left]
            left += 1
    
    return min_length if min_length != float('inf') else 0
```

**Visualization - Finding Minimum:**

```
Problem: Find smallest subarray with sum ≥ 7
Array: [2, 3, 1, 2, 4, 3]

right=0: [2]         sum=2  < 7, not valid, don't update
right=1: [2,3]       sum=5  < 7, not valid
right=2: [2,3,1]     sum=6  < 7, not valid
right=3: [2,3,1,2]   sum=8  ≥ 7, VALID! 
         ★ Update min_length = 4
         Contract: [3,1,2] sum=6 < 7, stop contracting
right=4: [3,1,2,4]   sum=10 ≥ 7, VALID!
         ★ Update min_length = min(4, 4) = 4
         Contract: [1,2,4] sum=7 ≥ 7, VALID!
         ★ Update min_length = min(4, 3) = 3
         Contract: [2,4] sum=6 < 7, stop
right=5: [2,4,3]     sum=9 ≥ 7, VALID!
         ★ Update min_length = min(3, 3) = 3
         Contract: [4,3] sum=7 ≥ 7, VALID!
         ★ Update min_length = min(3, 2) = 2  ← ANSWER!
         Contract: [3] sum=3 < 7, stop

Answer: 2 (subarray [4,3])
```

---

### Template for MAXIMUM Length

```python
def find_maximum_length(arr, k):
    """
    Find the MAXIMUM/LONGEST window satisfying a condition.
    
    Examples:
    - Longest Substring Without Repeating Characters
    - Longest Substring with At Most K Distinct Characters
    - Max Consecutive Ones III
    """
    left = 0
    current_state = {}  # or set, or counter
    max_length = 0  # Start with 0
    
    for right in range(len(arr)):
        # EXPAND: Add arr[right] to window
        add_to_state(arr[right])
        
        # CONTRACT while window is INVALID (violates condition)
        # We want to shrink until valid again
        while is_invalid(current_state, k):  # e.g., distinct > k
            # Remove arr[left] and shrink
            remove_from_state(arr[left])
            left += 1
        
        # ★ UPDATE HERE - window is now valid (after fixing)
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

**Visualization - Finding Maximum:**

```
Problem: Longest substring with at most 2 distinct characters
String: "eceba"

right=0: "e"      distinct={e:1}     count=1 ≤ 2, valid
         ★ Update max_length = 1
right=1: "ec"     distinct={e:1,c:1} count=2 ≤ 2, valid
         ★ Update max_length = 2
right=2: "ece"    distinct={e:2,c:1} count=2 ≤ 2, valid
         ★ Update max_length = 3
right=3: "eceb"   distinct={e:2,c:1,b:1} count=3 > 2, INVALID!
         Contract: remove 'e' → {e:1,c:1,b:1} count=3, still invalid
         Contract: remove 'c' → {e:1,b:1} count=2 ≤ 2, valid!
         Window is now "eb"
         ★ Update max_length = max(3, 2) = 3
right=4: "eba"    distinct={e:1,b:1,a:1} count=3 > 2, INVALID!
         Contract: remove 'e' → {b:1,a:1} count=2 ≤ 2, valid!
         Window is now "ba"
         ★ Update max_length = max(3, 2) = 3

Answer: 3 (substring "ece")
```

---

## 3.4 Detailed Examples

### Example 1: Longest Substring Without Repeating Characters

**Problem:** Given a string, find the length of the longest substring without repeating characters.

```python
def length_of_longest_substring(s):
    """
    LeetCode 3: Longest Substring Without Repeating Characters
    
    Example: "abcabcbb" → 3 ("abc")
             "bbbbb" → 1 ("b")
             "pwwkew" → 3 ("wke")
    
    Type: Find MAXIMUM → Update AFTER contraction
    Invalid condition: duplicate character exists
    """
    char_index = {}  # Character -> its most recent index
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        char = s[right]
        
        # If char exists in window, move left past its previous position
        if char in char_index and char_index[char] >= left:
            left = char_index[char] + 1
        
        # Update the character's latest position
        char_index[char] = right
        
        # Update result (window is always valid after adjustment)
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

**Alternative using Set (more intuitive):**

```python
def length_of_longest_substring_v2(s):
    """
    Using a set to track characters in current window.
    """
    char_set = set()
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        # CONTRACT while we have a duplicate
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        
        # EXPAND: add current character
        char_set.add(s[right])
        
        # UPDATE: window is valid
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

**Step-by-Step Trace:**

```
String: "abcabcbb"

right=0 (a): set={a}, left=0, window="a", len=1, max=1
right=1 (b): set={a,b}, left=0, window="ab", len=2, max=2
right=2 (c): set={a,b,c}, left=0, window="abc", len=3, max=3
right=3 (a): 'a' in set! Contract:
             remove s[0]='a', left=1, set={b,c}
             Now 'a' not in set
             Add 'a': set={b,c,a}, window="bca", len=3, max=3
right=4 (b): 'b' in set! Contract:
             remove s[1]='b', left=2, set={c,a}
             Now 'b' not in set
             Add 'b': set={c,a,b}, window="cab", len=3, max=3
right=5 (c): 'c' in set! Contract:
             remove s[2]='c', left=3, set={a,b}
             Now 'c' not in set
             Add 'c': set={a,b,c}, window="abc", len=3, max=3
right=6 (b): 'b' in set! Contract:
             remove s[3]='a', left=4, set={b,c}
             'b' still in set!
             remove s[4]='b', left=5, set={c}
             Now 'b' not in set
             Add 'b': set={c,b}, window="cb", len=2, max=3
right=7 (b): 'b' in set! Contract:
             remove s[5]='c', left=6, set={b}
             'b' still in set!
             remove s[6]='b', left=7, set={}
             Now 'b' not in set
             Add 'b': set={b}, window="b", len=1, max=3

Answer: 3
```

---

### Example 2: Minimum Size Subarray Sum

**Problem:** Find the minimal length of a contiguous subarray of which the sum ≥ target.

```python
def min_subarray_len(target, nums):
    """
    LeetCode 209: Minimum Size Subarray Sum
    
    Example: target=7, nums=[2,3,1,2,4,3] → 2 ([4,3])
    
    Type: Find MINIMUM → Update INSIDE contraction loop
    Valid condition: sum >= target
    """
    left = 0
    current_sum = 0
    min_length = float('inf')
    
    for right in range(len(nums)):
        # EXPAND
        current_sum += nums[right]
        
        # CONTRACT while VALID (trying to minimize)
        while current_sum >= target:
            # UPDATE inside - this is a valid window
            min_length = min(min_length, right - left + 1)
            
            # Shrink
            current_sum -= nums[left]
            left += 1
    
    return min_length if min_length != float('inf') else 0
```

**Visual Trace:**

```
target = 7, nums = [2, 3, 1, 2, 4, 3]

┌─────────────────────────────────────────────────────────────┐
│ right=0: sum=2                                              │
│ [2] 3  1  2  4  3     sum=2 < 7, not valid                  │
│  └┘                                                         │
├─────────────────────────────────────────────────────────────┤
│ right=1: sum=5                                              │
│ [2  3] 1  2  4  3     sum=5 < 7, not valid                  │
│  └──┘                                                       │
├─────────────────────────────────────────────────────────────┤
│ right=2: sum=6                                              │
│ [2  3  1] 2  4  3     sum=6 < 7, not valid                  │
│  └─────┘                                                    │
├─────────────────────────────────────────────────────────────┤
│ right=3: sum=8                                              │
│ [2  3  1  2] 4  3     sum=8 ≥ 7 ✓ min_len=4                 │
│  └────────┘           CONTRACT: remove 2, sum=6             │
│    [3  1  2] 4  3     sum=6 < 7, stop                       │
│     └─────┘                                                 │
├─────────────────────────────────────────────────────────────┤
│ right=4: sum=10                                             │
│     [3  1  2  4] 3    sum=10 ≥ 7 ✓ min_len=4                │
│      └────────┘       CONTRACT: remove 3, sum=7             │
│        [1  2  4] 3    sum=7 ≥ 7 ✓ min_len=3                 │
│         └─────┘       CONTRACT: remove 1, sum=6             │
│           [2  4] 3    sum=6 < 7, stop                       │
│            └───┘                                            │
├─────────────────────────────────────────────────────────────┤
│ right=5: sum=9                                              │
│           [2  4  3]   sum=9 ≥ 7 ✓ min_len=3                 │
│            └──────┘   CONTRACT: remove 2, sum=7             │
│              [4  3]   sum=7 ≥ 7 ✓ min_len=2 ← ANSWER        │
│               └───┘   CONTRACT: remove 4, sum=3             │
│                 [3]   sum=3 < 7, stop                       │
│                  └┘                                         │
└─────────────────────────────────────────────────────────────┘

Answer: 2
```

---

### Example 3: Longest Substring with At Most K Distinct Characters

**Problem:** Find the length of the longest substring with at most K distinct characters.

```python
from collections import defaultdict

def longest_substring_k_distinct(s, k):
    """
    LeetCode 340: Longest Substring with At Most K Distinct Characters
    
    Example: s="eceba", k=2 → 3 ("ece")
    
    Type: Find MAXIMUM → Update AFTER contraction
    Invalid condition: distinct count > k
    """
    if k == 0:
        return 0
    
    char_count = defaultdict(int)
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        # EXPAND: add character
        char_count[s[right]] += 1
        
        # CONTRACT while INVALID (more than k distinct)
        while len(char_count) > k:
            char_count[s[left]] -= 1
            if char_count[s[left]] == 0:
                del char_count[s[left]]  # Important: cleanup!
            left += 1
        
        # UPDATE: window is valid now
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

**Key Insight - HashMap Cleanup:**

```
┌─────────────────────────────────────────────────────────────┐
│  ⚠️ CRITICAL: DELETE keys when count becomes 0!             │
│                                                             │
│  WRONG:                                                     │
│  char_count[s[left]] -= 1                                   │
│  left += 1                                                  │
│  # len(char_count) is still same even if count is 0!        │
│                                                             │
│  CORRECT:                                                   │
│  char_count[s[left]] -= 1                                   │
│  if char_count[s[left]] == 0:                               │
│      del char_count[s[left]]  # Remove key entirely         │
│  left += 1                                                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### Example 4: Max Consecutive Ones III

**Problem:** Given a binary array, you can flip at most K 0s. Find the longest contiguous subarray of 1s.

```python
def longest_ones(nums, k):
    """
    LeetCode 1004: Max Consecutive Ones III
    
    Example: nums=[1,1,1,0,0,0,1,1,1,1,0], k=2 → 6
             We can flip two 0s to get [1,1,1,0,0,1,1,1,1,1,1]
                                              ↑           ↑
                                            these two 0s flipped
    
    Reframe: Find longest subarray with at most K zeros
    
    Type: Find MAXIMUM → Update AFTER contraction
    """
    left = 0
    zero_count = 0
    max_length = 0
    
    for right in range(len(nums)):
        # EXPAND
        if nums[right] == 0:
            zero_count += 1
        
        # CONTRACT while INVALID (too many zeros)
        while zero_count > k:
            if nums[left] == 0:
                zero_count -= 1
            left += 1
        
        # UPDATE
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

**Reframing Problems:**

```
┌─────────────────────────────────────────────────────────────┐
│               REFRAMING TECHNIQUE                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Original: "Flip at most K zeros to maximize consecutive 1s"│
│                                                             │
│  Reframed: "Find longest subarray with at most K zeros"     │
│                                                             │
│  This reframing turns a modification problem into a         │
│  standard sliding window problem!                           │
│                                                             │
│  Similar reframes:                                          │
│  • "Replace at most K chars" → "At most K different chars"  │
│  • "Delete at most K elements" → "Allow K violations"       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 3.5 The Two-Pointer Guarantee

### Why O(n) Complexity?

```
TIME COMPLEXITY PROOF:
════════════════════════════════════════════════════════════════

Each element is:
  • Added to window exactly ONCE (when right pointer reaches it)
  • Removed from window at most ONCE (when left pointer passes it)

Therefore:
  • Total additions: n
  • Total removals: at most n
  • Total operations: at most 2n = O(n)

VISUAL:

Index:  0   1   2   3   4   5   6   7
Array: [a] [b] [c] [d] [e] [f] [g] [h]
        ↑                           ↑
       left                       right
       
- Right pointer: visits each index exactly once (0→7)
- Left pointer: only moves forward, visits each index at most once
- No pointer ever moves backward!

This is why we use "while" not "if" for contraction:
- The while loop might run multiple times per right iteration
- But total left movements across ALL iterations ≤ n
```

---

## 3.6 Common Mistakes and How to Avoid Them

### Mistake 1: Wrong Update Timing

```python
# ❌ WRONG for finding MINIMUM
for right in range(n):
    current_sum += nums[right]
    while current_sum >= target:
        current_sum -= nums[left]
        left += 1
    min_length = min(min_length, right - left + 1)  # Wrong place!

# ✅ CORRECT for finding MINIMUM
for right in range(n):
    current_sum += nums[right]
    while current_sum >= target:
        min_length = min(min_length, right - left + 1)  # Update INSIDE
        current_sum -= nums[left]
        left += 1
```

### Mistake 2: Not Cleaning Up HashMap

```python
# ❌ WRONG
freq[s[left]] -= 1
left += 1
# len(freq) stays the same even when count is 0!

# ✅ CORRECT
freq[s[left]] -= 1
if freq[s[left]] == 0:
    del freq[s[left]]
left += 1
```

### Mistake 3: Off-by-One in Window Size

```python
# ❌ WRONG
window_size = right - left  # Missing +1!

# ✅ CORRECT
window_size = right - left + 1
```

### Mistake 4: Infinite Loop

```python
# ❌ WRONG - might never terminate if left isn't moved
while current_sum >= target:
    min_length = min(min_length, right - left + 1)
    # Forgot to move left pointer!

# ✅ CORRECT
while current_sum >= target:
    min_length = min(min_length, right - left + 1)
    current_sum -= nums[left]
    left += 1  # Always move left inside while loop
```

---

## 3.7 Decision Flowchart

```
VARIABLE WINDOW PROBLEM DECISION TREE:
════════════════════════════════════════════════════════════════

                    Problem Type?
                         │
         ┌───────────────┴───────────────┐
         │                               │
    Find MINIMUM                    Find MAXIMUM
    (shortest, smallest)            (longest, largest)
         │                               │
         ▼                               ▼
┌─────────────────────┐      ┌─────────────────────┐
│ Contract when VALID │      │ Contract when       │
│ (condition met)     │      │ INVALID (condition  │
│                     │      │ violated)           │
│ Update INSIDE while │      │ Update OUTSIDE/     │
│                     │      │ AFTER while         │
└─────────────────────┘      └─────────────────────┘
         │                               │
         ▼                               ▼
    while valid():                while invalid():
        update_min()                  contract()
        contract()                update_max()
```

---

## 3.8 Chapter Summary

```
┌─────────────────────────────────────────────────────────────┐
│            VARIABLE-SIZE WINDOW KEY POINTS                   │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ✓ Window size ADAPTS based on conditions                   │
│                                                             │
│  ✓ Two independent pointers: left (contract), right(expand) │
│                                                             │
│  ✓ Core pattern: EXPAND → CHECK → CONTRACT → UPDATE         │
│                                                             │
│  ✓ MINIMUM problems: Update result INSIDE while loop        │
│    (while window is valid)                                  │
│                                                             │
│  ✓ MAXIMUM problems: Update result AFTER while loop         │
│    (after window becomes valid again)                       │
│                                                             │
│  ✓ Time Complexity: O(n) - each element processed ≤ twice   │
│                                                             │
│  ✓ Always cleanup hashmap when count reaches 0              │
│                                                             │
│  ✓ Window size = right - left + 1 (don't forget +1!)        │
│                                                             │
│  ✓ Reframe modification problems as counting problems       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Practice Problems by Difficulty

### Easy-Medium
1. **Longest Substring Without Repeating Characters** (LC 3)
2. **Minimum Size Subarray Sum** (LC 209)
3. **Max Consecutive Ones III** (LC 1004)
4. **Fruit Into Baskets** (LC 904)
5. **Longest Repeating Character Replacement** (LC 424)

### Medium-Hard
6. **Longest Substring with At Most K Distinct Characters** (LC 340)
7. **Permutation in String** (LC 567)
8. **Find All Anagrams in a String** (LC 438)
9. **Subarray Product Less Than K** (LC 713)

### Hard
10. **Minimum Window Substring** (LC 76)
11. **Subarrays with K Different Integers** (LC 992)
12. **Substring with Concatenation of All Words** (LC 30)
