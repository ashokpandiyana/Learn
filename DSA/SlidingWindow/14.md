# Chapter 14: Quick Reference & Templates

## 14.1 Core Templates

### Template 1: Fixed-Size Window

```python
def fixed_window(arr, k):
    """
    Fixed-size sliding window template.
    Use for: max/min sum of k elements, anagrams, etc.
    Time: O(n), Space: O(1) or O(k)
    """
    n = len(arr)
    if k > n:
        return None  # Handle edge case
    
    # PHASE 1: Build first window [0, k-1]
    window_state = 0
    for i in range(k):
        window_state += arr[i]  # or other operation
    
    result = window_state
    
    # PHASE 2: Slide window [k, n-1]
    for i in range(k, n):
        window_state += arr[i]      # Add new element
        window_state -= arr[i - k]  # Remove old element
        result = max(result, window_state)
    
    return result
```

### Template 2: Variable Window - Find Maximum

```python
def variable_window_max(arr, k):
    """
    Variable window for finding MAXIMUM length.
    Use for: longest substring with condition
    Time: O(n), Space: O(1) or O(k)
    """
    left = 0
    max_length = 0
    state = {}  # or other structure
    
    for right in range(len(arr)):
        # EXPAND: Add arr[right]
        state[arr[right]] = state.get(arr[right], 0) + 1
        
        # CONTRACT: while INVALID
        while is_invalid(state, k):
            state[arr[left]] -= 1
            if state[arr[left]] == 0:
                del state[arr[left]]
            left += 1
        
        # UPDATE: After fixing (window is valid)
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

### Template 3: Variable Window - Find Minimum

```python
def variable_window_min(arr, target):
    """
    Variable window for finding MINIMUM length.
    Use for: shortest subarray with condition
    Time: O(n), Space: O(1)
    """
    left = 0
    min_length = float('inf')
    current_sum = 0
    
    for right in range(len(arr)):
        # EXPAND: Add arr[right]
        current_sum += arr[right]
        
        # CONTRACT: while VALID (try to minimize)
        while current_sum >= target:
            min_length = min(min_length, right - left + 1)
            current_sum -= arr[left]
            left += 1
    
    return min_length if min_length != float('inf') else 0
```

### Template 4: Counting - At Most K

```python
def at_most_k(arr, k):
    """
    Count subarrays with at most K [something].
    Use for: counting problems
    Time: O(n), Space: O(k)
    """
    from collections import defaultdict
    
    freq = defaultdict(int)
    left = 0
    count = 0
    
    for right in range(len(arr)):
        freq[arr[right]] += 1
        
        while len(freq) > k:  # More than K distinct
            freq[arr[left]] -= 1
            if freq[arr[left]] == 0:
                del freq[arr[left]]
            left += 1
        
        # Count all subarrays ending at right
        count += right - left + 1
    
    return count


def exactly_k(arr, k):
    """Exactly K = At Most K - At Most K-1"""
    return at_most_k(arr, k) - at_most_k(arr, k - 1)
```

### Template 5: Minimum Window Substring

```python
def min_window(s, t):
    """
    Minimum window containing all characters of t.
    Use for: minimum window substring problems
    Time: O(n), Space: O(k)
    """
    from collections import Counter, defaultdict
    
    need = Counter(t)
    have = defaultdict(int)
    required = len(need)
    formed = 0
    
    left = 0
    min_len = float('inf')
    result = ""
    
    for right in range(len(s)):
        char = s[right]
        have[char] += 1
        
        if char in need and have[char] == need[char]:
            formed += 1
        
        while formed == required:
            if right - left + 1 < min_len:
                min_len = right - left + 1
                result = s[left:right + 1]
            
            left_char = s[left]
            have[left_char] -= 1
            if left_char in need and have[left_char] < need[left_char]:
                formed -= 1
            left += 1
    
    return result
```

### Template 6: Sliding Window Maximum (Monotonic Deque)

```python
from collections import deque

def sliding_window_maximum(nums, k):
    """
    Maximum element in each window of size k.
    Time: O(n), Space: O(k)
    """
    dq = deque()  # Stores indices, decreasing values
    result = []
    
    for i in range(len(nums)):
        # Remove indices outside window
        while dq and dq[0] <= i - k:
            dq.popleft()
        
        # Maintain decreasing order
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        
        dq.append(i)
        
        # Record result after first window
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result
```

### Template 7: Prefix Sum with HashMap

```python
def subarray_sum_equals_k(nums, k):
    """
    Count subarrays with sum exactly k (handles negatives).
    Time: O(n), Space: O(n)
    """
    prefix_sum = 0
    count = 0
    prefix_count = {0: 1}  # Important initialization!
    
    for num in nums:
        prefix_sum += num
        
        if prefix_sum - k in prefix_count:
            count += prefix_count[prefix_sum - k]
        
        prefix_count[prefix_sum] = prefix_count.get(prefix_sum, 0) + 1
    
    return count
```

---

## 14.2 Data Structure Operations

### HashMap for Frequency

```python
from collections import defaultdict

# ADD element to window
freq[element] += 1
if freq[element] == 1:
    distinct_count += 1  # New element

# REMOVE element from window
freq[element] -= 1
if freq[element] == 0:
    del freq[element]  # MUST delete!
    distinct_count -= 1
```

### Monotonic Deque for Max/Min

```python
from collections import deque

# FOR MAXIMUM (decreasing deque)
while dq and nums[dq[-1]] < nums[i]:  # Remove smaller
    dq.pop()
dq.append(i)
max_val = nums[dq[0]]

# FOR MINIMUM (increasing deque)
while dq and nums[dq[-1]] > nums[i]:  # Remove larger
    dq.pop()
dq.append(i)
min_val = nums[dq[0]]

# REMOVE outside window
while dq and dq[0] <= i - k:
    dq.popleft()
```

### HashSet for Uniqueness

```python
# ADD element
if element in window_set:
    # Duplicate found!
window_set.add(element)

# REMOVE element
window_set.remove(element)  # or discard()
```

---

## 14.3 Quick Reference Tables

### When to Use Which Pattern

| Problem Type | Pattern | Key Indicator |
|-------------|---------|---------------|
| Max sum of k elements | Fixed Window | "size k", "exactly k" |
| Longest substring with condition | Variable Window | "longest", "maximum length" |
| Shortest subarray with condition | Variable Window | "shortest", "minimum length" |
| Count subarrays with property | Counting Pattern | "count", "number of" |
| Subarray sum = k (with negatives) | Prefix Sum | Negative numbers, exact sum |
| Max/min in each window | Monotonic Deque | "maximum of all windows" |
| Pattern matching (anagram) | Fixed Window + HashMap | "anagram", "permutation" |
| Contains all characters | Have/Need Pattern | "containing all", "minimum window" |

### Complexity Reference

| Pattern | Time | Space | Notes |
|---------|------|-------|-------|
| Fixed Window | O(n) | O(1) | Or O(k) with hashmap |
| Variable Window | O(n) | O(k) | Each element visited ‚â§ 2 times |
| Monotonic Deque | O(n) | O(k) | Each element pushed/popped once |
| Prefix Sum + HashMap | O(n) | O(n) | For negative numbers |
| Exactly K (via At Most) | O(n) | O(k) | Two passes of at_most |

### Common Edge Cases

| Edge Case | How to Handle |
|-----------|---------------|
| Empty array | Return 0, "", or [] |
| k > array length | Return special value or entire array |
| k = 0 | Usually return 0 or empty |
| All elements same | Should still work correctly |
| No valid window | Return -1, 0, or "" |
| Single element | Should work as window of size 1 |
| Negative numbers | Consider prefix sum approach |

---

## 14.4 Code Snippets Library

### Window Size Calculation
```python
window_size = right - left + 1  # Always +1!
```

### HashMap Cleanup
```python
freq[char] -= 1
if freq[char] == 0:
    del freq[char]
```

### Result Initialization
```python
# For MINIMUM
min_result = float('inf')

# For MAXIMUM  
max_result = 0  # or float('-inf') if negatives possible

# For COUNTING
count = 0

# For STRING
result = ""
result_left, result_right = 0, 0
```

### Shrinkable vs Non-Shrinkable
```python
# SHRINKABLE (for min, count, or all windows)
while invalid():
    left += 1

# NON-SHRINKABLE (for max only)
if invalid():
    left += 1
```

### Anagram Matching
```python
# O(26) comparison
if s_count == p_count:
    found_anagram()

# O(1) comparison with matches
if matches == 26:
    found_anagram()
```

---

## 14.5 Problem Categories Checklist

### Easy Problems
- [ ] Maximum Sum Subarray of Size K
- [ ] Average of Subarrays of Size K  
- [ ] Contains Duplicate II (LC 219)
- [ ] Maximum Average Subarray I (LC 643)

### Medium Problems
- [ ] Longest Substring Without Repeating (LC 3)
- [ ] Longest Repeating Character Replacement (LC 424)
- [ ] Max Consecutive Ones III (LC 1004)
- [ ] Permutation in String (LC 567)
- [ ] Find All Anagrams (LC 438)
- [ ] Fruit Into Baskets (LC 904)
- [ ] Subarray Product Less Than K (LC 713)
- [ ] Minimum Size Subarray Sum (LC 209)
- [ ] Subarray Sum Equals K (LC 560)
- [ ] Maximum Sum Circular Subarray (LC 918)

### Hard Problems
- [ ] Minimum Window Substring (LC 76)
- [ ] Sliding Window Maximum (LC 239)
- [ ] Subarrays with K Different Integers (LC 992)
- [ ] Shortest Subarray with Sum ‚â• K (LC 862)
- [ ] Substring with Concatenation (LC 30)
- [ ] Minimum Window Subsequence (LC 727)
- [ ] Count Subarrays With Fixed Bounds (LC 2444)

---

## 14.6 Formula Cheat Sheet

```
ESSENTIAL FORMULAS:
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

WINDOW SIZE:
  size = right - left + 1

ELEMENT TO REMOVE (fixed window):
  remove_index = i - k

SUBARRAYS ENDING AT RIGHT:
  count = right - left + 1

EXACTLY K:
  exactly(k) = atMost(k) - atMost(k-1)

PREFIX SUM:
  sum(arr[i:j]) = prefix[j] - prefix[i]

CIRCULAR MAX:
  max_circular = total - min_subarray

DIVISIBILITY:
  (prefix[j] - prefix[i]) % k == 0
  ‚ü∫ prefix[j] % k == prefix[i] % k

CHARACTERS TO REPLACE:
  replace_count = window_size - max_frequency

VALID WINDOW (char replacement):
  window_size - max_freq <= k
```

---

## 14.7 Interview Quick Reference Card

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              SLIDING WINDOW INTERVIEW CARD                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                             ‚îÇ
‚îÇ  IDENTIFY:                                                  ‚îÇ
‚îÇ  ‚ñ° "contiguous" ‚ñ° "subarray" ‚ñ° "substring"                  ‚îÇ
‚îÇ  ‚ñ° "longest" ‚ñ° "shortest" ‚ñ° "maximum" ‚ñ° "minimum"           ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  CLASSIFY:                                                  ‚îÇ
‚îÇ  ‚ñ° Fixed (size k given) ‚Üí Two-phase approach                ‚îÇ
‚îÇ  ‚ñ° Variable ‚Üí Expand/Contract pattern                       ‚îÇ
‚îÇ  ‚ñ° Has negatives ‚Üí Use prefix sum                           ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  TEMPLATE CHOICE:                                           ‚îÇ
‚îÇ  ‚ñ° Max length ‚Üí while invalid, update after                 ‚îÇ
‚îÇ  ‚ñ° Min length ‚Üí while valid, update inside                  ‚îÇ
‚îÇ  ‚ñ° Counting ‚Üí at_most(k) - at_most(k-1)                     ‚îÇ
‚îÇ  ‚ñ° Max element ‚Üí monotonic deque                            ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  DON'T FORGET:                                              ‚îÇ
‚îÇ  ‚ñ° Window size = right - left + 1                           ‚îÇ
‚îÇ  ‚ñ° Delete from map when count = 0                           ‚îÇ
‚îÇ  ‚ñ° Initialize prefix_count = {0: 1}                         ‚îÇ
‚îÇ  ‚ñ° Handle edge cases first                                  ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  COMPLEXITY:                                                ‚îÇ
‚îÇ  ‚ñ° Time: O(n) - each element processed ‚â§ 2 times            ‚îÇ
‚îÇ  ‚ñ° Space: O(1) to O(n) depending on structure               ‚îÇ
‚îÇ                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 14.8 Final Summary: The Golden Rules

```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë              THE 10 GOLDEN RULES OF SLIDING WINDOW           ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                             ‚ïë
‚ïë  1. Every element is processed at most TWICE                ‚ïë
‚ïë     (once added, once removed)                              ‚ïë
‚ïë                                                             ‚ïë
‚ïë  2. Window size = right - left + 1 (never forget +1!)       ‚ïë
‚ïë                                                             ‚ïë
‚ïë  3. For MINIMUM: update result INSIDE while loop            ‚ïë
‚ïë     For MAXIMUM: update result OUTSIDE while loop           ‚ïë
‚ïë                                                             ‚ïë
‚ïë  4. ALWAYS delete from HashMap when count becomes 0         ‚ïë
‚ïë                                                             ‚ïë
‚ïë  5. EXACTLY K = AT_MOST(K) - AT_MOST(K-1)                   ‚ïë
‚ïë                                                             ‚ïë
‚ïë  6. Negative numbers? ‚Üí Consider PREFIX SUM                 ‚ïë
‚ïë                                                             ‚ïë
‚ïë  7. Max/Min in window? ‚Üí Use MONOTONIC DEQUE                ‚ïë
‚ïë                                                             ‚ïë
‚ïë  8. Store INDICES in deque (not values) to check bounds     ‚ïë
‚ïë                                                             ‚ïë
‚ïë  9. Non-shrinkable only works for MAXIMUM problems          ‚ïë
‚ïë                                                             ‚ïë
‚ïë  10. When stuck, ask: "What makes this window invalid?"     ‚ïë
‚ïë                                                             ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

---

## 14.9 Your Learning Path

```
RECOMMENDED STUDY ORDER:
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

WEEK 1: Foundations
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚ñ° Chapter 1-2: Basics + Fixed Window
‚ñ° Solve: 3 easy fixed window problems
‚ñ° Master: The two-phase approach

WEEK 2: Variable Windows
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚ñ° Chapter 3-4: Variable Window + State Management
‚ñ° Solve: 5 medium variable window problems
‚ñ° Master: Expand/Contract pattern

WEEK 3: Advanced Patterns
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚ñ° Chapter 5-6: Counting + Two Windows
‚ñ° Solve: "Exactly K" and "Have/Need" problems
‚ñ° Master: at_most(k) - at_most(k-1)

WEEK 4: Specialized Techniques
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚ñ° Chapter 7-10: Binary Search, Strings, Min Window
‚ñ° Solve: Hard problems (LC 76, 239, 862)
‚ñ° Master: Monotonic deque, shrinkable vs non-shrinkable

WEEK 5: Integration
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚ñ° Chapter 11-14: Prefix Sum, Circular, Framework
‚ñ° Solve: Mixed problems without hints
‚ñ° Master: Pattern recognition and debugging

FINAL: Mock Interviews
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚ñ° Time yourself: 20-25 minutes per problem
‚ñ° Practice explaining your approach
‚ñ° Review and optimize solutions
```

---

*"The sliding window technique is a lens through which O(n¬≤) problems become O(n). Master it, and you'll see solutions where others see complexity."*

**Congratulations on completing the Sliding Window Mastery Guide!** üéâ
