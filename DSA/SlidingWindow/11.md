# Chapter 11: Sliding Window with Prefix Sum

## 11.1 Introduction: Two Powerful Techniques Combined

### Why Combine Prefix Sum with Sliding Window?

```
WHEN STANDARD SLIDING WINDOW ISN'T ENOUGH:
════════════════════════════════════════════════════════════════

Standard sliding window works when:
✓ All elements are positive (or all negative)
✓ Window property changes monotonically as we expand/contract

Standard sliding window FAILS when:
✗ Array contains NEGATIVE numbers
✗ Need to find subarrays with EXACT sum
✗ Window expansion doesn't guarantee improvement

EXAMPLE OF FAILURE:
───────────────────────────────────────────────────────────────
Array: [1, -2, 3, -1, 2], target sum = 3

With negatives, expanding window might DECREASE sum!
[1] → sum=1
[1,-2] → sum=-1  (decreased!)
[1,-2,3] → sum=2
[1,-2,3,-1] → sum=1  (decreased again!)

Can't use simple expand/contract logic.
Solution: PREFIX SUM!
```

### What is Prefix Sum?

```
PREFIX SUM CONCEPT:
════════════════════════════════════════════════════════════════

prefix[i] = sum of all elements from index 0 to i-1

Array:     [3,  1,  2,  4,  1]
            0   1   2   3   4

Prefix:  [0, 3,  4,  6, 10, 11]
          0  1   2   3   4   5
          ↑
       prefix[0] = 0 (empty sum)

prefix[0] = 0
prefix[1] = 3         = arr[0]
prefix[2] = 3+1 = 4   = arr[0] + arr[1]
prefix[3] = 4+2 = 6   = arr[0] + arr[1] + arr[2]
...

KEY FORMULA:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  sum(arr[i:j+1]) = prefix[j+1] - prefix[i]                  │
│                                                             │
│  Sum of subarray from index i to j (inclusive)              │
│  = prefix at end - prefix at start                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘

Example: sum(arr[1:3]) = sum([1,2,4]) 
       = prefix[4] - prefix[1] 
       = 10 - 3 = 7 ✓
```

---

## 11.2 Pattern 1: Subarray Sum Equals K

### The Problem

Standard sliding window can't solve "subarray sum equals K" with negative numbers. But prefix sum + hashmap can!

```
THE INSIGHT:
════════════════════════════════════════════════════════════════

We want: sum(arr[i:j]) = k
Using prefix sum: prefix[j] - prefix[i] = k
Rearranging: prefix[i] = prefix[j] - k

At each position j:
  • Calculate current prefix sum
  • Look for a previous prefix that equals (current - k)
  • If found, we have a subarray with sum = k!

This transforms the problem:
  FROM: "Find subarray with sum k"
  TO:   "Find two prefix sums that differ by k"
```

### Implementation

```python
def subarray_sum_equals_k(nums, k):
    """
    LeetCode 560: Subarray Sum Equals K
    
    Count subarrays with sum exactly equal to k.
    Works with NEGATIVE numbers!
    
    Time: O(n)
    Space: O(n)
    """
    prefix_sum = 0
    count = 0
    
    # Map: prefix_sum → how many times we've seen it
    prefix_count = {0: 1}  # Empty prefix has sum 0
    
    for num in nums:
        prefix_sum += num
        
        # If (prefix_sum - k) exists, we found subarray(s) with sum k
        target = prefix_sum - k
        if target in prefix_count:
            count += prefix_count[target]
        
        # Record current prefix sum
        prefix_count[prefix_sum] = prefix_count.get(prefix_sum, 0) + 1
    
    return count
```

### Visual Walkthrough

```
nums = [1, 2, 3, -2, 2], k = 4

═══════════════════════════════════════════════════════════════
BUILDING PREFIX SUMS AND COUNTING:
═══════════════════════════════════════════════════════════════

Initial: prefix_count = {0: 1}, prefix_sum = 0, count = 0

───────────────────────────────────────────────────────────────
i=0, num=1
───────────────────────────────────────────────────────────────
  [1]  2   3  -2   2
   ↑
  prefix_sum = 0 + 1 = 1
  target = 1 - 4 = -3
  
  -3 in prefix_count? NO
  
  prefix_count = {0: 1, 1: 1}
  count = 0

───────────────────────────────────────────────────────────────
i=1, num=2
───────────────────────────────────────────────────────────────
  [1   2]  3  -2   2
       ↑
  prefix_sum = 1 + 2 = 3
  target = 3 - 4 = -1
  
  -1 in prefix_count? NO
  
  prefix_count = {0: 1, 1: 1, 3: 1}
  count = 0

───────────────────────────────────────────────────────────────
i=2, num=3
───────────────────────────────────────────────────────────────
  [1   2   3] -2   2
           ↑
  prefix_sum = 3 + 3 = 6
  target = 6 - 4 = 2
  
  2 in prefix_count? NO
  
  prefix_count = {0: 1, 1: 1, 3: 1, 6: 1}
  count = 0

───────────────────────────────────────────────────────────────
i=3, num=-2
───────────────────────────────────────────────────────────────
  [1   2   3  -2]  2
               ↑
  prefix_sum = 6 + (-2) = 4
  target = 4 - 4 = 0
  
  0 in prefix_count? YES! count = 1
  
  ┌─────────────────────────────────────────────────────────┐
  │ Found subarray: prefix[4] - prefix[0] = 4 - 0 = 4      │
  │ Subarray: nums[0:4] = [1, 2, 3, -2] ✓                  │
  └─────────────────────────────────────────────────────────┘
  
  prefix_count = {0: 1, 1: 1, 3: 1, 6: 1, 4: 1}
  count = 1

───────────────────────────────────────────────────────────────
i=4, num=2
───────────────────────────────────────────────────────────────
  [1   2   3  -2   2]
                   ↑
  prefix_sum = 4 + 2 = 6
  target = 6 - 4 = 2
  
  2 in prefix_count? NO
  
  But wait! prefix_sum=6 already exists with count 1
  prefix_count = {0: 1, 1: 1, 3: 1, 6: 2, 4: 1}
  count = 1

───────────────────────────────────────────────────────────────
FINAL: count = 1

But let's verify all subarrays with sum 4:
[1,2,3,-2] = 4 ✓ (found)
[1,3] → not contiguous
[2,3,-2,2] = 5 ✗
[3,-2,2] = 3 ✗ (actually we should check [1,3] wait that's not contiguous)

Let me recheck: [2,3,-2,1]... hmm the array is [1,2,3,-2,2]
Actually: 
- [1,2,3,-2] = 4 ✓
- That seems to be the only one. count = 1 ✓
```

### Why Initialize with {0: 1}?

```
THE CRUCIAL INITIALIZATION:
════════════════════════════════════════════════════════════════

prefix_count = {0: 1}

This represents the "empty prefix" - the sum before any elements.

Why is it needed?
───────────────────────────────────────────────────────────────

Example: nums = [4], k = 4

Without {0: 1}:
  prefix_sum = 4
  target = 4 - 4 = 0
  0 in prefix_count? NO (if we didn't initialize!)
  count = 0  ← WRONG!

With {0: 1}:
  prefix_sum = 4
  target = 4 - 4 = 0
  0 in prefix_count? YES!
  count = 1  ← CORRECT!

The subarray [4] itself has sum 4.
It corresponds to: prefix[1] - prefix[0] = 4 - 0 = 4

prefix[0] = 0 is the "empty prefix" that must be pre-recorded!
```

---

## 11.3 Pattern 2: Subarray Sum Divisible by K

### The Modular Arithmetic Insight

```
DIVISIBILITY WITH PREFIX SUM:
════════════════════════════════════════════════════════════════

We want: sum(arr[i:j]) divisible by k
         sum(arr[i:j]) % k == 0

Using prefix sum:
  (prefix[j] - prefix[i]) % k == 0
  prefix[j] % k == prefix[i] % k

KEY INSIGHT:
If two prefix sums have the SAME remainder when divided by k,
then the subarray between them is divisible by k!

Example: k = 5
  prefix[i] = 7,  7 % 5 = 2
  prefix[j] = 12, 12 % 5 = 2
  
  sum(arr[i:j]) = 12 - 7 = 5
  5 % 5 = 0 ✓ (divisible!)
```

### Implementation

```python
def subarrays_div_by_k(nums, k):
    """
    LeetCode 974: Subarray Sums Divisible by K
    
    Count subarrays with sum divisible by k.
    
    Time: O(n)
    Space: O(k)
    """
    prefix_sum = 0
    count = 0
    
    # Map: remainder → count of prefix sums with this remainder
    remainder_count = {0: 1}
    
    for num in nums:
        prefix_sum += num
        
        # Handle negative remainders (Python handles this, but be safe)
        remainder = prefix_sum % k
        
        # If we've seen this remainder before, those make valid subarrays
        if remainder in remainder_count:
            count += remainder_count[remainder]
        
        remainder_count[remainder] = remainder_count.get(remainder, 0) + 1
    
    return count
```

### Visual Example

```
nums = [4, 5, 0, -2, -3, 1], k = 5

═══════════════════════════════════════════════════════════════

i=0: prefix=4, rem=4%5=4
     remainder_count = {0:1, 4:1}
     4 not seen before, count = 0

i=1: prefix=9, rem=9%5=4
     4 seen 1 time! count = 1
     Subarray: [5] → 5%5=0 ✓ Wait, let me recalculate...
     
     Actually prefix[2]-prefix[1] = 9-4 = 5, divisible!
     Subarray: nums[1:2] = [5] ✓
     
     remainder_count = {0:1, 4:2}

i=2: prefix=9, rem=9%5=4
     4 seen 2 times! count = 1+2 = 3
     Subarrays: [5,0] and [0]
     
     remainder_count = {0:1, 4:3}

i=3: prefix=7, rem=7%5=2
     2 not seen, count = 3
     remainder_count = {0:1, 4:3, 2:1}

i=4: prefix=4, rem=4%5=4
     4 seen 3 times! count = 3+3 = 6
     remainder_count = {0:1, 4:4, 2:1}

i=5: prefix=5, rem=5%5=0
     0 seen 1 time! count = 6+1 = 7
     This means prefix[6]-prefix[0] = 5-0 = 5, divisible!
     Subarray: entire array [4,5,0,-2,-3,1] ✓

FINAL: count = 7
```

---

## 11.4 Pattern 3: Maximum Subarray Sum with Constraint

### Problem: Maximum Sum with Length Constraint

```python
def max_sum_with_length_at_least_k(nums, k):
    """
    Find maximum sum of subarray with length at least k.
    
    Combines prefix sum with sliding window tracking of minimum prefix.
    """
    n = len(nums)
    
    # Build prefix sum
    prefix = [0] * (n + 1)
    for i in range(n):
        prefix[i + 1] = prefix[i] + nums[i]
    
    max_sum = float('-inf')
    min_prefix = prefix[0]  # Minimum prefix seen so far
    
    for i in range(k, n + 1):
        # Subarray ending at i-1 with length at least k
        # needs to start at or before index i-k
        # sum = prefix[i] - prefix[start]
        # To maximize sum, minimize prefix[start]
        
        # min_prefix considers all prefix[0] to prefix[i-k]
        max_sum = max(max_sum, prefix[i] - min_prefix)
        
        # Update min_prefix for next iteration
        # Include prefix[i-k+1] for the next round
        min_prefix = min(min_prefix, prefix[i - k + 1])
    
    return max_sum
```

### Visual Explanation

```
nums = [1, -2, 3, 4, -1], k = 2

prefix = [0, 1, -1, 2, 6, 5]
          0  1   2  3  4  5

═══════════════════════════════════════════════════════════════
FINDING MAX SUM WITH LENGTH ≥ 2:
═══════════════════════════════════════════════════════════════

i=2: (subarray ending at index 1, length ≥ 2)
     min_prefix from prefix[0:1] = min(0) = 0
     max_sum = prefix[2] - min_prefix = -1 - 0 = -1
     
     Update: include prefix[1]=1 for next round
     min_prefix = min(0, 1) = 0

i=3: (subarray ending at index 2, length ≥ 2)
     min_prefix = 0 (from prefix[0] or prefix[1])
     max_sum = max(-1, prefix[3] - 0) = max(-1, 2) = 2
     
     Update: include prefix[2]=-1
     min_prefix = min(0, -1) = -1

i=4: (subarray ending at index 3, length ≥ 2)
     min_prefix = -1
     max_sum = max(2, prefix[4] - (-1)) = max(2, 6+1) = 7
     
     Subarray: from index after min_prefix to index 3
     prefix[-1] is at index 2, so subarray is [2:4] = [3, 4]
     Sum = 7 ✓
     
     Update: min_prefix = min(-1, prefix[3]) = min(-1, 2) = -1

i=5: (subarray ending at index 4, length ≥ 2)
     min_prefix = -1
     max_sum = max(7, prefix[5] - (-1)) = max(7, 5+1) = 7
     
FINAL: max_sum = 7 (subarray [3, 4])
```

---

## 11.5 Pattern 4: Shortest Subarray with Sum at Least K

### The Challenge with Negative Numbers

```
WHY THIS IS HARD:
════════════════════════════════════════════════════════════════

With positive numbers only:
  • Simple sliding window works
  • Expand increases sum, contract decreases sum

With negative numbers:
  • Expanding might decrease sum!
  • Can't use simple expand/contract

Solution: Prefix Sum + Monotonic Deque
```

### Implementation

```python
from collections import deque

def shortest_subarray(nums, k):
    """
    LeetCode 862: Shortest Subarray with Sum at Least K
    
    Find shortest subarray with sum >= k.
    Works with NEGATIVE numbers!
    
    Time: O(n)
    Space: O(n)
    """
    n = len(nums)
    
    # Build prefix sum
    prefix = [0] * (n + 1)
    for i in range(n):
        prefix[i + 1] = prefix[i] + nums[i]
    
    # Monotonic deque: stores indices with increasing prefix values
    dq = deque()
    min_len = float('inf')
    
    for i in range(n + 1):
        # Check if we can form valid subarray with elements in deque
        # We want: prefix[i] - prefix[j] >= k
        # i.e., prefix[j] <= prefix[i] - k
        while dq and prefix[i] - prefix[dq[0]] >= k:
            min_len = min(min_len, i - dq[0])
            dq.popleft()  # This j won't give shorter subarray for future i
        
        # Maintain increasing order in deque
        # If prefix[i] <= prefix[back], back can never be optimal start
        while dq and prefix[dq[-1]] >= prefix[i]:
            dq.pop()
        
        dq.append(i)
    
    return min_len if min_len != float('inf') else -1
```

### Why Monotonic Deque Works

```
THE MONOTONIC DEQUE INSIGHT:
════════════════════════════════════════════════════════════════

We want shortest subarray [j+1, i] with prefix[i] - prefix[j] >= k

TWO KEY OBSERVATIONS:

1. Once we find a valid j for some i:
   • j won't be useful for any future i' > i
   • Because i'-j > i-j (longer subarray)
   • So we can remove j from consideration (popleft)

2. If prefix[j1] >= prefix[j2] where j1 < j2:
   • j1 is NEVER better than j2
   • For any future i: 
     - If prefix[i] - prefix[j1] >= k, then prefix[i] - prefix[j2] >= k too
     - AND j2 > j1 means shorter subarray!
   • So we can remove j1 from consideration (pop)

This means: deque maintains INCREASING prefix values!

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  DEQUE INVARIANT:                                           │
│  prefix[dq[0]] < prefix[dq[1]] < ... < prefix[dq[-1]]       │
│                                                             │
│  Front: smallest prefix (best for maximizing sum)           │
│  Back: largest prefix (most recent)                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Visual Walkthrough

```
nums = [2, -1, 2, 3, -2], k = 4
prefix = [0, 2, 1, 3, 6, 4]

═══════════════════════════════════════════════════════════════
i=0: prefix[0]=0
─────────────────────────────────────────────────────────────
  Deque empty, just add
  dq = [0]
  (prefix values: [0])

═══════════════════════════════════════════════════════════════
i=1: prefix[1]=2
─────────────────────────────────────────────────────────────
  Check front: prefix[1]-prefix[0] = 2-0 = 2 < 4, don't pop
  
  Maintain increasing: prefix[0]=0 < prefix[1]=2, keep
  dq = [0, 1]
  (prefix values: [0, 2])

═══════════════════════════════════════════════════════════════
i=2: prefix[2]=1
─────────────────────────────────────────────────────────────
  Check front: prefix[2]-prefix[0] = 1-0 = 1 < 4, don't pop
  
  Maintain increasing: 
    prefix[1]=2 >= prefix[2]=1, pop index 1!
    prefix[0]=0 < prefix[2]=1, keep
  dq = [0, 2]
  (prefix values: [0, 1])

═══════════════════════════════════════════════════════════════
i=3: prefix[3]=3
─────────────────────────────────────────────────────────────
  Check front: prefix[3]-prefix[0] = 3-0 = 3 < 4, don't pop
  
  Maintain increasing: prefix[2]=1 < prefix[3]=3, keep
  dq = [0, 2, 3]
  (prefix values: [0, 1, 3])

═══════════════════════════════════════════════════════════════
i=4: prefix[4]=6
─────────────────────────────────────────────────────────────
  Check front: prefix[4]-prefix[0] = 6-0 = 6 >= 4 ✓
    min_len = 4 - 0 = 4
    Subarray: nums[0:4] = [2,-1,2,3], sum=6 ✓
    popleft! dq = [2, 3]
  
  Check front again: prefix[4]-prefix[2] = 6-1 = 5 >= 4 ✓
    min_len = min(4, 4-2) = 2
    Subarray: nums[2:4] = [2,3], sum=5 ✓
    popleft! dq = [3]
  
  Check front again: prefix[4]-prefix[3] = 6-3 = 3 < 4, stop
  
  Maintain increasing: prefix[3]=3 < prefix[4]=6, keep
  dq = [3, 4]
  (prefix values: [3, 6])

═══════════════════════════════════════════════════════════════
i=5: prefix[5]=4
─────────────────────────────────────────────────────────────
  Check front: prefix[5]-prefix[3] = 4-3 = 1 < 4, don't pop
  
  Maintain increasing:
    prefix[4]=6 >= prefix[5]=4, pop index 4!
    prefix[3]=3 < prefix[5]=4, keep
  dq = [3, 5]
  (prefix values: [3, 4])

═══════════════════════════════════════════════════════════════
FINAL: min_len = 2

Shortest subarray: [2, 3] with sum = 5 >= 4
```

---

## 11.6 Pattern 5: Count Subarrays with Sum in Range

```python
def count_subarrays_in_range(nums, lower, upper):
    """
    Count subarrays with sum in range [lower, upper].
    
    Uses: count(sum <= upper) - count(sum <= lower-1)
    Combined with prefix sum and counting.
    """
    from sortedcontainers import SortedList
    
    prefix_sum = 0
    count = 0
    sorted_prefix = SortedList([0])  # Include empty prefix
    
    for num in nums:
        prefix_sum += num
        
        # Count prefix sums in range [prefix_sum - upper, prefix_sum - lower]
        # If prefix[j] is in this range, then sum[j:i] is in [lower, upper]
        left_bound = prefix_sum - upper
        right_bound = prefix_sum - lower
        
        # Count elements in sorted list within bounds
        left_idx = sorted_prefix.bisect_left(left_bound)
        right_idx = sorted_prefix.bisect_right(right_bound)
        count += right_idx - left_idx
        
        sorted_prefix.add(prefix_sum)
    
    return count
```

---

## 11.7 Sliding Window vs Prefix Sum: When to Use Which

```
DECISION GUIDE:
════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────┐
│                   USE SLIDING WINDOW                         │
├─────────────────────────────────────────────────────────────┤
│  ✓ All positive (or all negative) numbers                   │
│  ✓ "At most K" or "At least K" with monotonic property      │
│  ✓ Finding longest/shortest with inequality constraint       │
│  ✓ Window validity is monotonic                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                    USE PREFIX SUM                            │
├─────────────────────────────────────────────────────────────┤
│  ✓ Array contains NEGATIVE numbers                          │
│  ✓ Need EXACT sum (sum equals K)                            │
│  ✓ Divisibility conditions                                  │
│  ✓ Sum in a range [lower, upper]                            │
│  ✓ Non-monotonic relationship                               │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│               USE PREFIX SUM + MONOTONIC DEQUE               │
├─────────────────────────────────────────────────────────────┤
│  ✓ Shortest subarray with sum >= K (with negatives)         │
│  ✓ Need to optimize over prefix sums                        │
│  ✓ Requires maintaining sorted order of candidates          │
└─────────────────────────────────────────────────────────────┘
```

---

## 11.8 Chapter Summary

```
┌─────────────────────────────────────────────────────────────┐
│          PREFIX SUM + SLIDING WINDOW KEY POINTS              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. PREFIX SUM BASICS                                       │
│     • prefix[i] = sum(arr[0:i])                             │
│     • sum(arr[i:j]) = prefix[j] - prefix[i]                 │
│     • Initialize: prefix_count = {0: 1}                     │
│                                                             │
│  2. SUBARRAY SUM = K                                        │
│     • Look for prefix_sum - k in hashmap                    │
│     • Works with negative numbers!                          │
│     • Time: O(n), Space: O(n)                               │
│                                                             │
│  3. DIVISIBILITY BY K                                       │
│     • Track remainders instead of sums                      │
│     • Same remainder → divisible difference                 │
│     • Space: O(k) only                                      │
│                                                             │
│  4. SHORTEST WITH SUM ≥ K (NEGATIVES)                       │
│     • Use monotonic deque with prefix sums                  │
│     • Maintain increasing prefix values in deque            │
│     • Pop front when valid, pop back to maintain order      │
│                                                             │
│  5. WHEN TO USE                                             │
│     • Negative numbers → Prefix sum                         │
│     • Exact sum → Prefix sum                                │
│     • At most/least with positives → Sliding window         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 11.9 Practice Problems

| Problem | Technique | Difficulty |
|---------|-----------|------------|
| Subarray Sum Equals K (LC 560) | Prefix + HashMap | Medium |
| Subarray Sums Divisible by K (LC 974) | Prefix + Remainder | Medium |
| Shortest Subarray with Sum ≥ K (LC 862) | Prefix + Deque | Hard |
| Continuous Subarray Sum (LC 523) | Prefix + Remainder | Medium |
| Count Number of Nice Subarrays (LC 1248) | Prefix (variant) | Medium |
| Maximum Size Subarray Sum Equals k (LC 325) | Prefix + HashMap | Medium |
| Binary Subarrays With Sum (LC 930) | Prefix + HashMap | Medium |
