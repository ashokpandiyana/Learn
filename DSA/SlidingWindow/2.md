# Chapter 2: Fixed-Size Sliding Window

## 2.1 Definition and Characteristics

### What is a Fixed-Size Window?

A **Fixed-Size Sliding Window** maintains a window of constant size `k` that slides across the array one element at a time.

```
CHARACTERISTICS:
┌────────────────────────────────────────────────────────────┐
│                                                            │
│  • Window size is CONSTANT (given as input k)              │
│  • Window moves exactly ONE position per iteration         │
│  • Both pointers move together (right = left + k - 1)      │
│  • Total windows possible = n - k + 1                      │
│                                                            │
└────────────────────────────────────────────────────────────┘

Example: Array of size 7, window size k=3
Total windows = 7 - 3 + 1 = 5

Array: [ 1 | 2 | 3 | 4 | 5 | 6 | 7 ]

Window 1: [1, 2, 3]
Window 2: [2, 3, 4]
Window 3: [3, 4, 5]
Window 4: [4, 5, 6]
Window 5: [5, 6, 7]
```

---

## 2.2 The Two-Phase Approach

Every fixed-size window problem follows two phases:

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│   PHASE 1: BUILD                    PHASE 2: SLIDE          │
│   ────────────────                  ─────────────           │
│                                                             │
│   Build the first window            Slide window by:        │
│   of size k                         • Adding new element    │
│                                     • Removing old element  │
│                                                             │
│   Indices: [0, k-1]                 For i from k to n-1     │
│                                                             │
│   ┌───┬───┬───┐                     ┌───┬───┬───┐           │
│   │ 0 │ 1 │...│ k-1                 │   │   │   │→ slides   │
│   └───┴───┴───┘                     └───┴───┴───┘           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Visual Step-by-Step

```
Array: [2, 1, 5, 1, 3, 2]    k = 3

═══════════════════════════════════════════════════════════════
PHASE 1: BUILD INITIAL WINDOW (indices 0 to k-1)
═══════════════════════════════════════════════════════════════

    Index:   0    1    2    3    4    5
    Array: [ 2 ][ 1 ][ 5 ][ 1 ][ 3 ][ 2 ]
            └────────────┘
              Window 1
              
    window_sum = 2 + 1 + 5 = 8

═══════════════════════════════════════════════════════════════
PHASE 2: SLIDE THE WINDOW (i goes from k to n-1)
═══════════════════════════════════════════════════════════════

ITERATION i=3:
─────────────────────────────────────────────────────────────
    Index:   0    1    2    3    4    5
    Array: [ 2 ][ 1 ][ 5 ][ 1 ][ 3 ][ 2 ]
            ───   └────────────┘
           remove      Window 2
           (i-k=0)     
                             ↑
                          add (i=3)
    
    window_sum = 8 - arr[0] + arr[3]
               = 8 - 2 + 1 = 7

ITERATION i=4:
─────────────────────────────────────────────────────────────
    Index:   0    1    2    3    4    5
    Array: [ 2 ][ 1 ][ 5 ][ 1 ][ 3 ][ 2 ]
                 ───   └────────────┘
                remove      Window 3
                (i-k=1)     
                                  ↑
                               add (i=4)
    
    window_sum = 7 - arr[1] + arr[4]
               = 7 - 1 + 3 = 9

ITERATION i=5:
─────────────────────────────────────────────────────────────
    Index:   0    1    2    3    4    5
    Array: [ 2 ][ 1 ][ 5 ][ 1 ][ 3 ][ 2 ]
                      ───   └────────────┘
                     remove      Window 4
                     (i-k=2)     
                                       ↑
                                    add (i=5)
    
    window_sum = 9 - arr[2] + arr[5]
               = 9 - 5 + 2 = 6
```

---

## 2.3 The Standard Template

```python
def fixed_sliding_window(arr, k):
    """
    Standard template for fixed-size sliding window.
    
    Time Complexity: O(n)
    Space Complexity: O(1) for sum, O(k) for tracking elements
    """
    n = len(arr)
    
    # Edge case: window size larger than array
    if k > n:
        return None  # or handle appropriately
    
    # ═══════════════════════════════════════════
    # PHASE 1: Build the initial window [0, k-1]
    # ═══════════════════════════════════════════
    window_state = 0
    for i in range(k):
        window_state += arr[i]  # or other operation
    
    result = window_state  # Initialize result with first window
    
    # ═══════════════════════════════════════════
    # PHASE 2: Slide the window from index k to n-1
    # ═══════════════════════════════════════════
    for i in range(k, n):
        # Add new element (entering the window)
        window_state += arr[i]
        
        # Remove old element (leaving the window)
        window_state -= arr[i - k]
        
        # Update result
        result = max(result, window_state)  # or min, or other
    
    return result
```

### Index Relationship Diagram

```
When we're at index i (during Phase 2):

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  Index to REMOVE: i - k     (element leaving the window)    │
│  Index to ADD:    i         (element entering the window)   │
│                                                             │
│  Current window: [i - k + 1, i]                             │
│  Window size:    i - (i - k + 1) + 1 = k ✓                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘

Example: i = 5, k = 3

    Remove index: 5 - 3 = 2
    Add index: 5
    Window: [3, 4, 5]  (indices)
    
    0    1    2    3    4    5
   [ ]  [ ]  [×]  [■]  [■]  [■]
          ↑    └──────────────┘
       remove     current window
```

---

## 2.4 Detailed Examples

### Example 1: Maximum Sum Subarray of Size K

**Problem:** Find the maximum sum among all contiguous subarrays of size k.

```python
def max_sum_subarray(arr, k):
    """
    Find maximum sum of any subarray of size k.
    
    Example:
    arr = [2, 1, 5, 1, 3, 2], k = 3
    Subarrays: [2,1,5]=8, [1,5,1]=7, [5,1,3]=9, [1,3,2]=6
    Answer: 9
    """
    n = len(arr)
    if k > n:
        return 0
    
    # Phase 1: Build first window
    window_sum = sum(arr[:k])
    max_sum = window_sum
    
    # Phase 2: Slide
    for i in range(k, n):
        window_sum += arr[i] - arr[i - k]
        max_sum = max(max_sum, window_sum)
    
    return max_sum

# Trace through example:
# arr = [2, 1, 5, 1, 3, 2], k = 3
#
# Phase 1: window_sum = 2+1+5 = 8, max_sum = 8
#
# Phase 2:
# i=3: window_sum = 8 + 1 - 2 = 7, max_sum = max(8,7) = 8
# i=4: window_sum = 7 + 3 - 1 = 9, max_sum = max(8,9) = 9
# i=5: window_sum = 9 + 2 - 5 = 6, max_sum = max(9,6) = 9
#
# Return: 9
```

---

### Example 2: First Negative in Every Window of Size K

**Problem:** Find the first negative number in every window of size k. If no negative exists, use 0.

```python
from collections import deque

def first_negative_in_window(arr, k):
    """
    Find first negative integer in every window of size k.
    
    Example:
    arr = [12, -1, -7, 8, -15, 30, 16, 28], k = 3
    
    Windows and their first negative:
    [12, -1, -7]  → -1
    [-1, -7, 8]   → -1
    [-7, 8, -15]  → -7
    [8, -15, 30]  → -15
    [-15, 30, 16] → -15
    [30, 16, 28]  → 0 (no negative)
    
    Answer: [-1, -1, -7, -15, -15, 0]
    """
    result = []
    negative_indices = deque()  # Store indices of negative numbers
    
    # Phase 1: Process first window
    for i in range(k):
        if arr[i] < 0:
            negative_indices.append(i)
    
    # Record first negative of first window
    if negative_indices:
        result.append(arr[negative_indices[0]])
    else:
        result.append(0)
    
    # Phase 2: Slide the window
    for i in range(k, len(arr)):
        # Add: if new element is negative, add its index
        if arr[i] < 0:
            negative_indices.append(i)
        
        # Remove: remove indices that are outside the window
        # Window is now [i-k+1, i], so anything ≤ i-k is outside
        while negative_indices and negative_indices[0] <= i - k:
            negative_indices.popleft()
        
        # Record result
        if negative_indices:
            result.append(arr[negative_indices[0]])
        else:
            result.append(0)
    
    return result
```

**Deque State Visualization:**

```
arr = [12, -1, -7, 8, -15, 30, 16, 28], k = 3

Phase 1 (i=0,1,2): Build window [12, -1, -7]
─────────────────────────────────────────────
i=0: arr[0]=12 (positive), deque = []
i=1: arr[1]=-1 (negative), deque = [1]
i=2: arr[2]=-7 (negative), deque = [1, 2]
Result so far: [-1]  (arr[deque[0]] = arr[1] = -1)

Phase 2: Slide
─────────────────────────────────────────────
i=3: Window [1,2,3] = [-1, -7, 8]
     arr[3]=8 (positive), don't add
     Check removal: nothing ≤ 0 to remove
     deque = [1, 2]
     Result: -1

i=4: Window [2,3,4] = [-7, 8, -15]
     arr[4]=-15 (negative), add index 4
     Check removal: index 1 ≤ 1, remove it!
     deque = [2, 4]
     Result: -7

i=5: Window [3,4,5] = [8, -15, 30]
     arr[5]=30 (positive), don't add
     Check removal: index 2 ≤ 2, remove it!
     deque = [4]
     Result: -15

i=6: Window [4,5,6] = [-15, 30, 16]
     arr[6]=16 (positive), don't add
     Check removal: nothing ≤ 3 to remove
     deque = [4]
     Result: -15

i=7: Window [5,6,7] = [30, 16, 28]
     arr[7]=28 (positive), don't add
     Check removal: index 4 ≤ 4, remove it!
     deque = []
     Result: 0 (deque is empty)

Final: [-1, -1, -7, -15, -15, 0]
```

---

### Example 3: Count Distinct Elements in Every Window

**Problem:** Count the number of distinct elements in every window of size k.

```python
from collections import defaultdict

def count_distinct_in_windows(arr, k):
    """
    Count distinct elements in each window of size k.
    
    Example:
    arr = [1, 2, 1, 3, 4, 2, 3], k = 4
    
    [1,2,1,3] → distinct: {1,2,3} → 3
    [2,1,3,4] → distinct: {1,2,3,4} → 4
    [1,3,4,2] → distinct: {1,2,3,4} → 4
    [3,4,2,3] → distinct: {2,3,4} → 3
    
    Answer: [3, 4, 4, 3]
    """
    n = len(arr)
    result = []
    freq = defaultdict(int)  # Frequency map
    distinct_count = 0
    
    # Phase 1: Build first window
    for i in range(k):
        if freq[arr[i]] == 0:
            distinct_count += 1
        freq[arr[i]] += 1
    
    result.append(distinct_count)
    
    # Phase 2: Slide
    for i in range(k, n):
        # Add new element
        if freq[arr[i]] == 0:
            distinct_count += 1
        freq[arr[i]] += 1
        
        # Remove old element
        freq[arr[i - k]] -= 1
        if freq[arr[i - k]] == 0:
            distinct_count -= 1
        
        result.append(distinct_count)
    
    return result
```

**Key Insight:**
```
┌─────────────────────────────────────────────────────────────┐
│  TRACKING DISTINCT ELEMENTS:                                │
│                                                             │
│  When ADDING element x:                                     │
│    if freq[x] == 0 before adding → new distinct element     │
│    increment distinct_count BEFORE incrementing freq        │
│                                                             │
│  When REMOVING element x:                                   │
│    if freq[x] == 1 before removing → losing a distinct      │
│    decrement distinct_count AFTER decrementing freq         │
│    (check if freq becomes 0)                                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 2.5 Important Edge Cases

```python
def handle_edge_cases(arr, k):
    """
    Always handle these edge cases first!
    """
    
    # Case 1: Empty array
    if not arr:
        return []  # or appropriate default
    
    # Case 2: k is larger than array length
    if k > len(arr):
        return []  # or process entire array as one window
    
    # Case 3: k is 0 or negative
    if k <= 0:
        return []  # invalid input
    
    # Case 4: k equals array length (only one window)
    if k == len(arr):
        return [process_entire_array(arr)]
    
    # Case 5: k is 1 (each element is its own window)
    if k == 1:
        return arr[:]  # or process each element individually
```

### Edge Case Visualization

```
EDGE CASE SCENARIOS:
════════════════════════════════════════════════════════════

Case: k > n
─────────────────────
Array: [1, 2, 3]  k = 5

    [1][2][3]  ???
    └─────────────────?
    
    Window cannot fit! Handle as error or special case.

Case: k = n
─────────────────────
Array: [1, 2, 3, 4]  k = 4

    [1][2][3][4]
    └──────────┘
    
    Only ONE window possible = entire array

Case: k = 1
─────────────────────
Array: [1, 2, 3, 4]  k = 1

    [1] [2] [3] [4]
     ↑   ↑   ↑   ↑
     
    Each element is its own window (n windows total)

Case: All elements same
─────────────────────
Array: [5, 5, 5, 5]  k = 2

    [5,5] [5,5] [5,5]
    
    All windows have same sum/properties
```

---

## 2.6 Common Patterns Summary

| Pattern | State to Track | Update Operation |
|---------|---------------|------------------|
| Sum/Average | Running sum | `sum += new - old` |
| Max/Min element | Monotonic deque | Add/remove from deque |
| Distinct count | HashMap + counter | Inc/dec count on 0↔1 transitions |
| First negative | Deque of indices | Add negative indices, remove out-of-window |
| Contains element | HashMap or Set | Add new, remove old |

---

## 2.7 Chapter Summary

```
┌─────────────────────────────────────────────────────────────┐
│                FIXED-SIZE WINDOW KEY POINTS                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ✓ Window size k is CONSTANT throughout                     │
│                                                             │
│  ✓ Two phases: BUILD (0 to k-1) then SLIDE (k to n-1)       │
│                                                             │
│  ✓ During sliding at index i:                               │
│      • ADD element at index i                               │
│      • REMOVE element at index i - k                        │
│                                                             │
│  ✓ Total number of windows = n - k + 1                      │
│                                                             │
│  ✓ Always handle edge case: k > n                           │
│                                                             │
│  ✓ Time: O(n), Space: O(1) to O(k) depending on state       │
│                                                             │
│  ✓ Common data structures:                                  │
│      • Variable (sum, count)                                │
│      • HashMap (frequency, distinct elements)               │
│      • Deque (max/min, first occurrence)                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Practice Problems (Easy to Medium)

1. **Maximum Average Subarray I** (LeetCode 643)
2. **Contains Duplicate II** (LeetCode 219)
3. **Sliding Window Maximum** (LeetCode 239) - Uses Deque
4. **Find All Anagrams in a String** (LeetCode 438)
5. **Maximum Number of Vowels in a Substring** (LeetCode 1456)
6. **Grumpy Bookstore Owner** (LeetCode 1052)
