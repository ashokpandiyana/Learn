# Chapter 8: Sliding Window on Strings

## 8.1 Introduction: String-Specific Challenges

### Why Strings Are Special

String problems have unique characteristics that require specialized techniques:

```
STRING-SPECIFIC CONSIDERATIONS:
════════════════════════════════════════════════════════════════

1. CHARACTER SET
   • Lowercase only: 26 characters → O(26) = O(1) space
   • Uppercase + Lowercase: 52 characters
   • ASCII printable: 95 characters
   • Unicode: Much larger set

2. PATTERN MATCHING
   • Anagrams: Same characters, different order
   • Permutations: Rearrangements of a pattern
   • Substrings vs Subsequences (contiguous vs non-contiguous)

3. COMPARISON METHODS
   • Character-by-character
   • Frequency map comparison
   • Hash-based comparison

4. COMMON OPERATIONS
   • Character frequency tracking
   • Distinct character counting
   • Pattern containment checking
```

### Character Frequency Array vs HashMap

```
┌─────────────────────────────────────────────────────────────┐
│          FREQUENCY ARRAY vs HASHMAP                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  FREQUENCY ARRAY (for known character set):                 │
│  ─────────────────────────────────────────                  │
│  freq = [0] * 26  # For lowercase letters                   │
│  freq[ord(c) - ord('a')] += 1                               │
│                                                             │
│  Pros: Faster, fixed O(26) comparison                       │
│  Cons: Wastes space if few unique chars                     │
│                                                             │
│  HASHMAP (for variable character set):                      │
│  ─────────────────────────────────────                      │
│  freq = defaultdict(int)                                    │
│  freq[c] += 1                                               │
│                                                             │
│  Pros: Space-efficient, flexible                            │
│  Cons: Slightly slower, variable comparison time            │
│                                                             │
│  RECOMMENDATION:                                            │
│  • Known small charset (lowercase) → Array                  │
│  • Unknown/large charset → HashMap                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 8.2 Pattern 1: Finding Anagrams

### What is an Anagram?

An anagram is a rearrangement of characters. Two strings are anagrams if they have the **same character frequencies**.

```
ANAGRAM EXAMPLES:
════════════════════════════════════════════════════════════════

"listen" and "silent" → Anagrams ✓
  l:1, i:1, s:1, t:1, e:1, n:1  (same frequencies)

"hello" and "world" → Not anagrams ✗
  Different characters entirely

"aab" and "aba" → Anagrams ✓
  a:2, b:1  (same frequencies, different order)
```

### Template: Find All Anagrams in a String

```python
from collections import Counter

def find_anagrams(s, p):
    """
    LeetCode 438: Find All Anagrams in a String
    
    Find all start indices of p's anagrams in s.
    
    Example: s = "cbaebabacd", p = "abc"
    Output: [0, 6]
    
    Explanation:
    - Index 0: "cba" is anagram of "abc"
    - Index 6: "bac" is anagram of "abc"
    
    Time: O(n) where n = len(s)
    Space: O(k) where k = unique characters in p
    """
    if len(p) > len(s):
        return []
    
    p_count = Counter(p)       # Target frequencies
    s_count = Counter()        # Current window frequencies
    result = []
    k = len(p)
    
    for i in range(len(s)):
        # ADD: Include character at position i
        s_count[s[i]] += 1
        
        # REMOVE: Exclude character that left the window
        if i >= k:
            left_char = s[i - k]
            s_count[left_char] -= 1
            if s_count[left_char] == 0:
                del s_count[left_char]
        
        # CHECK: Compare frequency maps
        if s_count == p_count:
            result.append(i - k + 1)
    
    return result
```

### Visual Walkthrough: Find All Anagrams

```
s = "cbaebabacd", p = "abc"
p_count = {'a': 1, 'b': 1, 'c': 1}

═══════════════════════════════════════════════════════════════
i=0: char='c'
─────────────────────────────────────────────────────────────
  [c]  b   a   e   b   a   b   a   c   d
   ↑
  
  s_count = {'c': 1}
  Window size = 1 < 3, no removal
  s_count ≠ p_count

═══════════════════════════════════════════════════════════════
i=1: char='b'
─────────────────────────────────────────────────────────────
  [c   b]  a   e   b   a   b   a   c   d
       ↑
  
  s_count = {'c': 1, 'b': 1}
  Window size = 2 < 3, no removal
  s_count ≠ p_count

═══════════════════════════════════════════════════════════════
i=2: char='a'
─────────────────────────────────────────────────────────────
  [c   b   a]  e   b   a   b   a   c   d
           ↑
  
  s_count = {'c': 1, 'b': 1, 'a': 1}
  Window size = 3, no removal yet (i >= k first time)
  
  s_count == p_count? YES! ✓
  result.append(2 - 3 + 1 = 0)
  result = [0]

═══════════════════════════════════════════════════════════════
i=3: char='e'
─────────────────────────────────────────────────────────────
   c  [b   a   e]  b   a   b   a   c   d
               ↑
  
  Add 'e': s_count = {'c': 1, 'b': 1, 'a': 1, 'e': 1}
  Remove s[0]='c': s_count = {'b': 1, 'a': 1, 'e': 1}
  
  s_count ≠ p_count (has 'e', missing 'c')

═══════════════════════════════════════════════════════════════
i=4: char='b'
─────────────────────────────────────────────────────────────
   c   b  [a   e   b]  a   b   a   c   d
                   ↑
  
  Add 'b': s_count = {'b': 2, 'a': 1, 'e': 1}
  Remove s[1]='b': s_count = {'b': 1, 'a': 1, 'e': 1}
  
  s_count ≠ p_count

═══════════════════════════════════════════════════════════════
i=5: char='a'
─────────────────────────────────────────────────────────────
   c   b   a  [e   b   a]  b   a   c   d
                       ↑
  
  Add 'a': s_count = {'b': 1, 'a': 2, 'e': 1}
  Remove s[2]='a': s_count = {'b': 1, 'a': 1, 'e': 1}
  
  s_count ≠ p_count

═══════════════════════════════════════════════════════════════
i=6: char='b'
─────────────────────────────────────────────────────────────
   c   b   a   e  [b   a   b]  a   c   d
                           ↑
  
  Add 'b': s_count = {'b': 2, 'a': 1, 'e': 1}
  Remove s[3]='e': s_count = {'b': 2, 'a': 1}
  
  s_count ≠ p_count

═══════════════════════════════════════════════════════════════
i=7: char='a'
─────────────────────────────────────────────────────────────
   c   b   a   e   b  [a   b   a]  c   d
                               ↑
  
  Add 'a': s_count = {'b': 2, 'a': 2}
  Remove s[4]='b': s_count = {'b': 1, 'a': 2}
  
  s_count ≠ p_count

═══════════════════════════════════════════════════════════════
i=8: char='c'
─────────────────────────────────────────────────────────────
   c   b   a   e   b   a  [b   a   c]  d
                                   ↑
  
  Add 'c': s_count = {'b': 1, 'a': 2, 'c': 1}
  Remove s[5]='a': s_count = {'b': 1, 'a': 1, 'c': 1}
  
  s_count == p_count? YES! ✓
  result.append(8 - 3 + 1 = 6)
  result = [0, 6]

═══════════════════════════════════════════════════════════════
i=9: char='d'
─────────────────────────────────────────────────────────────
   c   b   a   e   b   a   b  [a   c   d]
                                       ↑
  
  Add 'd': s_count = {'b': 1, 'a': 1, 'c': 1, 'd': 1}
  Remove s[6]='b': s_count = {'a': 1, 'c': 1, 'd': 1}
  
  s_count ≠ p_count

═══════════════════════════════════════════════════════════════
FINAL: result = [0, 6]
```

---

## 8.3 Pattern 2: Optimized Matching with "Matches" Counter

### The Problem with Map Comparison

Comparing two hashmaps takes O(k) time where k is the number of unique keys. We can optimize to O(1) by tracking how many characters are "matched".

```
OPTIMIZATION INSIGHT:
════════════════════════════════════════════════════════════════

Instead of comparing entire maps each time:
  if s_count == p_count:  # O(26) or O(k)

Track a "matches" counter:
  • matches = number of characters with CORRECT frequency
  • When matches == total unique chars in p, we found an anagram!
  • Update matches in O(1) when adding/removing characters
```

### Optimized Template

```python
def find_anagrams_optimized(s, p):
    """
    Optimized version using "matches" counter.
    
    Time: O(n) with O(1) per-character operations
    Space: O(26) = O(1) for lowercase letters
    """
    if len(p) > len(s):
        return []
    
    p_count = [0] * 26
    s_count = [0] * 26
    
    # Build pattern frequency
    for c in p:
        p_count[ord(c) - ord('a')] += 1
    
    result = []
    k = len(p)
    matches = 0
    
    # Count initial matches (characters with count 0 in both)
    for i in range(26):
        if p_count[i] == s_count[i]:
            matches += 1
    
    for i in range(len(s)):
        # ADD character
        idx = ord(s[i]) - ord('a')
        
        # Before adding: was this character matched?
        if s_count[idx] == p_count[idx]:
            matches -= 1  # Will become unmatched
        
        s_count[idx] += 1
        
        # After adding: is it matched now?
        if s_count[idx] == p_count[idx]:
            matches += 1
        
        # REMOVE character (if window is full)
        if i >= k:
            left_idx = ord(s[i - k]) - ord('a')
            
            if s_count[left_idx] == p_count[left_idx]:
                matches -= 1
            
            s_count[left_idx] -= 1
            
            if s_count[left_idx] == p_count[left_idx]:
                matches += 1
        
        # CHECK: all 26 characters matched
        if matches == 26:
            result.append(i - k + 1)
    
    return result
```

### Visual: Matches Counter Logic

```
UNDERSTANDING THE MATCHES COUNTER:
════════════════════════════════════════════════════════════════

p = "abc" → p_count = [1,1,1,0,0,...,0]  (a=1, b=1, c=1)
                       a b c d e     z

Initially s_count = [0,0,0,0,0,...,0]

Which positions MATCH (s_count[i] == p_count[i])?
  Position a (0): s=0, p=1 → NO MATCH
  Position b (1): s=0, p=1 → NO MATCH
  Position c (2): s=0, p=1 → NO MATCH
  Position d (3): s=0, p=0 → MATCH ✓
  Position e (4): s=0, p=0 → MATCH ✓
  ...
  Position z (25): s=0, p=0 → MATCH ✓

Initial matches = 23 (all except a, b, c)

To find an anagram, we need matches = 26!

─────────────────────────────────────────────────────────────
When we ADD 'a':
─────────────────────────────────────────────────────────────

Before: s_count[a] = 0, p_count[a] = 1 → NOT matched
        Was it matched before? 0 == 1? NO

After:  s_count[a] = 1, p_count[a] = 1 → MATCHED!
        Is it matched now? 1 == 1? YES → matches++

─────────────────────────────────────────────────────────────
When we ADD another 'a' (too many!):
─────────────────────────────────────────────────────────────

Before: s_count[a] = 1, p_count[a] = 1 → WAS matched
        matches-- (about to break the match)

After:  s_count[a] = 2, p_count[a] = 1 → NOT matched
        2 == 1? NO, don't increment matches
```

---

## 8.4 Pattern 3: Permutation in String

### Problem: Check if Permutation Exists

```python
def check_inclusion(s1, s2):
    """
    LeetCode 567: Permutation in String
    
    Check if any permutation of s1 exists as a substring in s2.
    
    Example: s1 = "ab", s2 = "eidbaooo"
    Output: True ("ba" is a permutation of "ab" and exists in s2)
    
    This is essentially: "Does ANY anagram of s1 exist in s2?"
    """
    if len(s1) > len(s2):
        return False
    
    s1_count = [0] * 26
    s2_count = [0] * 26
    
    for c in s1:
        s1_count[ord(c) - ord('a')] += 1
    
    k = len(s1)
    
    for i in range(len(s2)):
        # Add current character
        s2_count[ord(s2[i]) - ord('a')] += 1
        
        # Remove character outside window
        if i >= k:
            s2_count[ord(s2[i - k]) - ord('a')] -= 1
        
        # Check if permutation found
        if s1_count == s2_count:
            return True
    
    return False
```

### Alternative: Using "Have/Need" Pattern

```python
from collections import Counter

def check_inclusion_have_need(s1, s2):
    """
    Alternative implementation using have/need counters.
    More intuitive for some people.
    """
    if len(s1) > len(s2):
        return False
    
    need = Counter(s1)
    have = Counter()
    
    required = len(need)  # Number of unique chars we need
    formed = 0            # Number of unique chars we have (with correct count)
    
    k = len(s1)
    
    for i in range(len(s2)):
        char = s2[i]
        
        # Add character
        have[char] += 1
        if char in need and have[char] == need[char]:
            formed += 1
        
        # Remove character outside window
        if i >= k:
            left_char = s2[i - k]
            if left_char in need and have[left_char] == need[left_char]:
                formed -= 1
            have[left_char] -= 1
            if have[left_char] == 0:
                del have[left_char]
        
        # Check if permutation found
        if formed == required:
            return True
    
    return False
```

---

## 8.5 Pattern 4: Longest Substring Problems

### Type A: Without Repeating Characters

```python
def length_of_longest_substring(s):
    """
    LeetCode 3: Longest Substring Without Repeating Characters
    
    Example: "abcabcbb" → 3 ("abc")
    
    Approach: Variable window, contract when duplicate found
    """
    char_index = {}  # Character -> most recent index
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        char = s[right]
        
        # If char exists AND is within current window
        if char in char_index and char_index[char] >= left:
            # Move left past the previous occurrence
            left = char_index[char] + 1
        
        # Update character's position
        char_index[char] = right
        
        # Update result
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

### Visual: Longest Without Repeating

```
s = "abcabcbb"

═══════════════════════════════════════════════════════════════
right=0, char='a'
─────────────────────────────────────────────────────────────
  [a]  b   c   a   b   c   b   b
   ↑
  left=0
  
  'a' not in char_index
  char_index = {'a': 0}
  max_length = max(0, 0-0+1) = 1

═══════════════════════════════════════════════════════════════
right=1, char='b'
─────────────────────────────────────────────────────────────
  [a   b]  c   a   b   c   b   b
       ↑
  left=0
  
  'b' not in char_index
  char_index = {'a': 0, 'b': 1}
  max_length = max(1, 1-0+1) = 2

═══════════════════════════════════════════════════════════════
right=2, char='c'
─────────────────────────────────────────────────────────────
  [a   b   c]  a   b   c   b   b
           ↑
  left=0
  
  'c' not in char_index
  char_index = {'a': 0, 'b': 1, 'c': 2}
  max_length = max(2, 2-0+1) = 3

═══════════════════════════════════════════════════════════════
right=3, char='a'
─────────────────────────────────────────────────────────────
   a   b   c  [a]  b   c   b   b
               ↑
  
  'a' in char_index at index 0, and 0 >= left(0)
  DUPLICATE! Move left = 0 + 1 = 1
  
  char_index = {'a': 3, 'b': 1, 'c': 2}
  Window is now [b, c, a] (indices 1-3)
  max_length = max(3, 3-1+1) = 3

═══════════════════════════════════════════════════════════════
right=4, char='b'
─────────────────────────────────────────────────────────────
   a  [b   c   a   b]  c   b   b
                   ↑
  left=1
  
  'b' in char_index at index 1, and 1 >= left(1)
  DUPLICATE! Move left = 1 + 1 = 2
  
  char_index = {'a': 3, 'b': 4, 'c': 2}
  Window is now [c, a, b] (indices 2-4)
  max_length = max(3, 4-2+1) = 3

═══════════════════════════════════════════════════════════════
right=5, char='c'
─────────────────────────────────────────────────────────────
   a   b  [c   a   b   c]  b   b
                       ↑
  left=2
  
  'c' in char_index at index 2, and 2 >= left(2)
  DUPLICATE! Move left = 2 + 1 = 3
  
  char_index = {'a': 3, 'b': 4, 'c': 5}
  Window is now [a, b, c] (indices 3-5)
  max_length = max(3, 5-3+1) = 3

═══════════════════════════════════════════════════════════════
right=6, char='b'
─────────────────────────────────────────────────────────────
   a   b   c  [a   b   c   b]  b
                           ↑
  left=3
  
  'b' in char_index at index 4, and 4 >= left(3)
  DUPLICATE! Move left = 4 + 1 = 5
  
  char_index = {'a': 3, 'b': 6, 'c': 5}
  Window is now [c, b] (indices 5-6)
  max_length = max(3, 6-5+1) = 3

═══════════════════════════════════════════════════════════════
right=7, char='b'
─────────────────────────────────────────────────────────────
   a   b   c   a   b  [c   b   b]
                               ↑
  left=5
  
  'b' in char_index at index 6, and 6 >= left(5)
  DUPLICATE! Move left = 6 + 1 = 7
  
  char_index = {'a': 3, 'b': 7, 'c': 5}
  Window is now [b] (index 7)
  max_length = max(3, 7-7+1) = 3

═══════════════════════════════════════════════════════════════
FINAL: max_length = 3
```

### Type B: With At Most K Distinct Characters

```python
from collections import defaultdict

def longest_k_distinct(s, k):
    """
    LeetCode 340: Longest Substring with At Most K Distinct Characters
    
    Example: s = "eceba", k = 2 → 3 ("ece")
    """
    freq = defaultdict(int)
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        freq[s[right]] += 1
        
        # Contract while too many distinct characters
        while len(freq) > k:
            freq[s[left]] -= 1
            if freq[s[left]] == 0:
                del freq[s[left]]
            left += 1
        
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

### Type C: Longest Repeating Character Replacement

```python
def character_replacement(s, k):
    """
    LeetCode 424: Longest Repeating Character Replacement
    
    You can replace at most k characters.
    Find longest substring with all same characters after replacements.
    
    Example: s = "AABABBA", k = 1 → 4
    
    Key insight: 
    Valid window if: window_size - max_freq <= k
    (We can replace all non-majority characters)
    """
    freq = defaultdict(int)
    left = 0
    max_freq = 0  # Frequency of most common character in window
    max_length = 0
    
    for right in range(len(s)):
        freq[s[right]] += 1
        max_freq = max(max_freq, freq[s[right]])
        
        # Window is invalid if we need to replace more than k characters
        # Characters to replace = window_size - max_freq
        while (right - left + 1) - max_freq > k:
            freq[s[left]] -= 1
            left += 1
        
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

---

## 8.6 Pattern 5: Substring with Concatenation

### Problem: All Starting Indices of Concatenation

```python
from collections import Counter

def find_substring(s, words):
    """
    LeetCode 30: Substring with Concatenation of All Words
    
    Find starting indices where concatenation of all words exists.
    All words have the same length.
    
    Example: s = "barfoothefoobarman", words = ["foo","bar"]
    Output: [0, 9]
    
    "barfoo" at index 0, "foobar" at index 9
    """
    if not s or not words:
        return []
    
    word_len = len(words[0])
    word_count = len(words)
    total_len = word_len * word_count
    word_freq = Counter(words)
    
    result = []
    
    # Try each starting position (0 to word_len - 1)
    for start in range(word_len):
        left = start
        right = start
        current_freq = Counter()
        count = 0  # Number of valid words in window
        
        while right + word_len <= len(s):
            # Get word at right
            word = s[right:right + word_len]
            right += word_len
            
            if word in word_freq:
                current_freq[word] += 1
                count += 1
                
                # Too many of this word - shrink from left
                while current_freq[word] > word_freq[word]:
                    left_word = s[left:left + word_len]
                    current_freq[left_word] -= 1
                    count -= 1
                    left += word_len
                
                # Check if we have all words
                if count == word_count:
                    result.append(left)
            else:
                # Invalid word - reset window
                current_freq.clear()
                count = 0
                left = right
    
    return result
```

### Visual: Concatenation Matching

```
s = "barfoothefoobarman", words = ["foo", "bar"]
word_len = 3, word_count = 2, total_len = 6

═══════════════════════════════════════════════════════════════
Starting position 0:
─────────────────────────────────────────────────────────────

Process words at positions 0, 3, 6, 9, 12, 15...

Position 0-2: "bar" ✓ (in words)
  current_freq = {"bar": 1}, count = 1

Position 3-5: "foo" ✓ (in words)
  current_freq = {"bar": 1, "foo": 1}, count = 2
  count == word_count! → result.append(0)

Position 6-8: "the" ✗ (not in words)
  Reset: current_freq = {}, count = 0, left = 9

Position 9-11: "foo" ✓
  current_freq = {"foo": 1}, count = 1

Position 12-14: "bar" ✓
  current_freq = {"foo": 1, "bar": 1}, count = 2
  count == word_count! → result.append(9)

Position 15-17: "man" ✗
  Reset

═══════════════════════════════════════════════════════════════
Starting position 1:
─────────────────────────────────────────────────────────────

Process words at positions 1, 4, 7, 10, 13, 16...

Position 1-3: "arf" ✗ (not in words)
Position 4-6: "oot" ✗
...and so on

═══════════════════════════════════════════════════════════════
FINAL: result = [0, 9]
```

---

## 8.7 String Comparison Methods Summary

```
┌─────────────────────────────────────────────────────────────┐
│           STRING WINDOW COMPARISON METHODS                   │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  METHOD 1: Direct Map Comparison                            │
│  ───────────────────────────────                            │
│  if s_count == p_count:                                     │
│  Time: O(26) per comparison                                 │
│  Simple but not optimal                                     │
│                                                             │
│  METHOD 2: Matches Counter                                  │
│  ───────────────────────────                                │
│  Track how many positions match                             │
│  if matches == 26:                                          │
│  Time: O(1) per comparison                                  │
│  Optimal for fixed charset                                  │
│                                                             │
│  METHOD 3: Have/Need with Formed Counter                    │
│  ───────────────────────────────────────                    │
│  Track unique chars satisfied                               │
│  if formed == required:                                     │
│  Time: O(1) per comparison                                  │
│  Best for variable-size windows                             │
│                                                             │
│  METHOD 4: Array Difference                                 │
│  ─────────────────────────                                  │
│  diff[c] = p_count[c] - s_count[c]                          │
│  if all diff == 0:                                          │
│  Alternative to matches counter                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 8.8 Chapter Summary

```
┌─────────────────────────────────────────────────────────────┐
│            STRING SLIDING WINDOW KEY POINTS                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. ANAGRAM/PERMUTATION: Fixed-size window                  │
│     • Window size = pattern length                          │
│     • Compare frequency maps                                │
│                                                             │
│  2. OPTIMIZATION: Use matches/formed counter                │
│     • O(1) comparison instead of O(26)                      │
│     • Update counter when adding/removing characters        │
│                                                             │
│  3. LONGEST SUBSTRING: Variable-size window                 │
│     • Without repeating: track last index of each char      │
│     • At most K distinct: track frequency map size          │
│                                                             │
│  4. CONCATENATION: Multiple starting positions              │
│     • Try each start position from 0 to word_len-1          │
│     • Slide by word_len instead of 1                        │
│                                                             │
│  5. CHOOSE DATA STRUCTURE:                                  │
│     • Fixed small charset → Array [0]*26                    │
│     • Variable charset → HashMap                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 8.9 Practice Problems

| Problem | Pattern | Difficulty |
|---------|---------|------------|
| Find All Anagrams (LC 438) | Anagram | Medium |
| Permutation in String (LC 567) | Permutation | Medium |
| Longest Substring Without Repeating (LC 3) | Unique Chars | Medium |
| Longest Substring with K Distinct (LC 340) | At Most K | Medium |
| Longest Repeating Character Replacement (LC 424) | Replacement | Medium |
| Substring with Concatenation (LC 30) | Concatenation | Hard |
| Minimum Window Substring (LC 76) | Pattern Match | Hard |
