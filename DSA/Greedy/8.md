# Chapter 8: Practice Strategy

## 8.1 Difficulty Progression System

A structured approach to build from beginner to expert level.

### The Learning Pyramid

```python
class GreedyLearningPath:
    """
    Structured learning path for mastering greedy algorithms.
    """
    
    def __init__(self):
        self.levels = {
            'Foundation': {
                'problems': 10,
                'difficulty': 'Easy',
                'time_per_problem': 15,
                'focus': 'Pattern recognition and basic implementation'
            },
            'Intermediate': {
                'problems': 25,
                'difficulty': 'Medium',
                'time_per_problem': 30,
                'focus': 'Multiple criteria, proof thinking'
            },
            'Advanced': {
                'problems': 20,
                'difficulty': 'Hard',
                'time_per_problem': 45,
                'focus': 'Complex patterns, optimization'
            }
        }
    
    def print_roadmap(self):
        print("=" * 60)
        print("GREEDY ALGORITHMS MASTERY ROADMAP")
        print("=" * 60)
        
        total_hours = 0
        
        for level, details in self.levels.items():
            hours = (details['problems'] * details['time_per_problem']) / 60
            total_hours += hours
            
            print(f"\n{level.upper()} LEVEL")
            print(f"{'─' * 60}")
            print(f"  Problems: {details['problems']}")
            print(f"  Difficulty: {details['difficulty']}")
            print(f"  Time per problem: {details['time_per_problem']} minutes")
            print(f"  Focus: {details['focus']}")
            print(f"  Total time: {hours:.1f} hours")
        
        print(f"\n{'=' * 60}")
        print(f"TOTAL TIME TO MASTERY: {total_hours:.1f} hours")
        print(f"Recommended: 1-2 hours/day = {total_hours/1.5:.0f}-{total_hours:.0f} days")
        print("=" * 60)

roadmap = GreedyLearningPath()
roadmap.print_roadmap()
```

### Phase 1: Foundation (10-15 Problems)

```python
FOUNDATION_PROBLEMS = {
    'Week 1: Basic Greedy Intuition': [
        {
            'name': 'Assign Cookies',
            'leetcode': 455,
            'difficulty': 'Easy',
            'pattern': 'Sorting + Greedy',
            'key_learning': 'Sort both arrays, greedy match',
            'time_target': '10 min'
        },
        {
            'name': 'Lemonade Change',
            'leetcode': 860,
            'difficulty': 'Easy',
            'pattern': 'Greedy + State',
            'key_learning': 'Track state, make local decisions',
            'time_target': '15 min'
        },
        {
            'name': 'Best Time to Buy and Sell Stock II',
            'leetcode': 122,
            'difficulty': 'Easy',
            'pattern': 'Greedy accumulation',
            'key_learning': 'Capture all profitable differences',
            'time_target': '10 min'
        }
    ],
    
    'Week 2: Interval Basics': [
        {
            'name': 'Meeting Rooms',
            'leetcode': 252,
            'difficulty': 'Easy',
            'pattern': 'Interval sorting',
            'key_learning': 'Sort and check overlaps',
            'time_target': '15 min'
        },
        {
            'name': 'Merge Intervals',
            'leetcode': 56,
            'difficulty': 'Medium',
            'pattern': 'Interval merging',
            'key_learning': 'Sort by start, merge overlapping',
            'time_target': '20 min'
        },
        {
            'name': 'Non-overlapping Intervals',
            'leetcode': 435,
            'difficulty': 'Medium',
            'pattern': 'Interval selection',
            'key_learning': 'Sort by end time, count',
            'time_target': '20 min'
        }
    ]
}

def print_foundation_plan():
    print("\n" + "=" * 60)
    print("FOUNDATION PHASE: Problem List")
    print("=" * 60)
    
    for week, problems in FOUNDATION_PROBLEMS.items():
        print(f"\n{week}")
        print("─" * 60)
        
        for i, p in enumerate(problems, 1):
            print(f"\n{i}. {p['name']} (LC {p['leetcode']}) - {p['difficulty']}")
            print(f"   Pattern: {p['pattern']}")
            print(f"   Key Learning: {p['key_learning']}")
            print(f"   Target Time: {p['time_target']}")

print_foundation_plan()
```

### Phase 2: Intermediate (25-30 Problems)

```python
INTERMEDIATE_PROBLEMS = {
    'Interval Mastery (8 problems)': [
        'Meeting Rooms II (LC 253)',
        'Insert Interval (LC 57)',
        'Minimum Number of Arrows (LC 452)',
        'Interval List Intersections (LC 986)',
        'Remove Covered Intervals (LC 1288)',
        'Maximum Number of Events (LC 1353)',
        'Video Stitching (LC 1024)',
        'Divide Intervals Into Min Groups (LC 2406)'
    ],
    
    'Priority Queue + Greedy (8 problems)': [
        'Kth Largest Element (LC 215)',
        'K Closest Points (LC 973)',
        'Top K Frequent Elements (LC 347)',
        'Task Scheduler (LC 621)',
        'Reorganize String (LC 767)',
        'Furthest Building (LC 1642)',
        'IPO (LC 502)',
        'Find Median from Data Stream (LC 295)'
    ],
    
    'Array Partitioning (7 problems)': [
        'Jump Game (LC 55)',
        'Jump Game II (LC 45)',
        'Gas Station (LC 134)',
        'Candy (LC 135)',
        'Partition Labels (LC 763)',
        'Hand of Straights (LC 846)',
        'Maximize Sum Of Array (LC 1589)'
    ]
}

def print_intermediate_plan():
    print("\n" + "=" * 60)
    print("INTERMEDIATE PHASE: Categories")
    print("=" * 60)
    
    for category, problems in INTERMEDIATE_PROBLEMS.items():
        print(f"\n{category}")
        print("─" * 60)
        for i, problem in enumerate(problems, 1):
            print(f"  {i}. {problem}")

print_intermediate_plan()
```

### Phase 3: Advanced (20-25 Problems)

```python
ADVANCED_PROBLEMS = {
    'Mathematical Greedy (5 problems)': [
        'Best Meeting Point (LC 296)',
        'Minimum Moves to Equal Array II (LC 462)',
        'Valid Triangle Number (LC 611)',
        'Bag of Tokens (LC 948)',
        'Maximize Score After N Operations (LC 1799)'
    ],
    
    'Complex State (5 problems)': [
        'Best Time to Buy/Sell Stock with Cooldown (LC 309)',
        'Best Time to Buy/Sell Stock with Fee (LC 714)',
        'Queue Reconstruction by Height (LC 406)',
        'Minimum Deletions to Make Character Frequencies Unique (LC 1647)',
        'Reduction Operations to Make Array Equal (LC 1887)'
    ],
    
    'Graph Greedy (5 problems)': [
        'Network Delay Time (LC 743)',
        'Min Cost to Connect All Points (LC 1584)',
        'Path with Maximum Probability (LC 1514)',
        'Swim in Rising Water (LC 778)',
        'Cheapest Flights K Stops (LC 787)'
    ],
    
    'Advanced Patterns (5 problems)': [
        'Remove K Digits (LC 402)',
        'Remove Duplicate Letters (LC 316)',
        'Course Schedule III (LC 630)',
        'Minimum Cost to Hire K Workers (LC 857)',
        'Maximum Performance of a Team (LC 1383)'
    ]
}

def print_advanced_plan():
    print("\n" + "=" * 60)
    print("ADVANCED PHASE: Mastery Problems")
    print("=" * 60)
    
    for category, problems in ADVANCED_PROBLEMS.items():
        print(f"\n{category}")
        print("─" * 60)
        for i, problem in enumerate(problems, 1):
            print(f"  {i}. {problem}")

print_advanced_plan()
```

---

## 8.2 The Deliberate Practice Framework

Not just solving problems, but learning from each one.

### The 5-Step Learning Process

```python
class DeliberatePracticeFramework:
    """
    Framework for extracting maximum learning from each problem.
    """
    
    def __init__(self, problem_name):
        self.problem = problem_name
        self.learnings = {
            'pattern': None,
            'key_insight': None,
            'mistakes': [],
            'variations': [],
            'proof': None
        }
    
    def step1_understand(self):
        """Step 1: Understand the problem deeply."""
        return """
        ────────────────────────────────────────────────────────
        STEP 1: DEEP UNDERSTANDING (5 minutes)
        ────────────────────────────────────────────────────────
        
        Questions to answer:
        □ What exactly are we optimizing? (max/min what?)
        □ What are the constraints?
        □ What are the edge cases?
        □ Can I draw a picture or diagram?
        □ What happens with 2-3 elements?
        
        Example Walkthrough:
        □ Work through 2-3 examples by hand
        □ Identify patterns in optimal solutions
        □ Note why certain choices are better
        """
    
    def step2_identify_pattern(self):
        """Step 2: Identify the greedy pattern."""
        return """
        ────────────────────────────────────────────────────────
        STEP 2: PATTERN IDENTIFICATION (5 minutes)
        ────────────────────────────────────────────────────────
        
        Pattern Checklist:
        □ Is it about intervals/scheduling?
           → Interval greedy (sort by end time)
        
        □ Need "best" element repeatedly?
           → Priority queue greedy
        
        □ Constraints from both directions?
           → Two-pass greedy
        
        □ About selection/assignment?
           → Sort + greedy traverse
        
        □ Graph with optimization?
           → Graph greedy (Dijkstra/MST)
        
        Key Question: WHY does greedy work here?
        □ Can explain with exchange argument?
        □ Can explain with stays-ahead proof?
        """
    
    def step3_implement(self):
        """Step 3: Implement cleanly."""
        return """
        ────────────────────────────────────────────────────────
        STEP 3: CLEAN IMPLEMENTATION (15-20 minutes)
        ────────────────────────────────────────────────────────
        
        Implementation Checklist:
        □ Handle edge cases first
        □ Use clear variable names
        □ Comment the greedy insight
        □ Keep main loop simple
        □ Track necessary state only
        
        Don't rush! Better to take 5 extra minutes for clean code.
        """
    
    def step4_test_and_debug(self):
        """Step 4: Test thoroughly."""
        return """
        ────────────────────────────────────────────────────────
        STEP 4: TESTING & DEBUGGING (5-10 minutes)
        ────────────────────────────────────────────────────────
        
        Test Cases:
        □ Given example
        □ Empty input
        □ Single element
        □ All same values
        □ Already sorted
        □ Reverse sorted
        □ Large values (overflow?)
        
        If Wrong Answer:
        □ Print intermediate state
        □ Check sorting criterion
        □ Verify greedy decision logic
        □ Check edge case handling
        """
    
    def step5_reflect(self):
        """Step 5: Reflect and generalize."""
        return """
        ────────────────────────────────────────────────────────
        STEP 5: REFLECTION & GENERALIZATION (10 minutes)
        ────────────────────────────────────────────────────────
        
        Critical Questions:
        □ What pattern did this problem use?
        □ What was the key greedy insight?
        □ What mistakes did I make?
        □ What variations exist?
        □ How would I explain the proof?
        
        Document:
        • Pattern name and template
        • Key insight in one sentence
        • Common mistakes to avoid
        • Similar problems to try next
        
        This reflection is MORE VALUABLE than solving the problem!
        It builds transferable pattern recognition.
        """
    
    def print_framework(self):
        print("=" * 60)
        print(f"DELIBERATE PRACTICE: {self.problem}")
        print("=" * 60)
        print(self.step1_understand())
        print(self.step2_identify_pattern())
        print(self.step3_implement())
        print(self.step4_test_and_debug())
        print(self.step5_reflect())

# Example usage
framework = DeliberatePracticeFramework("Meeting Rooms II")
framework.print_framework()
```

### Practice Log Template

```python
def create_practice_log():
    """
    Template for maintaining a practice log.
    """
    
    log_template = """
    ============================================================
    GREEDY ALGORITHM PRACTICE LOG
    ============================================================
    
    DATE: ___________
    PROBLEM: _________________________ (LC ___)
    DIFFICULTY: Easy / Medium / Hard
    TIME SPENT: ___ minutes
    
    ────────────────────────────────────────────────────────────
    PATTERN IDENTIFICATION
    ────────────────────────────────────────────────────────────
    Pattern Used: [ ] Interval  [ ] Heap  [ ] Two-pass  [ ] Other: _____
    
    Sorting Criterion: _________________________
    
    Greedy Insight (one sentence):
    _______________________________________________________________
    
    ────────────────────────────────────────────────────────────
    IMPLEMENTATION
    ────────────────────────────────────────────────────────────
    Time Complexity: _______
    Space Complexity: _______
    
    Key Code Snippet:
    ```
    
    
    ```
    
    ────────────────────────────────────────────────────────────
    MISTAKES & LEARNINGS
    ────────────────────────────────────────────────────────────
    Mistakes Made:
    1. _____________________________________________________
    2. _____________________________________________________
    
    What I Learned:
    1. _____________________________________________________
    2. _____________________________________________________
    
    ────────────────────────────────────────────────────────────
    SIMILAR PROBLEMS TO REVIEW
    ────────────────────────────────────────────────────────────
    1. _____________________________________________________
    2. _____________________________________________________
    
    ────────────────────────────────────────────────────────────
    CONFIDENCE LEVEL
    ────────────────────────────────────────────────────────────
    [ ] Need to redo
    [ ] Understood but need practice
    [ ] Confident, ready for similar problems
    [ ] Mastered, can explain to others
    
    ============================================================
    """
    
    print(log_template)

create_practice_log()
```

---

## 8.3 Common Mistakes and How to Avoid Them

### Mistake Analysis System

```python
class MistakeAnalyzer:
    """
    Analyze and learn from common mistakes.
    """
    
    COMMON_MISTAKES = {
        'Wrong Sorting Criterion': {
            'example': 'Job scheduling: sorting by duration instead of deadline',
            'symptoms': ['Wrong answer on some cases', 'Greedy seems to fail randomly'],
            'fix': 'Test multiple sorting strategies, use exchange argument to verify',
            'prevention': 'Always ask: "Why is this the right sorting order?"'
        },
        
        'Missing Edge Cases': {
            'example': 'Not handling empty array or single element',
            'symptoms': ['Runtime error', 'Wrong answer on simple cases'],
            'fix': 'Add explicit edge case handling at function start',
            'prevention': 'Write edge case handling before main logic'
        },
        
        'Off-by-One Errors': {
            'example': 'Using > instead of >= for interval overlap',
            'symptoms': ['Wrong answer on touching intervals', 'Boundary issues'],
            'fix': 'Carefully define what "overlap" means',
            'prevention': 'Test with touching intervals [1,2], [2,3]'
        },
        
        'Assuming Greedy Works': {
            'example': 'Using greedy for 0/1 knapsack',
            'symptoms': ['Fails some test cases', 'Can find counterexample'],
            'fix': 'Switch to DP',
            'prevention': 'Always test for counterexamples before implementing'
        },
        
        'Wrong Heap Type': {
            'example': 'Using min-heap when need max-heap',
            'symptoms': ['Getting opposite results', 'Wrong ordering'],
            'fix': 'Negate values for max-heap in Python',
            'prevention': 'Clearly state what "best" means (min or max)'
        }
    }
    
    def print_mistake_guide(self):
        print("=" * 60)
        print("COMMON MISTAKES & PREVENTION GUIDE")
        print("=" * 60)
        
        for i, (mistake, details) in enumerate(self.COMMON_MISTAKES.items(), 1):
            print(f"\n{i}. {mistake}")
            print("─" * 60)
            print(f"Example: {details['example']}")
            print(f"\nSymptoms:")
            for symptom in details['symptoms']:
                print(f"  • {symptom}")
            print(f"\nFix: {details['fix']}")
            print(f"Prevention: {details['prevention']}")

analyzer = MistakeAnalyzer()
analyzer.print_mistake_guide()
```

---

## 8.4 Spaced Repetition Schedule

```python
class SpacedRepetitionSchedule:
    """
    Optimal review schedule for long-term retention.
    """
    
    def __init__(self):
        self.intervals = [1, 3, 7, 14, 30]  # days
    
    def create_schedule(self, problems_per_week=10):
        print("=" * 60)
        print("SPACED REPETITION SCHEDULE")
        print("=" * 60)
        print("""
        Based on forgetting curve research:
        - Review after 1 day: Retention boost 20%
        - Review after 3 days: Retention boost 40%
        - Review after 1 week: Retention boost 60%
        - Review after 2 weeks: Long-term memory
        - Review after 1 month: Mastery
        """)
        
        print("\n" + "=" * 60)
        print(f"WEEKLY SCHEDULE (solving {problems_per_week} new problems/week)")
        print("=" * 60)
        
        schedule = """
        WEEK 1: Foundation
        Monday:    Solve problems 1-2 (new)
        Tuesday:   Review problems 1-2
        Wednesday: Solve problems 3-4 (new)
        Thursday:  Review problems 1-2, 3-4
        Friday:    Solve problems 5-6 (new)
        Saturday:  Review problems 3-4, 5-6
        Sunday:    Review all Week 1 problems
        
        WEEK 2: Building
        Monday:    Solve problems 7-8 (new)
        Tuesday:   Review problems 1-2 (1 week review)
        Wednesday: Solve problems 9-10 (new)
        Thursday:  Review problems 7-10
        Friday:    Solve problems 11-12 (new)
        Saturday:  Review problems 9-12
        Sunday:    Review problems 1-6 (1 week review)
        
        WEEK 3: Intermediate
        Monday:    Solve problems 13-14 (new)
        Tuesday:   Review problems 7-8 (1 week review)
        Wednesday: Solve problems 15-16 (new)
        Thursday:  Review problems 13-16
        Friday:    Solve problems 17-18 (new)
        Saturday:  Review problems 15-18
        Sunday:    Review problems 1-12 (2+ week review)
        
        KEY PRINCIPLES:
        • New problems when fresh (Monday, Wednesday, Friday)
        • Review same day after solving
        • Review 1 day later
        • Review 1 week later
        • Review 2 weeks later
        • Review before interviews
        """
        
        print(schedule)

schedule_manager = SpacedRepetitionSchedule()
schedule_manager.create_schedule()
```

---

## 8.5 Tracking Progress

```python
class ProgressTracker:
    """
    Track and visualize progress over time.
    """
    
    def __init__(self):
        self.skills = {
            'Pattern Recognition': 0,
            'Implementation Speed': 0,
            'Proof Explanation': 0,
            'Edge Case Handling': 0,
            'Time/Space Analysis': 0
        }
    
    def print_rubric(self):
        print("=" * 60)
        print("SKILL ASSESSMENT RUBRIC")
        print("=" * 60)
        
        rubric = """
        After each problem, rate yourself 1-5 on these skills:
        
        1. PATTERN RECOGNITION (Did you identify the pattern?)
           1 = Couldn't identify at all
           2 = Needed hints
           3 = Identified after thinking
           4 = Identified quickly
           5 = Identified immediately
        
        2. IMPLEMENTATION SPEED (How quickly did you code?)
           1 = Very slow, many attempts
           2 = Slow but got there
           3 = Reasonable pace
           4 = Quick with minor issues
           5 = Fast and clean
        
        3. PROOF EXPLANATION (Can you explain why greedy works?)
           1 = Can't explain
           2 = Vague explanation
           3 = Can explain with examples
           4 = Can give proof sketch
           5 = Can give rigorous proof
        
        4. EDGE CASE HANDLING (Did you catch edge cases?)
           1 = Missed most edge cases
           2 = Caught some after failing
           3 = Caught most proactively
           4 = Caught all common ones
           5 = Caught all + unusual ones
        
        5. COMPLEXITY ANALYSIS (Correct time/space analysis?)
           1 = Incorrect analysis
           2 = Correct with help
           3 = Correct for simple cases
           4 = Correct with explanation
           5 = Instant and precise
        
        ────────────────────────────────────────────────────────
        TRACK YOUR AVERAGE:
        - Week 1-2: Expect 2-3 average (learning)
        - Week 3-4: Expect 3-4 average (improving)
        - Week 5+: Target 4-5 average (proficient)
        
        Ready for interviews when: All skills at 4+
        ────────────────────────────────────────────────────────
        """
        
        print(rubric)
    
    def print_weekly_goals(self):
        print("\n" + "=" * 60)
        print("WEEKLY IMPROVEMENT GOALS")
        print("=" * 60)
        
        goals = """
        Week 1-2: Foundation
        • Solve 10-15 easy problems
        • Goal: Recognize basic patterns
        • Focus: Interval and sorting patterns
        
        Week 3-4: Building
        • Solve 15-20 medium problems
        • Goal: Identify pattern within 2 minutes
        • Focus: Heap and multi-criteria problems
        
        Week 5-6: Acceleration
        • Solve 20-25 medium problems
        • Goal: Implement within 15 minutes
        • Focus: Complex patterns and proofs
        
        Week 7-8: Mastery
        • Solve 15-20 hard problems
        • Goal: Explain proof to others
        • Focus: Mathematical insights and optimization
        
        Week 9-10: Polish
        • Review all problems
        • Mock interviews
        • Goal: <15min for medium, <30min for hard
        """
        
        print(goals)

tracker = ProgressTracker()
tracker.print_rubric()
tracker.print_weekly_goals()
```

---

## Summary: The Practice Blueprint

```python
def print_practice_blueprint():
    """
    Complete blueprint for mastering greedy algorithms.
    """
    
    blueprint = """
    ============================================================
    GREEDY ALGORITHMS: COMPLETE PRACTICE BLUEPRINT
    ============================================================
    
    PHASE 1: FOUNDATION (2 weeks, 15 problems)
    ────────────────────────────────────────────────────────────
    Focus: Pattern recognition
    Time: 1 hour/day
    Success: Can identify basic patterns in 30 seconds
    
    PHASE 2: INTERMEDIATE (3-4 weeks, 25 problems)
    ────────────────────────────────────────────────────────────
    Focus: Implementation and variations
    Time: 1.5 hours/day
    Success: Can solve medium problems in 20 minutes
    
    PHASE 3: ADVANCED (3-4 weeks, 20 problems)
    ────────────────────────────────────────────────────────────
    Focus: Complex patterns and proofs
    Time: 2 hours/day
    Success: Can explain proofs, handle hard problems
    
    PHASE 4: MASTERY (2 weeks, review)
    ────────────────────────────────────────────────────────────
    Focus: Speed and polish
    Time: 1.5 hours/day
    Success: Interview-ready speed and confidence
    
    ────────────────────────────────────────────────────────────
    DAILY ROUTINE:
    ────────────────────────────────────────────────────────────
    1. Review previous day's problem (10 min)
    2. Solve new problem with deliberate practice (40 min)
    3. Document learnings (10 min)
    4. Review one old problem (10 min)
    
    ────────────────────────────────────────────────────────────
    WEEKLY CHECKPOINTS:
    ────────────────────────────────────────────────────────────
    • Sunday: Review all week's problems
    • Self-assess on skill rubric
    • Identify weak areas
    • Plan next week's focus
    
    ────────────────────────────────────────────────────────────
    SUCCESS METRICS:
    ────────────────────────────────────────────────────────────
    Ready for interviews when you can:
    ✓ Identify pattern in 1-2 minutes
    ✓ Implement medium problems in 15-20 minutes
    ✓ Explain why greedy works
    ✓ Handle edge cases proactively
    ✓ Analyze time/space complexity correctly
    
    TOTAL TIME TO MASTERY: 10-12 weeks of focused practice
    ============================================================
    """
    
    print(blueprint)

print_practice_blueprint()
```

This completes Chapter 8 with a complete, actionable practice strategy!