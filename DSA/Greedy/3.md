# Chapter 3: Advanced Greedy Patterns

## 3.1 Greedy with Priority Queue / Heap

Priority queues enable dynamic greedy choices where elements arrive over time or priorities change as we process.

### Why Heap for Greedy?

**Key Insight**: When you need to repeatedly access the "best" element and the set of elements changes dynamically, use a heap.

```python
# Without heap: O(n²)
for each iteration:
    find minimum/maximum: O(n)
    
# With heap: O(n log n)
for each iteration:
    pop minimum/maximum: O(log n)
```

### Pattern 1: IPO (Maximum Capital)

**LeetCode 502: Find Maximum Capitalized**

This is a classic greedy + heap problem that appears frequently.

```python
import heapq

def find_maximized_capital(k, w, profits, capital):
    """
    Select at most k projects to maximize capital.
    
    Args:
        k: maximum projects can select
        w: initial capital
        profits: profit of each project
        capital: minimum capital needed for each project
    
    Greedy Strategy:
    1. Sort projects by capital required
    2. At each step, add all affordable projects to max-heap (by profit)
    3. Pick project with maximum profit
    4. Update capital and repeat
    
    Time: O(n log n + k log n)
    Space: O(n)
    """
    n = len(profits)
    projects = [(capital[i], profits[i]) for i in range(n)]
    projects.sort()  # Sort by capital required
    
    max_heap = []  # Max heap of profits (negate for Python's min heap)
    current_capital = w
    project_idx = 0
    
    print(f"Initial capital: {current_capital}")
    print(f"Available projects (capital, profit): {projects}\n")
    
    for i in range(k):
        # Add all projects we can afford to the heap
        while project_idx < n and projects[project_idx][0] <= current_capital:
            cap, prof = projects[project_idx]
            heapq.heappush(max_heap, -prof)  # Negative for max heap
            print(f"Can afford project with capital={cap}, profit={prof}")
            project_idx += 1
        
        # If no affordable projects, we're done
        if not max_heap:
            print(f"\nNo more affordable projects. Final capital: {current_capital}")
            break
        
        # Pick project with maximum profit
        max_profit = -heapq.heappop(max_heap)
        current_capital += max_profit
        print(f"→ Select project with profit={max_profit}, new capital={current_capital}\n")
    
    return current_capital

# Example
k = 2  # Can do 2 projects
w = 0  # Start with 0 capital
profits = [1, 2, 3]
capital = [0, 1, 1]

result = find_maximized_capital(k, w, profits, capital)
print(f"Maximum capital: {result}")

# Explanation:
# Projects sorted by capital: [(0,1), (1,2), (1,3)]
# 
# Initially capital = 0:
#   Affordable: project with capital=0, profit=1
#   Select it: capital = 0 + 1 = 1
# 
# Now capital = 1:
#   Affordable: projects with capital=1, profit=2 and profit=3
#   Select profit=3: capital = 1 + 3 = 4
# 
# Final capital: 4
```

**Why This Greedy Works**:
```python
# Proof intuition:
# 
# 1. At each step, we have current capital C
# 2. We can afford projects with capital requirement ≤ C
# 3. Among affordable projects, picking highest profit maximizes our capital
# 4. More capital → more projects become affordable
# 5. So greedy (max profit among affordable) is optimal
#
# Key: We're making irreversible choices, but each choice maximizes
# our ability to make future choices (by maximizing capital)
```

### Pattern 2: Minimum Cost to Hire K Workers

**LeetCode 857: Minimum Cost to Hire K Workers**

This is a hard problem that combines ratios, heaps, and greedy strategy.

```python
import heapq

def min_cost_to_hire_workers(quality, wage, k):
    """
    Hire exactly k workers with minimum total wage.
    
    Constraint: wage[i] / quality[i] ≥ some common ratio for all hired workers
    
    Greedy Strategy:
    1. Sort by wage/quality ratio
    2. Use max-heap to maintain k workers with lowest total quality
    3. For each ratio, calculate cost if we hire k workers with this ratio
    
    Time: O(n log n + n log k)
    Space: O(n)
    """
    n = len(quality)
    workers = []
    
    # Create (ratio, quality, wage) tuples
    for i in range(n):
        ratio = wage[i] / quality[i]
        workers.append((ratio, quality[i], wage[i]))
    
    # Sort by ratio
    workers.sort()
    
    max_heap = []  # Max heap of qualities (to remove highest quality)
    quality_sum = 0
    min_cost = float('inf')
    
    print(f"Workers sorted by wage/quality ratio:")
    for i, (ratio, qual, w) in enumerate(workers):
        print(f"  Worker {i}: quality={qual}, wage={w}, ratio={ratio:.2f}")
    print()
    
    for i, (ratio, qual, w) in enumerate(workers):
        # Add current worker
        heapq.heappush(max_heap, -qual)  # Negative for max heap
        quality_sum += qual
        
        # If we have more than k workers, remove highest quality
        if len(max_heap) > k:
            removed_quality = -heapq.heappop(max_heap)
            quality_sum -= removed_quality
            print(f"Step {i}: Removed worker with quality={removed_quality}")
        
        # If we have exactly k workers, calculate cost
        if len(max_heap) == k:
            cost = quality_sum * ratio
            print(f"Step {i}: k={k} workers, quality_sum={quality_sum}, "
                  f"ratio={ratio:.2f}, cost={cost:.2f}")
            min_cost = min(min_cost, cost)
    
    return min_cost

# Example
quality = [10, 20, 5]
wage = [70, 50, 30]
k = 2

result = min_cost_to_hire_workers(quality, wage, k)
print(f"\nMinimum cost: {result:.2f}")

# Explanation:
# Worker 0: quality=10, wage=70, ratio=7.0
# Worker 1: quality=20, wage=50, ratio=2.5
# Worker 2: quality=5, wage=30, ratio=6.0
#
# Sorted by ratio: Worker 1 (2.5), Worker 2 (6.0), Worker 0 (7.0)
#
# When we include Worker 1 (ratio=2.5): Can't have k=2 yet
# When we include Worker 2 (ratio=6.0): Have [Worker 1, Worker 2]
#   Cost = (20 + 5) * 6.0 = 150
# When we include Worker 0 (ratio=7.0): Replace Worker 1 (highest quality)
#   Cost = (5 + 10) * 7.0 = 105 ← Minimum!
```

### Pattern 3: Task Scheduler with Cooldown

**LeetCode 621: Task Scheduler (Heap Approach)**

```python
from collections import Counter
import heapq

def least_interval_heap(tasks, n):
    """
    Schedule tasks with cooldown period n.
    
    Greedy with Heap:
    1. Always execute most frequent available task
    2. Track cooldown with queue
    3. Use heap to get most frequent task efficiently
    
    Time: O(N log 26) ≈ O(N)
    Space: O(26) = O(1)
    """
    freq = Counter(tasks)
    max_heap = [-count for count in freq.values()]
    heapq.heapify(max_heap)
    
    time = 0
    cooldown_queue = []  # (available_time, frequency)
    
    while max_heap or cooldown_queue:
        time += 1
        
        # Add back tasks that finished cooldown
        while cooldown_queue and cooldown_queue[0][0] == time:
            _, freq = cooldown_queue.pop(0)
            heapq.heappush(max_heap, -freq)
        
        if max_heap:
            # Execute most frequent task
            freq = -heapq.heappop(max_heap)
            freq -= 1
            
            if freq > 0:
                # Add to cooldown queue
                available_at = time + n + 1
                cooldown_queue.append((available_at, freq))
            
            print(f"Time {time}: Execute task (remaining: {freq})")
        else:
            print(f"Time {time}: Idle")
    
    return time

# Example
tasks = ['A', 'A', 'A', 'B', 'B', 'B']
n = 2

result = least_interval_heap(tasks, n)
print(f"\nTotal time: {result}")

# Timeline:
# Time 1: Execute A (2 remaining), cooldown until 4
# Time 2: Execute B (2 remaining), cooldown until 5
# Time 3: Idle (both A and B in cooldown)
# Time 4: Execute A (1 remaining), cooldown until 7
# Time 5: Execute B (1 remaining), cooldown until 8
# Time 6: Idle
# Time 7: Execute A (0 remaining)
# Time 8: Execute B (0 remaining)
```

### Pattern 4: Merge K Sorted Lists (Greedy + Heap)

```python
import heapq

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
    
    def __lt__(self, other):
        # For heap comparison
        return self.val < other.val

def merge_k_lists(lists):
    """
    Merge k sorted linked lists.
    
    Greedy: Always take the smallest head from k lists
    Use min-heap to efficiently get minimum
    
    Time: O(N log k) where N = total nodes, k = number of lists
    Space: O(k) for heap
    """
    heap = []
    
    # Add first node of each list to heap
    for i, head in enumerate(lists):
        if head:
            # Use (val, list_idx, node) to handle ties
            heapq.heappush(heap, (head.val, i, head))
    
    dummy = ListNode(0)
    current = dummy
    
    while heap:
        val, list_idx, node = heapq.heappop(heap)
        
        # Add to result
        current.next = node
        current = current.next
        
        # If this list has more nodes, add next node to heap
        if node.next:
            heapq.heappush(heap, (node.next.val, list_idx, node.next))
    
    return dummy.next

# Helper function to create linked list
def create_list(arr):
    dummy = ListNode(0)
    current = dummy
    for val in arr:
        current.next = ListNode(val)
        current = current.next
    return dummy.next

# Helper function to print list
def print_list(head):
    result = []
    while head:
        result.append(head.val)
        head = head.next
    return result

# Example
lists = [
    create_list([1, 4, 5]),
    create_list([1, 3, 4]),
    create_list([2, 6])
]

result = merge_k_lists(lists)
print(f"Merged list: {print_list(result)}")
# Output: [1, 1, 2, 3, 4, 4, 5, 6]
```

---

## 3.2 Exchange Argument / Greedy Stays Ahead

These are proof techniques to verify greedy correctness. Essential for interviews when asked "why does this work?"

### Technique 1: Exchange Argument

**Template**:
1. Assume optimal solution O differs from greedy solution G
2. Find first place they differ
3. Show you can "exchange" O's choice with G's choice
4. Prove exchange doesn't worsen solution (may improve it)
5. By induction, G is optimal

**Example: Activity Selection Proof**

```python
def activity_selection_with_proof():
    """
    Prove: Selecting activity with earliest finish time is optimal
    
    Exchange Argument:
    
    Let G = greedy solution (earliest finish time)
    Let O = optimal solution
    
    If G ≠ O, let a₁ be first activity in G, and b₁ be first in O
    
    Case 1: a₁ = b₁
        → G and O agree on first choice, check remaining activities
    
    Case 2: a₁ ≠ b₁
        → finish(a₁) ≤ finish(b₁) (by greedy choice)
        → We can replace b₁ with a₁ in O
        → Since a₁ finishes earlier, it doesn't conflict with other activities in O
        → New solution O' is still valid and has same size as O
        → O' starts with a₁ like G
    
    By induction on subsequent choices, G is optimal.
    """
    pass

# Visualization of exchange:
print("""
Original Optimal (O):
Time: 0    5    10   15   20   25
      [----b₁---]
           [---b₂---]
                    [--b₃--]

Greedy choice a₁ finishes earlier:
Time: 0    5    10   15   20   25
      [-a₁-]
           [---b₂---]
                    [--b₃--]

Exchange b₁ → a₁:
- Still have 3 activities ✓
- No conflicts (a₁ ends before b₂ starts) ✓
- Therefore greedy choice can be in optimal solution ✓
""")
```

### Technique 2: Greedy Stays Ahead

**Template**:
1. Show greedy solution is "ahead" of any other solution at every step
2. If greedy is always ahead, it must be at least as good

**Example: Fractional Knapsack Proof**

```python
def fractional_knapsack_proof():
    """
    Prove: Taking highest value/weight ratio first is optimal
    
    Greedy Stays Ahead Argument:
    
    Greedy G: Take items by decreasing value/weight ratio
    Any other solution S
    
    After taking k items:
    - G has taken items with ratios: r₁ ≥ r₂ ≥ ... ≥ rₖ
    - S has taken items with ratios: s₁, s₂, ..., sₖ (not necessarily sorted)
    
    Claim: Value(G) ≥ Value(S) for same weight
    
    Proof:
    For any item with ratio r in S but not in G:
        There must be an item with ratio ≥ r in G (by greedy choice)
        We can swap them without decreasing value
    
    Therefore G is optimal.
    """
    pass

# Concrete example:
def demonstrate_stays_ahead():
    items = [
        ("A", 60, 10, 6.0),   # value, weight, ratio
        ("B", 100, 20, 5.0),
        ("C", 120, 30, 4.0)
    ]
    capacity = 50
    
    print("Greedy solution (by ratio):")
    greedy_value = 60 + 100 + (20/30)*120  # A + B + 2/3 of C
    print(f"Take A, B, 2/3 of C: value = {greedy_value}")
    
    print("\nAlternative solution:")
    alt_value = 120 + (30/20)*100  # C + 3/2 of B (if possible)
    print(f"Take C, 3/2 of B: value = {alt_value}")
    print(f"But wait, 3/2 of B needs weight 30, total = 60 > capacity!")
    
    print("\nValid alternative:")
    alt_value2 = 120 + 100  # C + B
    print(f"Take C, B: value = {alt_value2} with weight = 50")
    print(f"This gives same value as greedy!")
    
    print("\nConclusion: Greedy achieves optimal value")

demonstrate_stays_ahead()
```

### Real Interview Example: Prove Interval Scheduling

```python
def prove_interval_scheduling():
    """
    Problem: Maximum non-overlapping intervals
    Claim: Earliest finish time is optimal
    
    Interview Answer Template:
    """
    proof = """
    I'll use an exchange argument to prove correctness:
    
    1. Sort intervals by finish time: I₁, I₂, ..., Iₙ
       where finish(I₁) ≤ finish(I₂) ≤ ... ≤ finish(Iₙ)
    
    2. Greedy selects I₁ first (earliest finish)
    
    3. Suppose optimal solution O doesn't include I₁
       O selects some other interval J₁ first
    
    4. Since I₁ finishes earliest: finish(I₁) ≤ finish(J₁)
    
    5. Replace J₁ with I₁ in O:
       - I₁ finishes no later than J₁
       - Any interval compatible with J₁ is compatible with I₁
       - New solution O' has same size as O
    
    6. O' includes I₁ and is optimal
    
    7. By induction on remaining intervals, greedy is optimal
    
    Key insight: Finishing early leaves maximum room for future activities
    """
    print(proof)

prove_interval_scheduling()
```

---

## 3.3 Greedy with State Machines

State machines track different situations/modes, greedy choice depends on current state.

### Pattern: Stock Trading with States

**LeetCode 309: Best Time to Buy and Sell Stock with Cooldown**

```python
def max_profit_with_cooldown(prices):
    """
    Stock trading with cooldown: after selling, must wait 1 day
    
    States:
    - hold: currently holding stock
    - sold: just sold stock (must cooldown)
    - rest: not holding, not in cooldown
    
    Greedy Transitions:
    - hold → hold (do nothing) OR rest → hold (buy)
    - hold → sold (sell)
    - sold → rest (cooldown)
    - rest → rest (do nothing) OR rest → hold (buy)
    
    Time: O(n)
    Space: O(1)
    """
    if not prices:
        return 0
    
    # Initialize states
    hold = -prices[0]  # Bought on day 0
    sold = 0           # Can't sell on day 0
    rest = 0           # Start with resting
    
    print(f"Day 0: hold={hold}, sold={sold}, rest={rest}")
    
    for i in range(1, len(prices)):
        prev_hold = hold
        prev_sold = sold
        prev_rest = rest
        
        # Update each state with best transition
        hold = max(prev_hold, prev_rest - prices[i])
        sold = prev_hold + prices[i]
        rest = max(prev_rest, prev_sold)
        
        print(f"Day {i} (price={prices[i]}): hold={hold}, sold={sold}, rest={rest}")
    
    # Maximum profit is either resting or just sold (not holding)
    return max(sold, rest)

# Example
prices = [1, 2, 3, 0, 2]
result = max_profit_with_cooldown(prices)
print(f"\nMaximum profit: {result}")

# Optimal: Buy at 1, sell at 3, cooldown, buy at 0, sell at 2
# Profit = (3-1) + (2-0) = 4
```

**State Diagram**:
```
        +------+
        | REST |<----+
        +------+     |
         |    ↑      |
     buy |    | cooldown
         ↓    |      |
        +------+     |
        | HOLD |     |
        +------+     |
         |           |
      sell           |
         |           |
         ↓           |
        +------+     |
        | SOLD |-----+
        +------+
```

### Pattern: Jump Game with States

**LeetCode 45: Jump Game II**

```python
def jump_game_ii(nums):
    """
    Minimum jumps to reach end.
    
    State: current position and farthest reachable
    Greedy: At each jump, go to position that maximizes next reach
    
    Time: O(n)
    Space: O(1)
    """
    if len(nums) <= 1:
        return 0
    
    jumps = 0
    current_end = 0      # End of current jump range
    farthest = 0         # Farthest position reachable
    
    print(f"Start at index 0, nums={nums}")
    
    for i in range(len(nums) - 1):
        # Update farthest reachable position
        farthest = max(farthest, i + nums[i])
        print(f"  Index {i}: can reach {i + nums[i]}, farthest={farthest}")
        
        # If we've reached end of current jump
        if i == current_end:
            jumps += 1
            current_end = farthest
            print(f"→ Jump {jumps}: new range [0, {current_end}]")
            
            if current_end >= len(nums) - 1:
                break
    
    return jumps

# Example
nums = [2, 3, 1, 1, 4]
result = jump_game_ii(nums)
print(f"\nMinimum jumps: {result}")

# Visualization:
# Index:  0  1  2  3  4
# Value:  2  3  1  1  4
# 
# Jump 1: From 0, can reach [1,2], choose range [0,2]
# Jump 2: From [1,2], can reach up to index 4, done!
```

### Pattern: Gas Station (State = Running Sum)

**LeetCode 134: Gas Station**

```python
def can_complete_circuit(gas, cost):
    """
    Find starting gas station to complete circular tour.
    
    State Machine Approach:
    - Track running tank balance
    - If balance goes negative, reset starting position
    - Greedy: First position where we never go negative is the answer
    
    Time: O(n)
    Space: O(1)
    """
    if sum(gas) < sum(cost):
        return -1  # Impossible to complete circuit
    
    tank = 0
    start = 0
    total_tank = 0
    
    print(f"Gas:  {gas}")
    print(f"Cost: {cost}\n")
    
    for i in range(len(gas)):
        tank += gas[i] - cost[i]
        total_tank += gas[i] - cost[i]
        
        print(f"Station {i}: gain={gas[i]}, cost={cost[i]}, "
              f"tank={tank}, start={start}")
        
        # If tank goes negative, can't start from current start
        if tank < 0:
            start = i + 1
            tank = 0
            print(f"  → Reset: new start={start}, tank={tank}")
    
    return start if total_tank >= 0 else -1

# Example
gas = [1, 2, 3, 4, 5]
cost = [3, 4, 5, 1, 2]

result = can_complete_circuit(gas, cost)
print(f"\nStart at station: {result}")

# Explanation:
# Start 0: 1-3 = -2 (negative) → can't start here
# Start 1: 2-4 = -2 (negative) → can't start here
# Start 2: 3-5 = -2 (negative) → can't start here
# Start 3: 4-1 = 3, then 5-2 = 6, then 1-3 = 4... (all positive) ✓
```

**Why Greedy Works for Gas Station**:
```python
def gas_station_proof():
    """
    Claim: If we start at station k and fail at station j,
           any station between k and j cannot be a valid start.
    
    Proof:
    - Let tank[i] = cumulative gain from k to i
    - We failed at j means tank[j] < 0
    - For any station m between k and j:
      * tank[m] = sum from k to m ≥ 0 (else we'd fail earlier)
      * tank[j] = tank[m] + sum from m+1 to j < 0
      * This means sum from m+1 to j < -tank[m] ≤ 0
      * So starting at m, we'd also fail at j
    
    Therefore, skip directly to j+1.
    """
    print("""
    Visual Proof:
    
    Station:  0   1   2   3   4
    Tank:     +1  -2  +3  -1  +2
    
    Start at 0:
      0→1: tank = 1
      1→2: tank = 1-2 = -1 (FAIL)
    
    Why not try starting at 1?
      We already know 0→1 gave us tank=1
      If we start at 1, we start with tank=0
      Since 0→1 helped (gave +1), starting at 1 is worse!
    
    So greedy skip to station 2.
    """)

gas_station_proof()
```

---

## 3.4 Reverse Greedy / Backward Greedy

Instead of building solution forward, work backward or remove elements.

### Pattern: Remove K Digits

**LeetCode 402: Remove K Digits**

```python
def remove_k_digits(num, k):
    """
    Remove k digits to make smallest possible number.
    
    Reverse Greedy: Remove digits that are larger than next digit
    Use stack to maintain increasing sequence
    
    Time: O(n)
    Space: O(n)
    """
    stack = []
    removed = 0
    
    print(f"Remove {k} digits from {num}")
    print(f"\nProcessing:")
    
    for digit in num:
        # Remove larger digits before current digit
        while stack and removed < k and stack[-1] > digit:
            removed_digit = stack.pop()
            removed += 1
            print(f"  Remove '{removed_digit}' (larger than '{digit}'), "
                  f"stack={stack}, removed={removed}")
        
        stack.append(digit)
        print(f"  Add '{digit}', stack={stack}")
    
    # If we haven't removed k digits, remove from end
    while removed < k:
        stack.pop()
        removed += 1
        print(f"  Remove from end, stack={stack}, removed={removed}")
    
    # Convert to string and remove leading zeros
    result = ''.join(stack).lstrip('0')
    return result if result else '0'

# Example
num = "1432219"
k = 3
result = remove_k_digits(num, k)
print(f"\nResult: {result}")

# Explanation:
# Original: 1432219
# Remove 4: 132219 (4 > 3, remove it)
# Remove 3: 12219 (3 > 2, remove it)
# Remove 2: 1219 (first 2 > 1? No. Next 2 > 1? Yes, remove second 2)
# Result: 1219
```

**Why Reverse Greedy Works**:
```python
def why_remove_works():
    """
    Intuition: To minimize number, want smaller digits in higher positions.
    
    If digit[i] > digit[i+1], removing digit[i] makes number smaller:
    
    Example: 1432
    - Remove 4: 132 < 1432 ✓
    
    Why not remove 3 instead?
    - Remove 3: 142
    - 132 < 142, so removing larger digit earlier is better
    
    Greedy choice: Always remove first decreasing digit
    """
    examples = [
        ("1234", 2, "12"),      # Remove from end (all increasing)
        ("4321", 2, "21"),      # Remove from start (all decreasing)
        ("10200", 1, "200"),    # Remove leading 1, then leading 0s
        ("112", 1, "11"),       # Remove last digit
    ]
    
    print("Examples of Remove K Digits:")
    for num, k, expected in examples:
        result = remove_k_digits(num, k)
        print(f"  {num}, k={k} → {result} (expected: {expected})")

why_remove_works()
```

### Pattern: Jump Game (Backward Greedy)

**LeetCode 55: Jump Game**

```python
def can_jump(nums):
    """
    Determine if you can reach last index.
    
    Backward Greedy: Start from end, find leftmost position that can reach current target
    
    Time: O(n)
    Space: O(1)
    """
    target = len(nums) - 1
    
    print(f"Can reach end? nums={nums}")
    print(f"Starting from target={target}\n")
    
    # Work backward
    for i in range(len(nums) - 2, -1, -1):
        max_jump = nums[i]
        
        if i + max_jump >= target:
            print(f"Index {i} (jump={max_jump}): can reach {target} ✓")
            target = i
        else:
            print(f"Index {i} (jump={max_jump}): cannot reach {target} ✗")
    
    return target == 0

# Example 1: Possible
nums1 = [2, 3, 1, 1, 4]
result1 = can_jump(nums1)
print(f"Result: {result1}\n")

# Example 2: Impossible
nums2 = [3, 2, 1, 0, 4]
result2 = can_jump(nums2)
print(f"Result: {result2}")

# Explanation for nums2:
# Target starts at 4
# Index 3: jump=0, cannot reach 4, target stays 4
# Index 2: jump=1, can reach 3 but not 4, target stays 4
# Index 1: jump=2, can reach 3 but not 4, target stays 4
# Index 0: jump=3, can reach 3 but not 4, target stays 4
# Final target ≠ 0, so impossible
```

---

## Summary: Advanced Pattern Recognition

```python
# Decision tree for advanced patterns:

def choose_advanced_pattern(problem):
    """
    Pattern selection guide for advanced problems
    """
    
    if "dynamic elements" in problem and "optimal at each step" in problem:
        return "Priority Queue Pattern"
    
    if "prove correctness" in problem:
        return "Exchange Argument or Stays Ahead"
    
    if "different modes" in problem or "state transitions" in problem:
        return "State Machine Pattern"
    
    if "remove elements" in problem or "work backward" in problem:
        return "Reverse Greedy Pattern"
    
    return "Combination of patterns"

# Key indicators:
ADVANCED_PATTERNS = {
    "Heap": ["maximize capital", "k closest", "kth largest", "meeting rooms"],
    "Proof": ["explain why greedy works", "prove optimality"],
    "State": ["stock trading", "cooldown", "modes", "game states"],
    "Reverse": ["remove k elements", "smallest/largest after removal", "backward search"],
}
```

### Practice Problems for Chapter 3

1. **Hard**: IPO (LC 502) - Heap
2. **Hard**: Minimum Cost to Hire K Workers (LC 857) - Heap + Ratio
3. **Medium**: Remove K Digits (LC 402) - Reverse Greedy
4. **Medium**: Jump Game II (LC 45) - State Machine
5. **Medium**: Best Time to Buy and Sell Stock with Cooldown (LC 309) - States
6. **Hard**: Gas Station (LC 134) - State tracking

Master these patterns and you'll handle most hard greedy problems!