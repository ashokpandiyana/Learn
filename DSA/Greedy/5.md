# Chapter 5: Hard Interview Patterns

## 5.1 Greedy with Mathematical Insight

The hardest greedy problems often require a mathematical observation before the greedy approach becomes clear. These are the "aha!" moment problems.

### Pattern 1: Median Minimizes Absolute Deviations

**Problem: Best Meeting Point (LeetCode 296)**

```python
def min_total_distance(grid):
    """
    Find meeting point that minimizes total Manhattan distance.
    
    Mathematical Insight:
    - For 1D: Median minimizes sum of absolute deviations
    - For 2D: Solve separately for x and y coordinates
    
    Why median works:
    - Adding one point moves total distance by difference in counts on each side
    - Median balances the counts, minimizing total
    
    Time: O(mn log mn) for sorting
    Space: O(mn) for collecting positions
    """
    if not grid or not grid[0]:
        return 0
    
    # Collect all positions
    rows = []
    cols = []
    
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                rows.append(i)
                cols.append(j)
    
    print(f"Positions of all people:")
    positions = list(zip(rows, cols))
    for i, pos in enumerate(positions):
        print(f"  Person {i}: {pos}")
    
    # Sort to find medians
    rows.sort()
    cols.sort()
    
    # Median positions
    median_row = rows[len(rows) // 2]
    median_col = cols[len(cols) // 2]
    
    print(f"\nMedian position: ({median_row}, {median_col})")
    
    # Calculate total distance
    total = 0
    for r, c in positions:
        dist = abs(r - median_row) + abs(c - median_col)
        total += dist
        print(f"  Distance from ({r},{c}) to median: {dist}")
    
    print(f"\nTotal distance: {total}")
    
    # Proof of concept
    print("\n" + "=" * 60)
    print("WHY MEDIAN MINIMIZES DISTANCE")
    print("=" * 60)
    
    print("\n1D Example: Points at positions [1, 3, 9]")
    points_1d = [1, 3, 9]
    
    test_positions = [1, 3, 5, 7, 9]
    print("\nTesting different meeting points:")
    for pos in test_positions:
        dist = sum(abs(p - pos) for p in points_1d)
        marker = " ← MEDIAN (optimal)" if pos == 3 else ""
        print(f"  Position {pos}: total distance = {dist}{marker}")
    
    print("\nObservation:")
    print("  - Below median (pos=1): distances increase as we move away")
    print("  - At median (pos=3): optimal! Balanced distances")
    print("  - Above median (pos=9): distances increase")
    print("\nMedian balances the 'pull' from both sides!")
    
    return total

# Example
grid = [
    [1, 0, 0, 0, 1],
    [0, 0, 0, 0, 0],
    [0, 0, 1, 0, 0]
]

result = min_total_distance(grid)
```

**Mathematical Proof**:
```python
def prove_median_minimizes():
    """
    Rigorous proof that median minimizes sum of absolute deviations.
    """
    print("=" * 60)
    print("MATHEMATICAL PROOF")
    print("=" * 60)
    
    proof = """
    Theorem: For points x₁, x₂, ..., xₙ on a line,
             the median minimizes Σ|xᵢ - m|
    
    Proof:
    
    1. Sort points: x₁ ≤ x₂ ≤ ... ≤ xₙ
    
    2. Consider any point m between xₖ and xₖ₊₁
       
       Distance function:
       f(m) = Σᵢ₌₁ᵏ (m - xᵢ) + Σᵢ₌ₖ₊₁ⁿ (xᵢ - m)
            = k·m - Σᵢ₌₁ᵏ xᵢ + Σᵢ₌ₖ₊₁ⁿ xᵢ - (n-k)·m
            = (k - (n-k))·m + constant
            = (2k - n)·m + constant
    
    3. Derivative: f'(m) = 2k - n
    
    4. Analysis:
       - If k < n/2: f'(m) < 0 → function decreasing, move right
       - If k > n/2: f'(m) > 0 → function increasing, move left
       - If k = n/2: f'(m) = 0 → at minimum (median!)
    
    5. Therefore, median minimizes total distance.
    
    Intuition:
    - Moving away from median increases distances to majority side
    - At median, equal numbers on each side
    - Any move increases net distance
    """
    
    print(proof)
    
    # Numerical demonstration
    print("\nNumerical Demonstration:")
    points = [1, 2, 5, 9, 10]
    print(f"Points: {points}")
    print(f"Median: {points[len(points)//2]}")
    
    for test_m in range(0, 12):
        total = sum(abs(p - test_m) for p in points)
        print(f"  m={test_m:2d}: f(m)={total:2d}", end="")
        if test_m == points[len(points)//2]:
            print(" ← MINIMUM (median)")
        else:
            print()

prove_median_minimizes()
```

### Pattern 2: Minimize Maximum (or Maximize Minimum)

**Problem: Minimum Number of Arrows to Burst Balloons (Mathematical View)**

```python
def find_min_arrow_shots_mathematical(points):
    """
    Mathematical formulation: Cover all intervals with minimum points.
    
    Greedy Insight:
    - Place arrow at rightmost position of leftmost balloon
    - This maximizes coverage (can hit any balloon starting before this point)
    
    Time: O(n log n)
    Space: O(1)
    """
    if not points:
        return 0
    
    # Sort by START position (different from end-based greedy!)
    points.sort()
    
    print("Balloons sorted by start position:")
    for i, (start, end) in enumerate(points):
        print(f"  Balloon {i}: [{start}, {end}]")
    
    arrows = 0
    current_end = float('inf')  # Track rightmost boundary of current group
    
    print("\n" + "=" * 60)
    print("ARROW PLACEMENT STRATEGY")
    print("=" * 60)
    
    for i, (start, end) in enumerate(points):
        if start > current_end:
            # Need new arrow
            arrows += 1
            current_end = end
            print(f"\nBalloon {i} [{start},{end}]:")
            print(f"  Starts after current coverage ({current_end})")
            print(f"  → Place arrow #{arrows} at position {current_end}")
        else:
            # Can use same arrow, but update coverage
            print(f"\nBalloon {i} [{start},{end}]:")
            print(f"  Overlaps with current group (coverage ends at {current_end})")
            current_end = min(current_end, end)
            print(f"  → Update coverage to {current_end} (minimum end)")
    
    # Place last arrow
    arrows += 1
    print(f"\n→ Place final arrow #{arrows} at position {current_end}")
    
    print("\n" + "=" * 60)
    print("MATHEMATICAL INSIGHT")
    print("=" * 60)
    
    insight = """
    This is a SET COVER problem variant:
    
    - Universe: All balloons
    - Sets: Positions where we can place arrows
    - Goal: Minimum sets (arrows) to cover universe
    
    Greedy works because:
    1. At any point, we have a set of overlapping balloons
    2. Optimal to place arrow in their INTERSECTION
    3. Rightmost point of leftmost balloon guarantees future coverage
    4. If next balloon doesn't overlap, we were optimal (can't do better)
    
    Proof:
    - Suppose optimal uses fewer arrows
    - Then some balloon is covered by same arrow as a non-overlapping balloon
    - But non-overlapping → no common point for arrow
    - Contradiction! So our greedy is optimal.
    """
    
    print(insight)
    
    return arrows

# Example
balloons = [[10,16], [2,8], [1,6], [7,12]]
result = find_min_arrow_shots_mathematical(balloons)
print(f"\nMinimum arrows: {result}")
```

### Pattern 3: Game Theory & Minimax

**Problem: Stone Game Variations**

```python
def predict_winner(nums):
    """
    Two players alternately pick from ends of array.
    Predict if first player wins (both play optimally).
    
    Mathematical Insight:
    - For even-length arrays, first player can always force win
    - Can choose all even indices OR all odd indices
    - Pick the set with larger sum
    
    For odd-length: Need DP or full game tree
    
    Time: O(n²) for DP approach
    Space: O(n²)
    """
    n = len(nums)
    
    # Mathematical observation for even length
    if n % 2 == 0:
        even_sum = sum(nums[i] for i in range(0, n, 2))
        odd_sum = sum(nums[i] for i in range(1, n, 2))
        
        print(f"Array: {nums}")
        print(f"Length: {n} (even)")
        print(f"\nMathematical Analysis:")
        print(f"  Even indices {list(range(0, n, 2))}: sum = {even_sum}")
        print(f"  Odd indices {list(range(1, n, 2))}: sum = {odd_sum}")
        print(f"\nFirst player can force taking all {'even' if even_sum > odd_sum else 'odd'} indices")
        print(f"Therefore, first player wins!")
        
        return True
    
    # For odd length, need DP
    # dp[i][j] = max score difference (player1 - player2) for nums[i:j+1]
    dp = [[0] * n for _ in range(n)]
    
    # Base case: single element
    for i in range(n):
        dp[i][i] = nums[i]
    
    print(f"\nArray: {nums}")
    print(f"Length: {n} (odd) - need DP")
    print(f"\nDP Table Construction:")
    
    # Fill DP table
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            
            # Current player picks from left or right
            pick_left = nums[i] - dp[i+1][j]
            pick_right = nums[j] - dp[i][j-1]
            
            dp[i][j] = max(pick_left, pick_right)
            
            if length <= 3:  # Print small examples
                print(f"  dp[{i}][{j}] (nums[{i}:{j+1}]={nums[i:j+1]})")
                print(f"    Pick left ({nums[i]}): diff = {pick_left}")
                print(f"    Pick right ({nums[j]}): diff = {pick_right}")
                print(f"    → dp[{i}][{j}] = {dp[i][j]}")
    
    result = dp[0][n-1] >= 0
    print(f"\nFinal score difference: {dp[0][n-1]}")
    print(f"First player {'wins' if result else 'loses'}!")
    
    return result

# Examples
print("=" * 60)
print("EVEN LENGTH ARRAY (Greedy works!)")
print("=" * 60)
nums1 = [1, 5, 2, 4, 6, 3]
result1 = predict_winner(nums1)

print("\n" + "=" * 60)
print("ODD LENGTH ARRAY (Need DP)")
print("=" * 60)
nums2 = [1, 5, 233, 7]
result2 = predict_winner(nums2)
```

---

## 5.2 Greedy with Preprocessing

Transform the problem first, then apply greedy. The preprocessing itself is often the key insight.

### Pattern 1: Prefix Sums for Greedy Decisions

**Problem: Maximum Subarray Sum (Kadane's Algorithm)**

```python
def max_subarray(nums):
    """
    Find maximum sum of contiguous subarray.
    
    Greedy Insight (Kadane's Algorithm):
    - Track current sum ending at position i
    - If current sum negative, reset (greedy: start fresh)
    - Keep global maximum
    
    Mathematical Proof:
    - If sum up to i is negative, including it makes (i, j) worse than (i+1, j)
    - So greedy choice: drop negative prefix
    
    Time: O(n)
    Space: O(1)
    """
    max_sum = float('-inf')
    current_sum = 0
    start = 0
    end = 0
    temp_start = 0
    
    print(f"Array: {nums}")
    print(f"\n" + "=" * 60)
    print("KADANE'S ALGORITHM (Greedy)")
    print("=" * 60)
    
    for i in range(len(nums)):
        current_sum += nums[i]
        
        print(f"\nIndex {i} (value={nums[i]}): current_sum = {current_sum}")
        
        if current_sum > max_sum:
            max_sum = current_sum
            start = temp_start
            end = i
            print(f"  → New maximum! Subarray: [{start}:{end+1}] = {nums[start:end+1]}")
        
        # Greedy choice: if sum becomes negative, reset
        if current_sum < 0:
            current_sum = 0
            temp_start = i + 1
            print(f"  → Reset (negative sum). New potential start: {temp_start}")
    
    print(f"\n" + "=" * 60)
    print(f"Result: Maximum sum = {max_sum}")
    print(f"Subarray: nums[{start}:{end+1}] = {nums[start:end+1]}")
    print("=" * 60)
    
    # Proof explanation
    print("\nWhy Greedy Works:")
    proof = """
    Claim: If sum of nums[0..i] < 0, optimal subarray doesn't start before i+1
    
    Proof by contradiction:
    1. Suppose optimal subarray is nums[j..k] where j ≤ i < k
    2. Sum(nums[j..k]) = Sum(nums[j..i]) + Sum(nums[i+1..k])
    3. Since Sum(nums[j..i]) ≤ Sum(nums[0..i]) < 0 (we're being generous)
    4. Sum(nums[i+1..k]) > Sum(nums[j..k]) (removing negative prefix)
    5. So nums[i+1..k] is better than nums[j..k]
    6. Contradiction! Optimal can't include j..i
    
    Therefore, greedy choice to reset at negative sum is correct.
    """
    print(proof)
    
    return max_sum

# Example
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
result = max_subarray(nums)
```

### Pattern 2: Coordinate Compression

**Problem: Minimum Number of Taps (LeetCode 1326)**

```python
def min_taps(n, ranges):
    """
    Water garden [0, n] with minimum taps.
    ranges[i] means tap at i can water [i-ranges[i], i+ranges[i]]
    
    Preprocessing: Convert to interval covering problem
    Greedy: Same as jump game / video stitching
    
    Time: O(n)
    Space: O(n)
    """
    # Preprocess: For each position, find max reach
    max_reach = [0] * (n + 1)
    
    print(f"Garden length: {n}")
    print(f"Tap ranges: {ranges}")
    print(f"\nPreprocessing: Convert taps to intervals")
    
    for i, r in enumerate(ranges):
        left = max(0, i - r)
        right = min(n, i + r)
        
        if left <= n:
            max_reach[left] = max(max_reach[left], right)
            print(f"  Tap {i} (range={r}): covers [{left}, {right}], max_reach[{left}]={max_reach[left]}")
    
    print(f"\nAfter preprocessing:")
    print(f"  max_reach = {max_reach}")
    
    # Now it's a jump game problem!
    print(f"\n" + "=" * 60)
    print("GREEDY JUMP GAME APPROACH")
    print("=" * 60)
    
    taps = 0
    current_end = 0
    farthest = 0
    
    for i in range(n + 1):
        if i > farthest:
            print(f"\nPosition {i}: Cannot reach! farthest={farthest}")
            return -1
        
        farthest = max(farthest, max_reach[i])
        
        if i == current_end:
            taps += 1
            current_end = farthest
            print(f"\nTap #{taps}: At position {i}, extend coverage to {current_end}")
            
            if current_end >= n:
                print(f"→ Garden fully watered!")
                return taps
    
    return -1 if current_end < n else taps

# Example
n = 5
ranges = [3, 4, 1, 1, 0, 0]
result = min_taps(n, ranges)
print(f"\nMinimum taps needed: {result}")

print("\n" + "=" * 60)
print("KEY INSIGHT: PROBLEM TRANSFORMATION")
print("=" * 60)
print("""
Original Problem: Select minimum taps to water garden
↓ Preprocessing ↓
Transformed Problem: Jump game with intervals

Each position i asks: "What's the farthest I can water from here?"
This is exactly jump game: "What's the farthest I can jump from here?"

Greedy solution transfers directly!
""")
```

---

## 5.3 Greedy with Lookahead

Sometimes greedy needs to "peek" a few steps ahead.

### Pattern: Remove Duplicate Letters (Stack + Lookahead)

**LeetCode 316: Remove Duplicate Letters**

```python
def remove_duplicate_letters(s):
    """
    Remove duplicate letters so result is smallest lexicographically.
    Each letter appears exactly once.
    
    Greedy with Lookahead:
    - Use stack to build result
    - For each character, decide: keep previous characters or replace?
    - Lookahead: Check if we'll see previous character again
    - If yes, and current < previous, remove previous (greedy choice)
    
    Time: O(n)
    Space: O(1) - at most 26 characters
    """
    # Lookahead: count remaining occurrences
    last_occurrence = {c: i for i, c in enumerate(s)}
    remaining = {c: s.count(c) for c in set(s)}
    
    stack = []
    in_stack = set()
    
    print(f"Input: {s}")
    print(f"Last occurrence of each character:")
    for c in sorted(last_occurrence.keys()):
        print(f"  '{c}': index {last_occurrence[c]}")
    
    print(f"\n" + "=" * 60)
    print("GREEDY CONSTRUCTION WITH LOOKAHEAD")
    print("=" * 60)
    
    for i, c in enumerate(s):
        print(f"\nIndex {i}: character '{c}'")
        remaining[c] -= 1
        
        if c in in_stack:
            print(f"  Already in result, skip")
            continue
        
        # Greedy choice: remove larger characters if we'll see them again
        while stack and stack[-1] > c and remaining[stack[-1]] > 0:
            removed = stack.pop()
            in_stack.remove(removed)
            print(f"  Remove '{removed}' (larger than '{c}' and appears later)")
            print(f"    Stack: {stack}")
        
        stack.append(c)
        in_stack.add(c)
        print(f"  Add '{c}'")
        print(f"    Stack: {stack}")
    
    result = ''.join(stack)
    print(f"\n" + "=" * 60)
    print(f"Result: {result}")
    print("=" * 60)
    
    return result

# Example
s = "bcabc"
result = remove_duplicate_letters(s)

print("\n" + "=" * 60)
print("DETAILED EXAMPLE")
print("=" * 60)

example = """
Input: "bcabc"
Last occurrence: a→2, b→3, c→4

Process:
  i=0, char='b': stack=['b']
  i=1, char='c': stack=['b','c']
  i=2, char='a': 
    - 'a' < 'c' and c appears later → remove 'c'
    - 'a' < 'b' and b appears later → remove 'b'
    - stack=['a']
  i=3, char='b': stack=['a','b']
  i=4, char='c': stack=['a','b','c']

Result: "abc"

Why this is optimal:
- Lexicographically smallest: 'a' before 'b' before 'c'
- Contains each letter exactly once: ✓
- Greedy choices created optimal ordering
"""
print(example)

# Another example
print("\n" + "=" * 60)
s2 = "cbacdcbc"
print(f"Another example: {s2}")
result2 = remove_duplicate_letters(s2)
```

### Pattern: Candy Distribution (Two-Pass Lookahead)

**LeetCode 135: Candy**

```python
def candy(ratings):
    """
    Give candies to children based on ratings.
    Rules:
    1. Each child gets at least 1 candy
    2. Higher rating than neighbor → more candies than that neighbor
    
    Greedy with Two-Pass Lookahead:
    - Pass 1 (left to right): Ensure right neighbor rule
    - Pass 2 (right to left): Ensure left neighbor rule
    - Take maximum from both passes
    
    Time: O(n)
    Space: O(n)
    """
    n = len(ratings)
    candies = [1] * n
    
    print(f"Ratings: {ratings}")
    print(f"Initial candies: {candies}")
    
    # Pass 1: Left to right
    print(f"\n" + "=" * 60)
    print("PASS 1: Left to Right (satisfy right neighbor)")
    print("=" * 60)
    
    for i in range(1, n):
        if ratings[i] > ratings[i-1]:
            candies[i] = candies[i-1] + 1
            print(f"  Child {i}: rating {ratings[i]} > {ratings[i-1]} "
                  f"→ candies[{i}] = {candies[i]}")
    
    print(f"After pass 1: {candies}")
    
    # Pass 2: Right to left
    print(f"\n" + "=" * 60)
    print("PASS 2: Right to Left (satisfy left neighbor)")
    print("=" * 60)
    
    for i in range(n-2, -1, -1):
        if ratings[i] > ratings[i+1]:
            # Take max to satisfy both neighbors
            candies[i] = max(candies[i], candies[i+1] + 1)
            print(f"  Child {i}: rating {ratings[i]} > {ratings[i+1]} "
                  f"→ candies[{i}] = max({candies[i]}, {candies[i+1] + 1}) = {candies[i]}")
    
    print(f"After pass 2: {candies}")
    
    total = sum(candies)
    print(f"\n" + "=" * 60)
    print(f"Total candies: {total}")
    print("=" * 60)
    
    # Verification
    print(f"\nVerification:")
    valid = True
    for i in range(n):
        left_ok = i == 0 or ratings[i] <= ratings[i-1] or candies[i] > candies[i-1]
        right_ok = i == n-1 or ratings[i] <= ratings[i+1] or candies[i] > candies[i+1]
        status = "✓" if left_ok and right_ok else "✗"
        print(f"  Child {i}: {status} candies={candies[i]}, rating={ratings[i]}")
        valid = valid and left_ok and right_ok
    
    return total

# Example
ratings = [1, 0, 2]
result = candy(ratings)

print("\n" + "=" * 60)
print("WHY TWO PASSES WORK")
print("=" * 60)
print("""
Insight: Constraints work in opposite directions

Left-to-right pass ensures:
  If rating[i] > rating[i-1] → candy[i] > candy[i-1]

Right-to-left pass ensures:
  If rating[i] > rating[i+1] → candy[i] > candy[i+1]

Taking max in second pass preserves first pass constraints!

Example: [1, 0, 2]
  Pass 1: [1, 1, 2]  (2 > 0, so give more)
  Pass 2: [2, 1, 2]  (1 > 0, so give more, but keep max)
  
Total: 5 candies (optimal!)
""")
```

---

## 5.4 Greedy with Amortized Analysis

For problems where greedy may seem suboptimal locally but is optimal overall.

### Pattern: Text Justification (Cumulative Optimality)

**LeetCode 68: Text Justification**

```python
def full_justify(words, max_width):
    """
    Justify text: pack words in lines, distribute spaces evenly.
    
    Greedy Strategy:
    - Pack as many words as possible per line
    - Distribute spaces evenly (amortized fairness)
    
    Time: O(n) where n = total characters
    Space: O(n)
    """
    result = []
    current_line = []
    current_length = 0
    
    print(f"Max width: {max_width}")
    print(f"Words: {words}")
    print(f"\n" + "=" * 60)
    print("GREEDY LINE PACKING")
    print("=" * 60)
    
    for word in words:
        # Check if word fits in current line (including spaces)
        # current_length + len(current_line) = length with single spaces
        if current_length + len(current_line) + len(word) > max_width:
            # Justify and add current line
            line = justify_line(current_line, current_length, max_width, False)
            result.append(line)
            print(f"\nLine {len(result)}: '{line}'")
            
            # Start new line
            current_line = []
            current_length = 0
        
        current_line.append(word)
        current_length += len(word)
        print(f"  Add '{word}': current_length={current_length}")
    
    # Last line (left-justified)
    line = justify_line(current_line, current_length, max_width, True)
    result.append(line)
    print(f"\nLast line: '{line}' (left-justified)")
    
    return result

def justify_line(words, length, max_width, is_last):
    """Helper to justify a single line."""
    if is_last or len(words) == 1:
        # Left justify
        line = ' '.join(words)
        return line + ' ' * (max_width - len(line))
    
    # Distribute spaces evenly
    total_spaces = max_width - length
    gaps = len(words) - 1
    spaces_per_gap = total_spaces // gaps
    extra_spaces = total_spaces % gaps
    
    result = []
    for i, word in enumerate(words):
        result.append(word)
        if i < gaps:
            # Add base spaces
            result.append(' ' * spaces_per_gap)
            # Add extra space to leftmost gaps
            if i < extra_spaces:
                result.append(' ')
    
    return ''.join(result)

# Example
words = ["This", "is", "an", "example", "of", "text", "justification."]
max_width = 16

result = full_justify(words, max_width)
print(f"\n" + "=" * 60)
print("JUSTIFIED TEXT")
print("=" * 60)
for i, line in enumerate(result):
    print(f"Line {i+1}: '{line}' (length={len(line)})")
```

---

## Summary: Hard Problem Checklist

```python
# Framework for tackling hard greedy problems:

HARD_PROBLEM_APPROACH = """
1. LOOK FOR MATHEMATICAL PATTERN
   - Is there a mathematical property (median, mean, monotonicity)?
   - Can you prove something about optimal solution?
   - Try small examples, look for patterns

2. CONSIDER PREPROCESSING
   - Can you transform the problem?
   - Would sorting/grouping reveal structure?
   - Can you precompute useful information?

3. CHECK IF LOOKAHEAD HELPS
   - Do you need to know about future elements?
   - Can you track remaining occurrences?
   - Would two-pass solve conflicting constraints?

4. VERIFY AMORTIZATION
   - Is local choice suboptimal but globally optimal?
   - Can you prove total cost is minimized?
   - Does cumulative effect matter?

5. PROOF STRATEGY
   - Exchange argument: swap non-greedy with greedy
   - Stays ahead: show greedy is always ≥ optimal
   - Contradiction: assume greedy fails, derive impossibility
   - Mathematical: use algebra/calculus to prove
"""
```

### Practice Problems for Chapter 5

1. **Medium**: Best Meeting Point (LC 296) - Median
2. **Hard**: Text Justification (LC 68) - Amortized
3. **Medium**: Remove Duplicate Letters (LC 316) - Lookahead
4. **Hard**: Candy (LC 135) - Two-pass
5. **Medium**: Maximum Subarray (LC 53) - Kadane's
6. **Hard**: Minimum Number of Taps (LC 1326) - Preprocessing

---

## Final Thoughts on Hard Problems

Hard greedy problems require:
1. **Mathematical maturity** - recognizing patterns and properties
2. **Creative thinking** - transforming problems
3. **Proof skills** - justifying correctness
4. **Pattern recognition** - connecting to known techniques

The key is extensive practice with diverse problems. Each hard problem you solve builds intuition for the next!