# Chapter 1: Foundations of Greedy Algorithms

## 1.1 What is a Greedy Algorithm?

### Core Concept
A greedy algorithm builds up a solution piece by piece, always choosing the next piece that offers the most immediate benefit. The "greedy" aspect means the algorithm doesn't look ahead to see if this choice will lead to problems later—it simply makes the locally optimal choice at each step.

### Real-World Analogy
Imagine you're playing a video game where you collect coins along a path. A greedy approach would be: "At each intersection, always take the path with the most coins visible right now." You don't check if a path with fewer coins now leads to more coins later—you just grab what looks best immediately.

### Key Characteristics
1. **Irrevocable decisions**: Once made, choices are never reconsidered
2. **Local optimization**: Each step picks the best option available at that moment
3. **No backtracking**: Unlike algorithms that explore multiple paths
4. **Efficient**: Usually faster than exhaustive search approaches

### Simple Example: Making Change

**Problem**: Give change for $0.63 using the fewest coins (quarters=25¢, dimes=10¢, nickels=5¢, pennies=1¢)

**Greedy Approach**: Always use the largest coin possible

```python
def make_change(amount):
    """
    Greedy algorithm to make change with minimum coins
    """
    coins = [25, 10, 5, 1]  # Sorted in descending order
    result = []
    
    for coin in coins:
        while amount >= coin:
            result.append(coin)
            amount -= coin
    
    return result

# Example
change = make_change(63)
print(f"Coins: {change}")  # [25, 25, 10, 1, 1, 1]
print(f"Total coins: {len(change)}")  # 6 coins

# Step-by-step:
# 63 - 25 = 38  (use quarter)
# 38 - 25 = 13  (use quarter)
# 13 - 10 = 3   (use dime)
# 3 - 1 = 2     (use penny)
# 2 - 1 = 1     (use penny)
# 1 - 1 = 0     (use penny)
```

**Why this works**: US coin denominations are designed so greedy works optimally. But this isn't always true!

---

## 1.2 When Does Greedy Work?

Not all problems can be solved with greedy algorithms. For greedy to guarantee an optimal solution, the problem must have two key properties:

### Property 1: Greedy Choice Property

**Definition**: A globally optimal solution can be arrived at by making locally optimal (greedy) choices.

**What this means**: The choice that looks best right now will be part of the optimal solution. You don't need to consider all possibilities—just pick the best one available.

**Example - Fractional Knapsack**:
```python
def fractional_knapsack(capacity, items):
    """
    items: list of (value, weight) tuples
    Returns: maximum value achievable
    
    Greedy Choice: Always take item with highest value/weight ratio
    """
    # Calculate value per unit weight and sort
    items_with_ratio = []
    for i, (value, weight) in enumerate(items):
        ratio = value / weight
        items_with_ratio.append((ratio, value, weight, i))
    
    # Sort by ratio (descending)
    items_with_ratio.sort(reverse=True)
    
    total_value = 0
    remaining_capacity = capacity
    
    for ratio, value, weight, idx in items_with_ratio:
        if remaining_capacity >= weight:
            # Take the whole item
            total_value += value
            remaining_capacity -= weight
            print(f"Take 100% of item {idx}: value={value}, weight={weight}")
        else:
            # Take fractional part
            fraction = remaining_capacity / weight
            total_value += value * fraction
            print(f"Take {fraction*100:.1f}% of item {idx}: value={value*fraction:.2f}")
            break
    
    return total_value

# Example
items = [
    (60, 10),  # value=60, weight=10, ratio=6
    (100, 20), # value=100, weight=20, ratio=5
    (120, 30), # value=120, weight=30, ratio=4
]
capacity = 50

result = fractional_knapsack(capacity, items)
print(f"Maximum value: {result}")

# Output:
# Take 100% of item 0: value=60, weight=10
# Take 100% of item 1: value=100, weight=20
# Take 66.7% of item 2: value=80.00
# Maximum value: 240.0
```

**Why greedy works here**: Taking the highest ratio first is always part of the optimal solution. If we didn't take it, we could swap it with a lower ratio item and improve the solution.

### Property 2: Optimal Substructure

**Definition**: An optimal solution to the problem contains optimal solutions to subproblems.

**What this means**: If you make a greedy choice, the remaining problem is a smaller instance of the original problem.

**Example - Activity Selection**:
```python
def activity_selection(activities):
    """
    Select maximum number of non-overlapping activities
    activities: list of (start, end) tuples
    
    Greedy Choice: Always pick activity that finishes earliest
    Optimal Substructure: After picking an activity, remaining problem
                          is selecting from activities that start after it ends
    """
    # Sort by finish time
    activities.sort(key=lambda x: x[1])
    
    selected = [activities[0]]
    last_finish = activities[0][1]
    
    print(f"Selected activity: {activities[0]}")
    
    for start, end in activities[1:]:
        if start >= last_finish:  # Non-overlapping
            selected.append((start, end))
            last_finish = end
            print(f"Selected activity: ({start}, {end})")
        else:
            print(f"Skipped activity: ({start}, {end}) - overlaps")
    
    return selected

# Example
activities = [
    (1, 4),   # Activity 0
    (3, 5),   # Activity 1
    (0, 6),   # Activity 2
    (5, 7),   # Activity 3
    (3, 9),   # Activity 4
    (5, 9),   # Activity 5
    (6, 10),  # Activity 6
    (8, 11),  # Activity 7
]

result = activity_selection(activities)
print(f"\nTotal selected: {len(result)}")

# Visualization:
# Time:  0  1  2  3  4  5  6  7  8  9  10 11
# A0:       [-----]
# A1:          [---]
# A2:    [-----------]
# A3:                [---]
# A4:          [-----------]
# A5:                [------]
# A6:                   [-----]
# A7:                         [-----]
#
# Selected: A0(1,4), A3(5,7), A7(8,11)
```

**Proof of Optimal Substructure**: 
- After selecting activity ending at time `t`, the remaining problem is: "Select max activities from those starting at `t` or later"
- This is the same problem type, just smaller
- If our greedy choice is optimal, and the subproblem solution is optimal, then combining them gives an optimal solution to the original problem

### When Greedy Doesn't Work

**Counter-Example: 0/1 Knapsack**

In the 0/1 Knapsack problem, you cannot take fractions of items—you either take an item completely or leave it.

```python
# This greedy approach is WRONG for 0/1 Knapsack!
def wrong_greedy_knapsack(capacity, items):
    """
    This demonstrates WHY greedy fails for 0/1 Knapsack
    """
    # Sort by value/weight ratio (same as fractional)
    items_with_ratio = []
    for i, (value, weight) in enumerate(items):
        ratio = value / weight
        items_with_ratio.append((ratio, value, weight, i))
    
    items_with_ratio.sort(reverse=True)
    
    total_value = 0
    remaining_capacity = capacity
    selected = []
    
    for ratio, value, weight, idx in items_with_ratio:
        if remaining_capacity >= weight:
            total_value += value
            remaining_capacity -= weight
            selected.append(idx)
    
    return total_value, selected

# Counter-example where greedy fails
items = [
    (60, 10),  # ratio = 6
    (100, 20), # ratio = 5
    (120, 30), # ratio = 4
]
capacity = 50

greedy_value, greedy_items = wrong_greedy_knapsack(capacity, items)
print(f"Greedy solution: value={greedy_value}, items={greedy_items}")
# Greedy picks: item 0 (60) + item 1 (100) = 160, weight=30

# But optimal solution is:
print(f"Optimal solution: value=220, items=[1, 2]")
# Take items 1 and 2: 100 + 120 = 220, weight=50

# Greedy fails because it commits to item 0, leaving only 40 capacity
# If it skipped item 0, it could fit items 1 and 2 for higher value!
```

**Why greedy fails**: Taking the highest ratio first doesn't guarantee we can fit the best combination later. The greedy choice property doesn't hold.

---

## 1.3 Greedy vs Dynamic Programming

Both approaches are optimization techniques, but they work very differently.

### Comparison Table

| Aspect | Greedy | Dynamic Programming |
|--------|--------|---------------------|
| **Decision Making** | Makes immediate choice, never reconsiders | Considers all choices, picks best |
| **Optimality Guarantee** | Only when greedy choice property holds | Always (if formulated correctly) |
| **Time Complexity** | Usually O(n log n) or O(n) | Usually O(n²) or higher |
| **Space Complexity** | Usually O(1) or O(n) | Usually O(n) or O(n²) for memoization |
| **When to Use** | Problem has greedy choice property | Problem has overlapping subproblems |
| **Examples** | Activity selection, Huffman coding | Longest common subsequence, Edit distance |

### Detailed Comparison: Coin Change Problem

Let's solve the same problem with both approaches to see the difference.

**Problem**: Minimum coins needed to make amount (coins can be reused)

#### Greedy Approach (Only works for certain coin systems)

```python
def coin_change_greedy(coins, amount):
    """
    Greedy: Always use largest coin possible
    WARNING: Only works for some coin systems (like US coins)
    """
    coins.sort(reverse=True)
    count = 0
    
    for coin in coins:
        while amount >= coin:
            amount -= coin
            count += 1
            print(f"Use coin {coin}, remaining: {amount}")
    
    return count if amount == 0 else -1

# Works for US coins
us_coins = [25, 10, 5, 1]
amount = 30
result = coin_change_greedy(us_coins, amount)
print(f"Greedy result: {result} coins\n")  # 2 coins (25 + 5)

# FAILS for other coin systems
weird_coins = [25, 10, 1]
amount = 30
result = coin_change_greedy(weird_coins, amount)
print(f"Greedy result: {result} coins")  # 6 coins (25 + 1 + 1 + 1 + 1 + 1)
print(f"Optimal: 3 coins (10 + 10 + 10)")  # Greedy is wrong!
```

#### Dynamic Programming Approach (Always works)

```python
def coin_change_dp(coins, amount):
    """
    DP: Try all possibilities, remember best
    Works for ANY coin system
    """
    # dp[i] = minimum coins needed to make amount i
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # Base case: 0 coins for amount 0
    
    # For each amount from 1 to target
    for i in range(1, amount + 1):
        # Try using each coin
        for coin in coins:
            if coin <= i:
                # If we use this coin, we need dp[i-coin] + 1 coins
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1

# Test with weird coins where greedy fails
weird_coins = [25, 10, 1]
amount = 30

result = coin_change_dp(weird_coins, amount)
print(f"\nDP result: {result} coins")  # 3 coins (correct!)

# Trace how DP builds the solution
def coin_change_dp_with_trace(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    parent = [-1] * (amount + 1)  # Track which coin was used
    
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i and dp[i - coin] + 1 < dp[i]:
                dp[i] = dp[i - coin] + 1
                parent[i] = coin
    
    # Reconstruct solution
    result = []
    current = amount
    while current > 0:
        coin = parent[current]
        result.append(coin)
        current -= coin
    
    return dp[amount], result

min_coins, coins_used = coin_change_dp_with_trace(weird_coins, 30)
print(f"Coins used: {coins_used}")  # [10, 10, 10]
```

### Visual Comparison: Decision Tree

```
Greedy (makes one choice at each level):
Amount: 30
  ↓ (choose 25, largest)
Amount: 5
  ↓ (choose 1, can't use 25 or 10)
Amount: 4
  ↓ (choose 1)
...continues... → 6 coins total


Dynamic Programming (explores all choices):
                    30
        ╱           |           ╲
      use 25      use 10      use 1
       ↓            ↓           ↓
       5            20          29
    ╱  |  ╲      ╱  |  ╲       ...
  25  10  1    25  10  1
  
Evaluates ALL paths, memoizes results, returns minimum
→ Finds [10, 10, 10] = 3 coins
```

### When to Choose Each Approach

**Choose Greedy When:**
```python
# Checklist for greedy:
# ✓ Can you prove greedy choice property?
# ✓ Making a choice reduces problem to smaller instance?
# ✓ Can't find counterexample?
# ✓ Need fast solution (time-critical)?

# Examples where greedy works:
# - Activity selection (earliest finish time)
# - Huffman coding (merge lowest frequencies)
# - Dijkstra's shortest path (no negative edges)
# - Minimum spanning tree (Kruskal's, Prim's)
```

**Choose Dynamic Programming When:**
```python
# Indicators you need DP:
# ✗ Greedy choice leads to suboptimal solution
# ✓ Need to consider multiple choices
# ✓ Overlapping subproblems exist
# ✓ Can break into subproblems

# Examples where DP is needed:
# - 0/1 Knapsack
# - Longest common subsequence
# - Edit distance
# - Coin change (arbitrary denominations)
```

### Key Insight

The fundamental difference is **commitment**:
- **Greedy**: Makes irreversible decisions → faster but only works sometimes
- **DP**: Keeps options open, tries everything → slower but always finds optimum

Think of it like chess:
- **Greedy** is like always capturing the highest-value piece available
- **DP** is like looking ahead multiple moves to find the best sequence

---

## Summary: The Greedy Algorithm Checklist

Before implementing a greedy solution, verify:

1. ✅ **Greedy Choice Property**: Can you make locally optimal choices?
2. ✅ **Optimal Substructure**: Does the problem break into similar subproblems?
3. ✅ **No Counterexamples**: Test edge cases thoroughly
4. ✅ **Proof or Intuition**: Can you explain why greedy works?

If any check fails, consider Dynamic Programming instead!

### Practice Problem

**Try this**: Given meeting times, find the minimum number of meeting rooms needed.
- Think: Is this a greedy problem?
- What would be the greedy choice?
- Can you prove it works?

(Answer in Chapter 2!)