# Chapter 2: Fundamental Greedy Patterns

## 2.1 Activity Selection / Interval Scheduling

This is THE classic greedy pattern and the foundation for many interval-based problems.

### Core Problem: Maximum Non-Overlapping Intervals

**Problem Statement**: Given N activities with start and finish times, select the maximum number of activities that don't overlap.

**Why This Matters**: This pattern appears in scheduling, resource allocation, and many real-world optimization problems.

### The Greedy Insight

**Key Question**: Which activity should we pick first?

Let's analyze different strategies:

```python
# Strategy 1: Pick shortest duration first? ❌
# Counter-example:
#   Activity A: [0, 10] (duration 10)
#   Activity B: [1, 2] (duration 1)
#   Activity C: [2, 3] (duration 1)
#   Activity D: [3, 4] (duration 1)
#   ...
#   Activity K: [9, 10] (duration 1)
# 
# Picking shortest: B, C, D, ... K = 9 activities
# Optimal: Just pick A = 1 activity? NO! Actually 9 is correct!
# So shortest works here, but...

# Counter-example where shortest fails:
#   Activity A: [0, 5]
#   Activity B: [1, 2]
#   Activity C: [4, 9]
#
# Time:  0  1  2  3  4  5  6  7  8  9
#    A:  [--------]
#    B:     [-]
#    C:              [--------]
#
# Shortest picks B first, then either A or C: 2 activities
# Optimal: Pick A and C: 2 activities
# Equal here, but not always optimal!

# Strategy 2: Pick earliest start time first? ❌
#   Activity A: [0, 10]
#   Activity B: [1, 2]
#   Activity C: [3, 4]
#
# Earliest start picks A first, blocks B and C: 1 activity
# Optimal: Pick B and C: 2 activities

# Strategy 3: Pick EARLIEST FINISH TIME first? ✅
# This is the correct greedy choice!
```

### Why Earliest Finish Time Works

**Intuition**: By finishing early, we leave maximum room for subsequent activities.

**Proof Sketch** (Exchange Argument):
1. Suppose optimal solution O doesn't pick the earliest-finishing activity A
2. O picks some other activity B instead
3. Since A finishes before B, we can replace B with A in O
4. This doesn't create conflicts (A finishes earlier)
5. We now have a solution as good as O that includes A
6. By induction, greedy solution is optimal

### Complete Implementation

```python
def max_non_overlapping_intervals(intervals):
    """
    Select maximum number of non-overlapping intervals.
    
    Time Complexity: O(n log n) - dominated by sorting
    Space Complexity: O(n) - for sorting and result storage
    
    Args:
        intervals: List of [start, end] intervals
    
    Returns:
        List of selected intervals
    """
    if not intervals:
        return []
    
    # Sort by END time (ascending) - THIS IS CRUCIAL
    intervals.sort(key=lambda x: x[1])
    
    selected = [intervals[0]]
    last_end = intervals[0][1]
    
    print(f"Step 0: Selected {intervals[0]}, last_end = {last_end}")
    
    for i in range(1, len(intervals)):
        start, end = intervals[i]
        
        # Key condition: non-overlapping check
        if start >= last_end:
            selected.append([start, end])
            last_end = end
            print(f"Step {i}: Selected {[start, end]}, last_end = {last_end}")
        else:
            print(f"Step {i}: Skipped {[start, end]} (overlaps with last_end={last_end})")
    
    return selected

# Detailed Example
intervals = [
    [1, 3],
    [2, 4],
    [3, 5],
    [0, 2],
    [5, 7],
    [8, 9],
    [6, 9]
]

print("Input intervals:", intervals)
print("\nAfter sorting by end time:")
intervals_sorted = sorted(intervals, key=lambda x: x[1])
print(intervals_sorted)
print("\nGreedy Selection Process:")
result = max_non_overlapping_intervals(intervals)
print(f"\nTotal selected: {len(result)} intervals")
print(f"Selected intervals: {result}")

# Visual representation
print("\nVisual Timeline:")
print("Time: 0  1  2  3  4  5  6  7  8  9")
for i, interval in enumerate(intervals):
    start, end = interval
    line = " " * 6 + " " * (start * 3)
    line += "[" + "-" * ((end - start) * 3 - 2) + "]"
    print(f"  {interval}: {line}")
```

### Variation 1: Minimum Intervals to Remove

**LeetCode 435: Non-overlapping Intervals**

```python
def erase_overlap_intervals(intervals):
    """
    Find minimum number of intervals to remove to make rest non-overlapping.
    
    Key Insight: Minimum removals = Total - Maximum non-overlapping
    """
    if not intervals:
        return 0
    
    # Same greedy approach: maximize non-overlapping
    intervals.sort(key=lambda x: x[1])
    
    count = 1  # Count of non-overlapping intervals
    last_end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        if intervals[i][0] >= last_end:
            count += 1
            last_end = intervals[i][1]
    
    # Minimum to remove = total - maximum kept
    return len(intervals) - count

# Example
intervals = [[1,2], [2,3], [3,4], [1,3]]
result = erase_overlap_intervals(intervals)
print(f"Minimum intervals to remove: {result}")

# Explanation:
# Sort by end: [[1,2], [2,3], [1,3], [3,4]]
# Keep: [1,2], [2,3], [3,4] (3 intervals)
# Remove: [1,3] (1 interval)
```

### Variation 2: Minimum Meeting Rooms

**LeetCode 253: Meeting Rooms II**

This is a different twist - instead of selecting, we need to accommodate ALL intervals.

```python
import heapq

def min_meeting_rooms(intervals):
    """
    Find minimum number of meeting rooms needed.
    
    Key Insight: Sort by START time, track end times in heap
    At any point, heap size = rooms needed
    
    Time: O(n log n)
    Space: O(n)
    """
    if not intervals:
        return 0
    
    # Sort by START time (not end time!)
    intervals.sort(key=lambda x: x[0])
    
    # Min-heap to track end times of ongoing meetings
    rooms = []
    
    for start, end in intervals:
        # If earliest ending meeting finishes before this starts,
        # we can reuse that room
        if rooms and rooms[0] <= start:
            heapq.heappop(rooms)
        
        # Assign this meeting to a room
        heapq.heappush(rooms, end)
        
        print(f"Meeting [{start}, {end}]: Rooms in use = {len(rooms)}, End times = {sorted(rooms)}")
    
    return len(rooms)

# Example
meetings = [[0, 30], [5, 10], [15, 20]]
result = min_meeting_rooms(meetings)
print(f"\nMinimum rooms needed: {result}")

# Step-by-step:
# Time:  0    5   10   15   20   25   30
# M1:    [-------------------------]
# M2:         [---]
# M3:              [----]
#
# At time 0: Need room 1 for M1
# At time 5: M1 still ongoing, need room 2 for M2
# At time 15: M2 ended, reuse room 2 for M3
# Max rooms: 2
```

### Variation 3: Minimum Arrows to Burst Balloons

**LeetCode 452: Minimum Number of Arrows**

```python
def find_min_arrow_shots(points):
    """
    Find minimum arrows to burst all balloons.
    Each balloon is an interval; arrow at x bursts all balloons containing x.
    
    Key Insight: Same as finding minimum points to cover all intervals
    = Maximum non-overlapping intervals approach
    
    Time: O(n log n)
    Space: O(1)
    """
    if not points:
        return 0
    
    # Sort by END position
    points.sort(key=lambda x: x[1])
    
    arrows = 1
    arrow_position = points[0][1]  # Shoot at end of first balloon
    
    print(f"Arrow 1 at position {arrow_position}")
    
    for i in range(1, len(points)):
        start, end = points[i]
        
        # If balloon starts after arrow, need new arrow
        if start > arrow_position:
            arrows += 1
            arrow_position = end
            print(f"Arrow {arrows} at position {arrow_position}")
        else:
            print(f"Balloon [{start}, {end}] burst by arrow at {arrow_position}")
    
    return arrows

# Example
balloons = [[10,16], [2,8], [1,6], [7,12]]
result = find_min_arrow_shots(balloons)
print(f"\nMinimum arrows needed: {result}")

# After sorting by end: [[1,6], [2,8], [7,12], [10,16]]
# Arrow 1 at x=6: bursts [1,6] and [2,8]
# Arrow 2 at x=12: bursts [7,12] and [10,16]
# Total: 2 arrows
```

### Key Takeaways: Interval Pattern

1. **Sort by END time** when maximizing selection
2. **Sort by START time** when tracking simultaneous events
3. **Overlap check**: `start >= last_end` (or `start > last_end` for strict)
4. **Pattern recognition**: Any problem about selecting/covering intervals

---

## 2.2 Two-Pointer Greedy

Two pointers move through sorted data making greedy decisions based on relative values.

### Pattern 1: Opposite Ends (Converging Pointers)

**Classic Problem: Container With Most Water (LeetCode 11)**

```python
def max_area(height):
    """
    Find maximum water that can be contained between two lines.
    
    Greedy Insight: Always move the pointer with smaller height
    Why? Moving taller pointer cannot increase area (width decreases, 
         height limited by shorter line)
    
    Time: O(n)
    Space: O(1)
    """
    left, right = 0, len(height) - 1
    max_water = 0
    
    while left < right:
        # Calculate current area
        width = right - left
        current_height = min(height[left], height[right])
        current_area = width * current_height
        max_water = max(max_water, current_area)
        
        print(f"L={left} (h={height[left]}), R={right} (h={height[right]}), "
              f"Width={width}, Area={current_area}")
        
        # Greedy choice: move pointer with smaller height
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    
    return max_water

# Example
heights = [1, 8, 6, 2, 5, 4, 8, 3, 7]
result = max_area(heights)
print(f"\nMaximum area: {result}")

# Visual:
#       8 |     █         █
#       7 |     █         █   █
#       6 |     █ █       █   █
#       5 |     █ █   █   █   █
#       4 |     █ █   █ █ █   █
#       3 |     █ █   █ █ █ █ █
#       2 |     █ █ █ █ █ █ █
#       1 | █   █ █ █ █ █ █ █
#           0 1 2 3 4 5 6 7 8
#
# Max area between indices 1 and 8: 8 * 7 = 49
```

**Why This Greedy Works**:
```python
# Proof by contradiction:
# Suppose we move the taller pointer instead.
# 
# Before: left=L, right=R, height[L] < height[R]
# Area = (R - L) * min(height[L], height[R])
#      = (R - L) * height[L]
#
# If we move R to R-1:
# New area = (R-1 - L) * min(height[L], height[R-1])
#          ≤ (R-1 - L) * height[L]  (height is still limited by L)
#          < (R - L) * height[L]    (smaller width, same height limit)
#
# Moving taller pointer CANNOT improve area!
# So always move shorter pointer (greedy choice).
```

### Pattern 2: Same Direction (Extending Window)

**Problem: Partition Labels (LeetCode 763)**

```python
def partition_labels(s):
    """
    Partition string so each letter appears in at most one part.
    Maximize number of partitions.
    
    Greedy Strategy:
    1. Record last occurrence of each character
    2. Extend current partition to include all occurrences of seen characters
    3. When we reach the end of current partition, make a cut
    
    Time: O(n)
    Space: O(1) - fixed alphabet size
    """
    # Record last occurrence of each character
    last = {char: i for i, char in enumerate(s)}
    
    result = []
    start = 0
    end = 0
    
    for i, char in enumerate(s):
        # Extend partition to include this character's last occurrence
        end = max(end, last[char])
        
        print(f"i={i}, char='{char}', last['{char}']={last[char]}, current_end={end}")
        
        # If we've reached the end of current partition
        if i == end:
            partition_size = end - start + 1
            result.append(partition_size)
            print(f"  → Cut partition: s[{start}:{end+1}] = '{s[start:end+1]}', size={partition_size}\n")
            start = i + 1
    
    return result

# Example
s = "ababcbacadefegdehijhklij"
result = partition_labels(s)
print(f"Partition sizes: {result}")
print(f"Partitions: ", end="")

# Reconstruct partitions
start = 0
for size in result:
    print(f"'{s[start:start+size]}'", end=" ")
    start += size

# Explanation:
# Last occurrence: a:8, b:5, c:7, d:14, e:15, ...
# 
# Process 'a' at 0: must extend to index 8
# Process 'b' at 1: must extend to index 5 (already < 8)
# Process 'a' at 2: already covered
# ...
# At index 8: reached end of first partition → CUT
# 
# Result: ["ababcbaca", "defegde", "hijhklij"]
```

### Pattern 3: Assigning Pairs (Greedy Matching)

**Problem: Assign Cookies (LeetCode 455)**

```python
def find_content_children(g, s):
    """
    Assign cookies to children to maximize number of content children.
    g[i] = greed factor of child i
    s[j] = size of cookie j
    
    Greedy Strategy: Sort both, assign smallest cookie that satisfies smallest child
    
    Why? If smallest cookie can satisfy larger child, save it for future.
    If it can only satisfy smallest child, use it now.
    
    Time: O(n log n + m log m)
    Space: O(1)
    """
    g.sort()  # Sort children by greed
    s.sort()  # Sort cookies by size
    
    child = 0
    cookie = 0
    content = 0
    
    while child < len(g) and cookie < len(s):
        print(f"Child {child} (greed={g[child]}) vs Cookie {cookie} (size={s[cookie]})")
        
        if s[cookie] >= g[child]:
            # Cookie satisfies child
            content += 1
            print(f"  → Match! Content children: {content}")
            child += 1
            cookie += 1
        else:
            # Cookie too small, try next cookie
            print(f"  → Cookie too small, skip cookie")
            cookie += 1
    
    return content

# Example
greed_factors = [1, 2, 3]
cookie_sizes = [1, 1]
result = find_content_children(greed_factors, cookie_sizes)
print(f"\nContent children: {result}")

# After sorting: greed=[1,2,3], cookies=[1,1]
# Child 0 (greed=1) gets cookie 0 (size=1) ✓
# Child 1 (greed=2) gets cookie 1 (size=1) ✗ (too small)
# Result: 1 content child
```

---

## 2.3 Sorting-Based Greedy

The key insight: **Sorting creates order that makes greedy choices obvious.**

### Pattern 1: Sort by Single Criterion

**Problem: Boats to Save People (LeetCode 881)**

```python
def num_rescue_boats(people, limit):
    """
    Each boat carries at most 2 people and weight ≤ limit.
    Minimize number of boats.
    
    Greedy Strategy: Sort weights, pair heaviest with lightest if possible
    
    Time: O(n log n)
    Space: O(1)
    """
    people.sort()
    
    left = 0  # Lightest person
    right = len(people) - 1  # Heaviest person
    boats = 0
    
    while left <= right:
        # Try to pair heaviest with lightest
        if people[left] + people[right] <= limit:
            # Both can fit in one boat
            print(f"Boat {boats + 1}: person {left} ({people[left]} kg) + "
                  f"person {right} ({people[right]} kg) = {people[left] + people[right]} kg")
            left += 1
            right -= 1
        else:
            # Heaviest person alone
            print(f"Boat {boats + 1}: person {right} ({people[right]} kg) alone")
            right -= 1
        
        boats += 1
    
    return boats

# Example
people = [3, 2, 2, 1]
limit = 3
result = num_rescue_boats(people, limit)
print(f"\nMinimum boats: {result}")

# After sorting: [1, 2, 2, 3]
# Pair 1 (1kg) + 3 (3kg) = 4kg > 3kg limit → 3 goes alone
# Pair 1 (1kg) + 2 (2kg) = 3kg ≤ 3kg → together
# Person 2 (2kg) alone
# Total: 3 boats
```

### Pattern 2: Sort by Frequency

**Problem: Task Scheduler (LeetCode 621)**

```python
from collections import Counter
import heapq

def least_interval(tasks, n):
    """
    Schedule tasks with cooldown period n between same tasks.
    Minimize total time.
    
    Greedy Strategy: Always schedule most frequent task (to minimize idle time)
    
    Time: O(N log 26) ≈ O(N) where N is number of tasks
    Space: O(26) = O(1)
    """
    # Count task frequencies
    freq = Counter(tasks)
    
    # Max heap (negate for Python's min heap)
    max_heap = [-count for count for count in freq.values()]
    heapq.heapify(max_heap)
    
    time = 0
    schedule = []
    
    while max_heap:
        temp = []
        cycle = 0
        
        # Fill current cycle (n+1 slots)
        for i in range(n + 1):
            if max_heap:
                count = -heapq.heappop(max_heap)
                schedule.append(f"Task{len(temp)}")
                temp.append(count - 1)
                cycle += 1
            elif temp:  # Need idle if tasks remain
                schedule.append("idle")
                cycle += 1
        
        # Add remaining tasks back to heap
        for count in temp:
            if count > 0:
                heapq.heappush(max_heap, -count)
        
        # If heap empty, we're done (no idle padding needed)
        if not max_heap:
            time += cycle
        else:
            time += n + 1
        
        print(f"Cycle: {schedule[-cycle:]}, Time: {time}")
    
    return time

# Example
tasks = ['A', 'A', 'A', 'B', 'B', 'B']
n = 2
result = least_interval(tasks, n)
print(f"\nMinimum time: {result}")

# Frequency: A=3, B=3
# Cycle 1: A, B, idle (need cooldown)
# Cycle 2: A, B, idle
# Cycle 3: A, B (last, no idle needed)
# Total: 8 time units
```

### Pattern 3: Custom Comparator (Complex Sorting)

**Problem: Queue Reconstruction by Height (LeetCode 406)**

```python
def reconstruct_queue(people):
    """
    people[i] = [h_i, k_i] where:
    - h_i = height of person i
    - k_i = number of people in front with height >= h_i
    
    Greedy Strategy:
    1. Sort by height (desc), then by k (asc)
    2. Insert each person at index k
    
    Why? Taller people don't affect shorter people's k value.
    Process tall to short, inserting at correct position.
    
    Time: O(n^2) due to insertions
    Space: O(n)
    """
    # Sort: tallest first, if equal height, smaller k first
    people.sort(key=lambda x: (-x[0], x[1]))
    
    print("After sorting (tallest first):")
    for i, (h, k) in enumerate(people):
        print(f"  Person {i}: height={h}, k={k}")
    
    result = []
    
    print("\nInsertion process:")
    for h, k in people:
        # Insert at index k
        result.insert(k, [h, k])
        print(f"Insert [{h},{k}] at index {k}: {result}")
    
    return result

# Example
people = [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
result = reconstruct_queue(people)
print(f"\nFinal queue: {result}")

# After sorting: [[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]
#
# Insert [7,0] at 0: [[7,0]]
# Insert [7,1] at 1: [[7,0], [7,1]]
# Insert [6,1] at 1: [[7,0], [6,1], [7,1]]
# Insert [5,0] at 0: [[5,0], [7,0], [6,1], [7,1]]
# Insert [5,2] at 2: [[5,0], [7,0], [5,2], [6,1], [7,1]]
# Insert [4,4] at 4: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```

### Key Insights: When to Sort

```python
# Decision tree for sorting strategy:

# Q: Can sorting help?
# └─ Yes → What should we sort by?
#    ├─ Single attribute (value, weight, time) → Direct sort
#    ├─ Ratio (value/weight, profit/time) → Compute ratio, then sort
#    ├─ Multiple attributes → Custom comparator
#    └─ Order matters (relative positions) → Consider stable sort

# Common sorting patterns:
PATTERNS = {
    "Intervals": "Sort by end time (or start time)",
    "Matching/Assignment": "Sort both arrays",
    "Frequency": "Sort by count (use Counter + heap)",
    "Multi-criteria": "Sort by primary, break ties with secondary",
    "Ratio-based": "Sort by computed ratio (value/weight)",
}
```

---

## Summary: Pattern Recognition Guide

```python
# Quick pattern matching for interviews:

def identify_greedy_pattern(problem_description):
    """
    Pattern recognition guide for greedy problems
    """
    patterns = {
        "intervals, overlapping, non-overlapping, scheduling": 
            "→ Activity Selection Pattern (sort by end time)",
        
        "maximize/minimize, two arrays, pairing, matching":
            "→ Two-Pointer Pattern (sort both, greedy match)",
        
        "frequency, most common, reorganize, cooldown":
            "→ Frequency-based Pattern (Counter + heap)",
        
        "smallest, largest, next greater, comparison":
            "→ Sorting + Greedy traversal",
        
        "fill containers, assign resources, capacity":
            "→ Sort + Greedy filling",
    }
    
    for keywords, pattern in patterns.items():
        if any(kw in problem_description.lower() for kw in keywords.split(", ")):
            return pattern
    
    return "→ May not be greedy, consider DP"

# Test
print(identify_greedy_pattern("Select maximum non-overlapping intervals"))
print(identify_greedy_pattern("Assign cookies to children"))
print(identify_greedy_pattern("Schedule tasks with cooldown"))
```

### Practice Problems for Chapter 2

1. **Easy**: Assign Cookies (LC 455)
2. **Medium**: Non-overlapping Intervals (LC 435)
3. **Medium**: Meeting Rooms II (LC 253)
4. **Medium**: Task Scheduler (LC 621)
5. **Medium**: Partition Labels (LC 763)
6. **Hard**: Queue Reconstruction by Height (LC 406)

Master these patterns, and you'll recognize 70% of greedy problems in interviews!