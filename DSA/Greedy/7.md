# Chapter 7: Implementation Patterns

## 7.1 Template: Interval-Based Greedy

The most common greedy pattern - intervals, scheduling, and selection problems.

### Core Template

```python
def interval_greedy_template(intervals, optimization='maximize'):
    """
    Universal template for interval-based greedy problems.
    
    Args:
        intervals: List of [start, end] or similar structures
        optimization: 'maximize' selections or 'minimize' resources
    
    Returns:
        Result based on problem (count, list, etc.)
    """
    
    # Step 1: Edge case handling
    if not intervals:
        return 0  # or [], or appropriate default
    
    if len(intervals) == 1:
        return 1  # or intervals, or appropriate single-element result
    
    # Step 2: Sort by appropriate criterion
    # For maximizing selections: sort by END time
    # For minimizing resources: sort by START time
    if optimization == 'maximize':
        intervals.sort(key=lambda x: x[1])  # Sort by end time
    else:
        intervals.sort(key=lambda x: x[0])  # Sort by start time
    
    # Step 3: Initialize tracking variables
    result = []  # or counter, or other accumulator
    last_end = float('-inf')  # or intervals[0][1], depending on problem
    
    # Step 4: Greedy selection loop
    for interval in intervals:
        start, end = interval[0], interval[1]
        
        # Greedy decision: take or skip?
        if start >= last_end:  # Non-overlapping condition
            result.append(interval)
            last_end = end
    
    # Step 5: Return result
    return len(result)  # or result, or other format

# Example instantiations of the template
print("=" * 60)
print("INTERVAL TEMPLATE INSTANTIATIONS")
print("=" * 60)
```

### Pattern 1: Maximum Non-Overlapping Intervals

```python
def max_non_overlapping(intervals):
    """
    LeetCode 435: Non-overlapping Intervals (variation)
    Select maximum number of non-overlapping intervals.
    """
    if not intervals:
        return 0
    
    # Sort by end time - KEY INSIGHT
    intervals.sort(key=lambda x: x[1])
    
    count = 1
    last_end = intervals[0][1]
    
    print(f"Sorted intervals: {intervals}")
    print(f"Start with first interval: {intervals[0]}")
    
    for i in range(1, len(intervals)):
        if intervals[i][0] >= last_end:
            count += 1
            last_end = intervals[i][1]
            print(f"  Select interval {i}: {intervals[i]}, count={count}")
        else:
            print(f"  Skip interval {i}: {intervals[i]} (overlaps)")
    
    return count

# Test
intervals = [[1,2], [2,3], [3,4], [1,3]]
result = max_non_overlapping(intervals)
print(f"Maximum non-overlapping: {result}\n")
```

### Pattern 2: Minimum Intervals to Remove

```python
def min_intervals_to_remove(intervals):
    """
    LeetCode 435: Non-overlapping Intervals
    Minimum number to remove to make rest non-overlapping.
    
    Insight: Total - Maximum_kept = Minimum_removed
    """
    if not intervals:
        return 0
    
    intervals.sort(key=lambda x: x[1])
    
    keep_count = 1
    last_end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        if intervals[i][0] >= last_end:
            keep_count += 1
            last_end = intervals[i][1]
    
    remove_count = len(intervals) - keep_count
    
    print(f"Total intervals: {len(intervals)}")
    print(f"Can keep: {keep_count}")
    print(f"Must remove: {remove_count}")
    
    return remove_count

# Test
intervals = [[1,2], [2,3], [3,4], [1,3]]
result = min_intervals_to_remove(intervals)
print(f"Minimum to remove: {result}\n")
```

### Pattern 3: Minimum Meeting Rooms

```python
import heapq

def min_meeting_rooms(intervals):
    """
    LeetCode 253: Meeting Rooms II
    Find minimum meeting rooms needed.
    
    Different from selection - we MUST accommodate ALL intervals.
    Sort by START time, use heap to track end times.
    """
    if not intervals:
        return 0
    
    # Sort by START time - DIFFERENT from selection!
    intervals.sort(key=lambda x: x[0])
    
    # Min-heap of end times
    heap = []
    
    print(f"Sorted by start time: {intervals}")
    
    for start, end in intervals:
        # If earliest meeting ends before this starts, reuse room
        if heap and heap[0] <= start:
            heapq.heappop(heap)
            print(f"Meeting [{start},{end}]: Reuse room (previous ended at {heap[0] if heap else start})")
        else:
            print(f"Meeting [{start},{end}]: Need new room")
        
        heapq.heappush(heap, end)
        print(f"  Active rooms: {len(heap)}, End times: {sorted(heap)}")
    
    return len(heap)

# Test
meetings = [[0,30], [5,10], [15,20]]
result = min_meeting_rooms(meetings)
print(f"Minimum rooms needed: {result}\n")
```

### Pattern 4: Merge Intervals

```python
def merge_intervals(intervals):
    """
    LeetCode 56: Merge Intervals
    Merge all overlapping intervals.
    """
    if not intervals:
        return []
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    merged = [intervals[0]]
    
    print(f"Sorted intervals: {intervals}")
    print(f"Start with: {merged[0]}")
    
    for current in intervals[1:]:
        last_merged = merged[-1]
        
        # Check overlap: current starts before last merged ends
        if current[0] <= last_merged[1]:
            # Merge by extending end time
            merged[-1][1] = max(last_merged[1], current[1])
            print(f"  Merge {current} with {last_merged} → {merged[-1]}")
        else:
            # No overlap, add as new interval
            merged.append(current)
            print(f"  Add new interval: {current}")
    
    return merged

# Test
intervals = [[1,3], [2,6], [8,10], [15,18]]
result = merge_intervals(intervals)
print(f"Merged intervals: {result}\n")
```

---

## 7.2 Template: Priority Queue Greedy

For problems requiring dynamic "best" element selection.

### Core Template

```python
import heapq

def priority_queue_greedy_template(items, k=None):
    """
    Universal template for priority queue greedy problems.
    
    Args:
        items: Input items to process
        k: Optional parameter (k largest, k closest, etc.)
    
    Returns:
        Result based on greedy selection from heap
    """
    
    # Step 1: Build initial heap
    heap = []
    
    # For max-heap, negate values (Python has min-heap by default)
    # For custom comparison, use tuples: (priority, data)
    
    # Step 2: Process items
    for item in items:
        # Extract relevant priority
        priority = get_priority(item)
        
        # Add to heap (negate for max-heap)
        heapq.heappush(heap, (-priority, item))
        
        # Optional: Maintain size k
        if k and len(heap) > k:
            heapq.heappop(heap)
    
    # Step 3: Extract results
    results = []
    while heap:
        priority, item = heapq.heappop(heap)
        results.append(item)
    
    return results

def get_priority(item):
    """Define priority for heap ordering."""
    return item  # Customize based on problem
```

### Pattern 1: K Closest Points

```python
import heapq

def k_closest_points(points, k):
    """
    LeetCode 973: K Closest Points to Origin
    Find k points closest to origin.
    
    Greedy: Always maintain k closest points seen so far.
    """
    # Max-heap of distances (negate for max behavior)
    # Store: (-distance, point)
    heap = []
    
    print(f"Finding {k} closest points to origin")
    
    for point in points:
        x, y = point
        distance = x*x + y*y  # Squared distance (avoid sqrt)
        
        if len(heap) < k:
            # Haven't found k points yet
            heapq.heappush(heap, (-distance, point))
            print(f"  Add {point} (dist²={distance}), heap_size={len(heap)}")
        elif distance < -heap[0][0]:
            # This point is closer than farthest in heap
            removed = heapq.heappop(heap)
            heapq.heappush(heap, (-distance, point))
            print(f"  Replace {removed[1]} with {point} (dist²={distance})")
        else:
            print(f"  Skip {point} (dist²={distance} too large)")
    
    # Extract points (ignore distances)
    result = [point for _, point in heap]
    return result

# Test
points = [[1,3], [-2,2], [5,8], [0,1]]
k = 2
result = k_closest_points(points, k)
print(f"K closest points: {result}\n")
```

### Pattern 2: Task Scheduler with Cooldown

```python
from collections import Counter
import heapq

def task_scheduler(tasks, n):
    """
    LeetCode 621: Task Scheduler
    Schedule tasks with cooldown n between same task.
    
    Greedy: Always execute most frequent available task.
    """
    freq = Counter(tasks)
    
    # Max-heap of frequencies
    max_heap = [-count for count in freq.values()]
    heapq.heapify(max_heap)
    
    time = 0
    
    print(f"Tasks: {tasks}, Cooldown: {n}")
    print(f"Initial frequencies: {dict(freq)}\n")
    
    while max_heap:
        temp = []  # Store tasks executed in this cycle
        
        # Execute tasks in current cycle (n+1 slots)
        for i in range(n + 1):
            if max_heap:
                freq = -heapq.heappop(max_heap)
                temp.append(freq - 1)
                time += 1
                print(f"Time {time}: Execute task (remaining freq={freq-1})")
            elif temp:
                # Must idle (still have tasks but in cooldown)
                time += 1
                print(f"Time {time}: IDLE")
        
        # Add back tasks with remaining frequency
        for freq in temp:
            if freq > 0:
                heapq.heappush(max_heap, -freq)
    
    return time

# Test
tasks = ['A', 'A', 'A', 'B', 'B', 'B']
n = 2
result = task_scheduler(tasks, n)
print(f"\nTotal time: {result}\n")
```

### Pattern 3: Merge K Sorted Lists

```python
import heapq

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_k_sorted_lists(lists):
    """
    LeetCode 23: Merge K Sorted Lists
    Merge k sorted linked lists into one sorted list.
    
    Greedy: Always take minimum head from k lists.
    """
    # Min-heap: (value, list_index, node)
    heap = []
    
    # Add first node from each list
    for i, head in enumerate(lists):
        if head:
            heapq.heappush(heap, (head.val, i, head))
    
    dummy = ListNode(0)
    current = dummy
    
    print("Merging k sorted lists...")
    
    while heap:
        val, list_idx, node = heapq.heappop(heap)
        
        # Add to result
        current.next = node
        current = current.next
        print(f"  Take {val} from list {list_idx}")
        
        # Add next node from same list
        if node.next:
            heapq.heappush(heap, (node.next.val, list_idx, node.next))
    
    return dummy.next

# Helper to create and print lists
def create_list(arr):
    dummy = ListNode(0)
    current = dummy
    for val in arr:
        current.next = ListNode(val)
        current = current.next
    return dummy.next

def list_to_array(head):
    result = []
    while head:
        result.append(head.val)
        head = head.next
    return result

# Test
lists = [
    create_list([1, 4, 5]),
    create_list([1, 3, 4]),
    create_list([2, 6])
]

result = merge_k_sorted_lists(lists)
print(f"Merged list: {list_to_array(result)}\n")
```

---

## 7.3 Template: Two-Pass Greedy

For problems with conflicting constraints from different directions.

### Core Template

```python
def two_pass_greedy_template(arr):
    """
    Universal template for two-pass greedy problems.
    
    Use when:
    - Constraints come from both left and right
    - Need to satisfy neighbors in both directions
    - One pass can't capture all requirements
    """
    n = len(arr)
    
    # Step 1: Initialize result arrays
    left_to_right = [initial_value] * n
    right_to_left = [initial_value] * n
    
    # Step 2: Left to right pass
    for i in range(n):
        # Compute based on left neighbor
        if i > 0:
            left_to_right[i] = compute_from_left(arr, left_to_right, i)
    
    # Step 3: Right to left pass
    for i in range(n - 1, -1, -1):
        # Compute based on right neighbor
        if i < n - 1:
            right_to_left[i] = compute_from_right(arr, right_to_left, i)
    
    # Step 4: Combine results (usually max/min of both)
    result = [combine(left_to_right[i], right_to_left[i]) for i in range(n)]
    
    return result

def compute_from_left(arr, result, i):
    """Compute value based on left context."""
    pass

def compute_from_right(arr, result, i):
    """Compute value based on right context."""
    pass

def combine(left_val, right_val):
    """Combine left and right pass results."""
    return max(left_val, right_val)
```

### Pattern 1: Candy Distribution

```python
def candy(ratings):
    """
    LeetCode 135: Candy
    Distribute candies satisfying neighbor constraints.
    
    Constraints:
    - Each child gets at least 1 candy
    - If rating[i] > rating[i-1], candy[i] > candy[i-1]
    - If rating[i] > rating[i+1], candy[i] > candy[i+1]
    
    Two-pass greedy handles both constraints.
    """
    n = len(ratings)
    candies = [1] * n
    
    print(f"Ratings: {ratings}\n")
    
    # Pass 1: Left to right (satisfy right neighbor)
    print("Pass 1: Left to Right")
    for i in range(1, n):
        if ratings[i] > ratings[i-1]:
            candies[i] = candies[i-1] + 1
            print(f"  Child {i}: rating {ratings[i]} > {ratings[i-1]} → candy={candies[i]}")
    
    print(f"After pass 1: {candies}\n")
    
    # Pass 2: Right to left (satisfy left neighbor)
    print("Pass 2: Right to Left")
    for i in range(n-2, -1, -1):
        if ratings[i] > ratings[i+1]:
            # Take max to preserve pass 1 constraints
            candies[i] = max(candies[i], candies[i+1] + 1)
            print(f"  Child {i}: rating {ratings[i]} > {ratings[i+1]} → candy={candies[i]}")
    
    print(f"After pass 2: {candies}")
    
    total = sum(candies)
    print(f"\nTotal candies: {total}")
    
    return total

# Test
ratings = [1, 0, 2]
result = candy(ratings)
print()
```

### Pattern 2: Trapping Rain Water

```python
def trap_rain_water(height):
    """
    LeetCode 42: Trapping Rain Water
    Calculate water trapped between elevation map.
    
    Water at position i = min(max_left, max_right) - height[i]
    
    Two-pass to compute max_left and max_right for each position.
    """
    if not height:
        return 0
    
    n = len(height)
    
    # Pass 1: Compute max height to the left
    max_left = [0] * n
    max_left[0] = height[0]
    for i in range(1, n):
        max_left[i] = max(max_left[i-1], height[i])
    
    # Pass 2: Compute max height to the right
    max_right = [0] * n
    max_right[n-1] = height[n-1]
    for i in range(n-2, -1, -1):
        max_right[i] = max(max_right[i+1], height[i])
    
    # Compute water at each position
    water = 0
    print(f"Height: {height}")
    print(f"Max left:  {max_left}")
    print(f"Max right: {max_right}\n")
    
    for i in range(n):
        water_at_i = min(max_left[i], max_right[i]) - height[i]
        water += water_at_i
        if water_at_i > 0:
            print(f"Position {i}: water={water_at_i}")
    
    print(f"\nTotal water: {water}")
    return water

# Test
height = [0,1,0,2,1,0,1,3,2,1,2,1]
result = trap_rain_water(height)
print()
```

---

## 7.4 Template: Sorting + Greedy Traversal

When sorting reveals the greedy structure.

### Core Template

```python
def sort_and_traverse_template(items):
    """
    Universal template for sort + greedy traverse problems.
    
    Steps:
    1. Sort by appropriate criterion
    2. Traverse in sorted order
    3. Make greedy decisions
    4. Update state
    """
    
    # Step 1: Sort (define key function)
    items.sort(key=lambda x: sort_criterion(x))
    
    # Step 2: Initialize state
    state = initialize_state()
    result = []
    
    # Step 3: Greedy traversal
    for item in items:
        # Make greedy decision
        if should_take(item, state):
            result.append(item)
            update_state(state, item)
    
    return result

def sort_criterion(item):
    """Define how to sort items."""
    return item

def should_take(item, state):
    """Decide whether to take current item."""
    return True

def update_state(state, item):
    """Update state after taking item."""
    pass

def initialize_state():
    """Initialize tracking state."""
    return {}
```

### Pattern 1: Assign Cookies

```python
def assign_cookies(g, s):
    """
    LeetCode 455: Assign Cookies
    Assign cookies to children to maximize satisfied children.
    
    Greedy: Sort both, match smallest cookie to smallest child.
    """
    g.sort()  # Child greed factors
    s.sort()  # Cookie sizes
    
    child = 0
    cookie = 0
    
    print(f"Children greed: {g}")
    print(f"Cookie sizes: {s}\n")
    
    while child < len(g) and cookie < len(s):
        if s[cookie] >= g[child]:
            # Cookie satisfies child
            print(f"Cookie {cookie} (size={s[cookie]}) satisfies child {child} (greed={g[child]})")
            child += 1
        else:
            print(f"Cookie {cookie} (size={s[cookie]}) too small for child {child} (greed={g[child]})")
        cookie += 1
    
    print(f"\nSatisfied children: {child}")
    return child

# Test
g = [1, 2, 3]
s = [1, 1]
result = assign_cookies(g, s)
print()
```

### Pattern 2: Boats to Save People

```python
def num_rescue_boats(people, limit):
    """
    LeetCode 881: Boats to Save People
    Each boat carries at most 2 people with total weight ≤ limit.
    
    Greedy: Sort weights, pair heaviest with lightest.
    """
    people.sort()
    
    left = 0  # Lightest
    right = len(people) - 1  # Heaviest
    boats = 0
    
    print(f"People weights (sorted): {people}")
    print(f"Weight limit: {limit}\n")
    
    while left <= right:
        if people[left] + people[right] <= limit:
            # Both fit
            print(f"Boat {boats+1}: {people[left]} + {people[right]} = {people[left] + people[right]}")
            left += 1
            right -= 1
        else:
            # Only heaviest
            print(f"Boat {boats+1}: {people[right]} alone")
            right -= 1
        boats += 1
    
    print(f"\nTotal boats: {boats}")
    return boats

# Test
people = [3, 2, 2, 1]
limit = 3
result = num_rescue_boats(people, limit)
print()
```

---

## 7.5 Implementation Best Practices

### Practice 1: Clean Edge Case Handling

```python
def greedy_with_clean_edges(arr):
    """
    Best practice: Handle edge cases at the start.
    """
    # Early returns for edge cases
    if not arr:
        return 0
    
    if len(arr) == 1:
        return arr[0]
    
    # Main algorithm (no edge case clutter)
    result = process_main_algorithm(arr)
    
    return result

def process_main_algorithm(arr):
    """Main logic without edge case handling."""
    # Clean, focused implementation
    return sum(arr)
```

### Practice 2: Meaningful Variable Names

```python
# BAD: Cryptic names
def bad_example(arr):
    c = 0
    e = arr[0][1]
    for i in range(1, len(arr)):
        if arr[i][0] >= e:
            c += 1
            e = arr[i][1]
    return c

# GOOD: Clear names
def good_example(intervals):
    """Select maximum non-overlapping intervals."""
    count = 0
    last_end_time = intervals[0][1]
    
    for interval in intervals[1:]:
        start_time = interval[0]
        end_time = interval[1]
        
        if start_time >= last_end_time:
            count += 1
            last_end_time = end_time
    
    return count
```

### Practice 3: Comments for Greedy Logic

```python
def well_documented_greedy(intervals):
    """
    Select maximum non-overlapping intervals.
    
    Greedy Strategy: Always pick interval that finishes earliest.
    This leaves maximum room for subsequent intervals.
    
    Time: O(n log n) - sorting dominates
    Space: O(1) - only tracking variables
    """
    if not intervals:
        return 0
    
    # Sort by end time - this is the key greedy insight
    intervals.sort(key=lambda x: x[1])
    
    count = 1  # Always take first interval
    last_end = intervals[0][1]
    
    for interval in intervals[1:]:
        # Greedy choice: take if non-overlapping
        if interval[0] >= last_end:
            count += 1
            last_end = interval[1]
    
    return count
```

---

## Summary: Implementation Checklist

```python
def implementation_checklist():
    """
    Checklist for clean greedy implementations.
    """
    
    checklist = """
    ============================================================
    GREEDY IMPLEMENTATION CHECKLIST
    ============================================================
    
    BEFORE CODING:
    □ Identified correct greedy pattern (interval, heap, etc.)
    □ Determined sorting criterion (if needed)
    □ Know what state to track
    □ Clear on loop termination condition
    
    DURING CODING:
    □ Handle edge cases first (empty, single element)
    □ Use meaningful variable names
    □ Add comments for greedy logic
    □ Keep loop body simple and clear
    
    STRUCTURE:
    □ Sorting (if needed)
    □ Initialize state variables
    □ Main greedy loop:
      □ Make greedy decision
      □ Update state
      □ Track result
    □ Return result
    
    AFTER CODING:
    □ Walk through with example
    □ Check edge cases
    □ Verify time/space complexity
    □ Test with interviewer's examples
    
    COMMON PATTERNS TO REMEMBER:
    □ Intervals → sort by end time (usually)
    □ Resources → sort by start time
    □ Values → sort by value or ratio
    □ Heap → when need dynamic "best"
    □ Two-pass → when constraints from both sides
    
    ============================================================
    """
    
    print(checklist)

implementation_checklist()
```

This completes Chapter 7 with practical, reusable templates for all major greedy patterns!