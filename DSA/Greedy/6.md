# Chapter 6: Problem Recognition & Strategy

## 6.1 Identifying Greedy Problems

The ability to quickly recognize greedy problems is crucial in interviews. Let's develop a systematic approach.

### Red Flag Analysis System

```python
class GreedyDetector:
    """
    A systematic framework for identifying greedy problems.
    """
    
    def __init__(self, problem_description):
        self.description = problem_description.lower()
        self.signals = {
            'strong_greedy': [],
            'possible_greedy': [],
            'not_greedy': []
        }
    
    def analyze(self):
        """Run all detection heuristics."""
        self.check_keywords()
        self.check_structure()
        self.check_constraints()
        return self.make_decision()
    
    def check_keywords(self):
        """Check for keyword indicators."""
        # Strong indicators
        strong_keywords = [
            'maximum number of',
            'minimum number of',
            'earliest',
            'latest',
            'interval',
            'schedule',
            'select',
            'non-overlapping',
            'highest',
            'lowest',
            'minimum cost',
            'maximum profit'
        ]
        
        for keyword in strong_keywords:
            if keyword in self.description:
                self.signals['strong_greedy'].append(f"Keyword: '{keyword}'")
        
        # Possible indicators
        possible_keywords = [
            'optimize',
            'best',
            'arrange',
            'assign',
            'order',
            'sort'
        ]
        
        for keyword in possible_keywords:
            if keyword in self.description:
                self.signals['possible_greedy'].append(f"Keyword: '{keyword}'")
        
        # Anti-indicators (suggest DP instead)
        anti_keywords = [
            'subsequence',
            'count ways',
            'how many ways',
            'all possible',
            'combinations',
            'paths from',
            'longest common',
            'edit distance'
        ]
        
        for keyword in anti_keywords:
            if keyword in self.description:
                self.signals['not_greedy'].append(f"DP keyword: '{keyword}'")
    
    def check_structure(self):
        """Check problem structure."""
        # Greedy-friendly structures
        if 'interval' in self.description or 'meeting' in self.description:
            self.signals['strong_greedy'].append("Structure: Interval problem")
        
        if 'graph' in self.description and ('minimum' in self.description or 'shortest' in self.description):
            self.signals['strong_greedy'].append("Structure: Graph optimization")
        
        # DP-friendly structures
        if 'matrix' in self.description and 'path' in self.description:
            self.signals['not_greedy'].append("Structure: Matrix pathfinding (likely DP)")
    
    def check_constraints(self):
        """Check constraint patterns."""
        if 'one choice affects another' in self.description:
            self.signals['not_greedy'].append("Constraint: Interdependent choices")
        
        if 'irreversible' in self.description or 'commit' in self.description:
            self.signals['possible_greedy'].append("Constraint: Irreversible decisions")
    
    def make_decision(self):
        """Make final decision."""
        print("=" * 60)
        print("GREEDY PROBLEM DETECTION ANALYSIS")
        print("=" * 60)
        
        print("\n✓ STRONG GREEDY SIGNALS:")
        for signal in self.signals['strong_greedy']:
            print(f"  • {signal}")
        
        print("\n? POSSIBLE GREEDY SIGNALS:")
        for signal in self.signals['possible_greedy']:
            print(f"  • {signal}")
        
        print("\n✗ ANTI-GREEDY SIGNALS:")
        for signal in self.signals['not_greedy']:
            print(f"  • {signal}")
        
        score = len(self.signals['strong_greedy']) * 3 + \
                len(self.signals['possible_greedy']) - \
                len(self.signals['not_greedy']) * 2
        
        print(f"\nSCORE: {score}")
        
        if score >= 5:
            return "LIKELY GREEDY"
        elif score >= 2:
            return "POSSIBLY GREEDY - Test with examples"
        else:
            return "PROBABLY NOT GREEDY - Consider DP/other approaches"

# Test the detector
problems = [
    "Find the maximum number of non-overlapping intervals",
    "Count the number of ways to reach the end of an array",
    "Schedule meetings to minimize the number of rooms needed",
    "Find the longest common subsequence between two strings",
    "Select maximum profit by scheduling non-conflicting jobs"
]

for i, problem in enumerate(problems):
    print(f"\n{'='*60}")
    print(f"PROBLEM {i+1}: {problem}")
    print('='*60)
    detector = GreedyDetector(problem)
    result = detector.analyze()
    print(f"\n→ DECISION: {result}\n")
```

### Pattern Recognition Flowchart

```python
def greedy_decision_tree(problem):
    """
    A decision tree approach to recognize greedy problems.
    """
    print("=" * 60)
    print("GREEDY RECOGNITION DECISION TREE")
    print("=" * 60)
    
    questions = [
        {
            'q': "Does the problem ask for maximum/minimum of something?",
            'yes': 'continue',
            'no': 'probably_not_greedy'
        },
        {
            'q': "Is it about selecting, scheduling, or arranging items?",
            'yes': 'continue',
            'no': 'check_graph'
        },
        {
            'q': "Are items independent or weakly dependent?",
            'yes': 'likely_greedy',
            'no': 'check_dp'
        }
    ]
    
    # This is a simplified interactive version
    print("""
    Q1: Is it an optimization problem (max/min)?
        YES → Continue to Q2
        NO → Likely not greedy (maybe search/enumeration)
    
    Q2: Does it involve selection/scheduling/intervals?
        YES → Continue to Q3
        NO → Check if it's a graph problem
    
    Q3: Can you make local choices without considering all possibilities?
        YES → GREEDY (with high confidence)
        NO → Probably DP
    
    Q4: (For graph problems) Are edges non-negative?
        YES → Greedy (Dijkstra/MST)
        NO → Not greedy (Bellman-Ford)
    
    Q5: Does "greedy stays ahead" or "exchange argument" apply?
        YES → GREEDY
        NO → DP
    """)

# Example walkthrough
def analyze_problem_interactively():
    """Step-by-step problem analysis."""
    
    problem = """
    Problem: Given N activities with start and end times,
    select the maximum number of activities that don't overlap.
    """
    
    print("PROBLEM:", problem)
    print("\n" + "=" * 60)
    print("STEP-BY-STEP ANALYSIS")
    print("=" * 60)
    
    analysis = """
    STEP 1: Identify the type
    ✓ Optimization problem (maximize count)
    ✓ Selection problem (choose activities)
    
    STEP 2: Check for greedy signals
    ✓ "Maximum number" - optimization
    ✓ "Non-overlapping" - scheduling constraint
    ✓ Activities are independent (one doesn't affect another's time)
    
    STEP 3: Test greedy hypothesis
    Greedy strategy: "Always pick activity that finishes earliest"
    
    Example: Activities [(1,3), (2,4), (3,5)]
    - Pick (1,3) - finishes earliest ✓
    - Can pick (3,5) next ✓
    - Result: 2 activities
    
    Try another strategy: "Pick shortest activity"
    - All same length in this case
    - Gives same result
    
    STEP 4: Look for counterexample
    Activities: [(0,10), (1,2), (3,4), (5,6), (7,8), (9,10)]
    
    Greedy (earliest finish): Pick (1,2), (3,4), (5,6), (7,8), (9,10) = 5 activities ✓
    Alternative: Pick (0,10) = 1 activity ✗
    
    Greedy is better! ✓
    
    STEP 5: Can we prove it?
    Exchange argument: If optimal doesn't pick earliest-finishing,
    we can swap it in without making solution worse.
    
    CONCLUSION: ✓ GREEDY PROBLEM
    Strategy: Sort by end time, select greedily
    """
    
    print(analysis)

analyze_problem_interactively()
```

### The Counterexample Test

```python
def test_greedy_with_counterexamples():
    """
    The most reliable test: try to find a counterexample.
    If you can't find one after several attempts, greedy likely works.
    """
    
    print("=" * 60)
    print("COUNTEREXAMPLE TESTING METHODOLOGY")
    print("=" * 60)
    
    methodology = """
    When you suspect a greedy approach:
    
    1. STATE YOUR GREEDY STRATEGY CLEARLY
       Example: "Always pick the interval that ends earliest"
    
    2. CREATE SMALL TEST CASES
       - Start with 2-3 elements
       - Try edge cases (all same, all different, one extreme)
    
    3. TRY TO BREAK IT
       - What if one element is much larger/smaller?
       - What if all elements are equal?
       - What if there's a tie in your greedy criterion?
    
    4. COMPARE WITH BRUTE FORCE
       - For small inputs, enumerate all possibilities
       - Check if greedy matches optimal
    
    5. IF NO COUNTEREXAMPLE FOUND
       - Greedy likely works
       - Proceed to proof or implementation
    """
    
    print(methodology)
    
    # Example: Testing "pick highest profit first" for 0/1 knapsack
    print("\n" + "=" * 60)
    print("EXAMPLE: Testing 0/1 Knapsack Greedy")
    print("=" * 60)
    
    def test_knapsack_greedy():
        items = [
            (60, 10, "A"),  # (value, weight, name)
            (100, 20, "B"),
            (120, 30, "C")
        ]
        capacity = 50
        
        print(f"\nItems: {[(name, v, w) for v, w, name in items]}")
        print(f"Capacity: {capacity}")
        
        # Test 1: Greedy by value
        print("\n--- Test 1: Greedy by highest value ---")
        sorted_by_value = sorted(items, key=lambda x: x[0], reverse=True)
        greedy_value = 0
        greedy_weight = 0
        selected = []
        
        for value, weight, name in sorted_by_value:
            if greedy_weight + weight <= capacity:
                greedy_value += value
                greedy_weight += weight
                selected.append(name)
        
        print(f"Selected: {selected}")
        print(f"Total value: {greedy_value}")
        
        # Test 2: Optimal solution
        print("\n--- Optimal Solution (brute force) ---")
        print("Try all combinations:")
        print("  {} = 0")
        print("  {A} = 60")
        print("  {B} = 100")
        print("  {C} = 120")
        print("  {A,B} = 160, weight=30 ✓")
        print("  {A,C} = 180, weight=40 ✓")
        print("  {B,C} = 220, weight=50 ✓ ← OPTIMAL")
        print("  {A,B,C} = 280, weight=60 ✗ (too heavy)")
        
        print(f"\nOptimal value: 220")
        print(f"Greedy value: {greedy_value}")
        print(f"\n→ COUNTEREXAMPLE FOUND! Greedy ≠ Optimal")
        print("→ This problem needs DP, not greedy")
    
    test_knapsack_greedy()

test_greedy_with_counterexamples()
```

---

## 6.2 Proving Greedy Correctness

Once you've identified a greedy problem, you need to justify why it works.

### Proof Template Library

```python
class GreedyProofGenerator:
    """
    Templates for common greedy proof techniques.
    """
    
    @staticmethod
    def exchange_argument_template():
        """Template for exchange argument proofs."""
        return """
        ========================================
        EXCHANGE ARGUMENT PROOF TEMPLATE
        ========================================
        
        Goal: Prove greedy choice is in some optimal solution
        
        Structure:
        1. Let G = greedy solution
           Let O = optimal solution
        
        2. If G = O, done (greedy is optimal)
        
        3. If G ≠ O, find first difference:
           - G chooses element g
           - O chooses element o (where g ≠ o)
        
        4. Construct O' by swapping o with g in O
        
        5. Prove O' is valid (satisfies constraints)
        
        6. Prove cost(O') ≤ cost(O)
           (or benefit(O') ≥ benefit(O))
        
        7. Therefore, optimal solution exists that includes greedy choice
        
        8. By induction on remaining choices, greedy is optimal
        
        ========================================
        
        EXAMPLE: Activity Selection
        
        1. G picks activity with earliest finish time f₁
           O picks some other activity with finish time f₂
        
        2. Construct O': Replace f₂ with f₁ in O
        
        3. O' is valid because:
           - f₁ finishes before f₂ (by greedy choice)
           - Activities compatible with f₂ are compatible with f₁
        
        4. |O'| = |O| (same number of activities)
        
        5. Therefore, greedy choice is in some optimal solution
        
        6. Remaining problem: select from activities starting after f₁
           This is a subproblem with same structure
        
        7. By induction, greedy is optimal ✓
        """
    
    @staticmethod
    def stays_ahead_template():
        """Template for stays-ahead proofs."""
        return """
        ========================================
        GREEDY STAYS AHEAD PROOF TEMPLATE
        ========================================
        
        Goal: Prove greedy is always ≥ optimal at every step
        
        Structure:
        1. Define a measure of "progress"
        
        2. Show that after k steps:
           progress(greedy) ≥ progress(optimal)
        
        3. Base case: k=0 (initially equal)
        
        4. Inductive step: Assume true for k
           Prove for k+1
        
        5. Since greedy is ahead at every step,
           and both make n steps total,
           greedy achieves optimal result
        
        ========================================
        
        EXAMPLE: Fractional Knapsack
        
        Measure: Total value accumulated
        
        1. After k items, let:
           - V_G = greedy value
           - V_O = optimal value
           - W_G = greedy weight ≤ W_O
        
        2. Claim: V_G/W_G ≥ V_O/W_O (greedy has better ratio)
        
        3. Proof: Greedy always picks highest ratio available
           If optimal picks lower ratio, we can improve it
        
        4. At capacity: V_G ≥ V_O
        
        5. Therefore greedy is optimal ✓
        """
    
    @staticmethod
    def contradiction_template():
        """Template for proof by contradiction."""
        return """
        ========================================
        PROOF BY CONTRADICTION TEMPLATE
        ========================================
        
        Goal: Prove greedy choice is necessary for optimal solution
        
        Structure:
        1. Assume greedy is NOT optimal
        
        2. Then there exists a better solution S
        
        3. Analyze properties of S
        
        4. Show S must include greedy choice
           (or can be modified to include it without loss)
        
        5. Contradiction! Therefore greedy is optimal
        
        ========================================
        
        EXAMPLE: Huffman Coding
        
        1. Assume greedy (merge two lowest frequencies) is not optimal
        
        2. Let T be optimal tree with lower cost than greedy
        
        3. In T, the two lowest-frequency symbols must be siblings
           at maximum depth (else we could improve T)
        
        4. But this is exactly what greedy does!
        
        5. Contradiction: T must use greedy choice
        
        6. Therefore greedy is optimal ✓
        """

# Print all templates
prover = GreedyProofGenerator()
print(prover.exchange_argument_template())
print("\n")
print(prover.stays_ahead_template())
print("\n")
print(prover.contradiction_template())
```

### Proof in Practice: Complete Example

```python
def prove_interval_scheduling_complete():
    """
    Complete proof for interval scheduling problem.
    """
    
    print("=" * 60)
    print("COMPLETE PROOF: INTERVAL SCHEDULING")
    print("=" * 60)
    
    proof = """
    PROBLEM:
    Given n intervals [s₁,f₁], [s₂,f₂], ..., [sₙ,fₙ]
    Select maximum number of non-overlapping intervals
    
    GREEDY STRATEGY:
    Sort by finish time, always pick earliest-finishing available interval
    
    ============================================================
    PROOF (Exchange Argument)
    ============================================================
    
    CLAIM: Greedy produces optimal solution
    
    PROOF:
    
    Let I = {i₁, i₂, ..., iₖ} be intervals sorted by finish time
        where f(i₁) ≤ f(i₂) ≤ ... ≤ f(iₖ)
    
    Let G = greedy solution = {i₁, i₂, ..., iₘ}
    Let O = optimal solution = {j₁, j₂, ..., jₙ}
    
    We prove: m = n (greedy finds optimal number)
    
    --- Part 1: Greedy stays ahead ---
    
    Lemma: For all r ≤ min(m,n), f(iᵣ) ≤ f(jᵣ)
    (Greedy's rth interval finishes no later than optimal's rth)
    
    Proof by induction on r:
    
    Base case (r=1):
        i₁ has earliest finish time among all intervals (by greedy)
        Therefore f(i₁) ≤ f(j₁) ✓
    
    Inductive step:
        Assume f(iᵣ) ≤ f(jᵣ)
        Prove f(iᵣ₊₁) ≤ f(jᵣ₊₁)
        
        Since O is valid: s(jᵣ₊₁) ≥ f(jᵣ)
        By induction: f(jᵣ) ≥ f(iᵣ)
        Therefore: s(jᵣ₊₁) ≥ f(iᵣ)
        
        This means jᵣ₊₁ is available when greedy considers iᵣ₊₁
        Greedy picks earliest-finishing available interval
        Therefore: f(iᵣ₊₁) ≤ f(jᵣ₊₁) ✓
    
    --- Part 2: Greedy finds optimal number ---
    
    Assume for contradiction: m < n (greedy finds fewer intervals)
    
    From Lemma: f(iₘ) ≤ f(jₘ)
    Since O has n > m intervals: jₘ₊₁ exists
    Since O is valid: s(jₘ₊₁) ≥ f(jₘ)
    Therefore: s(jₘ₊₁) ≥ f(iₘ)
    
    This means jₘ₊₁ is compatible with greedy's last interval iₘ
    But greedy terminated, meaning no compatible intervals remain
    
    Contradiction! ✗
    
    Therefore: m ≥ n
    
    Since O is optimal: n ≥ m (O has maximum possible intervals)
    
    Therefore: m = n ✓
    
    CONCLUSION: Greedy produces optimal solution ■
    
    ============================================================
    """
    
    print(proof)
    
    # Visual demonstration
    print("\n" + "=" * 60)
    print("VISUAL DEMONSTRATION")
    print("=" * 60)
    
    visualization = """
    Example intervals:
    
    Time:  0    2    4    6    8    10   12
    
    A:     [----]
    B:          [----]
    C:     [----------]
    D:               [----]
    E:                    [----]
    
    Sorted by finish time: A(4), B(6), C(8), D(10), E(12)
    
    Greedy selection:
    Step 1: Pick A (earliest finish = 4)
    Step 2: Pick B (starts at 4, earliest finish = 6)
    Step 3: Pick D (starts at 6, earliest finish = 10)
    Step 4: Pick E (starts at 10, earliest finish = 12)
    Result: {A, B, D, E} = 4 intervals
    
    Why not pick C?
    - C finishes at 8
    - But conflicts with B (which finishes earlier at 6)
    - Picking B leaves more room for future intervals
    
    Optimal solution: {A, B, D, E} = 4 intervals ✓
    """
    
    print(visualization)

prove_interval_scheduling_complete()
```

---

## 6.3 Common Pitfalls

Learn from common mistakes to avoid them in interviews.

### Pitfall 1: Assuming Greedy Works Without Proof

```python
def demonstrate_pitfall_1():
    """
    Mistake: Using greedy without verifying correctness.
    """
    
    print("=" * 60)
    print("PITFALL #1: Unverified Greedy Assumptions")
    print("=" * 60)
    
    problem = """
    PROBLEM: Minimum number of coins to make change
    Coins: [1, 3, 4]
    Target: 6
    
    NAIVE GREEDY THINKING:
    "Just pick the largest coin that fits!"
    
    Greedy approach:
    - Pick 4 (largest ≤ 6) → remaining = 2
    - Pick 1 → remaining = 1
    - Pick 1 → remaining = 0
    Result: 3 coins [4, 1, 1]
    
    COUNTEREXAMPLE:
    Optimal solution: [3, 3] = 2 coins ✓
    
    LESSON: Greedy doesn't always work!
    This problem needs Dynamic Programming.
    
    ============================================================
    
    HOW TO AVOID:
    1. ✓ State greedy strategy explicitly
    2. ✓ Test with multiple examples
    3. ✓ Try to find counterexample
    4. ✓ Prove correctness or use DP
    """
    
    print(problem)
    
    # Demonstrate correct approach
    print("\n--- Correct DP Solution ---")
    
    def coin_change_dp(coins, amount):
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        
        for i in range(1, amount + 1):
            for coin in coins:
                if coin <= i:
                    dp[i] = min(dp[i], dp[i - coin] + 1)
        
        return dp[amount] if dp[amount] != float('inf') else -1
    
    coins = [1, 3, 4]
    target = 6
    result = coin_change_dp(coins, target)
    print(f"Coins: {coins}, Target: {target}")
    print(f"Minimum coins needed: {result}")

demonstrate_pitfall_1()
```

### Pitfall 2: Wrong Greedy Criterion

```python
def demonstrate_pitfall_2():
    """
    Mistake: Choosing wrong sorting criterion for greedy.
    """
    
    print("\n" + "=" * 60)
    print("PITFALL #2: Wrong Greedy Criterion")
    print("=" * 60)
    
    explanation = """
    PROBLEM: Job scheduling with deadlines and profits
    
    Jobs: [(profit, deadline)]
    [
        (100, 2),  # Job A
        (19, 1),   # Job B
        (27, 2),   # Job C
        (25, 1)    # Job D
    ]
    
    WRONG CRITERIA TO TEST:
    """
    
    print(explanation)
    
    jobs = [(100, 2, 'A'), (19, 1, 'B'), (27, 2, 'C'), (25, 1, 'D')]
    
    # Wrong 1: Sort by profit only
    print("\n--- Test 1: Sort by PROFIT (descending) ---")
    sorted_jobs = sorted(jobs, key=lambda x: x[0], reverse=True)
    print("Order:", [j[2] for j in sorted_jobs])
    print("Try: A(deadline=2), B(deadline=1) - Can we schedule both?")
    print("  A at time 2: ✓")
    print("  B at time 1: ✓")
    print("Total profit: 100 + 19 = 119")
    
    # Wrong 2: Sort by deadline only
    print("\n--- Test 2: Sort by DEADLINE (ascending) ---")
    sorted_jobs = sorted(jobs, key=lambda x: x[1])
    print("Order:", [j[2] for j in sorted_jobs])
    print("Try: B(deadline=1), D(deadline=1) - conflict!")
    print("This doesn't even tell us which to pick")
    
    # Right: Sort by profit, schedule if possible
    print("\n--- CORRECT: Sort by PROFIT, greedy schedule ---")
    sorted_jobs = sorted(jobs, key=lambda x: x[0], reverse=True)
    schedule = [None] * 3  # slots: 0, 1, 2
    total_profit = 0
    
    for profit, deadline, name in sorted_jobs:
        # Try to schedule in latest available slot before deadline
        for slot in range(min(deadline, len(schedule)) - 1, -1, -1):
            if schedule[slot] is None:
                schedule[slot] = (name, profit)
                total_profit += profit
                print(f"Schedule {name} (profit={profit}) at time {slot + 1}")
                break
    
    print(f"\nFinal schedule: {schedule}")
    print(f"Total profit: {total_profit}")
    
    print("\n" + "=" * 60)
    print("LESSON:")
    print("  - Sort criterion matters!")
    print("  - Test multiple strategies")
    print("  - Verify with examples")
    print("=" * 60)

demonstrate_pitfall_2()
```

### Pitfall 3: Missing Edge Cases

```python
def demonstrate_pitfall_3():
    """
    Mistake: Not handling edge cases properly.
    """
    
    print("\n" + "=" * 60)
    print("PITFALL #3: Missing Edge Cases")
    print("=" * 60)
    
    print("""
    COMMON EDGE CASES FOR GREEDY PROBLEMS:
    
    1. EMPTY INPUT
       - Empty array, zero elements
       - Handle before main algorithm
    
    2. SINGLE ELEMENT
       - Often base case
       - May need special handling
    
    3. ALL SAME VALUES
       - Ties in greedy criterion
       - Need tie-breaking rule
    
    4. EXTREME VALUES
       - Very large or very small
       - Check for overflow
    
    5. ALL DECREASING/INCREASING
       - Sorted input (best/worst case)
       - Test algorithm efficiency
    
    6. NEGATIVE VALUES
       - If applicable to problem
       - May break assumptions
    """)
    
    # Example: Interval scheduling edge cases
    print("\n" + "=" * 60)
    print("EXAMPLE: Interval Scheduling Edge Cases")
    print("=" * 60)
    
    def max_intervals_robust(intervals):
        """Robust interval scheduling with edge case handling."""
        
        # Edge case 1: Empty input
        if not intervals:
            print("Edge case: Empty input → return 0")
            return 0
        
        # Edge case 2: Single interval
        if len(intervals) == 1:
            print("Edge case: Single interval → return 1")
            return 1
        
        # Sort by end time
        intervals.sort(key=lambda x: x[1])
        
        count = 1
        last_end = intervals[0][1]
        
        for i in range(1, len(intervals)):
            # Edge case 3: Exact match (touching intervals)
            # Are [1,2] and [2,3] overlapping?
            # Depends on problem: usually NO (can start when previous ends)
            if intervals[i][0] >= last_end:  # Note: >= not >
                count += 1
                last_end = intervals[i][1]
        
        return count
    
    # Test edge cases
    test_cases = [
        ([], "Empty"),
        ([[1,2]], "Single interval"),
        ([[1,2], [2,3], [3,4]], "Touching intervals"),
        ([[1,10], [1,10], [1,10]], "Identical intervals"),
        ([[1,2], [1,2], [1,3]], "Overlapping starts"),
    ]
    
    for intervals, description in test_cases:
        result = max_intervals_robust(intervals)
        print(f"\n{description}: {intervals} → {result}")

demonstrate_pitfall_3()
```

### Pitfall 4: Forgetting Tie-Breaking

```python
def demonstrate_pitfall_4():
    """
    Mistake: Not handling ties in greedy criterion.
    """
    
    print("\n" + "=" * 60)
    print("PITFALL #4: Forgetting Tie-Breaking Rules")
    print("=" * 60)
    
    problem = """
    PROBLEM: Queue Reconstruction by Height
    People: [[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]
    
    Each person: [height, k] where k = number of people ≥ height in front
    
    PRIMARY SORT: By height (descending)
    After primary sort: [[7,0], [7,1], ...other heights...]
    
    BUT WAIT! Two people with height 7!
    [7,0] vs [7,1] - which comes first?
    
    WITHOUT TIE-BREAKING:
    - Random order between [7,0] and [7,1]
    - May give wrong answer!
    
    WITH TIE-BREAKING (secondary sort by k, ascending):
    - [7,0] comes before [7,1] ✓
    - Person with k=0 should be inserted first
    - Then person with k=1
    
    ============================================================
    """
    
    print(problem)
    
    def reconstruct_queue_wrong(people):
        """Without proper tie-breaking."""
        people.sort(key=lambda x: x[0], reverse=True)  # Only sort by height
        return people
    
    def reconstruct_queue_correct(people):
        """With proper tie-breaking."""
        people.sort(key=lambda x: (-x[0], x[1]))  # Sort by height desc, then k asc
        return people
    
    people = [[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]
    
    print("\n--- Without Tie-Breaking ---")
    result1 = reconstruct_queue_wrong(people.copy())
    print(f"Result: {result1}")
    print("Issue: Order of [7,0] and [7,1] is undefined!")
    
    print("\n--- With Tie-Breaking ---")
    result2 = reconstruct_queue_correct(people.copy())
    print(f"Result: {result2}")
    print("Correct: [7,0] before [7,1] ✓")
    
    print("\n" + "=" * 60)
    print("LESSON: Always define tie-breaking rules!")
    print("=" * 60)

demonstrate_pitfall_4()
```

---

## Summary: Problem Recognition Checklist

```python
def greedy_recognition_checklist():
    """
    Complete checklist for recognizing and solving greedy problems.
    """
    
    checklist = """
    ============================================================
    GREEDY PROBLEM RECOGNITION CHECKLIST
    ============================================================
    
    PHASE 1: RECOGNITION (30 seconds - 1 minute)
    ============================================================
    □ Does problem ask for max/min of something?
    □ Is it about selection, scheduling, or arrangement?
    □ Are there intervals, activities, or time-based elements?
    □ Do keywords suggest greedy? (maximum, minimum, earliest, etc.)
    □ Can choices be made locally without looking ahead much?
    
    RED FLAGS (Not Greedy):
    □ "Count number of ways" → DP
    □ "All possible combinations" → Backtracking
    □ "Longest common subsequence" → DP
    □ Complex dependencies between choices → DP
    
    PHASE 2: STRATEGY FORMULATION (1-2 minutes)
    ============================================================
    □ State greedy criterion clearly
    □ What are we sorting by (if anything)?
    □ What's the greedy choice at each step?
    □ How do we know when to stop?
    
    PHASE 3: VALIDATION (1-2 minutes)
    ============================================================
    □ Test with 2-3 small examples
    □ Try to find counterexample
    □ Can you explain why greedy works?
    □ Consider edge cases:
      □ Empty input
      □ Single element
      □ All same values
      □ Already sorted
    
    PHASE 4: PROOF STRATEGY (if asked)
    ============================================================
    □ Exchange argument (best for selection problems)
    □ Greedy stays ahead (best for accumulation problems)
    □ Contradiction (when structure is complex)
    
    PHASE 5: IMPLEMENTATION (5-10 minutes)
    ============================================================
    □ Handle edge cases first
    □ Sort if needed (clarify comparator)
    □ Implement greedy loop
    □ Track necessary state
    □ Return result
    
    PHASE 6: VERIFICATION (2-3 minutes)
    ============================================================
    □ Walk through example
    □ Check edge cases
    □ Verify time complexity
    □ Verify space complexity
    
    ============================================================
    """
    
    print(checklist)

greedy_recognition_checklist()
```

This completes Chapter 6! The key takeaway: **Recognition comes from pattern matching + testing + proof thinking**. With practice, you'll recognize greedy problems in seconds!