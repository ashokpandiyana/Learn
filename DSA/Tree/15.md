# Chapter 15: Essential Tree Patterns - In Depth Explanation

## Overview
Tree problems may seem diverse, but they follow predictable patterns. Mastering these patterns allows you to recognize problem types instantly and apply the right approach.

---

## 15.1 Pattern: Recursive DFS

### Concept
The recursive DFS pattern is the **foundation of most tree problems**. It follows a simple philosophy: solve for subtrees, then combine their results at the current node.

### The Template
```python
def dfs(node):
    # Base case: handle null nodes
    if not node:
        return base_case_value
    
    # Recursive case: process subtrees
    left_result = dfs(node.left)
    right_result = dfs(node.right)
    
    # Combine results with current node
    return combine(left_result, right_result, node.val)
```

### When to Use
- Any problem asking about tree properties (height, diameter, balance)
- Path problems from root to leaves
- Subtree validation problems
- Value aggregation problems

### Example 1: Maximum Depth of Binary Tree
```python
def maxDepth(root):
    """
    Find the height of the tree.
    Bottom-up approach: gather info from leaves to root.
    """
    if not root:
        return 0
    
    left_height = maxDepth(root.left)
    right_height = maxDepth(root.right)
    
    # Current depth = max of subtree depths + 1
    return max(left_height, right_height) + 1
```

**Complexity**: O(n) time, O(h) space where h is height

### Example 2: Symmetric Tree
```python
def isSymmetric(root):
    """
    Check if tree is mirror of itself.
    Compare left and right subtrees.
    """
    def isMirror(left, right):
        # Both null - symmetric
        if not left and not right:
            return True
        
        # One null - not symmetric
        if not left or not right:
            return False
        
        # Values must match AND subtrees must mirror
        return (left.val == right.val and
                isMirror(left.left, right.right) and
                isMirror(left.right, right.left))
    
    if not root:
        return True
    return isMirror(root.left, root.right)
```

### Example 3: Validate Binary Search Tree
```python
def isValidBST(root):
    """
    Validate BST using min/max bounds.
    Each node must be within valid range.
    """
    def validate(node, min_val, max_val):
        if not node:
            return True
        
        # Current value must be in range
        if node.val <= min_val or node.val >= max_val:
            return False
        
        # Left subtree: all values < node.val
        # Right subtree: all values > node.val
        return (validate(node.left, min_val, node.val) and
                validate(node.right, node.val, max_val))
    
    return validate(root, float('-inf'), float('inf'))
```

**Key Insight**: Pass constraints down the tree (top-down approach)

---

## 15.2 Pattern: Level Order BFS

### Concept
BFS processes nodes **level by level**, using a queue. This pattern is essential when level information matters or when you need the shortest path.

### The Template
```python
from collections import deque

def bfs(root):
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)  # Nodes at current level
        level_nodes = []
        
        # Process all nodes at this level
        for _ in range(level_size):
            node = queue.popleft()
            level_nodes.append(node.val)
            
            # Add children for next level
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(level_nodes)
    
    return result
```

### When to Use
- Level-wise processing required
- Finding shortest path
- Right/left side view
- Zigzag traversal
- Average of levels

### Example 1: Binary Tree Right Side View
```python
def rightSideView(root):
    """
    Return values visible from right side.
    Take the rightmost node at each level.
    """
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        
        for i in range(level_size):
            node = queue.popleft()
            
            # Last node in level is rightmost
            if i == level_size - 1:
                result.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
    
    return result
```

### Example 2: Zigzag Level Order
```python
def zigzagLevelOrder(root):
    """
    Level order but alternate direction each level.
    Use a flag to track left-to-right or right-to-left.
    """
    if not root:
        return []
    
    result = []
    queue = deque([root])
    left_to_right = True
    
    while queue:
        level_size = len(queue)
        level_nodes = deque()
        
        for _ in range(level_size):
            node = queue.popleft()
            
            # Add to appropriate end based on direction
            if left_to_right:
                level_nodes.append(node.val)
            else:
                level_nodes.appendleft(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(list(level_nodes))
        left_to_right = not left_to_right
    
    return result
```

**Complexity**: O(n) time, O(w) space where w is maximum width

---

## 15.3 Pattern: Tree DP (Dynamic Programming on Trees)

### Concept
Tree DP solves problems where the **answer at a node depends on answers from its subtrees**. This is a postorder approach - process children before parent.

### Key Characteristics
- Compute states at each node
- Combine child states to get parent state
- Often involves making optimal choices

### Example 1: House Robber III
```python
def rob(root):
    """
    Rob houses in binary tree. Can't rob adjacent nodes.
    Return max money that can be robbed.
    """
    def dfs(node):
        if not node:
            # (rob this node, don't rob this node)
            return (0, 0)
        
        left = dfs(node.left)
        right = dfs(node.right)
        
        # If we rob current, can't rob children
        rob_current = node.val + left[1] + right[1]
        
        # If we don't rob current, take max from children
        not_rob_current = max(left) + max(right)
        
        return (rob_current, not_rob_current)
    
    return max(dfs(root))
```

**State Definition**: At each node, track two states - robbing vs not robbing

### Example 2: Binary Tree Maximum Path Sum
```python
def maxPathSum(root):
    """
    Find maximum path sum where path can be any node-to-node.
    Path must go through at least one node.
    """
    max_sum = float('-inf')
    
    def maxGain(node):
        nonlocal max_sum
        
        if not node:
            return 0
        
        # Max gain from left and right (ignore negative gains)
        left_gain = max(maxGain(node.left), 0)
        right_gain = max(maxGain(node.right), 0)
        
        # Path through current node
        current_path_sum = node.val + left_gain + right_gain
        
        # Update global max
        max_sum = max(max_sum, current_path_sum)
        
        # Return max gain if we continue path through this node
        return node.val + max(left_gain, right_gain)
    
    maxGain(root)
    return max_sum
```

**Key Insight**: At each node, consider:
1. Path through both children (update global max)
2. Path through one child (return for parent to use)

### Example 3: Diameter of Binary Tree
```python
def diameterOfBinaryTree(root):
    """
    Longest path between any two nodes.
    May or may not pass through root.
    """
    diameter = 0
    
    def height(node):
        nonlocal diameter
        
        if not node:
            return 0
        
        left_height = height(node.left)
        right_height = height(node.right)
        
        # Path through current node
        current_diameter = left_height + right_height
        diameter = max(diameter, current_diameter)
        
        # Return height for parent
        return 1 + max(left_height, right_height)
    
    height(root)
    return diameter
```

---

## 15.4 Pattern: Iterative with Stack

### Concept
Convert recursive solutions to iterative using an **explicit stack**. This avoids stack overflow and gives you more control.

### When to Use
- Deep trees (risk of stack overflow with recursion)
- Need to track parent information
- Complex state management

### Preorder Iterative
```python
def preorderTraversal(root):
    """
    Preorder: Root -> Left -> Right
    Use stack to simulate recursion.
    """
    if not root:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        result.append(node.val)
        
        # Push right first (so left is processed first)
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    
    return result
```

### Inorder Iterative
```python
def inorderTraversal(root):
    """
    Inorder: Left -> Root -> Right
    Go left as far as possible, then process and go right.
    """
    result = []
    stack = []
    current = root
    
    while current or stack:
        # Go to leftmost node
        while current:
            stack.append(current)
            current = current.left
        
        # Process node
        current = stack.pop()
        result.append(current.val)
        
        # Go right
        current = current.right
    
    return result
```

### Postorder Iterative (Two Stack Method)
```python
def postorderTraversal(root):
    """
    Postorder: Left -> Right -> Root
    Use two stacks for easier implementation.
    """
    if not root:
        return []
    
    stack1 = [root]
    stack2 = []
    
    # Fill stack2 with reverse postorder
    while stack1:
        node = stack1.pop()
        stack2.append(node)
        
        # Note: left before right (opposite of preorder)
        if node.left:
            stack1.append(node.left)
        if node.right:
            stack1.append(node.right)
    
    # Pop stack2 for correct postorder
    result = []
    while stack2:
        result.append(stack2.pop().val)
    
    return result
```

---

## 15.5 Pattern: Parent Pointers / BFS from Node

### Concept
When you need to **traverse from any node** (not just root), treat the tree as an undirected graph using parent pointers or building a parent map.

### Building Parent Map
```python
def buildParentMap(root):
    """
    Create mapping from child to parent.
    Enables traversal from any node.
    """
    parent = {root: None}
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        
        if node.left:
            parent[node.left] = node
            queue.append(node.left)
        
        if node.right:
            parent[node.right] = node
            queue.append(node.right)
    
    return parent
```

### Example: All Nodes Distance K
```python
def distanceK(root, target, k):
    """
    Find all nodes at distance K from target node.
    """
    # Build parent map
    parent = {}
    
    def buildMap(node, par=None):
        if not node:
            return
        parent[node] = par
        buildMap(node.left, node)
        buildMap(node.right, node)
    
    buildMap(root)
    
    # BFS from target
    visited = set()
    queue = deque([(target, 0)])
    visited.add(target)
    result = []
    
    while queue:
        node, dist = queue.popleft()
        
        if dist == k:
            result.append(node.val)
            continue
        
        # Explore all neighbors (left, right, parent)
        for neighbor in [node.left, node.right, parent[node]]:
            if neighbor and neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, dist + 1))
    
    return result
```

---

## 15.6 Pattern: Serialize/Deserialize

### Concept
Convert tree to string and back. Essential for tree transmission and storage.

### Preorder with Null Markers
```python
class Codec:
    def serialize(self, root):
        """
        Encode tree to string using preorder.
        Use '#' for null nodes.
        """
        def preorder(node):
            if not node:
                return '#'
            return f"{node.val},{preorder(node.left)},{preorder(node.right)}"
        
        return preorder(root)
    
    def deserialize(self, data):
        """
        Decode string to tree.
        """
        def build():
            val = next(values)
            if val == '#':
                return None
            
            node = TreeNode(int(val))
            node.left = build()
            node.right = build()
            return node
        
        values = iter(data.split(','))
        return build()
```

### Level Order Serialization
```python
class Codec:
    def serialize(self, root):
        """
        Serialize using BFS (level order).
        """
        if not root:
            return ""
        
        result = []
        queue = deque([root])
        
        while queue:
            node = queue.popleft()
            
            if node:
                result.append(str(node.val))
                queue.append(node.left)
                queue.append(node.right)
            else:
                result.append('#')
        
        return ','.join(result)
    
    def deserialize(self, data):
        """
        Deserialize from level order string.
        """
        if not data:
            return None
        
        values = data.split(',')
        root = TreeNode(int(values[0]))
        queue = deque([root])
        i = 1
        
        while queue:
            node = queue.popleft()
            
            # Process left child
            if values[i] != '#':
                node.left = TreeNode(int(values[i]))
                queue.append(node.left)
            i += 1
            
            # Process right child
            if values[i] != '#':
                node.right = TreeNode(int(values[i]))
                queue.append(node.right)
            i += 1
        
        return root
```

---

## Pattern Recognition Quick Guide

| Problem Type | Pattern to Use |
|--------------|----------------|
| Tree property (height, balance) | Recursive DFS |
| Level-wise processing | BFS with Queue |
| Path with constraints | Tree DP or DFS with state |
| Deep tree, avoid overflow | Iterative with Stack |
| Distance from any node | Parent pointers + BFS |
| Save/restore tree | Serialize/Deserialize |
| Subtree validation | DFS with bounds |
| View from side | BFS, track last node |

---

## Practice Problems by Pattern

### Recursive DFS
1. Maximum Depth of Binary Tree
2. Minimum Depth of Binary Tree
3. Same Tree
4. Invert Binary Tree
5. Symmetric Tree

### BFS
1. Binary Tree Level Order Traversal
2. Binary Tree Right Side View
3. Zigzag Level Order Traversal
4. Average of Levels
5. Populating Next Right Pointers

### Tree DP
1. House Robber III
2. Binary Tree Maximum Path Sum
3. Diameter of Binary Tree
4. Longest Univalue Path
5. Maximum Sum BST in Binary Tree

Master these patterns and you'll solve 90% of tree problems!