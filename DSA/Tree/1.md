# Chapter 1: Introduction to Trees - In-Depth Guide

## 1.1 What is a Tree?

A **tree** is a hierarchical data structure that consists of nodes connected by edges. Unlike linear data structures (arrays, linked lists), trees are non-linear and represent hierarchical relationships.

### Key Characteristics:
- **Hierarchical**: Elements are arranged in levels
- **Connected**: All nodes are connected via edges
- **Acyclic**: No cycles exist (you can't return to a node by following edges)
- **One Root**: Exactly one entry point (root node)

### Visual Representation:
```
        1           ← Root (Level 0)
       / \
      2   3         ← Level 1
     / \   \
    4   5   6       ← Level 2 (Leaves)
```

### Real-World Examples:
- **File System**: Directories and files
- **Organization Chart**: CEO → Managers → Employees
- **HTML DOM**: Document Object Model
- **Decision Trees**: AI/ML algorithms
- **Family Tree**: Genealogical relationships

---

## 1.2 Tree Terminology - Complete Breakdown

### 1. Root Node
The **topmost node** with no parent. Every tree has exactly one root.

```python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.children = []

# Creating a root
root = TreeNode(1)  # This is our root
```

### 2. Parent Node
A node that has one or more child nodes below it.

```
        1         ← Parent of 2 and 3
       / \
      2   3       ← 2 is parent of 4 and 5
     / \
    4   5
```

### 3. Child Node
A node directly connected below another node.

```python
# Node 2 and 3 are children of node 1
root = TreeNode(1)
child1 = TreeNode(2)
child2 = TreeNode(3)
root.children = [child1, child2]
```

### 4. Leaf Node (External Node)
A node with **no children**. Terminal nodes of the tree.

```
        1
       / \
      2   3
     / \   \
    4   5   6     ← 4, 5, 6 are leaf nodes
```

### 5. Internal Node
A node that has **at least one child** (not a leaf).

```
        1         ← Internal nodes: 1, 2, 3
       / \
      2   3       ← (they have children)
     / \   \
    4   5   6
```

### 6. Siblings
Nodes that share the **same parent**.

```
        1
       / \
      2   3       ← 2 and 3 are siblings
     / \
    4   5         ← 4 and 5 are siblings
```

### 7. Ancestor
Any node on the **path from root to current node**.

```
        1         ← Ancestors of 5: 1, 2
       / \
      2   3
     / \
    4   5         ← Current node
```

### 8. Descendant
Any node in the **subtree** of the current node.

```
        1         ← Current node
       / \
      2   3       ← Descendants of 1: 2, 3, 4, 5, 6
     / \   \
    4   5   6
```

### 9. Depth of a Node
**Distance from root** to the node (measured in edges).

```
        1         ← Depth = 0
       / \
      2   3       ← Depth = 1
     / \   \
    4   5   6     ← Depth = 2
```

```python
def find_depth(root, target, depth=0):
    """Find depth of a target node"""
    if root is None:
        return -1
    if root.val == target:
        return depth
    
    # Search in children
    for child in root.children:
        result = find_depth(child, target, depth + 1)
        if result != -1:
            return result
    return -1

# Example usage:
# depth_of_5 = find_depth(root, 5)  # Returns 2
```

### 10. Height of a Node
**Longest path from node to any leaf** (measured in edges).

```
        1         ← Height = 2 (longest path to leaf: 1→2→4)
       / \
      2   3       ← Height of 2 = 1, Height of 3 = 1
     / \   \
    4   5   6     ← Height of leaves = 0
```

```python
def find_height(node):
    """Calculate height of a node"""
    if node is None:
        return -1  # Empty tree convention
    
    if not node.children:  # Leaf node
        return 0
    
    # Height is 1 + maximum height of children
    max_child_height = max(find_height(child) for child in node.children)
    return 1 + max_child_height

# Tree height = height of root
```

**Important Distinction:**
- **Depth**: Measured from root (going down)
- **Height**: Measured to leaves (going up)

### 11. Level
All nodes at the **same depth** form a level.

```
Level 0:    1
           / \
Level 1:  2   3
         / \   \
Level 2: 4  5   6
```

### 12. Subtree
A tree formed by a node and all its descendants.

```
        1
       / \
      2   3       ← Subtree rooted at 2:
     / \   \          2
    4   5   6         / \
                     4   5
```

### 13. Degree of a Node
**Number of children** a node has.

```
        1         ← Degree = 2
       / \
      2   3       ← Degree of 2 = 2, Degree of 3 = 1
     / \   \
    4   5   6     ← Degree of all leaves = 0
```

---

## 1.3 Tree Properties - Mathematical Insights

### Property 1: Relationship Between Nodes and Edges
**For any tree with N nodes, there are exactly N-1 edges.**

**Proof:**
- Start with 1 node (root): 0 edges
- Each additional node requires exactly 1 edge to connect it to the tree
- Therefore: N nodes → N-1 edges

```python
def count_edges(root):
    """Count edges in a tree"""
    if root is None:
        return 0
    
    edges = 0
    for child in root.children:
        edges += 1  # Edge to this child
        edges += count_edges(child)  # Edges in subtree
    
    return edges

# For N nodes: count_edges(root) == N - 1
```

### Property 2: Unique Path
**There exists exactly one path between any two nodes in a tree.**

This is because:
- Trees are connected (you can reach any node from any other node)
- Trees are acyclic (no loops)
- If there were two paths, they would form a cycle

```python
def find_path(root, target, path=[]):
    """Find path from root to target node"""
    if root is None:
        return None
    
    # Add current node to path
    path = path + [root.val]
    
    if root.val == target:
        return path
    
    # Search in children
    for child in root.children:
        result = find_path(child, target, path)
        if result:
            return result
    
    return None

# Example: find_path(root, 5) might return [1, 2, 5]
```

### Property 3: Minimum Edges for Connectivity
A tree with N nodes is the **minimal connected graph** - removing any edge disconnects it, adding any edge creates a cycle.

---

## 1.4 Types of Trees - Overview

### 1. Binary Tree
Each node has **at most 2 children**.

```
        1
       / \
      2   3
     /
    4
```

### 2. Binary Search Tree (BST)
Binary tree with ordering property:
- Left subtree values < Node value
- Right subtree values > Node value

```
        8
       / \
      3   10
     / \    \
    1   6    14
```

### 3. Balanced Trees (AVL, Red-Black)
Trees that maintain **height balance** for O(log n) operations.

### 4. N-ary Tree (General Tree)
Each node can have **any number of children**.

```
        1
      / | \
     2  3  4
    /|  |
   5 6  7
```

### 5. Trie (Prefix Tree)
Specialized tree for **string operations**.

```
        root
       / | \
      a  b  c
     /   |   \
    n    a    a
    |    |    |
    t    t    t
```

### 6. Segment Tree
For **range query operations** (sum, min, max).

### 7. Fenwick Tree (Binary Indexed Tree)
For **efficient prefix sum calculations**.

### 8. Heap
**Complete binary tree** with heap property (min-heap or max-heap).

### 9. B-Tree / B+ Tree
Multi-way trees used in **databases and file systems**.

---

## Key Takeaways

### When to Use Trees?
- **Hierarchical data**: File systems, organization structures
- **Fast search**: BST for O(log n) search
- **Dynamic data**: Where frequent insertions/deletions needed
- **Range queries**: Segment trees for efficient range operations
- **Prefix matching**: Tries for autocomplete, spell check

### Tree vs Other Data Structures

| Feature | Array | Linked List | Tree | Hash Table |
|---------|-------|-------------|------|------------|
| Search | O(n) or O(log n) | O(n) | O(log n) avg | O(1) avg |
| Insert | O(n) | O(1) | O(log n) avg | O(1) avg |
| Delete | O(n) | O(1)* | O(log n) avg | O(1) avg |
| Order | Sorted possible | Unsorted | Sorted in BST | Unsorted |
| Memory | Contiguous | Scattered | Scattered | Scattered |

*Assuming you have the reference to the node

---

## Practice Problems for Chapter 1

1. Given a tree, count the number of leaf nodes
2. Find the depth of the deepest node
3. Calculate the height of the tree
4. Count nodes at a given level
5. Print all ancestors of a given node
6. Find the lowest common ancestor of two nodes
7. Check if two nodes are siblings
8. Count the total number of nodes in the tree

These foundational concepts are crucial for understanding more advanced tree operations in the following chapters!