# Chapter 6: Tree Construction Problems - In-Depth Guide

## Overview: The Construction Problem

**Core Question**: Given traversal sequences, can we uniquely reconstruct the original tree?

The answer depends on **which traversals we have**!

---

## 6.1 From Traversals - What Works and What Doesn't

### The Rules:

| Given Traversals | Can Construct? | Why? |
|-----------------|----------------|------|
| **Inorder + Preorder** | ✅ YES | Preorder gives root, Inorder splits tree |
| **Inorder + Postorder** | ✅ YES | Postorder gives root, Inorder splits tree |
| **Preorder + Postorder** | ❌ NO* | Cannot determine left vs right splits |
| **Inorder only** | ❌ NO | Multiple trees can have same inorder |
| **Preorder only** | ❌ NO | Multiple trees can have same preorder |
| **Postorder only** | ❌ NO | Multiple trees can have same postorder |

\* Exception: Works for **full binary trees** (every node has 0 or 2 children)

### Why Inorder is Essential:

**Inorder traversal tells us how to SPLIT the tree!**

```
Example: Inorder = [9, 3, 15, 20, 7]
If root = 3:
         3
        / \
   [9] /   \ [15, 20, 7]
  LEFT      RIGHT

Inorder naturally divides into left and right subtrees!
```

### Visual Example - Why Preorder + Postorder Fails:

```
These two DIFFERENT trees have:
Same Preorder: [1, 2]
Same Postorder: [2, 1]

Tree 1:          Tree 2:
   1                1
  /                  \
 2                    2

Without Inorder, we can't tell which is correct!
```

---

## 6.2 Construct Binary Tree from Inorder + Preorder

### Key Insights:

1. **Preorder**: First element is always the root
2. **Inorder**: Root divides array into left and right subtrees
3. **Recursive pattern**: Apply same logic to subtrees

### Step-by-Step Example:

```
Given:
Preorder: [3, 9, 20, 15, 7]
Inorder:  [9, 3, 15, 20, 7]

Step 1: First element of preorder is root
Root = 3

Step 2: Find 3 in inorder
Inorder: [9, | 3 | , 15, 20, 7]
         LEFT  ROOT  RIGHT

Step 3: Left subtree has inorder [9]
        Right subtree has inorder [15, 20, 7]

Step 4: In preorder, after root:
        Next 1 element for left: [9]
        Remaining elements for right: [20, 15, 7]

Recursively build:
         3
        / \
       9   20
          /  \
         15   7
```

### Complete Implementation:

```python
def build_tree_inorder_preorder(preorder, inorder):
    """
    Construct binary tree from inorder and preorder traversal
    
    Time Complexity: O(n)
    Space Complexity: O(n) for hashmap + O(h) recursion
    
    Args:
        preorder: List[int] - preorder traversal
        inorder: List[int] - inorder traversal
    
    Returns:
        TreeNode - root of constructed tree
    """
    # Build hashmap for O(1) lookup of root index in inorder
    inorder_map = {val: idx for idx, val in enumerate(inorder)}
    
    def build(pre_start, pre_end, in_start, in_end):
        """
        Build tree from subarray ranges
        
        pre_start, pre_end: preorder array bounds
        in_start, in_end: inorder array bounds
        """
        # Base case: empty subarray
        if pre_start > pre_end or in_start > in_end:
            return None
        
        # Root is first element in preorder range
        root_val = preorder[pre_start]
        root = TreeNode(root_val)
        
        # Find root position in inorder
        root_idx_in_inorder = inorder_map[root_val]
        
        # Calculate size of left subtree
        left_size = root_idx_in_inorder - in_start
        
        # Recursively build left subtree
        # Preorder: skip root (pre_start+1), take next left_size elements
        # Inorder: from in_start to root-1
        root.left = build(
            pre_start + 1,
            pre_start + left_size,
            in_start,
            root_idx_in_inorder - 1
        )
        
        # Recursively build right subtree
        # Preorder: skip root and left subtree
        # Inorder: from root+1 to in_end
        root.right = build(
            pre_start + left_size + 1,
            pre_end,
            root_idx_in_inorder + 1,
            in_end
        )
        
        return root
    
    return build(0, len(preorder) - 1, 0, len(inorder) - 1)


# Alternative implementation using array slicing (less efficient)
def build_tree_simple(preorder, inorder):
    """
    Simpler but less efficient version using array slicing
    Time: O(n²) due to slicing
    Space: O(n²) due to creating subarrays
    """
    if not preorder or not inorder:
        return None
    
    # Root is first in preorder
    root_val = preorder[0]
    root = TreeNode(root_val)
    
    # Find root in inorder
    mid = inorder.index(root_val)
    
    # Recursively build subtrees
    root.left = build_tree_simple(
        preorder[1:mid+1],      # Left elements in preorder
        inorder[:mid]           # Left elements in inorder
    )
    root.right = build_tree_simple(
        preorder[mid+1:],       # Right elements in preorder
        inorder[mid+1:]         # Right elements in inorder
    )
    
    return root
```

### Detailed Trace Example:

```
Preorder: [3, 9, 20, 15, 7]
Inorder:  [9, 3, 15, 20, 7]

Call 1: build(0, 4, 0, 4)
  root = 3 (preorder[0])
  mid in inorder = 1
  left_size = 1 - 0 = 1
  
  Build left: build(1, 1, 0, 0)
    root = 9 (preorder[1])
    mid = 0, left_size = 0
    left = None, right = None
    return node(9)
  
  Build right: build(2, 4, 2, 4)
    root = 20 (preorder[2])
    mid = 3, left_size = 3 - 2 = 1
    
    Build left: build(3, 3, 2, 2)
      root = 15
      return node(15)
    
    Build right: build(4, 4, 4, 4)
      root = 7
      return node(7)
    
    return node(20) with children 15, 7
  
  return node(3) with children 9, node(20)

Final Tree:
     3
    / \
   9   20
      /  \
     15   7
```

---

## 6.3 Construct Binary Tree from Inorder + Postorder

### Key Insights:

1. **Postorder**: Last element is always the root
2. **Inorder**: Root divides array into left and right subtrees
3. **Critical**: Build right subtree BEFORE left (postorder is reversed preorder)

### Implementation:

```python
def build_tree_inorder_postorder(inorder, postorder):
    """
    Construct binary tree from inorder and postorder traversal
    
    Time Complexity: O(n)
    Space Complexity: O(n)
    
    Key difference from preorder version:
    - Root is LAST element in postorder
    - Build RIGHT subtree before LEFT
    """
    inorder_map = {val: idx for idx, val in enumerate(inorder)}
    
    def build(in_start, in_end, post_start, post_end):
        if in_start > in_end or post_start > post_end:
            return None
        
        # Root is LAST element in postorder range
        root_val = postorder[post_end]
        root = TreeNode(root_val)
        
        # Find root in inorder
        root_idx = inorder_map[root_val]
        
        # Calculate left subtree size
        left_size = root_idx - in_start
        
        # Build left subtree
        root.left = build(
            in_start,
            root_idx - 1,
            post_start,
            post_start + left_size - 1
        )
        
        # Build right subtree
        root.right = build(
            root_idx + 1,
            in_end,
            post_start + left_size,
            post_end - 1  # Exclude root (last element)
        )
        
        return root
    
    return build(0, len(inorder) - 1, 0, len(postorder) - 1)
```

### Example Trace:

```
Inorder:   [9, 3, 15, 20, 7]
Postorder: [9, 15, 7, 20, 3]

Step 1: Root = 3 (last in postorder)
        Find 3 in inorder → index 1
        Left: [9], Right: [15, 20, 7]

Step 2: Process right subtree [15, 20, 7]
        Root = 20 (last in postorder subarray [15, 7, 20])
        Left: [15], Right: [7]

Step 3: Complete tree:
     3
    / \
   9   20
      /  \
     15   7
```

---

## 6.4 Construct BST from Preorder (Special Case!)

**Key Insight**: For BST, we don't need inorder! The BST property gives us the split.

### Why BST is Special:

```
Preorder: [8, 5, 1, 7, 10, 12]

At root 8:
- Elements < 8: [5, 1, 7] → left subtree
- Elements > 8: [10, 12] → right subtree

BST property naturally divides the array!
```

### Implementation Using Bounds:

```python
def bst_from_preorder(preorder):
    """
    Construct BST from preorder traversal only
    
    Time Complexity: O(n)
    Space Complexity: O(h) recursion stack
    
    Strategy: Use valid range [min, max] for each subtree
    """
    def build(min_val, max_val):
        # Use nonlocal to maintain position across recursive calls
        nonlocal idx
        
        # Base case: all elements processed or out of range
        if idx >= len(preorder):
            return None
        
        val = preorder[idx]
        
        # Current value must be within valid range
        if val < min_val or val > max_val:
            return None
        
        # Valid node, create it and advance index
        idx += 1
        node = TreeNode(val)
        
        # Build left subtree: values must be < current
        node.left = build(min_val, val)
        
        # Build right subtree: values must be > current
        node.right = build(val, max_val)
        
        return node
    
    idx = 0
    return build(float('-inf'), float('inf'))


# Alternative: Using stack (iterative)
def bst_from_preorder_iterative(preorder):
    """
    Iterative construction using stack
    Time: O(n), Space: O(h)
    """
    if not preorder:
        return None
    
    root = TreeNode(preorder[0])
    stack = [root]
    
    for i in range(1, len(preorder)):
        val = preorder[i]
        node = TreeNode(val)
        
        if val < stack[-1].val:
            # Left child of current top
            stack[-1].left = node
        else:
            # Right child of some ancestor
            # Pop until we find the parent
            parent = None
            while stack and stack[-1].val < val:
                parent = stack.pop()
            parent.right = node
        
        stack.append(node)
    
    return root
```

### Trace Example with Bounds:

```
Preorder: [8, 5, 1, 7, 10, 12]

build(8, -∞, +∞):
  val=8, valid
  idx=1
  left = build(5, -∞, 8):
    val=5, valid
    idx=2
    left = build(1, -∞, 5):
      val=1, valid
      idx=3
      left = build(-∞, 1): val=7, invalid, return None
      right = build(1, 5): val=7, invalid, return None
      return node(1)
    right = build(5, 8):
      val=7, valid
      idx=4
      return node(7)
    return node(5)
  right = build(8, +∞):
    val=10, valid
    idx=5
    left = build(8, 10): val=12, invalid, return None
    right = build(10, +∞):
      val=12, valid
      return node(12)
    return node(10)
  return node(8)

Result:
      8
     / \
    5   10
   / \    \
  1   7   12
```

---

## 6.5 Serialize and Deserialize Binary Tree

**Problem**: Convert tree to string and back. Must work for ANY binary tree.

### Approach 1: Preorder with Null Markers

```python
class Codec:
    """
    Serialize/Deserialize using preorder traversal
    Time: O(n) for both operations
    Space: O(n)
    """
    
    def serialize(self, root):
        """
        Encodes a tree to a single string.
        Format: "1,2,None,None,3,4,None,None,5,None,None"
        """
        def preorder(node):
            if node is None:
                result.append("None")
                return
            
            result.append(str(node.val))
            preorder(node.left)
            preorder(node.right)
        
        result = []
        preorder(root)
        return ",".join(result)
    
    def deserialize(self, data):
        """
        Decodes your encoded data to tree.
        """
        def build():
            val = next(values)
            
            if val == "None":
                return None
            
            node = TreeNode(int(val))
            node.left = build()   # Build left subtree
            node.right = build()  # Build right subtree
            return node
        
        values = iter(data.split(","))
        return build()


# Example usage:
# Tree:     1
#          / \
#         2   3
#            / \
#           4   5
#
# Serialized: "1,2,None,None,3,4,None,None,5,None,None"
```

### Approach 2: Level Order (BFS) with Null Markers

```python
class CodecBFS:
    """
    Serialize/Deserialize using level order traversal
    Often more intuitive for humans to read
    """
    
    def serialize(self, root):
        """
        BFS serialization
        Format: "1,2,3,None,None,4,5,None,None,None,None"
        """
        if root is None:
            return ""
        
        result = []
        queue = [root]
        
        while queue:
            node = queue.pop(0)
            
            if node is None:
                result.append("None")
            else:
                result.append(str(node.val))
                queue.append(node.left)
                queue.append(node.right)
        
        return ",".join(result)
    
    def deserialize(self, data):
        """
        BFS deserialization
        """
        if not data:
            return None
        
        values = data.split(",")
        root = TreeNode(int(values[0]))
        queue = [root]
        i = 1
        
        while queue and i < len(values):
            node = queue.pop(0)
            
            # Process left child
            if values[i] != "None":
                node.left = TreeNode(int(values[i]))
                queue.append(node.left)
            i += 1
            
            # Process right child
            if i < len(values) and values[i] != "None":
                node.right = TreeNode(int(values[i]))
                queue.append(node.right)
            i += 1
        
        return root
```

### Serialize/Deserialize BST (Optimized)

For BST, we can save space by not storing null markers!

```python
class CodecBST:
    """
    Optimized for BST - no null markers needed!
    Uses preorder + BST property
    """
    
    def serialize(self, root):
        """Just preorder traversal, no nulls"""
        def preorder(node):
            if node:
                result.append(str(node.val))
                preorder(node.left)
                preorder(node.right)
        
        result = []
        preorder(root)
        return ",".join(result)
    
    def deserialize(self, data):
        """
        Reconstruct BST from preorder
        Use the bounds method
        """
        if not data:
            return None
        
        def build(min_val, max_val):
            nonlocal idx
            
            if idx >= len(values):
                return None
            
            val = int(values[idx])
            
            if val < min_val or val > max_val:
                return None
            
            idx += 1
            node = TreeNode(val)
            node.left = build(min_val, val)
            node.right = build(val, max_val)
            return node
        
        values = data.split(",")
        idx = 0
        return build(float('-inf'), float('inf'))
```

---

## 6.6 Advanced Construction Problems

### Problem 1: Construct from Inorder and Level Order

```python
def build_from_inorder_levelorder(inorder, levelorder):
    """
    Construct tree from inorder and level order traversals
    
    Strategy:
    1. First element in levelorder is root
    2. Find root in inorder to split tree
    3. Recursively process each level
    
    Time: O(n²)
    """
    if not inorder or not levelorder:
        return None
    
    root_val = levelorder[0]
    root = TreeNode(root_val)
    
    # Find split point in inorder
    mid = inorder.index(root_val)
    
    # Elements in left subtree (from inorder)
    left_inorder = set(inorder[:mid])
    
    # Filter levelorder for left and right subtrees
    left_level = [x for x in levelorder if x in left_inorder]
    right_level = [x for x in levelorder if x not in left_inorder and x != root_val]
    
    root.left = build_from_inorder_levelorder(inorder[:mid], left_level)
    root.right = build_from_inorder_levelorder(inorder[mid+1:], right_level)
    
    return root
```

### Problem 2: Construct Full Binary Tree from Preorder and Postorder

```python
def construct_from_pre_post(preorder, postorder):
    """
    Construct full binary tree (every node has 0 or 2 children)
    from preorder and postorder
    
    Only works for FULL binary trees!
    
    Time: O(n²) simple version, O(n) with optimization
    """
    if not preorder:
        return None
    
    root = TreeNode(preorder[0])
    
    if len(preorder) == 1:
        return root
    
    # Second element in preorder is left subtree root
    left_root = preorder[1]
    
    # Find left subtree root in postorder
    # Everything before it (and itself) is left subtree
    idx = postorder.index(left_root)
    
    # Build subtrees
    root.left = construct_from_pre_post(
        preorder[1:idx+2],
        postorder[:idx+1]
    )
    root.right = construct_from_pre_post(
        preorder[idx+2:],
        postorder[idx+1:-1]
    )
    
    return root
```

---

## Construction Problem Patterns Summary

### Pattern Recognition:

| Given | First Ask | Then Ask | Build Strategy |
|-------|-----------|----------|----------------|
| Inorder + Preorder | Where's the root? | Preorder[0] | Split inorder at root |
| Inorder + Postorder | Where's the root? | Postorder[-1] | Split inorder at root |
| Preorder (BST) | What's valid range? | Use BST property | Use bounds |
| Serialized string | What format? | Preorder/Level | Recreate traversal |

### Key Complexity Factors:

1. **HashMap lookup**: O(n) → O(1) per lookup
2. **Array slicing**: O(n) → Creates new arrays (slower)
3. **Index passing**: Best practice - no array copies
4. **BST optimization**: Can skip inorder entirely

---

## Common Pitfalls

### ❌ Mistake 1: Not handling duplicates
```python
# What if tree has duplicate values?
# HashMap approach fails!
# Need to handle carefully or assume unique values
```

### ❌ Mistake 2: Incorrect range calculations
```python
# In preorder + inorder:
left_size = root_idx - in_start  # ✅ Correct
left_size = root_idx              # ❌ Wrong!
```

### ❌ Mistake 3: Forgetting base cases
```python
if not preorder or not inorder:  # ✅ Always check!
    return None
```

### ❌ Mistake 4: Using wrong traversal order
```python
# For postorder, build RIGHT before LEFT!
root.right = build(...)  # Do this first
root.left = build(...)   # Then this
```

---

## Practice Problems

- ✅ Construct Binary Tree from Preorder and Inorder
- ✅ Construct Binary Tree from Inorder and Postorder
- ✅ Construct Binary Search Tree from Preorder Traversal
- ✅ Serialize and Deserialize Binary Tree
- ✅ Serialize and Deserialize BST
- ✅ Verify Preorder Serialization of Binary Tree
- ✅ Construct Full Binary Tree from Preorder and Postorder
- ✅ Find Duplicate Subtrees
- ✅ Create Binary Tree from Descriptions

---

## Final Tips

1. **Always create value→index map** for O(1) lookups
2. **Pass indices instead of slicing arrays** for better performance
3. **BST is special** - don't need inorder!
4. **Inorder is key** - it's the only traversal that splits tree naturally
5. **Practice both recursive and iterative** - interviews may ask for either
6. **Remember null markers** - essential for serialization

Master these construction patterns and you'll be ready for any tree building problem!
