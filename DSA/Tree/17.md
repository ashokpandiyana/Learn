# Chapter 17: Hard Interview Problems - In Depth Analysis

## Overview
This chapter covers the most challenging tree problems asked in top tech company interviews. Each problem includes detailed analysis, multiple solution approaches, and optimization strategies.

---

## 17.1 Traversal & Views

### Problem 1: Binary Tree Right Side View
**Difficulty**: Medium | **Companies**: Facebook, Amazon, Microsoft

**Problem**: Return the values visible when viewing the tree from the right side.

```
    1         <---
   / \
  2   3       <---
   \   \
    5   4     <---
```

**Solution Approaches**:

**Approach 1: BFS Level Order**
```python
def rightSideView(root):
    """
    Process level by level, take last node.
    Time: O(n), Space: O(w) where w is width
    """
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        
        for i in range(level_size):
            node = queue.popleft()
            
            # Last node in level
            if i == level_size - 1:
                result.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
    
    return result
```

**Approach 2: DFS with Depth Tracking**
```python
def rightSideView(root):
    """
    DFS: visit right subtree first, track depth.
    First node at each depth is rightmost.
    Time: O(n), Space: O(h)
    """
    result = []
    
    def dfs(node, depth):
        if not node:
            return
        
        # First time seeing this depth
        if depth == len(result):
            result.append(node.val)
        
        # Visit right first!
        dfs(node.right, depth + 1)
        dfs(node.left, depth + 1)
    
    dfs(root, 0)
    return result
```

**Key Insight**: DFS with right-first traversal is more space efficient for skewed trees.

---

### Problem 2: Vertical Order Traversal
**Difficulty**: Hard | **Companies**: Google, Facebook

**Problem**: Return nodes grouped by vertical columns, sorted by row and value.

```
    3
   / \
  9  20
    /  \
   15   7

Output: [[9], [3,15], [20], [7]]
Column: -1    0      1     2
```

**Solution**:
```python
def verticalTraversal(root):
    """
    Track (column, row, value) for each node.
    Sort by column, then row, then value.
    """
    if not root:
        return []
    
    # Store (column, row, value)
    nodes = []
    
    def dfs(node, row, col):
        if not node:
            return
        
        nodes.append((col, row, node.val))
        dfs(node.left, row + 1, col - 1)
        dfs(node.right, row + 1, col + 1)
    
    dfs(root, 0, 0)
    
    # Sort by column, row, value
    nodes.sort()
    
    # Group by column
    result = []
    current_col = float('-inf')
    
    for col, row, val in nodes:
        if col != current_col:
            result.append([])
            current_col = col
        result[-1].append(val)
    
    return result
```

**Complexity**: O(n log n) for sorting

**Follow-up**: Can we do better? Use BFS + TreeMap for O(n log k) where k is number of columns.

---

### Problem 3: Boundary Traversal
**Difficulty**: Medium-Hard | **Companies**: Amazon, Adobe

**Problem**: Return boundary in anti-clockwise direction (left boundary + leaves + right boundary in reverse).

```python
def boundaryOfBinaryTree(root):
    """
    Three separate traversals:
    1. Left boundary (excluding leaves)
    2. All leaves
    3. Right boundary in reverse (excluding leaves)
    """
    if not root:
        return []
    
    def is_leaf(node):
        return node and not node.left and not node.right
    
    def left_boundary(node, result):
        """Get left boundary excluding leaves."""
        if not node or is_leaf(node):
            return
        
        result.append(node.val)
        
        if node.left:
            left_boundary(node.left, result)
        else:
            left_boundary(node.right, result)
    
    def leaves(node, result):
        """Get all leaves left to right."""
        if not node:
            return
        
        if is_leaf(node):
            result.append(node.val)
            return
        
        leaves(node.left, result)
        leaves(node.right, result)
    
    def right_boundary(node, result):
        """Get right boundary excluding leaves, in reverse."""
        if not node or is_leaf(node):
            return
        
        if node.right:
            right_boundary(node.right, result)
        else:
            right_boundary(node.left, result)
        
        result.append(node.val)  # Add after recursion for reverse
    
    # Special case: single node
    if is_leaf(root):
        return [root.val]
    
    result = [root.val]
    left_boundary(root.left, result)
    leaves(root, result)
    right_boundary(root.right, result)
    
    return result
```

**Key Insight**: Three separate traversals prevent duplicates and maintain correct order.

---

## 17.2 Construction Problems

### Problem 4: Construct from Inorder + Preorder
**Difficulty**: Medium | **Companies**: Microsoft, Amazon, Bloomberg

**Concept**: 
- Preorder: Root → Left → Right
- Inorder: Left → Root → Right

**Solution**:
```python
def buildTree(preorder, inorder):
    """
    Use preorder to identify root.
    Use inorder to split into left/right subtrees.
    HashMap for O(1) root lookup in inorder.
    """
    inorder_map = {val: idx for idx, val in enumerate(inorder)}
    
    def build(pre_start, pre_end, in_start, in_end):
        if pre_start > pre_end:
            return None
        
        # Root is first in preorder range
        root_val = preorder[pre_start]
        root = TreeNode(root_val)
        
        # Find root in inorder
        root_idx = inorder_map[root_val]
        
        # Size of left subtree
        left_size = root_idx - in_start
        
        # Build subtrees
        root.left = build(
            pre_start + 1,
            pre_start + left_size,
            in_start,
            root_idx - 1
        )
        
        root.right = build(
            pre_start + left_size + 1,
            pre_end,
            root_idx + 1,
            in_end
        )
        
        return root
    
    return build(0, len(preorder) - 1, 0, len(inorder) - 1)
```

**Time**: O(n), **Space**: O(n)

**Common Mistakes**:
- Forgetting to use HashMap → O(n²) complexity
- Wrong index calculations for subtree ranges
- Not handling empty arrays

---

### Problem 5: Serialize and Deserialize Binary Tree
**Difficulty**: Hard | **Companies**: LinkedIn, Facebook, Google

**Solution 1: Preorder with Null Markers**
```python
class Codec:
    def serialize(self, root):
        """
        Preorder: root, left, right
        Use '#' for null nodes
        """
        result = []
        
        def preorder(node):
            if not node:
                result.append('#')
                return
            
            result.append(str(node.val))
            preorder(node.left)
            preorder(node.right)
        
        preorder(root)
        return ','.join(result)
    
    def deserialize(self, data):
        """
        Reconstruct using preorder logic.
        Use iterator for stateful reading.
        """
        def build():
            val = next(values)
            
            if val == '#':
                return None
            
            node = TreeNode(int(val))
            node.left = build()   # Recurse left
            node.right = build()  # Recurse right
            
            return node
        
        values = iter(data.split(','))
        return build()
```

**Solution 2: Level Order with Null Markers**
```python
class Codec:
    def serialize(self, root):
        """BFS with queue."""
        if not root:
            return ""
        
        result = []
        queue = deque([root])
        
        while queue:
            node = queue.popleft()
            
            if node:
                result.append(str(node.val))
                queue.append(node.left)
                queue.append(node.right)
            else:
                result.append('#')
        
        return ','.join(result)
    
    def deserialize(self, data):
        """Reconstruct level by level."""
        if not data:
            return None
        
        values = data.split(',')
        root = TreeNode(int(values[0]))
        queue = deque([root])
        i = 1
        
        while queue:
            node = queue.popleft()
            
            # Left child
            if values[i] != '#':
                node.left = TreeNode(int(values[i]))
                queue.append(node.left)
            i += 1
            
            # Right child
            if values[i] != '#':
                node.right = TreeNode(int(values[i]))
                queue.append(node.right)
            i += 1
        
        return root
```

---

## 17.3 BST Advanced Problems

### Problem 6: Recover BST (Two Nodes Swapped)
**Difficulty**: Medium-Hard | **Companies**: Microsoft, Amazon

**Problem**: Two nodes of a BST are swapped by mistake. Recover the tree without changing structure.

```python
def recoverTree(root):
    """
    Inorder should be sorted, but two elements are wrong.
    Find the two violations and swap.
    """
    first = second = prev = None
    
    def inorder(node):
        nonlocal first, second, prev
        
        if not node:
            return
        
        inorder(node.left)
        
        # Check violation: prev > current
        if prev and prev.val > node.val:
            if not first:
                first = prev    # First violation
            second = node       # Update second (handles adjacent case)
        
        prev = node
        inorder(node.right)
    
    inorder(root)
    
    # Swap values
    first.val, second.val = second.val, first.val
```

**Cases**:
1. Adjacent nodes swapped: One violation
2. Non-adjacent nodes: Two violations

**Complexity**: O(n) time, O(h) space

**Morris Traversal Version** (O(1) space):
```python
def recoverTree(root):
    """
    Morris inorder traversal for O(1) space.
    """
    first = second = prev = None
    current = root
    
    while current:
        if not current.left:
            # Process current
            if prev and prev.val > current.val:
                if not first:
                    first = prev
                second = current
            prev = current
            current = current.right
        else:
            # Find predecessor
            predecessor = current.left
            while predecessor.right and predecessor.right != current:
                predecessor = predecessor.right
            
            if not predecessor.right:
                # Create thread
                predecessor.right = current
                current = current.left
            else:
                # Remove thread and process
                predecessor.right = None
                if prev and prev.val > current.val:
                    if not first:
                        first = prev
                    second = current
                prev = current
                current = current.right
    
    # Swap
    first.val, second.val = second.val, first.val
```

---

## 17.4 Path Problems

### Problem 7: Binary Tree Maximum Path Sum
**Difficulty**: Hard | **Companies**: Google, Facebook, Amazon

**Problem**: Find maximum path sum where path can start and end at any node.

```python
def maxPathSum(root):
    """
    At each node, decide:
    1. Include both children (update global max)
    2. Include one child (return for parent)
    3. Start fresh from current node
    """
    max_sum = float('-inf')
    
    def maxGain(node):
        nonlocal max_sum
        
        if not node:
            return 0
        
        # Ignore negative gains
        left_gain = max(maxGain(node.left), 0)
        right_gain = max(maxGain(node.right), 0)
        
        # Path through current node (both children)
        path_sum = node.val + left_gain + right_gain
        
        # Update global max
        max_sum = max(max_sum, path_sum)
        
        # Return max path including current node
        # (can only include one child when extending path)
        return node.val + max(left_gain, right_gain)
    
    maxGain(root)
    return max_sum
```

**Key Points**:
- Handle negative values by taking max with 0
- Update global max when considering both children
- Return single path for parent to use

---

### Problem 8: Path Sum III
**Difficulty**: Medium | **Companies**: Facebook, Amazon

**Problem**: Count paths that sum to target (path can start/end anywhere but must go downward).

```python
def pathSum(root, targetSum):
    """
    Use prefix sum + HashMap.
    Track how many paths from root sum to each value.
    """
    def dfs(node, current_sum):
        if not node:
            return 0
        
        current_sum += node.val
        
        # Count paths ending here
        count = prefix_sums.get(current_sum - targetSum, 0)
        
        # Add current sum to map
        prefix_sums[current_sum] = prefix_sums.get(current_sum, 0) + 1
        
        # Recurse
        count += dfs(node.left, current_sum)
        count += dfs(node.right, current_sum)
        
        # Backtrack
        prefix_sums[current_sum] -= 1
        
        return count
    
    prefix_sums = {0: 1}  # Empty path
    return dfs(root, 0)
```

**Complexity**: O(n) time, O(n) space

---

## 17.5 LCA & Distance Problems

### Problem 9: All Nodes Distance K
**Difficulty**: Medium | **Companies**: Facebook, Amazon

**Problem**: Find all nodes at distance K from a target node.

```python
def distanceK(root, target, k):
    """
    Build parent map, then BFS from target.
    Treat tree as undirected graph.
    """
    # Build parent pointers
    parent = {}
    
    def build_parent(node, par=None):
        if not node:
            return
        parent[node] = par
        build_parent(node.left, node)
        build_parent(node.right, node)
    
    build_parent(root)
    
    # BFS from target
    visited = {target}
    queue = deque([(target, 0)])
    result = []
    
    while queue:
        node, dist = queue.popleft()
        
        if dist == k:
            result.append(node.val)
            continue
        
        # Explore all neighbors
        for neighbor in [node.left, node.right, parent[node]]:
            if neighbor and neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, dist + 1))
    
    return result
```

---

## 17.6 Advanced Hard Problems

### Problem 10: Count Complete Tree Nodes
**Difficulty**: Medium | **Companies**: Google, Microsoft

**Problem**: Count nodes in O(log²n) time (better than O(n) traversal).

```python
def countNodes(root):
    """
    Complete tree property: all levels filled except possibly last.
    If left height == right height → perfect tree → 2^h - 1 nodes
    Otherwise → recurse
    """
    if not root:
        return 0
    
    def get_height(node, go_left):
        """Get height going only left or only right."""
        height = 0
        while node:
            height += 1
            node = node.left if go_left else node.right
        return height
    
    left_height = get_height(root, True)
    right_height = get_height(root, False)
    
    if left_height == right_height:
        # Perfect tree
        return (1 << left_height) - 1  # 2^h - 1
    
    # Recursively count
    return 1 + countNodes(root.left) + countNodes(root.right)
```

**Complexity**: O(log²n)
- Height calculation: O(log n)
- Recursive calls: O(log n) levels
- Total: O(log n × log n)

---

### Problem 11: Binary Tree Cameras
**Difficulty**: Hard | **Companies**: Google

**Problem**: Place minimum cameras to monitor all nodes. Camera at node monitors itself, parent, and children.

```python
def minCameraCover(root):
    """
    States:
    0: Not monitored (needs monitoring)
    1: Has camera
    2: Monitored (but no camera)
    
    Greedy: prefer placing cameras on parents of leaves.
    """
    cameras = 0
    
    def dfs(node):
        nonlocal cameras
        
        if not node:
            return 2  # Null is considered monitored
        
        left = dfs(node.left)
        right = dfs(node.right)
        
        # If any child not monitored, place camera here
        if left == 0 or right == 0:
            cameras += 1
            return 1
        
        # If any child has camera, this is monitored
        if left == 1 or right == 1:
            return 2
        
        # Both children monitored, this needs monitoring
        return 0
    
    # Handle root not being monitored
    if dfs(root) == 0:
        cameras += 1
    
    return cameras
```

**Key Insight**: Process leaves first (postorder), place cameras on their parents for optimal coverage.

---

## Problem Solving Strategy

### Pattern Recognition Checklist

| If Problem Involves | Think About |
|---------------------|-------------|
| "All paths from X to Y" | DFS with backtracking |
| "Shortest path" | BFS |
| "Maximum/minimum path" | Tree DP |
| "Sorted order" | BST inorder |
| "View from side" | BFS + track position |
| "Distance K from node" | Parent map + BFS |
| "Construction" | HashMap for indices |
| "Two nodes swapped" | Inorder validation |
| "Complete tree property" | Use structure for optimization |

### Complexity Optimization Hierarchy

1. **O(n²) → O(n)**: Use HashMap for lookups
2. **O(n) → O(log n)**: Use BST properties or binary search on answer
3. **O(h) space → O(1)**: Use Morris traversal
4. **Multiple queries**: Preprocess with binary lifting

### Interview Approach

1. **Clarify**: Binary tree or BST? Constraints?
2. **Example**: Draw small tree, trace algorithm
3. **Brute Force**: Start with O(n²) if needed
4. **Optimize**: Apply patterns and techniques
5. **Code**: Clean, with edge cases
6. **Test**: Null, single node, skewed tree

Practice these problems repeatedly until patterns become second nature!