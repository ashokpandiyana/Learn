# Chapter 8: Tree Transformations - In-Depth Guide

## Introduction

Tree transformations involve modifying the structure or converting a tree from one form to another while maintaining certain properties. These are common in interviews and real-world applications.

---

## 8.1 Invert/Mirror Binary Tree

### Concept
Inverting (or mirroring) a binary tree means swapping the left and right children of every node recursively.

### Visualization

```
Original Tree:        Inverted Tree:
       4                    4
      / \                  / \
     2   7                7   2
    / \ / \              / \ / \
   1  3 6  9            9  6 3  1
```

### Implementation

#### Recursive Approach

```python
def invertTree(root):
    """
    Time: O(n) - visit each node once
    Space: O(h) - recursion stack
    """
    # Base case
    if not root:
        return None
    
    # Swap children
    root.left, root.right = root.right, root.left
    
    # Recursively invert subtrees
    invertTree(root.left)
    invertTree(root.right)
    
    return root
```

#### Iterative Approach (BFS)

```python
from collections import deque

def invertTree(root):
    """
    Time: O(n)
    Space: O(w) where w is max width of tree
    """
    if not root:
        return None
    
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        
        # Swap children
        node.left, node.right = node.right, node.left
        
        # Add children to queue
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    
    return root
```

### When to Use
- Image processing (horizontal flip)
- Creating mirror views
- Testing tree symmetry

---

## 8.2 Flatten Binary Tree to Linked List

### Concept
Convert a binary tree into a "linked list" in preorder traversal order, where:
- The right pointer acts as the "next" pointer
- The left pointer is always null

### Visualization

```
Original Tree:       Flattened:
     1                  1
    / \                  \
   2   5                  2
  / \   \                  \
 3   4   6                  3
                             \
                              4
                               \
                                5
                                 \
                                  6
```

### Approaches

#### Approach 1: Using Stack (Preorder Simulation)

```python
def flatten(root):
    """
    Time: O(n)
    Space: O(h)
    
    Simulate preorder traversal with stack
    """
    if not root:
        return
    
    stack = [root]
    prev = None
    
    while stack:
        node = stack.pop()
        
        # Connect previous node to current
        if prev:
            prev.left = None
            prev.right = node
        
        # Push right first (stack is LIFO)
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
        
        prev = node
```

#### Approach 2: Reverse Postorder (Optimal - O(1) Space)

```python
def flatten(root):
    """
    Time: O(n)
    Space: O(h) for recursion
    
    Process nodes in reverse postorder: Right → Left → Root
    This ensures we process children before parent
    """
    def flatten_helper(node):
        nonlocal prev
        
        if not node:
            return
        
        # Process right subtree first
        flatten_helper(node.right)
        # Then left subtree
        flatten_helper(node.left)
        
        # Connect current node to previously processed node
        node.right = prev
        node.left = None
        
        # Update prev to current node
        prev = node
    
    prev = None
    flatten_helper(root)

# Example walkthrough:
# Tree:    1
#         / \
#        2   5
#       /     \
#      3       6
#
# Processing order (reverse postorder): 6 → 5 → 3 → 2 → 1
# After 6: prev = 6
# After 5: 5.right = 6, prev = 5
# After 3: 3.right = prev (which will be 2), prev = 3
# After 2: 2.right = 3, prev = 2
# After 1: 1.right = 2
```

#### Approach 3: Morris-like Traversal (True O(1) Space)

```python
def flatten(root):
    """
    Time: O(n)
    Space: O(1) - no recursion!
    
    For each node:
    1. Find the rightmost node in left subtree
    2. Connect it to current node's right child
    3. Move left subtree to right
    4. Move to right child
    """
    curr = root
    
    while curr:
        if curr.left:
            # Find rightmost node in left subtree
            rightmost = curr.left
            while rightmost.right:
                rightmost = rightmost.right
            
            # Connect rightmost to current's right
            rightmost.right = curr.right
            
            # Move left subtree to right
            curr.right = curr.left
            curr.left = None
        
        # Move to next node
        curr = curr.right
```

### Detailed Example of Morris Approach

```
Initial:        1
               / \
              2   5
             / \   \
            3   4   6

Step 1: At node 1, has left child (2)
  - Find rightmost in left subtree: node 4
  - Connect 4.right = 5
  - Move 2 to 1.right
  - Set 1.left = None

Result:         1
                 \
                  2
                 / \
                3   4
                     \
                      5
                       \
                        6

Step 2: At node 2, has left child (3)
  - Find rightmost: node 3
  - Connect 3.right = 4 (current right)
  - Move 3 to 2.right

Result:         1
                 \
                  2
                   \
                    3
                     \
                      4
                       \
                        5
                         \
                          6

Step 3-6: Continue with nodes 3,4,5,6 (no left children)

Final:          1
                 \
                  2
                   \
                    3
                     \
                      4
                       \
                        5
                         \
                          6
```

---

## 8.3 Convert BST to Sorted Doubly Linked List

### Concept
Convert a Binary Search Tree into a sorted circular doubly linked list where:
- Left pointer = previous node
- Right pointer = next node
- List is circular (last node connects to first)

### Visualization

```
BST:         4
            / \
           2   5
          / \
         1   3

DLL: 1 ⇄ 2 ⇄ 3 ⇄ 4 ⇄ 5
     ↑_______________|
```

### Implementation

```python
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def treeToDoublyList(root):
    """
    Time: O(n)
    Space: O(h)
    
    Use inorder traversal and track previous node
    """
    if not root:
        return None
    
    first = None  # First node (smallest)
    last = None   # Last node (largest)
    
    def inorder(node):
        nonlocal first, last
        
        if not node:
            return
        
        # Process left subtree
        inorder(node.left)
        
        # Process current node
        if last:
            # Connect previous node to current
            last.right = node
            node.left = last
        else:
            # This is the first node (leftmost)
            first = node
        
        last = node
        
        # Process right subtree
        inorder(node.right)
    
    inorder(root)
    
    # Make it circular
    first.left = last
    last.right = first
    
    return first
```

### Step-by-Step Example

```
BST:     4
        / \
       2   5
      / \
     1   3

Inorder sequence: 1, 2, 3, 4, 5

Processing:
1. Visit 1: first = 1, last = 1
2. Visit 2: 1 ⇄ 2, last = 2
3. Visit 3: 2 ⇄ 3, last = 3
4. Visit 4: 3 ⇄ 4, last = 4
5. Visit 5: 4 ⇄ 5, last = 5

Make circular: 1.left = 5, 5.right = 1
```

---

## 8.4 Convert Binary Tree to BST

### Concept
Convert a binary tree into a Binary Search Tree while maintaining the same structure (same parent-child relationships).

### Algorithm

```python
def binaryTreeToBST(root):
    """
    Time: O(n log n) - O(n) for inorder + O(n log n) for sort
    Space: O(n)
    
    Steps:
    1. Store inorder traversal
    2. Sort the values
    3. Replace values in same inorder sequence
    """
    # Step 1: Collect all values via inorder
    values = []
    
    def inorder_collect(node):
        if not node:
            return
        inorder_collect(node.left)
        values.append(node.val)
        inorder_collect(node.right)
    
    inorder_collect(root)
    
    # Step 2: Sort values
    values.sort()
    
    # Step 3: Replace values in inorder sequence
    index = [0]  # Use list to modify in nested function
    
    def inorder_replace(node):
        if not node:
            return
        inorder_replace(node.left)
        node.val = values[index[0]]
        index[0] += 1
        inorder_replace(node.right)
    
    inorder_replace(root)
    return root
```

### Example

```
Original Tree:    10
                 /  \
                30   15
               /      \
              20       5

Inorder: [20, 30, 10, 15, 5]
Sorted:  [5, 10, 15, 20, 30]

Replace in inorder:
BST:             15
                /  \
               10   20
              /      \
             5       30
```

---

## 8.5 Merge Two BSTs

### Concept
Given two BSTs, merge them into a single balanced BST containing all elements from both trees.

### Approaches

#### Approach 1: Inorder Traversal + Merge

```python
def mergeTrees(root1, root2):
    """
    Time: O(m + n)
    Space: O(m + n)
    
    Steps:
    1. Get sorted arrays from both BSTs (inorder)
    2. Merge two sorted arrays
    3. Build balanced BST from merged array
    """
    # Step 1: Get inorder arrays
    def inorder(node, arr):
        if not node:
            return
        inorder(node.left, arr)
        arr.append(node.val)
        inorder(node.right, arr)
    
    arr1, arr2 = [], []
    inorder(root1, arr1)
    inorder(root2, arr2)
    
    # Step 2: Merge two sorted arrays
    merged = []
    i, j = 0, 0
    
    while i < len(arr1) and j < len(arr2):
        if arr1[i] <= arr2[j]:
            merged.append(arr1[i])
            i += 1
        else:
            merged.append(arr2[j])
            j += 1
    
    merged.extend(arr1[i:])
    merged.extend(arr2[j:])
    
    # Step 3: Build balanced BST
    def sortedArrayToBST(arr, start, end):
        if start > end:
            return None
        
        mid = (start + end) // 2
        root = TreeNode(arr[mid])
        root.left = sortedArrayToBST(arr, start, mid - 1)
        root.right = sortedArrayToBST(arr, mid + 1, end)
        return root
    
    return sortedArrayToBST(merged, 0, len(merged) - 1)
```

#### Approach 2: In-place Merge (Convert to DLL, Merge, Convert Back)

```python
def mergeTrees(root1, root2):
    """
    Time: O(m + n)
    Space: O(h1 + h2)
    
    More space efficient approach
    """
    # Convert both BSTs to sorted DLLs
    def treeToList(root):
        if not root:
            return None
        
        head = None
        prev = [None]
        
        def inorder(node):
            nonlocal head
            if not node:
                return
            
            inorder(node.left)
            
            if prev[0]:
                prev[0].right = node
                node.left = prev[0]
            else:
                head = node
            
            prev[0] = node
            inorder(node.right)
        
        inorder(root)
        return head
    
    # Merge two sorted linked lists
    def mergeLists(head1, head2):
        if not head1:
            return head2
        if not head2:
            return head1
        
        if head1.val <= head2.val:
            head = head1
            head1 = head1.right
        else:
            head = head2
            head2 = head2.right
        
        curr = head
        
        while head1 and head2:
            if head1.val <= head2.val:
                curr.right = head1
                head1.left = curr
                head1 = head1.right
            else:
                curr.right = head2
                head2.left = curr
                head2 = head2.right
            curr = curr.right
        
        if head1:
            curr.right = head1
            head1.left = curr
        if head2:
            curr.right = head2
            head2.left = curr
        
        return head
    
    # Convert list to balanced BST
    def listToBST(head, n):
        if n <= 0:
            return None
        
        # Build left subtree
        left = listToBST(head, n // 2)
        
        # Current node becomes root
        root = head
        root.left = left
        
        # Move head forward
        head = head.right
        
        # Build right subtree
        root.right = listToBST(head, n - n // 2 - 1)
        
        return root
    
    # Main logic
    list1 = treeToList(root1)
    list2 = treeToList(root2)
    merged_list = mergeLists(list1, list2)
    
    # Count nodes
    count = 0
    curr = merged_list
    while curr:
        count += 1
        curr = curr.right
    
    return listToBST(merged_list, count)
```

---

## Summary Table

| Transformation | Technique | Time | Space |
|----------------|-----------|------|-------|
| Invert Tree | Swap children (DFS/BFS) | O(n) | O(h) |
| Flatten to List | Preorder + Stack or Reverse Postorder | O(n) | O(h) or O(1) |
| BST to DLL | Inorder + Previous pointer | O(n) | O(h) |
| Tree to BST | Inorder + Sort + Replace | O(n log n) | O(n) |
| Merge BSTs | Inorder + Merge + Build | O(m + n) | O(m + n) |

---

## Practice Problems

1. **Invert Binary Tree** (LeetCode 226) - Easy
2. **Flatten Binary Tree to Linked List** (LeetCode 114) - Medium
3. **Convert BST to Greater Tree** (LeetCode 538) - Medium
4. **Increasing Order Search Tree** (LeetCode 897) - Easy
5. **All Nodes Distance K in Binary Tree** (LeetCode 863) - Medium

---

## Key Takeaways

1. **Inversion**: Simple swap of children at each node
2. **Flatten operations**: Often use preorder or reverse postorder
3. **BST to DLL**: Leverage inorder traversal for sorted order
4. **Merging structures**: Convert to intermediate form, merge, convert back
5. **Space optimization**: Consider Morris-like techniques for O(1) space
