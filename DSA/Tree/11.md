# Chapter 11: Trie (Prefix Tree) - Deep Dive

## What is a Trie?

A **Trie** (pronounced "try") is a tree-like data structure that stores a dynamic set of strings. It's also called a **prefix tree** because it's particularly efficient for prefix-based operations.

### Key Characteristics:
- Each node represents a character
- Path from root to node represents a prefix
- Root node is typically empty
- End of word is marked with a flag

## Visual Representation

```
Example: Insert words "cat", "car", "card", "dog"

        (root)
       /      \
      c        d
      |        |
      a        o
     / \       |
    t   r      g*
    |   |
    *   d*
```

The `*` marks end of a word.

## 11.1 Trie Node Structure

```python
class TrieNode:
    def __init__(self):
        # Dictionary to store children (character -> TrieNode)
        self.children = {}
        # Flag to mark end of word
        self.is_end_of_word = False
        # Optional: store the complete word at end node
        self.word = None
```

**Alternative implementation using array (for lowercase letters only):**

```python
class TrieNode:
    def __init__(self):
        # Array of 26 children (for 'a' to 'z')
        self.children = [None] * 26
        self.is_end_of_word = False
    
    def get_index(self, char):
        return ord(char) - ord('a')
```

## 11.2 Basic Trie Operations

### Complete Trie Implementation

```python
class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        """
        Insert a word into the trie
        Time Complexity: O(L) where L = length of word
        Space Complexity: O(L) in worst case
        """
        node = self.root
        
        for char in word:
            # If character doesn't exist, create new node
            if char not in node.children:
                node.children[char] = TrieNode()
            
            # Move to the child node
            node = node.children[char]
        
        # Mark end of word
        node.is_end_of_word = True
        node.word = word  # Optional: store the word
    
    def search(self, word):
        """
        Search for exact word in trie
        Time Complexity: O(L)
        Space Complexity: O(1)
        """
        node = self.root
        
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        
        # Must be marked as end of word
        return node.is_end_of_word
    
    def starts_with(self, prefix):
        """
        Check if any word starts with given prefix
        Time Complexity: O(L)
        Space Complexity: O(1)
        """
        node = self.root
        
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        
        return True
    
    def delete(self, word):
        """
        Delete a word from trie
        Time Complexity: O(L)
        """
        def _delete(node, word, index):
            if index == len(word):
                # Reached end of word
                if not node.is_end_of_word:
                    return False  # Word doesn't exist
                
                node.is_end_of_word = False
                # If node has no children, it can be deleted
                return len(node.children) == 0
            
            char = word[index]
            if char not in node.children:
                return False
            
            child_node = node.children[char]
            should_delete_child = _delete(child_node, word, index + 1)
            
            if should_delete_child:
                del node.children[char]
                # Return True if current node has no children and is not end of word
                return len(node.children) == 0 and not node.is_end_of_word
            
            return False
        
        _delete(self.root, word, 0)
```

## 11.3 Advanced Trie Operations

### Find All Words with Prefix

```python
def find_words_with_prefix(self, prefix):
    """
    Find all words starting with given prefix
    Time Complexity: O(P + N) where P = prefix length, N = number of nodes in subtree
    """
    def dfs(node, current_word, results):
        if node.is_end_of_word:
            results.append(current_word)
        
        for char, child_node in node.children.items():
            dfs(child_node, current_word + char, results)
    
    # Navigate to prefix node
    node = self.root
    for char in prefix:
        if char not in node.children:
            return []
        node = node.children[char]
    
    # DFS from prefix node
    results = []
    dfs(node, prefix, results)
    return results
```

### Count Words with Prefix

```python
def count_words_with_prefix(self, prefix):
    """
    Count how many words start with given prefix
    Time Complexity: O(P + N)
    """
    def count_words(node):
        count = 1 if node.is_end_of_word else 0
        for child in node.children.values():
            count += count_words(child)
        return count
    
    node = self.root
    for char in prefix:
        if char not in node.children:
            return 0
        node = node.children[char]
    
    return count_words(node)
```

## 11.4 Trie Applications

### Application 1: Autocomplete System

```python
class AutocompleteSystem:
    def __init__(self, sentences, times):
        """
        sentences: list of historical sentences
        times: frequency of each sentence
        """
        self.trie = Trie()
        self.freq = {}  # sentence -> frequency
        
        # Build trie with frequencies
        for sentence, time in zip(sentences, times):
            self.trie.insert(sentence)
            self.freq[sentence] = time
        
        self.current_input = ""
    
    def input(self, c):
        if c == '#':
            # User finished typing, save the sentence
            self.freq[self.current_input] = self.freq.get(self.current_input, 0) + 1
            self.trie.insert(self.current_input)
            self.current_input = ""
            return []
        
        self.current_input += c
        # Get all matching sentences
        candidates = self.trie.find_words_with_prefix(self.current_input)
        
        # Sort by frequency (descending) and lexicographically
        candidates.sort(key=lambda x: (-self.freq.get(x, 0), x))
        return candidates[:3]  # Return top 3
```

### Application 2: Word Search II (Leetcode #212)

```python
def find_words(self, board, words):
    """
    Find all words from dictionary that can be formed in the board
    Using Trie + DFS is much faster than checking each word individually
    """
    # Build trie from word list
    trie = Trie()
    for word in words:
        trie.insert(word)
    
    result = set()
    rows, cols = len(board), len(board[0])
    
    def dfs(i, j, node, path):
        if node.is_end_of_word:
            result.add(path)
        
        if i < 0 or i >= rows or j < 0 or j >= cols:
            return
        
        char = board[i][j]
        if char not in node.children or char == '#':
            return
        
        # Mark as visited
        board[i][j] = '#'
        
        # Explore all 4 directions
        for di, dj in [(0,1), (1,0), (0,-1), (-1,0)]:
            dfs(i + di, j + dj, node.children[char], path + char)
        
        # Restore
        board[i][j] = char
    
    # Start DFS from each cell
    for i in range(rows):
        for j in range(cols):
            if board[i][j] in trie.root.children:
                dfs(i, j, trie.root, "")
    
    return list(result)
```

### Application 3: Maximum XOR (Bit Trie)

```python
class BitTrie:
    """
    Trie for binary numbers (used for XOR problems)
    """
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, num):
        """Insert 32-bit number"""
        node = self.root
        for i in range(31, -1, -1):
            bit = (num >> i) & 1
            if bit not in node.children:
                node.children[bit] = TrieNode()
            node = node.children[bit]
    
    def find_max_xor(self, num):
        """Find maximum XOR with any inserted number"""
        node = self.root
        max_xor = 0
        
        for i in range(31, -1, -1):
            bit = (num >> i) & 1
            # Try to go opposite direction for maximum XOR
            toggled_bit = 1 - bit
            
            if toggled_bit in node.children:
                max_xor |= (1 << i)
                node = node.children[toggled_bit]
            else:
                node = node.children[bit]
        
        return max_xor

def find_maximum_xor(nums):
    """Find maximum XOR of any two numbers in array"""
    bit_trie = BitTrie()
    max_xor = 0
    
    for num in nums:
        bit_trie.insert(num)
        max_xor = max(max_xor, bit_trie.find_max_xor(num))
    
    return max_xor
```

## 11.5 Trie Variations

### Compressed Trie (Radix Tree)

In a compressed trie, we merge chains of nodes with single children:

```
Standard Trie:          Compressed Trie:
    r                       r
    |                       |
    o                      "omane"
    |                       
    m                   
    |
    a
    |
    n
    |
    e
```

### Suffix Trie

A suffix trie contains all suffixes of a string. For string "banana":
- Suffixes: "banana", "anana", "nana", "ana", "na", "a"

```python
def build_suffix_trie(text):
    """Build suffix trie for pattern matching"""
    trie = Trie()
    for i in range(len(text)):
        trie.insert(text[i:])
    return trie

def pattern_search(text, pattern):
    """Check if pattern exists in text using suffix trie"""
    suffix_trie = build_suffix_trie(text)
    return suffix_trie.starts_with(pattern)
```

## 11.6 Time and Space Complexity Analysis

| Operation | Time Complexity | Space Complexity |
|-----------|----------------|------------------|
| Insert | O(L) | O(L) worst case |
| Search | O(L) | O(1) |
| Delete | O(L) | O(1) |
| Prefix Search | O(L) | O(1) |
| Find All Words | O(L + N) | O(N) |

Where:
- L = length of word/prefix
- N = total number of nodes in result subtree

**Space Complexity of Trie:**
- Worst case: O(ALPHABET_SIZE × N × L)
- Average case: Much better due to prefix sharing
- N = number of words, L = average length

## Common Trie Problems

1. **Implement Trie (Prefix Tree)** - Leetcode #208
2. **Word Search II** - Leetcode #212
3. **Design Add and Search Words Data Structure** - Leetcode #211
4. **Replace Words** - Leetcode #648
5. **Maximum XOR of Two Numbers** - Leetcode #421
6. **Palindrome Pairs** - Leetcode #336
7. **Stream of Characters** - Leetcode #1032

## Key Takeaways

✅ **When to use Trie:**
- Multiple prefix-based queries
- Autocomplete features
- Dictionary lookups
- Word validation games

✅ **Advantages:**
- Fast prefix lookups: O(L)
- Space-efficient for shared prefixes
- Sorted order (lexicographic)

✅ **Disadvantages:**
- Memory overhead (pointers)
- Not cache-friendly
- Slower than hash table for exact matches

✅ **Interview Tips:**
- Always clarify character set (lowercase? alphanumeric?)
- Consider using HashMap vs Array for children
- Remember the is_end_of_word flag!
- For optimization, can store frequency/priority at nodes
