# Chapter 9: Balanced Trees - In-Depth Guide

## Introduction

Balanced trees are self-balancing binary search trees that maintain their height close to O(log n), ensuring efficient operations. The two most important balanced trees are **AVL Trees** and **Red-Black Trees**.

---

## 9.1 AVL Tree

### 9.1.1 Definition and Properties

An AVL tree is a **self-balancing Binary Search Tree** where the height difference between left and right subtrees (called the **Balance Factor**) cannot be more than 1 for all nodes.

**Balance Factor (BF) = Height(Left Subtree) - Height(Right Subtree)**

For all nodes in an AVL tree: **BF ∈ {-1, 0, 1}**

### Visualization of Balance Factor

```
Balanced (BF = 1):        Balanced (BF = 0):        Balanced (BF = -1):
       10                       10                        10
      /  \                     /  \                      /  \
     5   15                   5   15                    5   15
    /                        /     \                         \
   3                        3       20                       20
                                                              \
BF(10) = 2 - 1 = 1       BF(10) = 2 - 2 = 0            BF(10) = 1 - 2 = -1   20
                                                                               \
                                                                               25

Unbalanced (BF = 2):     Unbalanced (BF = -2):
       10                       10
      /  \                     /  \
     5   15                   5   15
    /                              \
   3                               20
  /                                 \
 1                                  25

BF(10) = 3 - 1 = 2               BF(10) = 1 - 3 = -2
```

### Why AVL Trees?

Regular BST worst case: O(n) operations (skewed tree)
AVL Tree guarantees: **O(log n)** for all operations

---

### 9.1.2 Rotations

When insertion or deletion causes imbalance (|BF| > 1), we perform rotations to restore balance.

#### Four Types of Imbalances and Rotations

| Imbalance Type | Structure | Rotation Needed |
|----------------|-----------|-----------------|
| **Left-Left (LL)** | Left child's left subtree too heavy | **Single Right Rotation** |
| **Right-Right (RR)** | Right child's right subtree too heavy | **Single Left Rotation** |
| **Left-Right (LR)** | Left child's right subtree too heavy | **Left then Right Rotation** |
| **Right-Left (RL)** | Right child's left subtree too heavy | **Right then Left Rotation** |

### Memory Trick
- **Outside imbalance** (LL or RR) → **Single rotation**
- **Inside imbalance** (LR or RL) → **Double rotation**

---

#### 1. Right Rotation (for LL imbalance)

```
Before (LL case):        After Right Rotation:
       z                        y
      / \                      / \
     y   T4    ------>        x   z
    / \                      / \ / \
   x   T3                   T1 T2 T3 T4
  / \
 T1  T2

Code:
```

```python
def rightRotate(z):
    """
    Right rotation on node z
    """
    y = z.left
    T3 = y.right
    
    # Perform rotation
    y.right = z
    z.left = T3
    
    # Update heights
    z.height = 1 + max(getHeight(z.left), getHeight(z.right))
    y.height = 1 + max(getHeight(y.left), getHeight(y.right))
    
    # Return new root
    return y
```

#### 2. Left Rotation (for RR imbalance)

```
Before (RR case):        After Left Rotation:
   z                            y
  / \                          / \
 T1  y          ------>       z   x
    / \                      / \ / \
   T2  x                    T1 T2 T3 T4
      / \
     T3  T4

Code:
```

```python
def leftRotate(z):
    """
    Left rotation on node z
    """
    y = z.right
    T2 = y.left
    
    # Perform rotation
    y.left = z
    z.right = T2
    
    # Update heights
    z.height = 1 + max(getHeight(z.left), getHeight(z.right))
    y.height = 1 + max(getHeight(y.left), getHeight(y.right))
    
    # Return new root
    return y
```

#### 3. Left-Right Rotation (for LR imbalance)

```
Step 1: Left rotate on left child
Step 2: Right rotate on root

Before (LR case):        After Left on y:       After Right on z:
       z                        z                        x
      / \                      / \                      / \
     y   T4    ------>        x   T4    ------>        y   z
    / \                      / \                      / \ / \
   T1  x                    y  T3                    T1 T2 T3 T4
      / \                  / \
     T2  T3               T1  T2
```

```python
def leftRightRotate(z):
    """
    LR rotation: Left rotate on left child, then right rotate on root
    """
    z.left = leftRotate(z.left)  # Left rotation on y
    return rightRotate(z)         # Right rotation on z
```

#### 4. Right-Left Rotation (for RL imbalance)

```
Step 1: Right rotate on right child
Step 2: Left rotate on root

Before (RL case):        After Right on y:      After Left on z:
     z                        z                        x
    / \                      / \                      / \
   T1  y      ------>       T1  x     ------>        z   y
      / \                      / \                  / \ / \
     x  T4                    T2  y                T1 T2 T3 T4
    / \                          / \
   T2  T3                       T3  T4
```

```python
def rightLeftRotate(z):
    """
    RL rotation: Right rotate on right child, then left rotate on root
    """
    z.right = rightRotate(z.right)  # Right rotation on y
    return leftRotate(z)             # Left rotation on z
```

---

### 9.1.3 Complete AVL Tree Implementation

```python
class AVLNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.height = 1  # New node has height 1

class AVLTree:
    def getHeight(self, node):
        if not node:
            return 0
        return node.height
    
    def getBalance(self, node):
        if not node:
            return 0
        return self.getHeight(node.left) - self.getHeight(node.right)
    
    def rightRotate(self, z):
        y = z.left
        T3 = y.right
        
        y.right = z
        z.left = T3
        
        z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right))
        y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right))
        
        return y
    
    def leftRotate(self, z):
        y = z.right
        T2 = y.left
        
        y.left = z
        z.right = T2
        
        z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right))
        y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right))
        
        return y
    
    def insert(self, root, val):
        """
        Time: O(log n)
        Space: O(log n) for recursion
        """
        # Step 1: Perform standard BST insertion
        if not root:
            return AVLNode(val)
        
        if val < root.val:
            root.left = self.insert(root.left, val)
        elif val > root.val:
            root.right = self.insert(root.right, val)
        else:
            # Duplicate values not allowed
            return root
        
        # Step 2: Update height of current node
        root.height = 1 + max(self.getHeight(root.left), 
                              self.getHeight(root.right))
        
        # Step 3: Get balance factor
        balance = self.getBalance(root)
        
        # Step 4: If unbalanced, perform rotations
        
        # Left-Left Case
        if balance > 1 and val < root.left.val:
            return self.rightRotate(root)
        
        # Right-Right Case
        if balance < -1 and val > root.right.val:
            return self.leftRotate(root)
        
        # Left-Right Case
        if balance > 1 and val > root.left.val:
            root.left = self.leftRotate(root.left)
            return self.rightRotate(root)
        
        # Right-Left Case
        if balance < -1 and val < root.right.val:
            root.right = self.rightRotate(root.right)
            return self.leftRotate(root)
        
        return root
    
    def minValueNode(self, node):
        current = node
        while current.left:
            current = current.left
        return current
    
    def delete(self, root, val):
        """
        Time: O(log n)
        Space: O(log n)
        """
        # Step 1: Perform standard BST deletion
        if not root:
            return root
        
        if val < root.val:
            root.left = self.delete(root.left, val)
        elif val > root.val:
            root.right = self.delete(root.right, val)
        else:
            # Node to be deleted found
            if not root.left:
                return root.right
            elif not root.right:
                return root.left
            
            # Node with two children: get inorder successor
            temp = self.minValueNode(root.right)
            root.val = temp.val
            root.right = self.delete(root.right, temp.val)
        
        # If tree had only one node
        if not root:
            return root
        
        # Step 2: Update height
        root.height = 1 + max(self.getHeight(root.left),
                              self.getHeight(root.right))
        
        # Step 3: Get balance factor
        balance = self.getBalance(root)
        
        # Step 4: Balance the tree
        
        # Left-Left Case
        if balance > 1 and self.getBalance(root.left) >= 0:
            return self.rightRotate(root)
        
        # Left-Right Case
        if balance > 1 and self.getBalance(root.left) < 0:
            root.left = self.leftRotate(root.left)
            return self.rightRotate(root)
        
        # Right-Right Case
        if balance < -1 and self.getBalance(root.right) <= 0:
            return self.leftRotate(root)
        
        # Right-Left Case
        if balance < -1 and self.getBalance(root.right) > 0:
            root.right = self.rightRotate(root.right)
            return self.leftRotate(root)
        
        return root
```

### Example: Building AVL Tree

```
Insert sequence: 10, 20, 30

Step 1: Insert 10
    10

Step 2: Insert 20
    10
      \
      20

Step 3: Insert 30
    10
      \
      20    <- BF(10) = -2 (RR case)
        \
        30

After Left Rotation on 10:
      20
     /  \
    10  30
```

---

## 9.2 Red-Black Tree

### 9.2.1 Properties

A Red-Black Tree is a BST with the following properties:

1. **Every node is either RED or BLACK**
2. **Root is always BLACK**
3. **No two adjacent RED nodes** (RED node cannot have RED parent or RED child)
4. **Every path from root to NULL has same number of BLACK nodes** (Black-Height property)
5. **All NULL leaves are BLACK**

### Visualization

```
Valid Red-Black Tree:

        10(B)
       /      \
     5(R)    20(B)
    /  \     /    \
  3(B) 7(B) 15(R) 25(R)

Black-Height from root: 2
Every path has 2 black nodes
```

### Why Red-Black Trees?

- **Less strictly balanced** than AVL trees
- **Faster insertions and deletions** (fewer rotations)
- **Slightly slower searches** than AVL
- Used in: **C++ STL map/set, Java TreeMap/TreeSet**

---

### 9.2.2 Insertion Rules

#### Basic Algorithm

```
1. Insert node as in regular BST
2. Color the new node RED
3. Fix violations if any
```

#### Fixing Violations

When we insert a RED node, we might violate property 3 (no two adjacent RED nodes).

**Cases to consider:**

```
Let:
- z = newly inserted node (RED)
- p = parent of z
- g = grandparent of z
- u = uncle of z (sibling of p)
```

**Case 1: Uncle is RED**
- Recolor: p → BLACK, u → BLACK, g → RED
- Move up to g and check again

**Case 2: Uncle is BLACK (or NULL) and z is "outside"**
- Single rotation + recoloring

**Case 3: Uncle is BLACK (or NULL) and z is "inside"**
- Double rotation + recoloring

### Implementation Sketch

```python
class RBNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.parent = None
        self.color = "RED"  # New nodes are always RED

class RedBlackTree:
    def __init__(self):
        self.NIL = RBNode(None)
        self.NIL.color = "BLACK"
        self.root = self.NIL
    
    def leftRotate(self, x):
        y = x.right
        x.right = y.left
        
        if y.left != self.NIL:
            y.left.parent = x
        
        y.parent = x.parent
        
        if x.parent == None:
            self.root = y
        elif x == x.parent.left:
            x.parent.left = y
        else:
            x.parent.right = y
        
        y.left = x
        x.parent = y
    
    def fixInsert(self, z):
        while z.parent and z.parent.color == "RED":
            if z.parent == z.parent.parent.left:
                u = z.parent.parent.right  # Uncle
                
                if u.color == "RED":
                    # Case 1: Uncle is RED
                    z.parent.color = "BLACK"
                    u.color = "BLACK"
                    z.parent.parent.color = "RED"
                    z = z.parent.parent
                else:
                    if z == z.parent.right:
                        # Case 2: z is right child
                        z = z.parent
                        self.leftRotate(z)
                    
                    # Case 3: z is left child
                    z.parent.color = "BLACK"
                    z.parent.parent.color = "RED"
                    self.rightRotate(z.parent.parent)
            else:
                # Mirror cases for right side
                u = z.parent.parent.left
                
                if u.color == "RED":
                    z.parent.color = "BLACK"
                    u.color = "BLACK"
                    z.parent.parent.color = "RED"
                    z = z.parent.parent
                else:
                    if z == z.parent.left:
                        z = z.parent
                        self.rightRotate(z)
                    
                    z.parent.color = "BLACK"
                    z.parent.parent.color = "RED"
                    self.leftRotate(z.parent.parent)
        
        self.root.color = "BLACK"
    
    def insert(self, val):
        node = RBNode(val)
        node.left = self.NIL
        node.right = self.NIL
        
        # Standard BST insertion
        y = None
        x = self.root
        
        while x != self.NIL:
            y = x
            if node.val < x.val:
                x = x.left
            else:
                x = x.right
        
        node.parent = y
        
        if y == None:
            self.root = node
        elif node.val < y.val:
            y.left = node
        else:
            y.right = node
        
        # Fix Red-Black Tree properties
        self.fixInsert(node)
```

---

## 9.3 AVL vs Red-Black Tree Comparison

| Property | AVL Tree | Red-Black Tree |
|----------|----------|----------------|
| **Balance** | Stricter (BF ≤ 1) | Relaxed (Black-height) |
| **Height** | ~1.44 log(n) | ~2 log(n) |
| **Search** | Faster | Slightly slower |
| **Insert** | Slower (more rotations) | Faster |
| **Delete** | Slower (more rotations) | Faster |
| **Rotations per insert** | ≤ 2 | ≤ 2 |
| **Rotations per delete** | O(log n) | ≤ 3 |
| **Use Case** | **Read-heavy workloads** | **Write-heavy workloads** |
| **Examples** | Windows NT kernel | Linux kernel, C++ STL |

---

## 9.4 Height Comparison

For n nodes:

| Tree Type | Minimum Height | Maximum Height |
|-----------|----------------|----------------|
| Complete Binary Tree | ⌊log₂(n)⌋ | ⌊log₂(n)⌋ |
| AVL Tree | ~log₂(n) | ~1.44 log₂(n) |
| Red-Black Tree | log₂(n) | 2 log₂(n) |
| Regular BST | ⌊log₂(n)⌋ | n - 1 |

---

## 9.5 When to Use Which?

### Use AVL Tree when:
- **Search operations dominate**
- Need faster lookup
- Example: Database indexing with heavy reads

### Use Red-Black Tree when:
- **Insert/Delete operations are frequent**
- Need faster modifications
- Example: System schedulers, memory allocators

### Use Regular BST when:
- Data comes in random order
- No worst-case guarantees needed
- Simplicity is preferred

---

## Practice Problems

1. **Check if Binary Tree is Balanced** (LeetCode 110) - Easy
2. **Convert Sorted Array to BST** (LeetCode 108) - Easy (creates AVL-like structure)
3. Implement AVL Tree from scratch
4. Implement Red-Black Tree from scratch
5. **Balance a BST** (LeetCode 1382) - Medium

---

## Key Takeaways

1. **AVL Trees**: Strictly balanced, best for read-heavy workloads
2. **Red-Black Trees**: Relaxed balance, best for write-heavy workloads
3. **Rotations**: Master LL, RR, LR, RL cases
4. **Height guarantees**: Both guarantee O(log n) operations
5. **Trade-offs**: AVL → faster search, RB → faster insert/delete
6. **Industry usage**: Red-Black trees more common in production systems
