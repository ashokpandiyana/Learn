# Chapter 2: Binary Trees - In-Depth Guide

## 2.1 Definition

A **Binary Tree** is a tree data structure where each node has **at most two children**, referred to as the **left child** and **right child**.

### Visual Representation:
```
        1           ← Root
       / \
      2   3         ← 2 is left child, 3 is right child
     / \   \
    4   5   6
```

### Key Characteristics:
- Maximum 2 children per node
- Children are ordered (left vs right matters)
- Can be empty (null tree)
- Recursive structure (each subtree is also a binary tree)

---

## 2.2 Binary Tree Node Structure

### Python Implementation:
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# Creating a simple binary tree
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

#       1
#      / \
#     2   3
#    / \
#   4   5
```

### Java Implementation:
```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

// Usage
TreeNode root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
```

### C++ Implementation:
```cpp
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Usage
TreeNode* root = new TreeNode(1);
root->left = new TreeNode(2);
root->right = new TreeNode(3);
```

---

## 2.3 Types of Binary Trees

### 2.3.1 Full Binary Tree (Strict Binary Tree)

**Definition:** Every node has either 0 or 2 children. No node has exactly 1 child.

```
       1              Valid Full Binary Tree
      / \
     2   3
    / \
   4   5

       1              NOT a Full Binary Tree
      / \             (Node 2 has only 1 child)
     2   3
    /
   4
```

**Properties:**
- If there are `L` leaf nodes, then total nodes = `2L - 1`
- Number of internal nodes = `L - 1`

**Code to Check:**
```python
def is_full_binary_tree(root):
    """Check if tree is a full binary tree"""
    if root is None:
        return True
    
    # Leaf node
    if root.left is None and root.right is None:
        return True
    
    # Node with both children
    if root.left and root.right:
        return (is_full_binary_tree(root.left) and 
                is_full_binary_tree(root.right))
    
    # Node with only one child
    return False

# Test
#       1
#      / \
#     2   3
#    / \
#   4   5
print(is_full_binary_tree(root))  # True
```

---

### 2.3.2 Complete Binary Tree

**Definition:** All levels are completely filled except possibly the last level, which is filled from left to right.

```
       1              Valid Complete Binary Tree
      / \
     2   3
    / \  /
   4  5 6

       1              NOT Complete
      / \             (Level 2 not filled left to right)
     2   3
    /     \
   4       7
```

**Important:** Heaps are always implemented as complete binary trees!

**Properties:**
- If last level has `L` nodes, they occupy leftmost positions
- Can be efficiently represented using arrays
- Height is always O(log n)

**Array Representation:**
```python
# For node at index i:
# Left child: 2*i + 1
# Right child: 2*i + 2
# Parent: (i-1) // 2

array = [1, 2, 3, 4, 5, 6]  # Represents complete binary tree
#        1
#       / \
#      2   3
#     / \ /
#    4  5 6

def get_left_child(i):
    return 2 * i + 1

def get_right_child(i):
    return 2 * i + 2

def get_parent(i):
    return (i - 1) // 2
```

**Code to Check:**
```python
def count_nodes(root):
    """Helper function to count nodes"""
    if not root:
        return 0
    return 1 + count_nodes(root.left) + count_nodes(root.right)

def is_complete_binary_tree(root):
    """Check if tree is complete using level order traversal"""
    if not root:
        return True
    
    queue = [root]
    flag = False  # Flag to indicate we've seen a non-full node
    
    while queue:
        node = queue.pop(0)
        
        # Check left child
        if node.left:
            if flag:  # We've seen a non-full node before
                return False
            queue.append(node.left)
        else:
            flag = True  # Mark that we've seen a non-full node
        
        # Check right child
        if node.right:
            if flag:
                return False
            queue.append(node.right)
        else:
            flag = True
    
    return True
```

---

### 2.3.3 Perfect Binary Tree

**Definition:** All internal nodes have exactly 2 children AND all leaves are at the same level.

```
       1              Perfect Binary Tree
      / \
     2   3
    / \ / \
   4  5 6  7

       1              NOT Perfect
      / \             (Leaves at different levels)
     2   3
    / \
   4   5
```

**Properties:**
- Most strict type of binary tree
- Number of nodes at level `h` = 2^h
- Total nodes with height `h` = 2^(h+1) - 1
- Number of leaf nodes = 2^h
- Number of internal nodes = 2^h - 1

**Formulas:**
```
If height = h:
  Leaf nodes: 2^h
  Total nodes: 2^(h+1) - 1
  
If total nodes = n:
  Height: log₂(n+1) - 1
  Leaf nodes: (n+1) / 2
```

**Code to Check:**
```python
def depth(node):
    """Calculate depth of leftmost path"""
    d = 0
    while node:
        d += 1
        node = node.left
    return d

def is_perfect(root, d, level=0):
    """Check if tree is perfect"""
    if not root:
        return True
    
    # If leaf node, check if at the expected depth
    if not root.left and not root.right:
        return d == level + 1
    
    # If only one child exists, not perfect
    if not root.left or not root.right:
        return False
    
    # Check both subtrees
    return (is_perfect(root.left, d, level + 1) and
            is_perfect(root.right, d, level + 1))

def is_perfect_binary_tree(root):
    d = depth(root)
    return is_perfect(root, d)
```

---

### 2.3.4 Balanced Binary Tree

**Definition:** For every node, the height difference between left and right subtree is at most 1.

```
       1              Balanced
      / \
     2   3
    / \
   4   5

       1              NOT Balanced
      /               (Height difference at root = 3)
     2
    /
   3
  /
 4
```

**Balance Factor:** `BF = Height(Left Subtree) - Height(Right Subtree)`
- For balanced tree: `-1 ≤ BF ≤ 1` for all nodes

**Code to Check:**
```python
def check_balanced(root):
    """
    Returns tuple: (is_balanced, height)
    """
    if not root:
        return True, 0
    
    # Check left subtree
    left_balanced, left_height = check_balanced(root.left)
    if not left_balanced:
        return False, 0
    
    # Check right subtree
    right_balanced, right_height = check_balanced(root.right)
    if not right_balanced:
        return False, 0
    
    # Check current node
    height_diff = abs(left_height - right_height)
    is_balanced = height_diff <= 1
    current_height = max(left_height, right_height) + 1
    
    return is_balanced, current_height

def is_balanced(root):
    return check_balanced(root)[0]

# Example usage:
#       1
#      / \
#     2   3
#    / \
#   4   5
balanced, height = check_balanced(root)
print(f"Is Balanced: {balanced}, Height: {height}")
```

**Optimized Single Function:**
```python
def is_balanced_optimized(root):
    def height(node):
        if not node:
            return 0
        
        left_h = height(node.left)
        if left_h == -1:  # Left subtree is unbalanced
            return -1
        
        right_h = height(node.right)
        if right_h == -1:  # Right subtree is unbalanced
            return -1
        
        # Check balance at current node
        if abs(left_h - right_h) > 1:
            return -1  # Signal unbalanced
        
        return max(left_h, right_h) + 1
    
    return height(root) != -1
```

---

### 2.3.5 Degenerate (Skewed) Tree

**Definition:** Each parent node has only one child. Essentially a linked list.

```
Left Skewed:        Right Skewed:

    1                   1
   /                     \
  2                       2
 /                         \
3                           3
```

**Properties:**
- Height = n - 1 (where n = number of nodes)
- Worst case for BST operations
- Search, Insert, Delete: O(n)
- Essentially loses advantages of tree structure

**Code to Check:**
```python
def is_skewed(root):
    """Check if tree is skewed (degenerate)"""
    if not root:
        return True
    
    # Check if it's a chain (each node has at most one child)
    current = root
    while current:
        # If node has both children, not skewed
        if current.left and current.right:
            return False
        
        # Move to the only child
        current = current.left if current.left else current.right
    
    return True

# Better: check if height == number of nodes - 1
def is_skewed_v2(root):
    def height(node):
        if not node:
            return 0
        return 1 + max(height(node.left), height(node.right))
    
    def count(node):
        if not node:
            return 0
        return 1 + count(node.left) + count(node.right)
    
    n = count(root)
    h = height(root)
    return h == n
```

---

## 2.4 Binary Tree Properties - Mathematical Analysis

### Property Table

| Property | Formula | Example (n=7) |
|----------|---------|---------------|
| Min height | ⌊log₂(n)⌋ | ⌊log₂(7)⌋ = 2 |
| Max height | n - 1 | 7 - 1 = 6 |
| Max nodes at level L | 2^L | Level 2: 2² = 4 |
| Max nodes with height H | 2^(H+1) - 1 | H=2: 2³-1 = 7 |
| Min nodes with height H | H + 1 | H=2: 2+1 = 3 |

### Detailed Explanation:

#### 1. Minimum Height
```python
import math

def min_height(n):
    """Minimum possible height for n nodes"""
    return math.floor(math.log2(n))

# Example:
# n=7: min_height = 2 (perfect tree)
#      1
#     / \
#    2   3
#   / \ / \
#  4  5 6  7
```

#### 2. Maximum Height
```python
def max_height(n):
    """Maximum possible height for n nodes"""
    return n - 1

# Example:
# n=4: max_height = 3 (skewed tree)
# 1
#  \
#   2
#    \
#     3
#      \
#       4
```

#### 3. Nodes at Each Level
```python
def max_nodes_at_level(level):
    """Maximum nodes at a given level"""
    return 2 ** level

# Level 0 (root): 1 node
# Level 1: 2 nodes
# Level 2: 4 nodes
# Level 3: 8 nodes
```

#### 4. Total Nodes in Perfect Tree
```python
def total_nodes_perfect(height):
    """Total nodes in perfect binary tree"""
    return (2 ** (height + 1)) - 1

# Height 0: 1 node
# Height 1: 3 nodes
# Height 2: 7 nodes
# Height 3: 15 nodes
```

---

## Comprehensive Example: Building and Analyzing a Binary Tree

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BinaryTreeAnalyzer:
    def __init__(self, root):
        self.root = root
    
    def height(self, node=None):
        """Calculate height of tree"""
        if node is None:
            node = self.root
        if not node:
            return -1  # Empty tree convention
        return 1 + max(self.height(node.left), self.height(node.right))
    
    def count_nodes(self, node=None):
        """Count total nodes"""
        if node is None:
            node = self.root
        if not node:
            return 0
        return 1 + self.count_nodes(node.left) + self.count_nodes(node.right)
    
    def count_leaf_nodes(self, node=None):
        """Count leaf nodes"""
        if node is None:
            node = self.root
        if not node:
            return 0
        if not node.left and not node.right:
            return 1
        return self.count_leaf_nodes(node.left) + self.count_leaf_nodes(node.right)
    
    def analyze(self):
        """Complete analysis of the tree"""
        print(f"Tree Analysis:")
        print(f"  Total Nodes: {self.count_nodes()}")
        print(f"  Height: {self.height()}")
        print(f"  Leaf Nodes: {self.count_leaf_nodes()}")
        print(f"  Internal Nodes: {self.count_nodes() - self.count_leaf_nodes()}")
        print(f"  Is Balanced: {is_balanced(self.root)}")
        print(f"  Is Complete: {is_complete_binary_tree(self.root)}")
        print(f"  Is Full: {is_full_binary_tree(self.root)}")

# Example usage:
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
root.right.left = TreeNode(6)

analyzer = BinaryTreeAnalyzer(root)
analyzer.analyze()
```

---

## Practice Problems for Chapter 2

1. Determine if a binary tree is height-balanced
2. Count the number of nodes in a complete binary tree
3. Convert a binary tree to its mirror
4. Find the maximum width of a binary tree
5. Check if a binary tree is symmetric
6. Find the diameter of a binary tree
7. Construct a balanced BST from sorted array
8. Convert sorted array to height-balanced BST

These concepts form the foundation for understanding tree traversals and more advanced tree algorithms!