# Chapter 14: N-ary Trees - Deep Dive

## What is an N-ary Tree?

An **N-ary tree** (also called **k-ary tree** or **multi-way tree**) is a tree where each node can have **at most N children**. Unlike binary trees (max 2 children), N-ary trees allow any number of children.

### Real-World Examples:
- **File systems**: Directories with multiple subdirectories
- **Organization charts**: Manager with multiple direct reports
- **HTML DOM**: Elements with multiple child elements
- **Game trees**: Chess positions with multiple possible moves
- **Decision trees**: Multiple branching options

## 14.1 N-ary Tree Structure

### Node Definition

```python
class Node:
    def __init__(self, val=0, children=None):
        self.val = val
        # List of child nodes
        self.children = children if children is not None else []

# Example usage
root = Node(1)
child1 = Node(2)
child2 = Node(3)
child3 = Node(4)
root.children = [child1, child2, child3]

child1.children = [Node(5), Node(6)]
```

### Visual Representation

```
        1
      / | \
     2  3  4
    / \
   5   6

Tree structure:
- Node 1 has 3 children: [2, 3, 4]
- Node 2 has 2 children: [5, 6]
- Nodes 3, 4, 5, 6 are leaf nodes
```

### Alternative Representation (with parent pointer)

```python
class NodeWithParent:
    def __init__(self, val=0):
        self.val = val
        self.children = []
        self.parent = None
    
    def add_child(self, child):
        self.children.append(child)
        child.parent = self
```

## 14.2 N-ary Tree Traversals

### Preorder Traversal (Root → Children)

Visit root first, then recursively visit each child left to right.

```python
def preorder_recursive(root):
    """
    Preorder: Visit root, then all children left to right
    Time: O(n), Space: O(h) for recursion
    """
    if not root:
        return []
    
    result = [root.val]  # Visit root
    
    # Visit all children
    for child in root.children:
        result.extend(preorder_recursive(child))
    
    return result

# Example tree:
#      1
#    / | \
#   3  2  4
#  / \
# 5   6
#
# Preorder: [1, 3, 5, 6, 2, 4]
```

**Iterative Preorder:**

```python
def preorder_iterative(root):
    """
    Iterative preorder using stack
    Time: O(n), Space: O(h)
    """
    if not root:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        result.append(node.val)
        
        # Add children in reverse order (right to left)
        # So they are processed left to right
        for child in reversed(node.children):
            stack.append(child)
    
    return result
```

### Postorder Traversal (Children → Root)

Visit all children first, then root.

```python
def postorder_recursive(root):
    """
    Postorder: Visit all children, then root
    Time: O(n), Space: O(h)
    """
    if not root:
        return []
    
    result = []
    
    # Visit all children first
    for child in root.children:
        result.extend(postorder_recursive(child))
    
    result.append(root.val)  # Visit root last
    
    return result

# Example tree:
#      1
#    / | \
#   3  2  4
#  / \
# 5   6
#
# Postorder: [5, 6, 3, 2, 4, 1]
```

**Iterative Postorder (elegant method):**

```python
def postorder_iterative(root):
    """
    Iterative postorder using stack
    Trick: Reverse of modified preorder
    """
    if not root:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        result.append(node.val)
        
        # Add children left to right (not reversed)
        for child in node.children:
            stack.append(child)
    
    # Reverse the result
    return result[::-1]
```

### Level Order Traversal (BFS)

Visit nodes level by level.

```python
from collections import deque

def level_order(root):
    """
    Level order traversal (BFS)
    Time: O(n), Space: O(w) where w = max width
    """
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        level = []
        
        for _ in range(level_size):
            node = queue.popleft()
            level.append(node.val)
            
            # Add all children to queue
            for child in node.children:
                queue.append(child)
        
        result.append(level)
    
    return result

# Example tree:
#      1
#    / | \
#   3  2  4
#  / \
# 5   6
#
# Level order: [[1], [3, 2, 4], [5, 6]]
```

### Level Order - Single List

```python
def level_order_single_list(root):
    """Return all nodes in single list (BFS order)"""
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        result.append(node.val)
        
        for child in node.children:
            queue.append(child)
    
    return result

# Result: [1, 3, 2, 4, 5, 6]
```

## 14.3 Common N-ary Tree Operations

### Maximum Depth

```python
def max_depth(root):
    """
    Find maximum depth (height) of tree
    Time: O(n), Space: O(h)
    """
    if not root:
        return 0
    
    if not root.children:
        return 1
    
    # Max depth among all children + 1
    return 1 + max(max_depth(child) for child in root.children)

# Alternative iterative (BFS)
def max_depth_iterative(root):
    if not root:
        return 0
    
    depth = 0
    queue = deque([root])
    
    while queue:
        depth += 1
        level_size = len(queue)
        
        for _ in range(level_size):
            node = queue.popleft()
            for child in node.children:
                queue.append(child)
    
    return depth
```

### Minimum Depth (shortest path to leaf)

```python
def min_depth(root):
    """
    Find minimum depth to any leaf
    Best solved with BFS
    Time: O(n), Space: O(w)
    """
    if not root:
        return 0
    
    queue = deque([(root, 1)])
    
    while queue:
        node, depth = queue.popleft()
        
        # First leaf we encounter has minimum depth
        if not node.children:
            return depth
        
        for child in node.children:
            queue.append((child, depth + 1))
    
    return 0
```

### Count Nodes

```python
def count_nodes(root):
    """
    Count total number of nodes
    Time: O(n), Space: O(h)
    """
    if not root:
        return 0
    
    count = 1  # Count root
    for child in root.children:
        count += count_nodes(child)
    
    return count
```

### Diameter of N-ary Tree

```python
def diameter(root):
    """
    Find diameter (longest path between any two nodes)
    Time: O(n), Space: O(h)
    """
    max_diameter = 0
    
    def height(node):
        nonlocal max_diameter
        
        if not node:
            return 0
        
        # Get heights of all children
        heights = []
        for child in node.children:
            heights.append(height(child))
        
        # Sort to get two largest heights
        heights.sort(reverse=True)
        
        # Diameter through this node
        if len(heights) >= 2:
            max_diameter = max(max_diameter, heights[0] + heights[1])
        elif len(heights) == 1:
            max_diameter = max(max_diameter, heights[0])
        
        # Return height of this subtree
        return 1 + (heights[0] if heights else 0)
    
    height(root)
    return max_diameter
```

### Path Sum

```python
def has_path_sum(root, target_sum):
    """
    Check if any root-to-leaf path sums to target
    Time: O(n), Space: O(h)
    """
    if not root:
        return False
    
    # Leaf node
    if not root.children:
        return root.val == target_sum
    
    # Check all children
    remaining = target_sum - root.val
    return any(has_path_sum(child, remaining) for child in root.children)

def all_path_sums(root, target_sum):
    """Find all root-to-leaf paths that sum to target"""
    result = []
    
    def dfs(node, path, current_sum):
        if not node:
            return
        
        path.append(node.val)
        current_sum += node.val
        
        # Leaf node
        if not node.children:
            if current_sum == target_sum:
                result.append(path[:])
        else:
            for child in node.children:
                dfs(child, path, current_sum)
        
        path.pop()
    
    dfs(root, [], 0)
    return result
```

## 14.4 Encode/Decode N-ary Tree to Binary Tree

**Problem**: How to represent an N-ary tree using a binary tree?

**Solution**: **Left-Child Right-Sibling** representation

### Concept

```
N-ary Tree:              Binary Tree:
     1                        1
   / | \                     /
  2  3  4                   2
 / \                       / \
5   6                     5   3
                           \   \
                            6   4

Rule:
- Left child → First child of original node
- Right child → Next sibling in original tree
```

### Implementation

```python
class TreeNode:  # Binary tree node
    def __init__(self, val=0):
        self.val = val
        self.left = None
        self.right = None

def encode(root):
    """
    Encode N-ary tree to binary tree
    Left = first child, Right = next sibling
    Time: O(n), Space: O(h)
    """
    if not root:
        return None
    
    binary_root = TreeNode(root.val)
    
    if root.children:
        # First child goes to left
        binary_root.left = encode(root.children[0])
        
        # Siblings form a chain on the right
        current = binary_root.left
        for i in range(1, len(root.children)):
            current.right = encode(root.children[i])
            current = current.right
    
    return binary_root

def decode(root):
    """
    Decode binary tree back to N-ary tree
    Time: O(n), Space: O(h)
    """
    if not root:
        return None
    
    nary_root = Node(root.val)
    
    # Left child becomes first child
    current = root.left
    while current:
        nary_root.children.append(decode(current))
        current = current.right  # Siblings
    
    return nary_root
```

## 14.5 Serialize and Deserialize N-ary Tree

### Method 1: Preorder with size

```python
def serialize(root):
    """
    Serialize using preorder: [val][num_children][children...]
    Example: 1[3] 3[2] 5[0] 6[0] 2[0] 4[0]
    """
    if not root:
        return ""
    
    result = []
    
    def preorder(node):
        if not node:
            return
        
        result.append(str(node.val))
        result.append(str(len(node.children)))
        
        for child in node.children:
            preorder(child)
    
    preorder(root)
    return " ".join(result)

def deserialize(data):
    """Deserialize from preorder with size"""
    if not data:
        return None
    
    tokens = data.split()
    index = [0]
    
    def build():
        if index[0] >= len(tokens):
            return None
        
        val = int(tokens[index[0]])
        index[0] += 1
        num_children = int(tokens[index[0]])
        index[0] += 1
        
        node = Node(val)
        for _ in range(num_children):
            node.children.append(build())
        
        return node
    
    return build()
```

### Method 2: Level order with markers

```python
def serialize_levelorder(root):
    """
    Serialize using level order with '#' as end marker
    Example: "1 3 2 4 # 5 6 # # # # #"
    """
    if not root:
        return ""
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        result.append(str(node.val))
        
        for child in node.children:
            queue.append(child)
        
        result.append("#")  # End of children for this node
    
    return " ".join(result)
```

## 14.6 Advanced Operations

### Lowest Common Ancestor (LCA)

```python
def lowest_common_ancestor(root, p, q):
    """
    Find LCA of two nodes in N-ary tree
    Time: O(n), Space: O(h)
    """
    if not root or root == p or root == q:
        return root
    
    # Search in all children
    found_in_children = []
    for child in root.children:
        lca = lowest_common_ancestor(child, p, q)
        if lca:
            found_in_children.append(lca)
    
    # If found in multiple children, current is LCA
    if len(found_in_children) > 1:
        return root
    
    # If found in one child, return that
    if len(found_in_children) == 1:
        return found_in_children[0]
    
    return None
```

### Clone N-ary Tree

```python
def clone_tree(root):
    """
    Create deep copy of N-ary tree
    Time: O(n), Space: O(h)
    """
    if not root:
        return None
    
    # Create new node
    new_root = Node(root.val)
    
    # Clone all children
    for child in root.children:
        new_root.children.append(clone_tree(child))
    
    return new_root

# With HashMap for node mapping
def clone_tree_with_map(root):
    """Clone with reference mapping"""
    if not root:
        return None
    
    node_map = {}
    
    def clone(node):
        if not node:
            return None
        
        if node in node_map:
            return node_map[node]
        
        new_node = Node(node.val)
        node_map[node] = new_node
        
        for child in node.children:
            new_node.children.append(clone(child))
        
        return new_node
    
    return clone(root)
```

## 14.7 Applications

### File System

```python
class FileNode:
    def __init__(self, name, is_file=False):
        self.name = name
        self.is_file = is_file
        self.children = []  # subdirectories/files
        self.content = "" if is_file else None
    
    def add_file(self, path, content):
        """Add file at given path"""
        parts = path.split('/')
        current = self
        
        for part in parts[:-1]:  # Navigate to parent directory
            found = False
            for child in current.children:
                if child.name == part:
                    current = child
                    found = True
                    break
            if not found:
                new_dir = FileNode(part, is_file=False)
                current.children.append(new_dir)
                current = new_dir
        
        # Add file
        file_node = FileNode(parts[-1], is_file=True)
        file_node.content = content
        current.children.append(file_node)
    
    def find_file(self, path):
        """Find and return file content"""
        parts = path.split('/')
        current = self
        
        for part in parts:
            found = False
            for child in current.children:
                if child.name == part:
                    current = child
                    found = True
                    break
            if not found:
                return None
        
        return current.content if current.is_file else None
```

## 14.8 Time and Space Complexity

| Operation | Time | Space |
|-----------|------|-------|
| Traversal (any) | O(n) | O(h) recursive, O(w) iterative |
| Search | O(n) | O(h) |
| Insert | O(1) | O(1) |
| Delete | O(k) | O(1) |
| Height | O(n) | O(h) |

Where:
- n = total nodes
- h = height of tree
- w = maximum width
- k = number of children to search

## Common N-ary Tree Problems

1. **N-ary Tree Level Order Traversal** - Leetcode #429
2. **N-ary Tree Preorder Traversal** - Leetcode #589
3. **N-ary Tree Postorder Traversal** - Leetcode #590
4. **Maximum Depth of N-ary Tree** - Leetcode #559
5. **Encode N-ary Tree to Binary Tree** - Leetcode #431
6. **Serialize and Deserialize N-ary Tree** - Leetcode #428
7. **Diameter of N-ary Tree** - Leetcode #1522

## Key Takeaways

✅ **Structure:**
- Each node has a list of children
- More flexible than binary trees
- Natural for hierarchical data

✅ **Traversals:**
- Preorder: Root → Children (left to right)
- Postorder: Children → Root
- Level order: BFS with queue

✅ **Encoding to Binary:**
- Left-child right-sibling representation
- Preserves structure completely

✅ **Interview Tips:**
- Ask: how many children can a node have?
- Consider using deque for children list
- Level order is often simpler than recursive
- For k-ary trees (fixed k), can use array
