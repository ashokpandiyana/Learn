# Chapter 4: Binary Search Tree (BST) - In-Depth Guide

## 4.1 BST Property - The Foundation

A **Binary Search Tree** is a binary tree with a special ordering property that makes searching efficient.

### The BST Property:
For every node in the tree:
- **All values in the left subtree < node's value**
- **All values in the right subtree > node's value**
- **Both subtrees must also be BSTs** (recursive property)

### Visual Example:

```
        8
       / \
      3   10
     / \    \
    1   6   14
       / \  /
      4  7 13

✅ Valid BST:
- Left of 8: {3,1,6,4,7} all < 8
- Right of 8: {10,14,13} all > 8
- Each subtree follows BST property
```

```
        8
       / \
      3   10
     / \    \
    1   12   14
       
❌ Invalid BST:
- 12 is in left subtree of 8
- But 12 > 8 (violates BST property)
```

### Key Insight:
The BST property enables **binary search** on a tree structure, making operations logarithmic in balanced trees.

---

## 4.2 BST Operations Complexity

### Complexity Table:

| Operation | Average Case | Worst Case (Skewed) | Best Case (Balanced) |
|-----------|--------------|---------------------|---------------------|
| **Search** | O(log n) | O(n) | O(log n) |
| **Insert** | O(log n) | O(n) | O(log n) |
| **Delete** | O(log n) | O(n) | O(log n) |
| **Find Min** | O(log n) | O(n) | O(log n) |
| **Find Max** | O(log n) | O(n) | O(log n) |
| **Inorder Traversal** | O(n) | O(n) | O(n) |

### Why the Variance?

**Balanced Tree (Best/Average Case):**
```
        50
       /  \
      30   70
     / \   / \
   20  40 60 80

Height = log₂(n)
Path length ≈ log₂(7) ≈ 2.8
```

**Skewed Tree (Worst Case):**
```
    50
      \
       60
         \
          70
            \
             80

Height = n-1
Degenerates to linked list!
Path length = 4
```

### Space Complexity:
- **Storage**: O(n) - one node per element
- **Recursion Stack**: O(h) where h = height
  - Best case: O(log n)
  - Worst case: O(n)

---

## 4.3 BST Search Operation

### Algorithm:

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def search_bst(root, target):
    """
    Search for a target value in BST
    Returns the node if found, None otherwise
    """
    # Base case: empty tree or found
    if root is None or root.val == target:
        return root
    
    # If target is smaller, search left subtree
    if target < root.val:
        return search_bst(root.left, target)
    # If target is larger, search right subtree
    else:
        return search_bst(root.right, target)

# Iterative version (more space efficient)
def search_bst_iterative(root, target):
    current = root
    
    while current is not None:
        if target == current.val:
            return current
        elif target < current.val:
            current = current.left
        else:
            current = current.right
    
    return None
```

### Search Example:
```
Search for 6 in:
        8
       / \
      3   10
     / \    \
    1   6   14
       / \
      4  7

Step 1: Start at 8, 6 < 8 → go left
Step 2: At 3, 6 > 3 → go right
Step 3: At 6, 6 == 6 → FOUND!

Comparisons: 3 (log₂(n) behavior)
```

---

## 4.4 BST Insertion

### Algorithm:

```python
def insert_bst(root, val):
    """
    Insert a value into BST
    Returns the root of the modified tree
    """
    # Base case: empty tree
    if root is None:
        return TreeNode(val)
    
    # Recursive case: find correct position
    if val < root.val:
        root.left = insert_bst(root.left, val)
    elif val > root.val:
        root.right = insert_bst(root.right, val)
    # If val == root.val, we typically don't insert duplicates
    # (or handle based on requirements)
    
    return root

# Iterative version
def insert_bst_iterative(root, val):
    """Iterative insertion - more space efficient"""
    new_node = TreeNode(val)
    
    if root is None:
        return new_node
    
    current = root
    parent = None
    
    # Find the insertion point
    while current is not None:
        parent = current
        if val < current.val:
            current = current.left
        else:
            current = current.right
    
    # Insert as left or right child of parent
    if val < parent.val:
        parent.left = new_node
    else:
        parent.right = new_node
    
    return root
```

### Insertion Example:
```
Insert 5 into:

Initial:              After insertion:
    8                     8
   / \                   / \
  3   10                3   10
 / \    \              / \    \
1   6   14            1   6   14
   / \                   / \
  4  7                  4  7
                           /
                          5

Path: 8 → 3 → 6 → 4 → insert as right child of 4
```

---

## 4.5 BST Deletion - The Complex Operation

Deletion is the most complex BST operation with **three distinct cases**.

### Case 1: Node is a Leaf (No Children)

**Simply remove the node**

```
Delete 4:
    8                8
   / \              / \
  3   10           3   10
 / \    \    →    / \    \
1   6   14       1   6   14
   / \              / \
  4  7              7

Just set parent's pointer to None
```

### Case 2: Node has One Child

**Replace node with its child**

```
Delete 10 (has only right child):
    8                8
   / \              / \
  3   10           3   14
 / \    \    →    / \
1   6   14       1   6
   / \              / \
  4  7             4  7

Connect parent directly to child
```

### Case 3: Node has Two Children (Most Complex!)

**Strategy: Replace with Inorder Successor (or Predecessor)**

**Inorder Successor** = Smallest value in right subtree (leftmost node in right subtree)

**Inorder Predecessor** = Largest value in left subtree (rightmost node in left subtree)

```
Delete 3 (has two children):

Step 1: Find inorder successor of 3
        → Go right to 6, then left until null
        → Successor = 4

    8                
   / \              
  3   10           
 / \    \    
1   6   14       
   / \            
  4  7            

Step 2: Copy successor's value to node 3
    8                
   / \              
  4   10           
 / \    \    
1   6   14       
   / \            
  4  7   ← this 4 needs to be deleted now

Step 3: Delete the successor (it has at most 1 child)
    8                
   / \              
  4   10           
 / \    \    
1   6   14       
     \            
      7
```

### Complete Deletion Code:

```python
def delete_bst(root, key):
    """
    Delete a node with given key from BST
    Returns the root of the modified tree
    """
    if root is None:
        return None
    
    # Search for the node
    if key < root.val:
        root.left = delete_bst(root.left, key)
    elif key > root.val:
        root.right = delete_bst(root.right, key)
    else:
        # Node found! Now handle three cases
        
        # Case 1: Leaf node or Case 2: One child
        if root.left is None:
            return root.right
        elif root.right is None:
            return root.left
        
        # Case 3: Two children
        # Find inorder successor (minimum in right subtree)
        successor = find_min(root.right)
        
        # Copy successor's value to current node
        root.val = successor.val
        
        # Delete the successor
        root.right = delete_bst(root.right, successor.val)
    
    return root

def find_min(node):
    """Find the minimum value node (leftmost)"""
    current = node
    while current.left is not None:
        current = current.left
    return current

def find_max(node):
    """Find the maximum value node (rightmost)"""
    current = node
    while current.right is not None:
        current = current.right
    return current
```

### Why Inorder Successor Works:
1. It's the **smallest value greater than the node** to delete
2. It maintains BST property after replacement
3. It has **at most one child** (right child only), making its deletion simple

---

## 4.6 BST Validation

### ⚠️ Common Mistake:

**WRONG APPROACH** - Only checking immediate children:

```python
# ❌ INCORRECT!
def is_valid_bst_wrong(root):
    if root is None:
        return True
    
    # This only checks immediate children!
    if root.left and root.left.val >= root.val:
        return False
    if root.right and root.right.val <= root.val:
        return False
    
    return (is_valid_bst_wrong(root.left) and 
            is_valid_bst_wrong(root.right))
```

**Why it's wrong:**
```
    10
   /  \
  5    15
      /  \
     6   20

This would validate as BST with wrong approach,
but 6 < 10, so 6 should NOT be in right subtree of 10!
```

### ✅ Correct Approach 1: Range/Bounds Method

```python
def is_valid_bst(root):
    """
    Validate BST using min/max bounds
    Each node must be within valid range
    """
    def validate(node, min_val, max_val):
        # Empty tree is valid
        if node is None:
            return True
        
        # Check if current node violates bounds
        if node.val <= min_val or node.val >= max_val:
            return False
        
        # Recursively validate subtrees with updated bounds
        # Left subtree: all values must be < node.val
        # Right subtree: all values must be > node.val
        return (validate(node.left, min_val, node.val) and
                validate(node.right, node.val, max_val))
    
    return validate(root, float('-inf'), float('inf'))
```

**How it works:**
```
        10
       /  \
      5    15
     / \   / \
    3  7 12  20

validate(10, -∞, +∞) → True
├─ validate(5, -∞, 10) → True
│  ├─ validate(3, -∞, 5) → True
│  └─ validate(7, 5, 10) → True
└─ validate(15, 10, +∞) → True
   ├─ validate(12, 10, 15) → True
   └─ validate(20, 15, +∞) → True
```

### ✅ Correct Approach 2: Inorder Traversal Method

```python
def is_valid_bst_inorder(root):
    """
    Validate using inorder traversal
    BST's inorder traversal is strictly increasing
    """
    def inorder(node):
        if node is None:
            return True
        
        # Check left subtree
        if not inorder(node.left):
            return False
        
        # Check current node
        # Must be greater than previous value
        if node.val <= self.prev:
            return False
        self.prev = node.val
        
        # Check right subtree
        return inorder(node.right)
    
    self.prev = float('-inf')
    return inorder(root)

# Alternative: collect values and check if sorted
def is_valid_bst_inorder_simple(root):
    values = []
    
    def inorder(node):
        if node is None:
            return
        inorder(node.left)
        values.append(node.val)
        inorder(node.right)
    
    inorder(root)
    
    # Check if strictly increasing
    for i in range(1, len(values)):
        if values[i] <= values[i-1]:
            return False
    return True
```

---

## 4.7 Important BST Problems

### Problem 1: Kth Smallest Element

**Approach**: Inorder traversal gives sorted order, stop at kth element

```python
def kth_smallest(root, k):
    """
    Find kth smallest element in BST
    Time: O(k + h) where h is height
    Space: O(h) for recursion stack
    """
    def inorder(node):
        if node is None:
            return None
        
        # Search left subtree first (smaller values)
        result = inorder(node.left)
        if result is not None:
            return result
        
        # Process current node
        self.count += 1
        if self.count == k:
            return node.val
        
        # Search right subtree
        return inorder(node.right)
    
    self.count = 0
    return inorder(root)

# Iterative version (more intuitive)
def kth_smallest_iterative(root, k):
    stack = []
    current = root
    count = 0
    
    while stack or current:
        # Go to leftmost node
        while current:
            stack.append(current)
            current = current.left
        
        # Process node
        current = stack.pop()
        count += 1
        if count == k:
            return current.val
        
        # Move to right subtree
        current = current.right
    
    return None
```

### Problem 2: Lowest Common Ancestor (LCA) in BST

```python
def lca_bst(root, p, q):
    """
    Find LCA using BST property
    Time: O(h), Space: O(1) iterative
    """
    current = root
    
    while current:
        # If both nodes are smaller, LCA is in left subtree
        if p.val < current.val and q.val < current.val:
            current = current.left
        # If both nodes are larger, LCA is in right subtree
        elif p.val > current.val and q.val > current.val:
            current = current.right
        else:
            # Split point found! This is the LCA
            # (one goes left, one goes right, or one is current)
            return current
    
    return None
```

### Problem 3: Convert Sorted Array to BST

```python
def sorted_array_to_bst(nums):
    """
    Build height-balanced BST from sorted array
    Strategy: Use middle element as root
    Time: O(n), Space: O(log n)
    """
    def build(left, right):
        if left > right:
            return None
        
        # Choose middle as root for balance
        mid = (left + right) // 2
        node = TreeNode(nums[mid])
        
        # Recursively build subtrees
        node.left = build(left, mid - 1)
        node.right = build(mid + 1, right)
        
        return node
    
    return build(0, len(nums) - 1)
```

### Problem 4: Two Sum in BST

```python
def find_target(root, k):
    """
    Check if two numbers in BST sum to k
    Approach 1: HashSet (works for any binary tree)
    Time: O(n), Space: O(n)
    """
    def dfs(node):
        if node is None:
            return False
        
        complement = k - node.val
        if complement in seen:
            return True
        
        seen.add(node.val)
        return dfs(node.left) or dfs(node.right)
    
    seen = set()
    return dfs(root)

def find_target_optimized(root, k):
    """
    Approach 2: Two pointers on inorder (BST specific)
    Time: O(n), Space: O(h)
    """
    # Get inorder traversal (sorted)
    def inorder(node):
        if node is None:
            return []
        return inorder(node.left) + [node.val] + inorder(node.right)
    
    values = inorder(root)
    
    # Two pointer approach on sorted array
    left, right = 0, len(values) - 1
    while left < right:
        current_sum = values[left] + values[right]
        if current_sum == k:
            return True
        elif current_sum < k:
            left += 1
        else:
            right -= 1
    
    return False
```

---

## Key Takeaways

1. **BST Property**: All left < node < all right (for entire subtrees)
2. **Inorder traversal of BST is always sorted** - use this for validation!
3. **Deletion is complex**: Remember the three cases
4. **Validation**: Use range bounds, don't just check immediate children
5. **Balance matters**: Skewed tree degrades to O(n), balanced gives O(log n)
6. **Common pattern**: Many BST problems leverage the sorted inorder property

---

## Practice Problems

- ✅ Validate Binary Search Tree
- ✅ Delete Node in BST
- ✅ Kth Smallest Element in BST
- ✅ Lowest Common Ancestor of BST
- ✅ Convert Sorted Array to BST
- ✅ Two Sum IV (Two Sum in BST)
- ✅ Trim a Binary Search Tree
- ✅ Range Sum of BST
- ✅ Recover Binary Search Tree (two nodes swapped)
- ✅ Inorder Successor in BST
