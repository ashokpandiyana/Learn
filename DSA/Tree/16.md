# Chapter 16: Common Techniques - In Depth Explanation

## Overview
Beyond patterns, certain techniques repeatedly appear in tree problems. Mastering these techniques gives you powerful tools to solve complex problems efficiently.

---

## 16.1 Using HashMap in Trees

### Why HashMaps?
HashMaps enable **O(1) lookups** during tree traversal, making certain problems tractable that would otherwise be O(n²) or worse.

### Technique 1: Index Mapping for Construction

**Problem**: Construct Binary Tree from Inorder and Preorder Traversal

```python
def buildTree(preorder, inorder):
    """
    Preorder: [Root | Left subtree | Right subtree]
    Inorder:  [Left subtree | Root | Right subtree]
    
    Use HashMap to quickly find root position in inorder.
    """
    # Create index map for O(1) lookup
    inorder_map = {val: idx for idx, val in enumerate(inorder)}
    
    def build(pre_start, pre_end, in_start, in_end):
        if pre_start > pre_end:
            return None
        
        # Root is first element in preorder range
        root_val = preorder[pre_start]
        root = TreeNode(root_val)
        
        # Find root position in inorder
        root_idx = inorder_map[root_val]
        
        # Calculate left subtree size
        left_size = root_idx - in_start
        
        # Recursively build left and right subtrees
        root.left = build(
            pre_start + 1,
            pre_start + left_size,
            in_start,
            root_idx - 1
        )
        
        root.right = build(
            pre_start + left_size + 1,
            pre_end,
            root_idx + 1,
            in_end
        )
        
        return root
    
    return build(0, len(preorder) - 1, 0, len(inorder) - 1)
```

**Complexity**: O(n) with HashMap vs O(n²) without

### Technique 2: Path Sum with Target

**Problem**: Path Sum III - Count paths that sum to target (path can start/end anywhere)

```python
def pathSum(root, targetSum):
    """
    Use HashMap to store prefix sums.
    Similar to subarray sum equals K.
    """
    def dfs(node, current_sum):
        if not node:
            return 0
        
        # Update current sum
        current_sum += node.val
        
        # Count paths ending at current node
        count = prefix_sums.get(current_sum - targetSum, 0)
        
        # Add current sum to map
        prefix_sums[current_sum] = prefix_sums.get(current_sum, 0) + 1
        
        # Recurse
        count += dfs(node.left, current_sum)
        count += dfs(node.right, current_sum)
        
        # Backtrack: remove current sum
        prefix_sums[current_sum] -= 1
        
        return count
    
    prefix_sums = {0: 1}  # Base case: sum = 0
    return dfs(root, 0)
```

**Key Insight**: `prefix_sums[current_sum - targetSum]` tells us how many paths from root to ancestors sum to `current_sum - targetSum`. Adding `targetSum` to those paths gives us `current_sum`.

### Technique 3: Vertical Order Traversal

```python
def verticalOrder(root):
    """
    Group nodes by vertical column.
    Use HashMap to store nodes at each column.
    """
    if not root:
        return []
    
    # Map: column -> list of (row, value)
    column_map = defaultdict(list)
    
    # BFS with (node, row, column)
    queue = deque([(root, 0, 0)])
    
    while queue:
        node, row, col = queue.popleft()
        column_map[col].append((row, node.val))
        
        if node.left:
            queue.append((node.left, row + 1, col - 1))
        if node.right:
            queue.append((node.right, row + 1, col + 1))
    
    # Sort by column, then by row, then by value
    result = []
    for col in sorted(column_map.keys()):
        # Sort by row, then by value
        column_map[col].sort()
        result.append([val for row, val in column_map[col]])
    
    return result
```

---

## 16.2 Using Global Variables

### When to Use Global Variables
Global variables (or nonlocal in Python) are useful when:
- Tracking maximum/minimum across all recursive calls
- Counting occurrences
- Aggregating results from multiple paths

### Example 1: Diameter of Binary Tree

```python
def diameterOfBinaryTree(root):
    """
    Track maximum diameter as we calculate heights.
    """
    diameter = 0
    
    def height(node):
        nonlocal diameter  # Access outer scope
        
        if not node:
            return 0
        
        left_height = height(node.left)
        right_height = height(node.right)
        
        # Update global maximum
        diameter = max(diameter, left_height + right_height)
        
        return 1 + max(left_height, right_height)
    
    height(root)
    return diameter
```

### Example 2: Count Good Nodes

```python
def goodNodes(root):
    """
    Count nodes where value >= all ancestors.
    Track maximum value seen so far.
    """
    count = 0
    
    def dfs(node, max_so_far):
        nonlocal count
        
        if not node:
            return
        
        # Is current node good?
        if node.val >= max_so_far:
            count += 1
        
        # Update maximum for children
        new_max = max(max_so_far, node.val)
        dfs(node.left, new_max)
        dfs(node.right, new_max)
    
    dfs(root, float('-inf'))
    return count
```

### Example 3: Sum of Distances

```python
def sumOfDistances(root):
    """
    Calculate sum of distances from each node to all others.
    Uses two DFS passes with global state.
    """
    subtree_count = {}
    subtree_sum = {}
    
    def dfs1(node):
        """First pass: calculate subtree info."""
        if not node:
            return 0, 0
        
        left_count, left_sum = dfs1(node.left)
        right_count, right_sum = dfs1(node.right)
        
        count = 1 + left_count + right_count
        total_sum = left_sum + right_sum + left_count + right_count
        
        subtree_count[node] = count
        subtree_sum[node] = total_sum
        
        return count, total_sum
    
    def dfs2(node, parent_contribution):
        """Second pass: calculate answer for each node."""
        if not node:
            return
        
        result[node.val] = subtree_sum[node] + parent_contribution
        
        # Calculate contribution for children
        # ... implementation continues
    
    result = {}
    dfs1(root)
    dfs2(root, 0)
    return result
```

**Pro Tip**: Use a class to encapsulate state instead of global variables for cleaner code:

```python
class Solution:
    def diameterOfBinaryTree(self, root):
        self.diameter = 0
        
        def height(node):
            if not node:
                return 0
            
            left = height(node.left)
            right = height(node.right)
            
            self.diameter = max(self.diameter, left + right)
            
            return 1 + max(left, right)
        
        height(root)
        return self.diameter
```

---

## 16.3 Return Value vs Side Effect

### Understanding the Difference

**Return Value**: Function returns result to caller
```python
def maxDepth(node):
    if not node:
        return 0
    return 1 + max(maxDepth(node.left), maxDepth(node.right))
```

**Side Effect**: Function modifies external state
```python
result = []

def collectLeaves(node):
    if not node:
        return
    if not node.left and not node.right:
        result.append(node.val)  # Side effect
    collectLeaves(node.left)
    collectLeaves(node.right)
```

### When to Use Each

| Use Return Values When | Use Side Effects When |
|------------------------|----------------------|
| Result is single value | Collecting multiple values |
| Pure functional style | Need complex state |
| Combining child results | Multiple outputs needed |
| Testing is easier | Performance critical |

### Example: Collecting All Paths

**Using Side Effects** (Common in interviews):
```python
def binaryTreePaths(root):
    """Collect all root-to-leaf paths."""
    paths = []
    
    def dfs(node, path):
        if not node:
            return
        
        path.append(str(node.val))
        
        # Leaf node
        if not node.left and not node.right:
            paths.append('->'.join(path))
        
        dfs(node.left, path)
        dfs(node.right, path)
        
        path.pop()  # Backtrack
    
    dfs(root, [])
    return paths
```

**Using Return Values** (More functional):
```python
def binaryTreePaths(root):
    """Collect all root-to-leaf paths."""
    def dfs(node):
        if not node:
            return []
        
        # Leaf node
        if not node.left and not node.right:
            return [str(node.val)]
        
        # Collect paths from children
        paths = []
        for path in dfs(node.left) + dfs(node.right):
            paths.append(str(node.val) + '->' + path)
        
        return paths
    
    return dfs(root)
```

---

## 16.4 Top-Down vs Bottom-Up

### Understanding the Approaches

**Top-Down (Preorder style)**:
- Pass information FROM root TO leaves
- Use function parameters
- Process current node, then recurse

**Bottom-Up (Postorder style)**:
- Gather information FROM leaves TO root
- Use return values
- Recurse first, then process current node

### Visual Comparison

```
Top-Down: Pass data downward
    root (height=0)
      â†"
    child (height=1)
      â†"
    grandchild (height=2)

Bottom-Up: Gather data upward
    grandchild (returns height)
      â†'
    child (combines children heights)
      â†'
    root (returns final height)
```

### Example 1: Maximum Depth

**Top-Down Approach**:
```python
def maxDepth(root):
    """Pass current depth down."""
    max_depth = 0
    
    def dfs(node, depth):
        nonlocal max_depth
        
        if not node:
            return
        
        # Leaf node
        if not node.left and not node.right:
            max_depth = max(max_depth, depth)
            return
        
        # Pass increased depth to children
        dfs(node.left, depth + 1)
        dfs(node.right, depth + 1)
    
    dfs(root, 1)
    return max_depth
```

**Bottom-Up Approach**:
```python
def maxDepth(root):
    """Gather height from children."""
    if not root:
        return 0
    
    # Get depths from children
    left_depth = maxDepth(root.left)
    right_depth = maxDepth(root.right)
    
    # Combine and return
    return 1 + max(left_depth, right_depth)
```

**Bottom-up is cleaner here!**

### Example 2: Path Sum

**Top-Down** (Natural for this problem):
```python
def hasPathSum(root, targetSum):
    """Pass remaining sum down."""
    if not root:
        return False
    
    # Reduce target by current value
    targetSum -= root.val
    
    # Leaf node: check if sum is 0
    if not root.left and not root.right:
        return targetSum == 0
    
    # Check either path
    return (hasPathSum(root.left, targetSum) or
            hasPathSum(root.right, targetSum))
```

### When to Use Each

| Problem Type | Approach | Why |
|--------------|----------|-----|
| Calculate height, size | Bottom-Up | Need info from children |
| Path sum, level tracking | Top-Down | Pass constraints down |
| Validate constraints | Top-Down | Pass bounds down |
| Aggregate subtree info | Bottom-Up | Combine child results |
| Both approaches work | Bottom-Up | Usually cleaner code |

---

## 16.5 Binary Lifting Technique

### What is Binary Lifting?

Binary lifting is an **advanced technique** for:
- Finding Kth ancestor in O(log n)
- Finding LCA in O(log n)
- Answering multiple queries efficiently

### The Concept

Instead of jumping one step at a time, jump in powers of 2:
- `ancestor[node][0]` = parent (2⁰ = 1 step)
- `ancestor[node][1]` = grandparent (2¹ = 2 steps)
- `ancestor[node][2]` = great-great-grandparent (2² = 4 steps)
- `ancestor[node][i]` = 2ⁱ steps up

### Building the Table

```python
class BinaryLifting:
    def __init__(self, root):
        """
        Preprocess tree for O(log n) queries.
        """
        import math
        
        # Count nodes and assign indices
        self.nodes = []
        self.depth = {}
        self.LOG = 20  # log2(max_nodes) + 1
        
        # Build node list and calculate depths
        self._build_node_list(root, 0)
        n = len(self.nodes)
        
        # ancestor[i][j] = 2^j-th ancestor of node i
        self.ancestor = [[-1] * self.LOG for _ in range(n)]
        
        # Build binary lifting table
        self._build_ancestors()
    
    def _build_node_list(self, node, depth):
        """DFS to build node list and depths."""
        if not node:
            return
        
        idx = len(self.nodes)
        self.nodes.append(node)
        self.depth[node] = depth
        
        self._build_node_list(node.left, depth + 1)
        self._build_node_list(node.right, depth + 1)
    
    def _build_ancestors(self):
        """Build binary lifting table."""
        # Build parent map first (0-th ancestor)
        parent_map = {}
        
        def build_parent(node):
            if not node:
                return
            if node.left:
                parent_map[node.left] = node
            if node.right:
                parent_map[node.right] = node
            build_parent(node.left)
            build_parent(node.right)
        
        build_parent(self.nodes[0])  # root
        
        # Fill first column (direct parent)
        for i, node in enumerate(self.nodes):
            if node in parent_map:
                parent_idx = self.nodes.index(parent_map[node])
                self.ancestor[i][0] = parent_idx
        
        # Fill remaining columns using DP
        for j in range(1, self.LOG):
            for i in range(len(self.nodes)):
                if self.ancestor[i][j-1] != -1:
                    parent = self.ancestor[i][j-1]
                    self.ancestor[i][j] = self.ancestor[parent][j-1]
    
    def get_kth_ancestor(self, node_idx, k):
        """
        Find k-th ancestor of node.
        Time: O(log k)
        """
        current = node_idx
        
        # Binary representation of k
        for i in range(self.LOG):
            if k & (1 << i):  # If i-th bit is set
                current = self.ancestor[current][i]
                if current == -1:
                    return None
        
        return current
    
    def lca(self, u_idx, v_idx):
        """
        Find Lowest Common Ancestor.
        Time: O(log n)
        """
        # Make u deeper
        if self.depth[self.nodes[u_idx]] < self.depth[self.nodes[v_idx]]:
            u_idx, v_idx = v_idx, u_idx
        
        # Bring u to same level as v
        depth_diff = self.depth[self.nodes[u_idx]] - self.depth[self.nodes[v_idx]]
        u_idx = self.get_kth_ancestor(u_idx, depth_diff)
        
        if u_idx == v_idx:
            return u_idx
        
        # Binary search for LCA
        for i in range(self.LOG - 1, -1, -1):
            if (self.ancestor[u_idx][i] != -1 and
                self.ancestor[v_idx][i] != -1 and
                self.ancestor[u_idx][i] != self.ancestor[v_idx][i]):
                u_idx = self.ancestor[u_idx][i]
                v_idx = self.ancestor[v_idx][i]
        
        # Parent of current position is LCA
        return self.ancestor[u_idx][0]
```

### Complexity Analysis

| Operation | Without Binary Lifting | With Binary Lifting |
|-----------|------------------------|---------------------|
| Preprocessing | O(n) | O(n log n) |
| Single Query | O(n) | O(log n) |
| Q Queries | O(nQ) | O(Q log n) |

**When to Use**: When you have many (Q > 100) ancestor or LCA queries

### Simplified Example: Find Kth Ancestor

```python
def kthAncestor(node, k):
    """
    Find k-th ancestor using binary lifting.
    Example: k=5 = 101₂ = 4 + 1
    Jump 4 steps, then 1 step.
    """
    current = node
    power = 0
    
    while k > 0:
        if k & 1:  # If current bit is 1
            current = ancestor[current][power]
            if not current:
                return None
        
        k >>= 1  # Next bit
        power += 1
    
    return current
```

---

## Summary: Technique Selection Guide

| Problem Characteristics | Technique to Use |
|------------------------|------------------|
| Need fast lookups during traversal | HashMap |
| Track global max/min | Global variable |
| Collect multiple values | Side effects + list |
| Combine child results | Return values |
| Pass constraints down | Top-Down |
| Aggregate from children | Bottom-Up |
| Many LCA/ancestor queries | Binary Lifting |
| Path sum with target | HashMap + prefix sum |
| Construct from traversals | HashMap for indices |

Practice recognizing which technique fits each problem, and you'll code solutions faster and cleaner!