# Chapter 3: Tree Traversals - In-Depth Guide

## Introduction to Tree Traversals

**Tree Traversal** is the process of visiting each node in a tree exactly once in a specific order. Unlike linear data structures, trees can be traversed in multiple ways.

### Two Main Categories:
1. **Depth-First Search (DFS)** - Go deep before going wide
2. **Breadth-First Search (BFS)** - Go wide before going deep

---

## 3.1 Depth-First Search (DFS) Traversals

DFS explores as far as possible along each branch before backtracking. Three types based on **when we visit the root**.

### Sample Tree for Examples:
```
        1
       / \
      2   3
     / \   \
    4   5   6
```

---

### 3.1.1 Preorder Traversal (Root â†’ Left â†’ Right)

**Order:** Visit root **first**, then left subtree, then right subtree.

**Steps:**
1. Visit current node
2. Traverse left subtree
3. Traverse right subtree

**Result for sample tree:** `1, 2, 4, 5, 3, 6`

**Visual Process:**
```
Step 1: Visit 1 â†’ [1]
Step 2: Go left to 2, visit 2 â†’ [1, 2]
Step 3: Go left to 4, visit 4 â†’ [1, 2, 4]
Step 4: No more left, backtrack, no right at 4
Step 5: Go right from 2 to 5, visit 5 â†’ [1, 2, 4, 5]
Step 6: Backtrack to 1, go right to 3, visit 3 â†’ [1, 2, 4, 5, 3]
Step 7: Go right from 3 to 6, visit 6 â†’ [1, 2, 4, 5, 3, 6]
```

#### Recursive Implementation:
```python
def preorder_recursive(root):
    """Preorder: Root â†’ Left â†’ Right"""
    result = []
    
    def traverse(node):
        if not node:
            return
        
        result.append(node.val)      # Visit root
        traverse(node.left)          # Traverse left
        traverse(node.right)         # Traverse right
    
    traverse(root)
    return result

# Usage
print(preorder_recursive(root))  # [1, 2, 4, 5, 3, 6]
```

#### Iterative Implementation (Using Stack):
```python
def preorder_iterative(root):
    """Iterative preorder using explicit stack"""
    if not root:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        result.append(node.val)
        
        # Push right first (so left is processed first)
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    
    return result
```

**Use Cases:**
- **Create a copy of the tree**
- **Prefix expression evaluation**
- **Serialize a tree** (save to disk/network)
- **Expression tree** (prefix notation)

---

### 3.1.2 Inorder Traversal (Left â†’ Root â†’ Right)

**Order:** Traverse left subtree, visit root, then right subtree.

**Steps:**
1. Traverse left subtree
2. Visit current node
3. Traverse right subtree

**Result for sample tree:** `4, 2, 5, 1, 3, 6`

**Visual Process:**
```
        1
       / \
      2   3
     / \   \
    4   5   6

Go left until no more left:
  1 â†’ 2 â†’ 4 (visit 4) â†’ back to 2 (visit 2) â†’ 5 (visit 5)
  â†’ back to 1 (visit 1) â†’ 3 (visit 3) â†’ 6 (visit 6)
```

#### Recursive Implementation:
```python
def inorder_recursive(root):
    """Inorder: Left â†’ Root â†’ Right"""
    result = []
    
    def traverse(node):
        if not node:
            return
        
        traverse(node.left)          # Traverse left
        result.append(node.val)      # Visit root
        traverse(node.right)         # Traverse right
    
    traverse(root)
    return result

# Usage
print(inorder_recursive(root))  # [4, 2, 5, 1, 3, 6]
```

#### Iterative Implementation:
```python
def inorder_iterative(root):
    """Iterative inorder using stack"""
    result = []
    stack = []
    current = root
    
    while current or stack:
        # Go to the leftmost node
        while current:
            stack.append(current)
            current = current.left
        
        # Current is None, pop from stack
        current = stack.pop()
        result.append(current.val)
        
        # Visit right subtree
        current = current.right
    
    return result
```

**ðŸ”¥ Critical Property:** 
For a **Binary Search Tree (BST)**, inorder traversal gives nodes in **sorted order**!

```python
# BST Example:
#        4
#       / \
#      2   6
#     / \ / \
#    1  3 5  7

# Inorder: [1, 2, 3, 4, 5, 6, 7] â†’ Sorted!
```

**Use Cases:**
- **Get sorted order from BST**
- **Validate BST** (check if inorder is sorted)
- **Infix expression** (expression trees)
- **Finding kth smallest element** in BST

---

### 3.1.3 Postorder Traversal (Left â†’ Right â†’ Root)

**Order:** Traverse left subtree, right subtree, then visit root.

**Steps:**
1. Traverse left subtree
2. Traverse right subtree
3. Visit current node

**Result for sample tree:** `4, 5, 2, 6, 3, 1`

**Visual Process:**
```
        1
       / \
      2   3
     / \   \
    4   5   6

Visit leaves first, then work up:
  4 â†’ 5 â†’ 2 (both children done) â†’ 6 â†’ 3 (both children done) â†’ 1 (root last)
```

#### Recursive Implementation:
```python
def postorder_recursive(root):
    """Postorder: Left â†’ Right â†’ Root"""
    result = []
    
    def traverse(node):
        if not node:
            return
        
        traverse(node.left)          # Traverse left
        traverse(node.right)         # Traverse right
        result.append(node.val)      # Visit root
    
    traverse(root)
    return result

# Usage
print(postorder_recursive(root))  # [4, 5, 2, 6, 3, 1]
```

#### Iterative Implementation (Two Stacks):
```python
def postorder_iterative(root):
    """Iterative postorder using two stacks"""
    if not root:
        return []
    
    stack1 = [root]
    stack2 = []
    
    # Fill stack2 with reverse postorder
    while stack1:
        node = stack1.pop()
        stack2.append(node)
        
        # Push left then right
        if node.left:
            stack1.append(node.left)
        if node.right:
            stack1.append(node.right)
    
    # Pop from stack2 to get postorder
    result = []
    while stack2:
        result.append(stack2.pop().val)
    
    return result
```

#### Iterative Implementation (One Stack):
```python
def postorder_iterative_one_stack(root):
    """Iterative postorder using one stack"""
    if not root:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        result.append(node.val)
        
        # Push left then right (reverse of preorder)
        if node.left:
            stack.append(node.left)
        if node.right:
            stack.append(node.right)
    
    # Reverse to get postorder from modified preorder
    return result[::-1]
```

**Use Cases:**
- **Delete a tree** (delete children before parent)
- **Postfix expression evaluation**
- **Calculate directory size** (children first, then parent)
- **Tree destruction** (free memory bottom-up)

---

## DFS Comparison Table

| Traversal | Order | Result | Main Use |
|-----------|-------|--------|----------|
| Preorder | Root â†’ L â†’ R | 1,2,4,5,3,6 | Copy tree, serialize |
| Inorder | L â†’ Root â†’ R | 4,2,5,1,3,6 | BST sorted, validate |
| Postorder | L â†’ R â†’ Root | 4,5,2,6,3,1 | Delete tree, calculate |

---

## 3.2 Breadth-First Search (BFS) / Level Order Traversal

**Level Order:** Visit nodes level by level, from left to right.

**Result for sample tree:** `1, 2, 3, 4, 5, 6`

**Visual Process:**
```
Level 0:    1          â†’ Visit [1]
           / \
Level 1:  2   3        â†’ Visit [2, 3]
         / \   \
Level 2: 4  5   6      â†’ Visit [4, 5, 6]

Final: [1, 2, 3, 4, 5, 6]
```

### Implementation Using Queue:
```python
from collections import deque

def level_order(root):
    """BFS Level Order Traversal"""
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        result.append(node.val)
        
        # Add children to queue
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    
    return result

# Usage
print(level_order(root))  # [1, 2, 3, 4, 5, 6]
```

### Level Order with Level Separation:
```python
def level_order_levels(root):
    """BFS with each level as separate list"""
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        current_level = []
        
        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(current_level)
    
    return result

# Usage
print(level_order_levels(root))  
# [[1], [2, 3], [4, 5, 6]]
```

### Zigzag Level Order:
```python
def zigzag_level_order(root):
    """Zigzag: left-to-right, then right-to-left alternating"""
    if not root:
        return []
    
    result = []
    queue = deque([root])
    left_to_right = True
    
    while queue:
        level_size = len(queue)
        current_level = deque()
        
        for _ in range(level_size):
            node = queue.popleft()
            
            # Add to appropriate end based on direction
            if left_to_right:
                current_level.append(node.val)
            else:
                current_level.appendleft(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(list(current_level))
        left_to_right = not left_to_right
    
    return result

# Result: [[1], [3, 2], [4, 5, 6]]
```

**Complexity:**
- **Time:** O(n) - visit each node once
- **Space:** O(w) where w = maximum width of tree

**Use Cases:**
- **Level-wise processing**
- **Finding shortest path** in tree
- **Right/Left side view** of tree
- **Connect nodes at same level**

---

## 3.3 Recursive vs Iterative Comparison

| Aspect | Recursive | Iterative |
|--------|-----------|-----------|
| **Code** | Clean, intuitive | More complex |
| **Space** | O(h) implicit stack | O(h) explicit stack |
| **Risk** | Stack overflow | No stack overflow |
| **Debug** | Harder to debug | Easier to trace |
| **Interview** | Often preferred | Shows deep understanding |

### When to Use Each:

**Recursive:**
- Quick implementation
- Tree height is reasonable
- Problem naturally recursive

**Iterative:**
- Large/deep trees
- Production code (avoid stack overflow)
- When explicitly asked in interview

---

## 3.4 Morris Traversal (O(1) Space)

**Key Idea:** Use threaded binary tree - temporarily create links to inorder successor.

**Space Complexity:** O(1) - no stack or recursion!

### Morris Inorder Traversal:
```python
def morris_inorder(root):
    """Morris Traversal for Inorder - O(1) space"""
    result = []
    current = root
    
    while current:
        if not current.left:
            # No left child, visit and go right
            result.append(current.val)
            current = current.right
        else:
            # Find inorder predecessor
            predecessor = current.left
            while predecessor.right and predecessor.right != current:
                predecessor = predecessor.right
            
            if not predecessor.right:
                # Create thread
                predecessor.right = current
                current = current.left
            else:
                # Remove thread
                predecessor.right = None
                result.append(current.val)
                current = current.right
    
    return result
```

**How it Works:**
1. Find rightmost node in left subtree (predecessor)
2. Make it point to current (create thread)
3. Use thread to return to current after processing left
4. Remove thread before moving right

**Visualization:**
```
Original:       With Thread:      After Processing:
    1               1                   1
   / \             / \                   \
  2   3           2   3                   3
                   \
                    1 (thread)
```

### Morris Preorder:
```python
def morris_preorder(root):
    """Morris Traversal for Preorder - O(1) space"""
    result = []
    current = root
    
    while current:
        if not current.left:
            result.append(current.val)
            current = current.right
        else:
            predecessor = current.left
            while predecessor.right and predecessor.right != current:
                predecessor = predecessor.right
            
            if not predecessor.right:
                result.append(current.val)  # Visit before going left
                predecessor.right = current
                current = current.left
            else:
                predecessor.right = None
                current = current.right
    
    return result
```

**When to Use Morris:**
- Interviewer asks for O(1) space solution
- Memory is extremely constrained
- Advanced/hard interview questions

---

## 3.5 Vertical Order Traversal

**Concept:** Group nodes by horizontal distance from root.

```
        1 (0)
       / \
   (-1)2   3(1)
      / \   \
 (-2)4   5(0) 6(2)

Vertical Lines:
  -2: [4]
  -1: [2]
   0: [1, 5]
   1: [3]
   2: [6]
```

### Implementation:
```python
from collections import defaultdict, deque

def vertical_order(root):
    """Vertical order traversal"""
    if not root:
        return []
    
    # column -> list of nodes
    columns = defaultdict(list)
    
    # BFS with (node, column) pairs
    queue = deque([(root, 0)])
    
    while queue:
        node, col = queue.popleft()
        columns[col].append(node.val)
        
        if node.left:
            queue.append((node.left, col - 1))
        if node.right:
            queue.append((node.right, col + 1))
    
    # Sort by column and flatten
    result = []
    for col in sorted(columns.keys()):
        result.extend(columns[col])
    
    return result
```

---

## 3.6 Boundary Traversal

**Parts:**
1. Left boundary (excluding leaves)
2. All leaves (left to right)
3. Right boundary (excluding leaves, bottom to top)

```
        1
       / \
      2   3
     / \   \
    4   5   6

Boundary: [1, 2, 4, 5, 6, 3]
```

### Implementation:
```python
def boundary_traversal(root):
    """Boundary traversal of binary tree"""
    if not root:
        return []
    
    result = [root.val]
    
    def is_leaf(node):
        return node and not node.left and not node.right
    
    def left_boundary(node):
        """Add left boundary (excluding leaves)"""
        if not node or is_leaf(node):
            return
        result.append(node.val)
        if node.left:
            left_boundary(node.left)
        else:
            left_boundary(node.right)
    
    def leaves(node):
        """Add all leaves"""
        if not node:
            return
        if is_leaf(node):
            result.append(node.val)
            return
        leaves(node.left)
        leaves(node.right)
    
    def right_boundary(node):
        """Add right boundary in reverse (excluding leaves)"""
        if not node or is_leaf(node):
            return
        if node.right:
            right_boundary(node.right)
        else:
            right_boundary(node.left)
        result.append(node.val)  # Add after recursion (reverse)
    
    # Execute in order
    left_boundary(root.left)
    leaves(root)
    right_boundary(root.right)
    
    return result
```

---

## 3.7 Diagonal Traversal

**Concept:** Nodes in same diagonal have same (row - col) value.

```
        1 (0-0=0)
       / \
      2   3 (1-1=0)
     / \   \
    4   5   6 (2-2=0)

Diagonals:
  0: [1, 3, 6]
  1: [2, 5]
  2: [4]
```

### Implementation:
```python
def diagonal_traversal(root):
    """Diagonal traversal (top-right to bottom-left)"""
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        
        # Process entire diagonal
        while node:
            result.append(node.val)
            if node.left:
                queue.append(node.left)
            node = node.right
    
    return result
```

---

## Complete Traversal Examples

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# Build tree:
#        1
#       / \
#      2   3
#     / \   \
#    4   5   6

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
root.right.right = TreeNode(6)

# Run all traversals
print("Preorder:", preorder_recursive(root))    # [1,2,4,5,3,6]
print("Inorder:", inorder_recursive(root))      # [4,2,5,1,3,6]
print("Postorder:", postorder_recursive(root))  # [4,5,2,6,3,1]
print("Level Order:", level_order(root))        # [1,2,3,4,5,6]
```

---

## Practice Problems for Chapter 3

1. Implement all three DFS traversals iteratively
2. Print level order traversal in reverse
3. Find right view of binary tree
4. Find left view of binary tree
5. Print nodes at distance K from root
6. Vertical order traversal with level info
7. Morris traversal for preorder
8. Serialize and deserialize using preorder

Master these traversals - they form the foundation for almost every tree problem!