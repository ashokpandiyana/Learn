# Chapter 7: Path Problems - In-Depth Guide

## Introduction

Path problems in trees are among the most common and challenging interview questions. They require understanding different types of paths and how to efficiently traverse and calculate properties along these paths.

---

## 7.1 Root-to-Leaf Paths

### Concept
A root-to-leaf path is a sequence of nodes starting from the root and ending at a leaf node (a node with no children). These paths always move downward in the tree.

### 7.1.1 Path Sum (Exact Sum Exists?)

**Problem**: Given a target sum, determine if there exists a root-to-leaf path where the sum of node values equals the target.

**Approach**: Use DFS (Depth-First Search) and subtract current node's value from the target as you traverse down.

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def hasPathSum(root, targetSum):
    """
    Time: O(n) - visit each node once
    Space: O(h) - recursion stack where h is height
    """
    # Base case: empty tree
    if not root:
        return False
    
    # Leaf node: check if remaining sum equals node value
    if not root.left and not root.right:
        return targetSum == root.val
    
    # Recursive case: check left or right subtree
    # Subtract current value from target
    remaining = targetSum - root.val
    return (hasPathSum(root.left, remaining) or 
            hasPathSum(root.right, remaining))

# Example tree:
#       5
#      / \
#     4   8
#    /   / \
#   11  13  4
#  /  \      \
# 7    2      1
#
# hasPathSum(root, 22) → True (path: 5→4→11→2)
```

### 7.1.2 Path Sum II (All Paths with Sum)

**Problem**: Return all root-to-leaf paths where the sum equals target.

**Approach**: Use backtracking to collect all valid paths.

```python
def pathSum(root, targetSum):
    """
    Time: O(n²) - O(n) to traverse, O(n) to copy path
    Space: O(h) for recursion + O(n) for result storage
    """
    def dfs(node, remaining, path, result):
        if not node:
            return
        
        # Add current node to path
        path.append(node.val)
        
        # Check if leaf node with target sum
        if not node.left and not node.right and remaining == node.val:
            result.append(path[:])  # Copy current path
        
        # Recursively explore children
        dfs(node.left, remaining - node.val, path, result)
        dfs(node.right, remaining - node.val, path, result)
        
        # Backtrack: remove current node
        path.pop()
    
    result = []
    dfs(root, targetSum, [], result)
    return result

# Example:
# Tree from above, targetSum = 22
# Returns: [[5,4,11,2], [5,8,4,5]] if such paths exist
```

### 7.1.3 Sum Root to Leaf Numbers

**Problem**: Each root-to-leaf path represents a number. For example, path 1→2→3 represents 123. Find sum of all such numbers.

```python
def sumNumbers(root):
    """
    Time: O(n)
    Space: O(h)
    """
    def dfs(node, current_number):
        if not node:
            return 0
        
        # Build number: append current digit
        current_number = current_number * 10 + node.val
        
        # If leaf, return the number
        if not node.left and not node.right:
            return current_number
        
        # Sum from both subtrees
        return (dfs(node.left, current_number) + 
                dfs(node.right, current_number))
    
    return dfs(root, 0)

# Example:
#     1
#    / \
#   2   3
# Paths: 1→2 (12) and 1→3 (13)
# Sum: 12 + 13 = 25
```

---

## 7.2 Any-to-Any Path

### Concept
An any-to-any path can start and end at any nodes in the tree. The path doesn't need to pass through the root and can go up and down.

### Key Insight for Any-to-Any Paths

At each node, consider four possibilities:
1. **Path through left child only**: max path in left subtree
2. **Path through right child only**: max path in right subtree
3. **Path through both children**: left_path + node.val + right_path (node is the highest point)
4. **Start fresh from current node**: just node.val

### 7.2.1 Maximum Path Sum

**Problem**: Find the maximum sum of any path in a binary tree. A path can start and end at any nodes.

```python
def maxPathSum(root):
    """
    Time: O(n)
    Space: O(h)
    
    Key insight: At each node, we track TWO things:
    1. max_sum (global): best path sum found so far
    2. return value: best path sum that can be extended upward
    """
    max_sum = float('-inf')
    
    def dfs(node):
        nonlocal max_sum
        
        if not node:
            return 0
        
        # Get max path sum from children
        # Use max(0, ...) to ignore negative paths
        left_max = max(0, dfs(node.left))
        right_max = max(0, dfs(node.right))
        
        # Update global max with path through current node
        # This path uses both children (cannot extend upward)
        current_path_sum = node.val + left_max + right_max
        max_sum = max(max_sum, current_path_sum)
        
        # Return max path that can extend upward
        # Can only use one child path
        return node.val + max(left_max, right_max)
    
    dfs(root)
    return max_sum

# Example:
#      -10
#      /  \
#     9   20
#        /  \
#       15   7
#
# Max path: 15 → 20 → 7 = 42
```

**Why Two Values?**
- **Global max_sum**: Tracks the best path found anywhere (can use both children)
- **Return value**: Best path that includes current node and can be extended by parent (uses only one child)

### Visualization of the Algorithm

```
Tree:        1
           /   \
          2     3
         / \
        4   5

At node 4: return 4 (leaf)
At node 5: return 5 (leaf)
At node 2:
  - left_max = 4
  - right_max = 5
  - current_path_sum = 2 + 4 + 5 = 11 (update global max)
  - return 2 + max(4, 5) = 7 (path extendable upward)
At node 3: return 3
At node 1:
  - left_max = 7 (from subtree rooted at 2)
  - right_max = 3
  - current_path_sum = 1 + 7 + 3 = 11 (update global max)
  - return 1 + max(7, 3) = 8

Answer: 11 (path 4 → 2 → 5)
```

### 7.2.2 Path with Maximum Sum (Alternative Problems)

**Problem Variant**: Find longest path where node values are increasing.

```python
def longestIncreasingPath(root):
    """
    Tracks longest increasing path
    """
    max_length = 0
    
    def dfs(node, parent_val):
        nonlocal max_length
        
        if not node:
            return 0
        
        # Get lengths from children only if values are increasing
        left_len = dfs(node.left, node.val) if node.left and node.left.val > node.val else 0
        right_len = dfs(node.right, node.val) if node.right and node.right.val > node.val else 0
        
        # Update global max (path through current node)
        max_length = max(max_length, left_len + right_len + 1)
        
        # Return length that can extend upward
        return max(left_len, right_len) + 1
    
    dfs(root, float('-inf'))
    return max_length
```

---

## 7.3 Diameter of Binary Tree

### Concept
The diameter is the length of the longest path between any two nodes. This path may or may not pass through the root.

**Length = Number of edges in the path**

### Algorithm

```python
def diameterOfBinaryTree(root):
    """
    Time: O(n)
    Space: O(h)
    
    Key: At each node, diameter passing through it is:
    left_height + right_height
    """
    diameter = 0
    
    def height(node):
        nonlocal diameter
        
        if not node:
            return 0
        
        # Get heights of subtrees
        left_height = height(node.left)
        right_height = height(node.right)
        
        # Update diameter (number of edges)
        diameter = max(diameter, left_height + right_height)
        
        # Return height of current subtree
        return 1 + max(left_height, right_height)
    
    height(root)
    return diameter

# Example:
#       1
#      / \
#     2   3
#    / \
#   4   5
#
# Diameter = 3 (path: 4 → 2 → 1 → 3 or 5 → 2 → 1 → 3)
# This is 3 edges
```

### Why Height Calculation?

The diameter passing through a node = sum of heights of its left and right subtrees.

```
      root
      /  \
    h_l  h_r

Diameter through root = h_l + h_r (edges on both sides)
```

---

## 7.4 Path Sum Patterns with HashMap

### 7.4.1 Path Sum III (Count Paths with Sum K)

**Problem**: Count the number of paths (not necessarily starting from root) that sum to a target value. Paths must go downward.

**Key Insight**: Use prefix sum + HashMap (similar to subarray sum problems)

```python
def pathSum(root, targetSum):
    """
    Time: O(n)
    Space: O(h) for recursion + O(n) for hashmap
    
    Concept: Use prefix sum to find paths
    If prefix_sum[i] - prefix_sum[j] = targetSum,
    then path from j+1 to i has sum = targetSum
    """
    def dfs(node, current_sum):
        if not node:
            return 0
        
        # Update current path sum
        current_sum += node.val
        
        # Count paths ending at current node
        # How many previous prefixes give us the target?
        count = prefix_count.get(current_sum - targetSum, 0)
        
        # Add current prefix sum to map
        prefix_count[current_sum] = prefix_count.get(current_sum, 0) + 1
        
        # Explore children
        count += dfs(node.left, current_sum)
        count += dfs(node.right, current_sum)
        
        # Backtrack: remove current prefix
        prefix_count[current_sum] -= 1
        
        return count
    
    # Initialize with 0 prefix (handles paths from root)
    prefix_count = {0: 1}
    return dfs(root, 0)

# Example:
#       10
#      /  \
#     5   -3
#    / \    \
#   3   2   11
#  / \   \
# 3  -2   1
#
# targetSum = 8
# Paths: [5, 3], [5, 2, 1], [-3, 11]
```

### How Prefix Sum Works

```
Path from root to current node: [10, 5, 3]
Prefix sums: [10, 15, 18]

If targetSum = 8:
- At node with value 3:
  current_sum = 18
  needed = 18 - 8 = 10
  
  If prefix_count[10] exists (it does, at root),
  it means path from after that node to current = 8
  
Path found: 5 → 3 (sum = 8)
```

---

## Summary of Path Problem Patterns

| Problem Type | Technique | Time | Space |
|--------------|-----------|------|-------|
| Root-to-leaf with sum | DFS + subtract | O(n) | O(h) |
| All paths with sum | DFS + backtracking | O(n²) | O(h) |
| Any-to-any max sum | DFS + global variable | O(n) | O(h) |
| Diameter | DFS + height calculation | O(n) | O(h) |
| Count paths with sum | DFS + prefix sum + HashMap | O(n) | O(n) |

---

## Practice Problems

1. **Binary Tree Maximum Path Sum** (LeetCode 124) - Hard
2. **Path Sum III** (LeetCode 437) - Medium
3. **Sum Root to Leaf Numbers** (LeetCode 129) - Medium
4. **Diameter of Binary Tree** (LeetCode 543) - Easy
5. **Longest Univalue Path** (LeetCode 687) - Medium

---

## Key Takeaways

1. **Root-to-leaf paths**: Use simple DFS with accumulation
2. **Any-to-any paths**: Consider path through current node using both children
3. **Use global variables** for tracking maximum/count across all nodes
4. **Return values** should represent extendable paths (only one child used)
5. **Prefix sum technique** is powerful for "count paths with sum" problems
6. **Backtracking** is essential when collecting all paths
