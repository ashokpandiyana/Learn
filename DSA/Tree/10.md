# Chapter 10: Heap / Priority Queue - In-Depth Guide

## Introduction

A **Heap** is a specialized tree-based data structure that satisfies the **heap property**. It's the foundation for implementing **Priority Queues** and is essential for many efficient algorithms.

---

## 10.1 Heap Properties

### Definition

A heap is a **complete binary tree** with the heap property:

- **Max-Heap**: Parent ≥ All children (largest element at root)
- **Min-Heap**: Parent ≤ All children (smallest element at root)

### Complete Binary Tree

A complete binary tree is filled at all levels except possibly the last, which is filled from left to right.

```
Valid Complete Binary Tree:    Invalid (not complete):
         1                              1
       /   \                          /   \
      2     3                        2     3
     / \   /                        /       \
    4   5 6                        4         5

All levels filled left-to-right   Gap in last level
```

### Visualization

```
Max-Heap:                Min-Heap:
       100                       1
      /   \                    /   \
    90    80                  3     2
   / \    / \                / \   / \
  70 60  50 40              8  5  6  4

Property: Parent ≥ Children   Property: Parent ≤ Children
```

**Key Point**: Heaps are **NOT sorted**. Only the parent-child relationship is maintained.

---

## 10.2 Array Representation

Heaps are typically stored in arrays, which provides efficient space usage and easy index calculations.

### Index Formulas (0-based indexing)

```
For node at index i:
- Parent index     = (i - 1) // 2
- Left child index = 2 * i + 1
- Right child index = 2 * i + 2
```

### Example

```
Heap:           100
               /   \
             90    80
            / \    / \
          70 60  50 40

Array: [100, 90, 80, 70, 60, 50, 40]
Index:   0   1   2   3   4   5   6

Relationships:
- Parent of index 4 (60) = (4-1)//2 = 1 → 90 ✓
- Left of index 1 (90) = 2*1+1 = 3 → 70 ✓
- Right of index 1 (90) = 2*1+2 = 4 → 60 ✓
```

### Alternative (1-based indexing)

Some implementations use 1-based for simpler formulas:
```
Parent(i) = i // 2
Left(i) = 2 * i
Right(i) = 2 * i + 1
```

---

## 10.3 Heap Operations

### 10.3.1 Heapify Up (Bubble Up)

Used after **insertion** to restore heap property by moving element upward.

```python
def heapify_up(heap, index):
    """
    Time: O(log n)
    Move element up until heap property is satisfied
    """
    parent = (index - 1) // 2
    
    # For max-heap: keep moving up if current > parent
    while index > 0 and heap[index] > heap[parent]:
        # Swap with parent
        heap[index], heap[parent] = heap[parent], heap[index]
        
        # Move up
        index = parent
        parent = (index - 1) // 2
```

**Visualization**:
```
Insert 95 into max-heap:

Step 1: Add to end        Step 2: Compare with parent
       100                       100
      /   \                     /   \
    90    80                  90    80
   / \    / \                / \    / \
  70 60  50 40             70 60  50 40
            \                       /
            95                    95
Index: 6                  Parent = (6-1)//2 = 2 (80)
                          95 > 80, swap!

Step 3: Continue          Step 4: Stop
       100                       100
      /   \                     /   \
    90    95                  95    90
   / \    / \                / \    / \
  70 60  50 40             70 60  90 80
        /                        /
      80                       50 40
95 > 90? No, stop!        Final heap
```

### 10.3.2 Heapify Down (Bubble Down)

Used after **deletion/extract** to restore heap property by moving element downward.

```python
def heapify_down(heap, index, heap_size):
    """
    Time: O(log n)
    Move element down until heap property is satisfied
    """
    while True:
        largest = index
        left = 2 * index + 1
        right = 2 * index + 2
        
        # Find largest among node, left child, right child
        if left < heap_size and heap[left] > heap[largest]:
            largest = left
        
        if right < heap_size and heap[right] > heap[largest]:
            largest = right
        
        # If largest is not current node, swap and continue
        if largest != index:
            heap[index], heap[largest] = heap[largest], heap[index]
            index = largest
        else:
            break
```

**Visualization**:
```
Extract max (100) from heap:

Step 1: Replace root with last    Step 2: Compare with children
       40                                 90
      /   \                              /   \
    90    80                            40    80
   / \    /                            / \    /
  70 60  50                          70 60  50

40 moved to root                    Max(90, 80) = 90
                                    Swap 40 with 90

Step 3: Continue                    Step 4: Stop
       90                                  90
      /   \                               /   \
    70    80                             70    80
   / \    /                             / \    /
  40 60  50                           60 40  50

Max(70, 60) = 70                    40 has no children or
Swap 40 with 70                     children are smaller. STOP!
```

### 10.3.3 Insert

```python
class MaxHeap:
    def __init__(self):
        self.heap = []
    
    def insert(self, val):
        """
        Time: O(log n)
        Space: O(1)
        """
        # Add to end
        self.heap.append(val)
        
        # Heapify up
        self.heapify_up(len(self.heap) - 1)
    
    def heapify_up(self, index):
        parent = (index - 1) // 2
        
        while index > 0 and self.heap[index] > self.heap[parent]:
            self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index]
            index = parent
            parent = (index - 1) // 2
```

### 10.3.4 Extract Max/Min

```python
def extract_max(self):
    """
    Time: O(log n)
    Returns and removes the maximum element
    """
    if not self.heap:
        return None
    
    if len(self.heap) == 1:
        return self.heap.pop()
    
    # Store max value
    max_val = self.heap[0]
    
    # Move last element to root
    self.heap[0] = self.heap.pop()
    
    # Heapify down
    self.heapify_down(0)
    
    return max_val

def heapify_down(self, index):
    size = len(self.heap)
    
    while True:
        largest = index
        left = 2 * index + 1
        right = 2 * index + 2
        
        if left < size and self.heap[left] > self.heap[largest]:
            largest = left
        
        if right < size and self.heap[right] > self.heap[largest]:
            largest = right
        
        if largest != index:
            self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index]
            index = largest
        else:
            break
```

### 10.3.5 Get Max/Min (Peek)

```python
def get_max(self):
    """
    Time: O(1)
    Returns max without removing
    """
    return self.heap[0] if self.heap else None
```

### 10.3.6 Build Heap

**Key Insight**: Building a heap from an array can be done in **O(n)** time!

```python
def build_heap(arr):
    """
    Time: O(n) - NOT O(n log n)!
    Space: O(1) - in-place
    
    Start from last non-leaf node and heapify down
    """
    n = len(arr)
    
    # Last non-leaf node is at index (n//2 - 1)
    # All nodes after that are leaves
    for i in range(n // 2 - 1, -1, -1):
        heapify_down(arr, i, n)
    
    return arr

# Example:
arr = [3, 9, 2, 1, 4, 5]
build_heap(arr)
# Result: [9, 4, 5, 1, 3, 2] (max-heap)
```

**Why O(n) instead of O(n log n)?**

```
Height analysis:
- n/2 nodes at height 0 (leaves) → 0 operations
- n/4 nodes at height 1 → each needs 1 comparison
- n/8 nodes at height 2 → each needs 2 comparisons
- ...
- 1 node at height log(n) → needs log(n) comparisons

Total: n/2*0 + n/4*1 + n/8*2 + ... ≈ O(n)

Mathematical proof using geometric series shows it's O(n).
```

---

## 10.4 Heap Applications

### 10.4.1 Priority Queue

A priority queue is an abstract data type where elements are served based on priority.

```python
import heapq  # Python's built-in heap (min-heap)

# Min-Heap Priority Queue
pq = []
heapq.heappush(pq, (priority, item))
min_item = heapq.heappop(pq)

# Max-Heap (negate priorities)
pq = []
heapq.heappush(pq, (-priority, item))
max_item = heapq.heappop(pq)
```

### 10.4.2 Heap Sort

```python
def heap_sort(arr):
    """
    Time: O(n log n)
    Space: O(1) - in-place
    
    Steps:
    1. Build max-heap: O(n)
    2. Extract max n times: O(n log n)
    """
    n = len(arr)
    
    # Build max-heap
    for i in range(n // 2 - 1, -1, -1):
        heapify_down(arr, i, n)
    
    # Extract elements one by one
    for i in range(n - 1, 0, -1):
        # Move current root to end
        arr[0], arr[i] = arr[i], arr[0]
        
        # Heapify reduced heap
        heapify_down(arr, 0, i)
    
    return arr

# Example:
arr = [12, 11, 13, 5, 6, 7]
heap_sort(arr)
# Result: [5, 6, 7, 11, 12, 13]
```

### 10.4.3 Kth Largest/Smallest Element

```python
def findKthLargest(nums, k):
    """
    Time: O(n log k)
    Space: O(k)
    
    Use min-heap of size k
    """
    import heapq
    
    heap = []
    
    for num in nums:
        heapq.heappush(heap, num)
        
        # Keep only k largest elements
        if len(heap) > k:
            heapq.heappop(heap)
    
    # Top of heap is kth largest
    return heap[0]

# Example:
nums = [3, 2, 1, 5, 6, 4]
k = 2
print(findKthLargest(nums, k))  # Output: 5
```

### 10.4.4 Merge K Sorted Arrays

```python
def mergeKArrays(arrays):
    """
    Time: O(N log k) where N = total elements, k = number of arrays
    Space: O(k) for heap
    """
    import heapq
    
    result = []
    heap = []
    
    # Initialize heap with first element from each array
    for i, arr in enumerate(arrays):
        if arr:
            heapq.heappush(heap, (arr[0], i, 0))  # (value, array_index, element_index)
    
    while heap:
        val, arr_idx, elem_idx = heapq.heappop(heap)
        result.append(val)
        
        # Add next element from same array
        if elem_idx + 1 < len(arrays[arr_idx]):
            next_val = arrays[arr_idx][elem_idx + 1]
            heapq.heappush(heap, (next_val, arr_idx, elem_idx + 1))
    
    return result

# Example:
arrays = [
    [1, 4, 7],
    [2, 5, 8],
    [3, 6, 9]
]
print(mergeKArrays(arrays))
# Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### 10.4.5 Running Median (Stream of Numbers)

```python
class MedianFinder:
    """
    Use two heaps:
    - max_heap: stores smaller half
    - min_heap: stores larger half
    
    Median is either:
    - Top of max_heap (if odd total)
    - Average of tops (if even total)
    """
    def __init__(self):
        self.max_heap = []  # Stores smaller half (negate for max-heap)
        self.min_heap = []  # Stores larger half
    
    def addNum(self, num):
        """
        Time: O(log n)
        """
        # Add to max_heap first
        heapq.heappush(self.max_heap, -num)
        
        # Balance: ensure max_heap's top ≤ min_heap's top
        if self.max_heap and self.min_heap and \
           -self.max_heap[0] > self.min_heap[0]:
            val = -heapq.heappop(self.max_heap)
            heapq.heappush(self.min_heap, val)
        
        # Balance sizes: max_heap can have at most 1 more element
        if len(self.max_heap) > len(self.min_heap) + 1:
            val = -heapq.heappop(self.max_heap)
            heapq.heappush(self.min_heap, val)
        
        if len(self.min_heap) > len(self.max_heap):
            val = heapq.heappop(self.min_heap)
            heapq.heappush(self.max_heap, -val)
    
    def findMedian(self):
        """
        Time: O(1)
        """
        if len(self.max_heap) > len(self.min_heap):
            return -self.max_heap[0]
        return (-self.max_heap[0] + self.min_heap[0]) / 2

# Example:
mf = MedianFinder()
mf.addNum(1)    # [1]
mf.addNum(2)    # [1, 2]
print(mf.findMedian())  # 1.5
mf.addNum(3)    # [1, 2, 3]
print(mf.findMedian())  # 2
```

### 10.4.6 Top K Frequent Elements

```python
def topKFrequent(nums, k):
    """
    Time: O(n log k)
    Space: O(n)
    """
    from collections import Counter
    import heapq
    
    # Count frequencies
    count = Counter(nums)
    
    # Use min-heap to keep top k
    heap = []
    
    for num, freq in count.items():
        heapq.heappush(heap, (freq, num))
        if len(heap) > k:
            heapq.heappop(heap)
    
    return [num for freq, num in heap]

# Example:
nums = [1, 1, 1, 2, 2, 3]
k = 2
print(topKFrequent(nums, k))  # [1, 2]
```

---

## 10.5 Two-Heap Pattern

The **two-heap pattern** is essential for median-finding and similar problems where you need to maintain a dynamic middle point.

### Key Idea

```
Numbers: [1, 5, 2, 8, 3, 7, 4]

Split into two halves:
Max-Heap (smaller half):  [4, 3, 2, 1]  (top = 4)
Min-Heap (larger half):   [5, 7, 8]     (top = 5)

Median = (4 + 5) / 2 = 4.5

Properties:
1. Max-heap size = Min-heap size OR Max-heap size = Min-heap size + 1
2. All elements in max-heap ≤ all elements in min-heap
```

### Applications

1. **Find Median in Stream**
2. **Sliding Window Median**
3. **Find Median in Sorted Arrays**

---

## 10.6 Complete Heap Implementation

```python
class MaxHeap:
    def __init__(self):
        self.heap = []
    
    def parent(self, i):
        return (i - 1) // 2
    
    def left(self, i):
        return 2 * i + 1
    
    def right(self, i):
        return 2 * i + 2
    
    def insert(self, val):
        """O(log n)"""
        self.heap.append(val)
        self._heapify_up(len(self.heap) - 1)
    
    def extract_max(self):
        """O(log n)"""
        if not self.heap:
            return None
        
        if len(self.heap) == 1:
            return self.heap.pop()
        
        max_val = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._heapify_down(0)
        
        return max_val
    
    def get_max(self):
        """O(1)"""
        return self.heap[0] if self.heap else None
    
    def size(self):
        """O(1)"""
        return len(self.heap)
    
    def _heapify_up(self, i):
        """O(log n)"""
        parent = self.parent(i)
        
        while i > 0 and self.heap[i] > self.heap[parent]:
            self.heap[i], self.heap[parent] = self.heap[parent], self.heap[i]
            i = parent
            parent = self.parent(i)
    
    def _heapify_down(self, i):
        """O(log n)"""
        size = len(self.heap)
        
        while True:
            largest = i
            left = self.left(i)
            right = self.right(i)
            
            if left < size and self.heap[left] > self.heap[largest]:
                largest = left
            
            if right < size and self.heap[right] > self.heap[largest]:
                largest = right
            
            if largest != i:
                self.heap[i], self.heap[largest] = self.heap[largest], self.heap[i]
                i = largest
            else:
                break
```

---

## 10.7 Complexity Summary

| Operation | Time Complexity | Explanation |
|-----------|----------------|-------------|
| **Insert** | O(log n) | Heapify up from leaf to root |
| **Extract Max/Min** | O(log n) | Heapify down from root to leaf |
| **Get Max/Min** | O(1) | Root element |
| **Build Heap** | **O(n)** | Bottom-up heapify |
| **Heap Sort** | O(n log n) | Build + n extractions |
| **Search** | O(n) | No guaranteed order except root |

---

## Practice Problems

### Easy
1. **Kth Largest Element in Array** (LeetCode 215)
2. **Last Stone Weight** (LeetCode 1046)

### Medium
3. **Top K Frequent Elements** (LeetCode 347)
4. **Find Median from Data Stream** (LeetCode 295)
5. **Kth Largest Element in a Stream** (LeetCode 703)
6. **Reorganize String** (LeetCode 767)

### Hard
7. **Merge K Sorted Lists** (LeetCode 23)
8. **Sliding Window Median** (LeetCode 480)
9. **IPO** (LeetCode 502)

---

## Key Takeaways

1. **Heaps guarantee O(log n)** insert and extract operations
2. **Building a heap is O(n)**, not O(n log n)
3. **Complete binary tree** property enables efficient array storage
4. **Two-heap pattern** is essential for median problems
5. **Use min-heap of size k** for "Kth largest" problems
6. **Priority queues** are implemented using heaps
7. **Heap sort** is O(n log n) and in-place but not stable
8. Python's `heapq` provides a **min-heap** by default (negate values for max-heap)
