# Chapter 13: Fenwick Tree (Binary Indexed Tree) - Deep Dive

## What is a Fenwick Tree?

A **Fenwick Tree** (also called **Binary Indexed Tree** or **BIT**) is a data structure that efficiently handles:
- **Prefix sum queries**: O(log n)
- **Point updates**: O(log n)
- **Space**: O(n)

It's simpler and more space-efficient than a Segment Tree for certain operations!

### The Problem

Given an array, perform:
1. Update element at index i
2. Calculate sum from index 0 to i (prefix sum)

**Naive approach:**
- Update: O(1)
- Prefix sum: O(n)

**Prefix sum array:**
- Update: O(n)
- Prefix sum: O(1)

**Fenwick Tree:**
- Update: O(log n) ✅
- Prefix sum: O(log n) ✅

## 13.1 The Magic Behind Fenwick Tree

### Understanding the LSB (Least Significant Bit)

The key insight: Use the binary representation of indices!

```
LSB(i) = i & (-i)  // Isolates the rightmost set bit

Examples:
12 in binary = 1100    -12 in binary = ...0100
12 & (-12) = 4

10 in binary = 1010    -10 in binary = ...0110
10 & (-10) = 2

5 in binary  = 0101    -5 in binary  = ...1011
5 & (-5) = 1
```

### Visual Representation

For array of size 8, tree structure:

```
Index:   1    2    3    4    5    6    7    8
         │    │    │    │    │    │    │    │
BIT:     A[1] │    │    │    │    │    │    │
              └─A[1:2]    │    │    │    │    │
                    └──A[1:3] │    │    │    │
                         └────────A[1:4]    │    │
                                   └──A[1:5] │    │
                                         └─A[1:6] │
                                               └─A[1:7]
                                                  └────A[1:8]
```

Each index is responsible for a range determined by its LSB:
- BIT[1] covers 1 element  (LSB = 1)
- BIT[2] covers 2 elements (LSB = 2)
- BIT[4] covers 4 elements (LSB = 4)
- BIT[8] covers 8 elements (LSB = 8)

### Ranges Covered

```
BIT[1] = A[1]
BIT[2] = A[1] + A[2]
BIT[3] = A[3]
BIT[4] = A[1] + A[2] + A[3] + A[4]
BIT[5] = A[5]
BIT[6] = A[5] + A[6]
BIT[7] = A[7]
BIT[8] = A[1] + A[2] + ... + A[8]
```

## 13.2 Complete Fenwick Tree Implementation

### Basic Implementation

```python
class FenwickTree:
    def __init__(self, n):
        """
        Initialize Fenwick Tree with n elements (1-indexed)
        Time: O(n), Space: O(n)
        """
        self.n = n
        self.tree = [0] * (n + 1)  # 1-indexed
    
    def _lsb(self, i):
        """Get Least Significant Bit"""
        return i & (-i)
    
    def update(self, i, delta):
        """
        Add delta to element at index i (1-indexed)
        Time: O(log n)
        """
        while i <= self.n:
            self.tree[i] += delta
            i += self._lsb(i)  # Move to next responsible index
    
    def prefix_sum(self, i):
        """
        Get sum from index 1 to i (inclusive)
        Time: O(log n)
        """
        total = 0
        while i > 0:
            total += self.tree[i]
            i -= self._lsb(i)  # Move to parent
        return total
    
    def range_sum(self, left, right):
        """
        Get sum from index left to right (inclusive)
        Time: O(log n)
        """
        return self.prefix_sum(right) - self.prefix_sum(left - 1)

# Example usage
bit = FenwickTree(8)
arr = [0, 3, 2, -1, 6, 5, 4, -3, 3]  # 0 at index 0 (unused)

# Build: update each element
for i in range(1, 9):
    bit.update(i, arr[i])

print(bit.prefix_sum(4))    # Sum of first 4 elements
print(bit.range_sum(2, 5))  # Sum from index 2 to 5
bit.update(3, 5)             # Add 5 to element at index 3
print(bit.range_sum(2, 5))  # Updated sum
```

### Alternative: Build in O(n)

```python
class FenwickTreeOptimized:
    def __init__(self, arr):
        """
        Build from array in O(n) instead of O(n log n)
        arr is 0-indexed, internal tree is 1-indexed
        """
        self.n = len(arr)
        self.tree = [0] * (self.n + 1)
        
        # Copy elements to tree (with 1-indexing)
        for i in range(self.n):
            self.tree[i + 1] = arr[i]
        
        # Build tree in O(n)
        for i in range(1, self.n + 1):
            j = i + (i & -i)
            if j <= self.n:
                self.tree[j] += self.tree[i]
    
    def update(self, i, delta):
        """Update 0-indexed position"""
        i += 1  # Convert to 1-indexed
        while i <= self.n:
            self.tree[i] += delta
            i += i & (-i)
    
    def prefix_sum(self, i):
        """Prefix sum up to 0-indexed position i"""
        i += 1  # Convert to 1-indexed
        total = 0
        while i > 0:
            total += self.tree[i]
            i -= i & (-i)
        return total
    
    def range_sum(self, left, right):
        """Range sum [left, right] for 0-indexed positions"""
        if left == 0:
            return self.prefix_sum(right)
        return self.prefix_sum(right) - self.prefix_sum(left - 1)
```

## 13.3 How Update Works

**Updating index 3:**

```
Step by step for update(3, 5):

1. Start at index 3
   LSB(3) = 3 & (-3) = 1
   Add 5 to tree[3]
   Next: 3 + 1 = 4

2. Now at index 4
   LSB(4) = 4 & (-4) = 4
   Add 5 to tree[4]
   Next: 4 + 4 = 8

3. Now at index 8
   LSB(8) = 8 & (-8) = 8
   Add 5 to tree[8]
   Next: 8 + 8 = 16 > n, STOP

Path: 3 → 4 → 8
```

### Visual Update Path

```
Updating index 3:

     8 ← Updated (covers 1-8)
     ↑
     4 ← Updated (covers 1-4)
     ↑
     3 ← Updated (covers 3)
```

## 13.4 How Prefix Sum Works

**Getting prefix sum for index 7:**

```
Step by step for prefix_sum(7):

1. Start at index 7
   LSB(7) = 7 & (-7) = 1
   Add tree[7] to sum
   Next: 7 - 1 = 6

2. Now at index 6
   LSB(6) = 6 & (-6) = 2
   Add tree[6] to sum
   Next: 6 - 2 = 4

3. Now at index 4
   LSB(4) = 4 & (-4) = 4
   Add tree[4] to sum
   Next: 4 - 4 = 0, STOP

Path: 7 → 6 → 4
Result: tree[7] + tree[6] + tree[4]
```

### Visual Query Path

```
Query prefix_sum(7):

     4 ← Include (covers 1-4)
     ↑
     6 ← Include (covers 5-6)
     ↑
     7 ← Include (covers 7)
```

## 13.5 Point Query (Get Single Element)

```python
def get(self, i):
    """
    Get value at index i
    Time: O(log n)
    """
    return self.range_sum(i, i)

# More efficient method if we track original values
def get_efficient(self, i):
    """
    If we maintain original array, O(1)
    """
    return self.original[i]
```

## 13.6 Advanced Operations

### Range Update (Add delta to range)

For range updates, we use **difference array** technique:

```python
class FenwickTreeRangeUpdate:
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)
    
    def range_update(self, left, right, delta):
        """
        Add delta to all elements in [left, right]
        Using difference array trick
        Time: O(log n)
        """
        self.update(left, delta)
        self.update(right + 1, -delta)
    
    def point_query(self, i):
        """
        Get value at index i after all range updates
        Time: O(log n)
        """
        return self.prefix_sum(i)
    
    def update(self, i, delta):
        while i <= self.n:
            self.tree[i] += delta
            i += i & (-i)
    
    def prefix_sum(self, i):
        total = 0
        while i > 0:
            total += self.tree[i]
            i -= i & (-i)
        return total
```

### Finding Kth Element (Binary Search)

```python
def find_kth(self, k):
    """
    Find index where prefix sum equals k
    Useful for: find kth smallest, order statistics
    Time: O(log²n)
    """
    i = 0
    bit = 1
    
    # Find highest power of 2 <= n
    while bit <= self.n:
        bit <<= 1
    bit >>= 1
    
    # Binary search using BIT structure
    while bit > 0:
        if i + bit <= self.n and self.tree[i + bit] < k:
            k -= self.tree[i + bit]
            i += bit
        bit >>= 1
    
    return i + 1
```

## 13.7 2D Fenwick Tree

For 2D range sum queries:

```python
class FenwickTree2D:
    def __init__(self, rows, cols):
        self.rows = rows
        self.cols = cols
        self.tree = [[0] * (cols + 1) for _ in range(rows + 1)]
    
    def update(self, row, col, delta):
        """
        Add delta to position (row, col)
        Time: O(log n * log m)
        """
        i = row
        while i <= self.rows:
            j = col
            while j <= self.cols:
                self.tree[i][j] += delta
                j += j & (-j)
            i += i & (-i)
    
    def prefix_sum(self, row, col):
        """
        Sum of rectangle from (1,1) to (row, col)
        Time: O(log n * log m)
        """
        total = 0
        i = row
        while i > 0:
            j = col
            while j > 0:
                total += self.tree[i][j]
                j -= j & (-j)
            i -= i & (-i)
        return total
    
    def range_sum(self, r1, c1, r2, c2):
        """
        Sum of rectangle from (r1, c1) to (r2, c2)
        Time: O(log n * log m)
        """
        return (self.prefix_sum(r2, c2) 
                - self.prefix_sum(r1 - 1, c2)
                - self.prefix_sum(r2, c1 - 1)
                + self.prefix_sum(r1 - 1, c1 - 1))
```

## 13.8 Fenwick Tree for Other Operations

### XOR Queries

```python
class FenwickTreeXOR:
    """Works because XOR has inverse (a XOR a = 0)"""
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)
    
    def update(self, i, value):
        while i <= self.n:
            self.tree[i] ^= value
            i += i & (-i)
    
    def prefix_xor(self, i):
        result = 0
        while i > 0:
            result ^= self.tree[i]
            i -= i & (-i)
        return result
```

### Frequency Array

```python
class FenwickTreeFrequency:
    """Count occurrences, useful for inversions"""
    def __init__(self, max_val):
        self.n = max_val
        self.tree = [0] * (max_val + 1)
    
    def add(self, value):
        """Increment count of value"""
        i = value
        while i <= self.n:
            self.tree[i] += 1
            i += i & (-i)
    
    def count_less_equal(self, value):
        """Count elements <= value"""
        total = 0
        i = value
        while i > 0:
            total += self.tree[i]
            i -= i & (-i)
        return total
    
    def count_in_range(self, left, right):
        """Count elements in [left, right]"""
        return self.count_less_equal(right) - self.count_less_equal(left - 1)
```

## 13.9 Fenwick vs Segment Tree

| Feature | Fenwick Tree | Segment Tree |
|---------|--------------|--------------|
| **Space** | O(n) | O(4n) |
| **Code Complexity** | Simple | More complex |
| **Point Update** | O(log n) | O(log n) |
| **Range Query** | O(log n) | O(log n) |
| **Range Update** | O(log n)* | O(log n) |
| **Operations** | Sum, XOR (invertible) | Any (min, max, GCD) |
| **Constants** | Better | Slightly worse |

*With difference array trick

### When to use Fenwick Tree:
✅ Need prefix sums or range sums
✅ Operations have inverse (sum, XOR)
✅ Want simpler code
✅ Space is a concern

### When to use Segment Tree:
✅ Need range min/max/GCD
✅ Complex range operations
✅ Need lazy propagation for range updates
✅ 2D range queries with various operations

## 13.10 Applications

### Count Inversions

```python
def count_inversions(arr):
    """
    Count pairs (i,j) where i < j and arr[i] > arr[j]
    Time: O(n log n)
    """
    # Coordinate compression
    sorted_arr = sorted(set(arr))
    rank = {v: i+1 for i, v in enumerate(sorted_arr)}
    
    bit = FenwickTree(len(sorted_arr))
    inversions = 0
    
    for i in range(len(arr) - 1, -1, -1):
        r = rank[arr[i]]
        # Count elements smaller than arr[i] seen so far
        inversions += bit.prefix_sum(r - 1)
        bit.update(r, 1)
    
    return inversions
```

### Range Sum Query - Mutable (Leetcode #307)

```python
class NumArray:
    def __init__(self, nums):
        self.nums = nums
        self.bit = FenwickTreeOptimized(nums)
    
    def update(self, index, val):
        delta = val - self.nums[index]
        self.nums[index] = val
        self.bit.update(index, delta)
    
    def sumRange(self, left, right):
        return self.bit.range_sum(left, right)
```

## 13.11 Common Fenwick Tree Problems

1. **Range Sum Query - Mutable** - Leetcode #307
2. **Count of Smaller Numbers After Self** - Leetcode #315
3. **Reverse Pairs** - Leetcode #493
4. **Count of Range Sum** - Leetcode #327
5. **Range Sum Query 2D - Mutable** - Leetcode #308

## Key Takeaways

✅ **Remember:**
- BIT is 1-indexed (index 0 unused)
- LSB formula: `i & (-i)`
- Update: add LSB, Query: subtract LSB
- Only works for operations with inverse

✅ **Advantages:**
- Simple implementation
- Better space and constants than segment tree
- Elegant and fast

✅ **Limitations:**
- Can't handle min/max efficiently
- Range updates need difference array trick
- Less flexible than segment tree

✅ **Interview Tips:**
- Perfect for range sum problems
- If problem needs min/max, use segment tree
- Remember 1-indexing!
- Practice both 0-indexed and 1-indexed versions
