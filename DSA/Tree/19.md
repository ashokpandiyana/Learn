# Chapter 19: Interview Tips & Tricks - Complete Guide

## Overview
Technical knowledge alone isn't enough. This chapter covers the soft skills, strategies, and mental models that separate good candidates from great ones.

---

## 19.1 Before Coding: The Critical First 5 Minutes

### The Golden Rule
**NEVER start coding immediately**. Spend 3-5 minutes in the planning phase. This investment saves 15-20 minutes of debugging later.

### Step-by-Step Approach

#### Step 1: Clarify the Problem (1-2 minutes)

**Essential Questions**:

```
1. "Is this a binary tree or could it be n-ary?"
2. "Can the tree be empty/null?"
3. "Are there duplicate values?"
4. "If it's a BST, are values unique?"
5. "What should I return for edge cases?"
6. "Any constraints on node values? (negative, range)"
7. "How large can the tree be? (10¬≥, 10‚Å∂, 10‚Åπ nodes)"
8. "Is the tree balanced, or could it be skewed?"
```

**Example Dialogue**:
```
Interviewer: "Find the kth smallest element in a BST."

You: "Great! A few clarifications:
- Are all values unique, or can there be duplicates?
- Is k guaranteed to be valid (1 ‚â§ k ‚â§ n)?
- Should I optimize for multiple queries, or just one?
- Any memory constraints? Can I use O(n) space?

Interviewer: "Yes, values are unique. k is always valid. 
Just one query. O(n) space is fine."

You: "Perfect! Let me think about approaches..."
```

---

#### Step 2: Work Through Examples (1-2 minutes)

**Draw It Out**:
```
Example: Find maximum path sum

    -10
    /  \
   9   20
      /  \
     15   7

Draw and trace:
- Path through 9: 9 only = 9
- Path through 15-20-7: 15+20+7 = 42 ‚úì
- Path through 15-20: 15+20 = 35
```

**Edge Cases to Consider**:
```python
# Always think about:
test_cases = [
    None,                    # Empty tree
    TreeNode(5),            # Single node
    skewed_tree,            # All left or all right
    TreeNode(-10),          # Negative values
    TreeNode(0),            # Zero
    perfect_tree,           # Balanced
]
```

---

#### Step 3: Explain Your Approach (1 minute)

**Structure Your Explanation**:

```
"I'm thinking of using [PATTERN] because [REASON].

The algorithm would:
1. [Step 1]
2. [Step 2]
3. [Step 3]

Time complexity: O(...)
Space complexity: O(...)

Does this approach make sense? Should I code it up?"
```

**Example**:
```
"I'm thinking of using DFS with a HashMap because we need
to track prefix sums for the path sum problem.

The algorithm would:
1. Traverse the tree using DFS
2. Maintain a running sum from root to current node
3. Use HashMap to store prefix sum counts
4. At each node, check if (current_sum - target) exists
5. Backtrack by removing the current sum

Time: O(n) - visit each node once
Space: O(n) - HashMap and recursion stack

Should I implement this?"
```

---

#### Step 4: Discuss Trade-offs (30 seconds)

**Show Depth of Understanding**:

```
"There are two approaches:

Approach 1: Inorder traversal + array
- Simple to implement
- Time: O(n), Space: O(n)
- Good if we need all elements

Approach 2: Controlled inorder with counter
- Stop after finding kth element
- Time: O(k) average, Space: O(h)
- Better if k is small

I'll go with Approach 2 for efficiency."
```

---

## 19.2 Common Mistakes to Avoid

### Mistake 1: Forgetting Null Checks

**Wrong**:
```python
def maxDepth(root):
    # CRASH! What if root is None?
    return 1 + max(maxDepth(root.left), maxDepth(root.right))
```

**Right**:
```python
def maxDepth(root):
    if not root:  # Always check first!
        return 0
    return 1 + max(maxDepth(root.left), maxDepth(root.right))
```

**Pro Tip**: Write the null check as muscle memory for EVERY recursive call.

---

### Mistake 2: Confusing Height vs Depth

```
         1        Depth 0, Height 2
        / \
       2   3      Depth 1, Height 1
      /
     4            Depth 2, Height 0
```

**Definitions**:
- **Depth**: Distance from root (root depth = 0)
- **Height**: Distance to deepest leaf (leaf height = 0)

```python
def depth(node, target, current_depth=0):
    """Depth of a node from root."""
    if not node:
        return -1
    if node == target:
        return current_depth
    
    left = depth(node.left, target, current_depth + 1)
    if left != -1:
        return left
    return depth(node.right, target, current_depth + 1)

def height(node):
    """Height of a node (max path to leaf)."""
    if not node:
        return -1  # Or 0, depending on convention
    return 1 + max(height(node.left), height(node.right))
```

---

### Mistake 3: Wrong Base Case

**Wrong**:
```python
def isValidBST(root):
    if not root:
        return True
    # Only checks immediate children - WRONG!
    return (root.left.val < root.val and 
            root.right.val > root.val)
```

**Right**:
```python
def isValidBST(root):
    def validate(node, min_val, max_val):
        if not node:
            return True
        
        # Check range
        if not (min_val < node.val < max_val):
            return False
        
        # Check subtrees with updated bounds
        return (validate(node.left, min_val, node.val) and
                validate(node.right, node.val, max_val))
    
    return validate(root, float('-inf'), float('-inf'))
```

---

### Mistake 4: Not Considering Skewed Trees

**Problem**: "Your solution times out on test case 1000"

```
Skewed tree (worst case):
1
 \
  2
   \
    3
     \
      ... (n nodes)

Height = n, not log n!
```

**Impact**:
```python
# If your algorithm is O(h):
# Balanced: O(log n) ‚úì
# Skewed: O(n) ‚úó (might TLE)

# Always mention: "For skewed trees, complexity is O(n)"
```

---

### Mistake 5: Mutating Input When Not Allowed

**Wrong**:
```python
def flatten(root):
    """Flatten to linked list - modifies tree."""
    # This is fine if mutation is allowed
    # But ask first!
```

**Better**:
```python
def flatten(root):
    """Ask: Can I modify the original tree?"""
    # If no: Create new nodes
    # If yes: Modify in place
```

---

## 19.3 Optimization Hints (Pattern Recognition)

### Hint 1: "Do this in O(1) space"

**Translation**: Use Morris Traversal

```python
def inorder_morris(root):
    """O(1) space inorder traversal."""
    current = root
    result = []
    
    while current:
        if not current.left:
            result.append(current.val)
            current = current.right
        else:
            # Find predecessor
            pred = current.left
            while pred.right and pred.right != current:
                pred = pred.right
            
            if not pred.right:
                pred.right = current
                current = current.left
            else:
                pred.right = None
                result.append(current.val)
                current = current.right
    
    return result
```

---

### Hint 2: "Optimize for multiple queries"

**Translation**: Precompute / Preprocess

```python
class TreeQueries:
    def __init__(self, root):
        """Preprocessing: O(n) or O(n log n)"""
        self.depth = {}
        self.parent = {}
        self.subtree_size = {}
        
        # Build all maps once
        self._preprocess(root)
    
    def query(self, node):
        """Query: O(1) or O(log n)"""
        return self.depth[node]
```

**Examples**:
- Binary lifting for LCA queries
- Parent map for "distance K" problems
- Depth map for level queries

---

### Hint 3: "Can you do better than O(n)?"

**For BST problems**: Use BST properties!

```python
def search_bst(root, target):
    """
    Generic tree: O(n) - must check all nodes
    BST: O(log n) - eliminate half each time
    """
    while root:
        if target == root.val:
            return root
        elif target < root.val:
            root = root.left   # Eliminate right subtree
        else:
            root = root.right  # Eliminate left subtree
    return None
```

---

### Hint 4: "This is timing out"

**Checklist**:
1. Are you using O(n¬≤) when O(n) exists? ‚Üí Use HashMap
2. Are you recalculating? ‚Üí Memoize
3. Are you using BFS when DFS works? ‚Üí Try DFS
4. Can you prune branches? ‚Üí Add early termination

```python
def hasPathSum(root, target):
    """Optimize by pruning."""
    if not root:
        return False
    
    target -= root.val
    
    # Leaf node - check sum
    if not root.left and not root.right:
        return target == 0
    
    # Early termination if found
    if root.left and hasPathSum(root.left, target):
        return True
    
    return root.right and hasPathSum(root.right, target)
```

---

## 19.4 Pattern Recognition in Interviews

### Quick Decision Tree

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Does problem mention "sorted"       ‚îÇ
‚îÇ or is it a BST?                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
    Yes ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ Use BST properties
           ‚îÇ    (inorder, bounds, binary search)
           ‚îÇ
    No ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Continue...

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Does it involve levels or distance? ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
    Yes ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ Use BFS
           ‚îÇ
    No ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Continue...

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Does answer depend on subtrees?     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
    Yes ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ Use Tree DP (postorder)
           ‚îÇ
    No ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Continue...

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Need to track paths with sum?       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
    Yes ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ Use prefix sum + HashMap
           ‚îÇ
    No ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DFS with state
```

---

### Pattern Matching Table

| Keywords in Problem | Pattern | Example |
|---------------------|---------|---------|
| "sorted order" | Inorder traversal | Kth smallest in BST |
| "level", "depth" | BFS | Right side view |
| "path from root" | DFS with accumulator | Path sum |
| "any path" | Tree DP | Max path sum |
| "distance K" | Parent map + BFS | All nodes distance K |
| "construct tree" | Recursive build | From inorder + preorder |
| "validate" | DFS with bounds | Validate BST |
| "view from side" | BFS + track position | Right/left side view |
| "count of X" | DFS with counter | Count good nodes |
| "serialize" | Preorder/Level order | Save tree to string |

---

## 19.5 Communication During Interview

### The Thinking-Out-Loud Framework

**Good Example**:
```
"Okay, so for this problem I'm thinking...

First, I notice it's a BST, so inorder gives sorted order.
That's useful.

For kth smallest, I could:
1. Do inorder, store in array, return arr[k-1]
   - Simple but uses O(n) space
   
2. Or do inorder but stop after k elements
   - More efficient, only O(h) space
   
I'll go with option 2. Let me code it up..."

[Start coding]

"I'll use a helper function with a counter...
Actually wait, counters in recursion are tricky.
Let me use a nonlocal variable... 

Hmm, or I could use iterative with a stack.
That might be cleaner. Let me do that instead."

[Interviewer sees your thought process]
```

**Bad Example**:
```
"Uh... let me think..."
[30 seconds of silence]
"Okay I'll code now..."
[Codes in silence]
[Makes mistakes, interviewer can't help]
```

---

### Handling Mistakes

**When You Realize Your Bug**:

```
"Oh wait, I see the issue. At line 15, I'm not handling
the case where left child is null. Let me fix that..."

[Fix it clearly]

"There, that should work now. Let me trace through
an example to verify..."
```

**When Interviewer Points Out Bug**:

```
Interviewer: "What happens if the tree is empty?"

You: "Ah, good catch! I need to handle the null case
at the beginning. Let me add that check..."

[Add the fix]

"Thanks for catching that!"
```

---

### Time Management

**45-Minute Interview Timeline**:

```
Minutes 0-5:   Problem understanding + examples
Minutes 5-7:   Discuss approach
Minutes 7-25:  Code solution
Minutes 25-30: Test with examples
Minutes 30-35: Discuss complexity
Minutes 35-40: Optimize or solve follow-up
Minutes 40-45: Questions for interviewer
```

**Red Flags**:
- Still clarifying at minute 10
- Haven't started coding by minute 10
- Still debugging basic syntax at minute 30

---

## 19.6 Testing Your Solution

### The Testing Checklist

```python
def test_solution():
    """Always test these cases:"""
    
    # 1. Null/Empty
    assert solution(None) == expected_empty
    
    # 2. Single node
    root = TreeNode(5)
    assert solution(root) == expected_single
    
    # 3. Two nodes (left child)
    root = TreeNode(5)
    root.left = TreeNode(3)
    assert solution(root) == expected_left
    
    # 4. Two nodes (right child)
    root = TreeNode(5)
    root.right = TreeNode(7)
    assert solution(root) == expected_right
    
    # 5. Skewed tree (worst case)
    root = create_skewed_tree([1,2,3,4,5])
    assert solution(root) == expected_skewed
    
    # 6. Perfect tree (best case)
    root = create_perfect_tree(height=3)
    assert solution(root) == expected_perfect
    
    # 7. Given example
    root = create_from_example()
    assert solution(root) == expected_example
    
    # 8. Edge values
    root = TreeNode(-1000000)  # Min value
    root.right = TreeNode(1000000)  # Max value
    assert solution(root) == expected_edge
```

---

### How to Trace Through Example

**Structured Tracing**:

```
Example: maxDepth([3,9,20,null,null,15,7])

     3
    / \
   9  20
      / \
     15  7

Trace:
maxDepth(3):
  ‚îú‚îÄ maxDepth(9):
  ‚îÇ   ‚îú‚îÄ maxDepth(null) = 0
  ‚îÇ   ‚îú‚îÄ maxDepth(null) = 0
  ‚îÇ   ‚îî‚îÄ return 1 + max(0,0) = 1
  ‚îÇ
  ‚îú‚îÄ maxDepth(20):
  ‚îÇ   ‚îú‚îÄ maxDepth(15):
  ‚îÇ   ‚îÇ   ‚îú‚îÄ maxDepth(null) = 0
  ‚îÇ   ‚îÇ   ‚îú‚îÄ maxDepth(null) = 0
  ‚îÇ   ‚îÇ   ‚îî‚îÄ return 1 + max(0,0) = 1
  ‚îÇ   ‚îÇ
  ‚îÇ   ‚îú‚îÄ maxDepth(7):
  ‚îÇ   ‚îÇ   ‚îú‚îÄ maxDepth(null) = 0
  ‚îÇ   ‚îÇ   ‚îú‚îÄ maxDepth(null) = 0
  ‚îÇ   ‚îÇ   ‚îî‚îÄ return 1 + max(0,0) = 1
  ‚îÇ   ‚îÇ
  ‚îÇ   ‚îî‚îÄ return 1 + max(1,1) = 2
  ‚îÇ
  ‚îî‚îÄ return 1 + max(1,2) = 3 ‚úì
```

---

## 19.7 Follow-Up Questions Framework

### Common Follow-Ups

#### "What if values are negative?"
```python
# Your solution should already handle this!
# If not, discuss the changes needed:

def maxPathSum(root):
    """
    Original handles negatives by taking max with 0.
    No changes needed.
    """
    pass
```

#### "What if tree is very large (10‚Åπ nodes)?"
```python
"""
Considerations:
1. Memory: Can we stream? Use iterative?
2. Time: Is O(n) acceptable? Can we prune?
3. Distributed: Can we parallelize?

For 10‚Åπ nodes:
- Recursion: Stack overflow risk ‚Üí Use iterative
- Memory: O(n) array won't fit ‚Üí Process in chunks
- Time: O(n) is 1 second ‚Üí Acceptable
"""
```

#### "What if there are multiple queries?"
```python
"""
Preprocess the tree:
- Build parent map: O(n)
- Build depth map: O(n)
- Use binary lifting: O(n log n)

Then each query becomes O(1) or O(log n)
"""
```

#### "Can you do this without recursion?"
```python
# Convert to iterative with explicit stack
def iterative_solution(root):
    stack = [(root, initial_state)]
    
    while stack:
        node, state = stack.pop()
        # Process based on state
        # Push children with updated state
```

---

## 19.8 Mental Models for Success

### Model 1: Trees are Recursive by Nature

**Insight**: Almost every tree problem decomposes into:
1. Solve for left subtree
2. Solve for right subtree  
3. Combine at current node

**Application**: When stuck, ask: "What do I need from my children?"

---

### Model 2: Choose Direction First

**Top-Down (Pass info down)**:
- Path constraints
- Accumulated values
- Target sums

**Bottom-Up (Gather info up)**:
- Subtree properties
- Max/min values
- Validation

**Rule**: If you need info from children ‚Üí Bottom-up. If you're passing constraints ‚Üí Top-down.

---

### Model 3: HashMap Unlocks O(n)

**Pattern**: 
```
O(n¬≤) problem ‚Üí Can I use HashMap? ‚Üí O(n) solution
```

**Examples**:
- Construct from traversals
- Path sum with target
- Vertical order traversal

---

## 19.9 Final Checklist

### Before Submitting Code

- [ ] Handles null/empty tree
- [ ] Handles single node
- [ ] Works for skewed tree
- [ ] No off-by-one errors
- [ ] Variable names are clear
- [ ] No undefined variables
- [ ] Base case is correct
- [ ] Tested with given example
- [ ] Complexity discussed

### During Interview

- [ ] Asked clarifying questions
- [ ] Explained approach before coding
- [ ] Thought out loud while coding
- [ ] Wrote clean, readable code
- [ ] Tested solution
- [ ] Discussed optimization
- [ ] Handled follow-ups

---

## 19.10 Common Interview Trees to Practice

### Easy (Warm-up)
1. Maximum Depth
2. Same Tree  
3. Invert Binary Tree
4. Symmetric Tree
5. Merge Two Binary Trees

### Medium (Core Skills)
1. Validate BST
2. Kth Smallest in BST
3. Level Order Traversal
4. Construct from Inorder + Preorder
5. Path Sum II
6. Right Side View
7. Lowest Common Ancestor

### Hard (Advanced)
1. Maximum Path Sum
2. Serialize and Deserialize
3. Binary Tree Cameras
4. Recover BST
5. All Nodes Distance K

---

## 19.11 Day-Before-Interview Checklist

### Topics to Review
- [ ] All three DFS traversals
- [ ] BFS level order
- [ ] BST properties
- [ ] Path problems pattern
- [ ] LCA in tree vs BST
- [ ] Construction from traversals
- [ ] Complexity analysis

### Code to Practice (Write from scratch)
- [ ] Inorder iterative
- [ ] Level order BFS
- [ ] Validate BST
- [ ] Maximum path sum
- [ ] LCA binary tree

### Mental Preparation
- Get good sleep
- Review pattern recognition
- Practice explaining out loud
- Stay calm, think clearly
- Remember: interviewer wants you to succeed!

---

## Summary: Keys to Success

1. **Clarify before coding** - 5 minutes of questions saves 20 minutes of debugging
2. **Think out loud** - Interviewers can't read your mind
3. **Start simple** - Get brute force working, then optimize
4. **Test thoroughly** - Walk through examples, especially edge cases
5. **Know patterns** - Recognize which technique fits the problem
6. **Practice daily** - Consistency beats cramming

**Remember**: Interviews test problem-solving, not memorization. Show your thought process, handle mistakes gracefully, and communicate clearly. You've got this! üöÄ