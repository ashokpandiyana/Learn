# Chapter 5: Lowest Common Ancestor (LCA) - In-Depth Guide

## What is Lowest Common Ancestor?

The **Lowest Common Ancestor (LCA)** of two nodes `p` and `q` in a tree is:
> The lowest (deepest) node that has both `p` and `q` as descendants (where a node can be a descendant of itself).

### Visual Example:

```
           3
         /   \
        5     1
       / \   / \
      6   2 0   8
         / \
        7   4

LCA(5, 1) = 3  (root is the only common ancestor)
LCA(5, 4) = 5  (5 is ancestor of itself and 4)
LCA(6, 7) = 5  (5 is the deepest node containing both)
LCA(6, 2) = 5
LCA(7, 4) = 2
LCA(0, 8) = 1
```

---

## 5.1 LCA in Binary Tree (General Case)

For a **general binary tree** (not BST), we need to search both subtrees.

### Approach: Recursive Search

**Key Insight:**
- If a node finds one target in left subtree and another in right subtree, **that node is the LCA**
- If both targets are in one subtree, the LCA is in that subtree
- The first node that sees both targets is the LCA

### Algorithm Explanation:

```
For each node, ask:
1. Am I one of the target nodes? → Return myself
2. Did my left subtree find a target? → Remember this
3. Did my right subtree find a target? → Remember this
4. If both subtrees found targets → I'm the LCA!
5. Otherwise, pass up whichever target was found
```

### Complete Implementation:

```python
def lowest_common_ancestor(root, p, q):
    """
    Find LCA in binary tree
    
    Time Complexity: O(n) - may visit all nodes
    Space Complexity: O(h) - recursion stack, h = height
    
    Returns: The LCA node or None
    """
    # Base case: empty tree or found one of the targets
    if root is None or root == p or root == q:
        return root
    
    # Search in left and right subtrees
    left = lowest_common_ancestor(root.left, p, q)
    right = lowest_common_ancestor(root.right, p, q)
    
    # Case 1: Both left and right found something
    # This means p and q are in different subtrees
    # Current node is the LCA!
    if left and right:
        return root
    
    # Case 2: Only left subtree found something
    # Both p and q are in left subtree, or only one target found
    # Pass it up
    if left:
        return left
    
    # Case 3: Only right subtree found something
    # Both p and q are in right subtree, or only one target found
    # Pass it up
    if right:
        return right
    
    # Case 4: Nothing found
    return None
```

### Step-by-Step Example:

```
Find LCA(7, 4):

           3
         /   \
        5     1
       / \   / \
      6   2 0   8
         / \
        7   4

Step-by-step recursion:

1. At node 3:
   - Search left (node 5)
   - Search right (node 1)

2. At node 5 (left of 3):
   - Search left (node 6) → returns None
   - Search right (node 2) → returns... (wait for node 2)

3. At node 2 (right of 5):
   - Search left (node 7) → returns 7 (found!)
   - Search right (node 4) → returns 4 (found!)
   - Both non-null → node 2 is LCA!
   - Return 2 to node 5

4. Back at node 5:
   - left = None (from node 6)
   - right = 2 (LCA found in right subtree)
   - Return 2 to node 3

5. At node 1 (right of 3):
   - Search returns None (neither target here)

6. Back at node 3:
   - left = 2 (LCA already found)
   - right = None
   - Return 2 (the LCA)

Answer: Node 2
```

### Alternative Implementation with Path Storage:

```python
def lca_with_paths(root, p, q):
    """
    Find LCA by storing paths from root to each node
    Time: O(n), Space: O(n)
    """
    def find_path(node, target, path):
        """Find path from root to target"""
        if node is None:
            return False
        
        # Add current node to path
        path.append(node)
        
        # Check if current node is target
        if node == target:
            return True
        
        # Search in left and right subtrees
        if (find_path(node.left, target, path) or 
            find_path(node.right, target, path)):
            return True
        
        # Target not found in this path, backtrack
        path.pop()
        return False
    
    # Find paths to both nodes
    path_p = []
    path_q = []
    
    if not find_path(root, p, path_p) or not find_path(root, q, path_q):
        return None
    
    # Find last common node in both paths
    lca = None
    for i in range(min(len(path_p), len(path_q))):
        if path_p[i] == path_q[i]:
            lca = path_p[i]
        else:
            break
    
    return lca
```

---

## 5.2 LCA in Binary Search Tree

In a **BST**, we can use the BST property to optimize!

### Key Insight:
- If both nodes are **smaller** than current → LCA is in **left** subtree
- If both nodes are **larger** than current → LCA is in **right** subtree  
- Otherwise → **current node is the LCA** (split point)

### Why This Works:

```
        20
       /  \
      8    22
     / \
    4   12
       /  \
      10  14

Find LCA(10, 14):
- At 20: 10 < 20 and 14 < 20 → both smaller, go LEFT
- At 8: 10 > 8 and 14 > 8 → both larger, go RIGHT
- At 12: 10 < 12 and 14 > 12 → SPLIT! Node 12 is LCA

Find LCA(4, 12):
- At 20: both < 20 → go LEFT
- At 8: 4 < 8 and 12 > 8 → SPLIT! Node 8 is LCA

Find LCA(8, 12):
- At 20: both < 20 → go LEFT
- At 8: 8 == 8 → Found one target! Node 8 is LCA
```

### Implementation:

```python
def lca_bst(root, p, q):
    """
    Find LCA in BST - Recursive
    
    Time Complexity: O(h) where h = height
    Space Complexity: O(h) for recursion stack
    """
    # Base case
    if root is None:
        return None
    
    # If both nodes are smaller, LCA is in left subtree
    if p.val < root.val and q.val < root.val:
        return lca_bst(root.left, p, q)
    
    # If both nodes are larger, LCA is in right subtree
    if p.val > root.val and q.val > root.val:
        return lca_bst(root.right, p, q)
    
    # Split point found! Current node is LCA
    # This handles three cases:
    # 1. p and q are in different subtrees
    # 2. current node is p (and q is in subtree)
    # 3. current node is q (and p is in subtree)
    return root


def lca_bst_iterative(root, p, q):
    """
    Find LCA in BST - Iterative (BEST for BST!)
    
    Time Complexity: O(h)
    Space Complexity: O(1) - no recursion!
    """
    current = root
    
    while current:
        # Both in left subtree
        if p.val < current.val and q.val < current.val:
            current = current.left
        # Both in right subtree
        elif p.val > current.val and q.val > current.val:
            current = current.right
        else:
            # Found the split point!
            return current
    
    return None
```

### Comparison: Binary Tree vs BST LCA

| Aspect | Binary Tree | BST |
|--------|-------------|-----|
| **Time** | O(n) | O(h) |
| **Space** | O(h) | O(1) iterative |
| **Strategy** | Search both subtrees | Use BST property |
| **Visits** | May visit all nodes | Only path to LCA |

---

## 5.3 LCA with Parent Pointers

If each node has a **parent pointer**, the problem becomes easier!

### Approach: Intersection of Two Linked Lists

```python
class TreeNode:
    def __init__(self, val=0):
        self.val = val
        self.left = None
        self.right = None
        self.parent = None  # Parent pointer

def lca_with_parent(p, q):
    """
    Find LCA when nodes have parent pointers
    
    Strategy: Like finding intersection of two linked lists
    Time: O(h), Space: O(1)
    """
    # Method 1: Using HashSet
    ancestors = set()
    
    # Add all ancestors of p to set
    current = p
    while current:
        ancestors.add(current)
        current = current.parent
    
    # Find first common ancestor from q
    current = q
    while current:
        if current in ancestors:
            return current
        current = current.parent
    
    return None


def lca_with_parent_optimized(p, q):
    """
    Two-pointer approach (like linked list intersection)
    Time: O(h), Space: O(1)
    """
    ptr1, ptr2 = p, q
    
    # Move both pointers up until they meet
    while ptr1 != ptr2:
        # When ptr1 reaches root, start from q
        ptr1 = ptr1.parent if ptr1 else q
        # When ptr2 reaches root, start from p
        ptr2 = ptr2.parent if ptr2 else p
    
    return ptr1
```

### Visual Example:

```
           3
         /   \
        5     1
       / \   / \
      6   2 0   8
         / \
        7   4

Find LCA(7, 4) with parent pointers:

Path from 7 to root: 7 → 2 → 5 → 3
Path from 4 to root: 4 → 2 → 5 → 3

Using HashSet:
1. Store: {7, 2, 5, 3}
2. Check 4 → not in set
3. Check 2 → IN SET! Return 2

Using two pointers:
ptr1: 7 → 2 → 5 → 3 → (wrap to 4) → 2
ptr2: 4 → 2 → 5 → 3 → (wrap to 7) → 2
Both meet at 2!
```

---

## 5.4 Binary Lifting for LCA

**Binary Lifting** is an advanced technique for answering **multiple LCA queries efficiently**.

### Problem:
- Single LCA query: O(h) or O(n)
- But what if we need to answer **Q queries**?
- Naive: O(Q × n) - too slow for large inputs!

### Binary Lifting Solution:
- **Preprocessing**: O(n log n)
- **Per Query**: O(log n)
- **Total for Q queries**: O(n log n + Q log n)

### Core Idea:

Instead of jumping one parent at a time, precompute **2^i-th ancestor** for each node.

```
For each node, store:
parent[node][0] = immediate parent (2^0 = 1 step)
parent[node][1] = parent's parent (2^1 = 2 steps)
parent[node][2] = 4th ancestor (2^2 = 4 steps)
parent[node][3] = 8th ancestor (2^3 = 8 steps)
...
```

### Implementation:

```python
import math

class BinaryLifting:
    def __init__(self, root, n):
        """
        Initialize binary lifting structure
        n = number of nodes in tree
        """
        self.LOG = math.ceil(math.log2(n)) + 1
        
        # parent[node][i] = 2^i-th ancestor of node
        self.parent = {}
        
        # depth[node] = distance from root
        self.depth = {}
        
        # Build the structure
        self._dfs(root, None, 0)
        self._build_ancestors()
    
    def _dfs(self, node, par, d):
        """Build depth and immediate parent"""
        if node is None:
            return
        
        self.depth[node] = d
        self.parent[node] = [None] * self.LOG
        self.parent[node][0] = par  # Immediate parent
        
        self._dfs(node.left, node, d + 1)
        self._dfs(node.right, node, d + 1)
    
    def _build_ancestors(self):
        """Build 2^i-th ancestors using DP"""
        for node in self.parent:
            for i in range(1, self.LOG):
                if self.parent[node][i-1] is not None:
                    # 2^i-th ancestor = 2^(i-1)-th ancestor of 2^(i-1)-th ancestor
                    self.parent[node][i] = self.parent[self.parent[node][i-1]][i-1]
    
    def get_kth_ancestor(self, node, k):
        """Get k-th ancestor of node in O(log k)"""
        if k > self.depth[node]:
            return None
        
        current = node
        
        # Jump using powers of 2
        for i in range(self.LOG):
            if k & (1 << i):  # If i-th bit of k is set
                current = self.parent[current][i]
                if current is None:
                    return None
        
        return current
    
    def lca(self, p, q):
        """
        Find LCA using binary lifting
        Time: O(log n)
        """
        # Make p the deeper node
        if self.depth[p] < self.depth[q]:
            p, q = q, p
        
        # Bring p to same level as q
        diff = self.depth[p] - self.depth[q]
        p = self.get_kth_ancestor(p, diff)
        
        # If q is ancestor of p
        if p == q:
            return p
        
        # Binary search for LCA
        # Jump both nodes up by largest possible power of 2
        # while keeping them in different subtrees
        for i in range(self.LOG - 1, -1, -1):
            if (self.parent[p][i] is not None and 
                self.parent[q][i] is not None and
                self.parent[p][i] != self.parent[q][i]):
                p = self.parent[p][i]
                q = self.parent[q][i]
        
        # Now p and q are children of LCA
        return self.parent[p][0]


# Usage example:
def solve_multiple_lca_queries(root, n, queries):
    """
    Solve multiple LCA queries efficiently
    queries = [(p1, q1), (p2, q2), ...]
    """
    bl = BinaryLifting(root, n)
    
    results = []
    for p, q in queries:
        lca = bl.lca(p, q)
        results.append(lca)
    
    return results
```

### When to Use Binary Lifting:

| Scenario | Best Approach |
|----------|--------------|
| Single LCA query | Regular recursive O(n) |
| Few queries (< 10) | Regular approach |
| Many queries (100+) | Binary Lifting |
| Need k-th ancestor | Binary Lifting |
| Path queries | Binary Lifting + additional DS |

### Visual Example of Binary Lifting:

```
Tree:
        1
       / \
      2   3
     / \
    4   5
   / \
  6   7

Binary Lifting Table:
Node | 2^0 | 2^1 | 2^2
-----|-----|-----|-----
  7  |  4  |  2  |  1
  6  |  4  |  2  |  1
  5  |  2  |  1  | null
  4  |  2  |  1  | null
  3  |  1  | null| null
  2  |  1  | null| null
  1  | null| null| null

Find LCA(6, 7):
1. Both at depth 3, already same level
2. Jump both by 2^1=2: 6→2, 7→2 (same, too far!)
3. Jump both by 2^0=1: 6→4, 7→4 (same, too far!)
4. Don't jump, parent[6][0]=4, parent[7][0]=4
5. LCA = parent of 4 = 2 ❌ Wait, 4 is already LCA!

Correct algorithm:
1. Both at depth 3
2. Check 2^1: parent[6][1]=2, parent[7][1]=2 (same, skip)
3. Check 2^0: parent[6][0]=4, parent[7][0]=4 (same, skip)
4. Since we never jumped, p == q, so 4 is LCA!
```

---

## Advanced LCA Problems

### Problem 1: Distance Between Two Nodes

```python
def find_distance(root, p, q):
    """
    Find distance between two nodes
    Distance = depth(p) + depth(q) - 2*depth(LCA)
    """
    def find_depth(node, target, depth):
        if node is None:
            return -1
        if node == target:
            return depth
        
        left = find_depth(node.left, target, depth + 1)
        if left != -1:
            return left
        
        return find_depth(node.right, target, depth + 1)
    
    lca_node = lowest_common_ancestor(root, p, q)
    
    depth_p = find_depth(root, p, 0)
    depth_q = find_depth(root, q, 0)
    depth_lca = find_depth(root, lca_node, 0)
    
    return depth_p + depth_q - 2 * depth_lca
```

### Problem 2: LCA of Multiple Nodes

```python
def lca_multiple_nodes(root, nodes):
    """
    Find LCA of multiple nodes
    Time: O(n × k) where k = number of nodes to find
    """
    def lca_helper(node):
        if node is None or node in nodes:
            return node
        
        left = lca_helper(node.left)
        right = lca_helper(node.right)
        
        if left and right:
            return node
        
        return left if left else right
    
    return lca_helper(root)
```

---

## Key Takeaways

1. **Binary Tree LCA**: Search both subtrees, O(n) time
2. **BST LCA**: Use BST property, O(h) time, O(1) space possible
3. **Parent Pointers**: Treat as linked list intersection
4. **Binary Lifting**: For multiple queries, preprocess in O(n log n), query in O(log n)
5. **Split Point**: In BST, LCA is where paths to p and q diverge

---

## Practice Problems

- ✅ Lowest Common Ancestor of a Binary Tree
- ✅ Lowest Common Ancestor of a Binary Search Tree  
- ✅ Lowest Common Ancestor of Deepest Leaves
- ✅ Kth Ancestor of a Tree Node (Binary Lifting)
- ✅ Distance Between Two Nodes
- ✅ Smallest Subtree with All Deepest Nodes
- ✅ Maximum Difference Between Node and Ancestor
