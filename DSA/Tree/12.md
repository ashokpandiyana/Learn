# Chapter 12: Segment Tree - Deep Dive

## What is a Segment Tree?

A **Segment Tree** is a binary tree used for storing intervals or segments. It allows querying which segments contain a given point efficiently. It's particularly powerful for **range queries** and **point updates**.

### Problem it Solves

Consider this scenario:
- Array: `[1, 3, 5, 7, 9, 11]`
- Query 1: "What's the sum from index 1 to 4?" → Answer: 3 + 5 + 7 + 9 = 24
- Query 2: "Update index 3 to 10"
- Query 3: "What's the sum from index 2 to 5?" → Answer: 5 + 10 + 9 + 11 = 35

**Naive approach:** Each query takes O(n), each update takes O(1)
**Segment Tree:** Both query and update take O(log n)!

## 12.1 Structure and Representation

### Visual Representation

For array `[1, 3, 5, 7, 9, 11]`:

```
                    [0-5]: 36
                   /          \
            [0-2]: 9          [3-5]: 27
            /      \          /        \
      [0-1]: 4  [2]: 5   [3-4]: 16   [5]: 11
      /    \              /      \
  [0]: 1  [1]: 3     [3]: 7    [4]: 9
```

Each node stores:
- The range it represents [start, end]
- The aggregated value for that range

### Array Representation

```python
# For n elements, we need array of size 4*n (safe allocation)
tree = [0] * (4 * n)

# Node indexing:
# - Parent at index i
# - Left child at 2*i
# - Right child at 2*i + 1
```

## 12.2 Complete Segment Tree Implementation

### Basic Segment Tree (Range Sum)

```python
class SegmentTree:
    def __init__(self, arr):
        """
        Initialize segment tree
        Time: O(n), Space: O(4n) = O(n)
        """
        self.n = len(arr)
        self.arr = arr
        # Allocate memory for segment tree (4*n is safe)
        self.tree = [0] * (4 * self.n)
        
        if self.n > 0:
            self.build(0, 0, self.n - 1)
    
    def build(self, node, start, end):
        """
        Build segment tree recursively
        node: current node index in tree
        start, end: range this node represents
        """
        if start == end:
            # Leaf node - stores single element
            self.tree[node] = self.arr[start]
            return
        
        mid = (start + end) // 2
        left_child = 2 * node + 1
        right_child = 2 * node + 2
        
        # Build left and right subtrees
        self.build(left_child, start, mid)
        self.build(right_child, mid + 1, end)
        
        # Internal node stores sum of children
        self.tree[node] = self.tree[left_child] + self.tree[right_child]
    
    def update(self, idx, value):
        """
        Update value at index idx
        Time: O(log n)
        """
        self._update(0, 0, self.n - 1, idx, value)
    
    def _update(self, node, start, end, idx, value):
        """Helper function for update"""
        if start == end:
            # Reached the leaf node
            self.arr[idx] = value
            self.tree[node] = value
            return
        
        mid = (start + end) // 2
        left_child = 2 * node + 1
        right_child = 2 * node + 2
        
        if idx <= mid:
            # Update left subtree
            self._update(left_child, start, mid, idx, value)
        else:
            # Update right subtree
            self._update(right_child, mid + 1, end, idx, value)
        
        # Update current node
        self.tree[node] = self.tree[left_child] + self.tree[right_child]
    
    def query(self, left, right):
        """
        Query sum in range [left, right]
        Time: O(log n)
        """
        return self._query(0, 0, self.n - 1, left, right)
    
    def _query(self, node, start, end, left, right):
        """Helper function for range query"""
        # Three cases:
        
        # Case 1: No overlap
        if right < start or left > end:
            return 0
        
        # Case 2: Complete overlap - return this node's value
        if left <= start and end <= right:
            return self.tree[node]
        
        # Case 3: Partial overlap - check both children
        mid = (start + end) // 2
        left_child = 2 * node + 1
        right_child = 2 * node + 2
        
        left_sum = self._query(left_child, start, mid, left, right)
        right_sum = self._query(right_child, mid + 1, end, left, right)
        
        return left_sum + right_sum

# Example usage
arr = [1, 3, 5, 7, 9, 11]
seg_tree = SegmentTree(arr)

print(seg_tree.query(1, 4))  # Sum from index 1 to 4 → 24
seg_tree.update(3, 10)       # Update index 3 to 10
print(seg_tree.query(2, 5))  # Sum from index 2 to 5 → 35
```

### Visualization of Query Process

For query(2, 4) on range [0, 5]:

```
                [0-5]
              /       \
        [0-2]           [3-5]  ← Partial overlap
       /     \          /    \
   [0-1]   [2]✓    [3-4]✓   [5]  ← Complete overlap (✓)
```

Only visit necessary nodes → O(log n)

## 12.3 Segment Tree for Different Operations

### Range Minimum Query (RMQ)

```python
class SegmentTreeMin:
    def __init__(self, arr):
        self.n = len(arr)
        self.arr = arr
        self.tree = [float('inf')] * (4 * self.n)
        if self.n > 0:
            self.build(0, 0, self.n - 1)
    
    def build(self, node, start, end):
        if start == end:
            self.tree[node] = self.arr[start]
            return
        
        mid = (start + end) // 2
        self.build(2*node+1, start, mid)
        self.build(2*node+2, mid+1, end)
        
        # Store minimum instead of sum
        self.tree[node] = min(self.tree[2*node+1], self.tree[2*node+2])
    
    def query(self, left, right):
        return self._query(0, 0, self.n-1, left, right)
    
    def _query(self, node, start, end, left, right):
        if right < start or left > end:
            return float('inf')  # Return "identity" for min
        
        if left <= start and end <= right:
            return self.tree[node]
        
        mid = (start + end) // 2
        left_min = self._query(2*node+1, start, mid, left, right)
        right_min = self._query(2*node+2, mid+1, end, left, right)
        
        return min(left_min, right_min)
```

### Range GCD Query

```python
import math

class SegmentTreeGCD:
    def __init__(self, arr):
        self.n = len(arr)
        self.arr = arr
        self.tree = [0] * (4 * self.n)
        if self.n > 0:
            self.build(0, 0, self.n - 1)
    
    def build(self, node, start, end):
        if start == end:
            self.tree[node] = self.arr[start]
            return
        
        mid = (start + end) // 2
        self.build(2*node+1, start, mid)
        self.build(2*node+2, mid+1, end)
        
        # Store GCD
        self.tree[node] = math.gcd(self.tree[2*node+1], self.tree[2*node+2])
```

## 12.4 Lazy Propagation

**Problem:** What if we need to update a range instead of a single element?

Without optimization: O(n) per update
With **Lazy Propagation**: O(log n) per update!

### Concept

Instead of updating all nodes immediately:
1. Mark nodes as "lazy" (pending update)
2. Only propagate updates when needed during queries
3. "Lazy" nodes pass updates to children when visited

### Implementation with Lazy Propagation

```python
class SegmentTreeLazy:
    def __init__(self, arr):
        self.n = len(arr)
        self.arr = arr
        self.tree = [0] * (4 * self.n)
        self.lazy = [0] * (4 * self.n)  # Lazy array
        
        if self.n > 0:
            self.build(0, 0, self.n - 1)
    
    def build(self, node, start, end):
        if start == end:
            self.tree[node] = self.arr[start]
            return
        
        mid = (start + end) // 2
        self.build(2*node+1, start, mid)
        self.build(2*node+2, mid+1, end)
        self.tree[node] = self.tree[2*node+1] + self.tree[2*node+2]
    
    def _push_down(self, node, start, end):
        """Push lazy value to children"""
        if self.lazy[node] != 0:
            # Apply pending update to current node
            range_length = end - start + 1
            self.tree[node] += self.lazy[node] * range_length
            
            # If not leaf, propagate to children
            if start != end:
                self.lazy[2*node+1] += self.lazy[node]
                self.lazy[2*node+2] += self.lazy[node]
            
            # Clear lazy value
            self.lazy[node] = 0
    
    def range_update(self, left, right, value):
        """
        Add 'value' to all elements in range [left, right]
        Time: O(log n)
        """
        self._range_update(0, 0, self.n-1, left, right, value)
    
    def _range_update(self, node, start, end, left, right, value):
        # Push pending updates first
        self._push_down(node, start, end)
        
        # No overlap
        if right < start or left > end:
            return
        
        # Complete overlap - mark as lazy
        if left <= start and end <= right:
            self.lazy[node] += value
            self._push_down(node, start, end)
            return
        
        # Partial overlap - recurse
        mid = (start + end) // 2
        self._range_update(2*node+1, start, mid, left, right, value)
        self._range_update(2*node+2, mid+1, end, left, right, value)
        
        # Push down children before using their values
        self._push_down(2*node+1, start, mid)
        self._push_down(2*node+2, mid+1, end)
        
        # Update current node
        self.tree[node] = self.tree[2*node+1] + self.tree[2*node+2]
    
    def query(self, left, right):
        """Query with lazy propagation"""
        return self._query(0, 0, self.n-1, left, right)
    
    def _query(self, node, start, end, left, right):
        # Push pending updates
        self._push_down(node, start, end)
        
        # No overlap
        if right < start or left > end:
            return 0
        
        # Complete overlap
        if left <= start and end <= right:
            return self.tree[node]
        
        # Partial overlap
        mid = (start + end) // 2
        left_sum = self._query(2*node+1, start, mid, left, right)
        right_sum = self._query(2*node+2, mid+1, end, left, right)
        
        return left_sum + right_sum

# Example usage
arr = [1, 3, 5, 7, 9, 11]
seg_tree_lazy = SegmentTreeLazy(arr)

# Add 10 to all elements from index 1 to 3
seg_tree_lazy.range_update(1, 3, 10)
print(seg_tree_lazy.query(0, 5))  # Sum of entire array
print(seg_tree_lazy.query(1, 3))  # Sum of updated range
```

## 12.5 Advanced Applications

### Finding Number of Elements Less Than X in Range

```python
class SegmentTreeCountLess:
    """Count elements less than X in range [L, R]"""
    
    def __init__(self, arr):
        self.n = len(arr)
        self.arr = arr
        # Each node stores a sorted list of elements in its range
        self.tree = [[] for _ in range(4 * self.n)]
        if self.n > 0:
            self.build(0, 0, self.n - 1)
    
    def build(self, node, start, end):
        if start == end:
            self.tree[node] = [self.arr[start]]
            return
        
        mid = (start + end) // 2
        self.build(2*node+1, start, mid)
        self.build(2*node+2, mid+1, end)
        
        # Merge sorted lists from children
        self.tree[node] = sorted(self.tree[2*node+1] + self.tree[2*node+2])
    
    def count_less(self, left, right, value):
        """Count elements < value in range [left, right]"""
        return self._count_less(0, 0, self.n-1, left, right, value)
    
    def _count_less(self, node, start, end, left, right, value):
        if right < start or left > end:
            return 0
        
        if left <= start and end <= right:
            # Binary search in sorted list
            import bisect
            return bisect.bisect_left(self.tree[node], value)
        
        mid = (start + end) // 2
        return (self._count_less(2*node+1, start, mid, left, right, value) +
                self._count_less(2*node+2, mid+1, end, left, right, value))
```

## 12.6 Time and Space Complexity

| Operation | Without Lazy | With Lazy |
|-----------|--------------|-----------|
| Build | O(n) | O(n) |
| Point Update | O(log n) | O(log n) |
| Range Update | O(n) | O(log n) |
| Range Query | O(log n) | O(log n) |
| Space | O(4n) = O(n) | O(4n) = O(n) |

## 12.7 When to Use Segment Tree?

✅ **Use Segment Tree when:**
- Multiple range queries needed
- Range updates (with lazy propagation)
- Operations are associative (sum, min, max, GCD, XOR)
- Need O(log n) query and update

❌ **Don't use when:**
- Only prefix queries (use prefix sum array)
- Only point updates with single query (simple array)
- Operations not associative
- Need O(1) query (use preprocessing)

## Common Segment Tree Problems

1. **Range Sum Query - Mutable** - Leetcode #307
2. **Count of Smaller Numbers After Self** - Leetcode #315
3. **Range Sum Query 2D - Mutable** - Leetcode #308
4. **The Skyline Problem** - Leetcode #218
5. **Falling Squares** - Leetcode #699

## Key Takeaways

✅ **Remember:**
- Array size = 4n (safe allocation)
- Node indexing: parent at i, children at 2i+1 and 2i+2
- Three query cases: no overlap, complete overlap, partial overlap
- Lazy propagation essential for range updates

✅ **Interview Tips:**
- Always clarify: point or range updates?
- If only point updates, standard segment tree
- If range updates, use lazy propagation
- Consider if simpler solutions exist (prefix sum, sparse table)
