# Chapter 3: Heap Implementation Patterns
## Mastering Python's heapq and Beyond

---

# 3.1 Python's heapq Module

Python provides a built-in heap implementation through the `heapq` module. Understanding it deeply is essential for interviews.

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                     HEAPQ KEY FACTS                                       ║
╠═══════════════════════════════════════════════════════════════════════════╣
║  • MIN-HEAP ONLY (no built-in max-heap)                                   ║
║  • Operates on regular Python lists                                       ║
║  • 0-indexed                                                              ║
║  • Does NOT create a heap object - transforms list in-place               ║
║  • Uses < operator for comparison                                         ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 3.1.1 All heapq Functions

```python
import heapq

# ═══════════════════════════════════════════════════════════════
# CORE FUNCTIONS
# ═══════════════════════════════════════════════════════════════

# 1. heappush(heap, item) - Add item to heap
#    Time: O(log n)
heap = []
heapq.heappush(heap, 5)
heapq.heappush(heap, 3)
heapq.heappush(heap, 7)
print(heap)  # [3, 5, 7]

# 2. heappop(heap) - Remove and return smallest
#    Time: O(log n)
smallest = heapq.heappop(heap)
print(smallest)  # 3
print(heap)      # [5, 7]

# 3. heapify(list) - Convert list to heap IN-PLACE
#    Time: O(n)
arr = [40, 10, 30, 20, 50]
heapq.heapify(arr)
print(arr)  # [10, 20, 30, 40, 50]

# 4. heap[0] - Peek at smallest without removing
#    Time: O(1)
print(heap[0])  # 5

# ═══════════════════════════════════════════════════════════════
# OPTIMIZED COMBINATION FUNCTIONS
# ═══════════════════════════════════════════════════════════════

# 5. heappushpop(heap, item) - Push then pop (more efficient)
#    Time: O(log n)
#    Equivalent to: push(item); return pop()
#    But faster because it avoids one heapify operation
heap = [1, 3, 5]
result = heapq.heappushpop(heap, 2)
print(result)  # 1 (pushed 2, then popped smallest which is 1)
print(heap)    # [2, 3, 5]

# 6. heapreplace(heap, item) - Pop then push (more efficient)
#    Time: O(log n)
#    Equivalent to: val = pop(); push(item); return val
#    ⚠️ Raises IndexError if heap is empty
heap = [1, 3, 5]
result = heapq.heapreplace(heap, 10)
print(result)  # 1 (popped 1, then pushed 10)
print(heap)    # [3, 5, 10]

# ═══════════════════════════════════════════════════════════════
# TOP K FUNCTIONS
# ═══════════════════════════════════════════════════════════════

# 7. nlargest(k, iterable, key=None) - Return k largest elements
#    Time: O(n log k) for small k, O(n log n) for large k
data = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
print(heapq.nlargest(3, data))   # [9, 6, 5]

# 8. nsmallest(k, iterable, key=None) - Return k smallest elements
#    Time: O(n log k) for small k
print(heapq.nsmallest(3, data))  # [1, 1, 2]

# With key function:
words = ['apple', 'pie', 'strawberry', 'cake']
print(heapq.nsmallest(2, words, key=len))  # ['pie', 'cake']
```

## 3.1.2 heappushpop vs heapreplace

```
╔═══════════════════════════════════════════════════════════════════════════╗
║              heappushpop vs heapreplace                                   ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  heappushpop(heap, item)          heapreplace(heap, item)                ║
║  ─────────────────────────        ───────────────────────                 ║
║  1. Push item                     1. Pop smallest                         ║
║  2. Pop smallest                  2. Push item                            ║
║                                                                           ║
║  Returns: min(item, heap[0])      Returns: old heap[0]                    ║
║                                                                           ║
║  Example:                         Example:                                ║
║  heap = [1, 3, 5]                 heap = [1, 3, 5]                        ║
║  heappushpop(heap, 0)             heapreplace(heap, 0)                    ║
║  → returns 0                      → returns 1                             ║
║  → heap = [1, 3, 5]               → heap = [0, 3, 5]                      ║
║                                                                           ║
║  Use Case:                        Use Case:                               ║
║  When you want to add but         When you want to replace root           ║
║  maintain size (Top K problems)   with new element                        ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

```python
# Practical Example: Maintaining Top K largest elements

def top_k_largest_pushpop(stream, k):
    """Using heappushpop - more efficient"""
    heap = []
    for num in stream:
        if len(heap) < k:
            heapq.heappush(heap, num)
        else:
            heapq.heappushpop(heap, num)  # Push then pop smallest
    return heap

# If num is smaller than heap[0], heappushpop returns num immediately
# (doesn't actually modify the heap - optimization!)
```

---

# 3.2 Max-Heap in Python

Since Python's heapq only supports min-heap, we need workarounds for max-heap functionality.

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    MAX-HEAP STRATEGIES                                    ║
╠═══════════════════════════════════════════════════════════════════════════╣
║  1. Negate Values         - Simple, works for numbers                     ║
║  2. Negate in Tuples      - When storing (priority, data) pairs           ║
║  3. Custom Wrapper Class  - Most flexible, works for any comparison       ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 3.2.1 Strategy 1: Negate Values

```python
import heapq

# ═══════════════════════════════════════════════════════════════
# MAX-HEAP BY NEGATION
# ═══════════════════════════════════════════════════════════════

class MaxHeap:
    """Max-heap using negation trick"""
    
    def __init__(self):
        self.heap = []
    
    def push(self, val):
        heapq.heappush(self.heap, -val)  # Negate on insert
    
    def pop(self):
        return -heapq.heappop(self.heap)  # Negate on extract
    
    def peek(self):
        return -self.heap[0]  # Negate on peek
    
    def __len__(self):
        return len(self.heap)

# Usage:
max_heap = MaxHeap()
max_heap.push(5)
max_heap.push(10)
max_heap.push(3)

print(max_heap.peek())  # 10 (maximum)
print(max_heap.pop())   # 10
print(max_heap.pop())   # 5
print(max_heap.pop())   # 3
```

```
VISUALIZATION: How Negation Works

Original values: [5, 10, 3]
Stored as:      [-5, -10, -3]

Min-heap of negated values:
         -10      ← Smallest negated = Largest original
        /    \
      -5     -3

When we pop:
  • heappop returns -10
  • We negate: -(-10) = 10 ✓
```

## 3.2.2 Strategy 2: Negate in Tuples

When storing (priority, data) pairs:

```python
import heapq

# ═══════════════════════════════════════════════════════════════
# MAX-HEAP WITH TUPLE DATA
# ═══════════════════════════════════════════════════════════════

# Example: Task scheduler with priorities
tasks = [
    (3, "Low priority task"),
    (10, "High priority task"),
    (5, "Medium priority task")
]

# Create max-heap by negating priorities
max_heap = [(-priority, task) for priority, task in tasks]
heapq.heapify(max_heap)

# Process in priority order (highest first)
while max_heap:
    neg_priority, task = heapq.heappop(max_heap)
    priority = -neg_priority
    print(f"Priority {priority}: {task}")

# Output:
# Priority 10: High priority task
# Priority 5: Medium priority task
# Priority 3: Low priority task
```

## 3.2.3 Strategy 3: Custom Wrapper Class

Most flexible approach, works for any comparison logic:

```python
import heapq
from functools import total_ordering

# ═══════════════════════════════════════════════════════════════
# CUSTOM WRAPPER FOR MAX-HEAP
# ═══════════════════════════════════════════════════════════════

@total_ordering
class MaxHeapItem:
    """Wrapper that reverses comparison for max-heap behavior"""
    
    def __init__(self, val):
        self.val = val
    
    def __lt__(self, other):
        # REVERSE the comparison!
        return self.val > other.val
    
    def __eq__(self, other):
        return self.val == other.val
    
    def __repr__(self):
        return f"MaxHeapItem({self.val})"

# Usage:
heap = []
heapq.heappush(heap, MaxHeapItem(5))
heapq.heappush(heap, MaxHeapItem(10))
heapq.heappush(heap, MaxHeapItem(3))

print(heapq.heappop(heap).val)  # 10 (maximum!)
print(heapq.heappop(heap).val)  # 5
print(heapq.heappop(heap).val)  # 3
```

### Why It Works:

```
╔═══════════════════════════════════════════════════════════════════════════╗
║  Python's heapq uses < operator for comparisons                           ║
║                                                                           ║
║  Normal:  5 < 10 is True   → 5 goes above 10 in min-heap                 ║
║  Wrapper: 5 < 10 becomes 5 > 10 which is False                           ║
║           So 10 is considered "smaller" and goes to top!                  ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

---

# 3.3 Custom Comparators

## 3.3.1 Using Tuples for Multi-Level Sorting

Python compares tuples element by element, making this perfect for complex ordering:

```python
import heapq

# ═══════════════════════════════════════════════════════════════
# MULTI-LEVEL SORTING WITH TUPLES
# ═══════════════════════════════════════════════════════════════

# Example: Process tasks by (priority, arrival_time)
# Lower priority number = higher priority
# Earlier arrival = process first (tiebreaker)

tasks = [
    (2, 100, "Task A"),  # priority=2, arrived at 100
    (1, 200, "Task B"),  # priority=1, arrived at 200
    (2, 50, "Task C"),   # priority=2, arrived at 50 (before A)
    (1, 150, "Task D"),  # priority=1, arrived at 150
]

heap = tasks.copy()
heapq.heapify(heap)

while heap:
    priority, arrival, name = heapq.heappop(heap)
    print(f"{name}: priority={priority}, arrival={arrival}")

# Output:
# Task D: priority=1, arrival=150   (priority 1, earlier arrival)
# Task B: priority=1, arrival=200   (priority 1, later arrival)
# Task C: priority=2, arrival=50    (priority 2, earlier arrival)
# Task A: priority=2, arrival=100   (priority 2, later arrival)
```

## 3.3.2 Handling Incomparable Objects

```
╔═══════════════════════════════════════════════════════════════════════════╗
║  PROBLEM: What if data items aren't comparable?                           ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  heap = [(1, "hello"), (1, "world")]                                      ║
║  heapq.heappush(heap, (1, "test"))                                        ║
║                                                                           ║
║  If priorities are equal (1 == 1), Python tries to compare strings.      ║
║  This works for strings, but fails for custom objects!                    ║
║                                                                           ║
║  class Task:                                                              ║
║      pass                                                                 ║
║                                                                           ║
║  heap = [(1, Task()), (1, Task())]  # ERROR on comparison!               ║
║                                                                           ║
║  SOLUTION: Use a tiebreaker (insertion counter)                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

```python
import heapq
from dataclasses import dataclass, field
from typing import Any

# ═══════════════════════════════════════════════════════════════
# PATTERN: USING INSERTION ORDER AS TIEBREAKER
# ═══════════════════════════════════════════════════════════════

class PriorityQueue:
    """
    Priority queue with support for incomparable items.
    Uses insertion order as tiebreaker.
    """
    
    def __init__(self):
        self.heap = []
        self.counter = 0  # Unique sequence number
    
    def push(self, item, priority):
        # Tuple: (priority, counter, item)
        # Counter ensures unique ordering when priorities are equal
        entry = (priority, self.counter, item)
        heapq.heappush(self.heap, entry)
        self.counter += 1
    
    def pop(self):
        if not self.heap:
            raise IndexError("Queue is empty")
        priority, counter, item = heapq.heappop(self.heap)
        return item
    
    def peek(self):
        if not self.heap:
            raise IndexError("Queue is empty")
        return self.heap[0][2]  # Return the item
    
    def __len__(self):
        return len(self.heap)

# Usage with incomparable objects:
class Task:
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return f"Task({self.name})"

pq = PriorityQueue()
pq.push(Task("Email"), 2)
pq.push(Task("Meeting"), 1)
pq.push(Task("Lunch"), 2)  # Same priority as Email!

print(pq.pop())  # Task(Meeting) - priority 1
print(pq.pop())  # Task(Email) - priority 2, inserted first
print(pq.pop())  # Task(Lunch) - priority 2, inserted second
```

```
VISUALIZATION: Why Tiebreaker Works

Without tiebreaker:
  heap = [(2, Task), (2, Task)]
  Comparison: 2 == 2, so compare Task < Task → ERROR!

With tiebreaker:
  heap = [(2, 0, Task), (2, 1, Task)]
  Comparison: 2 == 2, so compare 0 < 1 → True ✓
  (Never reaches Task comparison!)
```

## 3.3.3 Using dataclass for Heap Items

```python
from dataclasses import dataclass, field
from typing import Any

# ═══════════════════════════════════════════════════════════════
# ELEGANT SOLUTION USING DATACLASS
# ═══════════════════════════════════════════════════════════════

@dataclass(order=True)
class PrioritizedItem:
    priority: int
    counter: int = field(compare=False, default=0)  # Not used in comparison
    item: Any = field(compare=False)                 # Not used in comparison

# Usage:
counter = 0
heap = []

def push(item, priority):
    global counter
    entry = PrioritizedItem(priority, counter, item)
    heapq.heappush(heap, entry)
    counter += 1

def pop():
    return heapq.heappop(heap).item

push({"task": "Meeting"}, 1)
push({"task": "Email"}, 2)
push({"task": "Report"}, 1)

print(pop())  # {'task': 'Meeting'}
print(pop())  # {'task': 'Report'}
print(pop())  # {'task': 'Email'}
```

---

# 3.4 Advanced: Custom Comparison Function

When you need completely custom comparison logic:

```python
import heapq
from functools import cmp_to_key

# ═══════════════════════════════════════════════════════════════
# CUSTOM COMPARISON FOR COMPLEX SORTING
# ═══════════════════════════════════════════════════════════════

# Example: Sort by frequency descending, then alphabetically ascending

def compare(item1, item2):
    freq1, char1 = item1
    freq2, char2 = item2
    
    # Higher frequency first (descending)
    if freq1 != freq2:
        return freq2 - freq1  # Positive means item1 goes after item2
    
    # Same frequency: alphabetical order (ascending)
    if char1 < char2:
        return -1
    elif char1 > char2:
        return 1
    return 0

# For nlargest/nsmallest, we can use key function
data = [(5, 'a'), (5, 'b'), (3, 'c'), (10, 'd')]

# But heappush doesn't support custom comparator directly
# Solution: Create wrapper class

class CustomOrder:
    def __init__(self, item):
        self.item = item
    
    def __lt__(self, other):
        # Higher frequency is "less" (for min-heap to act as max-heap on freq)
        # For same frequency, earlier letter is "less"
        freq1, char1 = self.item
        freq2, char2 = other.item
        
        if freq1 != freq2:
            return freq1 > freq2  # Higher freq = higher priority
        return char1 < char2      # Earlier letter = higher priority

heap = [CustomOrder(item) for item in data]
heapq.heapify(heap)

while heap:
    item = heapq.heappop(heap).item
    print(item)
# Output: (10, 'd'), (5, 'a'), (5, 'b'), (3, 'c')
```

---

# 3.5 Heap with Update/Remove Operations

Standard heaps don't support efficient update or remove by value. Here's how to handle it:

## 3.5.1 Lazy Deletion Pattern

```python
import heapq
from collections import defaultdict

# ═══════════════════════════════════════════════════════════════
# LAZY DELETION PATTERN
# ═══════════════════════════════════════════════════════════════

class LazyHeap:
    """
    Min-heap with O(log n) lazy deletion.
    
    Instead of removing elements immediately, we mark them as deleted
    and skip them during pop operations.
    
    Use case: Sliding window problems, dynamic median
    """
    
    def __init__(self):
        self.heap = []
        self.deleted = defaultdict(int)  # Track deleted elements count
        self.size = 0
    
    def push(self, val):
        heapq.heappush(self.heap, val)
        self.size += 1
    
    def pop(self):
        self._clean_top()
        if not self.heap:
            raise IndexError("Heap is empty")
        self.size -= 1
        return heapq.heappop(self.heap)
    
    def peek(self):
        self._clean_top()
        if not self.heap:
            raise IndexError("Heap is empty")
        return self.heap[0]
    
    def remove(self, val):
        """Mark element for deletion - O(1)"""
        self.deleted[val] += 1
        self.size -= 1
    
    def _clean_top(self):
        """Remove all deleted elements from top"""
        while self.heap and self.deleted[self.heap[0]] > 0:
            self.deleted[self.heap[0]] -= 1
            heapq.heappop(self.heap)
    
    def __len__(self):
        return self.size

# Usage Example:
lazy_heap = LazyHeap()
lazy_heap.push(5)
lazy_heap.push(3)
lazy_heap.push(7)
lazy_heap.push(1)

print(lazy_heap.peek())  # 1

lazy_heap.remove(1)      # Mark 1 for deletion
print(lazy_heap.peek())  # 3 (1 is cleaned during peek)

lazy_heap.remove(3)
print(lazy_heap.pop())   # 5
print(lazy_heap.pop())   # 7
```

```
VISUALIZATION: Lazy Deletion

Initial: heap = [1, 3, 5, 7]
         deleted = {}

remove(1): heap = [1, 3, 5, 7]  (unchanged!)
           deleted = {1: 1}

peek():
  - Check heap[0] = 1
  - deleted[1] = 1 → clean it
  - heappop(heap) → heap = [3, 5, 7]
  - deleted = {1: 0}
  - heap[0] = 3 → not deleted, return 3

✓ Deletion is O(1), actual removal is deferred to access time
```

## 3.5.2 Index-Based Heap (Indexed Priority Queue)

For Dijkstra's algorithm and similar use cases where we need decrease-key:

```python
# ═══════════════════════════════════════════════════════════════
# INDEXED PRIORITY QUEUE
# ═══════════════════════════════════════════════════════════════

class IndexedMinHeap:
    """
    Min-heap that supports:
    - O(log n) decrease_key
    - O(log n) delete by key
    - O(1) contains check
    """
    
    def __init__(self):
        self.heap = []          # (priority, key)
        self.key_to_idx = {}    # key → index in heap
        self.key_to_priority = {}
    
    def _swap(self, i, j):
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
        # Update index mapping
        self.key_to_idx[self.heap[i][1]] = i
        self.key_to_idx[self.heap[j][1]] = j
    
    def _heapify_up(self, idx):
        while idx > 0:
            parent = (idx - 1) // 2
            if self.heap[idx][0] < self.heap[parent][0]:
                self._swap(idx, parent)
                idx = parent
            else:
                break
    
    def _heapify_down(self, idx):
        n = len(self.heap)
        while True:
            smallest = idx
            left, right = 2*idx+1, 2*idx+2
            if left < n and self.heap[left][0] < self.heap[smallest][0]:
                smallest = left
            if right < n and self.heap[right][0] < self.heap[smallest][0]:
                smallest = right
            if smallest == idx:
                break
            self._swap(idx, smallest)
            idx = smallest
    
    def push(self, key, priority):
        if key in self.key_to_idx:
            raise ValueError(f"Key {key} already exists")
        
        idx = len(self.heap)
        self.heap.append((priority, key))
        self.key_to_idx[key] = idx
        self.key_to_priority[key] = priority
        self._heapify_up(idx)
    
    def pop(self):
        if not self.heap:
            raise IndexError("Heap is empty")
        
        priority, key = self.heap[0]
        
        # Move last to root
        last = self.heap.pop()
        if self.heap:
            self.heap[0] = last
            self.key_to_idx[last[1]] = 0
            self._heapify_down(0)
        
        del self.key_to_idx[key]
        del self.key_to_priority[key]
        return key, priority
    
    def decrease_key(self, key, new_priority):
        """Decrease priority of existing key - O(log n)"""
        if key not in self.key_to_idx:
            raise KeyError(f"Key {key} not found")
        
        idx = self.key_to_idx[key]
        old_priority = self.heap[idx][0]
        
        if new_priority > old_priority:
            raise ValueError("New priority must be smaller")
        
        self.heap[idx] = (new_priority, key)
        self.key_to_priority[key] = new_priority
        self._heapify_up(idx)
    
    def contains(self, key):
        return key in self.key_to_idx
    
    def __len__(self):
        return len(self.heap)

# Usage: Dijkstra-style
ipq = IndexedMinHeap()
ipq.push('A', 10)
ipq.push('B', 5)
ipq.push('C', 15)

print(ipq.pop())  # ('B', 5)

ipq.decrease_key('C', 3)
print(ipq.pop())  # ('C', 3) - was 15, now 3
print(ipq.pop())  # ('A', 10)
```

---

# 3.6 Performance Tips

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    PERFORMANCE OPTIMIZATION TIPS                          ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  1. USE heapify() INSTEAD OF MULTIPLE push()                              ║
║     ✗ for x in arr: heappush(heap, x)  → O(n log n)                      ║
║     ✓ heapify(arr)                      → O(n)                           ║
║                                                                           ║
║  2. USE heappushpop() FOR TOP-K PATTERNS                                  ║
║     ✗ heappush(h, x); heappop(h)       → 2 operations                    ║
║     ✓ heappushpop(h, x)                 → 1 optimized operation          ║
║                                                                           ║
║  3. USE heapreplace() WHEN POP ALWAYS NEEDED                              ║
║     ✗ val = heappop(h); heappush(h, x) → 2 operations                    ║
║     ✓ val = heapreplace(h, x)           → 1 optimized operation          ║
║                                                                           ║
║  4. AVOID SEARCHING IN HEAP                                               ║
║     Heap search is O(n) - if you need frequent searches,                  ║
║     consider maintaining a separate set/dict for O(1) lookup              ║
║                                                                           ║
║  5. CHOOSE RIGHT K ALGORITHM                                              ║
║     k very small (< log n): use nlargest/nsmallest                       ║
║     k ≈ n/2: use sorting O(n log n)                                      ║
║     k ≈ n: return sorted(arr)                                            ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

---

# 3.7 Summary

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     CHAPTER 3 SUMMARY                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  PYTHON heapq                                                           │
│  • MIN-HEAP only                                                        │
│  • Key functions: heappush, heappop, heapify, peek via heap[0]         │
│  • Optimized: heappushpop, heapreplace                                  │
│  • Top-K: nlargest, nsmallest                                          │
│                                                                         │
│  MAX-HEAP STRATEGIES                                                    │
│  • Negate values: push(-x), return -pop()                              │
│  • Custom __lt__ wrapper class                                          │
│                                                                         │
│  CUSTOM COMPARATORS                                                     │
│  • Use tuples: (priority, tiebreaker, item)                            │
│  • Counter as tiebreaker for incomparable items                         │
│  • dataclass with field(compare=False)                                  │
│                                                                         │
│  ADVANCED PATTERNS                                                      │
│  • Lazy deletion: Mark deleted, clean on access                         │
│  • Indexed heap: Support decrease_key, contains                         │
│                                                                         │
│  INTERVIEW TIPS                                                         │
│  • Always mention heapq is min-heap only                                │
│  • Use tiebreaker to avoid comparison errors                            │
│  • Know when to use heappushpop vs heapreplace                          │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

**Next: Chapter 4 - Priority Queue Patterns** →
