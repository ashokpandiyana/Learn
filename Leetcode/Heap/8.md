# Chapter 8: Heap Sort
## The In-Place O(n log n) Sorting Algorithm

---

# 8.1 Introduction to Heap Sort

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                         HEAP SORT OVERVIEW                                ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  Heap Sort uses the heap data structure to sort an array in-place.        ║
║                                                                           ║
║  KEY PROPERTIES:                                                          ║
║  ┌─────────────────────────────────────────────────────────────────────┐ ║
║  │  Time Complexity:    O(n log n) - ALWAYS (best, average, worst)     │ ║
║  │  Space Complexity:   O(1) - IN-PLACE                                │ ║
║  │  Stable:             NO                                              │ ║
║  │  Adaptive:           NO (same time regardless of input order)       │ ║
║  └─────────────────────────────────────────────────────────────────────┘ ║
║                                                                           ║
║  TWO PHASES:                                                              ║
║  1. BUILD MAX-HEAP: Transform array into a max-heap - O(n)               ║
║  2. EXTRACT & SORT: Repeatedly extract max, place at end - O(n log n)    ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

---

# 8.2 The Algorithm

## 8.2.1 High-Level Steps

```
HEAP SORT ALGORITHM:

INPUT:  [4, 10, 3, 5, 1]

PHASE 1: Build Max-Heap
══════════════════════════════════════════════════════════════════

Transform array into max-heap (largest element at root)

        4                          10
       / \                        /  \
     10   3         →            5    3
     / \                        / \
    5   1                      4   1

Array: [4, 10, 3, 5, 1]  →  [10, 5, 3, 4, 1]


PHASE 2: Sort by Extracting Max
══════════════════════════════════════════════════════════════════

Repeat: Swap root (max) with last unsorted element, heapify

Step 1: Swap 10 ↔ 1, heapify [0..3]
        [10, 5, 3, 4, 1] → [1, 5, 3, 4, | 10] → [5, 4, 3, 1, | 10]
                                        └─sorted─┘

Step 2: Swap 5 ↔ 1, heapify [0..2]
        [5, 4, 3, 1, | 10] → [1, 4, 3, | 5, 10] → [4, 1, 3, | 5, 10]

Step 3: Swap 4 ↔ 3, heapify [0..1]
        [4, 1, 3, | 5, 10] → [3, 1, | 4, 5, 10] → [3, 1, | 4, 5, 10]

Step 4: Swap 3 ↔ 1, heapify [0..0]
        [3, 1, | 4, 5, 10] → [1, | 3, 4, 5, 10] → [1, 3, 4, 5, 10]

OUTPUT: [1, 3, 4, 5, 10] ✓
```

## 8.2.2 Visual Step-by-Step

```
DETAILED VISUALIZATION: Sorting [4, 10, 3, 5, 1]

═══════════════════════════════════════════════════════════════════════════
PHASE 1: BUILD MAX-HEAP (Bottom-up)
═══════════════════════════════════════════════════════════════════════════

Initial tree (not a heap):
                    4 [0]
                   / \
                10[1] 3[2]
                / \
              5[3] 1[4]

Start from last non-leaf: index (5//2 - 1) = 1

Heapify index 1 (value 10):
  Children: 5, 1
  10 > 5 and 10 > 1 → No change needed

                    4 [0]
                   / \
                10[1] 3[2]     ← 10 already max among its subtree
                / \
              5[3] 1[4]

Heapify index 0 (value 4):
  Children: 10, 3
  max(4, 10, 3) = 10 → Swap 4 and 10

                   10 [0]
                   / \
                 4[1] 3[2]     ← Swapped
                / \
              5[3] 1[4]

  Continue heapifying at index 1 (now value 4):
  Children: 5, 1
  max(4, 5, 1) = 5 → Swap 4 and 5

                   10 [0]
                   / \
                 5[1] 3[2]
                / \
              4[3] 1[4]

MAX-HEAP COMPLETE: [10, 5, 3, 4, 1]

═══════════════════════════════════════════════════════════════════════════
PHASE 2: EXTRACT AND SORT
═══════════════════════════════════════════════════════════════════════════

Iteration 1: Swap root with last element, reduce heap size
────────────────────────────────────────────────────────────────────────────

Before swap:                After swap:               After heapify:
      10                         1                         5
     /  \                       / \                       / \
    5    3                     5   3                     4   3
   / \                        /                         /
  4   1                      4                         1

Array: [10,5,3,4,1] → [1,5,3,4,|10] → [5,4,3,1,|10]
                              └──┘              └──┘
                             sorted            sorted

Iteration 2: 
────────────────────────────────────────────────────────────────────────────

Before swap:                After swap:               After heapify:
      5                          1                         4
     / \                        / \                       / \
    4   3                      4   3                     1   3
   /                          
  1                           

Array: [5,4,3,1,|10] → [1,4,3,|5,10] → [4,1,3,|5,10]

Iteration 3:
────────────────────────────────────────────────────────────────────────────

      4                          3                         3
     / \           →            / \           →           /
    1   3                      1                         1

Array: [4,1,3,|5,10] → [3,1,|4,5,10] → [3,1,|4,5,10]

Iteration 4:
────────────────────────────────────────────────────────────────────────────

      3                          1
     /             →
    1                           

Array: [3,1,|4,5,10] → [1,|3,4,5,10]

FINAL RESULT: [1, 3, 4, 5, 10] ✓
```

---

# 8.3 Implementation

## 8.3.1 Basic Implementation

```python
def heap_sort(arr):
    """
    Sort array in-place using heap sort.
    
    Time: O(n log n) - always
    Space: O(1) - in-place
    Stable: No
    """
    n = len(arr)
    
    # Phase 1: Build max-heap - O(n)
    # Start from last non-leaf node and heapify each
    for i in range(n // 2 - 1, -1, -1):
        _heapify_down(arr, n, i)
    
    # Phase 2: Extract elements one by one - O(n log n)
    for i in range(n - 1, 0, -1):
        # Swap root (maximum) with last unsorted element
        arr[0], arr[i] = arr[i], arr[0]
        
        # Heapify the reduced heap (size = i)
        _heapify_down(arr, i, 0)


def _heapify_down(arr, heap_size, i):
    """
    Heapify subtree rooted at index i.
    heap_size: only consider elements in arr[0:heap_size]
    """
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    # Compare with left child
    if left < heap_size and arr[left] > arr[largest]:
        largest = left
    
    # Compare with right child
    if right < heap_size and arr[right] > arr[largest]:
        largest = right
    
    # If largest is not root, swap and continue heapifying
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        _heapify_down(arr, heap_size, largest)


# Example:
arr = [64, 34, 25, 12, 22, 11, 90]
print(f"Original: {arr}")
heap_sort(arr)
print(f"Sorted:   {arr}")
# Output: [11, 12, 22, 25, 34, 64, 90]
```

## 8.3.2 Iterative Heapify (Stack-Safe)

```python
def heap_sort_iterative(arr):
    """
    Heap sort with iterative heapify (avoids recursion stack).
    Better for very large arrays.
    """
    n = len(arr)
    
    # Build max-heap
    for i in range(n // 2 - 1, -1, -1):
        _heapify_iterative(arr, n, i)
    
    # Extract elements
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        _heapify_iterative(arr, i, 0)


def _heapify_iterative(arr, heap_size, i):
    """Iterative version of heapify"""
    while True:
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < heap_size and arr[left] > arr[largest]:
            largest = left
        
        if right < heap_size and arr[right] > arr[largest]:
            largest = right
        
        if largest == i:
            break
        
        arr[i], arr[largest] = arr[largest], arr[i]
        i = largest
```

## 8.3.3 Descending Order Sort

```python
def heap_sort_descending(arr):
    """
    Sort array in descending order using MIN-heap.
    """
    n = len(arr)
    
    # Build min-heap
    for i in range(n // 2 - 1, -1, -1):
        _heapify_min(arr, n, i)
    
    # Extract minimums to end
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        _heapify_min(arr, i, 0)


def _heapify_min(arr, heap_size, i):
    """Heapify for min-heap"""
    smallest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < heap_size and arr[left] < arr[smallest]:
        smallest = left
    
    if right < heap_size and arr[right] < arr[smallest]:
        smallest = right
    
    if smallest != i:
        arr[i], arr[smallest] = arr[smallest], arr[i]
        _heapify_min(arr, heap_size, smallest)


# Example:
arr = [3, 1, 4, 1, 5, 9, 2, 6]
heap_sort_descending(arr)
print(arr)  # [9, 6, 5, 4, 3, 2, 1, 1]
```

---

# 8.4 Complexity Analysis

## 8.4.1 Time Complexity

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    TIME COMPLEXITY ANALYSIS                               ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  PHASE 1: BUILD MAX-HEAP                                                  ║
║  ═══════════════════════                                                  ║
║                                                                           ║
║  Naive analysis: n/2 nodes × O(log n) heapify = O(n log n)  ← WRONG!     ║
║                                                                           ║
║  Correct analysis: O(n)                                                   ║
║                                                                           ║
║  Why? Most nodes are near the bottom, doing less work:                    ║
║                                                                           ║
║  Level │ Nodes at level │ Max heapify swaps │ Total work                 ║
║  ──────┼────────────────┼───────────────────┼─────────────               ║
║    0   │       1        │        h          │     h                       ║
║    1   │       2        │       h-1         │   2(h-1)                    ║
║    2   │       4        │       h-2         │   4(h-2)                    ║
║   ...  │      ...       │       ...         │    ...                      ║
║   h-1  │     n/4        │        1          │    n/4                      ║
║    h   │     n/2        │        0          │     0    ← leaves, no work  ║
║                                                                           ║
║  Total = Σ (n/2^(h-i+1)) × i  for i = 0 to h                             ║
║        = O(n)                                                             ║
║                                                                           ║
║  PHASE 2: EXTRACT AND SORT                                                ║
║  ═════════════════════════                                                ║
║                                                                           ║
║  n-1 extractions × O(log n) heapify = O(n log n)                         ║
║                                                                           ║
║  TOTAL: O(n) + O(n log n) = O(n log n)                                   ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 8.4.2 Space Complexity

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    SPACE COMPLEXITY ANALYSIS                              ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  IN-PLACE SORTING:                                                        ║
║  • No additional array needed                                             ║
║  • Only O(1) extra space for swapping                                     ║
║                                                                           ║
║  RECURSION STACK (if using recursive heapify):                            ║
║  • Maximum depth = O(log n)                                               ║
║  • Can be avoided with iterative heapify                                  ║
║                                                                           ║
║  TOTAL SPACE:                                                             ║
║  • Iterative heapify: O(1)                                               ║
║  • Recursive heapify: O(log n) for call stack                            ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

---

# 8.5 Comparison with Other Sorting Algorithms

```
╔══════════════════════════════════════════════════════════════════════════════════════╗
║                    SORTING ALGORITHMS COMPARISON                                     ║
╠══════════════════════════════════════════════════════════════════════════════════════╣
║                                                                                      ║
║  Algorithm    │ Best      │ Average   │ Worst     │ Space   │Stable│ Notes          ║
║  ─────────────┼───────────┼───────────┼───────────┼─────────┼──────┼────────────────║
║  Heap Sort    │ O(n log n)│ O(n log n)│ O(n log n)│  O(1)   │  No  │ Consistent     ║
║  Quick Sort   │ O(n log n)│ O(n log n)│   O(n²)   │O(log n) │  No  │ Fast average   ║
║  Merge Sort   │ O(n log n)│ O(n log n)│ O(n log n)│  O(n)   │ Yes  │ Stable!        ║
║  Tim Sort     │   O(n)    │ O(n log n)│ O(n log n)│  O(n)   │ Yes  │ Adaptive       ║
║  Intro Sort   │ O(n log n)│ O(n log n)│ O(n log n)│O(log n) │  No  │ Hybrid         ║
║  ─────────────┼───────────┼───────────┼───────────┼─────────┼──────┼────────────────║
║                                                                                      ║
║  KEY INSIGHTS:                                                                       ║
║                                                                                      ║
║  HEAP SORT ADVANTAGES:                                                               ║
║  ┌─────────────────────────────────────────────────────────────────────────────────┐║
║  │ ✓ Guaranteed O(n log n) - no O(n²) worst case like quicksort                   │║
║  │ ✓ O(1) space - truly in-place                                                  │║
║  │ ✓ Good for systems with limited memory                                         │║
║  │ ✓ No pathological inputs that cause worst-case                                 │║
║  └─────────────────────────────────────────────────────────────────────────────────┘║
║                                                                                      ║
║  HEAP SORT DISADVANTAGES:                                                            ║
║  ┌─────────────────────────────────────────────────────────────────────────────────┐║
║  │ ✗ Not stable - equal elements may be reordered                                 │║
║  │ ✗ Poor cache performance - jumps around in memory                              │║
║  │ ✗ Not adaptive - doesn't benefit from partially sorted input                   │║
║  │ ✗ Higher constant factors than quicksort in practice                           │║
║  └─────────────────────────────────────────────────────────────────────────────────┘║
║                                                                                      ║
╚══════════════════════════════════════════════════════════════════════════════════════╝
```

## 8.5.1 When to Use Heap Sort

```python
"""
WHEN TO CHOOSE HEAP SORT:

1. MEMORY CONSTRAINED ENVIRONMENTS
   - Embedded systems
   - When O(n) extra space is not available
   - Merge sort needs O(n) space

2. WORST-CASE GUARANTEE NEEDED
   - Real-time systems where O(n²) is unacceptable
   - Security-sensitive code (no timing attacks via sorted input)
   - Quicksort degrades to O(n²) on sorted/nearly-sorted input

3. PARTIAL SORTING (Finding K largest/smallest)
   - Build heap O(n), extract k elements O(k log n)
   - Total: O(n + k log n)
   - For k << n, this beats full sorting O(n log n)

4. EXTERNAL SORTING
   - Heap-based merge in external merge sort
   - When data doesn't fit in memory

WHEN NOT TO USE HEAP SORT:

1. NEED STABILITY
   - Use Merge Sort or Tim Sort instead

2. TYPICAL AVERAGE CASE
   - Quicksort is usually 2-3x faster in practice

3. NEARLY SORTED DATA
   - Tim Sort and Insertion Sort excel here

4. CACHE PERFORMANCE CRITICAL
   - Heap sort has poor locality of reference
"""

def partial_sort_k_largest(arr, k):
    """
    Find k largest elements efficiently using heap sort technique.
    
    Time: O(n + k log n)
    """
    n = len(arr)
    
    # Build max-heap - O(n)
    for i in range(n // 2 - 1, -1, -1):
        _heapify_down(arr, n, i)
    
    # Extract k largest - O(k log n)
    result = []
    for i in range(k):
        result.append(arr[0])
        arr[0], arr[n - 1 - i] = arr[n - 1 - i], arr[0]
        _heapify_down(arr, n - 1 - i, 0)
    
    return result
```

---

# 8.6 Stability Analysis

## 8.6.1 Why Heap Sort is Not Stable

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    STABILITY IN SORTING                                   ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  STABLE SORT: Equal elements maintain their relative order                ║
║                                                                           ║
║  Example Input: [(A,5), (B,3), (C,5), (D,1)]                             ║
║                                                                           ║
║  Stable sort by value:   [(D,1), (B,3), (A,5), (C,5)]                    ║
║                                         ↑      ↑                          ║
║                                    A before C (original order preserved)  ║
║                                                                           ║
║  Unstable sort by value: [(D,1), (B,3), (C,5), (A,5)]  ← Possible!       ║
║                                         ↑      ↑                          ║
║                                    C before A (order changed)             ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 8.6.2 Demonstration

```python
def demonstrate_instability():
    """Show that heap sort is not stable"""
    
    # Create items with same key but different identity
    items = [
        {"name": "First-5", "key": 5},
        {"name": "First-3", "key": 3},
        {"name": "Second-5", "key": 5},  # Same key as First-5
        {"name": "Third-5", "key": 5},   # Same key as above
        {"name": "Second-3", "key": 3},  # Same key as First-3
    ]
    
    # Extract just keys for sorting
    keys = [item["key"] for item in items]
    
    print("Original order of items with key 5:")
    for item in items:
        if item["key"] == 5:
            print(f"  {item['name']}")
    
    # Sort using heap sort
    # We need to sort the items array based on keys
    # (This is a simplified demonstration)
    
    n = len(items)
    
    # Build max-heap based on keys
    def heapify(arr, size, i):
        largest = i
        left, right = 2*i+1, 2*i+2
        if left < size and arr[left]["key"] > arr[largest]["key"]:
            largest = left
        if right < size and arr[right]["key"] > arr[largest]["key"]:
            largest = right
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify(arr, size, largest)
    
    for i in range(n//2-1, -1, -1):
        heapify(items, n, i)
    
    for i in range(n-1, 0, -1):
        items[0], items[i] = items[i], items[0]
        heapify(items, i, 0)
    
    print("\nAfter heap sort, order of items with key 5:")
    for item in items:
        if item["key"] == 5:
            print(f"  {item['name']}")
    
    print("\nNote: Original relative order may not be preserved!")


# Run demonstration
demonstrate_instability()

"""
Typical output:

Original order of items with key 5:
  First-5
  Second-5
  Third-5

After heap sort, order of items with key 5:
  Third-5
  Second-5
  First-5

Note: Original relative order may not be preserved!
"""
```

---

# 8.7 Optimizations and Variations

## 8.7.1 Bottom-Up Heap Sort

```python
def bottom_up_heap_sort(arr):
    """
    Bottom-up (Floyd's) heap construction for heap sort.
    
    More cache-friendly version that sifts elements 
    all the way down before comparing.
    """
    n = len(arr)
    
    def sift_down(start, end):
        """Bottom-up sift: go down first, then bubble up"""
        root = start
        
        # Go all the way down (leaf path)
        while 2 * root + 1 <= end:
            child = 2 * root + 1
            # Go to larger child
            if child + 1 <= end and arr[child] < arr[child + 1]:
                child += 1
            root = child
        
        # Now bubble up to correct position
        while root > start:
            parent = (root - 1) // 2
            if arr[root] > arr[parent]:
                arr[root], arr[parent] = arr[parent], arr[root]
                root = parent
            else:
                break
    
    # Build max-heap
    for i in range((n - 2) // 2, -1, -1):
        sift_down(i, n - 1)
    
    # Sort
    for end in range(n - 1, 0, -1):
        arr[0], arr[end] = arr[end], arr[0]
        sift_down(0, end - 1)
```

## 8.7.2 K-Way Heap Sort

```python
def k_way_heap_sort(arr, k=2):
    """
    Heap sort using k-ary heap instead of binary.
    
    k=4 often performs better due to cache effects.
    """
    n = len(arr)
    
    def parent(i):
        return (i - 1) // k
    
    def children(i):
        start = k * i + 1
        return range(start, min(start + k, n))
    
    def sift_down(size, i):
        while True:
            largest = i
            for child in range(k * i + 1, min(k * i + k + 1, size)):
                if arr[child] > arr[largest]:
                    largest = child
            if largest == i:
                break
            arr[i], arr[largest] = arr[largest], arr[i]
            i = largest
    
    # Build max-heap
    for i in range((n - 2) // k, -1, -1):
        sift_down(n, i)
    
    # Sort
    for end in range(n - 1, 0, -1):
        arr[0], arr[end] = arr[end], arr[0]
        sift_down(end, 0)
```

---

# 8.8 Interview Questions Related to Heap Sort

```python
# ═══════════════════════════════════════════════════════════════════════════
# COMMON INTERVIEW QUESTIONS
# ═══════════════════════════════════════════════════════════════════════════

def sort_nearly_sorted(arr, k):
    """
    Sort an array where each element is at most k positions 
    from its sorted position.
    
    Use a min-heap of size k+1.
    Time: O(n log k)
    """
    import heapq
    
    n = len(arr)
    heap = arr[:k+1]
    heapq.heapify(heap)
    
    result_idx = 0
    
    for i in range(k+1, n):
        arr[result_idx] = heapq.heappop(heap)
        heapq.heappush(heap, arr[i])
        result_idx += 1
    
    while heap:
        arr[result_idx] = heapq.heappop(heap)
        result_idx += 1
    
    return arr


def is_heap(arr, heap_type='max'):
    """
    Check if array represents a valid heap.
    
    Time: O(n)
    """
    n = len(arr)
    
    for i in range(n // 2):
        left = 2 * i + 1
        right = 2 * i + 2
        
        if heap_type == 'max':
            if left < n and arr[i] < arr[left]:
                return False
            if right < n and arr[i] < arr[right]:
                return False
        else:  # min-heap
            if left < n and arr[i] > arr[left]:
                return False
            if right < n and arr[i] > arr[right]:
                return False
    
    return True


def convert_max_to_min_heap(arr):
    """
    Convert a max-heap to min-heap in-place.
    
    Simply rebuild as min-heap - O(n)
    """
    n = len(arr)
    
    def min_heapify(i):
        smallest = i
        left, right = 2*i+1, 2*i+2
        if left < n and arr[left] < arr[smallest]:
            smallest = left
        if right < n and arr[right] < arr[smallest]:
            smallest = right
        if smallest != i:
            arr[i], arr[smallest] = arr[smallest], arr[i]
            min_heapify(smallest)
    
    for i in range(n//2 - 1, -1, -1):
        min_heapify(i)
    
    return arr
```

---

# 8.9 Summary

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         CHAPTER 8 SUMMARY                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  HEAP SORT ALGORITHM                                                        │
│  1. Build max-heap from array: O(n)                                        │
│  2. Repeatedly extract max to end: O(n log n)                              │
│                                                                             │
│  COMPLEXITY                                                                 │
│  • Time: O(n log n) - always (best, average, worst)                        │
│  • Space: O(1) - in-place                                                  │
│  • NOT stable - equal elements may be reordered                            │
│  • NOT adaptive - same time regardless of input                            │
│                                                                             │
│  ADVANTAGES                                                                 │
│  • Guaranteed O(n log n) worst case                                        │
│  • True O(1) space                                                         │
│  • No pathological inputs                                                  │
│  • Good for partial sorting (find k largest)                               │
│                                                                             │
│  DISADVANTAGES                                                              │
│  • Not stable                                                              │
│  • Poor cache performance                                                  │
│  • Higher constants than quicksort                                         │
│  • Not adaptive to input patterns                                          │
│                                                                             │
│  WHEN TO USE                                                                │
│  • Memory-constrained environments                                         │
│  • Need guaranteed worst-case performance                                  │
│  • Partial sorting (k largest/smallest)                                    │
│  • External sorting                                                        │
│                                                                             │
│  KEY INTERVIEW POINTS                                                       │
│  • Build heap is O(n), NOT O(n log n)                                      │
│  • Explain why it's not stable                                             │
│  • Compare with quicksort and merge sort                                   │
│  • Know when to choose heap sort                                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

**Next: Chapter 9 - Interview Questions Bank** →
