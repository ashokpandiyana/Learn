# Chapter 2: Core Heap Operations
## Mastering Heap Manipulations

---

# 2.1 Operations Overview

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                     HEAP OPERATIONS COMPLEXITY                            â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Operation          â”‚ Time Complexity â”‚ Description                       â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  peek()             â”‚     O(1)        â”‚ View min/max without removing     â•‘
â•‘  push() / insert()  â”‚   O(log n)      â”‚ Add element, bubble up            â•‘
â•‘  pop() / extract()  â”‚   O(log n)      â”‚ Remove min/max, bubble down       â•‘
â•‘  heapify()          â”‚   O(log n)      â”‚ Fix single violation              â•‘
â•‘  build_heap()       â”‚     O(n)        â”‚ Convert array to heap             â•‘
â•‘  size()             â”‚     O(1)        â”‚ Return element count              â•‘
â•‘  is_empty()         â”‚     O(1)        â”‚ Check if heap empty               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”¥ CRITICAL: build_heap() is O(n), NOT O(n log n)!
```

---

# 2.2 Heapify Up (Bubble Up / Sift Up / Percolate Up)

## 2.2.1 Concept

**Heapify Up** is used to restore the heap property after **inserting** a new element at the bottom of the heap.

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  HEAPIFY UP ALGORITHM (for Min-Heap):                                     â•‘
â•‘                                                                           â•‘
â•‘  1. Start at the newly inserted node (last position)                      â•‘
â•‘  2. Compare with parent                                                   â•‘
â•‘  3. If current < parent: SWAP and move up                                 â•‘
â•‘  4. Repeat until root OR parent â‰¤ current                                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

## 2.2.2 Visual Example: Insert 5 into Min-Heap

```
INITIAL STATE:                    STEP 1: Add 5 at end
                                  (Violates heap property!)
       10                                10
      /  \                              /  \
    20    15                          20    15
   /  \                              /  \   /
  30   25                          30  25  5 â† New element
                                            â†‘
                                      5 < 15 (parent)
                                      VIOLATION!

STEP 2: Compare 5 with parent 15    STEP 3: Swap 5 and 15
        5 < 15, so swap!            
                                           10
       10                                 /  \
      /  \                              20    5  â† 5 moved up
    20    15 â† parent                  /  \   /
   /  \   /                          30  25  15
  30  25  5 â† current                     
                                    Now check: 5 < 10 (parent)
                                    VIOLATION!

STEP 4: Swap 5 and 10               FINAL STATE:
                                    
        10 â† parent                        5  â† New root!
       /  \                              /   \
     20    5 â† current                 10     15
    /  \   /                          /  \   /
   30  25 15                         30  25 20

                                    âœ“ Heap property restored!
                                    5 is now the minimum
```

## 2.2.3 Implementation

```python
def _heapify_up(self, index):
    """
    Restore heap property by moving element UP the tree.
    Used after insertion.
    
    Time Complexity: O(log n) - worst case traverse root to leaf
    Space Complexity: O(1)
    """
    # Continue while we have a parent and heap property is violated
    while self._has_parent(index):
        parent_idx = self._parent(index)
        
        # For Min-Heap: if current < parent, swap
        if self.heap[index] < self.heap[parent_idx]:
            self._swap(index, parent_idx)
            index = parent_idx  # Move up to parent position
        else:
            # Heap property satisfied, stop
            break

def push(self, value):
    """
    Insert a new element into the heap.
    
    Time Complexity: O(log n)
    """
    # Step 1: Add to the end (maintains complete tree property)
    self.heap.append(value)
    
    # Step 2: Restore heap property by bubbling up
    self._heapify_up(len(self.heap) - 1)
```

### Trace Example:

```python
# Insert sequence: [20, 15, 30, 10, 5]

# Insert 20: heap = [20]               (root, no bubble up needed)
# Insert 15: heap = [20, 15]
#            15 < 20? Yes! Swap â†’ [15, 20]
# Insert 30: heap = [15, 20, 30]
#            30 < 15? No. Done.
# Insert 10: heap = [15, 20, 30, 10]
#            10 < 20? Yes! Swap â†’ [15, 10, 30, 20]
#            10 < 15? Yes! Swap â†’ [10, 15, 30, 20]
# Insert 5:  heap = [10, 15, 30, 20, 5]
#            5 < 15? Yes! Swap â†’ [10, 5, 30, 20, 15]
#            5 < 10? Yes! Swap â†’ [5, 10, 30, 20, 15]

# Final: [5, 10, 30, 20, 15]
```

---

# 2.3 Heapify Down (Bubble Down / Sift Down / Percolate Down)

## 2.3.1 Concept

**Heapify Down** is used to restore the heap property after **removing** the root element or when fixing a violation from above.

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  HEAPIFY DOWN ALGORITHM (for Min-Heap):                                   â•‘
â•‘                                                                           â•‘
â•‘  1. Start at the root (or node to fix)                                    â•‘
â•‘  2. Find the SMALLER child                                                â•‘
â•‘  3. If current > smaller child: SWAP and move down                        â•‘
â•‘  4. Repeat until leaf OR current â‰¤ both children                          â•‘
â•‘                                                                           â•‘
â•‘  âš ï¸ IMPORTANT: Always swap with the SMALLER child in min-heap!            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

## 2.3.2 Why Swap with Smaller Child?

```
Consider this scenario (Min-Heap):

        50           If we swap 50 with 30 (larger child):
       /  \          
      20   30               30      â† Now 30 > 20, INVALID!
                           /  \
                         20   50    

                     If we swap 50 with 20 (smaller child):
        
                           20       â† 20 < 30, VALID!
                          /  \
                        50    30    

âœ“ Swapping with SMALLER child maintains heap property for sibling!
```

## 2.3.3 Visual Example: Extract Min from Min-Heap

```
INITIAL STATE:              STEP 1: Remove root (5)
                                    Replace with last element
       5
      / \                          25 â† Last element moved to root
    10   15                       /  \
   /  \  /                      10   15
  30  25 20                    /  \  /
      â†‘                       30  ?  20
   Last element                    â†‘
                              Now empty (25 moved up)

STEP 2: Heapify Down          Children: 10, 15
        25 > min(10,15)?      Smaller child: 10
        25 > 10? YES, SWAP!   

        25                            10
       /  \                          /  \
     10    15          â†’           25    15
    /  \   /                      /  \   /
   30   Â· 20                     30   Â· 20

STEP 3: Continue at new position
        Children: 30, Â·
        25 > 30? NO
        
        STOP! Heap property restored.

FINAL STATE:
        
        10      â† New minimum
       /  \
     25    15
    /      /
   30     20

Array: [10, 25, 15, 30, 20]
```

## 2.3.4 Implementation

```python
def _heapify_down(self, index):
    """
    Restore heap property by moving element DOWN the tree.
    Used after extraction or during build_heap.
    
    Time Complexity: O(log n)
    Space Complexity: O(1)
    """
    while self._has_left_child(index):
        # Find the smaller child
        smaller_child_idx = self._left_child(index)
        
        # Check if right child exists and is smaller
        if self._has_right_child(index):
            right_idx = self._right_child(index)
            if self.heap[right_idx] < self.heap[smaller_child_idx]:
                smaller_child_idx = right_idx
        
        # If current is smaller than smallest child, heap property OK
        if self.heap[index] <= self.heap[smaller_child_idx]:
            break
        
        # Swap with smaller child and continue
        self._swap(index, smaller_child_idx)
        index = smaller_child_idx

def pop(self):
    """
    Remove and return the minimum element.
    
    Time Complexity: O(log n)
    """
    if self.is_empty():
        raise IndexError("Heap is empty")
    
    # Step 1: Save the minimum (root)
    min_value = self.heap[0]
    
    # Step 2: Move last element to root
    last_element = self.heap.pop()
    
    if self.heap:  # If heap is not empty
        self.heap[0] = last_element
        # Step 3: Restore heap property
        self._heapify_down(0)
    
    return min_value
```

### Complete Trace of pop():

```python
# heap = [5, 10, 15, 30, 25, 20]
# Tree:      5
#          /   \
#        10     15
#       /  \   /
#      30  25 20

# pop() called:
# 1. Save min_value = 5
# 2. Remove last (20), place at root
#    heap = [20, 10, 15, 30, 25]
# 3. _heapify_down(0):
#    - current=20 at index 0
#    - children: 10 (idx 1), 15 (idx 2)
#    - smaller = 10
#    - 20 > 10? YES, swap
#    heap = [10, 20, 15, 30, 25]
#    - move to index 1
#    - children: 30 (idx 3), 25 (idx 4)
#    - smaller = 25
#    - 20 > 25? NO, STOP
# 4. Return 5

# Final heap = [10, 20, 15, 30, 25]
```

---

# 2.4 Build Heap (Heapify Array)

## 2.4.1 Two Approaches

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    BUILD HEAP METHODS                                     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                           â•‘
â•‘  METHOD 1: TOP-DOWN (Naive)           METHOD 2: BOTTOM-UP (Optimal)       â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€           â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€       â•‘
â•‘  â€¢ Insert elements one by one        â€¢ Start from last non-leaf           â•‘
â•‘  â€¢ Call heapify_up after each        â€¢ Call heapify_down on each          â•‘
â•‘  â€¢ Time: O(n log n)                  â€¢ Time: O(n)                         â•‘
â•‘                                                                           â•‘
â•‘  Use for: Streaming data             Use for: Static array                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

## 2.4.2 Bottom-Up Build Heap (Floyd's Algorithm)

```python
def build_heap(arr):
    """
    Convert an unsorted array into a valid heap IN-PLACE.
    Uses bottom-up approach (Floyd's algorithm).
    
    Time Complexity: O(n) - NOT O(n log n)!
    Space Complexity: O(1)
    """
    n = len(arr)
    
    # Start from last non-leaf node
    # Last non-leaf = parent of last element = (n-1-1)//2 = n//2 - 1
    start_idx = n // 2 - 1
    
    # Process each node from bottom to top
    for i in range(start_idx, -1, -1):
        _heapify_down(arr, n, i)

def _heapify_down(arr, n, i):
    """Heapify down for array-based heap"""
    smallest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] < arr[smallest]:
        smallest = left
    
    if right < n and arr[right] < arr[smallest]:
        smallest = right
    
    if smallest != i:
        arr[i], arr[smallest] = arr[smallest], arr[i]
        _heapify_down(arr, n, smallest)
```

## 2.4.3 Visual Example: Build Min-Heap from [40, 30, 50, 10, 20, 60, 5]

```
INITIAL ARRAY: [40, 30, 50, 10, 20, 60, 5]

AS TREE (not a heap yet):
              40(0)
            /      \
         30(1)     50(2)
         /   \     /   \
      10(3) 20(4) 60(5) 5(6)

Indices: 0  1  2  3  4  5  6
Last non-leaf index = 7//2 - 1 = 2

Process nodes: 2 â†’ 1 â†’ 0

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
STEP 1: Heapify node 2 (value 50)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Children: 60(5), 5(6)
Smaller child: 5
50 > 5? YES â†’ SWAP

              40                            40
            /    \                        /    \
          30      50         â†’          30      5
         /  \    /  \                  /  \    /  \
        10  20  60   5               10  20  60   50
                     â†‘                        â†‘
                  smaller               swapped up

Array: [40, 30, 5, 10, 20, 60, 50]

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
STEP 2: Heapify node 1 (value 30)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Children: 10(3), 20(4)
Smaller child: 10
30 > 10? YES â†’ SWAP

              40                            40
            /    \                        /    \
          30      5          â†’          10      5
         /  \    /  \                  /  \    /  \
        10  20  60   50               30  20  60   50
        â†‘                              â†‘
     smaller                      swapped up

Array: [40, 10, 5, 30, 20, 60, 50]

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
STEP 3: Heapify node 0 (value 40)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Children: 10(1), 5(2)
Smaller child: 5
40 > 5? YES â†’ SWAP

              40                            5
            /    \                        /    \
          10      5          â†’          10      40
         /  \    /  \                  /  \    /  \
        30  20  60   50               30  20  60   50
                â†‘                              â†‘
            smaller                       swapped

Continue heapify_down at index 2 (value 40):
Children: 60(5), 50(6)
Smaller child: 50
40 > 50? NO â†’ STOP

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FINAL RESULT:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

               5           â† Minimum at root!
            /    \
          10      40
         /  \    /  \
        30  20  60   50

Array: [5, 10, 40, 30, 20, 60, 50]

âœ“ Valid Min-Heap!
```

## 2.4.4 Why is Build Heap O(n)?

This is a **crucial interview topic**. Many incorrectly assume it's O(n log n).

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   PROOF: BUILD HEAP IS O(n)                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

INTUITION:
â€¢ Most nodes are at the BOTTOM of the tree
â€¢ Bottom nodes do LESS work (short heapify_down paths)
â€¢ Few nodes at TOP do MORE work (long heapify_down paths)
â€¢ The math works out to O(n)!

DETAILED ANALYSIS:

For a heap with n nodes and height h = log n:

Level   â”‚ Nodes at level â”‚ Max heapify_down â”‚ Work at level
â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
0 (root)â”‚       1        â”‚        h         â”‚     h
1       â”‚       2        â”‚       h-1        â”‚   2(h-1)
2       â”‚       4        â”‚       h-2        â”‚   4(h-2)
...     â”‚      ...       â”‚       ...        â”‚    ...
h-1     â”‚    2^(h-1)     â”‚        1         â”‚   2^(h-1)
h (leaf)â”‚    ~n/2        â”‚        0         â”‚     0
                                            
                           Leaves do NO work!

MATHEMATICAL SUM:
Total work = Î£ (nodes at level i) Ã— (max swaps from level i)
           = Î£ 2^i Ã— (h - i)    for i = 0 to h-1

Using mathematical series properties:
           = O(n)

INTUITIVE ARGUMENT:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                         â”‚
â”‚     Level 0:   1 node  Ã— log n work  =  log n          â”‚
â”‚     Level 1:   2 nodes Ã— (log n - 1) =  ~2 log n       â”‚
â”‚     ...                                                 â”‚
â”‚     Level h-1: n/2 nodes Ã— 1 work    =  n/2            â”‚
â”‚     Level h:   n/2 nodes Ã— 0 work    =  0              â”‚
â”‚                                                         â”‚
â”‚  Total â‰ˆ n (most work is at bottom where work is O(1)) â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Compare with TOP-DOWN (inserting one by one):
â€¢ Each of n inserts does O(log n) work
â€¢ Total = O(n log n)
```

```python
# Visual proof with example:
# n = 15 nodes, height h = 3

#                [0]              Level 0: 1 node, heapify_down up to 3 swaps
#              /     \
#           [1]       [2]         Level 1: 2 nodes, up to 2 swaps each
#          /   \     /   \
#        [3]   [4] [5]   [6]      Level 2: 4 nodes, up to 1 swap each
#        /\    /\   /\    /\
#       7  8  9 10 11 12 13 14    Level 3: 8 nodes, 0 swaps (leaves)

# Work calculation:
# Level 0: 1 Ã— 3 = 3
# Level 1: 2 Ã— 2 = 4
# Level 2: 4 Ã— 1 = 4
# Level 3: 8 Ã— 0 = 0
# Total: 11 operations for 15 nodes â‰ˆ O(n)

# If we did top-down insert:
# 15 inserts Ã— log(15) â‰ˆ 15 Ã— 4 = 60 operations = O(n log n)
```

---

# 2.5 Other Important Operations

## 2.5.1 Peek (Get Min/Max)

```python
def peek(self):
    """
    Return the minimum element without removing it.
    
    Time Complexity: O(1)
    Space Complexity: O(1)
    """
    if self.is_empty():
        raise IndexError("Heap is empty")
    return self.heap[0]
```

## 2.5.2 Delete Arbitrary Element

```python
def delete(self, value):
    """
    Delete a specific value from the heap.
    
    Time Complexity: O(n) for search + O(log n) for restructure = O(n)
    """
    # Find the index of the value
    try:
        idx = self.heap.index(value)
    except ValueError:
        raise ValueError(f"{value} not in heap")
    
    # Replace with last element
    last = self.heap.pop()
    
    if idx < len(self.heap):
        self.heap[idx] = last
        
        # Decide whether to bubble up or down
        parent_idx = self._parent(idx)
        if idx > 0 and self.heap[idx] < self.heap[parent_idx]:
            self._heapify_up(idx)
        else:
            self._heapify_down(idx)
```

## 2.5.3 Update/Decrease Key

```python
def decrease_key(self, idx, new_value):
    """
    Decrease the value at given index (for min-heap).
    
    Time Complexity: O(log n)
    
    Used in: Dijkstra's algorithm, Prim's algorithm
    """
    if new_value > self.heap[idx]:
        raise ValueError("New value is greater than current value")
    
    self.heap[idx] = new_value
    self._heapify_up(idx)  # May need to bubble up

def increase_key(self, idx, new_value):
    """
    Increase the value at given index (for min-heap).
    
    Time Complexity: O(log n)
    """
    if new_value < self.heap[idx]:
        raise ValueError("New value is smaller than current value")
    
    self.heap[idx] = new_value
    self._heapify_down(idx)  # May need to bubble down
```

---

# 2.6 Complete Min-Heap Implementation

```python
class MinHeap:
    """Complete Min-Heap with all operations"""
    
    def __init__(self, arr=None):
        if arr is None:
            self.heap = []
        else:
            self.heap = arr.copy()
            self._build_heap()
    
    # ========== PRIVATE HELPERS ==========
    
    def _parent(self, i): return (i - 1) // 2
    def _left(self, i): return 2 * i + 1
    def _right(self, i): return 2 * i + 2
    def _has_left(self, i): return self._left(i) < len(self.heap)
    def _has_right(self, i): return self._right(i) < len(self.heap)
    def _swap(self, i, j): 
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
    
    def _heapify_up(self, idx):
        while idx > 0:
            parent = self._parent(idx)
            if self.heap[idx] < self.heap[parent]:
                self._swap(idx, parent)
                idx = parent
            else:
                break
    
    def _heapify_down(self, idx):
        while self._has_left(idx):
            smallest = self._left(idx)
            if self._has_right(idx) and self.heap[self._right(idx)] < self.heap[smallest]:
                smallest = self._right(idx)
            if self.heap[idx] <= self.heap[smallest]:
                break
            self._swap(idx, smallest)
            idx = smallest
    
    def _build_heap(self):
        for i in range(len(self.heap) // 2 - 1, -1, -1):
            self._heapify_down(i)
    
    # ========== PUBLIC OPERATIONS ==========
    
    def push(self, val):
        """Add element - O(log n)"""
        self.heap.append(val)
        self._heapify_up(len(self.heap) - 1)
    
    def pop(self):
        """Remove and return minimum - O(log n)"""
        if not self.heap:
            raise IndexError("Empty heap")
        val = self.heap[0]
        last = self.heap.pop()
        if self.heap:
            self.heap[0] = last
            self._heapify_down(0)
        return val
    
    def peek(self):
        """Return minimum without removing - O(1)"""
        if not self.heap:
            raise IndexError("Empty heap")
        return self.heap[0]
    
    def pushpop(self, val):
        """Push then pop - more efficient than separate calls"""
        if self.heap and self.heap[0] < val:
            val, self.heap[0] = self.heap[0], val
            self._heapify_down(0)
        return val
    
    def replace(self, val):
        """Pop then push - more efficient than separate calls"""
        if not self.heap:
            raise IndexError("Empty heap")
        result = self.heap[0]
        self.heap[0] = val
        self._heapify_down(0)
        return result
    
    def __len__(self): return len(self.heap)
    def __bool__(self): return bool(self.heap)
    def __str__(self): return f"MinHeap({self.heap})"


# ========== USAGE EXAMPLE ==========
if __name__ == "__main__":
    # Build from array
    h = MinHeap([40, 30, 50, 10, 20, 60, 5])
    print(f"Built heap: {h}")  # [5, 10, 40, 30, 20, 60, 50]
    
    # Operations
    print(f"Min: {h.peek()}")  # 5
    print(f"Pop: {h.pop()}")   # 5
    print(f"After pop: {h}")   # [10, 20, 40, 30, 50, 60]
    
    h.push(3)
    print(f"After push(3): {h}")  # [3, 20, 10, 30, 50, 60, 40]
```

---

# 2.7 Summary

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     CHAPTER 2 SUMMARY                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  HEAPIFY UP (Bubble Up)                                                 â”‚
â”‚  â€¢ Used after: INSERTION                                                â”‚
â”‚  â€¢ Direction: Child â†’ Parent (upward)                                   â”‚
â”‚  â€¢ Compare: Current with parent                                         â”‚
â”‚  â€¢ Time: O(log n)                                                       â”‚
â”‚                                                                         â”‚
â”‚  HEAPIFY DOWN (Bubble Down)                                             â”‚
â”‚  â€¢ Used after: EXTRACTION, BUILD HEAP                                   â”‚
â”‚  â€¢ Direction: Parent â†’ Children (downward)                              â”‚
â”‚  â€¢ Compare: Current with SMALLER/LARGER child                           â”‚
â”‚  â€¢ Time: O(log n)                                                       â”‚
â”‚                                                                         â”‚
â”‚  BUILD HEAP                                                             â”‚
â”‚  â€¢ Bottom-up approach (Floyd's algorithm)                               â”‚
â”‚  â€¢ Start from last non-leaf: n//2 - 1                                   â”‚
â”‚  â€¢ Apply heapify_down to each                                           â”‚
â”‚  â€¢ Time: O(n) â† IMPORTANT!                                              â”‚
â”‚                                                                         â”‚
â”‚  KEY INSIGHT                                                            â”‚
â”‚  â€¢ In min-heap: swap with SMALLER child                                 â”‚
â”‚  â€¢ In max-heap: swap with LARGER child                                  â”‚
â”‚  â€¢ This maintains heap property for the sibling!                        â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

**Next: Chapter 3 - Heap Implementation Patterns** â†’
