# Chapter 10: Tips, Tricks & Common Mistakes
## Master the Details for Interview Success

---

# 10.1 Common Mistakes to Avoid

## 10.1.1 Python heapq Mistakes

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MISTAKE 1: Forgetting heapq is MIN-HEAP only
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import heapq

# âŒ WRONG: Expecting max-heap behavior
heap = [3, 1, 4, 1, 5]
heapq.heapify(heap)
print(heapq.heappop(heap))  # Returns 1, NOT 5!

# âœ… CORRECT: Negate for max-heap
max_heap = [-x for x in [3, 1, 4, 1, 5]]
heapq.heapify(max_heap)
print(-heapq.heappop(max_heap))  # Returns 5 âœ“


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MISTAKE 2: Comparing incomparable objects
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Task:
    def __init__(self, name):
        self.name = name

# âŒ WRONG: Tasks aren't comparable
heap = []
heapq.heappush(heap, (1, Task("A")))
heapq.heappush(heap, (1, Task("B")))  # ERROR when priorities are equal!

# âœ… CORRECT: Use index as tiebreaker
heap = []
counter = 0
heapq.heappush(heap, (1, counter, Task("A")))
counter += 1
heapq.heappush(heap, (1, counter, Task("B")))  # Works! âœ“


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MISTAKE 3: Modifying heap elements directly
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# âŒ WRONG: Direct modification breaks heap property
heap = [1, 3, 5, 7, 9]
heapq.heapify(heap)
heap[2] = 0  # Heap property violated!

# âœ… CORRECT: Use proper update methods
# Option 1: Rebuild (simple but O(n))
heap[2] = 0
heapq.heapify(heap)

# Option 2: Lazy deletion (for removals)
# See Chapter 4 for implementation


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MISTAKE 4: Wrong complexity assumption for build heap
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# âŒ WRONG: Assuming O(n log n)
# "Building heap from n elements is O(n log n)"

# âœ… CORRECT: heapify is O(n)
arr = [5, 3, 8, 1, 2, 9, 4]
heapq.heapify(arr)  # O(n), NOT O(n log n)!


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MISTAKE 5: Using wrong heap type for problem
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# âŒ WRONG: Max-heap for K largest
def k_largest_wrong(nums, k):
    # Using max-heap means we keep ALL elements
    heap = [-x for x in nums]
    heapq.heapify(heap)
    return [-heapq.heappop(heap) for _ in range(k)]
    # Time: O(n + k log n), Space: O(n)

# âœ… CORRECT: Min-heap of size K for K largest
def k_largest_correct(nums, k):
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
        if len(heap) > k:
            heapq.heappop(heap)
    return heap
    # Time: O(n log k), Space: O(k) â† Better!
```

## 10.1.2 Algorithm Logic Mistakes

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MISTAKE 6: Wrong child selection in heapify
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# âŒ WRONG: Swapping with any child that's larger/smaller
def wrong_heapify_down(arr, n, i):
    left = 2 * i + 1
    if left < n and arr[left] < arr[i]:  # Just checking left
        arr[i], arr[left] = arr[left], arr[i]
        wrong_heapify_down(arr, n, left)

# âœ… CORRECT: Swap with the SMALLEST (min-heap) or LARGEST (max-heap) child
def correct_heapify_down(arr, n, i):
    smallest = i
    left, right = 2*i+1, 2*i+2
    
    if left < n and arr[left] < arr[smallest]:
        smallest = left
    if right < n and arr[right] < arr[smallest]:
        smallest = right
    
    if smallest != i:
        arr[i], arr[smallest] = arr[smallest], arr[i]
        correct_heapify_down(arr, n, smallest)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MISTAKE 7: Off-by-one errors in index calculations
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# For 0-indexed heap:
# âŒ WRONG
parent = i // 2           # Should be (i-1)//2
left = 2 * i              # Should be 2*i+1
right = 2 * i + 1         # Should be 2*i+2
last_non_leaf = n // 2    # Should be n//2 - 1

# âœ… CORRECT (0-indexed)
parent = (i - 1) // 2
left = 2 * i + 1
right = 2 * i + 2
last_non_leaf = n // 2 - 1


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MISTAKE 8: Not handling edge cases
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import heapq

def find_kth_largest_buggy(nums, k):
    # âŒ WRONG: Doesn't handle k > len(nums)
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
        if len(heap) > k:
            heapq.heappop(heap)
    return heap[0]  # May error or wrong result!

def find_kth_largest_correct(nums, k):
    # âœ… CORRECT: Handle edge cases
    if not nums or k <= 0 or k > len(nums):
        return None  # Or raise exception
    
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
        if len(heap) > k:
            heapq.heappop(heap)
    return heap[0]
```

---

# 10.2 Optimization Tips

## 10.2.1 Use Optimized heapq Functions

```python
import heapq

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TIP 1: Use heappushpop instead of push + pop
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

heap = [1, 3, 5]

# âŒ SLOWER: Two separate operations
heapq.heappush(heap, 2)
result = heapq.heappop(heap)

# âœ… FASTER: Single optimized operation
result = heapq.heappushpop(heap, 2)

# heappushpop is optimized: if new item is smaller than root,
# it returns immediately without modifying heap!


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TIP 2: Use heapreplace instead of pop + push
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

heap = [1, 3, 5]

# âŒ SLOWER: Two operations
old_min = heapq.heappop(heap)
heapq.heappush(heap, 10)

# âœ… FASTER: Single operation
old_min = heapq.heapreplace(heap, 10)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TIP 3: Use heapify instead of n pushes
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

arr = [5, 3, 8, 1, 2, 9, 4]

# âŒ SLOWER: O(n log n)
heap = []
for x in arr:
    heapq.heappush(heap, x)

# âœ… FASTER: O(n)
heap = arr.copy()
heapq.heapify(heap)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TIP 4: Choose right method for top-k
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
k = 3

# For small k relative to n:
result = heapq.nlargest(k, arr)  # O(n + k log n)

# For k close to n, just sort:
result = sorted(arr, reverse=True)[:k]  # O(n log n)

# Rule of thumb:
# k < n / log(n): use nlargest/nsmallest
# k â‰ˆ n: use sorted
```

## 10.2.2 Memory Optimization

```python
import heapq

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TIP 5: Keep heap size bounded for top-k problems
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def top_k_memory_efficient(stream, k):
    """
    Process potentially infinite stream with O(k) space.
    """
    heap = []
    
    for item in stream:
        if len(heap) < k:
            heapq.heappush(heap, item)
        elif item > heap[0]:
            heapq.heapreplace(heap, item)
        # Items smaller than k-th largest are discarded immediately!
    
    return heap


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TIP 6: Use generator for lazy evaluation
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def merge_k_sorted_lazy(sorted_lists):
    """
    Generator that yields merged elements one at a time.
    Useful when you don't need all results at once.
    """
    heap = []
    
    for i, lst in enumerate(sorted_lists):
        if lst:
            heapq.heappush(heap, (lst[0], i, 0))
    
    while heap:
        val, list_idx, elem_idx = heapq.heappop(heap)
        yield val  # Lazy! Memory efficient
        
        if elem_idx + 1 < len(sorted_lists[list_idx]):
            next_val = sorted_lists[list_idx][elem_idx + 1]
            heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))
```

---

# 10.3 Interview Strategy

## 10.3.1 Pattern Recognition Checklist

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   HEAP PATTERN RECOGNITION                                â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                           â•‘
â•‘  ASK YOURSELF:                                                            â•‘
â•‘                                                                           â•‘
â•‘  â–¡ "Top K" / "K largest" / "K smallest" / "K most frequent"?             â•‘
â•‘    â†’ Use heap of size K (opposite type)                                   â•‘
â•‘                                                                           â•‘
â•‘  â–¡ "Median" / "middle element" / "balance two halves"?                   â•‘
â•‘    â†’ Use two heaps (max-heap + min-heap)                                 â•‘
â•‘                                                                           â•‘
â•‘  â–¡ "Merge K sorted" / "K lists" / "K arrays"?                            â•‘
â•‘    â†’ Use min-heap of size K                                               â•‘
â•‘                                                                           â•‘
â•‘  â–¡ "Schedule" / "cooldown" / "rearrange" / "no adjacent same"?           â•‘
â•‘    â†’ Use max-heap by frequency                                            â•‘
â•‘                                                                           â•‘
â•‘  â–¡ "Shortest path" / "minimum cost path" / "weighted graph"?             â•‘
â•‘    â†’ Dijkstra with min-heap                                               â•‘
â•‘                                                                           â•‘
â•‘  â–¡ "Meeting rooms" / "overlapping intervals" / "minimum resources"?      â•‘
â•‘    â†’ Sort by start, min-heap of end times                                 â•‘
â•‘                                                                           â•‘
â•‘  â–¡ "Sliding window" + "min/max"?                                         â•‘
â•‘    â†’ Heap with lazy deletion (or monotonic deque)                        â•‘
â•‘                                                                           â•‘
â•‘  â–¡ "Greedy selection" + "constraints"?                                   â•‘
â•‘    â†’ Sort by constraint, heap by value                                    â•‘
â•‘                                                                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

## 10.3.2 Communication Template

```
STEP-BY-STEP INTERVIEW APPROACH:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. CLARIFY THE PROBLEM (1-2 min)
   "Let me make sure I understand..."
   â€¢ Input format and constraints
   â€¢ Output requirements
   â€¢ Edge cases (empty input, k > n, duplicates)

2. IDENTIFY THE PATTERN (1 min)
   "This looks like a [pattern] problem because..."
   â€¢ Explain why heap is suitable
   â€¢ Mention the specific pattern (Top K, Two Heaps, etc.)

3. EXPLAIN APPROACH (2-3 min)
   "My approach will be to..."
   â€¢ High-level algorithm
   â€¢ Why this heap type (min vs max)
   â€¢ Key invariants to maintain

4. STATE COMPLEXITY BEFORE CODING
   "This will be O(n log k) time and O(k) space because..."
   â€¢ Show you understand the complexity
   â€¢ Interviewers love this!

5. CODE WITH COMMENTS (10-15 min)
   â€¢ Write clean, readable code
   â€¢ Add brief comments for key steps
   â€¢ Use meaningful variable names

6. TRACE THROUGH EXAMPLE (2-3 min)
   â€¢ Walk through with the given example
   â€¢ Show heap state at key points
   â€¢ Verify output matches expected

7. DISCUSS EDGE CASES & OPTIMIZATIONS (2 min)
   â€¢ Empty input
   â€¢ k = 0, k = 1, k = n
   â€¢ Possible optimizations
```

## 10.3.3 Complexity Quick Reference

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                     COMPLEXITY CHEAT SHEET                                â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                           â•‘
â•‘  PATTERN                  â”‚ TIME              â”‚ SPACE                     â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â•‘
â•‘  Top K elements           â”‚ O(n log k)        â”‚ O(k)                      â•‘
â•‘  Kth element (heap)       â”‚ O(n log k)        â”‚ O(k)                      â•‘
â•‘  Kth element (quickselect)â”‚ O(n) avg, O(nÂ²) â†“ â”‚ O(1)                      â•‘
â•‘  Find median (stream)     â”‚ O(log n) per add  â”‚ O(n)                      â•‘
â•‘  Merge K sorted lists     â”‚ O(N log k)        â”‚ O(k)                      â•‘
â•‘  Heap sort                â”‚ O(n log n)        â”‚ O(1)                      â•‘
â•‘  Build heap (heapify)     â”‚ O(n)              â”‚ O(1)                      â•‘
â•‘  Dijkstra                 â”‚ O((V+E) log V)    â”‚ O(V)                      â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â•‘
â•‘                                                                           â•‘
â•‘  N = total elements, n = array size, k = parameter                       â•‘
â•‘  V = vertices, E = edges                                                  â•‘
â•‘                                                                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

# 10.4 Debugging Tips

## 10.4.1 Common Bugs and Fixes

```python
import heapq

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DEBUG TIP 1: Print heap state at each step
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def debug_heap_operations(nums, k):
    """Example: Find kth largest with debug output"""
    heap = []
    
    print(f"Finding {k}th largest in {nums}")
    print("-" * 40)
    
    for i, num in enumerate(nums):
        print(f"Step {i+1}: Processing {num}")
        heapq.heappush(heap, num)
        print(f"  After push: {heap}")
        
        if len(heap) > k:
            removed = heapq.heappop(heap)
            print(f"  Removed: {removed}")
        
        print(f"  Current heap: {heap}")
        print()
    
    print(f"Result: {heap[0]}")
    return heap[0]

# debug_heap_operations([3, 2, 1, 5, 6, 4], 2)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DEBUG TIP 2: Verify heap property
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def is_valid_min_heap(arr):
    """Check if array satisfies min-heap property"""
    n = len(arr)
    for i in range(n):
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n and arr[i] > arr[left]:
            print(f"Violation at index {i}: {arr[i]} > left child {arr[left]}")
            return False
        if right < n and arr[i] > arr[right]:
            print(f"Violation at index {i}: {arr[i]} > right child {arr[right]}")
            return False
    
    return True


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DEBUG TIP 3: Visualize heap as tree
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def visualize_heap(heap):
    """Print heap as a tree structure"""
    if not heap:
        print("Empty heap")
        return
    
    import math
    n = len(heap)
    height = int(math.log2(n)) + 1
    
    print("Heap visualization:")
    idx = 0
    for level in range(height):
        nodes_at_level = 2 ** level
        level_values = []
        
        for _ in range(nodes_at_level):
            if idx < n:
                level_values.append(str(heap[idx]))
                idx += 1
        
        spacing = " " * (2 ** (height - level))
        print(spacing.join(level_values).center(40))
    print()

# Example:
heap = [1, 3, 2, 7, 5, 4, 6]
visualize_heap(heap)
```

## 10.4.2 Testing Your Solution

```python
import heapq
import random

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TEST HELPER: Compare against brute force
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def test_kth_largest():
    """Test kth largest implementation against brute force"""
    
    def kth_largest_heap(nums, k):
        heap = []
        for num in nums:
            heapq.heappush(heap, num)
            if len(heap) > k:
                heapq.heappop(heap)
        return heap[0]
    
    def kth_largest_brute(nums, k):
        return sorted(nums, reverse=True)[k-1]
    
    # Run random tests
    for test in range(100):
        n = random.randint(1, 100)
        k = random.randint(1, n)
        nums = [random.randint(-1000, 1000) for _ in range(n)]
        
        heap_result = kth_largest_heap(nums, k)
        brute_result = kth_largest_brute(nums, k)
        
        if heap_result != brute_result:
            print(f"FAILED: nums={nums}, k={k}")
            print(f"  Expected: {brute_result}, Got: {heap_result}")
            return False
    
    print("All tests passed!")
    return True

# test_kth_largest()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TEST HELPER: Edge cases
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def test_edge_cases():
    """Test common edge cases"""
    
    test_cases = [
        # (description, nums, k, expected)
        ("Single element", [5], 1, 5),
        ("K equals N", [3, 1, 2], 3, 1),
        ("K equals 1", [3, 1, 2], 1, 3),
        ("All same elements", [5, 5, 5, 5], 2, 5),
        ("Negative numbers", [-1, -5, -3], 2, -3),
        ("Already sorted", [1, 2, 3, 4, 5], 3, 3),
        ("Reverse sorted", [5, 4, 3, 2, 1], 3, 3),
    ]
    
    def kth_largest(nums, k):
        heap = []
        for num in nums:
            heapq.heappush(heap, num)
            if len(heap) > k:
                heapq.heappop(heap)
        return heap[0]
    
    for desc, nums, k, expected in test_cases:
        result = kth_largest(nums, k)
        status = "âœ“" if result == expected else "âœ—"
        print(f"{status} {desc}: got {result}, expected {expected}")

# test_edge_cases()
```

---

# 10.5 Final Interview Checklist

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    FINAL INTERVIEW CHECKLIST                              â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                           â•‘
â•‘  BEFORE THE INTERVIEW:                                                    â•‘
â•‘  â–¡ Review all 6 major patterns                                            â•‘
â•‘  â–¡ Practice 10+ heap problems on LeetCode                                 â•‘
â•‘  â–¡ Memorize complexity for common operations                              â•‘
â•‘  â–¡ Know Python heapq API by heart                                         â•‘
â•‘  â–¡ Practice explaining your thought process aloud                         â•‘
â•‘                                                                           â•‘
â•‘  DURING PROBLEM SOLVING:                                                  â•‘
â•‘  â–¡ Clarify constraints (size limits, duplicates, negatives)               â•‘
â•‘  â–¡ Identify the pattern before coding                                     â•‘
â•‘  â–¡ State time/space complexity upfront                                    â•‘
â•‘  â–¡ Use correct heap type (min for k-largest, max for k-smallest)          â•‘
â•‘  â–¡ Handle edge cases (empty, k=1, k=n)                                    â•‘
â•‘  â–¡ Use tiebreaker for incomparable objects                                â•‘
â•‘  â–¡ Trace through example to verify                                        â•‘
â•‘                                                                           â•‘
â•‘  KEY FACTS TO REMEMBER:                                                   â•‘
â•‘  â–¡ heapq is MIN-HEAP only (negate for max-heap)                          â•‘
â•‘  â–¡ Build heap is O(n), NOT O(n log n)                                    â•‘
â•‘  â–¡ Heap sort is O(n log n) always, O(1) space, NOT stable                â•‘
â•‘  â–¡ K largest â†’ min-heap of size K                                        â•‘
â•‘  â–¡ K smallest â†’ max-heap of size K                                       â•‘
â•‘  â–¡ Median â†’ two heaps (max + min)                                        â•‘
â•‘                                                                           â•‘
â•‘  COMMON INTERVIEW QUESTIONS:                                              â•‘
â•‘  â–¡ Why is build heap O(n)?                                               â•‘
â•‘  â–¡ Why use opposite heap type for top-K?                                 â•‘
â•‘  â–¡ When would you use Fibonacci heap?                                    â•‘
â•‘  â–¡ Why is heap sort not stable?                                          â•‘
â•‘  â–¡ Compare heap vs BST for priority queue                                â•‘
â•‘                                                                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

# 10.6 Quick Reference Card

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         HEAP MASTER CHEAT SHEET                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  PYTHON HEAPQ:                                                              â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚  import heapq                                                               â”‚
â”‚  heapq.heappush(h, x)      # Push x onto heap                              â”‚
â”‚  heapq.heappop(h)          # Pop smallest                                  â”‚
â”‚  heapq.heapify(arr)        # Convert list to heap in-place O(n)           â”‚
â”‚  heapq.heappushpop(h, x)   # Push then pop (optimized)                    â”‚
â”‚  heapq.heapreplace(h, x)   # Pop then push (optimized)                    â”‚
â”‚  heapq.nlargest(k, arr)    # K largest elements                           â”‚
â”‚  heapq.nsmallest(k, arr)   # K smallest elements                          â”‚
â”‚  h[0]                      # Peek at smallest (don't pop)                 â”‚
â”‚                                                                             â”‚
â”‚  MAX-HEAP TRICK:                                                            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚  heapq.heappush(h, -x)     # Push negated value                           â”‚
â”‚  -heapq.heappop(h)         # Pop and negate back                          â”‚
â”‚                                                                             â”‚
â”‚  INDEX FORMULAS (0-based):                                                  â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚  parent(i) = (i - 1) // 2                                                  â”‚
â”‚  left(i)   = 2 * i + 1                                                     â”‚
â”‚  right(i)  = 2 * i + 2                                                     â”‚
â”‚  last_non_leaf = n // 2 - 1                                                â”‚
â”‚                                                                             â”‚
â”‚  PATTERN â†’ HEAP TYPE:                                                       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚  K largest    â†’ Min-heap of size K                                         â”‚
â”‚  K smallest   â†’ Max-heap of size K                                         â”‚
â”‚  Median       â†’ Max-heap (small) + Min-heap (large)                       â”‚
â”‚  Merge K      â†’ Min-heap of K elements                                    â”‚
â”‚  Task sched   â†’ Max-heap by frequency                                      â”‚
â”‚  Dijkstra     â†’ Min-heap of (distance, node)                              â”‚
â”‚                                                                             â”‚
â”‚  TIME COMPLEXITY:                                                           â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚  Build heap:    O(n)                                                       â”‚
â”‚  Push/Pop:      O(log n)                                                   â”‚
â”‚  Peek:          O(1)                                                       â”‚
â”‚  Heap sort:     O(n log n)                                                 â”‚
â”‚  Top K:         O(n log k)                                                 â”‚
â”‚  Merge K lists: O(N log k)                                                 â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# Congratulations! ğŸ‰

You've completed the **Complete Heap Data Structure Mastery Guide**!

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                           â•‘
â•‘    SUMMARY OF YOUR LEARNING JOURNEY:                                      â•‘
â•‘                                                                           â•‘
â•‘    Chapter 1:  Foundations - What is a heap, types, array representation  â•‘
â•‘    Chapter 2:  Core Operations - Heapify, build heap, extract             â•‘
â•‘    Chapter 3:  Implementation - Python heapq, custom comparators          â•‘
â•‘    Chapter 4:  Priority Queue - Lazy deletion, indexed PQ                 â•‘
â•‘    Chapter 5:  Classic Patterns - Top K, Two Heaps, Merge K               â•‘
â•‘    Chapter 6:  Advanced Patterns - Dijkstra, Skyline, IPO                 â•‘
â•‘    Chapter 7:  Heap Variants - D-ary, Min-Max, Binomial, Fibonacci        â•‘
â•‘    Chapter 8:  Heap Sort - Algorithm, analysis, comparisons               â•‘
â•‘    Chapter 9:  Interview Questions - 25+ problems with solutions          â•‘
â•‘    Chapter 10: Tips & Tricks - Avoid mistakes, optimize, ace interview    â•‘
â•‘                                                                           â•‘
â•‘    NOW GO ACE THAT INTERVIEW! ğŸš€                                          â•‘
â•‘                                                                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```
