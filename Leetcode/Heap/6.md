# Chapter 6: Advanced Heap Patterns
## Complex Interview Problems and Solutions

---

# 6.1 Advanced Patterns Overview

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    ADVANCED HEAP PATTERNS                                 ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  1. DIJKSTRA'S ALGORITHM      → Shortest path in weighted graph           ║
║  2. SLIDING WINDOW + HEAP     → Range queries with element expiry         ║
║  3. K-WAY MERGE VARIANTS      → Constrained pair/combination finding      ║
║  4. GREEDY + TWO HEAPS        → IPO, maximize under constraints           ║
║  5. BFS + HEAP (Multi-source) → Trapping Rain Water II                    ║
║  6. CUSTOM ORDERING           → Skyline problem                           ║
║                                                                           ║
║  These patterns combine heap with other techniques:                       ║
║  • Graph traversal (BFS/DFS)                                             ║
║  • Greedy algorithms                                                      ║
║  • Sliding window                                                         ║
║  • Coordinate compression                                                 ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

---

# 6.2 Pattern 1: Dijkstra's Algorithm

## 6.2.1 Understanding Dijkstra

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    DIJKSTRA'S SHORTEST PATH                               ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  PROBLEM: Find shortest path from source to all vertices in weighted      ║
║           graph with non-negative edge weights.                           ║
║                                                                           ║
║  KEY INSIGHT: Always process the unvisited vertex with smallest distance  ║
║               This is where heap shines!                                  ║
║                                                                           ║
║  WITHOUT HEAP: O(V²) - scan all vertices to find minimum                 ║
║  WITH HEAP:    O((V + E) log V) - extract-min in O(log V)                ║
║                                                                           ║
║  ALGORITHM:                                                               ║
║  1. Initialize: dist[source] = 0, all others = ∞                         ║
║  2. Push (0, source) to min-heap                                         ║
║  3. While heap not empty:                                                 ║
║     a. Pop vertex u with minimum distance                                 ║
║     b. If already processed with better dist, skip (lazy deletion)        ║
║     c. For each neighbor v of u:                                          ║
║        - If dist[u] + weight(u,v) < dist[v]:                             ║
║          - Update dist[v]                                                 ║
║          - Push (dist[v], v) to heap                                     ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 6.2.2 Visual Walkthrough

```
GRAPH:
                    4
            A ─────────► B
            │╲           │
          2 │  ╲1        │ 1
            │    ╲       │
            ▼      ╲     ▼
            C ──────► D ──► E
                3       2

DIJKSTRA FROM A:
═════════════════════════════════════════════════════════════════════════════

Initial State:
  dist = {A: 0, B: ∞, C: ∞, D: ∞, E: ∞}
  heap = [(0, A)]

─────────────────────────────────────────────────────────────────────────────
Step 1: Pop (0, A)
─────────────────────────────────────────────────────────────────────────────
  Process A's neighbors:
  • A → B (weight 4): dist[B] = min(∞, 0+4) = 4, push (4, B)
  • A → C (weight 2): dist[C] = min(∞, 0+2) = 2, push (2, C)
  • A → D (weight 1): dist[D] = min(∞, 0+1) = 1, push (1, D)
  
  dist = {A: 0, B: 4, C: 2, D: 1, E: ∞}
  heap = [(1, D), (2, C), (4, B)]
  
            1
           / \
          2   4

─────────────────────────────────────────────────────────────────────────────
Step 2: Pop (1, D) - smallest distance!
─────────────────────────────────────────────────────────────────────────────
  Process D's neighbors:
  • D → E (weight 2): dist[E] = min(∞, 1+2) = 3, push (3, E)
  
  dist = {A: 0, B: 4, C: 2, D: 1, E: 3}
  heap = [(2, C), (4, B), (3, E)]

─────────────────────────────────────────────────────────────────────────────
Step 3: Pop (2, C)
─────────────────────────────────────────────────────────────────────────────
  Process C's neighbors:
  • C → D (weight 3): dist[D] = min(1, 2+3) = 1 (no update, already better)
  
  dist = {A: 0, B: 4, C: 2, D: 1, E: 3}
  heap = [(3, E), (4, B)]

─────────────────────────────────────────────────────────────────────────────
Step 4: Pop (3, E)
─────────────────────────────────────────────────────────────────────────────
  E has no outgoing edges.
  
  heap = [(4, B)]

─────────────────────────────────────────────────────────────────────────────
Step 5: Pop (4, B)
─────────────────────────────────────────────────────────────────────────────
  Process B's neighbors:
  • B → D (weight 1): dist[D] = min(1, 4+1) = 1 (no update)
  
  heap = [] → DONE!

─────────────────────────────────────────────────────────────────────────────
FINAL DISTANCES FROM A:
  A: 0, B: 4, C: 2, D: 1, E: 3 ✓
```

## 6.2.3 Implementation

```python
import heapq
from collections import defaultdict
from typing import Dict, List, Tuple

# ═══════════════════════════════════════════════════════════════════════════
# DIJKSTRA'S ALGORITHM - STANDARD IMPLEMENTATION
# ═══════════════════════════════════════════════════════════════════════════

def dijkstra(graph: Dict[str, List[Tuple[str, int]]], start: str) -> Dict[str, int]:
    """
    Find shortest distances from start to all vertices.
    
    graph: adjacency list {node: [(neighbor, weight), ...]}
    
    Time: O((V + E) log V)
    Space: O(V) for distances + O(V) for heap
    """
    # Initialize distances
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    
    # Min-heap: (distance, node)
    heap = [(0, start)]
    
    while heap:
        d, u = heapq.heappop(heap)
        
        # LAZY DELETION: Skip if we've found a better path
        if d > dist[u]:
            continue
        
        # Relax edges
        for v, weight in graph[u]:
            new_dist = dist[u] + weight
            if new_dist < dist[v]:
                dist[v] = new_dist
                heapq.heappush(heap, (new_dist, v))
    
    return dist


# ═══════════════════════════════════════════════════════════════════════════
# DIJKSTRA WITH PATH RECONSTRUCTION
# ═══════════════════════════════════════════════════════════════════════════

def dijkstra_with_path(graph, start, end):
    """
    Find shortest path and distance from start to end.
    
    Returns: (distance, path)
    """
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    parent = {start: None}
    
    heap = [(0, start)]
    
    while heap:
        d, u = heapq.heappop(heap)
        
        if u == end:
            break
        
        if d > dist[u]:
            continue
        
        for v, weight in graph[u]:
            new_dist = dist[u] + weight
            if new_dist < dist[v]:
                dist[v] = new_dist
                parent[v] = u
                heapq.heappush(heap, (new_dist, v))
    
    # Reconstruct path
    if dist[end] == float('inf'):
        return float('inf'), []
    
    path = []
    node = end
    while node is not None:
        path.append(node)
        node = parent[node]
    path.reverse()
    
    return dist[end], path


# ═══════════════════════════════════════════════════════════════════════════
# NETWORK DELAY TIME (LeetCode 743)
# ═══════════════════════════════════════════════════════════════════════════

def networkDelayTime(times: List[List[int]], n: int, k: int) -> int:
    """
    Time for signal to reach all nodes from node k.
    
    times[i] = [u, v, w] means edge from u to v with weight w
    n = number of nodes (1 to n)
    k = source node
    
    Returns: minimum time, or -1 if impossible
    """
    # Build adjacency list
    graph = defaultdict(list)
    for u, v, w in times:
        graph[u].append((v, w))
    
    # Dijkstra
    dist = {i: float('inf') for i in range(1, n + 1)}
    dist[k] = 0
    heap = [(0, k)]
    
    while heap:
        d, u = heapq.heappop(heap)
        
        if d > dist[u]:
            continue
        
        for v, w in graph[u]:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                heapq.heappush(heap, (dist[v], v))
    
    max_dist = max(dist.values())
    return max_dist if max_dist < float('inf') else -1


# ═══════════════════════════════════════════════════════════════════════════
# PATH WITH MINIMUM EFFORT (LeetCode 1631)
# ═══════════════════════════════════════════════════════════════════════════

def minimumEffortPath(heights: List[List[int]]) -> int:
    """
    Find path from top-left to bottom-right minimizing maximum absolute 
    difference between consecutive cells.
    
    Modified Dijkstra: minimize max edge weight on path instead of sum.
    """
    rows, cols = len(heights), len(heights[0])
    
    # dist[r][c] = minimum effort to reach (r, c)
    dist = [[float('inf')] * cols for _ in range(rows)]
    dist[0][0] = 0
    
    # (effort, row, col)
    heap = [(0, 0, 0)]
    
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    while heap:
        effort, r, c = heapq.heappop(heap)
        
        if r == rows - 1 and c == cols - 1:
            return effort
        
        if effort > dist[r][c]:
            continue
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            if 0 <= nr < rows and 0 <= nc < cols:
                # Effort = max of (current path effort, this edge effort)
                edge_effort = abs(heights[nr][nc] - heights[r][c])
                new_effort = max(effort, edge_effort)
                
                if new_effort < dist[nr][nc]:
                    dist[nr][nc] = new_effort
                    heapq.heappush(heap, (new_effort, nr, nc))
    
    return dist[rows-1][cols-1]
```

---

# 6.3 Pattern 2: Sliding Window with Heap

## 6.3.1 The Challenge

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    SLIDING WINDOW + HEAP                                  ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  PROBLEM: Track min/max in a sliding window                               ║
║                                                                           ║
║  CHALLENGE: Elements leave the window, but heap doesn't support           ║
║             efficient removal of arbitrary elements!                      ║
║                                                                           ║
║  SOLUTION: Lazy Deletion                                                  ║
║  - Store (value, index) in heap                                           ║
║  - When top element's index is outside window, pop it                     ║
║  - Only "clean" when we need the top element                              ║
║                                                                           ║
║  Window: [1, 3, -1, -3, 5, 3], k=3                                        ║
║                                                                           ║
║          [1, 3, -1]              max = 3                                  ║
║             [3, -1, -3]          max = 3                                  ║
║                [-1, -3, 5]       max = 5                                  ║
║                    [-3, 5, 3]    max = 5                                  ║
║                                                                           ║
║  Note: Deque is optimal O(n) for this. Heap is O(n log n) but            ║
║        generalizes better to complex scenarios.                           ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 6.3.2 Implementation

```python
import heapq
from typing import List

# ═══════════════════════════════════════════════════════════════════════════
# SLIDING WINDOW MAXIMUM (LeetCode 239) - HEAP APPROACH
# ═══════════════════════════════════════════════════════════════════════════

def maxSlidingWindow(nums: List[int], k: int) -> List[int]:
    """
    Find maximum in each sliding window of size k.
    
    Approach: Max-heap with lazy deletion based on index
    
    Time: O(n log n) - each element pushed/popped once, but lazy deletion
          can defer pops
    Space: O(n) worst case for heap
    
    Note: Monotonic deque achieves O(n), but heap generalizes better.
    """
    if not nums or k == 0:
        return []
    
    result = []
    # Max-heap: (-value, index) - negate for max-heap behavior
    heap = []
    
    for i in range(len(nums)):
        # Add current element
        heapq.heappush(heap, (-nums[i], i))
        
        # Remove elements outside the window (lazy deletion)
        while heap[0][1] <= i - k:
            heapq.heappop(heap)
        
        # Record result once we have a full window
        if i >= k - 1:
            result.append(-heap[0][0])
    
    return result


# ═══════════════════════════════════════════════════════════════════════════
# CONSTRAINED SUBSEQUENCE SUM (LeetCode 1425)
# ═══════════════════════════════════════════════════════════════════════════

def constrainedSubsetSum(nums: List[int], k: int) -> int:
    """
    Maximum sum of non-empty subsequence where consecutive elements
    in the original array are at most k indices apart.
    
    DP + Heap: dp[i] = max sum ending at i
    dp[i] = nums[i] + max(0, max(dp[j])) for j in [i-k, i-1]
    
    Use max-heap to track maximum dp value in the window.
    
    Time: O(n log n)
    Space: O(n)
    """
    n = len(nums)
    dp = [0] * n
    # Max-heap: (-dp_value, index)
    heap = []
    
    for i in range(n):
        # Clean heap: remove elements outside window [i-k, i-1]
        while heap and heap[0][1] < i - k:
            heapq.heappop(heap)
        
        # dp[i] = nums[i] + max(0, max_dp_in_window)
        max_prev = -heap[0][0] if heap else 0
        dp[i] = nums[i] + max(0, max_prev)
        
        # Add current dp[i] to heap
        heapq.heappush(heap, (-dp[i], i))
    
    return max(dp)


# ═══════════════════════════════════════════════════════════════════════════
# JUMP GAME VI (LeetCode 1696)
# ═══════════════════════════════════════════════════════════════════════════

def maxResult(nums: List[int], k: int) -> int:
    """
    Maximum score to reach the last index, where you can jump 1 to k steps.
    
    dp[i] = maximum score to reach index i
    dp[i] = nums[i] + max(dp[i-k], dp[i-k+1], ..., dp[i-1])
    
    Time: O(n log n)
    Space: O(n)
    """
    n = len(nums)
    dp = [float('-inf')] * n
    dp[0] = nums[0]
    
    # Max-heap: (-dp_value, index)
    heap = [(-dp[0], 0)]
    
    for i in range(1, n):
        # Remove elements outside window
        while heap[0][1] < i - k:
            heapq.heappop(heap)
        
        # dp[i] = nums[i] + max dp in window
        dp[i] = nums[i] + (-heap[0][0])
        
        heapq.heappush(heap, (-dp[i], i))
    
    return dp[n - 1]


# Trace example:
# nums = [1, -1, -2, 4, -7, 3], k = 2
# 
# i=0: dp[0] = 1, heap = [(-1, 0)]
# i=1: max in [0,0] = 1, dp[1] = -1 + 1 = 0, heap = [(-1, 0), (0, 1)]
# i=2: max in [0,1] = 1, dp[2] = -2 + 1 = -1, heap = [(-1, 0), (0, 1), (1, 2)]
# i=3: Clean: 0 < 3-2=1, pop (-1,0). max in [1,2] = 0
#      dp[3] = 4 + 0 = 4, heap = [(-4, 3), (0, 1), (1, 2)]
# i=4: Clean: 1 < 4-2=2, pop (0,1). max in [2,3] = 4
#      dp[4] = -7 + 4 = -3, heap = [(-4, 3), (1, 2), (3, 4)]
# i=5: Clean: 2 < 5-2=3, pop (1,2). max in [3,4] = 4
#      dp[5] = 3 + 4 = 7
# 
# Result: 7
```

---

# 6.4 Pattern 3: K-way Merge with Constraints

## 6.4.1 The Pattern

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    K-WAY MERGE WITH CONSTRAINTS                           ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  PROBLEM: Find K smallest/largest combinations from multiple sources      ║
║           Example: K pairs with smallest sums from two arrays             ║
║                                                                           ║
║  KEY INSIGHT: Treat it as a graph/matrix traversal                        ║
║  - Start from the "smallest" point                                        ║
║  - Use heap to explore in order of increasing cost                        ║
║  - Track visited states to avoid duplicates                               ║
║                                                                           ║
║  For two sorted arrays nums1, nums2:                                      ║
║                                                                           ║
║              nums2[0]  nums2[1]  nums2[2]  ...                            ║
║  nums1[0]      *───────►─────────►                                       ║
║                │                                                          ║
║  nums1[1]      ▼                                                          ║
║                │                                                          ║
║  nums1[2]      ▼                                                          ║
║                                                                           ║
║  Start at (0,0), expand right and down, use heap to get K smallest        ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 6.4.2 Implementation

```python
import heapq
from typing import List

# ═══════════════════════════════════════════════════════════════════════════
# FIND K PAIRS WITH SMALLEST SUMS (LeetCode 373)
# ═══════════════════════════════════════════════════════════════════════════

def kSmallestPairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
    """
    Find k pairs (u, v) with smallest sums u + v,
    where u is from nums1 and v is from nums2.
    
    Both arrays are sorted in ascending order.
    
    Approach: BFS-like exploration with min-heap
    - Start with (nums1[0], nums2[0])
    - Each step, consider (i+1, j) and (i, j+1)
    - Use set to avoid revisiting
    
    Time: O(k log k)
    Space: O(k) for heap and visited set
    """
    if not nums1 or not nums2:
        return []
    
    result = []
    # Heap: (sum, index_in_nums1, index_in_nums2)
    heap = [(nums1[0] + nums2[0], 0, 0)]
    visited = {(0, 0)}
    
    while heap and len(result) < k:
        _, i, j = heapq.heappop(heap)
        result.append([nums1[i], nums2[j]])
        
        # Explore (i+1, j)
        if i + 1 < len(nums1) and (i + 1, j) not in visited:
            visited.add((i + 1, j))
            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))
        
        # Explore (i, j+1)
        if j + 1 < len(nums2) and (i, j + 1) not in visited:
            visited.add((i, j + 1))
            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))
    
    return result


# ═══════════════════════════════════════════════════════════════════════════
# KTH SMALLEST ELEMENT IN SORTED MATRIX (LeetCode 378)
# ═══════════════════════════════════════════════════════════════════════════

def kthSmallest(matrix: List[List[int]], k: int) -> int:
    """
    Find kth smallest element in n x n matrix where each row and column
    is sorted in ascending order.
    
    Time: O(k log n)
    Space: O(n)
    """
    n = len(matrix)
    
    # Start with first element of each row
    # Heap: (value, row, col)
    heap = [(matrix[i][0], i, 0) for i in range(min(n, k))]
    heapq.heapify(heap)
    
    for _ in range(k):
        val, r, c = heapq.heappop(heap)
        
        if _ == k - 1:
            return val
        
        # Push next element from the same row
        if c + 1 < n:
            heapq.heappush(heap, (matrix[r][c + 1], r, c + 1))
    
    return -1  # Should never reach here


# ═══════════════════════════════════════════════════════════════════════════
# KTH SMALLEST PRIME FRACTION (LeetCode 786)
# ═══════════════════════════════════════════════════════════════════════════

def kthSmallestPrimeFraction(arr: List[int], k: int) -> List[int]:
    """
    Given sorted array of primes, find kth smallest fraction arr[i]/arr[j]
    where i < j.
    
    Matrix view: row i, col j → arr[i] / arr[j]
    Each row is sorted (ascending j = descending fraction)
    Each col is sorted (ascending i = ascending fraction)
    
    Time: O(k log n)
    Space: O(n)
    """
    n = len(arr)
    
    # Start with smallest fractions: arr[0]/arr[j] for all j
    # Heap: (fraction, i, j)
    heap = [(arr[0] / arr[j], 0, j) for j in range(1, n)]
    heapq.heapify(heap)
    
    for _ in range(k):
        frac, i, j = heapq.heappop(heap)
        
        if _ == k - 1:
            return [arr[i], arr[j]]
        
        # Next larger fraction in this "column": arr[i+1] / arr[j]
        if i + 1 < j:
            heapq.heappush(heap, (arr[i + 1] / arr[j], i + 1, j))
    
    return []
```

---

# 6.5 Pattern 4: Greedy with Two Data Structures

## 6.5.1 IPO Problem Pattern

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    GREEDY + TWO STRUCTURES PATTERN                        ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  PROBLEM: Select K items to maximize value under constraints              ║
║           Example: IPO - select projects to maximize capital              ║
║                                                                           ║
║  PATTERN:                                                                 ║
║  1. Sort items by constraint (e.g., required capital)                     ║
║  2. Use heap to track best available options                              ║
║  3. Greedy: always pick the best available option                         ║
║                                                                           ║
║  Two phases per selection:                                                ║
║  ┌─────────────────────────────────────────────────────────────────────┐ ║
║  │ PHASE 1: Move all now-affordable items to "available" heap          │ ║
║  │ PHASE 2: Pick the best (max profit) from available heap             │ ║
║  └─────────────────────────────────────────────────────────────────────┘ ║
║                                                                           ║
║  SORTED BY              MAX-HEAP                                          ║
║  CAPITAL NEEDED         (PROFIT)                                          ║
║                                                                           ║
║  [(1, 10), (2, 20), ...]   →   Current capital allows ≤ 2                ║
║   ↑ now affordable             [20, 10]                                  ║
║                                  ↑ pick this!                            ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 6.5.2 Implementation

```python
import heapq
from typing import List

# ═══════════════════════════════════════════════════════════════════════════
# IPO (LeetCode 502)
# ═══════════════════════════════════════════════════════════════════════════

def findMaximizedCapital(k: int, w: int, profits: List[int], capital: List[int]) -> int:
    """
    Maximize capital by completing at most k projects.
    
    k: maximum number of projects
    w: initial capital
    profits[i]: profit of project i
    capital[i]: minimum capital needed to start project i
    
    Approach:
    1. Sort projects by capital needed
    2. For each selection:
       - Add all affordable projects to max-heap (by profit)
       - Pick the most profitable
    
    Time: O(n log n) for sorting + O(k log n) for selections
    Space: O(n)
    """
    # Pair and sort by capital required
    projects = sorted(zip(capital, profits))
    
    # Max-heap of profits (available projects)
    available = []
    idx = 0
    n = len(profits)
    
    for _ in range(k):
        # Move all affordable projects to available heap
        while idx < n and projects[idx][0] <= w:
            cap, profit = projects[idx]
            heapq.heappush(available, -profit)  # Max-heap
            idx += 1
        
        # If no project available, stop
        if not available:
            break
        
        # Pick the most profitable project
        w += -heapq.heappop(available)
    
    return w


# ═══════════════════════════════════════════════════════════════════════════
# MAXIMUM PERFORMANCE OF A TEAM (LeetCode 1383)
# ═══════════════════════════════════════════════════════════════════════════

def maxPerformance(n: int, speed: List[int], efficiency: List[int], k: int) -> int:
    """
    Select at most k engineers to maximize performance.
    Performance = sum(speed) * min(efficiency)
    
    Key insight: Fix minimum efficiency, then want maximum speed sum.
    
    Approach:
    1. Sort by efficiency descending
    2. Iterate: current engineer has minimum efficiency
    3. Keep top k-1 speeds seen so far (max speed sum)
    
    Time: O(n log n + n log k)
    Space: O(k)
    """
    MOD = 10**9 + 7
    
    # Sort by efficiency descending
    engineers = sorted(zip(efficiency, speed), reverse=True)
    
    # Min-heap to keep track of top k speeds
    speed_heap = []
    speed_sum = 0
    max_perf = 0
    
    for eff, spd in engineers:
        # Add current engineer's speed
        heapq.heappush(speed_heap, spd)
        speed_sum += spd
        
        # If more than k engineers, remove slowest
        if len(speed_heap) > k:
            speed_sum -= heapq.heappop(speed_heap)
        
        # Current engineer has minimum efficiency
        # Performance = speed_sum * eff
        max_perf = max(max_perf, speed_sum * eff)
    
    return max_perf % MOD


# ═══════════════════════════════════════════════════════════════════════════
# MINIMUM COST TO HIRE K WORKERS (LeetCode 857)
# ═══════════════════════════════════════════════════════════════════════════

def mincostToHireWorkers(quality: List[int], wage: List[int], k: int) -> float:
    """
    Hire exactly k workers with minimum cost.
    
    Rules:
    - Pay in ratio of quality
    - Each worker paid at least their minimum wage
    
    Key insight: If we fix the "ratio" (wage/quality), then:
    - cost = ratio * total_quality
    - Ratio must be >= max(wage[i]/quality[i]) for selected workers
    
    Approach:
    1. Sort by wage/quality ratio
    2. Iterate: current worker sets the ratio (has highest ratio so far)
    3. Keep k-1 workers with lowest quality (minimize total quality)
    
    Time: O(n log n + n log k)
    Space: O(n)
    """
    # (ratio, quality)
    workers = sorted((w/q, q) for w, q in zip(wage, quality))
    
    # Max-heap of qualities (to remove highest quality = highest cost)
    quality_heap = []
    quality_sum = 0
    min_cost = float('inf')
    
    for ratio, q in workers:
        heapq.heappush(quality_heap, -q)  # Max-heap
        quality_sum += q
        
        if len(quality_heap) > k:
            quality_sum += heapq.heappop(quality_heap)  # Remove highest (negative)
        
        if len(quality_heap) == k:
            # Current worker sets the ratio (highest so far)
            cost = ratio * quality_sum
            min_cost = min(min_cost, cost)
    
    return min_cost
```

---

# 6.6 Pattern 5: Multi-Source BFS with Heap

## 6.6.1 Trapping Rain Water II

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    TRAPPING RAIN WATER II (3D)                            ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  PROBLEM: Given 2D elevation map, find how much water it can trap         ║
║                                                                           ║
║  KEY INSIGHT: Water level at any cell is determined by the                ║
║               MINIMUM boundary height surrounding it.                     ║
║                                                                           ║
║  APPROACH: Start from boundary (lowest walls first)                       ║
║  1. Add all boundary cells to min-heap                                    ║
║  2. Process cells in order of height                                      ║
║  3. For each cell, explore neighbors:                                     ║
║     - If neighbor is lower: can trap water!                               ║
║     - Water level = max(current_height, neighbor_height)                  ║
║                                                                           ║
║     Height Map:           Water Trapped:                                  ║
║     ┌───────────┐        ┌───────────┐                                   ║
║     │ 1 4 3 1 3 │        │ 0 0 0 0 0 │                                   ║
║     │ 3 2 1 3 2 │   →    │ 0 1 2 0 0 │                                   ║
║     │ 2 3 3 2 3 │        │ 0 0 0 0 0 │                                   ║
║     └───────────┘        └───────────┘                                   ║
║                          Total: 3 units                                   ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 6.6.2 Visual Walkthrough

```
HEIGHT MAP (3x5):
    Col:  0   1   2   3   4
Row 0:  [ 1,  4,  3,  1,  3 ]
Row 1:  [ 3,  2,  1,  3,  2 ]
Row 2:  [ 2,  3,  3,  2,  3 ]

STEP 1: Initialize - Add boundary cells to min-heap
═══════════════════════════════════════════════════

Boundary cells (sorted by height):
(1, 0, 0), (1, 0, 3), (2, 1, 4), (2, 2, 0), (2, 2, 3), 
(3, 0, 2), (3, 0, 4), (3, 1, 0), (3, 2, 1), (3, 2, 2), 
(3, 2, 4), (4, 0, 1)

Heap (min first): [(1, 0, 0), (1, 0, 3), ...]

STEP 2: Process (1, 0, 0) - height 1 at position (0,0)
═══════════════════════════════════════════════════════

Neighbors: (0,1)=4, (1,0)=3
All neighbors are on boundary or higher. No water trapped.

STEP 3: Process (1, 0, 3) - height 1 at position (0,3)
═══════════════════════════════════════════════════════

Neighbors: (0,2)=3, (0,4)=3, (1,3)=3
All higher. No water trapped.

STEP 4: Process (2, 1, 4) - height 2 at position (1,4)
═══════════════════════════════════════════════════════

Neighbors: (0,4)=3, (1,3)=3, (2,4)=3 (all boundary/visited)
No new cells.

... continue processing ...

STEP X: Process cell adjacent to (1,2) which has height 1
═════════════════════════════════════════════════════════════

Current water level from boundary: 3
Cell (1,2) has height 1
Water trapped at (1,2) = 3 - 1 = 2 units!

Similarly for (1,1): water level 3, height 2
Water trapped = 3 - 2 = 1 unit

TOTAL: 2 + 1 = 3 units ✓
```

## 6.6.3 Implementation

```python
import heapq
from typing import List

# ═══════════════════════════════════════════════════════════════════════════
# TRAPPING RAIN WATER II (LeetCode 407)
# ═══════════════════════════════════════════════════════════════════════════

def trapRainWater(heightMap: List[List[int]]) -> int:
    """
    Calculate volume of water trapped after raining on 2D elevation map.
    
    Approach: Multi-source BFS from boundary using min-heap
    - Process cells in order of height (like filling a container)
    - Water level at any point = height of lowest wall seen so far
    
    Time: O(mn log(mn)) where m,n are dimensions
    Space: O(mn)
    """
    if not heightMap or not heightMap[0]:
        return 0
    
    m, n = len(heightMap), len(heightMap[0])
    
    if m < 3 or n < 3:  # Need at least 3x3 to trap water
        return 0
    
    # Min-heap: (height, row, col)
    heap = []
    visited = [[False] * n for _ in range(m)]
    
    # Add all boundary cells to heap
    for i in range(m):
        for j in range(n):
            if i == 0 or i == m - 1 or j == 0 or j == n - 1:
                heapq.heappush(heap, (heightMap[i][j], i, j))
                visited[i][j] = True
    
    water = 0
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    while heap:
        height, row, col = heapq.heappop(heap)
        
        for dr, dc in directions:
            nr, nc = row + dr, col + dc
            
            if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc]:
                visited[nr][nc] = True
                
                # Water trapped = current boundary height - cell height
                # (only if boundary is higher)
                water += max(0, height - heightMap[nr][nc])
                
                # Add cell to heap with max(boundary_height, cell_height)
                # This becomes the new "effective height" for further exploration
                new_height = max(height, heightMap[nr][nc])
                heapq.heappush(heap, (new_height, nr, nc))
    
    return water


# ═══════════════════════════════════════════════════════════════════════════
# SWIM IN RISING WATER (LeetCode 778)
# ═══════════════════════════════════════════════════════════════════════════

def swimInWater(grid: List[List[int]]) -> int:
    """
    Find minimum time to swim from (0,0) to (n-1,n-1).
    At time t, can swim through cells with elevation <= t.
    
    This is finding path minimizing maximum cell value.
    Same as Dijkstra variant!
    
    Time: O(n² log n)
    Space: O(n²)
    """
    n = len(grid)
    
    # Min-heap: (max_height_on_path, row, col)
    heap = [(grid[0][0], 0, 0)]
    visited = [[False] * n for _ in range(n)]
    visited[0][0] = True
    
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    while heap:
        max_height, r, c = heapq.heappop(heap)
        
        if r == n - 1 and c == n - 1:
            return max_height
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            if 0 <= nr < n and 0 <= nc < n and not visited[nr][nc]:
                visited[nr][nc] = True
                # New path height = max of (current path max, new cell)
                new_max = max(max_height, grid[nr][nc])
                heapq.heappush(heap, (new_max, nr, nc))
    
    return -1  # Should never reach


# Example:
heightMap = [
    [1, 4, 3, 1, 3, 2],
    [3, 2, 1, 3, 2, 4],
    [2, 3, 3, 2, 3, 1]
]
print(trapRainWater(heightMap))  # 4
```

---

# 6.7 Pattern 6: The Skyline Problem

## 6.7.1 Understanding the Problem

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                    THE SKYLINE PROBLEM                                    ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  PROBLEM: Given building [left, right, height], find skyline contour      ║
║                                                                           ║
║  Buildings:                      Skyline:                                 ║
║                                                                           ║
║    ┌───┐                          ┌───┐                                   ║
║    │   │  ┌─────┐                 │   └──┐                               ║
║    │   │  │     │     →           │      └───┐                           ║
║  ┌─┤   ├──┤     │                 │          │                           ║
║  │ │   │  │     │                 │          │                           ║
║  ──┴───┴──┴─────┴──              ─┴──────────┴─                          ║
║                                                                           ║
║  Key points are where height changes!                                     ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

## 6.7.2 Implementation

```python
import heapq
from typing import List
from collections import defaultdict

# ═══════════════════════════════════════════════════════════════════════════
# THE SKYLINE PROBLEM (LeetCode 218)
# ═══════════════════════════════════════════════════════════════════════════

def getSkyline(buildings: List[List[int]]) -> List[List[int]]:
    """
    Find skyline formed by buildings.
    
    Approach:
    1. Create events for building start and end
    2. Process events left to right
    3. Use max-heap to track current maximum height
    4. When max height changes, record key point
    
    Time: O(n log n)
    Space: O(n)
    """
    # Create events: (x, type, height)
    # type: 0 = start (negative height for sorting), 1 = end
    events = []
    
    for left, right, height in buildings:
        events.append((left, -height, right))   # Start: negative height
        events.append((right, 0, 0))            # End: height 0
    
    # Sort: by x, then by height (start before end, taller before shorter)
    events.sort()
    
    # Max-heap: (-height, end_x)
    # Track active buildings
    heap = [(0, float('inf'))]  # Ground level
    result = []
    
    for x, neg_height, end in events:
        # Remove buildings that have ended
        while heap[0][1] <= x:
            heapq.heappop(heap)
        
        # If this is a start event, add building
        if neg_height != 0:
            heapq.heappush(heap, (neg_height, end))
        
        # Current max height
        max_height = -heap[0][0]
        
        # If height changed, record key point
        if not result or result[-1][1] != max_height:
            result.append([x, max_height])
    
    return result


# ═══════════════════════════════════════════════════════════════════════════
# ALTERNATIVE: Using Lazy Deletion
# ═══════════════════════════════════════════════════════════════════════════

def getSkylineLazy(buildings: List[List[int]]) -> List[List[int]]:
    """Alternative implementation with explicit lazy deletion"""
    
    if not buildings:
        return []
    
    # Events: (x, height, is_start)
    events = []
    for l, r, h in buildings:
        events.append((l, h, True))   # Start
        events.append((r, h, False))  # End
    
    # Sort: by x, starts before ends at same x, taller starts first
    events.sort(key=lambda e: (e[0], not e[1], -e[2] if e[1] else e[2]))
    
    result = []
    # Max-heap with lazy deletion
    heap = [0]  # Ground level
    ended = defaultdict(int)  # Heights that have ended
    
    for x, h, is_start in events:
        if is_start:
            heapq.heappush(heap, -h)
        else:
            ended[h] += 1
        
        # Clean up ended buildings
        while heap and ended[-heap[0]] > 0:
            ended[-heap[0]] -= 1
            heapq.heappop(heap)
        
        current_max = -heap[0] if heap else 0
        
        if not result or result[-1][1] != current_max:
            result.append([x, current_max])
    
    return result


# Example:
buildings = [[2,9,10], [3,7,15], [5,12,12], [15,20,10], [19,24,8]]
print(getSkyline(buildings))
# Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
```

---

# 6.8 Summary

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         CHAPTER 6 SUMMARY                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  DIJKSTRA'S ALGORITHM                                                       │
│  • Min-heap for next vertex selection: O((V+E) log V)                      │
│  • Lazy deletion: skip if dist[u] < popped distance                        │
│  • Variants: path reconstruction, minimize max edge                        │
│                                                                             │
│  SLIDING WINDOW + HEAP                                                      │
│  • Store (value, index) in heap                                            │
│  • Lazy deletion when index outside window                                  │
│  • Applications: DP optimization, range max/min                            │
│                                                                             │
│  K-WAY MERGE WITH CONSTRAINTS                                               │
│  • Treat as graph/matrix traversal                                         │
│  • BFS from starting point with min-heap                                   │
│  • Track visited states to avoid duplicates                                │
│                                                                             │
│  GREEDY + TWO STRUCTURES                                                    │
│  • Sort by constraint, heap by value                                       │
│  • Move affordable items to heap, pick best                                │
│  • Examples: IPO, max performance, hire workers                            │
│                                                                             │
│  MULTI-SOURCE BFS WITH HEAP                                                 │
│  • Start from boundary/multiple sources                                    │
│  • Process in order of "cost" using min-heap                              │
│  • Examples: Trapping Rain Water II, Swim in Rising Water                  │
│                                                                             │
│  SKYLINE PROBLEM                                                            │
│  • Event-based processing (starts and ends)                                │
│  • Max-heap to track current maximum                                       │
│  • Record key points when maximum changes                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

**You've completed Chapters 4-6! Continue to Chapter 7 for Heap Variants** →
