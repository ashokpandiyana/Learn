# Complete Heap Data Structure Mastery Guide
## From Beginner to Advanced - Interview Preparation

---

# Chapter 1: Foundations of Heap

## 1.1 What is a Heap?
- A **complete binary tree** stored in an array
- Satisfies the **heap property** (parent-child relationship)
- Not to be confused with memory heap (different concept)

### 1.1.1 Types of Heaps
| Type | Property |
|------|----------|
| **Max-Heap** | Parent â‰¥ Children |
| **Min-Heap** | Parent â‰¤ Children |

> ğŸ’¡ **Key Insight**: Heap is NOT a sorted structure. Only the root is guaranteed to be min/max.

## 1.2 Array Representation

For a node at index `i` (0-indexed):
```
Parent:       (i - 1) // 2
Left Child:   2 * i + 1
Right Child:  2 * i + 2
```

For 1-indexed:
```
Parent:       i // 2
Left Child:   2 * i
Right Child:  2 * i + 1
```

> âš ï¸ **Interview Tip**: Always clarify your indexing convention!

---

# Chapter 2: Core Heap Operations

## 2.1 Time Complexity Summary

| Operation | Time Complexity | Notes |
|-----------|-----------------|-------|
| Build Heap | **O(n)** | NOT O(n log n) |
| Insert (Push) | O(log n) | Bubble up |
| Extract Min/Max | O(log n) | Bubble down |
| Peek | O(1) | Return root |
| Delete arbitrary | O(log n) | With index known |
| Search | O(n) | Heap not optimized for search |
| Heapify (single) | O(log n) | Fix one violation |

> ğŸ”¥ **Critical**: Build Heap is O(n), not O(n log n). Be ready to prove this!

## 2.2 Heapify Up (Bubble Up / Sift Up)
- Used after **insertion**
- Compare with parent, swap if violates heap property
- Continue until root or property satisfied

```
Algorithm:
1. Start at inserted node (last position)
2. While node > parent (max-heap) or node < parent (min-heap):
   - Swap with parent
   - Move to parent position
```

## 2.3 Heapify Down (Bubble Down / Sift Down)
- Used after **extraction** or **deletion**
- Compare with children, swap with larger (max) or smaller (min) child
- Continue until leaf or property satisfied

```
Algorithm:
1. Start at root (or deleted position)
2. While node has children:
   - Find max/min child
   - If violates property, swap
   - Move to child position
3. Stop when property satisfied or at leaf
```

> ğŸ’¡ **Why swap with max/min child?** To maintain heap property for the other child as well.

## 2.4 Build Heap (Heapify Array)

### Method 1: Bottom-Up (Optimal - O(n))
```
Start from last non-leaf node (n//2 - 1)
Move backwards to root
Apply heapify-down on each node
```

### Method 2: Top-Down (O(n log n))
```
Insert elements one by one
Apply heapify-up after each insertion
```

> ğŸ”¥ **Must Know**: Mathematical proof that bottom-up is O(n):
> - Most nodes are near the bottom (do less work)
> - Fewer nodes at top (do more work)
> - Sum of work = O(n)

---

# Chapter 3: Heap Implementation Patterns

## 3.1 Python heapq Module

```python
import heapq

# Min-heap by default
heap = []
heapq.heappush(heap, 3)
heapq.heappop(heap)          # Extract min
heap[0]                       # Peek min
heapq.heapify(arr)           # Convert list to heap O(n)
heapq.heappushpop(heap, x)   # Push then pop (optimized)
heapq.heapreplace(heap, x)   # Pop then push (optimized)
heapq.nlargest(k, iterable)  # K largest elements
heapq.nsmallest(k, iterable) # K smallest elements
```

## 3.2 Max-Heap in Python (Workarounds)

### Pattern 1: Negate Values
```python
heapq.heappush(heap, -value)
max_val = -heapq.heappop(heap)
```

### Pattern 2: Tuple with Negation
```python
heapq.heappush(heap, (-priority, item))
```

### Pattern 3: Custom Wrapper Class
```python
class MaxHeapItem:
    def __init__(self, val):
        self.val = val
    def __lt__(self, other):
        return self.val > other.val  # Reverse comparison
```

> âš ï¸ **Interview Warning**: Always mention Python's heapq is min-heap only!

## 3.3 Custom Comparators

### For Complex Objects:
```python
# Using tuples (priority, tiebreaker, item)
heapq.heappush(heap, (priority, index, item))

# Custom class with __lt__
class Node:
    def __init__(self, freq, char):
        self.freq = freq
        self.char = char
    def __lt__(self, other):
        if self.freq == other.freq:
            return self.char < other.char
        return self.freq < other.freq
```

> ğŸ’¡ **Tiebreaker Pattern**: Use insertion order as secondary key to maintain stability.

---

# Chapter 4: Priority Queue Patterns

## 4.1 Priority Queue vs Heap
- **Priority Queue**: Abstract Data Type (ADT)
- **Heap**: One implementation of Priority Queue
- Other implementations: Balanced BST, Unsorted/Sorted Array

## 4.2 Lazy Deletion Pattern

> ğŸ”¥ **Critical Pattern for Interviews**

When you need to delete arbitrary elements but don't have their index:

```python
class LazyHeap:
    def __init__(self):
        self.heap = []
        self.deleted = set()  # or Counter for duplicates
    
    def push(self, val):
        heapq.heappush(self.heap, val)
    
    def pop(self):
        while self.heap and self.heap[0] in self.deleted:
            self.deleted.remove(heapq.heappop(self.heap))
        return heapq.heappop(self.heap)
    
    def remove(self, val):
        self.deleted.add(val)
```

**Use Cases**:
- Sliding window problems
- Dynamic median
- When elements become invalid

## 4.3 Indexed Priority Queue

Supports: `decreaseKey()`, `increaseKey()`, `contains()`, `delete(key)`

Used in:
- Dijkstra's Algorithm (efficient)
- Prim's Algorithm
- A* Search

---

# Chapter 5: Classic Heap Patterns

## 5.1 Pattern: Top K Elements

### K Largest Elements (Min-Heap of size K)
```python
def kLargest(nums, k):
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
        if len(heap) > k:
            heapq.heappop(heap)  # Remove smallest
    return heap
```

### K Smallest Elements (Max-Heap of size K)
```python
def kSmallest(nums, k):
    heap = []
    for num in nums:
        heapq.heappush(heap, -num)
        if len(heap) > k:
            heapq.heappop(heap)
    return [-x for x in heap]
```

> ğŸ’¡ **Why opposite heap?** 
> - For K largest: keep min-heap, reject elements smaller than smallest of top-k
> - For K smallest: keep max-heap, reject elements larger than largest of bottom-k

**Time**: O(n log k) | **Space**: O(k)

### Quick Select Alternative
- Average O(n), Worst O(nÂ²)
- Better for one-time queries
- Heap better for streaming data

## 5.2 Pattern: Kth Largest/Smallest Element

```python
def findKthLargest(nums, k):
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
        if len(heap) > k:
            heapq.heappop(heap)
    return heap[0]  # Kth largest is the smallest in our k-sized heap
```

## 5.3 Pattern: Two Heaps (Median Finding)

> ğŸ”¥ **High Frequency Interview Pattern**

Maintain two heaps:
- **Max-heap**: smaller half
- **Min-heap**: larger half

```python
class MedianFinder:
    def __init__(self):
        self.small = []  # Max-heap (negate values)
        self.large = []  # Min-heap
    
    def addNum(self, num):
        # Always add to max-heap first
        heapq.heappush(self.small, -num)
        
        # Balance: ensure small's max <= large's min
        if self.small and self.large and (-self.small[0] > self.large[0]):
            heapq.heappush(self.large, -heapq.heappop(self.small))
        
        # Size balance: differ by at most 1
        if len(self.small) > len(self.large) + 1:
            heapq.heappush(self.large, -heapq.heappop(self.small))
        if len(self.large) > len(self.small) + 1:
            heapq.heappush(self.small, -heapq.heappop(self.large))
    
    def findMedian(self):
        if len(self.small) > len(self.large):
            return -self.small[0]
        elif len(self.large) > len(self.small):
            return self.large[0]
        return (-self.small[0] + self.large[0]) / 2
```

**Variations**:
- Sliding Window Median (add lazy deletion)
- Find Median in Stream
- Balance two groups with constraint

## 5.4 Pattern: Merge K Sorted Lists/Arrays

```python
def mergeKLists(lists):
    heap = []
    for i, lst in enumerate(lists):
        if lst:
            heapq.heappush(heap, (lst.val, i, lst))
    
    dummy = curr = ListNode(0)
    while heap:
        val, i, node = heapq.heappop(heap)
        curr.next = node
        curr = curr.next
        if node.next:
            heapq.heappush(heap, (node.next.val, i, node.next))
    
    return dummy.next
```

**Time**: O(N log K) where N = total elements, K = number of lists

> ğŸ’¡ **Index as Tiebreaker**: Essential to avoid comparison errors between nodes!

## 5.5 Pattern: Smallest/Largest Element in Sorted Matrix

```python
def kthSmallest(matrix, k):
    n = len(matrix)
    heap = [(matrix[0][0], 0, 0)]
    visited = {(0, 0)}
    
    for _ in range(k):
        val, r, c = heapq.heappop(heap)
        if _ == k - 1:
            return val
        
        for nr, nc in [(r+1, c), (r, c+1)]:
            if nr < n and nc < n and (nr, nc) not in visited:
                visited.add((nr, nc))
                heapq.heappush(heap, (matrix[nr][nc], nr, nc))
```

## 5.6 Pattern: Task Scheduler / Reorganize String

**Goal**: Arrange elements with cooling/gap constraint

```python
def reorganizeString(s):
    count = Counter(s)
    heap = [(-freq, char) for char, freq in count.items()]
    heapq.heapify(heap)
    
    result = []
    prev_freq, prev_char = 0, ''
    
    while heap:
        freq, char = heapq.heappop(heap)
        result.append(char)
        
        # Add previous back (cooling done)
        if prev_freq < 0:
            heapq.heappush(heap, (prev_freq, prev_char))
        
        prev_freq, prev_char = freq + 1, char
    
    return ''.join(result) if len(result) == len(s) else ""
```

> ğŸ’¡ **Key Insight**: Process most frequent first, hold for one round before reinserting.

## 5.7 Pattern: Meeting Rooms / Interval Problems

```python
def minMeetingRooms(intervals):
    intervals.sort(key=lambda x: x[0])  # Sort by start
    heap = []  # Min-heap of end times
    
    for start, end in intervals:
        if heap and heap[0] <= start:
            heapq.heappop(heap)  # Reuse room
        heapq.heappush(heap, end)
    
    return len(heap)
```

---

# Chapter 6: Advanced Heap Patterns

## 6.1 Pattern: Running/Sliding Window with Heap

### Sliding Window Maximum (Deque is optimal, but heap works)
```python
def maxSlidingWindow(nums, k):
    heap = []  # (-value, index)
    result = []
    
    for i, num in enumerate(nums):
        heapq.heappush(heap, (-num, i))
        
        # Remove elements outside window
        while heap[0][1] <= i - k:
            heapq.heappop(heap)
        
        if i >= k - 1:
            result.append(-heap[0][0])
    
    return result
```

> âš ï¸ **Note**: Lazy deletion by index - only remove when it becomes the max.

## 6.2 Pattern: Dijkstra's Algorithm

```python
def dijkstra(graph, start):
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    heap = [(0, start)]
    
    while heap:
        d, u = heapq.heappop(heap)
        
        if d > dist[u]:  # Lazy deletion check
            continue
            
        for v, weight in graph[u]:
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                heapq.heappush(heap, (dist[v], v))
    
    return dist
```

**Time**: O((V + E) log V)

> ğŸ”¥ **Critical**: The `if d > dist[u]: continue` is the lazy deletion pattern!

## 6.3 Pattern: K-way Merge with Constraints

**Example**: Find K pairs with smallest sums

```python
def kSmallestPairs(nums1, nums2, k):
    if not nums1 or not nums2:
        return []
    
    heap = [(nums1[0] + nums2[0], 0, 0)]
    visited = {(0, 0)}
    result = []
    
    while heap and len(result) < k:
        _, i, j = heapq.heappop(heap)
        result.append([nums1[i], nums2[j]])
        
        if i + 1 < len(nums1) and (i + 1, j) not in visited:
            visited.add((i + 1, j))
            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))
        
        if j + 1 < len(nums2) and (i, j + 1) not in visited:
            visited.add((i, j + 1))
            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))
    
    return result
```

## 6.4 Pattern: IPO / Maximize Capital

**Greedy with Two Heaps**

```python
def findMaximizedCapital(k, w, profits, capital):
    projects = list(zip(capital, profits))
    projects.sort()  # Sort by capital needed
    
    heap = []  # Max-heap of profits
    i = 0
    
    for _ in range(k):
        # Add all affordable projects
        while i < len(projects) and projects[i][0] <= w:
            heapq.heappush(heap, -projects[i][1])
            i += 1
        
        if not heap:
            break
        
        w += -heapq.heappop(heap)  # Take most profitable
    
    return w
```

## 6.5 Pattern: Trapping Rain Water II (3D)

```python
def trapRainWater(heightMap):
    if not heightMap:
        return 0
    
    m, n = len(heightMap), len(heightMap[0])
    heap = []
    visited = [[False] * n for _ in range(m)]
    
    # Add all boundary cells
    for i in range(m):
        for j in range(n):
            if i == 0 or i == m-1 or j == 0 or j == n-1:
                heapq.heappush(heap, (heightMap[i][j], i, j))
                visited[i][j] = True
    
    water = 0
    while heap:
        h, i, j = heapq.heappop(heap)
        
        for di, dj in [(0,1), (0,-1), (1,0), (-1,0)]:
            ni, nj = i + di, j + dj
            if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj]:
                visited[ni][nj] = True
                water += max(0, h - heightMap[ni][nj])
                heapq.heappush(heap, (max(h, heightMap[ni][nj]), ni, nj))
    
    return water
```

---

# Chapter 7: Specialized Heap Variants

## 7.1 Min-Max Heap
- Alternating min and max levels
- O(1) find-min AND find-max
- O(log n) delete-min and delete-max

## 7.2 D-ary Heap
- Each node has D children instead of 2
- Shallower tree: height = O(log_d n)
- Trade-off: More comparisons per level

**Optimal D**:
- When decrease-key is frequent: larger D
- Cache efficiency: D = 4 often optimal

## 7.3 Fibonacci Heap

| Operation | Binary Heap | Fibonacci Heap |
|-----------|-------------|----------------|
| Insert | O(log n) | O(1) |
| Find-min | O(1) | O(1) |
| Delete-min | O(log n) | O(log n) amortized |
| **Decrease-key** | O(log n) | **O(1) amortized** |
| Merge | O(n) | O(1) |

> ğŸ’¡ **When to use**: Algorithms with many decrease-key operations (Dijkstra, Prim)

## 7.4 Binomial Heap
- Collection of binomial trees
- O(log n) merge operation
- Used in mergeable priority queues

---

# Chapter 8: Heap Sort

## 8.1 Algorithm
```python
def heapSort(arr):
    n = len(arr)
    
    # Build max heap - O(n)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # Extract elements - O(n log n)
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
```

## 8.2 Properties
- **Time**: O(n log n) - always
- **Space**: O(1) - in-place
- **Not Stable**: Equal elements may be reordered
- **Not Adaptive**: Same time regardless of input

## 8.3 Comparison with Other Sorts

| Sort | Time (Avg) | Time (Worst) | Space | Stable |
|------|------------|--------------|-------|--------|
| Heap Sort | O(n log n) | O(n log n) | O(1) | No |
| Quick Sort | O(n log n) | O(nÂ²) | O(log n) | No |
| Merge Sort | O(n log n) | O(n log n) | O(n) | Yes |

> ğŸ’¡ **When to choose Heap Sort**: Need guaranteed O(n log n) with O(1) space

---

# Chapter 9: Common Interview Questions by Difficulty

## 9.1 Easy
1. Kth Largest Element in Stream
2. Last Stone Weight
3. Relative Ranks
4. Minimum Cost of Ropes

## 9.2 Medium
1. Top K Frequent Elements
2. Kth Largest Element in Array
3. Find K Pairs with Smallest Sums
4. Task Scheduler
5. Reorganize String
6. Merge K Sorted Lists
7. Meeting Rooms II
8. Kth Smallest in Sorted Matrix
9. Furthest Building You Can Reach
10. Seat Reservation Manager

## 9.3 Hard
1. Find Median from Data Stream
2. Sliding Window Median
3. Trapping Rain Water II
4. IPO
5. Smallest Range Covering Elements from K Lists
6. Course Schedule III
7. The Skyline Problem
8. Maximum Performance of a Team
9. Minimum Cost to Hire K Workers
10. Minimum Number of Refueling Stops

---

# Chapter 10: Tips, Tricks & Common Mistakes

## 10.1 Common Mistakes

âŒ **Forgetting Python heapq is min-heap only**
```python
# Wrong for max-heap
heapq.heappush(heap, value)
# Correct
heapq.heappush(heap, -value)
```

âŒ **Not handling tiebreakers**
```python
# Can crash if items aren't comparable
heapq.heappush(heap, (priority, item))
# Correct
heapq.heappush(heap, (priority, index, item))
```

âŒ **Modifying heap elements directly**
```python
# Wrong - breaks heap property
heap[i] = new_value
# Correct - re-heapify or use lazy deletion
```

âŒ **Confusing build heap complexity**
```python
# O(n), NOT O(n log n)
heapq.heapify(arr)
```

## 10.2 Optimization Tips

1. **Use `heappushpop` and `heapreplace`**
   ```python
   # Instead of push then pop
   heapq.heappushpop(heap, x)  # More efficient
   
   # Instead of pop then push
   heapq.heapreplace(heap, x)  # More efficient
   ```

2. **Batch operations when possible**
   ```python
   # Instead of n pushes
   arr = [...]
   heapq.heapify(arr)  # O(n) vs O(n log n)
   ```

3. **Use nlargest/nsmallest for small k**
   ```python
   heapq.nlargest(k, arr)  # Optimized for small k
   ```

## 10.3 Interview Strategy

1. **Identify the pattern first**
   - Top K â†’ Heap of size K
   - Median â†’ Two heaps
   - Merge sorted â†’ Min heap
   - Greedy selection â†’ Max/Min heap

2. **State complexity clearly**
   - Time: Usually O(n log n) or O(n log k)
   - Space: O(n) or O(k)

3. **Discuss trade-offs**
   - Heap vs Quick Select for Kth element
   - Heap vs Balanced BST for dynamic median
   - Binary Heap vs Fibonacci Heap for Dijkstra

4. **Edge cases to consider**
   - Empty input
   - K > n
   - Duplicate elements
   - Negative numbers

---

# Quick Reference Card

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    HEAP CHEAT SHEET                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Build Heap:      O(n)     - Bottom-up heapify           â”‚
â”‚ Push:            O(log n) - Heapify up                  â”‚
â”‚ Pop:             O(log n) - Heapify down                â”‚
â”‚ Peek:            O(1)     - Return root                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ PATTERNS:                                               â”‚
â”‚ â€¢ Top K          â†’ Heap of size K (opposite type)       â”‚
â”‚ â€¢ Median         â†’ Two heaps (max + min)                â”‚
â”‚ â€¢ Merge K Lists  â†’ Min heap of K elements               â”‚
â”‚ â€¢ Task Scheduler â†’ Max heap + cooldown                  â”‚
â”‚ â€¢ Dijkstra       â†’ Min heap + lazy deletion             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ PYTHON:                                                 â”‚
â”‚ import heapq                                            â”‚
â”‚ heapq.heappush(h, val)    heapq.heappop(h)             â”‚
â”‚ heapq.heapify(arr)        h[0] # peek                   â”‚
â”‚ heapq.nlargest(k, arr)    heapq.nsmallest(k, arr)      â”‚
â”‚ Max-heap: negate values (-val)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ INDICES (0-based):                                      â”‚
â”‚ Parent: (i-1)//2   Left: 2i+1   Right: 2i+2            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

**Good luck with your interviews!** ğŸš€
