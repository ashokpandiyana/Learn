# Chapter 2: Two Pointer Categories

## Complete In-Depth Guide to All Four Patterns

---

# Overview: The Four Fundamental Patterns

```
┌─────────────────────────────────────────────────────────────────┐
│                  TWO POINTER FAMILY TREE                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                      TWO POINTERS                               │
│                           │                                     │
│         ┌─────────┬───────┴───────┬─────────┐                  │
│         │         │               │         │                   │
│         ▼         ▼               ▼         ▼                   │
│    ┌─────────┐ ┌─────────┐ ┌──────────┐ ┌─────────┐            │
│    │OPPOSITE │ │  SAME   │ │ SLIDING  │ │MULTIPLE │            │
│    │DIRECTION│ │DIRECTION│ │ WINDOW   │ │ ARRAYS  │            │
│    └─────────┘ └─────────┘ └──────────┘ └─────────┘            │
│         │         │               │         │                   │
│         ▼         ▼               ▼         ▼                   │
│    Converging  Fast/Slow    Expand/      Parallel               │
│    from ends   pointers     Contract     traversal              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# 2.1 Opposite Direction (Converging Pointers)

## Core Concept

Two pointers start at **opposite ends** of the data structure and move **toward each other** until they meet or a condition is satisfied.

```
INITIAL STATE:
┌─────────────────────────────────────────────────┐
│                                                 │
│    [1]  [3]  [5]  [7]  [9]  [11]  [13]  [15]  │
│     ↑                                    ↑      │
│   LEFT                                 RIGHT    │
│   (i=0)                                (j=7)    │
│                                                 │
│   Movement: LEFT →→→    ←←← RIGHT              │
│                                                 │
└─────────────────────────────────────────────────┘

MEETING CONDITION:
┌─────────────────────────────────────────────────┐
│                                                 │
│    [1]  [3]  [5]  [7]  [9]  [11]  [13]  [15]  │
│                   ↑    ↑                        │
│                 LEFT  RIGHT                     │
│                                                 │
│   Loop ends when: left >= right                 │
│                                                 │
└─────────────────────────────────────────────────┘
```

---

## Why Converging Pointers Work

The key insight is **elimination**: when we move a pointer, we're eliminating possibilities that we've proven cannot lead to a solution.

```
Example: Find two numbers that sum to 16

Array: [1, 3, 5, 7, 9, 11, 13, 15]
        ↑                      ↑
       L=1                   R=15

Sum = 1 + 15 = 16 ✓ FOUND!

But what if target was 20?

Step 1: 1 + 15 = 16 < 20
        Need LARGER sum → move LEFT right
        WHY? Because 1 + anything ≤ 15 is ≤ 16 < 20
        So 1 can NEVER be part of the answer!
        
        [1, 3, 5, 7, 9, 11, 13, 15]
         ✗  ↑                   ↑
           L=3                R=15

Step 2: 3 + 15 = 18 < 20
        Still need larger → move LEFT right
        
        [1, 3, 5, 7, 9, 11, 13, 15]
         ✗  ✗  ↑                ↑
              L=5             R=15

Step 3: 5 + 15 = 20 ✓ FOUND!
```

---

## The Universal Template

```python
def converging_two_pointer(arr, target):
    """
    Universal template for opposite direction two pointers.
    
    Time Complexity: O(n)
    Space Complexity: O(1)
    """
    left = 0
    right = len(arr) - 1
    
    while left < right:  # or left <= right depending on problem
        # Calculate current state
        current = calculate(arr[left], arr[right])
        
        if current == target:
            # Found the answer
            return process_result(left, right)
        
        elif current < target:
            # Need to increase current value
            left += 1
            
        else:  # current > target
            # Need to decrease current value
            right -= 1
    
    return not_found()
```

---

## Pattern 2.1.1: Two Sum (Sorted Array)

### Problem
Find two numbers in a sorted array that add up to a target.

### Visualization

```
Target = 9
Array: [2, 3, 4, 5, 6, 7, 8]
        ↑                 ↑
        L                 R

┌────────────────────────────────────────────────────────┐
│  STEP-BY-STEP EXECUTION                                │
├────────────────────────────────────────────────────────┤
│                                                        │
│  Step 1: L=0, R=6                                      │
│          sum = 2 + 8 = 10 > 9                          │
│          Need smaller → R--                            │
│          [2, 3, 4, 5, 6, 7, 8]                         │
│           ↑              ↑                             │
│                                                        │
│  Step 2: L=0, R=5                                      │
│          sum = 2 + 7 = 9 == 9 ✓                        │
│          FOUND at indices (0, 5)                       │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### Implementation

```python
def two_sum_sorted(numbers: list[int], target: int) -> list[int]:
    """
    Find indices of two numbers that sum to target.
    Input array is SORTED in ascending order.
    
    Returns 1-indexed result as per LeetCode convention.
    """
    left, right = 0, len(numbers) - 1
    
    while left < right:
        current_sum = numbers[left] + numbers[right]
        
        if current_sum == target:
            return [left + 1, right + 1]  # 1-indexed
        elif current_sum < target:
            left += 1   # Need larger sum
        else:
            right -= 1  # Need smaller sum
    
    return [-1, -1]  # No solution

# Test Cases
assert two_sum_sorted([2,7,11,15], 9) == [1, 2]
assert two_sum_sorted([2,3,4], 6) == [1, 3]
assert two_sum_sorted([-1,0], -1) == [1, 2]
```

---

## Pattern 2.1.2: Container With Most Water

### Problem
Given heights of vertical lines, find two lines that form a container holding the most water.

### Visualization

```
Height Array: [1, 8, 6, 2, 5, 4, 8, 3, 7]

Visual Representation:
        8           8
        █           █       7
        █   6       █       █
        █   █   5   █       █
        █   █   █ 4 █       █
        █   █   █ █ █   3   █
        █   █ 2 █ █ █   █   █
    1   █   █ █ █ █ █   █   █
    █   █   █ █ █ █ █   █   █
    ─────────────────────────
    0   1   2 3 4 5 6   7   8
        ↑                   ↑
        L                   R
        
Water = min(8, 7) × (8 - 1) = 7 × 7 = 49
```

### Key Insight

```
┌─────────────────────────────────────────────────────────┐
│  WHY MOVE THE SHORTER LINE?                             │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Water = min(height[L], height[R]) × (R - L)           │
│                                                         │
│  If height[L] < height[R]:                              │
│    • Current water is limited by height[L]              │
│    • Moving R left: width decreases, height ≤ current  │
│      → Water can only DECREASE or stay same            │
│    • Moving L right: width decreases, but height       │
│      might increase → Water MIGHT increase             │
│                                                         │
│  Therefore: Always move the SHORTER line!               │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Implementation

```python
def max_area(height: list[int]) -> int:
    """
    Find maximum water container area.
    
    Strategy: Start wide, move the shorter line inward.
    
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(height) - 1
    max_water = 0
    
    while left < right:
        # Calculate current container's water
        width = right - left
        h = min(height[left], height[right])
        current_water = width * h
        
        # Update maximum
        max_water = max(max_water, current_water)
        
        # Move the shorter line (greedy choice)
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    
    return max_water

# Trace for [1,8,6,2,5,4,8,3,7]:
# L=0,R=8: min(1,7)×8 = 8,  move L (1<7)
# L=1,R=8: min(8,7)×7 = 49, move R (8>7)
# L=1,R=7: min(8,3)×6 = 18, move R (8>3)
# L=1,R=6: min(8,8)×5 = 40, move R (equal, either works)
# ... max = 49
```

---

## Pattern 2.1.3: Valid Palindrome

### Problem
Check if a string reads the same forwards and backwards.

### Visualization

```
String: "A man, a plan, a canal: Panama"

After filtering (alphanumeric only, lowercase):
"amanaplanacanalpanama"

Two Pointer Check:
┌───────────────────────────────────────────────────────┐
│                                                       │
│  a m a n a p l a n a c a n a l p a n a m a           │
│  ↑                                       ↑           │
│  L                                       R           │
│  'a' == 'a' ✓                                        │
│                                                       │
│  a m a n a p l a n a c a n a l p a n a m a           │
│    ↑                                   ↑             │
│    L                                   R             │
│    'm' == 'm' ✓                                      │
│                                                       │
│  ... continue until L >= R ...                        │
│                                                       │
│  All matched → PALINDROME!                            │
│                                                       │
└───────────────────────────────────────────────────────┘
```

### Implementation

```python
def is_palindrome(s: str) -> bool:
    """
    Check if string is palindrome.
    Consider only alphanumeric, ignore case.
    
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(s) - 1
    
    while left < right:
        # Skip non-alphanumeric from left
        while left < right and not s[left].isalnum():
            left += 1
        
        # Skip non-alphanumeric from right
        while left < right and not s[right].isalnum():
            right -= 1
        
        # Compare (case-insensitive)
        if s[left].lower() != s[right].lower():
            return False
        
        left += 1
        right -= 1
    
    return True

# Trace for "A man, a plan, a canal: Panama":
# L=0('A'), R=29('a'): 'a'=='a' ✓
# L=1(' '), skip → L=2('m')
# R=28('m'): 'm'=='m' ✓
# ... all match → True
```

---

## Pattern 2.1.4: Trapping Rain Water

### Problem
Calculate how much rainwater can be trapped between bars.

### Visualization

```
Height: [0,1,0,2,1,0,1,3,2,1,2,1]

Visual:
                        3
                        █
            2           █ 2   2
            █   1   1   █ █ 1 █ 1
        1   █ 1 █ 0 █   █ █ █ █ █
    0   █ 0 █ █ █ █ █   █ █ █ █ █
    ─────────────────────────────────
    0   1 2 3 4 5 6 7   8 9 10 11

Water trapped (shown as ~):
                        3
                        █
            2 ~ ~ ~ ~   █ 2 ~ 2
            █ 1 █ ~ █   █ █ 1 █ 1
        1   █ █ █ ~ █   █ █ █ █ █
    0   █ 0 █ █ █ ~ █   █ █ █ █ █
    
Total water = 6 units
```

### Key Insight

```
┌─────────────────────────────────────────────────────────┐
│  WATER AT POSITION i                                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  water[i] = min(left_max, right_max) - height[i]       │
│                                                         │
│  Where:                                                 │
│  • left_max = max height to the left of i               │
│  • right_max = max height to the right of i             │
│                                                         │
│  Two Pointer Optimization:                              │
│  • If height[L] < height[R]:                            │
│    Water at L is bounded by left_max (we know right    │
│    has something taller)                                │
│  • If height[L] >= height[R]:                           │
│    Water at R is bounded by right_max                   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Implementation

```python
def trap(height: list[int]) -> int:
    """
    Calculate trapped rainwater using two pointers.
    
    Time: O(n), Space: O(1)
    """
    if not height:
        return 0
    
    left, right = 0, len(height) - 1
    left_max, right_max = 0, 0
    water = 0
    
    while left < right:
        if height[left] < height[right]:
            # Process left side
            if height[left] >= left_max:
                left_max = height[left]  # Update max
            else:
                water += left_max - height[left]  # Trap water
            left += 1
        else:
            # Process right side
            if height[right] >= right_max:
                right_max = height[right]  # Update max
            else:
                water += right_max - height[right]  # Trap water
            right -= 1
    
    return water

# Detailed trace for [0,1,0,2,1,0,1,3,2,1,2,1]:
# L=0,R=11: h[0]=0 < h[11]=1
#           left_max=0, water+=0-0=0, L++
# L=1,R=11: h[1]=1 < h[11]=1? No, equal
#           right_max=1, water+=0, R--
# L=1,R=10: h[1]=1 < h[10]=2
#           left_max=1, water+=0, L++
# L=2,R=10: h[2]=0 < h[10]=2
#           left_max=1, water+=1-0=1, L++
# ... continue, total = 6
```

---

## Pattern 2.1.5: Three Sum

### Problem
Find all unique triplets that sum to zero.

### Strategy

```
┌─────────────────────────────────────────────────────────┐
│  REDUCING 3SUM TO 2SUM                                  │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  For each element nums[i], find two numbers in the     │
│  remaining array that sum to -nums[i]                   │
│                                                         │
│  nums[i] + nums[j] + nums[k] = 0                       │
│  ⟹ nums[j] + nums[k] = -nums[i]                        │
│                                                         │
│  This is a Two Sum problem with target = -nums[i]!     │
│                                                         │
│  Array: [-4, -1, -1, 0, 1, 2]                          │
│           ↑   ↑            ↑                            │
│           i   L            R                            │
│                                                         │
│  For i=0 (nums[i]=-4):                                 │
│  Find j,k where nums[j]+nums[k] = 4                    │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Implementation with Duplicate Handling

```python
def three_sum(nums: list[int]) -> list[list[int]]:
    """
    Find all unique triplets summing to zero.
    
    Time: O(n²), Space: O(1) excluding output
    """
    nums.sort()  # Critical: enables two pointers
    result = []
    n = len(nums)
    
    for i in range(n - 2):
        # Skip duplicate values for i
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        
        # Early termination optimizations
        if nums[i] > 0:  # Can't sum to 0 with all positives
            break
        if nums[i] + nums[n-2] + nums[n-1] < 0:  # Too small
            continue
        
        # Two pointer search
        left, right = i + 1, n - 1
        target = -nums[i]
        
        while left < right:
            current_sum = nums[left] + nums[right]
            
            if current_sum == target:
                result.append([nums[i], nums[left], nums[right]])
                
                # Skip duplicates for left
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                # Skip duplicates for right
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                
                left += 1
                right -= 1
                
            elif current_sum < target:
                left += 1
            else:
                right -= 1
    
    return result

# Trace for [-1, 0, 1, 2, -1, -4]:
# After sort: [-4, -1, -1, 0, 1, 2]
#
# i=0, nums[i]=-4, target=4:
#   L=1,R=5: -1+2=1 < 4, L++
#   L=2,R=5: -1+2=1 < 4, L++
#   L=3,R=5: 0+2=2 < 4, L++
#   L=4,R=5: 1+2=3 < 4, L++
#   L=5,R=5: exit (no triplet with -4)
#
# i=1, nums[i]=-1, target=1:
#   L=2,R=5: -1+2=1 == 1 ✓ → [-1,-1,2]
#   L=3,R=4: 0+1=1 == 1 ✓ → [-1,0,1]
#
# i=2, nums[i]=-1, SKIP (duplicate of i=1)
#
# Result: [[-1,-1,2], [-1,0,1]]
```

---

## Opposite Direction: Summary

```
┌─────────────────────────────────────────────────────────┐
│  OPPOSITE DIRECTION CHECKLIST                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ✓ Use when:                                           │
│    • Data is sorted                                     │
│    • Comparing/combining elements from both ends        │
│    • Finding pairs with target sum/difference           │
│    • Palindrome verification                            │
│    • Container/area optimization                        │
│                                                         │
│  ✓ Key decisions:                                      │
│    • left < right vs left <= right                     │
│    • Which pointer to move based on comparison          │
│    • Handling duplicates (skip after finding)           │
│                                                         │
│  ✓ Common mistakes:                                    │
│    • Forgetting to sort                                 │
│    • Wrong duplicate skipping logic                     │
│    • Off-by-one in loop condition                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

# 2.2 Same Direction (Fast & Slow Pointers)

## Core Concept

Both pointers start from the **same position** (usually the beginning) and move in the **same direction**, but at different speeds or under different conditions.

```
INITIAL STATE:
┌─────────────────────────────────────────────────────────┐
│                                                         │
│    [0]  [1]  [0]  [3]  [12]  [0]  [5]                  │
│     ↑                                                   │
│   SLOW                                                  │
│   FAST                                                  │
│                                                         │
└─────────────────────────────────────────────────────────┘

DURING EXECUTION:
┌─────────────────────────────────────────────────────────┐
│                                                         │
│    [1]  [3]  [12]  [5]  [12]  [0]  [5]                 │
│                     ↑                   ↑               │
│                   SLOW                FAST              │
│                                                         │
│   SLOW: Points to position for next valid element      │
│   FAST: Scans through array finding valid elements     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Two Main Variations

### Variation 1: Read-Write Pointers (Array Modification)

```
┌─────────────────────────────────────────────────────────┐
│  SLOW = "Writer" - where to write next valid element   │
│  FAST = "Reader" - scans all elements                  │
│                                                         │
│  Used for:                                              │
│  • Remove duplicates                                    │
│  • Remove specific element                              │
│  • Move zeros                                           │
│  • Filter array in-place                                │
└─────────────────────────────────────────────────────────┘
```

### Variation 2: Speed Difference (Linked Lists)

```
┌─────────────────────────────────────────────────────────┐
│  SLOW = Moves 1 step at a time                         │
│  FAST = Moves 2 steps at a time                        │
│                                                         │
│  Used for:                                              │
│  • Cycle detection (Floyd's algorithm)                  │
│  • Finding middle element                               │
│  • Finding cycle start                                  │
│  • Detecting list intersection                          │
└─────────────────────────────────────────────────────────┘
```

---

## Pattern 2.2.1: Remove Duplicates from Sorted Array

### Problem
Remove duplicates in-place, return new length.

### Visualization

```
Input: [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]

Step-by-step:
┌────────────────────────────────────────────────────────┐
│                                                        │
│  Initial: [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]             │
│            s  f                                        │
│                                                        │
│  f=1: nums[1]=0 == nums[0]=0, skip                    │
│       [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]                  │
│        s     f                                         │
│                                                        │
│  f=2: nums[2]=1 != nums[0]=0, write!                  │
│       s++, nums[s]=nums[f]                            │
│       [0, 1, 1, 1, 1, 2, 2, 3, 3, 4]                  │
│           s  f                                         │
│                                                        │
│  f=3: nums[3]=1 == nums[1]=1, skip                    │
│  f=4: nums[4]=1 == nums[1]=1, skip                    │
│                                                        │
│  f=5: nums[5]=2 != nums[1]=1, write!                  │
│       [0, 1, 2, 1, 1, 2, 2, 3, 3, 4]                  │
│              s           f                             │
│                                                        │
│  ... continue ...                                      │
│                                                        │
│  Final: [0, 1, 2, 3, 4, ?, ?, ?, ?, ?]                │
│                       s                 f              │
│         Return s+1 = 5                                 │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### Implementation

```python
def remove_duplicates(nums: list[int]) -> int:
    """
    Remove duplicates from sorted array in-place.
    Return the new length.
    
    Time: O(n), Space: O(1)
    """
    if not nums:
        return 0
    
    slow = 0  # Position of last unique element
    
    for fast in range(1, len(nums)):
        if nums[fast] != nums[slow]:
            slow += 1
            nums[slow] = nums[fast]
    
    return slow + 1

# Alternative: Compare with previous instead of slow
def remove_duplicates_v2(nums: list[int]) -> int:
    if not nums:
        return 0
    
    slow = 1  # Position for next unique element
    
    for fast in range(1, len(nums)):
        if nums[fast] != nums[fast - 1]:
            nums[slow] = nums[fast]
            slow += 1
    
    return slow
```

---

## Pattern 2.2.2: Remove Element

### Problem
Remove all occurrences of a value in-place.

### Visualization

```
Input: nums = [3, 2, 2, 3], val = 3

┌────────────────────────────────────────────────────────┐
│                                                        │
│  Initial: [3, 2, 2, 3]    val = 3                     │
│            sf                                          │
│                                                        │
│  f=0: nums[0]=3 == val, skip (don't write)            │
│       [3, 2, 2, 3]                                     │
│        s  f                                            │
│                                                        │
│  f=1: nums[1]=2 != val, write!                        │
│       nums[s]=nums[f], s++                            │
│       [2, 2, 2, 3]                                     │
│           s  f                                         │
│                                                        │
│  f=2: nums[2]=2 != val, write!                        │
│       [2, 2, 2, 3]                                     │
│              s  f                                      │
│                                                        │
│  f=3: nums[3]=3 == val, skip                          │
│                                                        │
│  Final: [2, 2, ?, ?]  Return s = 2                    │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### Implementation

```python
def remove_element(nums: list[int], val: int) -> int:
    """
    Remove all instances of val in-place.
    Return new length.
    
    Time: O(n), Space: O(1)
    """
    slow = 0
    
    for fast in range(len(nums)):
        if nums[fast] != val:
            nums[slow] = nums[fast]
            slow += 1
    
    return slow

# Optimized for few elements to remove (swap with end)
def remove_element_optimized(nums: list[int], val: int) -> int:
    """
    Better when val is rare: O(number of val) writes.
    """
    i, n = 0, len(nums)
    
    while i < n:
        if nums[i] == val:
            nums[i] = nums[n - 1]  # Swap with last
            n -= 1  # Shrink array
            # Don't increment i, need to check swapped element
        else:
            i += 1
    
    return n
```

---

## Pattern 2.2.3: Move Zeros

### Problem
Move all zeros to the end while maintaining relative order of non-zeros.

### Visualization

```
Input: [0, 1, 0, 3, 12]

┌────────────────────────────────────────────────────────┐
│                                                        │
│  Initial: [0, 1, 0, 3, 12]                            │
│            sf                                          │
│                                                        │
│  f=0: nums[0]=0, skip                                 │
│       [0, 1, 0, 3, 12]                                │
│        s  f                                            │
│                                                        │
│  f=1: nums[1]=1 ≠ 0, swap!                            │
│       swap(nums[s], nums[f]), s++                     │
│       [1, 0, 0, 3, 12]                                │
│           s     f                                      │
│                                                        │
│  f=2: nums[2]=0, skip                                 │
│       [1, 0, 0, 3, 12]                                │
│           s        f                                   │
│                                                        │
│  f=3: nums[3]=3 ≠ 0, swap!                            │
│       [1, 3, 0, 0, 12]                                │
│              s        f                                │
│                                                        │
│  f=4: nums[4]=12 ≠ 0, swap!                           │
│       [1, 3, 12, 0, 0]                                │
│                  s     f                               │
│                                                        │
│  Final: [1, 3, 12, 0, 0] ✓                            │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### Implementation

```python
def move_zeroes(nums: list[int]) -> None:
    """
    Move zeros to end in-place, maintain order.
    
    Time: O(n), Space: O(1)
    """
    slow = 0  # Position for next non-zero
    
    for fast in range(len(nums)):
        if nums[fast] != 0:
            # Swap to avoid overwriting
            nums[slow], nums[fast] = nums[fast], nums[slow]
            slow += 1

# Alternative: Write then fill zeros
def move_zeroes_v2(nums: list[int]) -> None:
    slow = 0
    
    # Move all non-zeros to front
    for fast in range(len(nums)):
        if nums[fast] != 0:
            nums[slow] = nums[fast]
            slow += 1
    
    # Fill remaining with zeros
    for i in range(slow, len(nums)):
        nums[i] = 0
```

---

## Pattern 2.2.4: Floyd's Cycle Detection (Linked List)

### Problem
Detect if a linked list has a cycle.

### Visualization

```
List with cycle:
┌─────────────────────────────────────────────────────────┐
│                                                         │
│    1 → 2 → 3 → 4 → 5                                   │
│            ↑       ↓                                    │
│            └───────┘                                    │
│                                                         │
│  SLOW moves 1 step, FAST moves 2 steps                 │
│                                                         │
│  Step 0: S=1, F=1                                      │
│  Step 1: S=2, F=3                                      │
│  Step 2: S=3, F=5                                      │
│  Step 3: S=4, F=4 ← MEET! Cycle detected              │
│                                                         │
└─────────────────────────────────────────────────────────┘

List without cycle:
┌─────────────────────────────────────────────────────────┐
│                                                         │
│    1 → 2 → 3 → 4 → 5 → None                            │
│                                                         │
│  Step 0: S=1, F=1                                      │
│  Step 1: S=2, F=3                                      │
│  Step 2: S=3, F=5                                      │
│  Step 3: S=4, F=None ← FAST reached end, no cycle     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Why Does It Work?

```
┌─────────────────────────────────────────────────────────┐
│  MATHEMATICAL PROOF                                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  If there's a cycle:                                    │
│  • Fast enters cycle first                              │
│  • When slow enters cycle, fast is already inside      │
│  • Fast "chases" slow at relative speed of 1           │
│  • Distance decreases by 1 each step                   │
│  • They MUST meet within one cycle length              │
│                                                         │
│  If no cycle:                                           │
│  • Fast reaches null/end                                │
│  • Loop terminates with "no cycle" result              │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Implementation

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def has_cycle(head: ListNode) -> bool:
    """
    Detect cycle using Floyd's algorithm.
    
    Time: O(n), Space: O(1)
    """
    if not head or not head.next:
        return False
    
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next        # Move 1 step
        fast = fast.next.next   # Move 2 steps
        
        if slow == fast:
            return True
    
    return False
```

---

## Pattern 2.2.5: Find Cycle Start

### Problem
Find where the cycle begins in a linked list.

### The Math Behind It

```
┌─────────────────────────────────────────────────────────┐
│  FINDING CYCLE START                                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│         a            b                                  │
│    ┌─────────┐  ┌─────────┐                            │
│    ↓         ↓  ↓         ↓                            │
│    START ───→ CYCLE_START ───→ MEET                    │
│                    ↑            │                       │
│                    └────────────┘                       │
│                          c                              │
│                                                         │
│  Let:                                                   │
│  • a = distance from start to cycle start              │
│  • b = distance from cycle start to meeting point      │
│  • c = remaining cycle length (meet to cycle start)    │
│  • Cycle length = b + c                                │
│                                                         │
│  When they meet:                                        │
│  • Slow traveled: a + b                                │
│  • Fast traveled: a + b + k(b + c) for some k ≥ 1     │
│  • Fast = 2 × Slow                                     │
│  • a + b + k(b + c) = 2(a + b)                        │
│  • k(b + c) = a + b                                    │
│  • a = k(b + c) - b = (k-1)(b + c) + c                │
│  • a = (k-1) × cycle_length + c                        │
│                                                         │
│  This means: a ≡ c (mod cycle_length)                  │
│  So moving 'a' steps from START and 'c' steps from    │
│  MEET will land at the same position: CYCLE_START!     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Implementation

```python
def detect_cycle(head: ListNode) -> ListNode:
    """
    Find the node where cycle begins.
    Return None if no cycle.
    
    Time: O(n), Space: O(1)
    """
    if not head or not head.next:
        return None
    
    # Phase 1: Detect cycle
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            break
    else:
        return None  # No cycle
    
    # Phase 2: Find cycle start
    # Reset one pointer to head
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next  # Both move at same speed now!
    
    return slow  # Meeting point is cycle start
```

---

## Pattern 2.2.6: Find Middle of Linked List

### Visualization

```
Odd length list: 1 → 2 → 3 → 4 → 5
┌────────────────────────────────────────────────────────┐
│                                                        │
│  Step 0: S=1, F=1                                     │
│  Step 1: S=2, F=3                                     │
│  Step 2: S=3, F=5                                     │
│  Step 3: F.next is None, stop                         │
│  Middle = S = 3 ✓                                     │
│                                                        │
└────────────────────────────────────────────────────────┘

Even length list: 1 → 2 → 3 → 4 → 5 → 6
┌────────────────────────────────────────────────────────┐
│                                                        │
│  Step 0: S=1, F=1                                     │
│  Step 1: S=2, F=3                                     │
│  Step 2: S=3, F=5                                     │
│  Step 3: S=4, F=None (past end)                       │
│  Middle = S = 4 (second of two middles) ✓            │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### Implementation

```python
def find_middle(head: ListNode) -> ListNode:
    """
    Find middle node. For even length, return second middle.
    
    Time: O(n), Space: O(1)
    """
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow

def find_middle_first(head: ListNode) -> ListNode:
    """
    For even length, return FIRST middle.
    Useful for splitting list in half.
    """
    slow = fast = head
    prev = None
    
    while fast and fast.next:
        prev = slow
        slow = slow.next
        fast = fast.next.next
    
    # For even length, prev points to first middle
    # For odd length, slow is the exact middle
    return slow  # or return prev for first middle in even case
```

---

## Same Direction: Summary

```
┌─────────────────────────────────────────────────────────┐
│  SAME DIRECTION PATTERNS                                │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ARRAY MODIFICATION (Read-Write):                       │
│  ┌─────────────────────────────────────────────────┐   │
│  │ slow = write position                           │   │
│  │ fast = read position                            │   │
│  │ if valid: nums[slow] = nums[fast]; slow++       │   │
│  └─────────────────────────────────────────────────┘   │
│                                                         │
│  LINKED LIST (Speed Difference):                        │
│  ┌─────────────────────────────────────────────────┐   │
│  │ slow = slow.next      (1 step)                  │   │
│  │ fast = fast.next.next (2 steps)                 │   │
│  │ Meet → cycle exists                             │   │
│  │ Fast reaches end → no cycle                     │   │
│  └─────────────────────────────────────────────────┘   │
│                                                         │
│  COMMON APPLICATIONS:                                   │
│  • Remove duplicates (sorted array)                     │
│  • Remove element                                       │
│  • Move zeros                                           │
│  • Cycle detection                                      │
│  • Find middle                                          │
│  • Palindrome linked list                               │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

# 2.3 Sliding Window (Special Two Pointer)

## Core Concept

A **window** defined by two pointers (left and right boundaries) that **expands** or **contracts** based on conditions.

```
┌─────────────────────────────────────────────────────────┐
│              SLIDING WINDOW CONCEPT                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Array: [2, 1, 5, 1, 3, 2]                             │
│             ↑     ↑                                     │
│           LEFT  RIGHT                                   │
│             └──┬──┘                                     │
│              WINDOW                                     │
│           (subarray)                                    │
│                                                         │
│  Window contains: [1, 5, 1]                            │
│  Window sum: 7                                          │
│  Window size: right - left + 1 = 3                     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Two Types of Sliding Windows

### Type 1: Fixed Size Window

```
┌─────────────────────────────────────────────────────────┐
│  FIXED SIZE WINDOW                                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Problem: Find max sum of subarray of size k           │
│                                                         │
│  [2, 1, 5, 1, 3, 2]   k = 3                            │
│                                                         │
│  Window 1: [2, 1, 5] → sum = 8                         │
│  Window 2: [1, 5, 1] → sum = 7                         │
│  Window 3: [5, 1, 3] → sum = 9 ← MAX                   │
│  Window 4: [1, 3, 2] → sum = 6                         │
│                                                         │
│  Technique: Add new element, remove old element         │
│  new_sum = old_sum + arr[right] - arr[left-1]          │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Type 2: Dynamic Size Window

```
┌─────────────────────────────────────────────────────────┐
│  DYNAMIC SIZE WINDOW                                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Problem: Smallest subarray with sum ≥ target          │
│                                                         │
│  [2, 3, 1, 2, 4, 3]   target = 7                       │
│                                                         │
│  Expand until sum ≥ 7, then shrink to minimize         │
│                                                         │
│  [2, 3, 1, 2] → sum = 8 ≥ 7, window size = 4          │
│     [3, 1, 2] → sum = 6 < 7, must expand              │
│     [3, 1, 2, 4] → sum = 10 ≥ 7, window size = 4      │
│        [1, 2, 4] → sum = 7 ≥ 7, window size = 3       │
│           [2, 4] → sum = 6 < 7, must expand           │
│           [2, 4, 3] → sum = 9 ≥ 7, window size = 3    │
│              [4, 3] → sum = 7 ≥ 7, window size = 2 ←  │
│                                                         │
│  Minimum size = 2 → [4, 3]                             │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Pattern 2.3.1: Maximum Sum Subarray of Size K

### Implementation (Fixed Window)

```python
def max_sum_subarray_k(arr: list[int], k: int) -> int:
    """
    Find maximum sum of any contiguous subarray of size k.
    
    Time: O(n), Space: O(1)
    """
    n = len(arr)
    if n < k:
        return 0
    
    # Calculate sum of first window
    window_sum = sum(arr[:k])
    max_sum = window_sum
    
    # Slide the window
    for right in range(k, n):
        # Add new element, remove leftmost element
        window_sum += arr[right] - arr[right - k]
        max_sum = max(max_sum, window_sum)
    
    return max_sum

# Trace for [2, 1, 5, 1, 3, 2], k=3:
# Initial window: [2,1,5], sum = 8, max = 8
# Slide: remove 2, add 1 → [1,5,1], sum = 7, max = 8
# Slide: remove 1, add 3 → [5,1,3], sum = 9, max = 9
# Slide: remove 5, add 2 → [1,3,2], sum = 6, max = 9
# Result: 9
```

---

## Pattern 2.3.2: Minimum Size Subarray Sum

### Implementation (Dynamic Window)

```python
def min_sub_array_len(target: int, nums: list[int]) -> int:
    """
    Find shortest subarray with sum ≥ target.
    
    Time: O(n), Space: O(1)
    """
    left = 0
    window_sum = 0
    min_length = float('inf')
    
    for right in range(len(nums)):
        # Expand window
        window_sum += nums[right]
        
        # Shrink window while condition is satisfied
        while window_sum >= target:
            min_length = min(min_length, right - left + 1)
            window_sum -= nums[left]
            left += 1
    
    return min_length if min_length != float('inf') else 0

# Trace for [2,3,1,2,4,3], target=7:
# right=0: sum=2 < 7
# right=1: sum=5 < 7
# right=2: sum=6 < 7
# right=3: sum=8 ≥ 7 → len=4, shrink: sum=6 < 7
# right=4: sum=10 ≥ 7 → len=4, shrink: sum=7 ≥ 7 → len=3
#          shrink: sum=5 < 7
# right=5: sum=8 ≥ 7 → len=3, shrink: sum=7 ≥ 7 → len=2 ✓
#          shrink: sum=3 < 7
# Result: 2
```

---

## Pattern 2.3.3: Longest Substring Without Repeating Characters

### Visualization

```
String: "abcabcbb"

┌────────────────────────────────────────────────────────┐
│                                                        │
│  Window expands until duplicate found:                 │
│                                                        │
│  [a] b c a b c b b     seen = {a}                     │
│   L R                   max_len = 1                    │
│                                                        │
│  [a b] c a b c b b     seen = {a,b}                   │
│   L   R                 max_len = 2                    │
│                                                        │
│  [a b c] a b c b b     seen = {a,b,c}                 │
│   L     R               max_len = 3                    │
│                                                        │
│  [a b c a] b c b b     'a' repeated!                  │
│   L       R             Shrink from left              │
│                                                        │
│    [b c a] b c b b     seen = {b,c,a}                 │
│     L     R             max_len = 3                    │
│                                                        │
│  ... continue ...       Final max_len = 3             │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### Implementation

```python
def length_of_longest_substring(s: str) -> int:
    """
    Find length of longest substring without repeating characters.
    
    Time: O(n), Space: O(min(n, alphabet_size))
    """
    char_index = {}  # Last seen index of each character
    left = 0
    max_length = 0
    
    for right, char in enumerate(s):
        # If char seen and within current window
        if char in char_index and char_index[char] >= left:
            # Move left to skip the duplicate
            left = char_index[char] + 1
        
        # Update last seen index
        char_index[char] = right
        
        # Update max length
        max_length = max(max_length, right - left + 1)
    
    return max_length

# Alternative using set (clearer logic)
def length_of_longest_substring_v2(s: str) -> int:
    char_set = set()
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        # Shrink window until no duplicate
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

---

## Pattern 2.3.4: Longest Substring with At Most K Distinct Characters

### Implementation

```python
def length_of_longest_substring_k_distinct(s: str, k: int) -> int:
    """
    Find longest substring with at most k distinct characters.
    
    Time: O(n), Space: O(k)
    """
    from collections import defaultdict
    
    char_count = defaultdict(int)
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        # Expand: add character to window
        char_count[s[right]] += 1
        
        # Shrink: while more than k distinct characters
        while len(char_count) > k:
            char_count[s[left]] -= 1
            if char_count[s[left]] == 0:
                del char_count[s[left]]
            left += 1
        
        # Update max
        max_length = max(max_length, right - left + 1)
    
    return max_length

# Trace for "eceba", k=2:
# right=0 'e': {e:1}, len=1, max=1
# right=1 'c': {e:1,c:1}, len=2, max=2
# right=2 'e': {e:2,c:1}, len=2, max=3
# right=3 'b': {e:2,c:1,b:1}, len=3 > k=2!
#              Shrink: remove 'e' → {e:1,c:1,b:1} still 3
#              Shrink: remove 'c' → {e:1,b:1}, len=2, max=3
# right=4 'a': {e:1,b:1,a:1}, len=3 > k=2!
#              Shrink: remove 'e' → {b:1,a:1}, len=2, max=3
# Result: 3 ("ece" or "eba")
```

---

## Pattern 2.3.5: Minimum Window Substring (Hard)

### Problem
Find smallest substring of s that contains all characters of t.

### Visualization

```
s = "ADOBECODEBANC", t = "ABC"

Need: A=1, B=1, C=1

┌────────────────────────────────────────────────────────┐
│                                                        │
│  Expand until we have all characters of t:             │
│                                                        │
│  [A D O B E C] O D E B A N C                          │
│   L         R                                          │
│   have: A=1,B=1,C=1 ✓                                 │
│   Window = "ADOBEC", length = 6                        │
│                                                        │
│  Shrink while still valid:                             │
│                                                        │
│    [D O B E C] O D E B A N C   (removed A, invalid!)  │
│     L       R                                          │
│   Must expand again...                                 │
│                                                        │
│  Continue until find minimum: "BANC" (length 4)        │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### Implementation

```python
from collections import Counter

def min_window(s: str, t: str) -> str:
    """
    Find minimum window substring containing all chars of t.
    
    Time: O(n + m), Space: O(m) where n=len(s), m=len(t)
    """
    if not s or not t or len(s) < len(t):
        return ""
    
    # Count characters needed
    need = Counter(t)
    required = len(need)  # Unique chars to match
    
    # Window state
    window_counts = {}
    formed = 0  # Number of unique chars with desired frequency
    
    # Result tracking
    min_len = float('inf')
    result = (0, 0)  # (start, end)
    
    left = 0
    
    for right, char in enumerate(s):
        # Expand: add character to window
        window_counts[char] = window_counts.get(char, 0) + 1
        
        # Check if this char's frequency matches requirement
        if char in need and window_counts[char] == need[char]:
            formed += 1
        
        # Shrink while window is valid
        while formed == required:
            # Update result if smaller window found
            if right - left + 1 < min_len:
                min_len = right - left + 1
                result = (left, right)
            
            # Remove left character
            left_char = s[left]
            window_counts[left_char] -= 1
            
            if left_char in need and window_counts[left_char] < need[left_char]:
                formed -= 1
            
            left += 1
    
    return "" if min_len == float('inf') else s[result[0]:result[1] + 1]
```

---

## Sliding Window: Master Template

```python
def sliding_window_template(arr, condition_params):
    """
    Universal sliding window template.
    
    Adapt the condition checks for your specific problem.
    """
    left = 0
    result = initial_value()
    window_state = initialize_state()  # sum, count, set, dict, etc.
    
    for right in range(len(arr)):
        # ═══════════════════════════════════════════
        # STEP 1: EXPAND - Add arr[right] to window
        # ═══════════════════════════════════════════
        update_state_add(window_state, arr[right])
        
        # ═══════════════════════════════════════════
        # STEP 2: SHRINK - While window violates condition
        # ═══════════════════════════════════════════
        while window_invalid(window_state, condition_params):
            update_state_remove(window_state, arr[left])
            left += 1
        
        # ═══════════════════════════════════════════
        # STEP 3: UPDATE - Record result
        # ═══════════════════════════════════════════
        # For maximum: result = max(result, right - left + 1)
        # For minimum: if valid: result = min(result, ...)
        # For count: result += number of valid subarrays
        result = update_result(result, window_state, left, right)
    
    return result
```

---

## Sliding Window: Summary

```
┌─────────────────────────────────────────────────────────┐
│  SLIDING WINDOW DECISION GUIDE                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  FIXED SIZE WINDOW:                                     │
│  • "Subarray of size k"                                 │
│  • "Window of exactly n elements"                       │
│  • Technique: Add right, remove left simultaneously     │
│                                                         │
│  DYNAMIC SIZE WINDOW (Maximum):                         │
│  • "Longest substring with..."                          │
│  • "Maximum length where..."                            │
│  • Technique: Expand always, shrink when invalid        │
│                                                         │
│  DYNAMIC SIZE WINDOW (Minimum):                         │
│  • "Shortest subarray with..."                          │
│  • "Minimum length where..."                            │
│  • Technique: Expand until valid, shrink while valid    │
│                                                         │
│  COUNTING SUBARRAYS:                                    │
│  • "Number of subarrays where..."                       │
│  • Technique: Count valid subarrays ending at each R    │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

# 2.4 Multiple Arrays/Strings

## Core Concept

Pointers traverse **different data structures** simultaneously, typically for merging, comparing, or intersecting.

```
┌─────────────────────────────────────────────────────────┐
│              PARALLEL POINTER TRAVERSAL                 │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Array A: [1, 3, 5, 7, 9]                              │
│            ↑                                            │
│            i                                            │
│                                                         │
│  Array B: [2, 4, 5, 6, 8, 10]                          │
│            ↑                                            │
│            j                                            │
│                                                         │
│  Move pointers based on comparison:                     │
│  • A[i] < B[j]: process A[i], i++                      │
│  • A[i] > B[j]: process B[j], j++                      │
│  • A[i] == B[j]: process both, i++, j++                │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Pattern 2.4.1: Merge Two Sorted Arrays

### Problem
Merge nums2 into nums1 in-place. nums1 has enough space at the end.

### Visualization

```
nums1 = [1, 2, 3, 0, 0, 0], m = 3
nums2 = [2, 5, 6], n = 3

KEY INSIGHT: Start from the END to avoid overwriting!

┌────────────────────────────────────────────────────────┐
│                                                        │
│  [1, 2, 3, 0, 0, 0]    [2, 5, 6]                      │
│         ↑        ↑            ↑                        │
│        p1        p           p2                        │
│                                                        │
│  Step 1: 3 < 6, place 6                               │
│  [1, 2, 3, 0, 0, 6]    [2, 5, 6]                      │
│         ↑     ↑         ↑                              │
│        p1     p        p2                              │
│                                                        │
│  Step 2: 3 < 5, place 5                               │
│  [1, 2, 3, 0, 5, 6]    [2, 5, 6]                      │
│         ↑  ↑         ↑                                 │
│        p1  p        p2                                 │
│                                                        │
│  Step 3: 3 > 2, place 3                               │
│  [1, 2, 3, 3, 5, 6]    [2, 5, 6]                      │
│      ↑  ↑            ↑                                 │
│     p1  p           p2                                 │
│                                                        │
│  Step 4: 2 == 2, place nums1's 2 (either works)       │
│  [1, 2, 2, 3, 5, 6]    [2, 5, 6]                      │
│   ↑  ↑               ↑                                 │
│  p1  p              p2                                 │
│                                                        │
│  Step 5: 1 < 2, place 2                               │
│  [1, 2, 2, 3, 5, 6]    [2, 5, 6]                      │
│   ↑↑                ↑ (exhausted)                      │
│  p1p               p2                                  │
│                                                        │
│  Result: [1, 2, 2, 3, 5, 6] ✓                         │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### Implementation

```python
def merge(nums1: list[int], m: int, nums2: list[int], n: int) -> None:
    """
    Merge nums2 into nums1 in-place.
    
    Time: O(m + n), Space: O(1)
    """
    p1 = m - 1      # Last element of nums1's actual content
    p2 = n - 1      # Last element of nums2
    p = m + n - 1   # Last position in nums1
    
    # Merge from back to front
    while p1 >= 0 and p2 >= 0:
        if nums1[p1] > nums2[p2]:
            nums1[p] = nums1[p1]
            p1 -= 1
        else:
            nums1[p] = nums2[p2]
            p2 -= 1
        p -= 1
    
    # Copy remaining elements from nums2 (if any)
    # Note: If p1 >= 0, elements are already in place
    while p2 >= 0:
        nums1[p] = nums2[p2]
        p2 -= 1
        p -= 1
```

---

## Pattern 2.4.2: Intersection of Two Arrays

### Version 1: Return Unique Elements

```python
def intersection(nums1: list[int], nums2: list[int]) -> list[int]:
    """
    Find intersection (unique elements).
    Using sorting + two pointers.
    
    Time: O(n log n + m log m), Space: O(1) excluding output
    """
    nums1.sort()
    nums2.sort()
    
    i, j = 0, 0
    result = []
    
    while i < len(nums1) and j < len(nums2):
        if nums1[i] < nums2[j]:
            i += 1
        elif nums1[i] > nums2[j]:
            j += 1
        else:
            # Found intersection
            if not result or result[-1] != nums1[i]:
                result.append(nums1[i])
            i += 1
            j += 1
    
    return result
```

### Version 2: Return All Occurrences

```python
def intersect(nums1: list[int], nums2: list[int]) -> list[int]:
    """
    Find intersection (include duplicates).
    Each element appears as many times as it shows in both.
    
    Time: O(n log n + m log m), Space: O(1) excluding output
    """
    nums1.sort()
    nums2.sort()
    
    i, j = 0, 0
    result = []
    
    while i < len(nums1) and j < len(nums2):
        if nums1[i] < nums2[j]:
            i += 1
        elif nums1[i] > nums2[j]:
            j += 1
        else:
            result.append(nums1[i])  # Add every match
            i += 1
            j += 1
    
    return result

# Example:
# nums1 = [1, 2, 2, 3], nums2 = [2, 2, 3, 4]
# Intersection with duplicates: [2, 2, 3]
```

---

## Pattern 2.4.3: Compare Version Numbers

### Problem
Compare two version strings like "1.0.1" and "1.0.2".

### Visualization

```
version1 = "1.01.0"
version2 = "1.001.0.0"

Split and compare:
┌────────────────────────────────────────────────────────┐
│                                                        │
│  v1: [1, 01, 0]      →  [1, 1, 0]                     │
│       ↑                                                │
│       i                                                │
│                                                        │
│  v2: [1, 001, 0, 0]  →  [1, 1, 0, 0]                  │
│       ↑                                                │
│       j                                                │
│                                                        │
│  Compare: 1==1, 1==1, 0==0, 0==0 (treat missing as 0) │
│  Result: Equal (return 0)                              │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### Implementation

```python
def compare_version(version1: str, version2: str) -> int:
    """
    Compare version numbers.
    Return -1 if v1 < v2, 1 if v1 > v2, 0 if equal.
    
    Time: O(n + m), Space: O(n + m)
    """
    v1 = version1.split('.')
    v2 = version2.split('.')
    
    i, j = 0, 0
    
    while i < len(v1) or j < len(v2):
        # Get current version number (0 if exhausted)
        num1 = int(v1[i]) if i < len(v1) else 0
        num2 = int(v2[j]) if j < len(v2) else 0
        
        if num1 < num2:
            return -1
        elif num1 > num2:
            return 1
        
        i += 1
        j += 1
    
    return 0  # All parts equal

# Space-optimized version (no split)
def compare_version_optimized(version1: str, version2: str) -> int:
    i, j = 0, 0
    n1, n2 = len(version1), len(version2)
    
    while i < n1 or j < n2:
        # Extract number from version1
        num1 = 0
        while i < n1 and version1[i] != '.':
            num1 = num1 * 10 + int(version1[i])
            i += 1
        i += 1  # Skip '.'
        
        # Extract number from version2
        num2 = 0
        while j < n2 and version2[j] != '.':
            num2 = num2 * 10 + int(version2[j])
            j += 1
        j += 1  # Skip '.'
        
        if num1 != num2:
            return -1 if num1 < num2 else 1
    
    return 0
```

---

## Pattern 2.4.4: Backspace String Compare

### Problem
Compare two strings where '#' means backspace.

### Two Pointer Solution (O(1) space)

```python
def backspace_compare(s: str, t: str) -> bool:
    """
    Compare strings with backspace characters.
    
    Key Insight: Process from RIGHT to LEFT!
    
    Time: O(n + m), Space: O(1)
    """
    def get_next_valid_char_index(string: str, index: int) -> int:
        """
        Find next valid character index, skipping backspaced chars.
        """
        skip = 0
        while index >= 0:
            if string[index] == '#':
                skip += 1
                index -= 1
            elif skip > 0:
                skip -= 1
                index -= 1
            else:
                break
        return index
    
    i = len(s) - 1
    j = len(t) - 1
    
    while i >= 0 or j >= 0:
        i = get_next_valid_char_index(s, i)
        j = get_next_valid_char_index(t, j)
        
        # Both exhausted
        if i < 0 and j < 0:
            return True
        
        # One exhausted
        if i < 0 or j < 0:
            return False
        
        # Compare characters
        if s[i] != t[j]:
            return False
        
        i -= 1
        j -= 1
    
    return True

# Trace for s="ab#c", t="ad#c":
# s: start at i=3 ('c'), no skip → compare 'c'
# t: start at j=3 ('c'), no skip → compare 'c'
# 'c' == 'c' ✓
# 
# s: i=2 ('#'), skip=1 → i=1 ('b'), skip>0 → i=0 ('a')
# t: j=2 ('#'), skip=1 → j=1 ('d'), skip>0 → j=0 ('a')
# 'a' == 'a' ✓
# 
# Both exhausted → True
```

---

## Pattern 2.4.5: Squares of a Sorted Array

### Problem
Given sorted array, return squares in sorted order.

### Visualization

```
Input: [-4, -1, 0, 3, 10]
Squares: [16, 1, 0, 9, 100]

Key Insight: Largest squares are at the ENDS!

┌────────────────────────────────────────────────────────┐
│                                                        │
│  [-4, -1, 0, 3, 10]                                   │
│    ↑            ↑                                      │
│    L            R                                      │
│                                                        │
│  |−4|² = 16 vs |10|² = 100                            │
│  100 > 16 → place 100, R--                            │
│                                                        │
│  Result: [_, _, _, _, 100]                            │
│                     ↑                                  │
│                   fill                                 │
│                                                        │
│  Continue...                                           │
│  Final: [0, 1, 9, 16, 100]                            │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### Implementation

```python
def sorted_squares(nums: list[int]) -> list[int]:
    """
    Return sorted squares of sorted array.
    
    Time: O(n), Space: O(n)
    """
    n = len(nums)
    result = [0] * n
    
    left, right = 0, n - 1
    pos = n - 1  # Fill from the end
    
    while left <= right:
        left_sq = nums[left] ** 2
        right_sq = nums[right] ** 2
        
        if left_sq > right_sq:
            result[pos] = left_sq
            left += 1
        else:
            result[pos] = right_sq
            right -= 1
        
        pos -= 1
    
    return result
```

---

## Multiple Arrays: Summary

```
┌─────────────────────────────────────────────────────────┐
│  MULTIPLE ARRAY PATTERNS                                │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  MERGE (Both sorted):                                   │
│  • Compare elements, place smaller                      │
│  • Common: Merge from END to avoid overwriting          │
│                                                         │
│  INTERSECTION/UNION:                                    │
│  • Both sorted: Two pointers O(n+m)                    │
│  • Unsorted: Hash set approach                          │
│                                                         │
│  COMPARISON:                                            │
│  • Traverse both simultaneously                         │
│  • Handle different lengths (pad with default)          │
│  • Consider processing from right (backspace)           │
│                                                         │
│  KEY DECISIONS:                                         │
│  • Which pointer to advance?                            │
│  • What if lengths differ?                              │
│  • Left-to-right or right-to-left?                     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

# Chapter 2: Master Summary

```
┌─────────────────────────────────────────────────────────┐
│         TWO POINTER CATEGORIES AT A GLANCE              │
├──────────────────┬──────────────────────────────────────┤
│                  │                                      │
│  OPPOSITE        │  • Start at both ends                │
│  DIRECTION       │  • Move inward based on comparison   │
│                  │  • Two Sum, Container, Palindrome    │
│                  │                                      │
├──────────────────┼──────────────────────────────────────┤
│                  │                                      │
│  SAME            │  • Start at same position            │
│  DIRECTION       │  • Different speeds OR conditions    │
│                  │  • Remove dupes, Cycle detection     │
│                  │                                      │
├──────────────────┼──────────────────────────────────────┤
│                  │                                      │
│  SLIDING         │  • Window between two pointers       │
│  WINDOW          │  • Expand (R++) and shrink (L++)    │
│                  │  • Subarray sum, Longest substring   │
│                  │                                      │
├──────────────────┼──────────────────────────────────────┤
│                  │                                      │
│  MULTIPLE        │  • Pointers on different arrays     │
│  ARRAYS          │  • Parallel traversal                │
│                  │  • Merge, Intersection, Compare      │
│                  │                                      │
└──────────────────┴──────────────────────────────────────┘
```

---

## Decision Tree: Which Pattern to Use?

```
                        START
                          │
          ┌───────────────┴───────────────┐
          │ Single array/string?          │
          └───────────────┬───────────────┘
                 YES      │       NO
          ┌───────────────┴───────┐
          │                       │
          ▼                       ▼
    ┌───────────┐         MULTIPLE ARRAYS
    │ Sorted?   │         (Pattern 2.4)
    └─────┬─────┘
     YES  │  NO
          │   │
          │   └──→ Can sort? ──YES──→ Sort first
          │              │
          ▼              NO
    ┌─────────────────┐   │
    │ Find pair/sum?  │   │
    └────────┬────────┘   │
        YES  │  NO        │
             │   │        │
    OPPOSITE │   │        │
    DIRECTION│   ▼        ▼
   (2.1)     │ ┌────────────────────┐
             │ │ Contiguous         │
             │ │ subarray problem?  │
             │ └─────────┬──────────┘
             │      YES  │  NO
             │           │   │
             │   SLIDING │   │
             │   WINDOW  │   │
             │   (2.3)   │   ▼
             │           │ ┌─────────────┐
             │           │ │ In-place    │
             │           │ │ modification│
             │           │ │ or cycle?   │
             │           │ └──────┬──────┘
             │           │   YES  │
             │           │        │
             │           │   SAME │
             │           │DIRECTION
             │           │  (2.2) │
             └───────────┴────────┘
```

---

**Next Chapter:** Chapter 3 will dive deep into specific pattern implementations with advanced variations and optimization techniques.
