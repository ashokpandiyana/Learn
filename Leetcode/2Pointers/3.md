# Chapter 3: Pattern Deep Dive

## Advanced Techniques and Variations

---

# Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                    CHAPTER 3 ROADMAP                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  3.1 PAIR SUM VARIANTS                                         │
│      └── Two Sum → Three Sum → Four Sum → K-Sum                │
│                                                                 │
│  3.2 PARTITIONING PATTERNS                                     │
│      └── Dutch National Flag, Quick Select, 3-Way Partition    │
│                                                                 │
│  3.3 IN-PLACE MODIFICATION                                     │
│      └── Remove Duplicates, Allow K Duplicates, Compress       │
│                                                                 │
│  3.4 LINKED LIST PATTERNS                                      │
│      └── Cycle Detection, Find Start, Middle, Palindrome       │
│                                                                 │
│  3.5 PALINDROME PATTERNS                                       │
│      └── Basic, Allow Deletions, Longest Palindromic           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# 3.1 Pattern: Pair Sum Variants

## The Evolution of Sum Problems

```
┌─────────────────────────────────────────────────────────────────┐
│                    SUM PROBLEM HIERARCHY                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  TWO SUM          →  Find 2 numbers summing to target          │
│  (Foundation)        Time: O(n), Space: O(1) on sorted         │
│       │                                                         │
│       ▼                                                         │
│  THREE SUM        →  Find 3 numbers summing to target          │
│  (Fix 1 + Two Sum)   Time: O(n²), Space: O(1)                  │
│       │                                                         │
│       ▼                                                         │
│  FOUR SUM         →  Find 4 numbers summing to target          │
│  (Fix 2 + Two Sum)   Time: O(n³), Space: O(1)                  │
│       │                                                         │
│       ▼                                                         │
│  K-SUM            →  Find K numbers summing to target          │
│  (Recursive)         Time: O(n^(k-1)), Space: O(k)             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3.1.1 Two Sum II - The Foundation

### Problem
Find two numbers in a **sorted** array that sum to target.

### Core Insight

```
┌─────────────────────────────────────────────────────────────────┐
│  WHY TWO POINTERS WORK ON SORTED ARRAYS                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Array: [1, 2, 4, 6, 8, 10, 12]    Target: 14                  │
│          ↑                    ↑                                 │
│          L                    R                                 │
│                                                                 │
│  Current Sum = 1 + 12 = 13 < 14                                │
│                                                                 │
│  OBSERVATION:                                                   │
│  • 1 + 12 = 13 (too small)                                     │
│  • 1 + 10 = 11 (even smaller!)                                 │
│  • 1 + 8 = 9   (even smaller!)                                 │
│  • 1 + ANY element < 12 will be < 13 < 14                      │
│                                                                 │
│  CONCLUSION: 1 can NEVER be part of the answer!                │
│  ACTION: Move L right to try larger values                     │
│                                                                 │
│  This ELIMINATION is why O(n) is possible!                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation with Edge Cases

```python
def two_sum_ii(numbers: list[int], target: int) -> list[int]:
    """
    Find two numbers that sum to target in sorted array.
    Return 1-indexed positions.
    
    Time: O(n), Space: O(1)
    
    Edge Cases Handled:
    - Negative numbers
    - Duplicate values
    - Target at extremes
    """
    left, right = 0, len(numbers) - 1
    
    while left < right:
        current_sum = numbers[left] + numbers[right]
        
        if current_sum == target:
            return [left + 1, right + 1]  # 1-indexed
        elif current_sum < target:
            left += 1
        else:
            right -= 1
    
    return [-1, -1]  # No solution found

# Variant: Find pair with given DIFFERENCE
def two_sum_difference(numbers: list[int], diff: int) -> list[int]:
    """
    Find two numbers where numbers[j] - numbers[i] = diff
    Array is sorted.
    
    Time: O(n), Space: O(1)
    """
    left, right = 0, 1
    n = len(numbers)
    
    while right < n:
        current_diff = numbers[right] - numbers[left]
        
        if left == right:  # Can't use same element
            right += 1
        elif current_diff == diff:
            return [left, right]
        elif current_diff < diff:
            right += 1  # Need larger difference
        else:
            left += 1   # Need smaller difference
    
    return [-1, -1]

# Example: [1, 3, 5, 7, 9], diff = 4
# Output: [0, 2] because 5 - 1 = 4
```

---

## 3.1.2 Three Sum - Building on Two Sum

### Problem
Find all unique triplets that sum to zero.

### Strategy Visualization

```
┌─────────────────────────────────────────────────────────────────┐
│  3SUM = FIXED ELEMENT + 2SUM                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Array: [-4, -1, -1, 0, 1, 2]    Target: 0                     │
│                                                                 │
│  ITERATION 1: Fix nums[0] = -4                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Need to find two numbers that sum to 4 (= -(-4))       │   │
│  │  Search space: [-1, -1, 0, 1, 2]                        │   │
│  │                  ↑            ↑                          │   │
│  │                  L            R                          │   │
│  │  -1 + 2 = 1 < 4 → L++                                   │   │
│  │  -1 + 2 = 1 < 4 → L++                                   │   │
│  │  0 + 2 = 2 < 4 → L++                                    │   │
│  │  1 + 2 = 3 < 4 → L++                                    │   │
│  │  L >= R → No triplet with -4                            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ITERATION 2: Fix nums[1] = -1                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Need to find two numbers that sum to 1 (= -(-1))       │   │
│  │  Search space: [-1, 0, 1, 2]                            │   │
│  │                  ↑        ↑                              │   │
│  │                  L        R                              │   │
│  │  -1 + 2 = 1 == 1 ✓ → Found [-1, -1, 2]                 │   │
│  │  Skip duplicates, L++, R--                              │   │
│  │  0 + 1 = 1 == 1 ✓ → Found [-1, 0, 1]                   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ITERATION 3: Fix nums[2] = -1 → SKIP (duplicate!)             │
│                                                                 │
│  Result: [[-1, -1, 2], [-1, 0, 1]]                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Complete Implementation with Optimizations

```python
def three_sum(nums: list[int]) -> list[list[int]]:
    """
    Find all unique triplets that sum to zero.
    
    Time: O(n²), Space: O(1) excluding output
    
    Key Optimizations:
    1. Early termination if smallest > 0
    2. Skip if current + two largest < 0
    3. Proper duplicate handling
    """
    nums.sort()
    result = []
    n = len(nums)
    
    for i in range(n - 2):
        # OPTIMIZATION 1: If smallest positive, no solution possible
        if nums[i] > 0:
            break
        
        # DUPLICATE HANDLING: Skip same values for i
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        
        # OPTIMIZATION 2: If sum of three smallest > 0, break
        if nums[i] + nums[i + 1] + nums[i + 2] > 0:
            break
        
        # OPTIMIZATION 3: If current + two largest < 0, skip this i
        if nums[i] + nums[n - 2] + nums[n - 1] < 0:
            continue
        
        # Two Sum for remaining elements
        target = -nums[i]
        left, right = i + 1, n - 1
        
        while left < right:
            current_sum = nums[left] + nums[right]
            
            if current_sum == target:
                result.append([nums[i], nums[left], nums[right]])
                
                # Skip duplicates for left pointer
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                # Skip duplicates for right pointer
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                
                left += 1
                right -= 1
                
            elif current_sum < target:
                left += 1
            else:
                right -= 1
    
    return result
```

### Three Sum Closest Variant

```python
def three_sum_closest(nums: list[int], target: int) -> int:
    """
    Find triplet sum closest to target.
    
    Time: O(n²), Space: O(1)
    """
    nums.sort()
    n = len(nums)
    closest_sum = float('inf')
    
    for i in range(n - 2):
        # Skip duplicates (optional, for efficiency)
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        
        left, right = i + 1, n - 1
        
        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]
            
            # Update if closer to target
            if abs(current_sum - target) < abs(closest_sum - target):
                closest_sum = current_sum
            
            if current_sum == target:
                return target  # Can't get closer than exact match
            elif current_sum < target:
                left += 1
            else:
                right -= 1
    
    return closest_sum
```

---

## 3.1.3 Four Sum - Extending the Pattern

### Strategy

```
┌─────────────────────────────────────────────────────────────────┐
│  4SUM = FIX TWO ELEMENTS + 2SUM                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  for i in range(n-3):           # First element                │
│      for j in range(i+1, n-2):  # Second element               │
│          # Two pointer for remaining two elements               │
│          left, right = j+1, n-1                                │
│          target = TARGET - nums[i] - nums[j]                   │
│          # Standard two sum...                                  │
│                                                                 │
│  Time Complexity: O(n) × O(n) × O(n) = O(n³)                   │
│                   (i)   (j)   (two-pointer)                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def four_sum(nums: list[int], target: int) -> list[list[int]]:
    """
    Find all unique quadruplets that sum to target.
    
    Time: O(n³), Space: O(1) excluding output
    """
    nums.sort()
    result = []
    n = len(nums)
    
    for i in range(n - 3):
        # Skip duplicates for first element
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        
        # OPTIMIZATION: Early termination
        if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target:
            break
        if nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target:
            continue
        
        for j in range(i + 1, n - 2):
            # Skip duplicates for second element
            if j > i + 1 and nums[j] == nums[j - 1]:
                continue
            
            # OPTIMIZATION: Early termination for inner loop
            if nums[i] + nums[j] + nums[j+1] + nums[j+2] > target:
                break
            if nums[i] + nums[j] + nums[n-2] + nums[n-1] < target:
                continue
            
            # Two Sum for remaining elements
            left, right = j + 1, n - 1
            remaining = target - nums[i] - nums[j]
            
            while left < right:
                current_sum = nums[left] + nums[right]
                
                if current_sum == remaining:
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    
                    left += 1
                    right -= 1
                    
                elif current_sum < remaining:
                    left += 1
                else:
                    right -= 1
    
    return result
```

---

## 3.1.4 K-Sum Generalization

### Recursive Approach

```
┌─────────────────────────────────────────────────────────────────┐
│  K-SUM RECURSION STRATEGY                                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  k_sum(k, start, target):                                      │
│                                                                 │
│  BASE CASE (k == 2):                                           │
│  └── Use two pointers to find pairs                            │
│                                                                 │
│  RECURSIVE CASE (k > 2):                                       │
│  └── For each element at index i:                              │
│      └── Find (k-1)-sum in remaining array                     │
│      └── Add current element to each result                    │
│                                                                 │
│  Example: 4-Sum                                                 │
│  4-sum(target) → fix nums[i] + 3-sum(target - nums[i])        │
│                → fix nums[j] + 2-sum(remaining)                │
│                → two pointers                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def k_sum(nums: list[int], target: int, k: int) -> list[list[int]]:
    """
    Generalized K-Sum problem.
    Find all unique k-tuples that sum to target.
    
    Time: O(n^(k-1)), Space: O(k) for recursion
    """
    nums.sort()
    return k_sum_helper(nums, target, k, 0)

def k_sum_helper(nums: list[int], target: int, k: int, start: int) -> list[list[int]]:
    result = []
    n = len(nums)
    
    # BASE CASE: Two Sum with two pointers
    if k == 2:
        left, right = start, n - 1
        while left < right:
            current_sum = nums[left] + nums[right]
            if current_sum == target:
                result.append([nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif current_sum < target:
                left += 1
            else:
                right -= 1
        return result
    
    # RECURSIVE CASE
    for i in range(start, n - k + 1):
        # Skip duplicates
        if i > start and nums[i] == nums[i - 1]:
            continue
        
        # OPTIMIZATION: Early termination
        # Smallest possible sum with current element
        if nums[i] + sum(nums[i+1:i+k]) > target:
            break
        # Largest possible sum with current element
        if nums[i] + sum(nums[n-k+1:]) < target:
            continue
        
        # Recurse for (k-1)-sum
        sub_results = k_sum_helper(nums, target - nums[i], k - 1, i + 1)
        
        # Prepend current element to each sub-result
        for sub in sub_results:
            result.append([nums[i]] + sub)
    
    return result

# Usage:
# two_sum: k_sum(nums, target, 2)
# three_sum: k_sum(nums, 0, 3)
# four_sum: k_sum(nums, target, 4)
# five_sum: k_sum(nums, target, 5)
```

---

## Pair Sum Variants: Summary

```
┌─────────────────────────────────────────────────────────────────┐
│  SUM PROBLEMS COMPARISON                                        │
├──────────────┬──────────────┬──────────────┬───────────────────┤
│  Problem     │  Time        │  Space       │  Approach         │
├──────────────┼──────────────┼──────────────┼───────────────────┤
│  2-Sum       │  O(n)        │  O(1)        │  Two pointers     │
│  3-Sum       │  O(n²)       │  O(1)        │  Fix 1 + 2-sum    │
│  4-Sum       │  O(n³)       │  O(1)        │  Fix 2 + 2-sum    │
│  K-Sum       │  O(n^(k-1))  │  O(k)        │  Recursive        │
├──────────────┴──────────────┴──────────────┴───────────────────┤
│                                                                 │
│  KEY INSIGHTS:                                                  │
│  • Always SORT first                                            │
│  • Handle duplicates at EVERY level                             │
│  • Use early termination optimizations                          │
│  • Base case is always Two Sum with two pointers               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# 3.2 Pattern: Partitioning

## Core Concept

Partitioning rearranges array elements based on a condition, placing elements into different "regions."

```
┌─────────────────────────────────────────────────────────────────┐
│                   PARTITIONING CONCEPT                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  2-WAY PARTITION (Quick Sort style):                           │
│  ┌──────────────────┬──────────────────┐                       │
│  │   < pivot        │    >= pivot      │                       │
│  └──────────────────┴──────────────────┘                       │
│                                                                 │
│  3-WAY PARTITION (Dutch National Flag):                        │
│  ┌──────────────────┬──────────────────┬──────────────────┐    │
│  │   < pivot        │    == pivot      │    > pivot       │    │
│  └──────────────────┴──────────────────┴──────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3.2.1 Dutch National Flag (Sort Colors)

### Problem
Sort an array of 0s, 1s, and 2s in-place with single pass.

### Visualization

```
┌─────────────────────────────────────────────────────────────────┐
│  DUTCH NATIONAL FLAG ALGORITHM                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Three regions maintained by three pointers:                    │
│                                                                 │
│  [0,0,0,...] [1,1,1,...] [unsorted] [2,2,2,...]                │
│           ↑           ↑          ↑                              │
│          low         mid        high                            │
│                                                                 │
│  INVARIANTS:                                                    │
│  • [0, low)      : all 0s                                      │
│  • [low, mid)    : all 1s                                      │
│  • [mid, high]   : unsorted (being processed)                  │
│  • (high, n-1]   : all 2s                                      │
│                                                                 │
│  ALGORITHM:                                                     │
│  • If nums[mid] == 0: swap with low, low++, mid++              │
│  • If nums[mid] == 1: mid++ (already in place)                 │
│  • If nums[mid] == 2: swap with high, high--                   │
│    (DON'T increment mid - swapped element not yet examined!)   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Step-by-Step Example

```
Input: [2, 0, 2, 1, 1, 0]

┌────────────────────────────────────────────────────────────────┐
│                                                                │
│  Initial: [2, 0, 2, 1, 1, 0]                                  │
│            ↑              ↑                                    │
│           low            high                                  │
│           mid                                                  │
│                                                                │
│  Step 1: nums[mid]=2 → swap with high                         │
│          [0, 0, 2, 1, 1, 2]                                    │
│           ↑           ↑                                        │
│          low        high (high--)                              │
│          mid                                                   │
│          (mid stays - must check swapped value!)               │
│                                                                │
│  Step 2: nums[mid]=0 → swap with low                          │
│          [0, 0, 2, 1, 1, 2]                                    │
│              ↑        ↑                                        │
│             low     high                                       │
│             mid (low++, mid++)                                 │
│                                                                │
│  Step 3: nums[mid]=0 → swap with low                          │
│          [0, 0, 2, 1, 1, 2]                                    │
│                 ↑     ↑                                        │
│                low  high                                       │
│                mid                                             │
│                                                                │
│  Step 4: nums[mid]=2 → swap with high                         │
│          [0, 0, 1, 1, 2, 2]                                    │
│                 ↑  ↑                                           │
│                low high                                        │
│                mid                                             │
│                                                                │
│  Step 5: nums[mid]=1 → mid++                                  │
│          [0, 0, 1, 1, 2, 2]                                    │
│                 ↑  ↑                                           │
│                low high                                        │
│                   mid                                          │
│                                                                │
│  Step 6: nums[mid]=1 → mid++                                  │
│          [0, 0, 1, 1, 2, 2]                                    │
│                 ↑  ↑                                           │
│                low mid                                         │
│                   high                                         │
│                                                                │
│  mid > high → DONE!                                           │
│  Result: [0, 0, 1, 1, 2, 2] ✓                                 │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def sort_colors(nums: list[int]) -> None:
    """
    Sort array of 0s, 1s, 2s in-place (Dutch National Flag).
    
    Time: O(n) - single pass
    Space: O(1)
    """
    low = mid = 0
    high = len(nums) - 1
    
    while mid <= high:
        if nums[mid] == 0:
            # Swap with low region, expand both
            nums[low], nums[mid] = nums[mid], nums[low]
            low += 1
            mid += 1
        elif nums[mid] == 1:
            # Already in correct region
            mid += 1
        else:  # nums[mid] == 2
            # Swap with high region
            nums[mid], nums[high] = nums[high], nums[mid]
            high -= 1
            # DON'T increment mid! Need to examine swapped element

# Generalized version: partition around pivot value
def three_way_partition(nums: list[int], pivot: int) -> None:
    """
    Partition array into three regions: <pivot, ==pivot, >pivot
    """
    low = mid = 0
    high = len(nums) - 1
    
    while mid <= high:
        if nums[mid] < pivot:
            nums[low], nums[mid] = nums[mid], nums[low]
            low += 1
            mid += 1
        elif nums[mid] == pivot:
            mid += 1
        else:
            nums[mid], nums[high] = nums[high], nums[mid]
            high -= 1
```

---

## 3.2.2 Quick Select Partition

### Problem
Find the kth smallest/largest element.

### Lomuto Partition Scheme

```
┌─────────────────────────────────────────────────────────────────┐
│  LOMUTO PARTITION                                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Choose pivot (usually last element)                            │
│  Partition: [< pivot] [pivot] [>= pivot]                       │
│                                                                 │
│  Array: [3, 2, 1, 5, 4]    pivot = 4                           │
│                                                                 │
│  i = -1 (boundary of "less than" region)                       │
│                                                                 │
│  j=0: 3 < 4 → i++, swap → [3, 2, 1, 5, 4], i=0                │
│  j=1: 2 < 4 → i++, swap → [3, 2, 1, 5, 4], i=1                │
│  j=2: 1 < 4 → i++, swap → [3, 2, 1, 5, 4], i=2                │
│  j=3: 5 >= 4 → skip                                            │
│                                                                 │
│  Place pivot: swap(i+1, pivot_idx)                             │
│  [3, 2, 1, 4, 5]                                                │
│            ↑                                                    │
│         pivot at index 3                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def partition_lomuto(arr: list[int], low: int, high: int) -> int:
    """
    Lomuto partition scheme.
    Returns the final position of the pivot.
    
    Time: O(n), Space: O(1)
    """
    pivot = arr[high]  # Choose last element as pivot
    i = low - 1        # Boundary of "less than pivot" region
    
    for j in range(low, high):
        if arr[j] < pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    # Place pivot in its final position
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

def quick_select(arr: list[int], k: int) -> int:
    """
    Find kth smallest element (1-indexed).
    
    Time: O(n) average, O(n²) worst case
    Space: O(1)
    """
    k = k - 1  # Convert to 0-indexed
    left, right = 0, len(arr) - 1
    
    while left <= right:
        pivot_idx = partition_lomuto(arr, left, right)
        
        if pivot_idx == k:
            return arr[pivot_idx]
        elif pivot_idx < k:
            left = pivot_idx + 1
        else:
            right = pivot_idx - 1
    
    return -1  # k out of bounds

# Find kth largest = find (n-k+1)th smallest
def find_kth_largest(arr: list[int], k: int) -> int:
    return quick_select(arr.copy(), len(arr) - k + 1)
```

---

## 3.2.3 Hoare Partition Scheme

### Comparison

```
┌─────────────────────────────────────────────────────────────────┐
│  LOMUTO vs HOARE PARTITION                                      │
├──────────────────────────┬──────────────────────────────────────┤
│  LOMUTO                  │  HOARE                               │
├──────────────────────────┼──────────────────────────────────────┤
│  • Pivot at end          │  • Pivot can be anywhere             │
│  • Single pointer scan   │  • Two pointers from ends            │
│  • More swaps (~n/2)     │  • Fewer swaps (~n/6)               │
│  • Easier to understand  │  • More efficient in practice        │
│  • Returns exact pivot   │  • Returns partition point           │
│    position              │    (pivot may not be there)          │
└──────────────────────────┴──────────────────────────────────────┘
```

### Implementation

```python
def partition_hoare(arr: list[int], low: int, high: int) -> int:
    """
    Hoare partition scheme.
    More efficient than Lomuto.
    
    Note: Returns partition point, not pivot position!
    """
    pivot = arr[(low + high) // 2]  # Middle element as pivot
    i = low - 1
    j = high + 1
    
    while True:
        # Find element >= pivot from left
        i += 1
        while arr[i] < pivot:
            i += 1
        
        # Find element <= pivot from right
        j -= 1
        while arr[j] > pivot:
            j -= 1
        
        # If pointers crossed, return partition point
        if i >= j:
            return j
        
        # Swap elements
        arr[i], arr[j] = arr[j], arr[i]
```

---

## Partitioning: Summary

```
┌─────────────────────────────────────────────────────────────────┐
│  PARTITIONING PATTERNS                                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  DUTCH NATIONAL FLAG:                                           │
│  • Three pointers: low, mid, high                              │
│  • Three regions: <, ==, >                                     │
│  • Key: Don't increment mid when swapping with high!           │
│  • Use for: Sort colors, 3-way partition                       │
│                                                                 │
│  QUICK SELECT:                                                  │
│  • Find kth element in O(n) average                            │
│  • Based on partition around pivot                              │
│  • Only recurse on one side (unlike quicksort)                 │
│                                                                 │
│  LOMUTO vs HOARE:                                               │
│  • Lomuto: Simpler, exact pivot position                       │
│  • Hoare: Faster, fewer swaps, but tricky edge cases          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# 3.3 Pattern: In-Place Modification

## Core Concept

Modify arrays in-place using two pointers as "reader" and "writer."

```
┌─────────────────────────────────────────────────────────────────┐
│  IN-PLACE MODIFICATION PARADIGM                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  WRITER (slow): Where to write the next valid element          │
│  READER (fast): Scans through finding valid elements           │
│                                                                 │
│  [valid | valid | valid | ... to be written ... | processed ]   │
│                        ↑                              ↑         │
│                     WRITER                          READER      │
│                                                                 │
│  INVARIANT: Everything before WRITER is valid output           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3.3.1 Remove Duplicates - Allow At Most K

### Problem Generalization

```
┌─────────────────────────────────────────────────────────────────┐
│  REMOVE DUPLICATES VARIANTS                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  K = 1: Remove ALL duplicates (keep unique only)               │
│  Input:  [1, 1, 1, 2, 2, 3]                                    │
│  Output: [1, 2, 3]                                              │
│                                                                 │
│  K = 2: Allow at most 2 of each                                │
│  Input:  [1, 1, 1, 2, 2, 3]                                    │
│  Output: [1, 1, 2, 2, 3]                                        │
│                                                                 │
│  K = 3: Allow at most 3 of each                                │
│  Input:  [1, 1, 1, 1, 2, 2, 3]                                 │
│  Output: [1, 1, 1, 2, 2, 3]                                     │
│                                                                 │
│  GENERAL INSIGHT:                                               │
│  Compare nums[fast] with nums[slow - k]                        │
│  If different → can include nums[fast]                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Visualization for K=2

```
Input: [1, 1, 1, 2, 2, 3]    K = 2

┌────────────────────────────────────────────────────────────────┐
│                                                                │
│  Initial: slow = 2 (first K elements always valid)            │
│  [1, 1, 1, 2, 2, 3]                                           │
│         ↑  ↑                                                   │
│        slow fast                                               │
│                                                                │
│  fast=2: nums[2]=1, nums[slow-2]=nums[0]=1                    │
│          1 == 1 → SKIP (already have 2 ones)                  │
│  [1, 1, 1, 2, 2, 3]                                           │
│         ↑     ↑                                                │
│        slow  fast                                              │
│                                                                │
│  fast=3: nums[3]=2, nums[slow-2]=nums[0]=1                    │
│          2 != 1 → INCLUDE                                     │
│          nums[slow] = nums[fast], slow++                      │
│  [1, 1, 2, 2, 2, 3]                                           │
│            ↑     ↑                                             │
│           slow  fast                                           │
│                                                                │
│  fast=4: nums[4]=2, nums[slow-2]=nums[1]=1                    │
│          2 != 1 → INCLUDE                                     │
│  [1, 1, 2, 2, 2, 3]                                           │
│               ↑     ↑                                          │
│              slow  fast                                        │
│                                                                │
│  fast=5: nums[5]=3, nums[slow-2]=nums[2]=2                    │
│          3 != 2 → INCLUDE                                     │
│  [1, 1, 2, 2, 3, 3]                                           │
│                  ↑  ↑                                          │
│                slow fast                                       │
│                                                                │
│  Result: [1, 1, 2, 2, 3], length = 5                          │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def remove_duplicates_k(nums: list[int], k: int = 2) -> int:
    """
    Remove duplicates, allowing at most k of each element.
    Return new length.
    
    Time: O(n), Space: O(1)
    
    KEY INSIGHT: Compare nums[fast] with nums[slow - k]
    If they're different, we haven't seen k copies yet!
    """
    if len(nums) <= k:
        return len(nums)
    
    slow = k  # First k elements always valid
    
    for fast in range(k, len(nums)):
        # If current != element k positions back, include it
        if nums[fast] != nums[slow - k]:
            nums[slow] = nums[fast]
            slow += 1
    
    return slow

# Specific versions
def remove_duplicates_i(nums: list[int]) -> int:
    """Allow at most 1 (unique only)"""
    return remove_duplicates_k(nums, 1)

def remove_duplicates_ii(nums: list[int]) -> int:
    """Allow at most 2"""
    return remove_duplicates_k(nums, 2)
```

---

## 3.3.2 String Compression

### Problem
Compress string in-place: ["a","a","b","b","c","c","c"] → ["a","2","b","2","c","3"]

### Visualization

```
Input: ["a","a","b","b","b","c","c","c","c","c"]

┌────────────────────────────────────────────────────────────────┐
│                                                                │
│  Phase 1: Count consecutive 'a's                              │
│  ["a","a","b","b","b","c","c","c","c","c"]                    │
│    ↑     ↑                                                     │
│   read  (count = 2)                                           │
│   write                                                        │
│                                                                │
│  Write 'a' then '2':                                          │
│  ["a","2","b","b","b","c","c","c","c","c"]                    │
│         ↑  ↑                                                   │
│       write read                                               │
│                                                                │
│  Phase 2: Count consecutive 'b's (count = 3)                  │
│  Write 'b' then '3':                                          │
│  ["a","2","b","3","b","c","c","c","c","c"]                    │
│               ↑     ↑                                          │
│             write  read                                        │
│                                                                │
│  Phase 3: Count consecutive 'c's (count = 5)                  │
│  Write 'c' then '5':                                          │
│  ["a","2","b","3","c","5","c","c","c","c"]                    │
│                        ↑                 ↑                     │
│                      write             read                    │
│                                                                │
│  Result: ["a","2","b","3","c","5"], length = 6                │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def compress(chars: list[str]) -> int:
    """
    Compress string in-place.
    Return new length.
    
    Time: O(n), Space: O(1)
    """
    write = 0  # Write position
    read = 0   # Read position
    n = len(chars)
    
    while read < n:
        char = chars[read]
        count = 0
        
        # Count consecutive occurrences
        while read < n and chars[read] == char:
            read += 1
            count += 1
        
        # Write character
        chars[write] = char
        write += 1
        
        # Write count if > 1
        if count > 1:
            for digit in str(count):
                chars[write] = digit
                write += 1
    
    return write

# Alternative: Using two-pointer more explicitly
def compress_v2(chars: list[str]) -> int:
    slow = 0  # Write pointer
    fast = 0  # Read pointer
    n = len(chars)
    
    while fast < n:
        chars[slow] = chars[fast]
        count = 1
        
        # Count consecutive
        while fast + count < n and chars[fast + count] == chars[fast]:
            count += 1
        
        # Move fast pointer
        fast += count
        slow += 1
        
        # Write count digits
        if count > 1:
            for c in str(count):
                chars[slow] = c
                slow += 1
    
    return slow
```

---

## 3.3.3 Remove Element Variations

### Multiple Conditions

```python
def remove_elements_condition(nums: list[int], condition) -> int:
    """
    Remove elements that satisfy a condition.
    
    Examples:
    - Remove all even numbers
    - Remove all values > threshold
    - Remove all negative numbers
    """
    slow = 0
    
    for fast in range(len(nums)):
        if not condition(nums[fast]):  # Keep elements NOT matching condition
            nums[slow] = nums[fast]
            slow += 1
    
    return slow

# Usage examples:
# Remove evens: remove_elements_condition(nums, lambda x: x % 2 == 0)
# Remove negatives: remove_elements_condition(nums, lambda x: x < 0)
# Remove > 10: remove_elements_condition(nums, lambda x: x > 10)
```

### Remove All Instances (Optimal for Few Removals)

```python
def remove_element_swap(nums: list[int], val: int) -> int:
    """
    Optimal when val is rare - O(num_val) swaps instead of O(n).
    
    Strategy: Swap element to remove with last element.
    """
    i = 0
    n = len(nums)
    
    while i < n:
        if nums[i] == val:
            nums[i] = nums[n - 1]
            n -= 1
            # Don't increment i - need to check swapped element
        else:
            i += 1
    
    return n
```

---

## In-Place Modification: Summary

```
┌─────────────────────────────────────────────────────────────────┐
│  IN-PLACE MODIFICATION TOOLKIT                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  PATTERN: slow = writer, fast = reader                         │
│                                                                 │
│  REMOVE DUPLICATES (sorted):                                    │
│  • K=1: if nums[fast] != nums[slow]                            │
│  • K=n: if nums[fast] != nums[slow - k]                        │
│                                                                 │
│  REMOVE ELEMENT:                                                │
│  • Standard: Skip if equals val                                 │
│  • Swap variant: Swap with end when val found                  │
│                                                                 │
│  COMPRESSION:                                                   │
│  • Count consecutive, write char + count                       │
│  • Handle multi-digit counts                                    │
│                                                                 │
│  KEY PRINCIPLE:                                                 │
│  Everything before slow pointer is valid output!               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# 3.4 Pattern: Linked List

## Core Concept

Two pointers on linked lists use **speed difference** rather than indices.

```
┌─────────────────────────────────────────────────────────────────┐
│  LINKED LIST TWO POINTER MECHANICS                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Unlike arrays, we CAN'T use indices.                          │
│  Instead, we use SPEED DIFFERENCE:                              │
│                                                                 │
│  SLOW: slow = slow.next        (1 step)                        │
│  FAST: fast = fast.next.next   (2 steps)                       │
│                                                                 │
│  This creates a "relative motion" that's useful for:           │
│  • Detecting cycles (fast catches slow)                        │
│  • Finding middle (fast reaches end, slow at middle)           │
│  • Finding nth from end (fast gets head start)                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3.4.1 Floyd's Cycle Detection - Deep Dive

### Why It Works: Mathematical Proof

```
┌─────────────────────────────────────────────────────────────────┐
│  FLOYD'S ALGORITHM PROOF                                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  List Structure:                                                │
│                                                                 │
│  HEAD ──────→ CYCLE_START ──────→ MEETING_POINT                │
│    │              ↑                     │                       │
│    │              └─────────────────────┘                       │
│    │                                                            │
│    ←───── a ─────→←────── b ────→                              │
│                   ←───────── c ─────────→                       │
│                                                                 │
│  Where:                                                         │
│  • a = distance from HEAD to CYCLE_START                       │
│  • b = distance from CYCLE_START to MEETING_POINT              │
│  • c = cycle length                                             │
│                                                                 │
│  When they meet:                                                │
│  • Slow traveled: a + b                                        │
│  • Fast traveled: a + b + n*c (for some n ≥ 1)                │
│                                                                 │
│  Since fast moves 2x speed:                                     │
│  2(a + b) = a + b + n*c                                        │
│  a + b = n*c                                                    │
│  a = n*c - b = (n-1)*c + (c - b)                               │
│                                                                 │
│  INSIGHT: a ≡ (c - b) mod c                                    │
│                                                                 │
│  So: Starting from HEAD and MEETING_POINT simultaneously,      │
│       moving 1 step at a time, they meet at CYCLE_START!       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Visualization

```
Example List:  1 → 2 → 3 → 4 → 5
                       ↑       ↓
                       └───────┘

a = 2 (HEAD to node 3)
b = 2 (node 3 to meeting point, say node 5)
c = 3 (cycle length: 3 → 4 → 5 → 3)

┌────────────────────────────────────────────────────────────────┐
│  PHASE 1: DETECTION                                            │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  Step 0: S=1, F=1                                             │
│  Step 1: S=2, F=3                                             │
│  Step 2: S=3, F=5                                             │
│  Step 3: S=4, F=4 (fast went 5→3→4)                          │
│                                                                │
│  MEET at node 4!                                               │
│                                                                │
├────────────────────────────────────────────────────────────────┤
│  PHASE 2: FIND START                                           │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  Reset slow to HEAD, keep fast at meeting point               │
│  Both move 1 step at a time:                                  │
│                                                                │
│  Step 0: S=1, F=4                                             │
│  Step 1: S=2, F=5                                             │
│  Step 2: S=3, F=3                                             │
│                                                                │
│  MEET at node 3 = CYCLE START!                                │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Complete Implementation

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def detect_cycle(head: ListNode) -> ListNode:
    """
    Detect cycle and return cycle start node.
    Return None if no cycle.
    
    Time: O(n), Space: O(1)
    """
    if not head or not head.next:
        return None
    
    # PHASE 1: Detect if cycle exists
    slow = fast = head
    has_cycle = False
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            has_cycle = True
            break
    
    if not has_cycle:
        return None
    
    # PHASE 2: Find cycle start
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next
    
    return slow

def cycle_length(head: ListNode) -> int:
    """
    Find the length of cycle (0 if no cycle).
    """
    # First detect cycle
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            break
    else:
        return 0  # No cycle
    
    # Count cycle length
    length = 1
    current = slow.next
    while current != slow:
        length += 1
        current = current.next
    
    return length
```

---

## 3.4.2 Find Middle Element - Variations

### Two Middles Problem

```
┌─────────────────────────────────────────────────────────────────┐
│  MIDDLE ELEMENT VARIATIONS                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ODD LENGTH: 1 → 2 → 3 → 4 → 5                                 │
│                    ↑                                            │
│              Single middle (3)                                  │
│                                                                 │
│  EVEN LENGTH: 1 → 2 → 3 → 4 → 5 → 6                            │
│                    ↑   ↑                                        │
│             First(3)  Second(4)                                 │
│                                                                 │
│  Standard algorithm returns SECOND middle for even length      │
│  Some problems need FIRST middle (e.g., splitting list)        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def find_middle(head: ListNode) -> ListNode:
    """
    Find middle node.
    For even length, returns SECOND middle.
    
    Time: O(n), Space: O(1)
    """
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow

def find_middle_first(head: ListNode) -> ListNode:
    """
    Find middle node.
    For even length, returns FIRST middle.
    
    Useful for: Splitting list into two halves
    """
    slow = fast = head
    prev = None
    
    while fast and fast.next:
        prev = slow
        slow = slow.next
        fast = fast.next.next
    
    # For odd: slow is middle
    # For even: slow is second middle, prev is first middle
    # If we need first middle for even, return prev
    # But standard "first middle" returns slow for odd, prev for even
    
    # Actually, let's use a different approach:
    # Start fast one step ahead
    return slow  # This still returns second middle

def find_middle_for_split(head: ListNode) -> ListNode:
    """
    Returns node BEFORE the second half.
    Useful for splitting list into two equal halves.
    """
    slow = fast = head
    prev = None
    
    while fast and fast.next:
        prev = slow
        slow = slow.next
        fast = fast.next.next
    
    return prev  # Last node of first half
```

---

## 3.4.3 Nth Node From End

### Problem
Find the nth node from the end of list.

### Visualization

```
List: 1 → 2 → 3 → 4 → 5    n = 2

┌────────────────────────────────────────────────────────────────┐
│  STRATEGY: Give fast pointer a "head start" of n nodes        │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  Step 0: Advance fast by n=2                                  │
│  1 → 2 → 3 → 4 → 5                                            │
│  ↑       ↑                                                     │
│ slow    fast                                                   │
│                                                                │
│  Step 1: Move both together until fast reaches end            │
│  1 → 2 → 3 → 4 → 5                                            │
│      ↑       ↑                                                 │
│    slow    fast                                                │
│                                                                │
│  Step 2:                                                       │
│  1 → 2 → 3 → 4 → 5                                            │
│          ↑       ↑                                             │
│        slow    fast                                            │
│                                                                │
│  Step 3:                                                       │
│  1 → 2 → 3 → 4 → 5 → null                                     │
│              ↑       ↑                                         │
│            slow    fast                                        │
│                                                                │
│  fast is null → slow is at 2nd from end (node 4) ✓           │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def find_nth_from_end(head: ListNode, n: int) -> ListNode:
    """
    Find nth node from end (1-indexed).
    
    Time: O(length), Space: O(1)
    """
    fast = slow = head
    
    # Advance fast by n nodes
    for _ in range(n):
        if not fast:
            return None  # n > list length
        fast = fast.next
    
    # Move both until fast reaches end
    while fast:
        slow = slow.next
        fast = fast.next
    
    return slow

def remove_nth_from_end(head: ListNode, n: int) -> ListNode:
    """
    Remove nth node from end.
    Return new head.
    
    Time: O(length), Space: O(1)
    """
    # Use dummy node to handle edge case of removing head
    dummy = ListNode(0)
    dummy.next = head
    
    fast = slow = dummy
    
    # Advance fast by n+1 (so slow stops BEFORE node to remove)
    for _ in range(n + 1):
        fast = fast.next
    
    # Move both
    while fast:
        slow = slow.next
        fast = fast.next
    
    # Remove node
    slow.next = slow.next.next
    
    return dummy.next
```

---

## 3.4.4 Palindrome Linked List

### Problem
Check if linked list is palindrome.

### Strategy

```
┌─────────────────────────────────────────────────────────────────┐
│  PALINDROME CHECK STRATEGY                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Find middle of list                                        │
│  2. Reverse second half                                        │
│  3. Compare first half with reversed second half               │
│  4. (Optional) Restore list                                    │
│                                                                 │
│  Example: 1 → 2 → 3 → 2 → 1                                   │
│                                                                 │
│  Step 1: Find middle (3)                                       │
│  First half: 1 → 2 → 3                                        │
│  Second half: 2 → 1                                            │
│                                                                 │
│  Step 2: Reverse second half                                   │
│  Second half reversed: 1 → 2                                   │
│                                                                 │
│  Step 3: Compare                                                │
│  1 == 1 ✓, 2 == 2 ✓                                           │
│  Palindrome!                                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def is_palindrome(head: ListNode) -> bool:
    """
    Check if linked list is palindrome.
    
    Time: O(n), Space: O(1)
    """
    if not head or not head.next:
        return True
    
    # Step 1: Find middle
    slow = fast = head
    while fast.next and fast.next.next:
        slow = slow.next
        fast = fast.next.next
    
    # Step 2: Reverse second half
    second_half = reverse_list(slow.next)
    
    # Step 3: Compare halves
    first_half = head
    result = True
    
    while second_half:  # Second half is shorter or equal
        if first_half.val != second_half.val:
            result = False
            break
        first_half = first_half.next
        second_half = second_half.next
    
    # Step 4: Restore list (optional but good practice)
    slow.next = reverse_list(slow.next)
    
    return result

def reverse_list(head: ListNode) -> ListNode:
    """
    Reverse linked list in-place.
    """
    prev = None
    current = head
    
    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    
    return prev
```

---

## Linked List Patterns: Summary

```
┌─────────────────────────────────────────────────────────────────┐
│  LINKED LIST TWO POINTER TOOLKIT                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  CYCLE DETECTION (Floyd's):                                     │
│  • slow = slow.next, fast = fast.next.next                     │
│  • Meet → cycle exists                                          │
│  • To find start: reset slow to head, move both at same speed  │
│                                                                 │
│  FIND MIDDLE:                                                   │
│  • When fast reaches end, slow is at middle                    │
│  • Even length: returns second middle by default               │
│                                                                 │
│  NTH FROM END:                                                  │
│  • Give fast a head start of n nodes                           │
│  • When fast reaches end, slow is at target                    │
│                                                                 │
│  PALINDROME:                                                    │
│  • Find middle → Reverse second half → Compare                 │
│                                                                 │
│  INTERSECTION:                                                  │
│  • Calculate lengths, align pointers, find meeting point       │
│  • Or: Traverse both, swap heads at end, meet at intersection  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# 3.5 Pattern: Palindrome Checks

## Core Concept

Palindrome problems leverage the **symmetry** property—comparing from both ends toward the center.

---

## 3.5.1 Valid Palindrome - Basic

```python
def is_palindrome_string(s: str) -> bool:
    """
    Check if string is palindrome.
    Ignore non-alphanumeric, case-insensitive.
    
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(s) - 1
    
    while left < right:
        # Skip non-alphanumeric from left
        while left < right and not s[left].isalnum():
            left += 1
        
        # Skip non-alphanumeric from right
        while left < right and not s[right].isalnum():
            right -= 1
        
        # Compare
        if s[left].lower() != s[right].lower():
            return False
        
        left += 1
        right -= 1
    
    return True
```

---

## 3.5.2 Valid Palindrome II - Allow One Deletion

### Problem
Can the string become a palindrome by removing at most one character?

### Strategy

```
┌─────────────────────────────────────────────────────────────────┐
│  VALID PALINDROME II STRATEGY                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  When we find a mismatch at s[L] != s[R]:                      │
│                                                                 │
│  Option 1: Delete s[L], check if s[L+1:R+1] is palindrome      │
│  Option 2: Delete s[R], check if s[L:R] is palindrome          │
│                                                                 │
│  Example: "abca"                                                │
│            ↑  ↑                                                  │
│            L  R                                                  │
│            'a' == 'a' ✓                                         │
│                                                                 │
│            "abca"                                               │
│             ↑↑                                                   │
│             LR                                                   │
│            'b' != 'c' ✗                                         │
│                                                                 │
│  Try 1: Delete 'b' → check "ca" → 'c' != 'a' ✗                │
│  Try 2: Delete 'c' → check "ba" → 'b' != 'a' ✗                │
│                                                                 │
│  Wait! Let me reconsider...                                     │
│  After first check (a==a), L=1, R=2                            │
│  s[L:R+1] = "bc"                                                │
│  Try 1: Delete s[L]='b' → check s[L+1:R+1] = "c" → palindrome! │
│                                                                 │
│  Hmm, let me redo: "abca"                                      │
│  L=0, R=3: 'a'=='a' ✓, L=1, R=2                               │
│  L=1, R=2: 'b'!='c' ✗                                          │
│  Delete 'b': check "ca"[1:3] = "c" in original = s[2:3] ✓     │
│  OR                                                             │
│  Delete 'c': check "ab"[1:2] = "b" in original = s[1:2] ✓     │
│                                                                 │
│  Result: TRUE                                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def valid_palindrome_ii(s: str) -> bool:
    """
    Check if string can become palindrome by removing at most 1 char.
    
    Time: O(n), Space: O(1)
    """
    def is_palindrome_range(left: int, right: int) -> bool:
        """Check if s[left:right+1] is palindrome."""
        while left < right:
            if s[left] != s[right]:
                return False
            left += 1
            right -= 1
        return True
    
    left, right = 0, len(s) - 1
    
    while left < right:
        if s[left] != s[right]:
            # Try deleting either character
            return (is_palindrome_range(left + 1, right) or 
                    is_palindrome_range(left, right - 1))
        left += 1
        right -= 1
    
    return True
```

---

## 3.5.3 Valid Palindrome III - Allow K Deletions

### Problem
Can the string become a palindrome by removing at most k characters?

### Strategy

```
┌─────────────────────────────────────────────────────────────────┐
│  VALID PALINDROME III - DP APPROACH                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  This becomes a DP problem!                                     │
│                                                                 │
│  Observation: Minimum deletions to make palindrome =           │
│               length - Longest Palindromic Subsequence (LPS)   │
│                                                                 │
│  So: Check if (n - LPS) <= k                                   │
│                                                                 │
│  LPS can be found using two pointers conceptually,             │
│  but requires DP for implementation.                            │
│                                                                 │
│  Alternative: LPS(s) = LCS(s, reverse(s))                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def valid_palindrome_iii(s: str, k: int) -> bool:
    """
    Check if string can become palindrome by removing at most k chars.
    
    Time: O(n²), Space: O(n)
    """
    n = len(s)
    
    # Find Longest Palindromic Subsequence
    # LPS(s) = LCS(s, reverse(s))
    rev_s = s[::-1]
    
    # DP for LCS
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            if s[i - 1] == rev_s[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    
    lps_length = dp[n][n]
    min_deletions = n - lps_length
    
    return min_deletions <= k

# Space-optimized version
def valid_palindrome_iii_optimized(s: str, k: int) -> bool:
    """Space-optimized O(n) version."""
    n = len(s)
    rev_s = s[::-1]
    
    # Only need previous row
    prev = [0] * (n + 1)
    
    for i in range(1, n + 1):
        curr = [0] * (n + 1)
        for j in range(1, n + 1):
            if s[i - 1] == rev_s[j - 1]:
                curr[j] = prev[j - 1] + 1
            else:
                curr[j] = max(prev[j], curr[j - 1])
        prev = curr
    
    lps_length = prev[n]
    return n - lps_length <= k
```

---

## 3.5.4 Longest Palindromic Substring

### Strategy: Expand Around Center

```
┌─────────────────────────────────────────────────────────────────┐
│  EXPAND AROUND CENTER                                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Key Insight: Every palindrome has a CENTER                    │
│                                                                 │
│  Odd length:  "aba"  → center is 'b'                           │
│  Even length: "abba" → center is between 'b' and 'b'           │
│                                                                 │
│  For each possible center, expand outward:                      │
│                                                                 │
│  s = "babad"                                                    │
│                                                                 │
│  Center at index 0 ('b'): "b" → length 1                       │
│  Center at index 1 ('a'): "a" → "bab" → length 3               │
│  Center at index 2 ('b'): "b" → "aba" → length 3               │
│  ...                                                            │
│                                                                 │
│  Also check even-length centers (between characters)            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def longest_palindrome(s: str) -> str:
    """
    Find longest palindromic substring.
    
    Time: O(n²), Space: O(1)
    """
    if not s:
        return ""
    
    start, max_len = 0, 1
    
    def expand_around_center(left: int, right: int) -> int:
        """Expand and return length of palindrome."""
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return right - left - 1  # Length of palindrome
    
    for i in range(len(s)):
        # Odd length palindrome (center at i)
        len1 = expand_around_center(i, i)
        
        # Even length palindrome (center between i and i+1)
        len2 = expand_around_center(i, i + 1)
        
        # Update if longer found
        curr_max = max(len1, len2)
        if curr_max > max_len:
            max_len = curr_max
            # Calculate start index
            start = i - (curr_max - 1) // 2
    
    return s[start:start + max_len]
```

---

## Palindrome Patterns: Summary

```
┌─────────────────────────────────────────────────────────────────┐
│  PALINDROME PROBLEM TOOLKIT                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  BASIC CHECK:                                                   │
│  • Two pointers from ends, compare inward                      │
│  • Time: O(n), Space: O(1)                                     │
│                                                                 │
│  ALLOW 1 DELETION:                                              │
│  • On mismatch: try deleting either character                  │
│  • Time: O(n), Space: O(1)                                     │
│                                                                 │
│  ALLOW K DELETIONS:                                             │
│  • Find LPS (Longest Palindromic Subsequence)                  │
│  • Check if n - LPS <= k                                       │
│  • Time: O(n²), Space: O(n)                                    │
│                                                                 │
│  LONGEST PALINDROMIC SUBSTRING:                                 │
│  • Expand around each center                                    │
│  • Check both odd and even lengths                              │
│  • Time: O(n²), Space: O(1)                                    │
│  • (Manacher's algorithm: O(n), but complex)                   │
│                                                                 │
│  PALINDROMIC SUBSTRINGS COUNT:                                  │
│  • Similar to longest, but count instead of track max          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# Chapter 3: Master Summary

```
┌─────────────────────────────────────────────────────────────────┐
│              PATTERN DEEP DIVE - KEY TAKEAWAYS                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  PAIR SUM VARIANTS:                                             │
│  • Build K-sum from 2-sum recursively                          │
│  • Always sort first, handle duplicates at every level         │
│  • Use early termination optimizations                          │
│                                                                 │
│  PARTITIONING:                                                  │
│  • Dutch Flag: 3 pointers for 3 regions                        │
│  • Don't increment mid when swapping with high!                │
│  • Quick Select for kth element in O(n) average                │
│                                                                 │
│  IN-PLACE MODIFICATION:                                         │
│  • Slow = writer, Fast = reader                                │
│  • Remove duplicates (K): compare with element K back          │
│                                                                 │
│  LINKED LIST:                                                   │
│  • Speed difference instead of indices                         │
│  • Floyd's for cycles: mathematical proof is elegant           │
│  • Middle/Nth from end: fast gets head start                   │
│                                                                 │
│  PALINDROMES:                                                   │
│  • Basic: two pointers from ends                               │
│  • 1 deletion: try both options on mismatch                    │
│  • K deletions: becomes DP (LPS)                               │
│  • Longest substring: expand around centers                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

**Next Chapter:** Chapter 4 will cover Advanced Techniques including Container Problems, Complex Subarray/Substring problems, and combining Two Pointers with Binary Search.
