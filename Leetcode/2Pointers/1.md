# Chapter 1: Foundation of Two Pointer Technique

## Complete In-Depth Guide

---

# 1.1 What is Two Pointer Technique?

## Definition

The **Two Pointer Technique** is an algorithmic pattern where two pointers (indices or references) traverse a data structureâ€”typically an array, string, or linked listâ€”simultaneously or at different speeds to solve a problem efficiently.

Instead of using nested loops that compare every pair of elements (O(nÂ²)), two pointers allow us to make intelligent decisions about which elements to compare, reducing complexity to O(n).

---

## The Core Intuition

### Think of it like this:

Imagine you're searching for two people in a **sorted line** whose heights add up to exactly 180cm.

**Brute Force Approach (Inefficient):**
```
Person 1 stays still, Person 2 checks everyone else
Then Person 1 moves, Person 2 checks everyone again
... and so on
```
This takes O(nÂ²) comparisons.

**Two Pointer Approach (Efficient):**
```
Start with the SHORTEST and TALLEST person
- If sum < 180: Move away from shortest (need taller)
- If sum > 180: Move away from tallest (need shorter)
- If sum = 180: Found it!
```
This takes at most O(n) comparisons.

---

## Visual Representation

### How Two Pointers Work

```
Initial State:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Array: [1]  [3]  [5]  [7]  [9]  [11]  [13]    â”‚
â”‚          â†‘                              â†‘       â”‚
â”‚         LEFT                          RIGHT     â”‚
â”‚        (start)                        (end)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

After some iterations (searching for sum = 14):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Array: [1]  [3]  [5]  [7]  [9]  [11]  [13]    â”‚
â”‚                    â†‘         â†‘                  â”‚
â”‚                  LEFT      RIGHT                â”‚
â”‚                                                 â”‚
â”‚  1 + 13 = 14? No (14 âœ“) â†’ Found at indices 0,6 â”‚
â”‚  Actually: 5 + 9 = 14 âœ“                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Why Does It Work?

The technique works because of **Monotonic Behavior**:

```
SORTED ARRAY: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
               â†‘                          â†‘
              L=1                       R=10
              
Current Sum = 1 + 10 = 11

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  If we need a LARGER sum:                              â”‚
â”‚  â€¢ Moving L right increases the sum (1â†’2, 2â†’3, etc.)  â”‚
â”‚  â€¢ Moving R left decreases the sum (10â†’9, 9â†’8, etc.) â”‚
â”‚                                                        â”‚
â”‚  If we need a SMALLER sum:                             â”‚
â”‚  â€¢ Moving L right increases the sum âŒ                 â”‚
â”‚  â€¢ Moving R left decreases the sum âœ“                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

This **predictable behavior** is why two pointers are so powerful on sorted data!

---

## Basic Code Example: Two Sum on Sorted Array

```python
def two_sum_sorted(numbers: list[int], target: int) -> list[int]:
    """
    Find two numbers in a SORTED array that add up to target.
    Returns 1-indexed positions.
    
    Time Complexity: O(n) - each pointer moves at most n times
    Space Complexity: O(1) - only two variables used
    """
    left = 0                      # Start pointer
    right = len(numbers) - 1      # End pointer
    
    while left < right:           # Continue until pointers meet
        current_sum = numbers[left] + numbers[right]
        
        if current_sum == target:
            return [left + 1, right + 1]  # Found! (1-indexed)
        
        elif current_sum < target:
            # Need bigger sum â†’ move left pointer right
            # (access larger values)
            left += 1
            
        else:  # current_sum > target
            # Need smaller sum â†’ move right pointer left
            # (access smaller values)
            right -= 1
    
    return []  # No solution found

# Example Usage:
# numbers = [2, 7, 11, 15], target = 9
# Step 1: left=0, right=3 â†’ 2+15=17 > 9 â†’ right--
# Step 2: left=0, right=2 â†’ 2+11=13 > 9 â†’ right--
# Step 3: left=0, right=1 â†’ 2+7=9 == 9 â†’ Return [1, 2]
```

---

## Comparison: Brute Force vs Two Pointers

### Brute Force Solution

```python
def two_sum_brute(numbers: list[int], target: int) -> list[int]:
    """
    Check every possible pair - O(nÂ²) time
    """
    n = len(numbers)
    for i in range(n):                    # First pointer
        for j in range(i + 1, n):         # Second pointer
            if numbers[i] + numbers[j] == target:
                return [i + 1, j + 1]
    return []
```

### Performance Comparison

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Array Size     â”‚   Brute Force   â”‚   Two Pointer   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   n = 100        â”‚   ~5,000 ops    â”‚   ~100 ops      â”‚
â”‚   n = 1,000      â”‚   ~500,000 ops  â”‚   ~1,000 ops    â”‚
â”‚   n = 10,000     â”‚   ~50M ops      â”‚   ~10,000 ops   â”‚
â”‚   n = 1,000,000  â”‚   ~500B ops     â”‚   ~1M ops       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

For n = 1,000,000:
â€¢ Brute Force: ~500,000,000,000 operations (minutes/hours)
â€¢ Two Pointer: ~1,000,000 operations (milliseconds)
```

---

## The Two Pointer "Contract"

For two pointers to work correctly, you need:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  THE THREE GUARANTEES                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  1. PROGRESS GUARANTEE                                  â”‚
â”‚     â†’ At least one pointer moves in every iteration     â”‚
â”‚     â†’ Prevents infinite loops                           â”‚
â”‚                                                         â”‚
â”‚  2. TERMINATION GUARANTEE                               â”‚
â”‚     â†’ Pointers eventually meet or cross                 â”‚
â”‚     â†’ Loop condition ensures finite iterations          â”‚
â”‚                                                         â”‚
â”‚  3. CORRECTNESS GUARANTEE                               â”‚
â”‚     â†’ Moving a pointer eliminates only invalid options  â”‚
â”‚     â†’ We never skip past the correct answer             â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# 1.2 When to Use Two Pointers

## The Decision Framework

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   Is input linear   â”‚
                    â”‚ (array/string/list)?â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               NO   â”‚                     â”‚  YES
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   Is data sorted    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚         â”‚   or can be sorted? â”‚         â”‚
          â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
          â”‚                                         â”‚
          â–¼                                         â–¼
    Consider other                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    approaches                            â”‚ Two Pointers    â”‚
    (BFS, DFS, DP)                       â”‚ likely works!   â”‚
                                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Scenario 1: Array/String is SORTED or Has ORDER

This is the **most common** scenario for two pointers.

### Why Sorting Matters

```python
# UNSORTED: We can't predict behavior
[5, 2, 8, 1, 9]  â†’  Moving pointer gives UNPREDICTABLE results
 â†‘           â†‘
5+9=14, then 5+1=6? We jumped around randomly!

# SORTED: Behavior is PREDICTABLE
[1, 2, 5, 8, 9]  â†’  Moving pointer gives PREDICTABLE results
 â†‘           â†‘
1+9=10, moving left up: 2+9=11 (increased by 1)
        moving right down: 1+8=9 (decreased by 1)
```

### Examples of Sorted/Ordered Problems

```python
# Example 1: Two Sum in Sorted Array
def two_sum(nums, target):
    """Array is PRE-SORTED"""
    l, r = 0, len(nums) - 1
    while l < r:
        s = nums[l] + nums[r]
        if s == target: return [l, r]
        elif s < target: l += 1
        else: r -= 1
    return []

# Example 2: Valid Palindrome (inherent order)
def is_palindrome(s):
    """String has NATURAL order (compare start vs end)"""
    l, r = 0, len(s) - 1
    while l < r:
        if s[l] != s[r]:
            return False
        l += 1
        r -= 1
    return True
```

---

## Scenario 2: Finding Pairs, Triplets, or Subarrays

When you need to find **combinations** with specific properties:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PAIR PROBLEMS (2 elements)                            â”‚
â”‚  â€¢ Two Sum                                             â”‚
â”‚  â€¢ Two numbers with given difference                   â”‚
â”‚  â€¢ Pair with maximum/minimum property                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  TRIPLET PROBLEMS (3 elements)                         â”‚
â”‚  â€¢ Three Sum = 0                                       â”‚
â”‚  â€¢ Three Sum Closest                                   â”‚
â”‚  â€¢ Triangle validity                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  SUBARRAY PROBLEMS (contiguous sequence)               â”‚
â”‚  â€¢ Subarray with given sum                             â”‚
â”‚  â€¢ Longest subarray with condition                     â”‚
â”‚  â€¢ Minimum window containing X                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Code: Three Sum (Finding Triplets)

```python
def three_sum(nums: list[int]) -> list[list[int]]:
    """
    Find all unique triplets that sum to zero.
    
    Strategy:
    1. Sort the array
    2. Fix one element (outer loop)
    3. Use two pointers for remaining two elements
    
    Time: O(nÂ²), Space: O(1) excluding output
    """
    nums.sort()  # CRITICAL: Must sort first!
    result = []
    n = len(nums)
    
    for i in range(n - 2):  # Fix first element
        # Skip duplicates for first element
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        
        # Two pointer search for remaining two elements
        left, right = i + 1, n - 1
        target = -nums[i]  # We need: nums[left] + nums[right] = -nums[i]
        
        while left < right:
            current = nums[left] + nums[right]
            
            if current == target:
                result.append([nums[i], nums[left], nums[right]])
                
                # Skip duplicates for second element
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                # Skip duplicates for third element
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                    
                left += 1
                right -= 1
                
            elif current < target:
                left += 1
            else:
                right -= 1
    
    return result

# Visualization for nums = [-4, -1, -1, 0, 1, 2]
# 
# i=0: nums[i]=-4, target=4
#      [-1, -1, 0, 1, 2]
#        â†‘           â†‘
#      -1+2=1 < 4, move left
#      ... no valid triplet
#
# i=1: nums[i]=-1, target=1  
#      [-1, 0, 1, 2]
#        â†‘        â†‘
#      -1+2=1 == 1 âœ“ â†’ [-1, -1, 2]
```

---

## Scenario 3: In-Place Operations with O(1) Space

When you need to modify an array **without using extra space**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  COMMON IN-PLACE OPERATIONS                            â”‚
â”‚                                                        â”‚
â”‚  â€¢ Remove duplicates from sorted array                 â”‚
â”‚  â€¢ Remove specific element                             â”‚
â”‚  â€¢ Move zeros to end                                   â”‚
â”‚  â€¢ Partition array (Dutch National Flag)               â”‚
â”‚  â€¢ Reverse array/string                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Code: Remove Duplicates In-Place

```python
def remove_duplicates(nums: list[int]) -> int:
    """
    Remove duplicates from SORTED array in-place.
    Return the new length.
    
    Two Pointer Strategy:
    - SLOW pointer: marks position for next unique element
    - FAST pointer: scans through array finding unique elements
    
    Time: O(n), Space: O(1)
    """
    if not nums:
        return 0
    
    slow = 0  # Position for next unique element
    
    for fast in range(1, len(nums)):
        # Found a new unique element?
        if nums[fast] != nums[slow]:
            slow += 1                  # Move slow forward
            nums[slow] = nums[fast]    # Place unique element
    
    return slow + 1  # Length = last index + 1

# Step-by-step visualization:
# Input: [1, 1, 2, 2, 2, 3]
#
# Initial:  [1, 1, 2, 2, 2, 3]
#            s  f
#            nums[f]=1 == nums[s]=1, skip
#
# Step 1:   [1, 1, 2, 2, 2, 3]
#            s     f
#            nums[f]=2 != nums[s]=1
#            slow++, nums[slow]=nums[fast]
#           [1, 2, 2, 2, 2, 3]
#               s  f
#
# Step 2:   [1, 2, 2, 2, 2, 3]
#               s     f
#            nums[f]=2 == nums[s]=2, skip
#
# Step 3:   [1, 2, 2, 2, 2, 3]
#               s        f
#            nums[f]=2 == nums[s]=2, skip
#
# Step 4:   [1, 2, 2, 2, 2, 3]
#               s           f
#            nums[f]=3 != nums[s]=2
#            slow++, nums[slow]=nums[fast]
#           [1, 2, 3, 2, 2, 3]
#                  s        f
#
# Result: First 3 elements [1, 2, 3], return 3
```

---

## Scenario 4: Comparing Elements from Different Positions

When you need to **compare or process elements** from different parts of the data structure:

```python
# Example: Merge Two Sorted Arrays
def merge(nums1: list[int], m: int, nums2: list[int], n: int) -> None:
    """
    Merge nums2 into nums1 in-place.
    nums1 has enough space at the end.
    
    KEY INSIGHT: Start from the END to avoid overwriting!
    
    Time: O(m+n), Space: O(1)
    """
    p1 = m - 1      # Pointer for nums1's elements
    p2 = n - 1      # Pointer for nums2's elements
    p = m + n - 1   # Pointer for placement position
    
    # Fill from back to front
    while p1 >= 0 and p2 >= 0:
        if nums1[p1] > nums2[p2]:
            nums1[p] = nums1[p1]
            p1 -= 1
        else:
            nums1[p] = nums2[p2]
            p2 -= 1
        p -= 1
    
    # Copy remaining elements from nums2 (if any)
    while p2 >= 0:
        nums1[p] = nums2[p2]
        p2 -= 1
        p -= 1

# Visualization:
# nums1 = [1, 3, 5, 0, 0, 0], m = 3
# nums2 = [2, 4, 6], n = 3
#
# Initial:
# [1, 3, 5, 0, 0, 0]    [2, 4, 6]
#        p1       p            p2
#
# Step 1: 5 < 6 â†’ place 6
# [1, 3, 5, 0, 0, 6]    [2, 4, 6]
#        p1    p          p2
#
# Step 2: 5 > 4 â†’ place 5
# [1, 3, 5, 0, 5, 6]    [2, 4, 6]
#     p1    p             p2
#
# ... continue until merged
# Result: [1, 2, 3, 4, 5, 6]
```

---

## Scenario 5: Palindrome-Related Problems

Palindromes have **inherent symmetry** that two pointers exploit perfectly:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              PALINDROME SYMMETRY                        â”‚
â”‚                                                         â”‚
â”‚     String: "r a c e c a r"                            â”‚
â”‚              â†‘           â†‘                              â”‚
â”‚              L           R                              â”‚
â”‚              Match? âœ“                                   â”‚
â”‚                                                         â”‚
â”‚     String: "r a c e c a r"                            â”‚
â”‚                â†‘       â†‘                                â”‚
â”‚                L       R                                â”‚
â”‚                Match? âœ“                                 â”‚
â”‚                                                         â”‚
â”‚     Continue until L >= R (all matched = palindrome)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Code: Valid Palindrome with Character Filtering

```python
def is_palindrome(s: str) -> bool:
    """
    Check if string is palindrome, considering only
    alphanumeric characters and ignoring case.
    
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(s) - 1
    
    while left < right:
        # Skip non-alphanumeric from left
        while left < right and not s[left].isalnum():
            left += 1
        
        # Skip non-alphanumeric from right
        while left < right and not s[right].isalnum():
            right -= 1
        
        # Compare characters (case-insensitive)
        if s[left].lower() != s[right].lower():
            return False
        
        left += 1
        right -= 1
    
    return True

# Example: "A man, a plan, a canal: Panama"
#
# Step 1: "A man, a plan, a canal: Panama"
#          â†‘                          â†‘
#          L='A'                    R='a'
#          'a' == 'a' âœ“
#
# Step 2: "A man, a plan, a canal: Panama"
#            â†‘                    â†‘
#          L='m'                R='m'
#          'm' == 'm' âœ“
#
# ... continues until all match
# Result: True (it's a palindrome!)
```

---

## Quick Reference: When to Use Two Pointers

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           TWO POINTER USAGE CHECKLIST                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  âœ“ USE Two Pointers when:                              â”‚
â”‚    â–¡ Data is sorted or can be sorted                   â”‚
â”‚    â–¡ Finding pairs/triplets with a target sum          â”‚
â”‚    â–¡ Comparing elements from both ends (palindrome)    â”‚
â”‚    â–¡ In-place array modification needed                â”‚
â”‚    â–¡ Merging sorted arrays/lists                       â”‚
â”‚    â–¡ Finding meeting point (linked list cycles)        â”‚
â”‚    â–¡ Sliding window problems                           â”‚
â”‚                                                         â”‚
â”‚  âœ— DON'T USE Two Pointers when:                        â”‚
â”‚    â–¡ Data is unsorted AND sorting isn't allowed        â”‚
â”‚    â–¡ Need to find ALL pairs (not just one)            â”‚
â”‚    â–¡ Non-linear data structures (trees, graphs)        â”‚
â”‚    â–¡ Order of elements doesn't matter for solution     â”‚
â”‚    â–¡ Random access is required repeatedly              â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# 1.3 Core Prerequisites

Before mastering two pointers, ensure solid understanding of these fundamentals:

---

## Prerequisite 1: Array Traversal and Manipulation

### Basic Operations You Must Know

```python
# 1. Accessing elements by index
arr = [10, 20, 30, 40, 50]
first = arr[0]        # 10
last = arr[-1]        # 50
middle = arr[len(arr)//2]  # 30

# 2. Modifying elements
arr[2] = 35           # [10, 20, 35, 40, 50]

# 3. Swapping elements (CRITICAL for two pointers!)
arr[0], arr[4] = arr[4], arr[0]  # [50, 20, 35, 40, 10]

# 4. Iterating with index
for i in range(len(arr)):
    print(i, arr[i])

# 5. Iterating with enumerate
for i, val in enumerate(arr):
    print(i, val)
```

### Understanding Array Indices

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Array:  [10, 20, 30, 40, 50]                         â”‚
â”‚  Index:   0   1   2   3   4                           â”‚
â”‚  Neg:    -5  -4  -3  -2  -1                           â”‚
â”‚                                                       â”‚
â”‚  Key Properties:                                      â”‚
â”‚  â€¢ First element: index 0                             â”‚
â”‚  â€¢ Last element: index n-1 or -1                      â”‚
â”‚  â€¢ Length: n (here, n=5)                              â”‚
â”‚  â€¢ Valid indices: 0 to n-1                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Prerequisite 2: Basic Sorting Algorithms

### Why Sorting Matters for Two Pointers

```python
# WITHOUT sorting: Two pointers don't work predictably
unsorted = [5, 2, 8, 1, 9]
# We can't know which direction to move pointers!

# WITH sorting: Predictable behavior enables two pointers
sorted_arr = sorted(unsorted)  # [1, 2, 5, 8, 9]
# Now moving leftâ†’ increases value, moving â†right decreases value
```

### Key Sorting Knowledge

```python
# 1. Built-in sort (modifies in place)
arr = [3, 1, 4, 1, 5]
arr.sort()            # arr is now [1, 1, 3, 4, 5]

# 2. Sorted function (returns new list)
arr = [3, 1, 4, 1, 5]
new_arr = sorted(arr)  # new_arr = [1, 1, 3, 4, 5], arr unchanged

# 3. Sorting with key
words = ["banana", "apple", "cherry"]
words.sort(key=len)    # ["apple", "banana", "cherry"]

# 4. Reverse sorting
arr.sort(reverse=True)  # [5, 4, 3, 1, 1]

# 5. Time Complexity: O(n log n) for Python's Timsort
```

### When Can You Sort?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SORTING DECISION                                      â”‚
â”‚                                                        â”‚
â”‚  Can I sort the input?                                 â”‚
â”‚                                                        â”‚
â”‚  YES if:                                               â”‚
â”‚  â€¢ Problem asks for existence (find ANY pair)          â”‚
â”‚  â€¢ Original order doesn't matter for answer            â”‚
â”‚  â€¢ Problem explicitly says input is sorted             â”‚
â”‚                                                        â”‚
â”‚  NO if:                                                â”‚
â”‚  â€¢ Need to return original indices                     â”‚
â”‚  â€¢ Order has meaning (time series, sequences)          â”‚
â”‚  â€¢ Problem requires preserving relative order          â”‚
â”‚                                                        â”‚
â”‚  WORKAROUND: Store (value, original_index) pairs       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Prerequisite 3: Hash Maps (For Comparison)

Understanding hash maps helps you know **when NOT to use two pointers**:

```python
# Two Sum: Hash Map vs Two Pointer

# HASH MAP APPROACH - O(n) time, O(n) space
# Works on UNSORTED arrays, returns ORIGINAL indices
def two_sum_hash(nums, target):
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []

# TWO POINTER APPROACH - O(n) time after O(n log n) sort, O(1) space
# Requires SORTED array, returns VALUES not original indices
def two_sum_pointer(nums, target):
    nums.sort()  # Destroys original indices!
    l, r = 0, len(nums) - 1
    while l < r:
        s = nums[l] + nums[r]
        if s == target:
            return [nums[l], nums[r]]  # Values, not indices
        elif s < target:
            l += 1
        else:
            r -= 1
    return []
```

### Comparison Table

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Aspect         â”‚   Two Pointer    â”‚   Hash Map       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Requires Sorting â”‚   Yes            â”‚   No             â”‚
â”‚ Time Complexity  â”‚   O(n)*          â”‚   O(n)           â”‚
â”‚ Space Complexity â”‚   O(1)           â”‚   O(n)           â”‚
â”‚ Original Indices â”‚   Lost if sorted â”‚   Preserved      â”‚
â”‚ Best For         â”‚   Space-critical â”‚   Index-critical â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
* O(n) after sorting; O(n log n) if sorting needed
```

---

## Prerequisite 4: Sliding Window Basics

Sliding window is a **specialized form** of two pointers:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           SLIDING WINDOW CONCEPT                        â”‚
â”‚                                                         â”‚
â”‚  Array: [1, 3, 2, 6, -1, 4, 1, 8, 2]                   â”‚
â”‚                                                         â”‚
â”‚  Fixed Window (size 3):                                 â”‚
â”‚  [1, 3, 2] 6, -1, 4, 1, 8, 2    sum = 6                â”‚
â”‚   â†‘     â†‘                                               â”‚
â”‚   L     R                                               â”‚
â”‚                                                         â”‚
â”‚  1, [3, 2, 6] -1, 4, 1, 8, 2    sum = 11               â”‚
â”‚      â†‘     â†‘                                            â”‚
â”‚      L     R                                            â”‚
â”‚                                                         â”‚
â”‚  Dynamic Window (variable size):                        â”‚
â”‚  Window expands (R++) or shrinks (L++) based on        â”‚
â”‚  conditions like sum â‰¥ target, distinct chars â‰¤ k      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Sliding Window Template

```python
def sliding_window_template(arr, condition):
    """
    Generic sliding window pattern.
    """
    left = 0
    window_state = initialize()  # Sum, count, set, etc.
    result = initial_result()
    
    for right in range(len(arr)):
        # EXPAND: Add right element to window
        update_window(window_state, arr[right])
        
        # SHRINK: While window violates condition
        while window_violates_condition(window_state):
            # Remove left element from window
            remove_from_window(window_state, arr[left])
            left += 1
        
        # UPDATE: Record result if window is valid
        result = update_result(result, window_state)
    
    return result

# Concrete Example: Minimum subarray with sum â‰¥ target
def min_subarray_len(target, nums):
    left = 0
    window_sum = 0
    min_length = float('inf')
    
    for right in range(len(nums)):
        window_sum += nums[right]  # Expand
        
        while window_sum >= target:  # Shrink while valid
            min_length = min(min_length, right - left + 1)
            window_sum -= nums[left]
            left += 1
    
    return min_length if min_length != float('inf') else 0
```

---

## Summary: Foundation Checklist

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         CHAPTER 1 MASTERY CHECKLIST                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  â–¡ Understand WHY two pointers reduce O(nÂ²) to O(n)    â”‚
â”‚                                                         â”‚
â”‚  â–¡ Know the THREE types of two pointer patterns:        â”‚
â”‚    â€¢ Opposite direction (converging)                    â”‚
â”‚    â€¢ Same direction (fast/slow)                         â”‚
â”‚    â€¢ Sliding window (expand/shrink)                     â”‚
â”‚                                                         â”‚
â”‚  â–¡ Recognize WHEN to use two pointers:                  â”‚
â”‚    â€¢ Sorted data                                        â”‚
â”‚    â€¢ Pair/triplet finding                               â”‚
â”‚    â€¢ In-place modifications                             â”‚
â”‚    â€¢ Palindrome checks                                  â”‚
â”‚                                                         â”‚
â”‚  â–¡ Master PREREQUISITES:                                â”‚
â”‚    â€¢ Array indexing and swapping                        â”‚
â”‚    â€¢ Sorting (when allowed, complexity)                 â”‚
â”‚    â€¢ Hash map alternative (trade-offs)                  â”‚
â”‚    â€¢ Sliding window basics                              â”‚
â”‚                                                         â”‚
â”‚  â–¡ Understand the MONOTONIC PROPERTY that makes        â”‚
â”‚    two pointers work on sorted data                     â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Key Insight to Remember

> **ğŸ’¡ The Magic of Two Pointers:**
> 
> On sorted data, moving a pointer in one direction has a **predictable effect** on the result. This predictability lets us make **informed decisions** about which pointer to move, eliminating the need to check all pairs.
> 
> This is why two pointers transform O(nÂ²) brute force into O(n) elegance.

---

**Next Chapter:** Chapter 2 will cover the Four Main Categories of Two Pointer patterns in detail, with specific templates and problem-solving strategies for each.
