# Chapter 4: Advanced Techniques

## Mastering Complex Two Pointer Problems

---

# Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                    CHAPTER 4 ROADMAP                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  4.1 CONTAINER PROBLEMS                                        │
│      └── Container With Most Water, Trapping Rain Water        │
│                                                                 │
│  4.2 SUBARRAY PROBLEMS                                         │
│      └── Sum constraints, Count subarrays, Product problems    │
│                                                                 │
│  4.3 SUBSTRING PROBLEMS                                        │
│      └── Minimum Window, Anagrams, Permutations                │
│                                                                 │
│  4.4 BINARY SEARCH + TWO POINTERS                              │
│      └── K Closest Elements, Kth Smallest in Matrix            │
│                                                                 │
│  4.5 ADVANCED MULTI-POINTER TECHNIQUES                         │
│      └── 3+ pointers, Complex state management                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# 4.1 Container Problems

## Core Concept

Container problems involve finding optimal boundaries that maximize or calculate some quantity (usually area or volume).

```
┌─────────────────────────────────────────────────────────────────┐
│                   CONTAINER PROBLEM TYPES                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  TYPE 1: MAXIMIZE CONTAINER (Container With Most Water)        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Find two lines that form container with maximum water  │   │
│  │  Water = min(height[L], height[R]) × (R - L)            │   │
│  │  Strategy: Start wide, shrink by moving shorter line    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  TYPE 2: CALCULATE TRAPPED (Trapping Rain Water)               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Calculate total water trapped between bars             │   │
│  │  Water at i = min(left_max, right_max) - height[i]      │   │
│  │  Strategy: Process from side with smaller boundary      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4.1.1 Container With Most Water

### Problem Statement
Given n non-negative integers representing heights of vertical lines, find two lines that together with x-axis forms a container that holds the most water.

### Visual Representation

```
Height: [1, 8, 6, 2, 5, 4, 8, 3, 7]

        8               8
        █               █       7
        █   6           █       █
        █   █   5       █       █
        █   █   █   4   █       █
        █   █   █   █   █   3   █
        █   █   2   █   █   █   █
    1   █   █   █   █   █   █   █
    █   █   █   █   █   █   █   █
────────────────────────────────────
    0   1   2   3   4   5   6   7   8
        ↑                       ↑
        L                       R
        
Container: height = min(8, 7) = 7
           width = 8 - 1 = 7
           area = 7 × 7 = 49
```

### The Greedy Insight

```
┌─────────────────────────────────────────────────────────────────┐
│  WHY MOVE THE SHORTER LINE?                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Current state: L at height h₁, R at height h₂, h₁ < h₂       │
│  Current area = h₁ × (R - L)                                   │
│                                                                 │
│  OPTION A: Move L (shorter line) to the right                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  • Width decreases by 1                                 │   │
│  │  • New height could be anything                          │   │
│  │  • If new height > h₁: area MIGHT increase              │   │
│  │  • If new height ≤ h₁: area decreases                   │   │
│  │  • POSSIBILITY of improvement exists!                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  OPTION B: Move R (taller line) to the left                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  • Width decreases by 1                                 │   │
│  │  • Height is STILL limited by h₁ (the shorter one)      │   │
│  │  • New height = min(h₁, new_h₂) ≤ h₁                    │   │
│  │  • Area = (smaller or same height) × (smaller width)    │   │
│  │  • Area can ONLY decrease or stay same!                 │   │
│  │  • NO possibility of improvement!                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  CONCLUSION: Always move the shorter line!                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Formal Proof of Correctness

```
┌─────────────────────────────────────────────────────────────────┐
│  PROOF: We never skip the optimal solution                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Assume optimal solution uses indices i* and j* (i* < j*)      │
│                                                                 │
│  Our algorithm starts with L=0, R=n-1                          │
│                                                                 │
│  CLAIM: Before we move past i* or j*, we will have             │
│         evaluated the pair (i*, j*)                             │
│                                                                 │
│  PROOF BY INVARIANT:                                            │
│  At any point, L ≤ i* and R ≥ j*                               │
│                                                                 │
│  When we move a pointer:                                        │
│  • If L < i*: moving L doesn't skip i*                         │
│  • If R > j*: moving R doesn't skip j*                         │
│  • If L = i* and R = j*: we evaluate this pair!                │
│  • If L = i* and R > j*: we must have height[L] ≥ height[R]   │
│    (otherwise we'd move L past i*)                              │
│    But this means height[i*] ≥ height[R] > height[j*]          │
│    So moving R toward j* is correct                             │
│                                                                 │
│  Therefore, we always evaluate the optimal pair. ∎              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Step-by-Step Execution

```
Height: [1, 8, 6, 2, 5, 4, 8, 3, 7]
Index:   0  1  2  3  4  5  6  7  8

┌────────────────────────────────────────────────────────────────┐
│  Step  │  L  │  R  │ h[L] │ h[R] │ Width │ Area │  Max  │ Move │
├────────┼─────┼─────┼──────┼──────┼───────┼──────┼───────┼──────┤
│   1    │  0  │  8  │  1   │  7   │   8   │  8   │   8   │  L++ │
│   2    │  1  │  8  │  8   │  7   │   7   │  49  │  49   │  R-- │
│   3    │  1  │  7  │  8   │  3   │   6   │  18  │  49   │  R-- │
│   4    │  1  │  6  │  8   │  8   │   5   │  40  │  49   │  R-- │
│   5    │  1  │  5  │  8   │  4   │   4   │  16  │  49   │  R-- │
│   6    │  1  │  4  │  8   │  5   │   3   │  15  │  49   │  R-- │
│   7    │  1  │  3  │  8   │  2   │   2   │  4   │  49   │  R-- │
│   8    │  1  │  2  │  8   │  6   │   1   │  6   │  49   │  R-- │
│   9    │  L ≥ R → STOP                                         │
├────────────────────────────────────────────────────────────────┤
│  RESULT: Maximum Area = 49 (between indices 1 and 8)           │
└────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def max_area(height: list[int]) -> int:
    """
    Find maximum water container area.
    
    Time: O(n) - each pointer moves at most n times
    Space: O(1) - only pointers and max tracker
    
    Key Insight: Moving shorter line is the only way to 
                 potentially find a larger container.
    """
    left, right = 0, len(height) - 1
    max_water = 0
    
    while left < right:
        # Calculate current container
        width = right - left
        h = min(height[left], height[right])
        current = width * h
        
        # Update maximum
        max_water = max(max_water, current)
        
        # Move the shorter line (greedy choice)
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    
    return max_water

# Optimized version: Skip equal or shorter heights
def max_area_optimized(height: list[int]) -> int:
    """
    Optimized version that skips lines that can't improve result.
    """
    left, right = 0, len(height) - 1
    max_water = 0
    
    while left < right:
        h = min(height[left], height[right])
        max_water = max(max_water, h * (right - left))
        
        # Skip all lines shorter than or equal to current
        if height[left] < height[right]:
            current_height = height[left]
            while left < right and height[left] <= current_height:
                left += 1
        else:
            current_height = height[right]
            while left < right and height[right] <= current_height:
                right -= 1
    
    return max_water
```

---

## 4.1.2 Trapping Rain Water

### Problem Statement
Given n non-negative integers representing elevation map where width of each bar is 1, compute how much water can be trapped after raining.

### Visual Representation

```
Height: [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]

Water trapped shown as '~':

                            3
                            █
            2 ~ ~ ~ ~ ~ ~   █   2       2
            █   1   1   1   █   █   1   █   1
    0   1   █ 0 █ 0 █ 0 █   █   █ 0 █ 0 █ 0
        █ ~ █ ~ █ ~ █ ~ █   █   █ ~ █ ~ █
    ─────────────────────────────────────────
    0   1   2   3   4   5   6   7   8   9  10  11

Water at each position:
Position: 0  1  2  3  4  5  6  7  8  9  10 11
Height:   0  1  0  2  1  0  1  3  2  1  2  1
Water:    0  0  1  0  1  2  1  0  0  1  0  0
                                    
Total = 1 + 1 + 2 + 1 + 1 = 6 units
```

### Key Insight: Water at Each Position

```
┌─────────────────────────────────────────────────────────────────┐
│  WATER LEVEL FORMULA                                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Water at position i = min(left_max, right_max) - height[i]    │
│                                                                 │
│  Where:                                                         │
│  • left_max = maximum height to the left of i (inclusive)      │
│  • right_max = maximum height to the right of i (inclusive)    │
│                                                                 │
│  Example at position 5 (height = 0):                           │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  left_max = max(0,1,0,2,1,0) = 2                        │   │
│  │  right_max = max(0,1,3,2,1,2,1) = 3                     │   │
│  │  water_level = min(2, 3) = 2                            │   │
│  │  water_trapped = 2 - 0 = 2                              │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  INTUITION: Water level is limited by the SHORTER of the two  │
│             tallest walls on either side.                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Two Pointer Approach

```
┌─────────────────────────────────────────────────────────────────┐
│  TWO POINTER OPTIMIZATION                                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Instead of computing left_max and right_max for each i,       │
│  we can process from both ends simultaneously!                  │
│                                                                 │
│  Key Insight:                                                   │
│  If height[L] < height[R]:                                      │
│    • We KNOW there's a wall at R that's at least height[R]     │
│    • So right_max ≥ height[R] > height[L]                      │
│    • Water at L is determined by left_max only!                │
│    • Process L, then move L++                                   │
│                                                                 │
│  If height[L] ≥ height[R]:                                      │
│    • We KNOW there's a wall at L that's at least height[L]     │
│    • So left_max ≥ height[L] ≥ height[R]                       │
│    • Water at R is determined by right_max only!               │
│    • Process R, then move R--                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Step-by-Step Execution

```
Height: [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]

┌────────────────────────────────────────────────────────────────────────┐
│ Step │ L │ R  │h[L]│h[R]│L_max│R_max│ Process │ Water │ Total │       │
├──────┼───┼────┼────┼────┼─────┼─────┼─────────┼───────┼───────┼───────┤
│  1   │ 0 │ 11 │ 0  │ 1  │  0  │  1  │  L=0    │   0   │   0   │ L++   │
│  2   │ 1 │ 11 │ 1  │ 1  │  1  │  1  │  L=1    │   0   │   0   │ L++   │
│  3   │ 2 │ 11 │ 0  │ 1  │  1  │  1  │  L=2    │   1   │   1   │ L++   │
│  4   │ 3 │ 11 │ 2  │ 1  │  2  │  1  │  R=11   │   0   │   1   │ R--   │
│  5   │ 3 │ 10 │ 2  │ 2  │  2  │  2  │  R=10   │   0   │   1   │ R--   │
│  6   │ 3 │ 9  │ 2  │ 1  │  2  │  2  │  R=9    │   1   │   2   │ R--   │
│  7   │ 3 │ 8  │ 2  │ 2  │  2  │  2  │  R=8    │   0   │   2   │ R--   │
│  8   │ 3 │ 7  │ 2  │ 3  │  2  │  3  │  L=3    │   0   │   2   │ L++   │
│  9   │ 4 │ 7  │ 1  │ 3  │  2  │  3  │  L=4    │   1   │   3   │ L++   │
│ 10   │ 5 │ 7  │ 0  │ 3  │  2  │  3  │  L=5    │   2   │   5   │ L++   │
│ 11   │ 6 │ 7  │ 1  │ 3  │  2  │  3  │  L=6    │   1   │   6   │ L++   │
│ 12   │ L ≥ R → STOP                                                    │
├────────────────────────────────────────────────────────────────────────┤
│  RESULT: Total Water Trapped = 6 units                                 │
└────────────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def trap(height: list[int]) -> int:
    """
    Calculate trapped rainwater using two pointers.
    
    Time: O(n) - single pass
    Space: O(1) - only pointers and max trackers
    """
    if not height:
        return 0
    
    left, right = 0, len(height) - 1
    left_max, right_max = 0, 0
    water = 0
    
    while left < right:
        if height[left] < height[right]:
            # Process left side
            if height[left] >= left_max:
                left_max = height[left]  # Update max, no water here
            else:
                water += left_max - height[left]  # Trap water
            left += 1
        else:
            # Process right side
            if height[right] >= right_max:
                right_max = height[right]  # Update max, no water here
            else:
                water += right_max - height[right]  # Trap water
            right -= 1
    
    return water

# Alternative approaches for comparison
def trap_dp(height: list[int]) -> int:
    """
    DP approach: Pre-compute left_max and right_max arrays.
    Time: O(n), Space: O(n)
    """
    if not height:
        return 0
    
    n = len(height)
    left_max = [0] * n
    right_max = [0] * n
    
    # Compute left_max
    left_max[0] = height[0]
    for i in range(1, n):
        left_max[i] = max(left_max[i-1], height[i])
    
    # Compute right_max
    right_max[n-1] = height[n-1]
    for i in range(n-2, -1, -1):
        right_max[i] = max(right_max[i+1], height[i])
    
    # Calculate water
    water = 0
    for i in range(n):
        water += min(left_max[i], right_max[i]) - height[i]
    
    return water

def trap_stack(height: list[int]) -> int:
    """
    Monotonic stack approach.
    Time: O(n), Space: O(n)
    """
    stack = []  # Store indices
    water = 0
    
    for i, h in enumerate(height):
        while stack and height[stack[-1]] < h:
            bottom = stack.pop()
            if not stack:
                break
            # Calculate water above 'bottom'
            width = i - stack[-1] - 1
            bounded_height = min(h, height[stack[-1]]) - height[bottom]
            water += width * bounded_height
        stack.append(i)
    
    return water
```

### Approach Comparison

```
┌─────────────────────────────────────────────────────────────────┐
│  TRAPPING RAIN WATER - APPROACH COMPARISON                      │
├────────────────┬────────────────┬────────────────┬──────────────┤
│   Approach     │   Time         │   Space        │   Notes      │
├────────────────┼────────────────┼────────────────┼──────────────┤
│ Two Pointers   │   O(n)         │   O(1)         │ Optimal!     │
│ DP (arrays)    │   O(n)         │   O(n)         │ Intuitive    │
│ Monotonic Stack│   O(n)         │   O(n)         │ Horizontal   │
│ Brute Force    │   O(n²)        │   O(1)         │ Too slow     │
└────────────────┴────────────────┴────────────────┴──────────────┘
```

---

## 4.1.3 Container Problems: Summary

```
┌─────────────────────────────────────────────────────────────────┐
│  CONTAINER PROBLEMS TOOLKIT                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  CONTAINER WITH MOST WATER:                                     │
│  • Goal: Maximize area between two lines                        │
│  • Formula: min(h[L], h[R]) × (R - L)                          │
│  • Strategy: Move shorter line (greedy)                         │
│  • Proof: Moving taller line can never help                     │
│                                                                 │
│  TRAPPING RAIN WATER:                                           │
│  • Goal: Calculate total water trapped                          │
│  • Formula: sum of min(left_max, right_max) - height[i]        │
│  • Strategy: Process from side with smaller max                 │
│  • Key: If h[L] < h[R], left_max determines water at L         │
│                                                                 │
│  COMMON PATTERN:                                                │
│  • Start with widest possible range                             │
│  • Make greedy decisions about which pointer to move           │
│  • Guarantee correctness through proof                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# 4.2 Subarray Problems

## Core Concept

Subarray problems involve finding contiguous portions of an array that satisfy certain conditions.

```
┌─────────────────────────────────────────────────────────────────┐
│                   SUBARRAY PROBLEM TYPES                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. FIND OPTIMAL SUBARRAY                                       │
│     • Minimum/Maximum length with condition                     │
│     • Subarray with exact/at least/at most sum                 │
│                                                                 │
│  2. COUNT SUBARRAYS                                             │
│     • Number of subarrays with property                         │
│     • Often uses: count(at most K) - count(at most K-1)        │
│                                                                 │
│  3. PRODUCT/SUM CONSTRAINTS                                     │
│     • Product less than K                                       │
│     • Sum equals/greater than target                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4.2.1 Minimum Size Subarray Sum

### Problem
Find the minimal length subarray with sum ≥ target.

### Visualization

```
nums = [2, 3, 1, 2, 4, 3]    target = 7

┌────────────────────────────────────────────────────────────────┐
│  SLIDING WINDOW APPROACH                                       │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  Expand until sum ≥ target, then shrink to minimize length    │
│                                                                │
│  [2, 3, 1, 2] 4, 3    sum=8 ≥ 7, len=4                        │
│   L        R           Try shrinking...                        │
│                                                                │
│   [3, 1, 2] 4, 3      sum=6 < 7, must expand                  │
│    L     R                                                     │
│                                                                │
│   [3, 1, 2, 4] 3      sum=10 ≥ 7, len=4                       │
│    L        R          Try shrinking...                        │
│                                                                │
│      [1, 2, 4] 3      sum=7 ≥ 7, len=3                        │
│       L     R          Try shrinking...                        │
│                                                                │
│         [2, 4] 3      sum=6 < 7, must expand                  │
│          L  R                                                  │
│                                                                │
│         [2, 4, 3]     sum=9 ≥ 7, len=3                        │
│          L     R       Try shrinking...                        │
│                                                                │
│            [4, 3]     sum=7 ≥ 7, len=2 ✓                      │
│             L  R       Try shrinking...                        │
│                                                                │
│               [3]     sum=3 < 7, done                         │
│                                                                │
│  RESULT: Minimum length = 2 ([4, 3])                          │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def min_sub_array_len(target: int, nums: list[int]) -> int:
    """
    Find minimum length subarray with sum >= target.
    
    Time: O(n) - each element visited at most twice
    Space: O(1)
    """
    left = 0
    current_sum = 0
    min_length = float('inf')
    
    for right in range(len(nums)):
        # Expand: add current element
        current_sum += nums[right]
        
        # Shrink: while sum is sufficient, try to minimize
        while current_sum >= target:
            min_length = min(min_length, right - left + 1)
            current_sum -= nums[left]
            left += 1
    
    return min_length if min_length != float('inf') else 0

# Variant: Subarray with sum EXACTLY equal to target
def subarray_sum_equals(nums: list[int], target: int) -> list[int]:
    """
    Find subarray with sum exactly equal to target.
    Works for positive numbers only.
    """
    left = 0
    current_sum = 0
    
    for right in range(len(nums)):
        current_sum += nums[right]
        
        while current_sum > target and left <= right:
            current_sum -= nums[left]
            left += 1
        
        if current_sum == target:
            return [left, right]
    
    return [-1, -1]
```

---

## 4.2.2 Subarray Product Less Than K

### Problem
Count subarrays where product of all elements < k.

### Key Insight

```
┌─────────────────────────────────────────────────────────────────┐
│  COUNTING SUBARRAYS ENDING AT EACH POSITION                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  nums = [10, 5, 2, 6]    k = 100                               │
│                                                                 │
│  For window [L...R] with product < k:                          │
│  Number of valid subarrays ENDING at R = R - L + 1             │
│                                                                 │
│  Example: Window [5, 2, 6] (indices 1-3)                       │
│  Valid subarrays ending at index 3:                            │
│    [6]        (length 1)                                        │
│    [2, 6]     (length 2)                                        │
│    [5, 2, 6]  (length 3)                                        │
│  Count = 3 - 1 + 1 = 3                                          │
│                                                                 │
│  This works because any subarray within a valid window         │
│  that ends at R is also valid (smaller product).               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Step-by-Step Execution

```
nums = [10, 5, 2, 6]    k = 100

┌────────────────────────────────────────────────────────────────┐
│ R │ L │   Window    │ Product │ Valid? │ New Subarrays│ Total │
├───┼───┼─────────────┼─────────┼────────┼──────────────┼───────┤
│ 0 │ 0 │ [10]        │   10    │   ✓    │     1        │   1   │
│ 1 │ 0 │ [10,5]      │   50    │   ✓    │     2        │   3   │
│ 2 │ 0 │ [10,5,2]    │  100    │   ✗    │              │       │
│   │ 1 │ [5,2]       │   10    │   ✓    │     2        │   5   │
│ 3 │ 1 │ [5,2,6]     │   60    │   ✓    │     3        │   8   │
└───┴───┴─────────────┴─────────┴────────┴──────────────┴───────┘

Result: 8 subarrays with product < 100
Subarrays: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]
```

### Implementation

```python
def num_subarray_product_less_than_k(nums: list[int], k: int) -> int:
    """
    Count subarrays with product < k.
    
    Time: O(n), Space: O(1)
    """
    if k <= 1:
        return 0
    
    left = 0
    product = 1
    count = 0
    
    for right in range(len(nums)):
        # Expand: multiply current element
        product *= nums[right]
        
        # Shrink: while product >= k
        while product >= k:
            product //= nums[left]
            left += 1
        
        # Count subarrays ending at 'right'
        # All subarrays [left..right], [left+1..right], ..., [right..right]
        count += right - left + 1
    
    return count

# Variant: Maximum length subarray with product < k
def max_length_product_less_than_k(nums: list[int], k: int) -> int:
    """Find maximum length subarray with product < k."""
    if k <= 1:
        return 0
    
    left = 0
    product = 1
    max_len = 0
    
    for right in range(len(nums)):
        product *= nums[right]
        
        while product >= k and left <= right:
            product //= nums[left]
            left += 1
        
        max_len = max(max_len, right - left + 1)
    
    return max_len
```

---

## 4.2.3 Subarrays with K Different Integers

### Problem
Count subarrays with exactly K distinct integers.

### Key Technique: at_most(K) - at_most(K-1)

```
┌─────────────────────────────────────────────────────────────────┐
│  EXACTLY K = AT_MOST(K) - AT_MOST(K-1)                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  This technique transforms "exactly K" into "at most K":       │
│                                                                 │
│  exactly(K) = at_most(K) - at_most(K-1)                        │
│                                                                 │
│  Example: K = 2                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  at_most(2) includes subarrays with 0, 1, or 2 distinct │   │
│  │  at_most(1) includes subarrays with 0 or 1 distinct     │   │
│  │  Difference = subarrays with EXACTLY 2 distinct         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Why this works:                                                │
│  • "At most K" is easier to compute with sliding window        │
│  • Window stays valid as long as distinct ≤ K                  │
│  • Can count all valid subarrays at each step                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
from collections import defaultdict

def subarrays_with_k_distinct(nums: list[int], k: int) -> int:
    """
    Count subarrays with exactly K distinct integers.
    
    Time: O(n), Space: O(n)
    
    Uses: exactly(K) = at_most(K) - at_most(K-1)
    """
    def at_most(k: int) -> int:
        """Count subarrays with at most k distinct integers."""
        if k == 0:
            return 0
        
        count = defaultdict(int)
        left = 0
        result = 0
        
        for right in range(len(nums)):
            # Add current element
            if count[nums[right]] == 0:
                k -= 1  # New distinct element
            count[nums[right]] += 1
            
            # Shrink while more than k distinct
            while k < 0:
                count[nums[left]] -= 1
                if count[nums[left]] == 0:
                    k += 1  # Removed a distinct element
                left += 1
            
            # All subarrays ending at 'right' with at most k distinct
            result += right - left + 1
        
        return result
    
    return at_most(k) - at_most(k - 1)

# Step-by-step trace for nums=[1,2,1,2,3], k=2:
# at_most(2) = 12 (all subarrays with ≤2 distinct)
# at_most(1) = 5  (all subarrays with ≤1 distinct)
# exactly(2) = 12 - 5 = 7
```

---

## 4.2.4 Maximum Sum of Two Non-Overlapping Subarrays

### Problem
Find maximum sum of two non-overlapping subarrays of lengths L and M.

### Strategy

```
┌─────────────────────────────────────────────────────────────────┐
│  TWO NON-OVERLAPPING SUBARRAYS                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Two cases:                                                     │
│  1. L subarray comes BEFORE M subarray                         │
│  2. M subarray comes BEFORE L subarray                         │
│                                                                 │
│  For each position i:                                           │
│  • Track best L-sum ending at or before i                      │
│  • Track M-sum starting at i                                    │
│  • Combine for total                                            │
│                                                                 │
│  Use prefix sums for O(1) range sum queries.                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def max_sum_two_no_overlap(nums: list[int], L: int, M: int) -> int:
    """
    Maximum sum of two non-overlapping subarrays.
    First has length L, second has length M.
    
    Time: O(n), Space: O(n)
    """
    n = len(nums)
    
    # Compute prefix sums
    prefix = [0] * (n + 1)
    for i in range(n):
        prefix[i + 1] = prefix[i] + nums[i]
    
    def range_sum(i, j):
        """Sum of nums[i:j+1]"""
        return prefix[j + 1] - prefix[i]
    
    max_sum = 0
    
    # Case 1: L before M
    max_l = 0  # Best L-subarray sum ending at or before current position
    for i in range(L - 1, n - M):
        # Update best L-sum up to position i
        max_l = max(max_l, range_sum(i - L + 1, i))
        # M-subarray starts at i+1
        m_sum = range_sum(i + 1, i + M)
        max_sum = max(max_sum, max_l + m_sum)
    
    # Case 2: M before L
    max_m = 0  # Best M-subarray sum ending at or before current position
    for i in range(M - 1, n - L):
        max_m = max(max_m, range_sum(i - M + 1, i))
        l_sum = range_sum(i + 1, i + L)
        max_sum = max(max_sum, max_m + l_sum)
    
    return max_sum
```

---

## Subarray Problems: Summary

```
┌─────────────────────────────────────────────────────────────────┐
│  SUBARRAY PROBLEMS TOOLKIT                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  MINIMUM LENGTH WITH SUM ≥ TARGET:                             │
│  • Expand until valid, shrink while valid                      │
│  • Update min_length during shrinking                          │
│                                                                 │
│  PRODUCT < K:                                                   │
│  • Count subarrays ending at each position                     │
│  • Valid window [L,R] contributes R-L+1 subarrays              │
│                                                                 │
│  EXACTLY K DISTINCT:                                            │
│  • Use at_most(K) - at_most(K-1)                               │
│  • Transforms "exactly" into two "at most" problems            │
│                                                                 │
│  NON-OVERLAPPING SUBARRAYS:                                     │
│  • Consider both orderings                                      │
│  • Track best first-subarray up to each position               │
│  • Use prefix sums for range queries                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# 4.3 Substring Problems

## Core Concept

Substring problems use sliding window with character frequency tracking.

---

## 4.3.1 Minimum Window Substring

### Problem
Find smallest substring of s containing all characters of t.

### Visualization

```
s = "ADOBECODEBANC"    t = "ABC"

Need: A=1, B=1, C=1

┌────────────────────────────────────────────────────────────────┐
│  Step  │   Window        │   Have    │ Valid? │    Action     │
├────────┼─────────────────┼───────────┼────────┼───────────────┤
│   1    │ [A]DOBECODEBANC │ A=1       │   ✗    │ Expand        │
│   2    │ [AD]OBECODEBANC │ A=1,D=1   │   ✗    │ Expand        │
│   3    │ [ADO]BECODEBANC │ A=1,D=1,O=1│  ✗    │ Expand        │
│   4    │ [ADOB]ECODEBANC │ A=1,B=1...│   ✗    │ Expand        │
│   5    │ [ADOBE]CODEBANC │ ...       │   ✗    │ Expand        │
│   6    │ [ADOBEC]ODEBANC │ A=1,B=1,C=1│  ✓    │ Shrink!       │
│        │         len=6   │           │        │               │
│   7    │  [DOBEC]ODEBANC │ A=0       │   ✗    │ Expand        │
│   8    │  ...continue... │           │        │               │
│   ...  │                 │           │        │               │
│   N    │          [BANC] │ B=1,A=1,  │   ✓    │ Best! len=4   │
│        │                 │ N=1,C=1   │        │               │
└────────┴─────────────────┴───────────┴────────┴───────────────┘

Result: "BANC" (length 4)
```

### Implementation

```python
from collections import Counter

def min_window(s: str, t: str) -> str:
    """
    Find minimum window substring containing all chars of t.
    
    Time: O(|s| + |t|), Space: O(|s| + |t|)
    """
    if not s or not t or len(s) < len(t):
        return ""
    
    # Count characters needed from t
    need = Counter(t)
    required = len(need)  # Number of unique chars to satisfy
    
    # Window state
    window = {}
    formed = 0  # Unique chars in current window with sufficient count
    
    # Result: (window length, left, right)
    result = (float('inf'), 0, 0)
    
    left = 0
    
    for right, char in enumerate(s):
        # Expand: add character
        window[char] = window.get(char, 0) + 1
        
        # Check if this char is now satisfied
        if char in need and window[char] == need[char]:
            formed += 1
        
        # Shrink: while window is valid
        while formed == required:
            # Update result if smaller
            if right - left + 1 < result[0]:
                result = (right - left + 1, left, right)
            
            # Remove leftmost character
            left_char = s[left]
            window[left_char] -= 1
            
            if left_char in need and window[left_char] < need[left_char]:
                formed -= 1
            
            left += 1
    
    # Return result
    length, start, end = result
    return "" if length == float('inf') else s[start:end + 1]
```

---

## 4.3.2 Find All Anagrams

### Problem
Find all start indices of p's anagrams in s.

### Key Insight

```
┌─────────────────────────────────────────────────────────────────┐
│  FIXED WINDOW SIZE                                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Anagram has SAME length as p!                                  │
│  Use fixed window of size len(p).                               │
│                                                                 │
│  s = "cbaebabacd"    p = "abc"                                 │
│                                                                 │
│  Window size = 3                                                │
│                                                                 │
│  [cba]ebabacd → counts match "abc"? YES! → index 0             │
│  c[bae]babacd → counts match? NO                                │
│  cb[aeb]abacd → counts match? NO                                │
│  cba[eba]bacd → counts match? NO                                │
│  cbae[bab]acd → counts match? NO                                │
│  cbaeb[aba]cd → counts match? NO                                │
│  cbaeba[bac]d → counts match "abc"? YES! → index 6             │
│  cbaebab[acd] → counts match? NO                                │
│                                                                 │
│  Result: [0, 6]                                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
from collections import Counter

def find_anagrams(s: str, p: str) -> list[int]:
    """
    Find all anagram starting indices.
    
    Time: O(n), Space: O(1) - at most 26 chars
    """
    if len(s) < len(p):
        return []
    
    p_count = Counter(p)
    window = Counter()
    result = []
    k = len(p)
    
    for i in range(len(s)):
        # Add new character to window
        window[s[i]] += 1
        
        # Remove character that's no longer in window
        if i >= k:
            left_char = s[i - k]
            window[left_char] -= 1
            if window[left_char] == 0:
                del window[left_char]
        
        # Check if window matches p
        if window == p_count:
            result.append(i - k + 1)
    
    return result

# Optimized version using match counter
def find_anagrams_optimized(s: str, p: str) -> list[int]:
    """
    Optimized using character match tracking.
    Avoids comparing entire counters at each step.
    """
    if len(s) < len(p):
        return []
    
    p_count = Counter(p)
    required = len(p_count)  # Unique chars to match
    
    window = {}
    formed = 0  # Chars with matching count
    result = []
    k = len(p)
    
    for i in range(len(s)):
        # Add new character
        char = s[i]
        window[char] = window.get(char, 0) + 1
        
        if char in p_count and window[char] == p_count[char]:
            formed += 1
        elif char in p_count and window[char] == p_count[char] + 1:
            formed -= 1  # Exceeded required count
        
        # Remove old character
        if i >= k:
            left_char = s[i - k]
            if left_char in p_count and window[left_char] == p_count[left_char]:
                formed -= 1
            elif left_char in p_count and window[left_char] == p_count[left_char] + 1:
                formed += 1  # Back to required count
            
            window[left_char] -= 1
            if window[left_char] == 0:
                del window[left_char]
        
        # Check if anagram
        if formed == required:
            result.append(i - k + 1)
    
    return result
```

---

## 4.3.3 Longest Substring Without Repeating Characters

### Implementation with Optimization

```python
def length_of_longest_substring(s: str) -> int:
    """
    Find length of longest substring without repeating characters.
    
    Time: O(n), Space: O(min(n, alphabet_size))
    """
    char_index = {}  # Last seen index of each character
    left = 0
    max_length = 0
    
    for right, char in enumerate(s):
        # If char seen before AND within current window
        if char in char_index and char_index[char] >= left:
            # Jump left past the duplicate
            left = char_index[char] + 1
        
        # Update last seen index
        char_index[char] = right
        
        # Update max length
        max_length = max(max_length, right - left + 1)
    
    return max_length

# Variant: Return the actual substring
def longest_substring_without_repeating(s: str) -> str:
    """Return the actual longest substring."""
    char_index = {}
    left = 0
    max_length = 0
    start = 0
    
    for right, char in enumerate(s):
        if char in char_index and char_index[char] >= left:
            left = char_index[char] + 1
        
        char_index[char] = right
        
        if right - left + 1 > max_length:
            max_length = right - left + 1
            start = left
    
    return s[start:start + max_length]
```

---

## 4.3.4 Substring with Concatenation of All Words

### Problem
Find all starting indices where concatenation of all words in words[] exists as substring.

### Visualization

```
s = "barfoothefoobarman"
words = ["foo", "bar"]    (each word length = 3, total = 6)

┌────────────────────────────────────────────────────────────────┐
│  Check each starting position:                                 │
│                                                                │
│  Start 0: "barfoo" = "bar" + "foo" ✓ → index 0                │
│  Start 1: "arfoot" = "arf" + "oot" ✗                          │
│  Start 2: "rfooth" = ✗                                         │
│  Start 3: "foothe" = "foo" + "the" ✗                          │
│  ...                                                           │
│  Start 9: "foobar" = "foo" + "bar" ✓ → index 9                │
│                                                                │
│  Result: [0, 9]                                                │
└────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
from collections import Counter

def find_substring(s: str, words: list[str]) -> list[int]:
    """
    Find all starting indices of word concatenations.
    
    Time: O(n * m * k) where n=len(s), m=len(words), k=len(word)
    Space: O(m)
    """
    if not s or not words:
        return []
    
    word_len = len(words[0])
    num_words = len(words)
    total_len = word_len * num_words
    word_count = Counter(words)
    result = []
    
    # Check each starting position
    for i in range(len(s) - total_len + 1):
        seen = {}
        j = 0
        
        while j < num_words:
            # Extract next word
            word_start = i + j * word_len
            word = s[word_start:word_start + word_len]
            
            if word not in word_count:
                break  # Invalid word
            
            seen[word] = seen.get(word, 0) + 1
            
            if seen[word] > word_count[word]:
                break  # Too many occurrences
            
            j += 1
        
        if j == num_words:
            result.append(i)
    
    return result

# Optimized: Use sliding window for each offset
def find_substring_optimized(s: str, words: list[str]) -> list[int]:
    """
    Optimized using sliding window technique.
    For each offset (0 to word_len-1), use sliding window.
    
    Time: O(n * k) where k = word_len
    """
    if not s or not words:
        return []
    
    word_len = len(words[0])
    num_words = len(words)
    total_len = word_len * num_words
    word_count = Counter(words)
    result = []
    
    # For each offset
    for offset in range(word_len):
        left = offset
        seen = {}
        count = 0  # Words matched
        
        for right in range(offset, len(s) - word_len + 1, word_len):
            word = s[right:right + word_len]
            
            if word in word_count:
                seen[word] = seen.get(word, 0) + 1
                count += 1
                
                # Too many of this word
                while seen[word] > word_count[word]:
                    left_word = s[left:left + word_len]
                    seen[left_word] -= 1
                    count -= 1
                    left += word_len
                
                # Found valid window
                if count == num_words:
                    result.append(left)
            else:
                # Invalid word, reset window
                seen.clear()
                count = 0
                left = right + word_len
    
    return sorted(result)
```

---

## Substring Problems: Summary

```
┌─────────────────────────────────────────────────────────────────┐
│  SUBSTRING PROBLEMS TOOLKIT                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  MINIMUM WINDOW SUBSTRING:                                      │
│  • Expand until valid, shrink while valid                      │
│  • Track "formed" count for efficiency                          │
│                                                                 │
│  FIND ALL ANAGRAMS:                                             │
│  • Fixed window size = len(pattern)                            │
│  • Compare character counts                                     │
│                                                                 │
│  LONGEST WITHOUT REPEATING:                                     │
│  • Track last seen index of each character                     │
│  • Jump left past duplicate when found                          │
│                                                                 │
│  WORD CONCATENATION:                                            │
│  • Fixed total length = num_words * word_len                   │
│  • Use sliding window for each offset                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# 4.4 Binary Search + Two Pointers

## Core Concept

Combining binary search with two pointers for complex search problems.

---

## 4.4.1 Find K Closest Elements

### Problem
Find k closest elements to x in sorted array.

### Strategy

```
┌─────────────────────────────────────────────────────────────────┐
│  BINARY SEARCH FOR WINDOW START                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Instead of finding element, find STARTING POSITION of window! │
│                                                                 │
│  arr = [1, 2, 3, 4, 5]    k = 4    x = 3                       │
│                                                                 │
│  Possible windows of size 4:                                    │
│  [1, 2, 3, 4] starting at index 0                              │
│  [2, 3, 4, 5] starting at index 1                              │
│                                                                 │
│  Binary search: Find best starting index in range [0, n-k]     │
│                                                                 │
│  Comparison: Is left bound or right bound closer to x?         │
│  If x - arr[mid] > arr[mid+k] - x:                             │
│     Right side is closer → move left                            │
│  Else:                                                          │
│     Left side is closer or equal → this could be answer        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def find_closest_elements(arr: list[int], k: int, x: int) -> list[int]:
    """
    Find k closest elements to x.
    
    Time: O(log(n-k) + k), Space: O(1)
    """
    left, right = 0, len(arr) - k
    
    while left < right:
        mid = (left + right) // 2
        
        # Compare distances from x to window boundaries
        # Window is [mid, mid+k-1], next window is [mid+1, mid+k]
        if x - arr[mid] > arr[mid + k] - x:
            # Right boundary of next window is closer
            left = mid + 1
        else:
            # Current window's left boundary is closer or equal
            right = mid
    
    return arr[left:left + k]

# Alternative: Two pointer approach after binary search
def find_closest_elements_v2(arr: list[int], k: int, x: int) -> list[int]:
    """
    Binary search to find closest element, then expand.
    
    Time: O(log n + k), Space: O(1)
    """
    n = len(arr)
    
    # Find insertion point
    left, right = 0, n - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] < x:
            left = mid + 1
        else:
            right = mid - 1
    
    # Now left is insertion point, expand from there
    low, high = left - 1, left
    
    while high - low - 1 < k:
        if low < 0:
            high += 1
        elif high >= n:
            low -= 1
        elif x - arr[low] <= arr[high] - x:
            low -= 1
        else:
            high += 1
    
    return arr[low + 1:high]
```

---

## 4.4.2 Kth Smallest Element in Sorted Matrix

### Problem
Find kth smallest element in n×n matrix where each row and column is sorted.

### Strategy: Binary Search on Value

```
┌─────────────────────────────────────────────────────────────────┐
│  BINARY SEARCH ON VALUE RANGE                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Matrix:                                                        │
│  [ 1,  5,  9]                                                  │
│  [10, 11, 13]                                                   │
│  [12, 13, 15]                                                   │
│                                                                 │
│  Value range: [1, 15]                                           │
│  For each mid value, count elements ≤ mid                      │
│  Use two pointers to count efficiently!                         │
│                                                                 │
│  mid = 8:                                                       │
│  Row 0: 1, 5 ≤ 8 (count 2)                                     │
│  Row 1: none ≤ 8 (count 0)                                     │
│  Row 2: none ≤ 8 (count 0)                                     │
│  Total = 2 < k=4, so answer > 8                                │
│                                                                 │
│  Adjust binary search accordingly.                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def kth_smallest(matrix: list[list[int]], k: int) -> int:
    """
    Find kth smallest in sorted matrix.
    
    Time: O(n * log(max-min)), Space: O(1)
    """
    n = len(matrix)
    
    def count_less_equal(target: int) -> int:
        """Count elements ≤ target using two pointers."""
        count = 0
        row, col = n - 1, 0  # Start from bottom-left
        
        while row >= 0 and col < n:
            if matrix[row][col] <= target:
                # All elements in this column up to row are ≤ target
                count += row + 1
                col += 1
            else:
                row -= 1
        
        return count
    
    # Binary search on value
    left, right = matrix[0][0], matrix[n-1][n-1]
    
    while left < right:
        mid = (left + right) // 2
        
        if count_less_equal(mid) < k:
            left = mid + 1
        else:
            right = mid
    
    return left
```

---

## 4.4.3 Find the Duplicate Number

### Problem
Array of n+1 integers in range [1, n], find the duplicate.

### Strategy: Binary Search + Counting

```
┌─────────────────────────────────────────────────────────────────┐
│  BINARY SEARCH ON VALUE RANGE                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  nums = [1, 3, 4, 2, 2]    n = 4                               │
│  Values in range [1, 4]                                         │
│                                                                 │
│  KEY INSIGHT:                                                   │
│  If no duplicates, count(≤ mid) = mid                          │
│  If duplicate ≤ mid, count(≤ mid) > mid                        │
│                                                                 │
│  mid = 2:                                                       │
│  Elements ≤ 2: [1, 2, 2] → count = 3 > 2                       │
│  Duplicate is ≤ 2!                                              │
│                                                                 │
│  mid = 1:                                                       │
│  Elements ≤ 1: [1] → count = 1 = 1                             │
│  Duplicate is > 1                                               │
│                                                                 │
│  Therefore duplicate = 2                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
def find_duplicate(nums: list[int]) -> int:
    """
    Find duplicate number using binary search on value range.
    
    Time: O(n log n), Space: O(1)
    """
    left, right = 1, len(nums) - 1
    
    while left < right:
        mid = (left + right) // 2
        
        # Count elements ≤ mid
        count = sum(1 for num in nums if num <= mid)
        
        if count > mid:
            # Duplicate is in [left, mid]
            right = mid
        else:
            # Duplicate is in [mid+1, right]
            left = mid + 1
    
    return left

# Floyd's Cycle Detection (O(n) time)
def find_duplicate_floyd(nums: list[int]) -> int:
    """
    Using Floyd's cycle detection.
    Treat array as linked list: index → value → next index
    
    Time: O(n), Space: O(1)
    """
    # Phase 1: Find meeting point
    slow = fast = nums[0]
    
    while True:
        slow = nums[slow]
        fast = nums[nums[fast]]
        if slow == fast:
            break
    
    # Phase 2: Find cycle start
    slow = nums[0]
    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]
    
    return slow
```

---

## Binary Search + Two Pointers: Summary

```
┌─────────────────────────────────────────────────────────────────┐
│  BINARY SEARCH + TWO POINTERS                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  K CLOSEST ELEMENTS:                                            │
│  • Binary search for window START position                     │
│  • Compare window boundaries to target                          │
│                                                                 │
│  KTH SMALLEST IN MATRIX:                                        │
│  • Binary search on VALUE range                                 │
│  • Two pointers to count elements ≤ mid                        │
│                                                                 │
│  FIND DUPLICATE:                                                │
│  • Binary search: count elements ≤ mid                         │
│  • If count > mid, duplicate ≤ mid                             │
│  • Or use Floyd's cycle detection                               │
│                                                                 │
│  PATTERN:                                                       │
│  • Binary search defines WHAT to search                        │
│  • Two pointers VALIDATES each candidate                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# 4.5 Advanced Multi-Pointer Techniques

## 4.5.1 3+ Pointer Problems

### Shortest Unsorted Continuous Subarray

```python
def find_unsorted_subarray(nums: list[int]) -> int:
    """
    Find length of shortest subarray that, if sorted,
    would make entire array sorted.
    
    Time: O(n), Space: O(1)
    
    Strategy: Use two passes to find boundaries.
    """
    n = len(nums)
    
    # Find right boundary: rightmost element smaller than max seen from left
    max_seen = float('-inf')
    right = -1
    
    for i in range(n):
        if nums[i] < max_seen:
            right = i
        else:
            max_seen = nums[i]
    
    # Find left boundary: leftmost element larger than min seen from right
    min_seen = float('inf')
    left = 0
    
    for i in range(n - 1, -1, -1):
        if nums[i] > min_seen:
            left = i
        else:
            min_seen = nums[i]
    
    return right - left + 1 if right != -1 else 0
```

### Longest Mountain in Array

```python
def longest_mountain(arr: list[int]) -> int:
    """
    Find longest mountain subarray.
    Mountain: strictly increasing then strictly decreasing.
    
    Time: O(n), Space: O(1)
    """
    n = len(arr)
    if n < 3:
        return 0
    
    max_length = 0
    i = 1
    
    while i < n - 1:
        # Check if arr[i] is a peak
        if arr[i - 1] < arr[i] > arr[i + 1]:
            # Found peak, expand in both directions
            left = i - 1
            right = i + 1
            
            # Expand left
            while left > 0 and arr[left - 1] < arr[left]:
                left -= 1
            
            # Expand right
            while right < n - 1 and arr[right] > arr[right + 1]:
                right += 1
            
            max_length = max(max_length, right - left + 1)
            
            # Optimization: start next search from right
            i = right
        else:
            i += 1
    
    return max_length
```

---

## 4.5.2 Complex State Management

### Smallest Range Covering Elements from K Lists

### Problem
Given k sorted lists, find smallest range containing at least one element from each list.

### Strategy

```
┌─────────────────────────────────────────────────────────────────┐
│  K-POINTER APPROACH                                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Lists:                                                         │
│  [4, 10, 15, 24, 26]                                           │
│  [0, 9, 12, 20]                                                 │
│  [5, 18, 22, 30]                                               │
│                                                                 │
│  Maintain one pointer in each list.                            │
│  Current values: [4, 0, 5] → Range [0, 5]                      │
│                                                                 │
│  To minimize range:                                             │
│  Move pointer at MINIMUM value (to potentially increase it)    │
│                                                                 │
│  [4, 9, 5] → Range [4, 9]                                      │
│  [4, 9, 18] → Range [4, 18] (worse, but continue)              │
│  ...                                                            │
│                                                                 │
│  Use min-heap to track minimum, variable to track maximum.     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation

```python
import heapq

def smallest_range(nums: list[list[int]]) -> list[int]:
    """
    Find smallest range covering at least one element from each list.
    
    Time: O(n log k) where n = total elements, k = number of lists
    Space: O(k)
    """
    # Min heap: (value, list_index, element_index)
    heap = []
    current_max = float('-inf')
    
    # Initialize with first element from each list
    for i, row in enumerate(nums):
        heapq.heappush(heap, (row[0], i, 0))
        current_max = max(current_max, row[0])
    
    result = [float('-inf'), float('inf')]
    
    while heap:
        current_min, list_idx, elem_idx = heapq.heappop(heap)
        
        # Update result if better range found
        if current_max - current_min < result[1] - result[0]:
            result = [current_min, current_max]
        
        # Move pointer in the list that had minimum
        if elem_idx + 1 < len(nums[list_idx]):
            next_val = nums[list_idx][elem_idx + 1]
            heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))
            current_max = max(current_max, next_val)
        else:
            # One list exhausted, can't cover all lists anymore
            break
    
    return result
```

---

## 4.5.3 Intervals and Meetings

### Interval List Intersections

```python
def interval_intersection(
    first_list: list[list[int]], 
    second_list: list[list[int]]
) -> list[list[int]]:
    """
    Find intersection of two interval lists.
    
    Time: O(n + m), Space: O(1) excluding output
    """
    result = []
    i = j = 0
    
    while i < len(first_list) and j < len(second_list):
        # Find intersection
        start = max(first_list[i][0], second_list[j][0])
        end = min(first_list[i][1], second_list[j][1])
        
        if start <= end:
            result.append([start, end])
        
        # Move pointer with smaller end
        if first_list[i][1] < second_list[j][1]:
            i += 1
        else:
            j += 1
    
    return result
```

---

# Chapter 4: Master Summary

```
┌─────────────────────────────────────────────────────────────────┐
│           ADVANCED TECHNIQUES - KEY TAKEAWAYS                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  CONTAINER PROBLEMS:                                            │
│  • Most Water: Move shorter line (greedy proof)                │
│  • Trapping Rain: Process from side with smaller boundary      │
│                                                                 │
│  SUBARRAY PROBLEMS:                                             │
│  • Min length: Expand-shrink pattern                           │
│  • Count subarrays: Track subarrays ending at each position    │
│  • Exactly K: Use at_most(K) - at_most(K-1)                   │
│                                                                 │
│  SUBSTRING PROBLEMS:                                            │
│  • Character frequency tracking                                 │
│  • "Formed" counter for efficiency                              │
│  • Fixed vs dynamic window                                      │
│                                                                 │
│  BINARY SEARCH + TWO POINTERS:                                  │
│  • Binary search WHAT, two pointers VALIDATE                   │
│  • Search on value range, count with two pointers              │
│                                                                 │
│  MULTI-POINTER:                                                 │
│  • Multiple passes from different directions                    │
│  • Heap for k-pointer problems                                  │
│  • State variables (max_seen, min_seen, etc.)                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

**Next Chapter:** Chapter 5 will cover Hard-Level Problems with complete solutions and detailed analysis.
