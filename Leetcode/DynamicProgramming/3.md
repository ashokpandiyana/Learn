# Chapter 3: Pattern 2 - 2D Grid DP

## Overview

2D Grid DP problems involve a **grid or matrix** where you need to make decisions at each cell. The state is typically represented as `dp[i][j]`, meaning the solution at row `i` and column `j`.

**Pattern Recognition**:
- Input is a 2D grid/matrix
- Movement restricted (usually right, down, or diagonal)
- Need to find paths, count ways, or optimize over the grid
- State requires two indices: row and column

**Common Applications**:
- Path counting in grids
- Minimum/maximum path problems
- Matrix manipulations
- Robot movement problems

---

## 3.1 Path Problems

### 3.1.1 Unique Paths

**Problem**: Robot starts at top-left of `m × n` grid. Can only move right or down. How many unique paths to bottom-right?

**LeetCode**: #62

#### Analysis

**State**: `dp[i][j]` = number of unique paths to reach cell (i, j)

**Recurrence**: 
- Can only reach (i, j) from (i-1, j) or (i, j-1)
- `dp[i][j] = dp[i-1][j] + dp[i][j-1]`

**Base Cases**:
- `dp[0][j] = 1` for all j (only one way: keep moving right)
- `dp[i][0] = 1` for all i (only one way: keep moving down)

**Visualization for 3×3 grid**:
```
Start → → →
  ↓     1  1  1
  ↓     1  2  3
  ↓     1  3  6 ← End
```

```python
# Approach 1: 2D Tabulation
def uniquePaths(m, n):
    # Create m x n grid
    dp = [[0] * n for _ in range(m)]
    
    # Initialize first row and column
    for i in range(m):
        dp[i][0] = 1
    for j in range(n):
        dp[0][j] = 1
    
    # Fill the table
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    
    return dp[m-1][n-1]

# Approach 2: Space Optimized (1D array)
def uniquePaths_optimized(m, n):
    # Only need previous row
    dp = [1] * n
    
    for i in range(1, m):
        for j in range(1, n):
            dp[j] += dp[j-1]
    
    return dp[n-1]

# Approach 3: Memoization
from functools import cache

def uniquePaths_memo(m, n):
    @cache
    def dp(i, j):
        # Base cases
        if i == 0 or j == 0:
            return 1
        if i < 0 or j < 0:
            return 0
        
        return dp(i-1, j) + dp(i, j-1)
    
    return dp(m-1, n-1)

# Test
print(uniquePaths(3, 7))  # 28
print(uniquePaths_optimized(3, 7))  # 28
```

**Complexity**:
- Time: O(m × n)
- Space: O(m × n) for 2D, O(n) for optimized

**Mathematical Insight**: This is actually a combinatorics problem!
- Total moves needed: (m-1) down + (n-1) right = m+n-2 moves
- Answer = C(m+n-2, m-1) = (m+n-2)! / ((m-1)! × (n-1)!)

```python
# Mathematical solution - O(min(m,n)) time, O(1) space
def uniquePaths_math(m, n):
    from math import comb
    return comb(m + n - 2, m - 1)
```

---

### 3.1.2 Unique Paths II (With Obstacles)

**Problem**: Same as Unique Paths, but some cells have obstacles (marked as 1).

**LeetCode**: #63

#### Analysis

**Key Difference**: If cell has obstacle, `dp[i][j] = 0`

**Critical Edge Case**: If start or end cell has obstacle, return 0

```python
def uniquePathsWithObstacles(obstacleGrid):
    if not obstacleGrid or obstacleGrid[0][0] == 1:
        return 0
    
    m, n = len(obstacleGrid), len(obstacleGrid[0])
    dp = [[0] * n for _ in range(m)]
    
    # Initialize first cell
    dp[0][0] = 1
    
    # Initialize first row
    for j in range(1, n):
        if obstacleGrid[0][j] == 0:
            dp[0][j] = dp[0][j-1]
        # else remains 0
    
    # Initialize first column
    for i in range(1, m):
        if obstacleGrid[i][0] == 0:
            dp[i][0] = dp[i-1][0]
        # else remains 0
    
    # Fill the table
    for i in range(1, m):
        for j in range(1, n):
            if obstacleGrid[i][j] == 0:
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
            # else remains 0
    
    return dp[m-1][n-1]

# Space Optimized
def uniquePathsWithObstacles_optimized(obstacleGrid):
    if not obstacleGrid or obstacleGrid[0][0] == 1:
        return 0
    
    m, n = len(obstacleGrid), len(obstacleGrid[0])
    dp = [0] * n
    dp[0] = 1
    
    for i in range(m):
        for j in range(n):
            if obstacleGrid[i][j] == 1:
                dp[j] = 0
            elif j > 0:
                dp[j] += dp[j-1]
    
    return dp[n-1]

# Test
grid = [
    [0, 0, 0],
    [0, 1, 0],
    [0, 0, 0]
]
print(uniquePathsWithObstacles(grid))  # 2
```

**Visualization**:
```
Grid:          DP Table:
0 0 0          1 1 1
0 X 0    →     1 0 1
0 0 0          1 1 2

Paths: 
1. Right → Right → Down → Down
2. Down → Down → Right → Right
```

---

### 3.1.3 Minimum Path Sum

**Problem**: Grid with non-negative numbers. Find path from top-left to bottom-right that minimizes sum. Can only move right or down.

**LeetCode**: #64

#### Analysis

**State**: `dp[i][j]` = minimum path sum to reach cell (i, j)

**Recurrence**: 
```python
dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
```

**Base Cases**:
- `dp[0][0] = grid[0][0]`
- `dp[0][j] = dp[0][j-1] + grid[0][j]` (can only come from left)
- `dp[i][0] = dp[i-1][0] + grid[i][0]` (can only come from top)

```python
# 2D Solution
def minPathSum(grid):
    if not grid or not grid[0]:
        return 0
    
    m, n = len(grid), len(grid[0])
    dp = [[0] * n for _ in range(m)]
    
    # Initialize first cell
    dp[0][0] = grid[0][0]
    
    # Initialize first row
    for j in range(1, n):
        dp[0][j] = dp[0][j-1] + grid[0][j]
    
    # Initialize first column
    for i in range(1, m):
        dp[i][0] = dp[i-1][0] + grid[i][0]
    
    # Fill the table
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
    
    return dp[m-1][n-1]

# Space Optimized (modify in-place if allowed)
def minPathSum_inplace(grid):
    if not grid or not grid[0]:
        return 0
    
    m, n = len(grid), len(grid[0])
    
    # Initialize first row
    for j in range(1, n):
        grid[0][j] += grid[0][j-1]
    
    # Initialize first column
    for i in range(1, m):
        grid[i][0] += grid[i-1][0]
    
    # Fill the grid
    for i in range(1, m):
        for j in range(1, n):
            grid[i][j] += min(grid[i-1][j], grid[i][j-1])
    
    return grid[m-1][n-1]

# Space Optimized (1D array, no modification)
def minPathSum_1d(grid):
    if not grid or not grid[0]:
        return 0
    
    m, n = len(grid), len(grid[0])
    dp = [float('inf')] * n
    dp[0] = 0
    
    for i in range(m):
        dp[0] += grid[i][0]
        for j in range(1, n):
            dp[j] = grid[i][j] + min(dp[j], dp[j-1])
    
    return dp[n-1]

# Test
grid = [
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1]
]
print(minPathSum(grid))  # 7 (path: 1→3→1→1→1)
```

**Visualization**:
```
Grid:          DP Table:
1 3 1          1  4  5
1 5 1    →     2  7  6
4 2 1          6  8  7

Minimum path: 1 → 3 → 1 → 1 → 1 = 7
```

---

### 3.1.4 Dungeon Game (Reverse DP)

**Problem**: Knight starts at top-left, princess at bottom-right. Each cell has value (positive = health gain, negative = damage). Find minimum initial health needed to reach princess (health must always be ≥ 1).

**LeetCode**: #174

#### Analysis

**Key Insight**: Must work BACKWARDS from princess to knight!

**Why?** Because minimum health needed at current cell depends on what happens NEXT, not what happened before.

**State**: `dp[i][j]` = minimum health needed to reach princess starting from (i, j)

**Recurrence**:
```python
# Need enough health to survive current cell and have enough for next step
min_health_needed = min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]
dp[i][j] = max(1, min_health_needed)  # At least 1 health required
```

```python
def calculateMinimumHP(dungeon):
    if not dungeon or not dungeon[0]:
        return 1
    
    m, n = len(dungeon), len(dungeon[0])
    dp = [[float('inf')] * n for _ in range(m)]
    
    # Base case: at princess cell
    dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])
    
    # Initialize last row (can only move right)
    for j in range(n - 2, -1, -1):
        dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])
    
    # Initialize last column (can only move down)
    for i in range(m - 2, -1, -1):
        dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])
    
    # Fill table from bottom-right to top-left
    for i in range(m - 2, -1, -1):
        for j in range(n - 2, -1, -1):
            min_health_needed = min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]
            dp[i][j] = max(1, min_health_needed)
    
    return dp[0][0]

# Test
dungeon = [
    [-2, -3,  3],
    [-5, -10, 1],
    [10, 30, -5]
]
print(calculateMinimumHP(dungeon))  # 7
```

**Visualization**:
```
Dungeon:          DP (min health needed):
-2  -3   3        7   5   2
-5 -10   1   →    6  11   5
10  30  -5        1   1   6

Path: Start with 7 health
(0,0): 7 - 2 = 5
(1,0): 5 - 5 = 0... but need 6 at start!
Work backwards to find minimum starting health = 7
```

**Important Note**: This is a classic example where forward DP doesn't work! Always consider if backward DP is more natural.

---

## 3.2 Matrix Manipulation

### 3.2.1 Maximal Square

**Problem**: Given binary matrix with 0s and 1s, find the largest square containing only 1s and return its area.

**LeetCode**: #221

#### Analysis

**State**: `dp[i][j]` = side length of largest square with bottom-right corner at (i, j)

**Recurrence**: If `matrix[i][j] == '1'`:
```python
dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
```

**Why?** To form a square at (i, j), we need:
- A square at (i-1, j) (above)
- A square at (i, j-1) (left)
- A square at (i-1, j-1) (diagonal)
Take minimum and add 1!

```python
def maximalSquare(matrix):
    if not matrix or not matrix[0]:
        return 0
    
    m, n = len(matrix), len(matrix[0])
    dp = [[0] * n for _ in range(m)]
    max_side = 0
    
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == '1':
                if i == 0 or j == 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                max_side = max(max_side, dp[i][j])
    
    return max_side * max_side

# Space Optimized
def maximalSquare_optimized(matrix):
    if not matrix or not matrix[0]:
        return 0
    
    m, n = len(matrix), len(matrix[0])
    dp = [0] * n
    max_side = 0
    prev = 0  # This stores dp[i-1][j-1]
    
    for i in range(m):
        for j in range(n):
            temp = dp[j]  # Save current value before overwriting
            
            if matrix[i][j] == '1':
                if i == 0 or j == 0:
                    dp[j] = 1
                else:
                    dp[j] = min(dp[j], dp[j-1], prev) + 1
                max_side = max(max_side, dp[j])
            else:
                dp[j] = 0
            
            prev = temp
    
    return max_side * max_side

# Test
matrix = [
    ['1', '0', '1', '0', '0'],
    ['1', '0', '1', '1', '1'],
    ['1', '1', '1', '1', '1'],
    ['1', '0', '0', '1', '0']
]
print(maximalSquare(matrix))  # 4 (2x2 square)
```

**Visualization**:
```
Matrix:           DP (side lengths):
1 0 1 0 0         1 0 1 0 0
1 0 1 1 1    →    1 0 1 1 1
1 1 1 1 1         1 1 1 2 2
1 0 0 1 0         1 0 0 1 0

Largest square has side length 2, area = 4
```

---

### 3.2.2 Maximal Rectangle

**Problem**: Given binary matrix, find the largest rectangle containing only 1s and return its area.

**LeetCode**: #85

#### Analysis

**Key Insight**: This is actually **multiple Maximal Histogram problems stacked!**

For each row, treat it as the base of a histogram where height = consecutive 1s above.

**Prerequisites**: Understand "Largest Rectangle in Histogram" first!

#### Largest Rectangle in Histogram (Helper Problem)

```python
def largestRectangleArea(heights):
    """
    Find largest rectangle in histogram.
    Key: For each bar, find nearest smaller bar on left and right.
    Use monotonic stack!
    """
    stack = []  # Store indices
    max_area = 0
    heights.append(0)  # Sentinel to pop all remaining
    
    for i in range(len(heights)):
        # While current height is smaller than stack top
        while stack and heights[i] < heights[stack[-1]]:
            h = heights[stack.pop()]
            w = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, h * w)
        stack.append(i)
    
    return max_area

# Test
print(largestRectangleArea([2, 1, 5, 6, 2, 3]))  # 10
```

#### Now Maximal Rectangle

```python
def maximalRectangle(matrix):
    if not matrix or not matrix[0]:
        return 0
    
    m, n = len(matrix), len(matrix[0])
    heights = [0] * n
    max_area = 0
    
    for i in range(m):
        for j in range(n):
            # Update heights
            if matrix[i][j] == '1':
                heights[j] += 1
            else:
                heights[j] = 0
        
        # Calculate max rectangle for this row as base
        max_area = max(max_area, largestRectangleArea(heights[:]))
    
    return max_area

# Test
matrix = [
    ['1', '0', '1', '0', '0'],
    ['1', '0', '1', '1', '1'],
    ['1', '1', '1', '1', '1'],
    ['1', '0', '0', '1', '0']
]
print(maximalRectangle(matrix))  # 6
```

**Visualization**:
```
Matrix:
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

Heights array at each row:
Row 0: [1, 0, 1, 0, 0]
Row 1: [2, 0, 2, 1, 1]
Row 2: [3, 1, 3, 2, 2]  ← Max rectangle area = 6 (width 3, height 2)
Row 3: [4, 0, 0, 3, 0]
```

**Complexity**:
- Time: O(m × n) for building heights + O(m × n) for histogram = O(m × n)
- Space: O(n) for heights array

---

## 3.3 Optimization Techniques

### 3.3.1 Space Optimization: O(m×n) → O(n)

**General Pattern**: When `dp[i][j]` only depends on current row and previous row, use 1D array.

**Template**:
```python
# Instead of:
dp = [[0] * n for _ in range(m)]
for i in range(m):
    for j in range(n):
        dp[i][j] = f(dp[i-1][j], dp[i][j-1], ...)

# Use:
dp = [0] * n
for i in range(m):
    for j in range(n):
        dp[j] = f(dp[j], dp[j-1], ...)  # dp[j] is "previous row"
```

**Example: Unique Paths**
```python
def uniquePaths_optimized(m, n):
    dp = [1] * n  # First row all 1s
    
    for i in range(1, m):
        for j in range(1, n):
            dp[j] += dp[j-1]
            # dp[j] on right = old dp[i-1][j] + new dp[i][j-1]
    
    return dp[n-1]
```

### 3.3.2 In-Place Modification

If the problem allows modifying the input, save space!

```python
def minPathSum_inplace(grid):
    m, n = len(grid), len(grid[0])
    
    # Modify first row
    for j in range(1, n):
        grid[0][j] += grid[0][j-1]
    
    # Modify first column
    for i in range(1, m):
        grid[i][0] += grid[i-1][0]
    
    # Modify rest
    for i in range(1, m):
        for j in range(1, n):
            grid[i][j] += min(grid[i-1][j], grid[i][j-1])
    
    return grid[m-1][n-1]
```

**Trade-off**: Saves space but destroys input. Only use if allowed!

### 3.3.3 Diagonal Processing

Some problems allow processing diagonally for better cache locality.

```python
# Process diagonals instead of rows
def processGrid_diagonal(grid):
    m, n = len(grid), len(grid[0])
    
    # Process each diagonal
    for d in range(m + n - 1):
        for i in range(max(0, d - n + 1), min(m, d + 1)):
            j = d - i
            # Process grid[i][j]
```

---

## Common Patterns and Important Notes

### Pattern 1: Path Problems
- **State**: `dp[i][j]` = answer to reach cell (i, j)
- **Recurrence**: Usually `dp[i][j] = f(dp[i-1][j], dp[i][j-1])`
- **Direction**: Usually top-down or left-right (sometimes reverse!)

### Pattern 2: Matrix Properties
- **State**: `dp[i][j]` = property of submatrix ending at (i, j)
- **Recurrence**: Often involves `min()` or `max()` of neighbors
- **Example**: Maximal Square

### Pattern 3: Stacked Problems
- **Key Insight**: Break 2D problem into multiple 1D problems
- **Example**: Maximal Rectangle = Multiple Histograms

### Critical Notes

#### Note 1: Forward vs Backward DP
```python
# Most problems: Forward (top-left to bottom-right)
for i in range(m):
    for j in range(n):
        dp[i][j] = f(dp[i-1][j], dp[i][j-1])

# Some problems: Backward (bottom-right to top-left)
for i in range(m-1, -1, -1):
    for j in range(n-1, -1, -1):
        dp[i][j] = f(dp[i+1][j], dp[i][j+1])
```

**Rule**: Use backward DP when current decision depends on future outcomes (e.g., Dungeon Game)

#### Note 2: Diagonal Access
When you need `dp[i-1][j-1]` in space-optimized version:
```python
prev = 0  # Store dp[i-1][j-1]
for j in range(n):
    temp = dp[j]  # Save before overwriting
    dp[j] = f(dp[j], dp[j-1], prev)
    prev = temp  # Update prev for next iteration
```

#### Note 3: Initialization
```python
# First row and column often need special handling
dp[0][0] = base_value

# First row
for j in range(1, n):
    dp[0][j] = initialize_first_row(j)

# First column
for i in range(1, m):
    dp[i][0] = initialize_first_col(i)
```

---

## Practice Problems Summary

### Beginner Level
1. Unique Paths (#62)
2. Unique Paths II (#63)
3. Minimum Path Sum (#64)

### Intermediate Level
4. Maximal Square (#221)
5. Triangle (#120)
6. Minimum Falling Path Sum (#931)

### Advanced Level
7. Dungeon Game (#174)
8. Maximal Rectangle (#85)
9. Largest Rectangle in Histogram (#84)
10. Cherry Pickup (#741)

---

## Key Takeaways

1. **2D Grid DP** uses state `dp[i][j]` for cell (i, j)
2. **Path problems**: Usually `dp[i][j] = f(dp[i-1][j], dp[i][j-1])`
3. **Space optimization**: O(m×n) → O(n) by keeping only current and previous row
4. **In-place modification** can reduce space to O(1)
5. **Backward DP** when future outcomes affect current decisions
6. **Stacked problems**: Break 2D into multiple 1D problems
7. **Edge cases**: First row and column need special initialization
8. **Diagonal access**: Store previous diagonal value in variable

Master these 2D grid patterns, and you'll handle matrix DP problems with confidence!