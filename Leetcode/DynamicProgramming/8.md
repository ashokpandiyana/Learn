# Chapter 8: Pattern 7 - State Machine DP

## Overview

State Machine DP is used when the problem has **distinct states** and you transition between them based on actions. Each state has different rules and constraints.

**Pattern Recognition**:
- Problem has multiple "modes" or "phases"
- Actions have different effects in different states
- Constraints on when you can change states
- Need to track current state along with position

**Key Concept**: Think of the problem as a finite state machine where transitions have costs/values.

---

## 8.1 Stock Trading Problems

Stock problems are the **classic examples** of state machine DP. Let's build up from simple to complex.

### 8.1.1 Best Time to Buy and Sell Stock (Single Transaction)

**Problem**: One buy and one sell. Maximize profit.

**LeetCode**: #121

#### Analysis

**State**: Not really state machine, but foundation
- Track minimum price seen so far
- Track maximum profit

```python
def maxProfit(prices):
    if not prices:
        return 0
    
    min_price = prices[0]
    max_profit = 0
    
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    
    return max_profit

# DP interpretation
def maxProfit_dp(prices):
    if not prices:
        return 0
    
    # hold[i] = max profit on day i if holding stock
    # sold[i] = max profit on day i if not holding stock
    hold = -prices[0]  # Buy on day 0
    sold = 0
    
    for i in range(1, len(prices)):
        # Can only buy once, so use 0 - prices[i]
        hold = max(hold, -prices[i])
        sold = max(sold, hold + prices[i])
    
    return sold

# Test
print(maxProfit([7, 1, 5, 3, 6, 4]))  # 5 (buy at 1, sell at 6)
print(maxProfit([7, 6, 4, 3, 1]))     # 0 (no profit possible)
```

**Complexity**: O(n) time, O(1) space

---

### 8.1.2 Best Time to Buy and Sell Stock II (Unlimited Transactions)

**Problem**: Can do unlimited buy-sell transactions. Maximize profit.

**LeetCode**: #122

#### Analysis

**States**:
- **hold**: Currently holding stock
- **sold**: Currently not holding stock

**Transitions**:
- hold → sold: Sell stock
- sold → hold: Buy stock

**State Machine Diagram**:
```
    buy        sell
sold ←→ hold
  ↓          ↓
update     update
profit     profit
```

```python
def maxProfit(prices):
    if not prices:
        return 0
    
    # State definitions:
    # hold = max profit while holding stock
    # sold = max profit while not holding stock
    
    hold = -prices[0]  # Buy on day 0
    sold = 0           # Don't buy on day 0
    
    for i in range(1, len(prices)):
        # To hold: either keep holding or buy today
        new_hold = max(hold, sold - prices[i])
        
        # To be sold: either stay sold or sell today
        new_sold = max(sold, hold + prices[i])
        
        hold, sold = new_hold, new_sold
    
    return sold

# Greedy approach (simpler for this problem)
def maxProfit_greedy(prices):
    """
    Key insight: Capture all upward movements!
    """
    profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i-1]:
            profit += prices[i] - prices[i-1]
    return profit

# Test
print(maxProfit([7, 1, 5, 3, 6, 4]))  # 7 (buy 1 sell 5, buy 3 sell 6)
print(maxProfit([1, 2, 3, 4, 5]))     # 4 (buy 1 sell 5)
```

**Complexity**: O(n) time, O(1) space

---

### 8.1.3 Best Time to Buy and Sell Stock III (At Most 2 Transactions)

**Problem**: At most 2 complete transactions. Maximize profit.

**LeetCode**: #123

#### Analysis

**States** (need to track transaction count):
- **hold1**: Holding after 1st buy
- **sold1**: After 1st sell
- **hold2**: Holding after 2nd buy
- **sold2**: After 2nd sell

**State Machine**:
```
      buy1      sell1     buy2      sell2
start → hold1 → sold1 → hold2 → sold2
```

```python
def maxProfit(prices):
    if not prices:
        return 0
    
    # Initialize states
    hold1 = -prices[0]  # After 1st buy
    sold1 = 0           # After 1st sell
    hold2 = -prices[0]  # After 2nd buy (could buy on day 0)
    sold2 = 0           # After 2nd sell
    
    for i in range(1, len(prices)):
        # Process in reverse order to avoid using updated values
        sold2 = max(sold2, hold2 + prices[i])
        hold2 = max(hold2, sold1 - prices[i])
        sold1 = max(sold1, hold1 + prices[i])
        hold1 = max(hold1, -prices[i])
    
    return sold2

# Alternative: 2D DP approach
def maxProfit_2d(prices):
    if not prices:
        return 0
    
    n = len(prices)
    k = 2  # At most 2 transactions
    
    # dp[i][j] = max profit on day i with at most j transactions
    # We need to track if we're holding or not
    # buy[i][j] = max profit on day i after buying in transaction j
    # sell[i][j] = max profit on day i after selling in transaction j
    
    buy = [[-float('inf')] * (k + 1) for _ in range(n)]
    sell = [[0] * (k + 1) for _ in range(n)]
    
    for i in range(n):
        for j in range(1, k + 1):
            if i == 0:
                buy[i][j] = -prices[i]
                sell[i][j] = 0
            else:
                buy[i][j] = max(buy[i-1][j], sell[i-1][j-1] - prices[i])
                sell[i][j] = max(sell[i-1][j], buy[i-1][j] + prices[i])
    
    return sell[n-1][k]

# Test
print(maxProfit([3, 3, 5, 0, 0, 3, 1, 4]))  # 6 (buy 0, sell 3, buy 1, sell 4)
print(maxProfit([1, 2, 3, 4, 5]))           # 4 (buy 1, sell 5)
```

**Visualization for [3, 3, 5, 0, 0, 3, 1, 4]**:
```
Day:   0  1  2  3  4  5  6  7
Price: 3  3  5  0  0  3  1  4

Transaction 1: Buy at 0, Sell at 2 (profit = 2)
Transaction 2: Buy at 3, Sell at 7 (profit = 4)
Total: 6
```

**Complexity**: O(n) time, O(1) space for state machine, O(n×k) for 2D

---

### 8.1.4 Best Time to Buy and Sell Stock IV (At Most K Transactions)

**Problem**: At most k transactions. Maximize profit.

**LeetCode**: #188

#### Analysis

**Generalization** of the previous problem!

**Special Case**: If k ≥ n/2, same as unlimited transactions (every up can be captured)

```python
def maxProfit(k, prices):
    if not prices or k == 0:
        return 0
    
    n = len(prices)
    
    # Optimization: k >= n/2 means unlimited transactions
    if k >= n // 2:
        return maxProfit_unlimited(prices)
    
    # buy[j] = max profit after buying in transaction j
    # sell[j] = max profit after selling in transaction j
    buy = [-float('inf')] * (k + 1)
    sell = [0] * (k + 1)
    
    for price in prices:
        # Process transactions in reverse to avoid using updated values
        for j in range(k, 0, -1):
            sell[j] = max(sell[j], buy[j] + price)
            buy[j] = max(buy[j], sell[j-1] - price)
    
    return sell[k]

def maxProfit_unlimited(prices):
    """Helper for when k is large"""
    profit = 0
    for i in range(1, len(prices)):
        profit += max(0, prices[i] - prices[i-1])
    return profit

# Alternative: 2D DP
def maxProfit_2d(k, prices):
    if not prices or k == 0:
        return 0
    
    n = len(prices)
    if k >= n // 2:
        return maxProfit_unlimited(prices)
    
    # dp[i][j][0] = max profit on day i, j transactions, not holding
    # dp[i][j][1] = max profit on day i, j transactions, holding
    
    # Space optimized version
    buy = [-prices[0]] * (k + 1)
    sell = [0] * (k + 1)
    
    for i in range(1, n):
        for j in range(k, 0, -1):
            sell[j] = max(sell[j], buy[j] + prices[i])
            buy[j] = max(buy[j], sell[j-1] - prices[i])
    
    return sell[k]

# Test
print(maxProfit(2, [2, 4, 1]))              # 2 (buy 2, sell 4)
print(maxProfit(2, [3, 2, 6, 5, 0, 3]))     # 7 (buy 2 sell 6, buy 0 sell 3)
```

**Complexity**: O(n×k) time, O(k) space

---

### 8.1.5 Best Time to Buy and Sell Stock with Cooldown

**Problem**: After selling, must wait 1 day before buying again.

**LeetCode**: #309

#### Analysis

**States**:
- **hold**: Currently holding stock
- **sold**: Just sold stock (in cooldown)
- **rest**: Not holding, not in cooldown

**State Machine**:
```
       buy
rest ------→ hold
  ↑           ↓
  |          sell
  |           ↓
  ←------  sold
  cooldown
```

```python
def maxProfit(prices):
    if not prices:
        return 0
    
    # State definitions
    hold = -prices[0]  # Holding stock
    sold = 0           # Just sold (cooldown next day)
    rest = 0           # Resting (can buy)
    
    for i in range(1, len(prices)):
        # New states (use temp to avoid overwriting)
        new_hold = max(hold, rest - prices[i])  # Keep holding or buy
        new_sold = hold + prices[i]             # Sell stock
        new_rest = max(rest, sold)              # Rest or finish cooldown
        
        hold, sold, rest = new_hold, new_sold, new_rest
    
    return max(sold, rest)

# Alternative: More explicit state tracking
def maxProfit_v2(prices):
    if not prices:
        return 0
    
    n = len(prices)
    
    # dp[i][0] = max profit on day i, currently resting
    # dp[i][1] = max profit on day i, currently holding
    # dp[i][2] = max profit on day i, just sold (cooldown)
    
    if n == 1:
        return 0
    
    dp = [[0] * 3 for _ in range(n)]
    dp[0][0] = 0          # Rest on day 0
    dp[0][1] = -prices[0] # Buy on day 0
    dp[0][2] = 0          # Can't sell on day 0
    
    for i in range(1, n):
        # Rest: was resting or finished cooldown
        dp[i][0] = max(dp[i-1][0], dp[i-1][2])
        
        # Hold: was holding or buy today
        dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
        
        # Sold: must have been holding
        dp[i][2] = dp[i-1][1] + prices[i]
    
    return max(dp[n-1][0], dp[n-1][2])

# Test
print(maxProfit([1, 2, 3, 0, 2]))  # 3 (buy 1, sell 2, cooldown, buy 0, sell 2)
```

**Visualization**:
```
Day:   0  1  2  3  4
Price: 1  2  3  0  2

Strategy:
Day 0: Buy at 1
Day 1: Sell at 2 (profit = 1)
Day 2: Cooldown
Day 3: Buy at 0
Day 4: Sell at 2 (profit = 2)
Total: 3
```

**Complexity**: O(n) time, O(1) space

---

### 8.1.6 Best Time to Buy and Sell Stock with Transaction Fee

**Problem**: Each transaction has a fixed fee. Maximize profit.

**LeetCode**: #714

#### Analysis

**States**:
- **hold**: Currently holding stock
- **sold**: Currently not holding stock

Similar to unlimited transactions, but subtract fee!

```python
def maxProfit(prices, fee):
    if not prices:
        return 0
    
    # hold = max profit while holding stock
    # sold = max profit while not holding stock
    
    hold = -prices[0]  # Buy on day 0
    sold = 0
    
    for i in range(1, len(prices)):
        # To hold: keep holding or buy today
        new_hold = max(hold, sold - prices[i])
        
        # To be sold: stay sold or sell today (pay fee)
        new_sold = max(sold, hold + prices[i] - fee)
        
        hold, sold = new_hold, new_sold
    
    return sold

# Alternative: Pay fee when buying
def maxProfit_v2(prices, fee):
    if not prices:
        return 0
    
    hold = -prices[0] - fee  # Buy and pay fee
    sold = 0
    
    for i in range(1, len(prices)):
        new_hold = max(hold, sold - prices[i] - fee)
        new_sold = max(sold, hold + prices[i])
        hold, sold = new_hold, new_sold
    
    return sold

# Test
print(maxProfit([1, 3, 2, 8, 4, 9], 2))  # 8 (buy 1, sell 8, buy 4, sell 9)
```

**Complexity**: O(n) time, O(1) space

---

## 8.2 General State Machine Pattern

### 8.2.1 Template for State Machine DP

```python
def state_machine_dp(data):
    # Define states
    state1 = initial_value1
    state2 = initial_value2
    # ... more states
    
    for item in data:
        # Calculate new state values
        # IMPORTANT: Use temp variables to avoid overwriting
        new_state1 = transition_function1(state1, state2, ..., item)
        new_state2 = transition_function2(state1, state2, ..., item)
        
        # Update states
        state1, state2 = new_state1, new_state2
    
    return final_state
```

### 8.2.2 Drawing State Diagrams

**Steps**:
1. Identify all possible states
2. Draw transitions between states
3. Label transitions with conditions/costs
4. Identify initial and final states

**Example: Stock with Cooldown**:
```
Initial → rest
          ↓ buy
         hold
          ↓ sell
         sold (cooldown)
          ↓ wait
         rest ← (loop)
```

---

## 8.3 More State Machine Problems

### 8.3.1 Paint House

**Problem**: n houses in a row. Each can be painted red, blue, or green. Adjacent houses can't have same color. Each house-color combination has a cost. Minimize total cost.

**LeetCode**: #256

#### Analysis

**States** (3 states for 3 colors):
- **red**: Last house painted red
- **blue**: Last house painted blue
- **green**: Last house painted green

```python
def minCost(costs):
    if not costs:
        return 0
    
    # States: cost if last house is painted red/blue/green
    red = costs[0][0]
    blue = costs[0][1]
    green = costs[0][2]
    
    for i in range(1, len(costs)):
        # Paint house i red: previous must be blue or green
        new_red = costs[i][0] + min(blue, green)
        
        # Paint house i blue: previous must be red or green
        new_blue = costs[i][1] + min(red, green)
        
        # Paint house i green: previous must be red or blue
        new_green = costs[i][2] + min(red, blue)
        
        red, blue, green = new_red, new_blue, new_green
    
    return min(red, blue, green)

# Test
costs = [[17, 2, 17], [16, 16, 5], [14, 3, 19]]
print(minCost(costs))  # 10 (blue, green, blue)
```

**State Diagram**:
```
       red ←→ blue
        ↓ ↗  ↘ ↓
        green
```

**Complexity**: O(n) time, O(1) space

---

### 8.3.2 Paint House II (K Colors)

**Problem**: Same as Paint House, but k colors instead of 3.

**LeetCode**: #265

#### Analysis

**Optimization**: Track minimum and second minimum to avoid O(k²) per house.

```python
def minCostII(costs):
    if not costs:
        return 0
    
    n, k = len(costs), len(costs[0])
    
    # dp[i] = min cost to paint houses up to current, ending with color i
    dp = costs[0][:]
    
    for i in range(1, n):
        # Find minimum and second minimum from previous row
        min1 = min2 = float('inf')
        min1_idx = -1
        
        for j in range(k):
            if dp[j] < min1:
                min2 = min1
                min1 = dp[j]
                min1_idx = j
            elif dp[j] < min2:
                min2 = dp[j]
        
        # Update dp for current house
        new_dp = [0] * k
        for j in range(k):
            # If this color was minimum, use second minimum
            if j == min1_idx:
                new_dp[j] = costs[i][j] + min2
            else:
                new_dp[j] = costs[i][j] + min1
        
        dp = new_dp
    
    return min(dp)

# Test
costs = [[1, 5, 3], [2, 9, 4]]
print(minCostII(costs))  # 5 (color 0 then color 2)
```

**Complexity**: O(n×k) time, O(k) space

---

### 8.3.3 Delete and Earn (Alternative View)

**Problem**: Delete number to earn points, but must delete all instances of num-1 and num+1.

**LeetCode**: #740

We solved this as House Robber variant, but it's also a state machine!

**States**:
- **take**: Take current number
- **skip**: Skip current number

```python
def deleteAndEarn(nums):
    if not nums:
        return 0
    
    # Count points for each number
    max_num = max(nums)
    points = [0] * (max_num + 1)
    for num in nums:
        points[num] += num
    
    # State machine: take or skip
    take = 0  # Max points if we take current number
    skip = 0  # Max points if we skip current number
    
    for point in points:
        # If we take current, we must have skipped previous
        new_take = skip + point
        # If we skip current, take max of previous states
        new_skip = max(take, skip)
        
        take, skip = new_take, new_skip
    
    return max(take, skip)
```

---

## 8.4 Advanced State Machine Concepts

### 8.4.1 Multiple State Variables

Some problems need **multiple independent state variables**.

**Example**: Track both "transaction count" and "holding status"

```python
# Stock IV problem - 2 state variables
for i in range(n):
    for j in range(k):  # Transaction count
        for status in [HOLD, SOLD]:  # Holding status
            # Update state
            pass
```

### 8.4.2 State Compression

When states have patterns, can sometimes compress:

```python
# Instead of tracking all k transactions separately
# Track only necessary information
# Example: min1, min2 in Paint House II
```

### 8.4.3 Identifying States from Constraints

**Method**:
1. List all constraints in problem
2. Each constraint often corresponds to a state
3. Draw transitions between states
4. Verify all transitions are valid

**Example: Stock with Cooldown**:
- Constraint 1: Can be holding or not holding → 2 states
- Constraint 2: After selling, must cooldown → 3rd state
- Result: 3 states (hold, sold, rest)

---

## 8.5 Common Patterns

### Pattern 1: Two States (Binary Choice)

```python
# Common in include/exclude problems
state0 = initial_value
state1 = initial_value

for item in items:
    new_state0 = transition0(state0, state1)
    new_state1 = transition1(state0, state1)
    state0, state1 = new_state0, new_state1
```

### Pattern 2: Chain of States

```python
# Common in sequential processes
# State A → State B → State C → ...
stateA = initialA
stateB = initialB
stateC = initialC

for item in items:
    # Process in reverse order to avoid using updated values
    new_stateC = transitionC(stateB, stateC, item)
    new_stateB = transitionB(stateA, stateB, item)
    new_stateA = transitionA(stateA, item)
    
    stateA, stateB, stateC = new_stateA, new_stateB, new_stateC
```

### Pattern 3: Cyclic States

```python
# Common when states can transition to multiple other states
# Example: Paint House (any color to any other color)
states = [initial] * k

for item in items:
    new_states = [0] * k
    for i in range(k):
        new_states[i] = min/max(
            states[j] + cost(j, i, item) for j in range(k) if j != i
        )
    states = new_states
```

---

## 8.6 Debugging State Machines

### Technique 1: Print State Values

```python
for i, item in enumerate(items):
    # ... state updates ...
    print(f"After item {i}: hold={hold}, sold={sold}")
```

### Technique 2: Verify Invariants

```python
# Example: One state should always dominate
assert hold <= sold  # Can't be better to hold than to sell (if no cooldown)
```

### Technique 3: Test Transitions

```python
# Manually verify each transition makes sense
# Example: Can only sell if holding
if not was_holding:
    assert can_sell == False
```

---

## Practice Problems Summary

### Beginner
1. Best Time to Buy and Sell Stock (#121)
2. Best Time to Buy and Sell Stock II (#122)
3. Paint House (#256)

### Intermediate
4. Best Time to Buy and Sell Stock with Cooldown (#309)
5. Best Time to Buy and Sell Stock with Transaction Fee (#714)
6. Paint House II (#265)

### Advanced
7. Best Time to Buy and Sell Stock III (#123)
8. Best Time to Buy and Sell Stock IV (#188)
9. Maximum Profit in Job Scheduling (#1235)

---

## Key Takeaways

1. **State Machine = Multiple modes with transitions**
2. **Draw diagrams** to visualize states and transitions
3. **Use temp variables** when updating multiple states
4. **Process in reverse order** for dependent states (like stock transactions)
5. **Identify states from constraints** in the problem
6. **O(1) space** possible for most state machines with constant states
7. **Stock problems** are the classic example - master these!
8. **Think about valid transitions** - not all states can reach all others

State Machine DP is powerful for problems with modes, phases, or status tracking!