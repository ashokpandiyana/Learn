# Chapter 16: Code Templates & Best Practices

## Overview

This chapter provides production-ready templates and coding best practices for each DP pattern. These templates will accelerate your problem-solving and reduce bugs.

---

## 16.1 General DP Templates

### 16.1.1 Memoization Template (Top-Down)

```python
from functools import cache

def dp_memoization_template(n, *args):
    """
    Generic top-down DP template
    
    Args:
        n: problem size
        *args: additional parameters
    """
    
    @cache  # Or @lru_cache(maxsize=None)
    def dp(state1, state2, *other_states):
        """
        Define what each state represents clearly
        
        Args:
            state1: description (e.g., current position)
            state2: description (e.g., items used)
            other_states: any additional state variables
        
        Returns:
            Optimal value for this state
        """
        
        # Base case(s)
        if base_condition:
            return base_value
        
        # Impossible/invalid state
        if invalid_condition:
            return float('inf')  # for minimization
            # return float('-inf')  # for maximization
            # return 0  # for counting
            # return False  # for boolean
        
        # Recurrence relation
        result = initial_value
        
        # Try all possible transitions
        for choice in possible_choices:
            next_states = compute_next_states(state1, state2, choice)
            candidate = cost(choice) + dp(*next_states)
            result = optimize(result, candidate)  # min/max/sum
        
        return result
    
    # Call with initial state
    return dp(initial_state1, initial_state2, ...)

# Example: Climbing Stairs
def climbStairs(n):
    @cache
    def dp(step):
        # Base cases
        if step == 0:
            return 1
        if step < 0:
            return 0
        
        # Recurrence
        return dp(step - 1) + dp(step - 2)
    
    return dp(n)
```

---

### 16.1.2 Tabulation Template (Bottom-Up)

```python
def dp_tabulation_template(n, *args):
    """
    Generic bottom-up DP template
    
    Args:
        n: problem size
        *args: additional parameters
    """
    
    # Initialize DP table
    # 1D: dp = [initial_value] * (n + 1)
    # 2D: dp = [[initial_value] * cols for _ in range(rows)]
    dp = initialize_dp_table(n)
    
    # Set base cases
    dp[base_index] = base_value
    
    # Fill table in correct order
    for i in iteration_range:
        for j in nested_range:  # if needed
            # Skip invalid states
            if is_invalid(i, j):
                continue
            
            # Compute recurrence
            dp[i][j] = compute_from_previous_states(dp, i, j)
    
    # Return answer
    return dp[final_index]

# Example: Coin Change
def coinChange(coins, amount):
    # Initialize
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # Base case
    
    # Fill table
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    # Return result
    return dp[amount] if dp[amount] != float('inf') else -1
```

---

### 16.1.3 Space Optimized Template

```python
def dp_space_optimized_template(n):
    """
    Space optimization when current state depends on limited previous states
    """
    
    # For dp[i] depending on dp[i-1], dp[i-2]
    if depends_on_last_two:
        prev2 = base_value_0
        prev1 = base_value_1
        
        for i in range(2, n + 1):
            curr = compute(prev1, prev2)
            prev2, prev1 = prev1, curr
        
        return prev1
    
    # For 2D when row i depends only on row i-1
    if two_d_to_one_d:
        dp = [0] * cols
        
        for i in range(rows):
            new_dp = [0] * cols
            for j in range(cols):
                new_dp[j] = compute(dp, i, j)
            dp = new_dp
        
        return dp[target]

# Example: Fibonacci
def fib(n):
    if n <= 1:
        return n
    
    prev2, prev1 = 0, 1
    for i in range(2, n + 1):
        curr = prev1 + prev2
        prev2, prev1 = prev1, curr
    
    return prev1
```

---

## 16.2 Pattern-Specific Templates

### 16.2.1 Linear DP Template

```python
def linear_dp_template(nums):
    """
    For 1D array problems with sequential decisions
    """
    n = len(nums)
    
    # Edge cases
    if not nums:
        return 0
    if n == 1:
        return nums[0]
    
    # Initialize
    dp = [0] * n
    dp[0] = base_case(nums[0])
    
    # Fill table
    for i in range(1, n):
        # Option 1: Include current element
        include = nums[i] + dp[i - 2] if i >= 2 else nums[i]
        
        # Option 2: Exclude current element
        exclude = dp[i - 1]
        
        dp[i] = max(include, exclude)  # or min, or sum
    
    return dp[n - 1]

# Specific: House Robber
def rob(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    
    prev2, prev1 = 0, 0
    
    for num in nums:
        curr = max(prev1, prev2 + num)
        prev2, prev1 = prev1, curr
    
    return prev1
```

---

### 16.2.2 Grid DP Template

```python
def grid_dp_template(grid):
    """
    For 2D grid problems (paths, optimization)
    """
    if not grid or not grid[0]:
        return 0
    
    m, n = len(grid), len(grid[0])
    
    # Initialize
    dp = [[0] * n for _ in range(m)]
    dp[0][0] = grid[0][0]
    
    # First row (can only come from left)
    for j in range(1, n):
        dp[0][j] = dp[0][j - 1] + grid[0][j]
    
    # First column (can only come from top)
    for i in range(1, m):
        dp[i][0] = dp[i - 1][0] + grid[i][0]
    
    # Fill rest of table
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])
    
    return dp[m - 1][n - 1]

# Space Optimized Version
def grid_dp_optimized(grid):
    m, n = len(grid), len(grid[0])
    dp = [0] * n
    
    # Initialize first row
    dp[0] = grid[0][0]
    for j in range(1, n):
        dp[j] = dp[j - 1] + grid[0][j]
    
    # Process remaining rows
    for i in range(1, m):
        dp[0] += grid[i][0]  # First column
        for j in range(1, n):
            dp[j] = grid[i][j] + min(dp[j], dp[j - 1])
    
    return dp[n - 1]
```

---

### 16.2.3 Subsequence DP Template (LCS Family)

```python
def lcs_template(text1, text2):
    """
    Template for Longest Common Subsequence problems
    """
    m, n = len(text1), len(text2)
    
    # Initialize
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Fill table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                # Characters match
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                # Characters don't match
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    
    return dp[m][n]

# With path reconstruction
def lcs_with_path(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Fill table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    
    # Reconstruct LCS
    lcs = []
    i, j = m, n
    while i > 0 and j > 0:
        if text1[i - 1] == text2[j - 1]:
            lcs.append(text1[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1
    
    return ''.join(reversed(lcs)), dp[m][n]
```

---

### 16.2.4 Knapsack Template

```python
def knapsack_01_template(weights, values, capacity):
    """
    0/1 Knapsack - each item used at most once
    """
    n = len(weights)
    
    # 2D version
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            # Option 1: Don't take item i-1
            dp[i][w] = dp[i - 1][w]
            
            # Option 2: Take item i-1 (if fits)
            if weights[i - 1] <= w:
                dp[i][w] = max(
                    dp[i][w],
                    dp[i - 1][w - weights[i - 1]] + values[i - 1]
                )
    
    return dp[n][capacity]

def knapsack_01_optimized(weights, values, capacity):
    """
    Space optimized - O(capacity) space
    """
    dp = [0] * (capacity + 1)
    
    for i in range(len(weights)):
        # MUST iterate backwards for 0/1 knapsack
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    
    return dp[capacity]

def knapsack_unbounded(weights, values, capacity):
    """
    Unbounded Knapsack - unlimited items
    """
    dp = [0] * (capacity + 1)
    
    for i in range(len(weights)):
        # Iterate FORWARDS for unbounded
        for w in range(weights[i], capacity + 1):
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    
    return dp[capacity]
```

---

### 16.2.5 Interval DP Template

```python
def interval_dp_template(arr):
    """
    For problems on subarrays/intervals
    """
    n = len(arr)
    
    # Initialize
    dp = [[0] * n for _ in range(n)]
    
    # Base case: single elements
    for i in range(n):
        dp[i][i] = base_value(arr[i])
    
    # Fill by increasing length
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            
            # Initialize with worst case
            dp[i][j] = float('inf')  # or float('-inf')
            
            # Try all split points
            for k in range(i, j):
                cost = dp[i][k] + dp[k + 1][j] + merge_cost(i, k, j)
                dp[i][j] = min(dp[i][j], cost)
    
    return dp[0][n - 1]

# Specific: Matrix Chain Multiplication
def matrix_chain_multiplication(dims):
    n = len(dims) - 1
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    
    for length in range(2, n + 1):
        for i in range(1, n - length + 2):
            j = i + length - 1
            dp[i][j] = float('inf')
            
            for k in range(i, j):
                cost = (dp[i][k] + dp[k + 1][j] + 
                       dims[i - 1] * dims[k] * dims[j])
                dp[i][j] = min(dp[i][j], cost)
    
    return dp[1][n]
```

---

### 16.2.6 Bitmask DP Template

```python
def bitmask_dp_template(n, data):
    """
    For subset/permutation problems with small n (â‰¤ 20)
    """
    # Initialize
    dp = [initial_value] * (1 << n)
    dp[0] = base_value
    
    # Process all subsets
    for mask in range(1 << n):
        if dp[mask] == initial_value:
            continue
        
        # Try adding each element not in mask
        for i in range(n):
            if not (mask & (1 << i)):
                new_mask = mask | (1 << i)
                dp[new_mask] = optimize(
                    dp[new_mask],
                    dp[mask] + cost(i, mask)
                )
    
    return dp[(1 << n) - 1]

# Specific: TSP
def tsp(dist):
    n = len(dist)
    dp = [[float('inf')] * n for _ in range(1 << n)]
    dp[1][0] = 0  # Start at city 0
    
    for mask in range(1 << n):
        for i in range(n):
            if not (mask & (1 << i)):
                continue
            
            for j in range(n):
                if mask & (1 << j):
                    continue
                
                new_mask = mask | (1 << j)
                dp[new_mask][j] = min(
                    dp[new_mask][j],
                    dp[mask][i] + dist[i][j]
                )
    
    # Return to start
    full_mask = (1 << n) - 1
    return min(dp[full_mask][i] + dist[i][0] for i in range(n))
```

---

## 16.3 Best Practices

### 16.3.1 Naming Conventions

```python
# GOOD: Clear, descriptive names
def maxProfit(prices):
    hold = -prices[0]  # Max profit while holding stock
    sold = 0           # Max profit while not holding
    
    for price in prices:
        new_hold = max(hold, sold - price)
        new_sold = max(sold, hold + price)
        hold, sold = new_hold, new_sold
    
    return sold

# BAD: Cryptic names
def f(p):
    h, s = -p[0], 0
    for x in p:
        h, s = max(h, s - x), max(s, h + x)
    return s
```

**Guidelines**:
- Use descriptive names: `dp[i]`, `max_profit`, `min_cost`
- Add comments explaining what state represents
- Use meaningful variable names in loops

---

### 16.3.2 Code Organization

```python
def well_organized_dp(n, data):
    """
    Clear problem description
    
    Args:
        n: problem size
        data: input data
    
    Returns:
        Optimal value
    
    Time: O(n^2)
    Space: O(n)
    """
    
    # ============ Edge Cases ============
    if n == 0:
        return 0
    if n == 1:
        return data[0]
    
    # ============ Initialize DP ============
    dp = [0] * (n + 1)
    dp[0] = base_value
    
    # ============ Fill DP Table ============
    for i in range(1, n + 1):
        dp[i] = compute_recurrence(dp, i, data)
    
    # ============ Return Result ============
    return dp[n]
```

---

### 16.3.3 Error Handling

```python
def robust_dp(arr):
    """Include proper error handling"""
    
    # Input validation
    if arr is None:
        raise ValueError("Input cannot be None")
    
    if not arr:
        return 0  # or appropriate default
    
    if any(x < 0 for x in arr):
        raise ValueError("All elements must be non-negative")
    
    # Bounds checking
    if len(arr) > 10**5:
        raise ValueError("Input too large")
    
    # Main logic
    n = len(arr)
    dp = [0] * n
    
    # ... DP logic ...
    
    return dp[n - 1]
```

---

### 16.3.4 Debugging Helpers

```python
def dp_with_debug(n, debug=False):
    """Include debug mode"""
    dp = [0] * (n + 1)
    
    for i in range(1, n + 1):
        dp[i] = compute(dp, i)
        
        if debug:
            print(f"dp[{i}] = {dp[i]}")
    
    if debug:
        print(f"Final DP table: {dp}")
    
    return dp[n]

def visualize_2d_dp(dp):
    """Pretty print 2D DP table"""
    print("DP Table:")
    print("-" * 50)
    for i, row in enumerate(dp):
        print(f"Row {i}: {' '.join(f'{x:6}' for x in row)}")
    print("-" * 50)
```

---

### 16.3.5 Testing Template

```python
def test_dp_solution():
    """Comprehensive test cases"""
    
    # Test 1: Basic functionality
    assert solution([1, 2, 3]) == expected_output
    
    # Test 2: Edge case - empty
    assert solution([]) == 0
    
    # Test 3: Edge case - single element
    assert solution([5]) == 5
    
    # Test 4: Edge case - all same
    assert solution([3, 3, 3, 3]) == expected_output
    
    # Test 5: Large input
    assert solution(list(range(1000))) == expected_output
    
    # Test 6: Negative numbers
    assert solution([-1, -2, -3]) == expected_output
    
    print("All tests passed!")

# Run tests
test_dp_solution()
```

---

## 16.4 Common Code Snippets

### 16.4.1 Initialization Patterns

```python
# 1D array
dp = [0] * (n + 1)
dp = [float('inf')] * (n + 1)
dp = [False] * (n + 1)

# 2D array
dp = [[0] * n for _ in range(m)]
dp = [[float('inf')] * n for _ in range(m)]

# Dictionary (sparse states)
dp = {}
dp = defaultdict(int)
dp = defaultdict(lambda: float('inf'))

# With specific base cases
dp = [0] * (n + 1)
dp[0] = 1  # Base case
```

---

### 16.4.2 Common Recurrence Patterns

```python
# Maximum/Minimum
dp[i] = max(dp[i-1], dp[i-2] + arr[i])
dp[i] = min(dp[i-1] + cost1, dp[i-2] + cost2)

# Counting ways
dp[i] = dp[i-1] + dp[i-2]
dp[i] += dp[i-coin]

# Boolean (is possible?)
dp[i] = dp[i-1] or dp[i-k]
dp[i] |= dp[i-k]

# String matching
if s1[i] == s2[j]:
    dp[i][j] = dp[i-1][j-1] + 1
else:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

---

### 16.4.3 Iteration Patterns

```python
# Forward iteration
for i in range(1, n + 1):
    dp[i] = f(dp[i-1])

# Backward iteration (0/1 knapsack)
for i in range(n - 1, -1, -1):
    dp[i] = f(dp[i+1])

# Two pointers
left, right = 0, n - 1
while left <= right:
    # process

# By length (interval DP)
for length in range(2, n + 1):
    for i in range(n - length + 1):
        j = i + length - 1
        # process dp[i][j]

# Bitmask iteration
for mask in range(1 << n):
    for i in range(n):
        if mask & (1 << i):
            # process
```

---

## 16.5 Performance Tips

### 16.5.1 Avoid Repeated Calculations

```python
# BAD: Recalculate max every time
for i in range(n):
    dp[i] = arr[i] + max(dp[max(0, i-k):i])

# GOOD: Use sliding window
from collections import deque
dq = deque()
for i in range(n):
    # Maintain max in window
    while dq and dp[dq[-1]] < dp[i-1]:
        dq.pop()
    dq.append(i-1)
    dp[i] = arr[i] + dp[dq[0]]
```

---

### 16.5.2 Early Termination

```python
# Check for impossible cases early
if sum(arr) % 2 == 1:
    return False  # Can't partition into equal sums

# Prune search space
if current_cost > best_known:
    return  # No need to continue
```

---

### 16.5.3 Precomputation

```python
# Precompute values used multiple times
max_in_range = [[0] * n for _ in range(n)]
for i in range(n):
    max_in_range[i][i] = arr[i]
    for j in range(i + 1, n):
        max_in_range[i][j] = max(max_in_range[i][j-1], arr[j])

# Use in DP
for i in range(n):
    for j in range(i, n):
        dp[i][j] = f(max_in_range[i][j])  # O(1) lookup
```

---

## 16.6 Code Review Checklist

### Before Submitting

- [ ] **Correctness**
  - [ ] Base cases handled
  - [ ] Edge cases tested
  - [ ] Recurrence relation correct
  - [ ] Iteration order correct

- [ ] **Performance**
  - [ ] Time complexity optimal
  - [ ] Space optimized if possible
  - [ ] No redundant calculations

- [ ] **Code Quality**
  - [ ] Clear variable names
  - [ ] Comments for tricky parts
  - [ ] Consistent style
  - [ ] No magic numbers

- [ ] **Robustness**
  - [ ] Input validation
  - [ ] Error handling
  - [ ] Overflow prevention
  - [ ] Edge cases covered

---

## Key Takeaways

1. **Use templates as starting points** - modify for specific problems
2. **Clear naming** reduces bugs and improves readability
3. **Organize code** into clear sections (init, base cases, fill, return)
4. **Test thoroughly** with edge cases
5. **Debug incrementally** - print intermediate states
6. **Optimize after correctness** - don't prematurely optimize
7. **Comment tricky logic** - future you will thank you
8. **Consistent style** - choose one and stick to it
9. **Modular functions** - break complex DP into helper functions
10. **Learn from patterns** - recognize and reuse successful structures

Master these templates and you'll code DP solutions faster and with fewer bugs!