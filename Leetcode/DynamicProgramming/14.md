# Chapter 14: Advanced Optimization Techniques

## Overview

This chapter covers advanced techniques to optimize DP solutions beyond basic space/time improvements. These techniques can reduce complexity from O(n²) to O(n log n) or from O(n³) to O(n²).

**When to Use**:
- Basic DP is too slow (TLE)
- Special properties in recurrence relation
- Large constraints (n > 10^5)
- Need to push complexity limits

---

## 14.1 Space Optimization Techniques

### 14.1.1 Rolling Array

**Concept**: When `dp[i]` only depends on `dp[i-1]` or `dp[i-k]`, use cyclic buffer.

#### Basic Rolling Array (2 states)

```python
# Original: O(n) space
def fib_original(n):
    dp = [0] * (n + 1)
    dp[0], dp[1] = 0, 1
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]

# Optimized: O(1) space
def fib_optimized(n):
    if n <= 1:
        return n
    prev2, prev1 = 0, 1
    for i in range(2, n + 1):
        curr = prev1 + prev2
        prev2, prev1 = prev1, curr
    return prev1

# General pattern for k states
def dp_k_states(n, k):
    """When dp[i] depends on dp[i-1], dp[i-2], ..., dp[i-k]"""
    dp = [0] * k  # Only keep last k values
    
    for i in range(k, n + 1):
        new_val = sum(dp)  # Or specific recurrence
        dp[i % k] = new_val  # Circular buffer
    
    return dp[(n - 1) % k]
```

#### 2D to 1D Optimization

```python
# Original: O(m × n) space
def uniquePaths_2d(m, n):
    dp = [[0] * n for _ in range(m)]
    dp[0][0] = 1
    
    for i in range(m):
        for j in range(n):
            if i > 0:
                dp[i][j] += dp[i-1][j]
            if j > 0:
                dp[i][j] += dp[i][j-1]
    
    return dp[m-1][n-1]

# Optimized: O(n) space
def uniquePaths_1d(m, n):
    dp = [1] * n
    
    for i in range(1, m):
        for j in range(1, n):
            dp[j] += dp[j-1]
    
    return dp[n-1]
```

**Key Insight**: When row `i` only depends on row `i-1`, use 1D array!

---

### 14.1.2 State Compression

**Concept**: Encode multiple state variables into single integer.

```python
# Example: Track position and k different properties
def compressed_state_dp(n, k):
    """
    Instead of dp[i][prop1][prop2][prop3]
    Use dp[i][compressed_state]
    """
    def compress(prop1, prop2, prop3):
        # Pack into single integer
        return (prop1 << 16) | (prop2 << 8) | prop3
    
    def decompress(state):
        prop3 = state & 0xFF
        prop2 = (state >> 8) & 0xFF
        prop1 = (state >> 16) & 0xFF
        return prop1, prop2, prop3
    
    dp = {}
    dp[compress(0, 0, 0)] = initial_value
    
    # Process DP
    for i in range(n):
        new_dp = {}
        for state, value in dp.items():
            p1, p2, p3 = decompress(state)
            # Update based on recurrence
            new_state = compress(p1+1, p2, p3)
            new_dp[new_state] = max(new_dp.get(new_state, 0), value + 1)
        dp = new_dp
    
    return max(dp.values())
```

---

## 14.2 Convex Hull Trick

### 14.2.1 Basic Concept

**Problem Type**: DP with recurrence of form:
```
dp[i] = min(dp[j] + cost[j] × val[i]) for j < i
```

Where cost and val are monotonic.

**Optimization**: O(n²) → O(n log n) or O(n)

#### Example: Fence Problem

```python
def min_cost_fence(n, heights, costs):
    """
    Build fence with heights[i]. Cost to paint fence from j to i:
    dp[i] = min(dp[j] + heights[j] * costs[i]) for j < i
    
    This is convex hull optimization!
    """
    from collections import deque
    
    class Line:
        def __init__(self, m, c):
            self.m = m  # slope
            self.c = c  # intercept
        
        def eval(self, x):
            return self.m * x + self.c
        
        def intersect(self, other):
            # Find intersection x-coordinate with another line
            return (other.c - self.c) / (self.m - other.m)
    
    # Convex hull of lines
    hull = deque()
    
    def bad(l1, l2, l3):
        """Check if l2 is unnecessary"""
        # l2 is bad if its intersection with l3 is left of intersection with l1
        return l1.intersect(l3) <= l1.intersect(l2)
    
    def add_line(line):
        """Add line to convex hull"""
        while len(hull) >= 2 and bad(hull[-2], hull[-1], line):
            hull.pop()
        hull.append(line)
    
    def query(x):
        """Find minimum value at x"""
        # Remove lines that are no longer optimal
        while len(hull) >= 2 and hull[0].eval(x) >= hull[1].eval(x):
            hull.popleft()
        return hull[0].eval(x)
    
    # DP with convex hull trick
    dp = [float('inf')] * n
    dp[0] = 0
    add_line(Line(heights[0], dp[0]))
    
    for i in range(1, n):
        dp[i] = query(costs[i])
        add_line(Line(heights[i], dp[i]))
    
    return dp[n-1]

# Test
heights = [1, 2, 3, 4]
costs = [4, 3, 2, 1]
print(min_cost_fence(len(heights), heights, costs))
```

**Complexity**: O(n log n) with set, O(n) with deque if queries are monotonic

---

### 14.2.2 When Convex Hull Trick Applies

**Requirements**:
1. Recurrence: `dp[i] = min/max(dp[j] + A[j] × B[i] + C[j])`
2. A[j] is monotonic (increasing or decreasing)
3. B[i] is monotonic

**Common Applications**:
- Batch scheduling
- Painting fences
- Building bridges
- Any DP with linear cost function

---

## 14.3 Divide and Conquer Optimization

### 14.3.1 Basic Concept

**Problem Type**: DP with recurrence:
```
dp[i][j] = min(dp[i-1][k] + cost[k][j]) for k < j
```

With **quadrangle inequality**: optimal k is monotonic.

**Optimization**: O(kn²) → O(kn log n)

```python
def divide_conquer_dp(n, k, cost):
    """
    dp[t][i] = min cost to partition first i elements into t groups
    cost[i][j] = cost of one group from i to j
    
    With quadrangle inequality:
    If dp[i-1][k1] optimal for j1 and dp[i-1][k2] optimal for j2
    and j1 < j2, then k1 <= k2
    """
    INF = float('inf')
    dp = [[INF] * n for _ in range(k + 1)]
    dp[0][0] = 0
    
    def compute(t, left, right, opt_left, opt_right):
        """
        Compute dp[t][mid] for mid in [left, right]
        Optimal k is in range [opt_left, opt_right]
        """
        if left > right:
            return
        
        mid = (left + right) // 2
        best_k = -1
        
        # Find optimal k for mid
        for k in range(opt_left, min(opt_right, mid) + 1):
            if dp[t-1][k] == INF:
                continue
            
            val = dp[t-1][k] + cost[k][mid]
            if val < dp[t][mid]:
                dp[t][mid] = val
                best_k = k
        
        # Recursively compute left and right halves
        compute(t, left, mid - 1, opt_left, best_k)
        compute(t, mid + 1, right, best_k, opt_right)
    
    for t in range(1, k + 1):
        compute(t, 0, n - 1, 0, n - 1)
    
    return dp[k][n - 1]

# Example: Partition array into k subarrays to minimize sum of max in each
def partition_array(arr, k):
    n = len(arr)
    
    # Precompute cost[i][j] = max element in arr[i:j+1]
    cost = [[0] * n for _ in range(n)]
    for i in range(n):
        max_val = arr[i]
        for j in range(i, n):
            max_val = max(max_val, arr[j])
            cost[i][j] = max_val
    
    return divide_conquer_dp(n, k, cost)
```

**Complexity**: O(kn log n) vs O(kn²)

---

## 14.4 Monotonic Queue/Stack Optimization

### 14.4.1 Sliding Window Maximum

**Problem**: Compute max/min in sliding window efficiently.

```python
from collections import deque

def sliding_window_maximum(nums, k):
    """
    For each window of size k, find maximum
    Using monotonic deque
    """
    dq = deque()  # Store indices
    result = []
    
    for i in range(len(nums)):
        # Remove elements outside window
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # Remove smaller elements (not useful)
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        
        dq.append(i)
        
        # Add to result when window is full
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result

# Application in DP
def dp_with_sliding_window(arr, k):
    """
    dp[i] = max(dp[j]) + arr[i] for j in [i-k, i-1]
    """
    n = len(arr)
    dp = [0] * n
    dq = deque()
    
    dp[0] = arr[0]
    dq.append(0)
    
    for i in range(1, n):
        # Remove elements outside window
        while dq and dq[0] < i - k:
            dq.popleft()
        
        # Get maximum from window
        dp[i] = dp[dq[0]] + arr[i]
        
        # Maintain monotonic property
        while dq and dp[dq[-1]] <= dp[i]:
            dq.pop()
        
        dq.append(i)
    
    return dp[n - 1]

# Test
print(sliding_window_maximum([1, 3, -1, -3, 5, 3, 6, 7], 3))
# Output: [3, 3, 5, 5, 6, 7]
```

**Complexity**: O(n) instead of O(nk)

---

### 14.4.2 Range Minimum Query with DP

```python
def range_min_query_dp(arr, k):
    """
    dp[i] = min value in range [i-k+1, i]
    """
    from collections import deque
    
    n = len(arr)
    dp = [0] * n
    dq = deque()
    
    for i in range(n):
        # Remove outside window
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # Maintain increasing queue
        while dq and arr[dq[-1]] > arr[i]:
            dq.pop()
        
        dq.append(i)
        dp[i] = arr[dq[0]]
    
    return dp
```

---

## 14.5 Matrix Exponentiation

### 14.5.1 Linear Recurrence Acceleration

**Problem**: Solve recurrence like Fibonacci in O(log n) time!

```python
import numpy as np

def matrix_power(matrix, n):
    """
    Compute matrix^n using binary exponentiation
    """
    size = len(matrix)
    result = np.eye(size, dtype=object)
    base = np.array(matrix, dtype=object)
    
    while n > 0:
        if n % 2 == 1:
            result = np.dot(result, base)
        base = np.dot(base, base)
        n //= 2
    
    return result

def fibonacci_fast(n):
    """
    Compute F(n) in O(log n) time using matrix exponentiation
    
    [F(n+1)]   [1 1]^n   [F(1)]   [1 1]^n   [1]
    [F(n)  ] = [1 0]   × [F(0)] = [1 0]   × [0]
    """
    if n <= 1:
        return n
    
    matrix = [[1, 1], [1, 0]]
    result = matrix_power(matrix, n)
    
    return int(result[0][1])

# Without numpy (using manual matrix multiplication)
def multiply_matrices(A, B):
    """Multiply two 2x2 matrices"""
    return [
        [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],
        [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]
    ]

def matrix_power_manual(matrix, n):
    """Matrix power without numpy"""
    if n == 1:
        return matrix
    
    if n % 2 == 0:
        half = matrix_power_manual(matrix, n // 2)
        return multiply_matrices(half, half)
    else:
        return multiply_matrices(matrix, matrix_power_manual(matrix, n - 1))

def fibonacci_fast_pure(n):
    """Fibonacci without numpy"""
    if n <= 1:
        return n
    
    matrix = [[1, 1], [1, 0]]
    result = matrix_power_manual(matrix, n)
    return result[0][1]

# Test
print(fibonacci_fast(10))       # 55
print(fibonacci_fast_pure(10))  # 55
print(fibonacci_fast(100))      # 354224848179261915075
```

**Complexity**: O(log n) instead of O(n)

---

### 14.5.2 General Linear Recurrence

```python
def solve_linear_recurrence(coeffs, initial, n):
    """
    Solve: a[i] = c[0]*a[i-1] + c[1]*a[i-2] + ... + c[k-1]*a[i-k]
    
    coeffs: [c[0], c[1], ..., c[k-1]]
    initial: [a[0], a[1], ..., a[k-1]]
    n: term to compute
    """
    k = len(coeffs)
    
    if n < k:
        return initial[n]
    
    # Build transformation matrix
    matrix = [[0] * k for _ in range(k)]
    matrix[0] = coeffs
    for i in range(1, k):
        matrix[i][i-1] = 1
    
    # Compute matrix^(n-k+1)
    result_matrix = matrix_power_manual_general(matrix, n - k + 1)
    
    # Multiply with initial vector
    result = 0
    for i in range(k):
        result += result_matrix[0][i] * initial[k - 1 - i]
    
    return result

def matrix_power_manual_general(matrix, n):
    """Matrix power for general size"""
    size = len(matrix)
    
    def multiply(A, B):
        C = [[0] * size for _ in range(size)]
        for i in range(size):
            for j in range(size):
                for k in range(size):
                    C[i][j] += A[i][k] * B[k][j]
        return C
    
    result = [[1 if i == j else 0 for j in range(size)] for i in range(size)]
    base = [row[:] for row in matrix]
    
    while n > 0:
        if n % 2 == 1:
            result = multiply(result, base)
        base = multiply(base, base)
        n //= 2
    
    return result

# Example: Tribonacci
# T[n] = T[n-1] + T[n-2] + T[n-3]
coeffs = [1, 1, 1]
initial = [0, 1, 1]
print(solve_linear_recurrence(coeffs, initial, 10))  # Tribonacci(10)
```

---

## 14.6 Segment Tree for DP

### 14.6.1 Range Query DP

**Problem**: DP where we need range max/min/sum queries.

```python
class SegmentTree:
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (4 * n)
    
    def update(self, idx, val, node=1, start=0, end=None):
        if end is None:
            end = self.n - 1
        
        if start == end:
            self.tree[node] = val
            return
        
        mid = (start + end) // 2
        if idx <= mid:
            self.update(idx, val, 2*node, start, mid)
        else:
            self.update(idx, val, 2*node+1, mid+1, end)
        
        self.tree[node] = max(self.tree[2*node], self.tree[2*node+1])
    
    def query(self, left, right, node=1, start=0, end=None):
        if end is None:
            end = self.n - 1
        
        if left > end or right < start:
            return float('-inf')
        
        if left <= start and end <= right:
            return self.tree[node]
        
        mid = (start + end) // 2
        left_max = self.query(left, right, 2*node, start, mid)
        right_max = self.query(left, right, 2*node+1, mid+1, end)
        
        return max(left_max, right_max)

def dp_with_segment_tree(arr):
    """
    Example: dp[i] = max(dp[j]) + arr[i] for j in some range
    """
    n = len(arr)
    seg_tree = SegmentTree(n)
    dp = [0] * n
    
    dp[0] = arr[0]
    seg_tree.update(0, dp[0])
    
    for i in range(1, n):
        # Query range for maximum dp value
        max_prev = seg_tree.query(max(0, i-10), i-1)
        dp[i] = max_prev + arr[i]
        seg_tree.update(i, dp[i])
    
    return dp[n-1]
```

**Complexity**: O(n log n) for updates and queries

---

## 14.7 Optimization Decision Tree

### How to Choose Optimization

```
Start
  |
  ├─ Is space the bottleneck?
  |    ├─ Yes → Rolling array / State compression
  |    └─ No → Continue
  |
  ├─ Is it O(n²) with linear cost function?
  |    ├─ Yes → Convex Hull Trick
  |    └─ No → Continue
  |
  ├─ Does it have quadrangle inequality?
  |    ├─ Yes → Divide and Conquer Optimization
  |    └─ No → Continue
  |
  ├─ Need range queries in DP?
  |    ├─ Yes → Monotonic Queue or Segment Tree
  |    └─ No → Continue
  |
  └─ Is it linear recurrence?
       ├─ Yes → Matrix Exponentiation
       └─ No → Other advanced techniques
```

---

## Practice Problems

### Convex Hull Trick
1. **Batch Scheduling** - O(n²) → O(n log n)
2. **Fence Painting** - Linear cost optimization
3. **USACO Silver Problems** - Various applications

### Divide and Conquer
1. **Partition Problem** - Split array optimally
2. **Post Office Problem** - Minimize total distance
3. **Print Neatly** - Text justification

### Monotonic Queue
1. Sliding Window Maximum (#239)
2. Shortest Subarray with Sum at Least K (#862)
3. Jump Game VI (#1696)

---

## Key Takeaways

1. **Rolling array**: When `dp[i]` depends on small window
2. **Convex hull trick**: Linear cost functions with monotonicity
3. **Divide & conquer**: Quadrangle inequality optimization
4. **Monotonic queue**: Range min/max in sliding window
5. **Matrix exponentiation**: Linear recurrence in O(log n)
6. **Segment tree**: Range queries with updates
7. **Always profile first**: Don't optimize prematurely
8. **Space-time tradeoff**: Sometimes more space for less time
9. **Problem-specific**: Some optimizations only work for specific problems
10. **Master basics first**: Advanced techniques build on fundamentals

These optimizations can be the difference between TLE and AC in competitions!