# Chapter 12: Pattern 11 - DP on Graphs

## Overview

DP on Graphs applies dynamic programming to graph structures, often combined with graph traversal algorithms. Unlike tree DP, graphs can have cycles and multiple paths between nodes.

**Pattern Recognition**:
- Graph structure with weighted edges
- Shortest/longest path problems
- Path counting with constraints
- Reachability problems
- Graph coloring/assignment

**Key Difference from Tree DP**: Must handle cycles and multiple paths!

---

## 12.1 Shortest Path DP

### 12.1.1 DAG Shortest Path

**Problem**: Find shortest path in a Directed Acyclic Graph (DAG).

**Key Insight**: In a DAG, we can process nodes in topological order!

```python
from collections import defaultdict, deque

def shortest_path_dag(n, edges, start):
    """
    n: number of nodes (0 to n-1)
    edges: list of (u, v, weight)
    start: starting node
    Returns: shortest distances from start to all nodes
    """
    # Build adjacency list
    graph = defaultdict(list)
    in_degree = [0] * n
    
    for u, v, w in edges:
        graph[u].append((v, w))
        in_degree[v] += 1
    
    # Topological sort using Kahn's algorithm
    queue = deque([i for i in range(n) if in_degree[i] == 0])
    topo_order = []
    
    while queue:
        node = queue.popleft()
        topo_order.append(node)
        
        for neighbor, _ in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    # DP: process nodes in topological order
    dist = [float('inf')] * n
    dist[start] = 0
    
    for node in topo_order:
        if dist[node] != float('inf'):
            for neighbor, weight in graph[node]:
                dist[neighbor] = min(dist[neighbor], dist[node] + weight)
    
    return dist

# Test
n = 6
edges = [
    (0, 1, 5), (0, 2, 3),
    (1, 3, 6), (1, 2, 2),
    (2, 4, 4), (2, 5, 2),
    (2, 3, 7), (3, 4, -1),
    (4, 5, -2)
]
print(shortest_path_dag(n, edges, 0))
```

**Visualization**:
```
DAG:
    0
   /|\
  5 | 3
 /  |  \
1   2   \
|\ /|\   \
6 2 4 2   \
| X | |    \
|/ \| |     \
3   5 |      \
 \ /  |       \
 -1   4        \
  \  /          \
   -2            \
    5             end

Topological order: 0 → 1 → 2 → 3 → 4 → 5
```

**Complexity**: O(V + E) time and space

---

### 12.1.2 Bellman-Ford Algorithm

**Problem**: Find shortest paths from source, handling negative weights.

**Key Feature**: Can detect negative cycles!

```python
def bellman_ford(n, edges, start):
    """
    Returns: (distances, has_negative_cycle)
    """
    dist = [float('inf')] * n
    dist[start] = 0
    
    # Relax edges V-1 times
    for _ in range(n - 1):
        for u, v, w in edges:
            if dist[u] != float('inf'):
                dist[v] = min(dist[v], dist[u] + w)
    
    # Check for negative cycles
    has_negative_cycle = False
    for u, v, w in edges:
        if dist[u] != float('inf') and dist[u] + w < dist[v]:
            has_negative_cycle = True
            break
    
    return dist, has_negative_cycle

# Test
n = 5
edges = [
    (0, 1, -1), (0, 2, 4),
    (1, 2, 3), (1, 3, 2),
    (1, 4, 2), (3, 2, 5),
    (3, 1, 1), (4, 3, -3)
]
dist, has_cycle = bellman_ford(n, edges, 0)
print(f"Distances: {dist}")
print(f"Has negative cycle: {has_cycle}")
```

**Complexity**: O(V × E) time, O(V) space

---

### 12.1.3 Floyd-Warshall Algorithm

**Problem**: Find shortest paths between **all pairs** of vertices.

**Key Feature**: Simple implementation, handles negative weights (but not negative cycles).

```python
def floyd_warshall(n, edges):
    """
    Returns: 2D array dist where dist[i][j] = shortest path from i to j
    """
    # Initialize distance matrix
    dist = [[float('inf')] * n for _ in range(n)]
    
    # Distance from node to itself is 0
    for i in range(n):
        dist[i][i] = 0
    
    # Add edges
    for u, v, w in edges:
        dist[u][v] = w
    
    # DP: try each intermediate node
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] != float('inf') and dist[k][j] != float('inf'):
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    
    return dist

# With path reconstruction
def floyd_warshall_with_path(n, edges):
    dist = [[float('inf')] * n for _ in range(n)]
    next_node = [[None] * n for _ in range(n)]
    
    for i in range(n):
        dist[i][i] = 0
        next_node[i][i] = i
    
    for u, v, w in edges:
        dist[u][v] = w
        next_node[u][v] = v
    
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    next_node[i][j] = next_node[i][k]
    
    def reconstruct_path(start, end):
        if next_node[start][end] is None:
            return []
        
        path = [start]
        while start != end:
            start = next_node[start][end]
            path.append(start)
        return path
    
    return dist, reconstruct_path

# Test
n = 4
edges = [
    (0, 1, 3), (0, 3, 7),
    (1, 0, 8), (1, 2, 2),
    (2, 0, 5), (2, 3, 1),
    (3, 0, 2)
]
dist, get_path = floyd_warshall_with_path(n, edges)
print("Distance matrix:")
for row in dist:
    print(row)
print(f"\nPath from 0 to 3: {get_path(0, 3)}")
```

**Visualization**:
```
Graph:
  0 --3--> 1
  ^      / |
  |8   /2  |
  |  /     v
  | /      2
  7        |1
  |        v
  +<--2--- 3

Floyd-Warshall iterations:
k=0: Consider paths through node 0
k=1: Consider paths through node 1
k=2: Consider paths through node 2
k=3: Consider paths through node 3

Final shortest paths:
0→1: 3 (direct)
0→2: 5 (0→1→2)
0→3: 6 (0→1→2→3)
```

**Complexity**: O(V³) time, O(V²) space

---

## 12.2 Count Paths Problems

### 12.2.1 Number of Ways to Arrive at Destination

**Problem**: Count number of shortest paths from source to destination.

**LeetCode**: #1976

```python
def countPaths(n, roads):
    """
    n: number of intersections (0 to n-1)
    roads: list of [u, v, time]
    Returns: number of shortest paths from 0 to n-1
    """
    from collections import defaultdict
    import heapq
    
    MOD = 10**9 + 7
    
    # Build graph
    graph = defaultdict(list)
    for u, v, time in roads:
        graph[u].append((v, time))
        graph[v].append((u, time))
    
    # Dijkstra with path counting
    dist = [float('inf')] * n
    ways = [0] * n
    dist[0] = 0
    ways[0] = 1
    
    pq = [(0, 0)]  # (distance, node)
    
    while pq:
        d, u = heapq.heappop(pq)
        
        if d > dist[u]:
            continue
        
        for v, time in graph[u]:
            new_dist = d + time
            
            if new_dist < dist[v]:
                # Found shorter path
                dist[v] = new_dist
                ways[v] = ways[u]
                heapq.heappush(pq, (new_dist, v))
            elif new_dist == dist[v]:
                # Found another shortest path
                ways[v] = (ways[v] + ways[u]) % MOD
    
    return ways[n - 1]

# Test
n = 7
roads = [
    [0,6,7],[0,1,2],[1,2,3],[1,3,3],
    [6,3,3],[3,5,1],[6,5,1],[2,5,1],
    [0,4,5],[4,6,2]
]
print(countPaths(n, roads))  # 4
```

**Complexity**: O((E + V) log V) time (Dijkstra)

---

### 12.2.2 All Paths from Source Lead to Destination

**Problem**: Check if all paths from source lead to a specific destination.

**LeetCode**: #1059

```python
def leadsToDestination(n, edges, source, destination):
    """
    Returns True if all paths from source lead to destination
    """
    from collections import defaultdict
    
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
    
    # Destination must have no outgoing edges
    if len(graph[destination]) > 0:
        return False
    
    # DFS with three states: WHITE (unvisited), GRAY (visiting), BLACK (visited)
    WHITE, GRAY, BLACK = 0, 1, 2
    state = [WHITE] * n
    
    def dfs(node):
        # If we reach a node with no outgoing edges
        if len(graph[node]) == 0:
            return node == destination
        
        # Mark as visiting (detect cycles)
        state[node] = GRAY
        
        # Check all neighbors
        for neighbor in graph[node]:
            if state[neighbor] == GRAY:
                # Cycle detected
                return False
            
            if state[neighbor] == WHITE:
                if not dfs(neighbor):
                    return False
        
        # Mark as visited
        state[node] = BLACK
        return True
    
    return dfs(source)

# Test
n = 4
edges = [[0,1],[0,2],[1,3],[2,3]]
source = 0
destination = 3
print(leadsToDestination(n, edges, source, destination))  # True
```

**Complexity**: O(V + E) time and space

---

## 12.3 Game Theory DP on Graphs

### 12.3.1 Cat and Mouse

**Problem**: Graph game where cat chases mouse. Both move optimally. Determine winner.

**LeetCode**: #913

```python
def catMouseGame(graph):
    """
    graph[i] = list of nodes reachable from node i
    Mouse starts at 1, Cat at 2, Hole at 0
    Mouse moves first. Both move optimally.
    Returns: 1 if mouse wins, 2 if cat wins, 0 if draw
    """
    from functools import cache
    
    n = len(graph)
    DRAW, MOUSE_WIN, CAT_WIN = 0, 1, 2
    
    @cache
    def dp(mouse, cat, turn):
        """
        mouse: current mouse position
        cat: current cat position
        turn: number of turns taken
        Returns: outcome from this state
        """
        # Base cases
        if turn >= 2 * n:
            return DRAW
        if mouse == 0:
            return MOUSE_WIN
        if mouse == cat:
            return CAT_WIN
        
        if turn % 2 == 0:
            # Mouse's turn
            mouse_win = False
            draw = False
            
            for next_pos in graph[mouse]:
                result = dp(next_pos, cat, turn + 1)
                
                if result == MOUSE_WIN:
                    return MOUSE_WIN
                if result == DRAW:
                    draw = True
            
            return DRAW if draw else CAT_WIN
        else:
            # Cat's turn
            cat_win = False
            draw = False
            
            for next_pos in graph[cat]:
                # Cat cannot move to hole
                if next_pos == 0:
                    continue
                
                result = dp(mouse, next_pos, turn + 1)
                
                if result == CAT_WIN:
                    return CAT_WIN
                if result == DRAW:
                    draw = True
            
            return DRAW if draw else MOUSE_WIN
    
    return dp(1, 2, 0)

# Test
graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]
print(catMouseGame(graph))  # 0 (Draw)
```

**Complexity**: O(n³) time and space

---

## 12.4 Probability DP on Graphs

### 12.4.1 Frog Position After T Seconds

**Problem**: Frog starts at node 1. Each second, jumps to unvisited neighbor with equal probability. Find probability at target after exactly t seconds.

**LeetCode**: #1377

```python
def frogPosition(n, edges, t, target):
    """
    Returns: probability frog is at target after t seconds
    """
    from collections import defaultdict
    
    # Build tree
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    def dfs(node, parent, time, prob):
        """
        node: current node
        parent: parent node (to avoid going back)
        time: remaining time
        prob: current probability
        """
        # Count unvisited neighbors
        neighbors = [v for v in graph[node] if v != parent]
        
        # If we're at target
        if node == target:
            # Must either have exact time left or be stuck here
            if time == 0 or len(neighbors) == 0:
                return prob
            else:
                return 0.0
        
        # If no time left or no neighbors
        if time == 0 or len(neighbors) == 0:
            return 0.0
        
        # Try each neighbor
        for neighbor in neighbors:
            result = dfs(neighbor, node, time - 1, prob / len(neighbors))
            if result > 0:
                return result
        
        return 0.0
    
    return dfs(1, -1, t, 1.0)

# Test
n = 7
edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]
t = 2
target = 4
print(frogPosition(n, edges, t, target))  # 0.16666666666666666
```

**Complexity**: O(n) time and space

---

## 12.5 Graph Coloring DP

### 12.5.1 Count Different Palindromic Subsequences

**Problem**: Count distinct palindromic subsequences in string.

**LeetCode**: #730

```python
def countPalindromicSubsequences(s):
    """
    Count distinct non-empty palindromic subsequences
    """
    MOD = 10**9 + 7
    n = len(s)
    
    # dp[i][j] = count of distinct palindromes in s[i:j+1]
    dp = [[0] * n for _ in range(n)]
    
    # Single characters
    for i in range(n):
        dp[i][i] = 1
    
    # Build up by length
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            
            if s[i] == s[j]:
                # Find next and previous occurrence of s[i]
                left = i + 1
                right = j - 1
                
                while left <= right and s[left] != s[i]:
                    left += 1
                while left <= right and s[right] != s[i]:
                    right -= 1
                
                if left > right:
                    # No occurrence in between
                    dp[i][j] = (2 * dp[i + 1][j - 1] + 2) % MOD
                elif left == right:
                    # One occurrence
                    dp[i][j] = (2 * dp[i + 1][j - 1] + 1) % MOD
                else:
                    # Two or more occurrences
                    dp[i][j] = (2 * dp[i + 1][j - 1] - dp[left + 1][right - 1]) % MOD
            else:
                # Different characters
                dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]) % MOD
    
    return dp[0][n - 1] % MOD

# Test
print(countPalindromicSubsequences("bccb"))  # 6
# Palindromes: "b", "c", "bb", "cc", "bcb", "bccb"
```

**Complexity**: O(n²) time and space

---

## 12.6 Advanced Graph DP

### 12.6.1 Minimum Number of Vertices to Reach All Nodes

**Problem**: Find minimum set of vertices from which all nodes are reachable.

**LeetCode**: #1557

```python
def findSmallestSetOfVertices(n, edges):
    """
    Returns: list of nodes that can reach all other nodes
    Key insight: Nodes with no incoming edges!
    """
    has_incoming = [False] * n
    
    for u, v in edges:
        has_incoming[v] = True
    
    return [i for i in range(n) if not has_incoming[i]]

# Test
n = 6
edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]
print(findSmallestSetOfVertices(n, edges))  # [0, 3]
```

**Complexity**: O(E) time, O(V) space

---

### 12.6.2 Minimum Cost to Make at Least One Valid Path

**Problem**: Grid with directional arrows. Change directions to reach bottom-right from top-left. Minimize changes.

**LeetCode**: #1368

```python
def minCost(grid):
    """
    grid[i][j] = direction (1=right, 2=left, 3=down, 4=up)
    Returns: minimum cost to reach bottom-right
    """
    from collections import deque
    
    m, n = len(grid), len(grid[0])
    directions = {1: (0, 1), 2: (0, -1), 3: (1, 0), 4: (-1, 0)}
    
    # BFS with 0-1 weights (use deque)
    cost = [[float('inf')] * n for _ in range(m)]
    cost[0][0] = 0
    
    dq = deque([(0, 0, 0)])  # (row, col, cost)
    
    while dq:
        r, c, curr_cost = dq.popleft()
        
        if curr_cost > cost[r][c]:
            continue
        
        # Try all 4 directions
        for direction, (dr, dc) in directions.items():
            nr, nc = r + dr, c + dc
            
            if 0 <= nr < m and 0 <= nc < n:
                # Cost: 0 if same direction, 1 if different
                new_cost = curr_cost + (0 if grid[r][c] == direction else 1)
                
                if new_cost < cost[nr][nc]:
                    cost[nr][nc] = new_cost
                    
                    # 0-1 BFS: add to front if cost 0, back if cost 1
                    if grid[r][c] == direction:
                        dq.appendleft((nr, nc, new_cost))
                    else:
                        dq.append((nr, nc, new_cost))
    
    return cost[m - 1][n - 1]

# Test
grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
print(minCost(grid))  # 3
```

**Complexity**: O(m × n) time and space

---

## 12.7 Key Patterns Summary

### Pattern 1: DAG DP
```python
# Process nodes in topological order
topo_order = topological_sort(graph)
for node in topo_order:
    for neighbor in graph[node]:
        dp[neighbor] = update(dp[neighbor], dp[node])
```

### Pattern 2: All Pairs Shortest Path
```python
# Floyd-Warshall
for k in range(n):
    for i in range(n):
        for j in range(n):
            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
```

### Pattern 3: Path Counting
```python
# Count paths while computing shortest paths
if new_dist < dist[v]:
    dist[v] = new_dist
    count[v] = count[u]
elif new_dist == dist[v]:
    count[v] += count[u]
```

---

## Practice Problems Summary

### Beginner
1. Network Delay Time (#743)
2. Find the City with Smallest Number of Neighbors (#1334)
3. Cheapest Flights Within K Stops (#787)

### Intermediate
4. All Paths From Source to Target (#797)
5. Number of Ways to Arrive at Destination (#1976)
6. Path with Maximum Probability (#1514)

### Advanced
7. Cat and Mouse (#913)
8. Shortest Path Visiting All Nodes (#847)
9. Find All People With Secret (#2092)

---

## Key Takeaways

1. **DAG DP = Topological sort + DP** (O(V + E))
2. **Floyd-Warshall** for all-pairs shortest paths (O(V³))
3. **Bellman-Ford** handles negative weights (O(VE))
4. **Path counting**: Track count along with distance
5. **Game theory**: Minimax with memoization
6. **Probability**: Track probability along paths
7. **0-1 BFS**: Use deque for 0-1 edge weights
8. **State**: Often (node, additional_info, turn/time)
9. **Cycle detection**: Essential for graph DP
10. **Memoization**: Cache by graph state

Graph DP combines graph algorithms with dynamic programming - master both!