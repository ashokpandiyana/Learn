# Chapter 15: Problem-Solving Framework

## Overview

This chapter provides a systematic approach to solving DP problems from scratch. A structured framework helps you identify patterns, formulate solutions, and avoid common mistakes.

---

## 15.1 The 5-Step Framework

### Step 1: Identify if it's a DP Problem

#### Key Indicators

**✓ Strong Signals (Very Likely DP)**:
- Asks for **optimal value** (minimum, maximum)
- Asks to **count number of ways**
- Asks **"is it possible?"** with constraints
- Has **overlapping subproblems**
- Has **optimal substructure**

**✓ Keywords to Watch**:
- "Minimum/Maximum"
- "Longest/Shortest"
- "Count ways to..."
- "Optimize"
- "Best strategy"

**✗ Not DP Indicators**:
- Asks for exact arrangement/order (might be backtracking)
- Single pass solution obvious (greedy might work)
- No overlapping subproblems
- Independent subproblems (divide & conquer)

#### Quick Test Questions

Ask yourself:
1. **Can I break this into smaller subproblems?**
2. **Will solving smaller problems help solve the larger one?**
3. **Am I solving the same subproblem multiple times?**
4. **Does the optimal solution use optimal solutions of subproblems?**

If 3+ answers are "yes", likely DP!

---

### Step 2: Define the State

**Most Critical Step!** Wrong state definition = impossible problem.

#### State Definition Checklist

**What information uniquely identifies a subproblem?**

```python
# Common state patterns:

# 1D: Position-based
dp[i] = solution for first i elements

# 2D: Two sequences/dimensions
dp[i][j] = solution for elements up to i and j

# 3D: Additional constraint
dp[i][j][k] = solution with constraint k

# Bitmask: Subset selection
dp[mask] = solution for subset represented by mask

# Graph: Node-based
dp[node] = solution starting/ending at node
```

#### How to Find the State

**Method 1: What Changes?**
- What varies in different subproblems?
- What do I need to know to solve current problem?

**Method 2: From Examples**
- Work through small examples
- What information do you track?
- That's probably your state!

**Method 3: From Constraints**
- Each constraint often needs a state variable
- "At most k transactions" → need to track transaction count

#### Example: Coin Change

```
Problem: Minimum coins to make amount n

❌ Bad state: dp[i] = minimum coins using coin i
   (Doesn't track amount!)

✓ Good state: dp[amount] = minimum coins to make amount
```

#### State Design Patterns

| Pattern | State Definition | Example |
|---------|------------------|---------|
| Linear DP | `dp[i]` | Climbing Stairs |
| 2D Grid | `dp[i][j]` | Unique Paths |
| Subsequence | `dp[i][j]` | LCS |
| Knapsack | `dp[i][w]` | 0/1 Knapsack |
| Interval | `dp[i][j]` | Burst Balloons |
| Bitmask | `dp[mask]` | TSP |
| State Machine | Multiple vars | Stock Trading |

---

### Step 3: Formulate Recurrence Relation

**Connect current state to previous states.**

#### Recurrence Patterns

**Pattern 1: Include/Exclude**
```python
# Decision: take current element or not
dp[i] = max(
    include: value[i] + dp[i-1],  # Take it
    exclude: dp[i-1]              # Skip it
)
```

**Pattern 2: Try All Options**
```python
# Try each possible choice
dp[i] = min(
    dp[i-1] + cost1,
    dp[i-2] + cost2,
    dp[i-3] + cost3
)
```

**Pattern 3: Combine Subproblems**
```python
# LCS pattern
if s1[i] == s2[j]:
    dp[i][j] = dp[i-1][j-1] + 1
else:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

**Pattern 4: Partition/Split**
```python
# Interval DP pattern
for k in range(i, j):
    dp[i][j] = min(
        dp[i][j],
        dp[i][k] + dp[k+1][j] + cost(i, k, j)
    )
```

#### How to Find Recurrence

**Method 1: Think About Last Decision**
- What was the last action taken?
- How does it affect the result?

**Example**: House Robber
```
Last decision: Did I rob house i?
If yes: get nums[i], can't rob i-1, use dp[i-2]
If no: get 0, can rob i-1, use dp[i-1]

Recurrence: dp[i] = max(nums[i] + dp[i-2], dp[i-1])
```

**Method 2: Draw Dependency Diagram**
```
dp[i] depends on:
    ↓
dp[i-1], dp[i-2]
```

**Method 3: Work Backwards from Answer**
- Where does the answer come from?
- What subproblems contribute to it?

---

### Step 4: Identify Base Cases

**Foundation of recursion/iteration.**

#### Common Base Cases

```python
# Empty case
dp[0] = 0  # or 1 for counting problems

# Single element
dp[1] = single_element_value

# Impossible states
dp[negative] = infinity  # for minimization
dp[invalid] = -infinity  # for maximization
dp[invalid] = False      # for boolean problems
```

#### Base Case Checklist

1. **What's the smallest subproblem?**
   - Empty array/string?
   - Single element?
   - Zero capacity?

2. **What's the trivial answer?**
   - Often 0 or 1
   - Sometimes infinity

3. **What makes problem impossible?**
   - Out of bounds
   - Negative values
   - Invalid states

#### Example: Climbing Stairs

```python
# Base cases
dp[0] = 1  # One way to stay at ground (do nothing)
dp[1] = 1  # One way to reach step 1 (one step)

# Why not dp[0] = 0?
# Because we count "ways", not "steps"
# Zero steps is one valid way!
```

---

### Step 5: Determine Iteration Order

**Must compute dependencies before current state.**

#### Order Patterns

**Linear (1D)**
```python
# Left to right
for i in range(n):
    dp[i] = f(dp[i-1], dp[i-2], ...)
```

**2D Grid**
```python
# Row by row, or column by column
for i in range(m):
    for j in range(n):
        dp[i][j] = f(dp[i-1][j], dp[i][j-1])
```

**Interval DP**
```python
# By increasing length
for length in range(2, n+1):
    for i in range(n - length + 1):
        j = i + length - 1
        dp[i][j] = f(...)
```

**Graph/Tree**
```python
# Topological order or post-order traversal
for node in topological_sort(graph):
    dp[node] = f(dp[children])
```

**Bitmask**
```python
# Increasing number of bits set
for mask in range(1 << n):
    for i in range(n):
        if mask & (1 << i):
            dp[mask] = f(dp[mask ^ (1 << i)])
```

---

## 15.2 Implementation Strategies

### Strategy 1: Top-Down (Memoization)

**When to Use**:
- State space is sparse (not all states needed)
- Recurrence is natural recursively
- Complex state transitions
- Easier to think about

```python
from functools import cache

@cache
def solve(state):
    # Base case
    if is_base_case(state):
        return base_value
    
    # Recurrence
    result = initial_value
    for next_state in get_next_states(state):
        result = combine(result, solve(next_state))
    
    return result
```

**Advantages**:
- Intuitive
- Only computes needed states
- Natural for tree/graph problems

**Disadvantages**:
- Recursion overhead
- Stack overflow risk
- Can be slower

---

### Strategy 2: Bottom-Up (Tabulation)

**When to Use**:
- All or most states needed
- Simple iteration order
- Need maximum performance
- Want to avoid recursion limits

```python
def solve(n):
    # Initialize DP table
    dp = [initial_value] * (n + 1)
    
    # Base cases
    dp[0] = base_value
    
    # Fill table
    for i in range(1, n + 1):
        dp[i] = compute(dp, i)
    
    return dp[n]
```

**Advantages**:
- Usually faster
- No stack overflow
- Easier to optimize space

**Disadvantages**:
- Harder to think about
- May compute unnecessary states
- Tricky with complex dependencies

---

### Strategy 3: Space Optimization

**After getting correct solution, optimize space.**

```python
# Original: O(n) space
dp = [0] * (n + 1)
for i in range(1, n + 1):
    dp[i] = dp[i-1] + dp[i-2]

# Optimized: O(1) space
prev2, prev1 = 0, 1
for i in range(2, n + 1):
    curr = prev1 + prev2
    prev2, prev1 = prev1, curr
```

**When to Optimize**:
- After correctness verified
- Space limit is tight
- State only depends on small window

---

## 15.3 Debugging Strategies

### Strategy 1: Print DP Table

```python
def solve_with_debug(n):
    dp = [0] * (n + 1)
    
    for i in range(1, n + 1):
        dp[i] = compute(dp, i)
        print(f"dp[{i}] = {dp[i]}")  # Debug print
    
    # Pretty print 2D table
    if is_2d:
        for row in dp:
            print(' '.join(f'{x:4}' for x in row))
    
    return dp[n]
```

### Strategy 2: Check with Small Examples

```python
# Test with small inputs you can verify manually
test_cases = [
    (1, expected_1),
    (2, expected_2),
    (3, expected_3),
]

for input_val, expected in test_cases:
    result = solve(input_val)
    assert result == expected, f"Failed for {input_val}: got {result}, expected {expected}"
```

### Strategy 3: Verify Base Cases

```python
# Explicitly test base cases
assert dp[0] == expected_base_0
assert dp[1] == expected_base_1
```

### Strategy 4: Check Recurrence Manually

```python
# For one example, manually compute and verify
i = 5
manual = compute_manually(i)
dp_value = dp[i]
assert manual == dp_value, f"Recurrence wrong at {i}"
```

---

## 15.4 Common Pitfalls and Solutions

### Pitfall 1: Wrong State Definition

**Problem**: State doesn't capture all necessary information

**Example**:
```python
# ❌ WRONG: Trying to solve LCS
dp[i] = length of LCS ending at s1[i]
# Missing: which character of s2?

# ✓ CORRECT:
dp[i][j] = LCS of s1[0:i] and s2[0:j]
```

**Solution**: Ask "What do I need to know to solve this subproblem?"

---

### Pitfall 2: Off-by-One Errors

**Problem**: Index confusion

**Common Issues**:
```python
# String of length n
# ❌ dp[n] but only defined dp[0:n-1]
# ✓ dp = [0] * (n + 1)

# Range [i, j] inclusive
# ❌ length = j - i
# ✓ length = j - i + 1
```

**Solution**: Be explicit about what index represents

---

### Pitfall 3: Incorrect Base Cases

**Problem**: Base case doesn't match problem definition

**Example**:
```python
# Counting paths
# ❌ dp[0] = 0  (wrong - there's 1 way to stay at start)
# ✓ dp[0] = 1
```

**Solution**: Test base cases with simplest inputs

---

### Pitfall 4: Wrong Iteration Order

**Problem**: Using values before computing them

**Example**:
```python
# Knapsack
# ❌ Forward iteration (item used multiple times)
for w in range(capacity + 1):
    dp[w] = dp[w - weight] + value

# ✓ Backward iteration (item used once)
for w in range(capacity, weight - 1, -1):
    dp[w] = max(dp[w], dp[w - weight] + value)
```

**Solution**: Draw dependency diagram

---

### Pitfall 5: Integer Overflow

**Problem**: Result exceeds integer limits

**Solution**:
```python
# Use modulo
MOD = 10**9 + 7
dp[i] = (dp[i-1] + dp[i-2]) % MOD

# Or use Python (unlimited integers)
# No overflow in Python!
```

---

### Pitfall 6: Not Handling Edge Cases

**Problem**: Empty input, single element, etc.

**Solution**:
```python
# Always check
if not arr:
    return 0
if len(arr) == 1:
    return arr[0]
```

---

## 15.5 Optimization Checklist

After getting correct solution:

### ✓ Space Optimization
- [ ] Can I use rolling array?
- [ ] Can I reduce dimensions?
- [ ] Can I use in-place modification?

### ✓ Time Optimization
- [ ] Am I recomputing anything?
- [ ] Can I precompute something?
- [ ] Can I use better data structure?
- [ ] Is there a mathematical formula?

### ✓ Code Quality
- [ ] Clear variable names?
- [ ] Comments for tricky parts?
- [ ] Edge cases handled?
- [ ] Tested with examples?

---

## 15.6 Complete Example Walkthrough

### Problem: Minimum Path Sum

**Problem**: Find minimum sum path from top-left to bottom-right in grid.

#### Step 1: Identify DP Problem

- ✓ Asks for minimum (optimal value)
- ✓ Optimal substructure (optimal path uses optimal subpaths)
- ✓ Overlapping subproblems (multiple paths through same cell)

**Verdict**: Yes, this is DP!

#### Step 2: Define State

**Options considered**:
- `dp[i]` = min sum to reach row i? ❌ (missing column info)
- `dp[j]` = min sum to reach column j? ❌ (missing row info)
- `dp[i][j]` = min sum to reach cell (i,j) ✓

**State**: `dp[i][j]` = minimum path sum to reach cell (i, j)

#### Step 3: Formulate Recurrence

**Thinking**:
- Can only come from left or top
- Must include current cell value

**Recurrence**:
```python
dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
```

#### Step 4: Base Cases

**Smallest subproblems**:
- `dp[0][0] = grid[0][0]` (starting point)
- `dp[0][j] = dp[0][j-1] + grid[0][j]` (first row, can only come from left)
- `dp[i][0] = dp[i-1][0] + grid[i][0]` (first column, can only come from top)

#### Step 5: Iteration Order

**Dependencies**: `dp[i][j]` needs `dp[i-1][j]` and `dp[i][j-1]`

**Order**: Row by row, left to right ✓

#### Implementation

```python
def minPathSum(grid):
    if not grid or not grid[0]:
        return 0
    
    m, n = len(grid), len(grid[0])
    dp = [[0] * n for _ in range(m)]
    
    # Base cases
    dp[0][0] = grid[0][0]
    
    # First row
    for j in range(1, n):
        dp[0][j] = dp[0][j-1] + grid[0][j]
    
    # First column
    for i in range(1, m):
        dp[i][0] = dp[i-1][0] + grid[i][0]
    
    # Fill rest
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
    
    return dp[m-1][n-1]

# Test
grid = [[1,3,1], [1,5,1], [4,2,1]]
print(minPathSum(grid))  # 7
```

#### Optimization

```python
# Space optimized: O(n) instead of O(m×n)
def minPathSum_optimized(grid):
    m, n = len(grid), len(grid[0])
    dp = [0] * n
    
    dp[0] = grid[0][0]
    for j in range(1, n):
        dp[j] = dp[j-1] + grid[0][j]
    
    for i in range(1, m):
        dp[0] += grid[i][0]
        for j in range(1, n):
            dp[j] = grid[i][j] + min(dp[j], dp[j-1])
    
    return dp[n-1]
```

---

## 15.7 Pattern Recognition Guide

### Quick Reference

| If problem has... | Try pattern... |
|-------------------|----------------|
| 1D array, optimization | Linear DP |
| 2D grid, paths | 2D Grid DP |
| Two strings | Subsequence DP |
| Weights, capacity | Knapsack |
| Subarray/substring | Interval DP |
| Small set (n≤20) | Bitmask DP |
| Tree structure | Tree DP |
| Graph with cycles | Graph DP |
| Multiple modes/states | State Machine DP |
| Probabilities | Probability DP |

---

## Key Takeaways

1. **Follow the 5-step framework systematically**
2. **State definition is critical** - spend time on it
3. **Start simple** - get correct solution first
4. **Draw examples** - visualize state transitions
5. **Test base cases** thoroughly
6. **Debug with small inputs** you can verify
7. **Optimize after correctness** verified
8. **Practice pattern recognition** on many problems
9. **Learn from mistakes** - keep error log
10. **Build intuition** through repetition

**Remember**: DP mastery comes from solving 100+ problems. Use this framework, but develop your intuition through practice!