# Chapter 5: Pattern 4 - String DP

## Overview

String DP focuses specifically on problems involving string manipulation, transformation, and pattern matching. While related to subsequence DP, these problems have unique characteristics and patterns.

**Pattern Recognition**:
- Palindrome-related problems
- String matching with wildcards/regex
- String partitioning
- String transformation costs

---

## 5.1 Palindrome Problems

### 5.1.1 Longest Palindromic Substring

**Problem**: Find the longest contiguous palindromic substring.

**LeetCode**: #5

#### Two Main Approaches

**Approach 1: Expand Around Center - O(n²) Time, O(1) Space**

```python
def longestPalindrome_expand(s):
    if not s:
        return ""
    
    def expand_around_center(left, right):
        """Expand while characters match"""
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return right - left - 1  # Length of palindrome
    
    start = 0
    max_len = 0
    
    for i in range(len(s)):
        # Odd length palindrome (center is single char)
        len1 = expand_around_center(i, i)
        # Even length palindrome (center is between chars)
        len2 = expand_around_center(i, i + 1)
        
        length = max(len1, len2)
        if length > max_len:
            max_len = length
            start = i - (length - 1) // 2
    
    return s[start:start + max_len]

# Test
print(longestPalindrome_expand("babad"))  # "bab" or "aba"
print(longestPalindrome_expand("cbbd"))   # "bb"
```

**Approach 2: Dynamic Programming - O(n²) Time, O(n²) Space**

**State**: `dp[i][j]` = True if substring `s[i...j]` is palindrome

**Recurrence**:
```python
if s[i] == s[j]:
    dp[i][j] = dp[i+1][j-1]  # Check inner substring
else:
    dp[i][j] = False
```

```python
def longestPalindrome_dp(s):
    n = len(s)
    if n < 2:
        return s
    
    dp = [[False] * n for _ in range(n)]
    start = 0
    max_len = 1
    
    # Every single character is palindrome
    for i in range(n):
        dp[i][i] = True
    
    # Check for two-character palindromes
    for i in range(n - 1):
        if s[i] == s[i + 1]:
            dp[i][i + 1] = True
            start = i
            max_len = 2
    
    # Check for palindromes of length 3 and more
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            
            if s[i] == s[j] and dp[i + 1][j - 1]:
                dp[i][j] = True
                start = i
                max_len = length
    
    return s[start:start + max_len]

# Test
print(longestPalindrome_dp("babad"))  # "bab" or "aba"
```

**Visualization for "babad"**:
```
       b  a  b  a  d
    b  T  F  T  F  F
    a     T  F  T  F
    b        T  F  F
    a           T  F
    d              T

T = True (is palindrome)
Longest: "bab" or "aba" (length 3)
```

**Approach 3: Manacher's Algorithm - O(n) Time (Advanced)**

```python
def longestPalindrome_manacher(s):
    """
    Manacher's algorithm - O(n) time complexity
    """
    # Transform string to avoid even/odd length issues
    # "babad" -> "#b#a#b#a#d#"
    t = '#'.join('^{}$'.format(s))
    n = len(t)
    p = [0] * n  # p[i] = radius of palindrome centered at i
    center = right = 0
    
    for i in range(1, n - 1):
        # Mirror of i with respect to center
        mirror = 2 * center - i
        
        if i < right:
            p[i] = min(right - i, p[mirror])
        
        # Expand around center i
        try:
            while t[i + (p[i] + 1)] == t[i - (p[i] + 1)]:
                p[i] += 1
        except:
            pass
        
        # Update center and right boundary
        if i + p[i] > right:
            center, right = i, i + p[i]
    
    # Find maximum length
    max_len = max(p)
    center_index = p.index(max_len)
    
    # Extract original substring
    start = (center_index - max_len) // 2
    return s[start:start + max_len]
```

**When to use which approach**:
- **Expand around center**: Simple, O(1) space, good for interviews
- **DP**: When you need to query multiple substrings
- **Manacher's**: When O(n) time is required (rare in interviews)

---

### 5.1.2 Palindrome Partitioning II (Minimum Cuts)

**Problem**: Given string, partition it such that every substring is a palindrome. Find minimum cuts needed.

**LeetCode**: #132

#### Analysis

**Two Steps**:
1. Precompute which substrings are palindromes
2. Find minimum cuts using DP

**State**: `dp[i]` = minimum cuts needed for substring `s[0...i]`

**Recurrence**:
```python
if s[0...i] is palindrome:
    dp[i] = 0
else:
    for j in range(i):
        if s[j+1...i] is palindrome:
            dp[i] = min(dp[i], dp[j] + 1)
```

```python
def minCut(s):
    n = len(s)
    
    # Step 1: Build palindrome table
    is_palindrome = [[False] * n for _ in range(n)]
    
    for i in range(n):
        is_palindrome[i][i] = True
    
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j]:
                is_palindrome[i][j] = (length == 2) or is_palindrome[i + 1][j - 1]
    
    # Step 2: DP for minimum cuts
    dp = [float('inf')] * n
    
    for i in range(n):
        if is_palindrome[0][i]:
            dp[i] = 0
        else:
            for j in range(i):
                if is_palindrome[j + 1][i]:
                    dp[i] = min(dp[i], dp[j] + 1)
    
    return dp[n - 1]

# Optimized version with better palindrome checking
def minCut_optimized(s):
    n = len(s)
    dp = list(range(n))  # dp[i] = i (worst case: all single chars)
    
    for i in range(n):
        # Odd length palindromes
        j = 0
        while i - j >= 0 and i + j < n and s[i - j] == s[i + j]:
            if i - j == 0:
                dp[i + j] = 0
            else:
                dp[i + j] = min(dp[i + j], dp[i - j - 1] + 1)
            j += 1
        
        # Even length palindromes
        j = 0
        while i - j >= 0 and i + j + 1 < n and s[i - j] == s[i + j + 1]:
            if i - j == 0:
                dp[i + j + 1] = 0
            else:
                dp[i + j + 1] = min(dp[i + j + 1], dp[i - j - 1] + 1)
            j += 1
    
    return dp[n - 1]

# Test
print(minCut("aab"))      # 1 (a | ab)
print(minCut("abbab"))    # 1 (abba | b)
print(minCut("abababa"))  # 0 (entire string is palindrome)
```

**Complexity**:
- Time: O(n²) for both approaches
- Space: O(n²) for first, O(n) for optimized

---

### 5.1.3 Count Palindromic Substrings

**Problem**: Count how many palindromic substrings exist in a string.

**LeetCode**: #647

#### Analysis

Similar to longest palindromic substring, but count all palindromes.

```python
def countSubstrings_expand(s):
    """Expand around center approach"""
    def count_palindromes(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count
    
    total = 0
    for i in range(len(s)):
        # Odd length
        total += count_palindromes(i, i)
        # Even length
        total += count_palindromes(i, i + 1)
    
    return total

def countSubstrings_dp(s):
    """DP approach"""
    n = len(s)
    dp = [[False] * n for _ in range(n)]
    count = 0
    
    # Single characters
    for i in range(n):
        dp[i][i] = True
        count += 1
    
    # Two characters
    for i in range(n - 1):
        if s[i] == s[i + 1]:
            dp[i][i + 1] = True
            count += 1
    
    # Three or more characters
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j] and dp[i + 1][j - 1]:
                dp[i][j] = True
                count += 1
    
    return count

# Test
print(countSubstrings_expand("abc"))   # 3 (a, b, c)
print(countSubstrings_expand("aaa"))   # 6 (a, a, a, aa, aa, aaa)
```

---

## 5.2 String Matching and Transformation

### 5.2.1 Wildcard Matching

**Problem**: Implement wildcard pattern matching with '?' and '*'.
- '?' matches any single character
- '*' matches any sequence of characters (including empty)

**LeetCode**: #44

#### Analysis

**State**: `dp[i][j]` = True if `s[0...i-1]` matches `p[0...j-1]`

**Recurrence**:
```python
if p[j-1] == '*':
    dp[i][j] = dp[i][j-1] or dp[i-1][j]
    # * matches empty OR * matches one more char
elif p[j-1] == '?' or s[i-1] == p[j-1]:
    dp[i][j] = dp[i-1][j-1]
else:
    dp[i][j] = False
```

```python
def isMatch(s, p):
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    
    # Empty string matches empty pattern
    dp[0][0] = True
    
    # Handle patterns starting with *
    for j in range(1, n + 1):
        if p[j - 1] == '*':
            dp[0][j] = dp[0][j - 1]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j - 1] == '*':
                # * matches empty OR matches one more character
                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]
            elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
    
    return dp[m][n]

# Space Optimized
def isMatch_optimized(s, p):
    m, n = len(s), len(p)
    dp = [False] * (n + 1)
    dp[0] = True
    
    for j in range(1, n + 1):
        if p[j - 1] == '*':
            dp[j] = dp[j - 1]
    
    for i in range(1, m + 1):
        prev = dp[0]
        dp[0] = False
        
        for j in range(1, n + 1):
            temp = dp[j]
            
            if p[j - 1] == '*':
                dp[j] = dp[j - 1] or dp[j]
            elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:
                dp[j] = prev
            else:
                dp[j] = False
            
            prev = temp
    
    return dp[n]

# Test
print(isMatch("aa", "a"))       # False
print(isMatch("aa", "*"))       # True
print(isMatch("cb", "?a"))      # False
print(isMatch("adceb", "*a*b")) # True
```

**Visualization for s="adceb", p="*a*b"**:
```
       ""  *  a  *  b
    "" T   T  F  F  F
    a  F   T  T  T  F
    d  F   T  F  T  F
    c  F   T  F  T  F
    e  F   T  F  T  F
    b  F   T  F  T  T

Result: True
```

---

### 5.2.2 Regular Expression Matching

**Problem**: Implement regex matching with '.' and '*'.
- '.' matches any single character
- '*' matches zero or more of the preceding element

**LeetCode**: #10

#### Analysis

**Critical Difference from Wildcard**: '*' depends on previous character!

**State**: `dp[i][j]` = True if `s[0...i-1]` matches `p[0...j-1]`

**Recurrence**:
```python
if p[j-1] == '*':
    # Case 1: * matches zero occurrence
    dp[i][j] = dp[i][j-2]
    # Case 2: * matches one or more (if current chars match)
    if p[j-2] == '.' or s[i-1] == p[j-2]:
        dp[i][j] |= dp[i-1][j]
else:
    if p[j-1] == '.' or s[i-1] == p[j-1]:
        dp[i][j] = dp[i-1][j-1]
```

```python
def isMatch_regex(s, p):
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    
    # Empty matches empty
    dp[0][0] = True
    
    # Handle patterns like a*, a*b*, etc.
    for j in range(2, n + 1):
        if p[j - 1] == '*':
            dp[0][j] = dp[0][j - 2]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j - 1] == '*':
                # Zero occurrence of character before *
                dp[i][j] = dp[i][j - 2]
                
                # One or more occurrence
                if p[j - 2] == '.' or p[j - 2] == s[i - 1]:
                    dp[i][j] = dp[i][j] or dp[i - 1][j]
            else:
                # Regular character or '.'
                if p[j - 1] == '.' or p[j - 1] == s[i - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
    
    return dp[m][n]

# Memoization approach (often clearer)
from functools import cache

def isMatch_regex_memo(s, p):
    @cache
    def dp(i, j):
        # Base case: reached end of pattern
        if j == len(p):
            return i == len(s)
        
        # Check if current characters match
        first_match = i < len(s) and (p[j] == s[i] or p[j] == '.')
        
        # Handle '*' in pattern
        if j + 1 < len(p) and p[j + 1] == '*':
            # Try zero occurrence OR one or more occurrences
            return dp(i, j + 2) or (first_match and dp(i + 1, j))
        else:
            # Regular character matching
            return first_match and dp(i + 1, j + 1)
    
    return dp(0, 0)

# Test
print(isMatch_regex("aa", "a"))      # False
print(isMatch_regex("aa", "a*"))     # True
print(isMatch_regex("ab", ".*"))     # True
print(isMatch_regex("aab", "c*a*b")) # True
```

**Key Examples to Understand**:
```
s = "aab", p = "c*a*b"

c* matches zero 'c' → ""
a* matches "aa"
b matches "b"
Result: True

s = "mississippi", p = "mis*is*p*."

mis matches "mis"
s* matches "s"
is matches "is"
s* matches "s"
ip matches "ip"
p* matches zero 'p'
. matches "i"
Result: True
```

---

### 5.2.3 Minimum ASCII Delete Sum

**Problem**: Given two strings, delete characters from both to make them equal. Minimize the sum of ASCII values of deleted characters.

**LeetCode**: #712

#### Analysis

Similar to Edit Distance, but with different cost function.

**State**: `dp[i][j]` = minimum ASCII sum to make `s1[0...i-1]` and `s2[0...j-1]` equal

**Recurrence**:
```python
if s1[i-1] == s2[j-1]:
    dp[i][j] = dp[i-1][j-1]  # No deletion needed
else:
    dp[i][j] = min(
        dp[i-1][j] + ord(s1[i-1]),  # Delete from s1
        dp[i][j-1] + ord(s2[j-1])   # Delete from s2
    )
```

```python
def minimumDeleteSum(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Base cases: delete all characters
    for i in range(1, m + 1):
        dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])
    
    for j in range(1, n + 1):
        dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])
    
    # Fill table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(
                    dp[i - 1][j] + ord(s1[i - 1]),
                    dp[i][j - 1] + ord(s2[j - 1])
                )
    
    return dp[m][n]

# Test
print(minimumDeleteSum("sea", "eat"))  # 231 (delete 's' and 't')
print(minimumDeleteSum("delete", "leet"))  # 403
```

---

### 5.2.4 Minimum Insertions to Make String Palindrome

**Problem**: Find minimum insertions needed to make a string a palindrome.

**LeetCode**: #1312

#### Analysis

**Key Insight**: 
```
Minimum insertions = n - LPS(s)
```
where LPS = Longest Palindromic Subsequence

**Why?** Characters not in LPS need to be duplicated!

```python
def minInsertions(s):
    # Find LPS length
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    
    for i in range(n):
        dp[i][i] = 1
    
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    
    lps_length = dp[0][n - 1]
    return n - lps_length

# Alternative: Direct DP
def minInsertions_direct(s):
    n = len(s)
    # dp[i][j] = min insertions to make s[i...j] palindrome
    dp = [[0] * n for _ in range(n)]
    
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1])
    
    return dp[0][n - 1]

# Test
print(minInsertions("zzazz"))    # 0 (already palindrome)
print(minInsertions("mbadm"))    # 2 (mbdadbm)
print(minInsertions("leetcode")) # 5 (eoctcodetoce)
```

---

## Key Patterns and Techniques

### Pattern 1: Palindrome Detection
```python
# Build palindrome table once, use many times
def build_palindrome_table(s):
    n = len(s)
    dp = [[False] * n for _ in range(n)]
    
    for i in range(n):
        dp[i][i] = True
    
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j]:
                dp[i][j] = (length == 2) or dp[i + 1][j - 1]
    
    return dp
```

### Pattern 2: String Matching State
```python
# dp[i][j] typically means:
# - s[0...i-1] matches p[0...j-1]
# OR
# - s[i...n-1] matches p[j...m-1]
```

### Pattern 3: Character Costs
```python
# When operations have costs (like ASCII values):
cost = ord(char)  # Get ASCII value

# Common operations:
delete_cost = dp[i-1][j] + cost(s[i-1])
insert_cost = dp[i][j-1] + cost(s[j-1])
replace_cost = dp[i-1][j-1] + cost(change s[i-1] to s[j-1])
```

---

## Important Notes

### Note 1: Palindrome vs Substring
- **Palindrome**: Can skip characters (subsequence)
- **Palindromic Substring**: Must be contiguous (subarray)

### Note 2: Wildcard vs Regex '*'
- **Wildcard '*'**: Matches any sequence independently
- **Regex '*'**: Matches zero or more of PREVIOUS character

### Note 3: String Matching Edge Cases
```python
# Always handle:
1. Empty strings
2. Pattern-only wildcards ("***")
3. String longer than pattern
4. Special characters at start/end
```

### Note 4: Optimization Opportunities
```python
# Many string DP problems can be optimized:
1. Space: O(n²) → O(n) with rolling array
2. Preprocessing: Build lookup tables
3. Early termination: Check impossible cases first
```

---

## Practice Problems Summary

### Beginner
1. Valid Palindrome (#125)
2. Palindromic Substrings (#647)
3. Longest Palindromic Substring (#5)

### Intermediate
4. Palindrome Partitioning II (#132)
5. Minimum ASCII Delete Sum (#712)
6. Wildcard Matching (#44)

### Advanced
7. Regular Expression Matching (#10)
8. Distinct Subsequences (#115)
9. Interleaving String (#97)

---

## Key Takeaways

1. **Palindromes**: Expand around center (O(1) space) vs DP (O(n²) space)
2. **String Matching**: Two pointers with DP state
3. **Wildcard vs Regex**: Different '*' semantics
4. **Cost Problems**: Track costs in recurrence relation
5. **Preprocessing**: Build palindrome/character tables when needed
6. **Space Optimization**: Most problems can use O(n) space
7. **Edge Cases**: Empty strings, special characters, single characters

Master these string patterns - they're fundamental for many interview problems!