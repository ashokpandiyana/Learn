# Chapter 11: Strongly Connected Components (SCC)
## Finding Maximal Strongly Connected Subgraphs

---

## 11.1 What are Strongly Connected Components?

### Definition

A **Strongly Connected Component (SCC)** of a directed graph is a maximal set of vertices where every vertex is reachable from every other vertex.

```
"Maximal" means: We can't add any more vertices and still have
every vertex reachable from every other.

Within an SCC:
- For any two vertices u, v in the SCC
- There exists a path from u to v AND a path from v to u
```

### Visual Example

```
Directed Graph:
    (1)──→(2)──→(3)
     ↑    ↓      ↓
     └───(4)    (5)──→(6)
                 ↑     ↓
                 └─────┘

SCCs:
┌─────────┐    ┌───┐    ┌─────────┐
│ SCC 1   │    │SCC│    │  SCC 3  │
│  1 ⇄ 2  │───→│ 3 │───→│  5 ⇄ 6  │
│    ⇅    │    │   │    │         │
│    4    │    └───┘    └─────────┘
└─────────┘

SCC 1: {1, 2, 4} - All can reach each other
SCC 2: {3} - Only itself (can't return to 1,2,4)
SCC 3: {5, 6} - Can reach each other (5→6→5)

Note: Between SCCs, connections are ONE-WAY only!
```

### Condensation Graph (DAG of SCCs)

```
If we collapse each SCC into a single node:

    [SCC1] ──→ [SCC2] ──→ [SCC3]
    {1,2,4}     {3}       {5,6}

This "condensation graph" is always a DAG!
(If there were a cycle between SCCs, they'd be one SCC)
```

---

## 11.2 Applications of SCC

```
┌─────────────────────────────────────────────────────────────────┐
│ SCC Applications                                                 │
├─────────────────────────────────────────────────────────────────┤
│ • 2-SAT Problem: Solving Boolean satisfiability                 │
│ • Finding mutually reachable nodes in social networks           │
│ • Deadlock detection in resource allocation graphs              │
│ • Analyzing web page links (pages that link to each other)      │
│ • Compiler optimization: Finding loops in control flow          │
│ • Solving systems of difference constraints                     │
│ • Finding cycles that share vertices                            │
└─────────────────────────────────────────────────────────────────┘
```

---

## 11.3 Kosaraju's Algorithm

### Concept

Kosaraju's algorithm uses **two DFS passes**:
1. First DFS: Record finish times (post-order)
2. Second DFS: Process in reverse finish order on **reversed graph**

```
Key Insight:
If we reverse all edges, SCCs remain the same!
(If u→v and v→u existed, after reversal v→u and u→v exist)

Processing vertices in reverse finish order on reversed graph
ensures we explore one complete SCC before moving to the next.
```

### Visual Walkthrough

```
Original Graph:
    (0)──→(1)
     ↑     │
     │     ↓
    (3)←──(2)──→(4)

Step 1: First DFS to get finish order
DFS from 0: 0 → 1 → 2 → 3 → back to 2 → 4
Finish order (post-order): [3, 4, 2, 1, 0]

Step 2: Reverse the graph
    (0)←──(1)
     │     ↑
     ↓     │
    (3)──→(2)←──(4)

Step 3: DFS on reversed graph in reverse finish order
Process: 0, 1, 2, 4, 3

DFS(0): visits 0 → 3 → 2 → 1 → back
        SCC 1: {0, 1, 2, 3}

DFS(4): visits 4
        SCC 2: {4}

Final SCCs: [{0,1,2,3}, {4}]
```

### Implementation

```python
from collections import defaultdict

def kosaraju_scc(n, edges):
    """
    Kosaraju's Algorithm for finding SCCs
    
    Args:
        n: number of vertices
        edges: list of (u, v) directed edges
    
    Returns:
        List of SCCs (each SCC is a list of vertices)
    """
    # Build graph and reversed graph
    graph = defaultdict(list)
    reversed_graph = defaultdict(list)
    
    for u, v in edges:
        graph[u].append(v)
        reversed_graph[v].append(u)
    
    # Step 1: First DFS to get finish order
    visited = [False] * n
    finish_order = []
    
    def dfs1(node):
        visited[node] = True
        for neighbor in graph[node]:
            if not visited[neighbor]:
                dfs1(neighbor)
        finish_order.append(node)  # Add after processing all neighbors
    
    for i in range(n):
        if not visited[i]:
            dfs1(i)
    
    # Step 2: DFS on reversed graph in reverse finish order
    visited = [False] * n
    sccs = []
    
    def dfs2(node, current_scc):
        visited[node] = True
        current_scc.append(node)
        for neighbor in reversed_graph[node]:
            if not visited[neighbor]:
                dfs2(neighbor, current_scc)
    
    # Process in reverse finish order
    for node in reversed(finish_order):
        if not visited[node]:
            current_scc = []
            dfs2(node, current_scc)
            sccs.append(current_scc)
    
    return sccs


# Example
edges = [
    (0, 1), (1, 2), (2, 3), (3, 0),  # Cycle: 0-1-2-3-0
    (2, 4)  # 4 is separate
]
sccs = kosaraju_scc(5, edges)
print(f"SCCs: {sccs}")  # [[4], [0, 3, 2, 1]] or similar
```

### Why Does It Work?

```
Key Insight: Finish order captures SCC "hierarchy"

If SCC A has an edge to SCC B:
    [A] ──→ [B]

Then vertices in A will finish AFTER vertices in B.
(We go deep into B, finish B's vertices, come back, finish A's)

When we reverse the graph:
    [A] ←── [B]

Now edges go from B to A.
Processing in reverse finish order (A first):
- We start DFS from A
- Can only reach vertices within A (edges from B are reversed)
- We get exactly SCC A!

Then process B, get exactly SCC B.
```

### Complexity Analysis

```
Time Complexity:
- Building graphs: O(V + E)
- First DFS: O(V + E)
- Second DFS: O(V + E)
Total: O(V + E)

Space Complexity:
- Two graphs: O(V + E)
- Visited arrays: O(V)
- Finish order: O(V)
Total: O(V + E)
```

---

## 11.4 Tarjan's Algorithm

### Concept

Tarjan's algorithm finds SCCs in a **single DFS pass** using:
- **Discovery time** (`disc`): When node was first visited
- **Low-link value** (`low`): Minimum discovery time reachable from subtree

```
Key Insight:
A vertex u is the "root" of an SCC if low[u] == disc[u]
This means u cannot reach any vertex discovered before itself.
```

### Visual: Discovery Time and Low-Link

```
Graph:
    (0)──→(1)──→(2)
     ↑     ↓     │
     └────(4)←───┘
           │
           ↓
          (3)

DFS from 0:

Visit 0: disc[0]=0, low[0]=0
Visit 1: disc[1]=1, low[1]=1
Visit 2: disc[2]=2, low[2]=2
Visit 4: disc[4]=3, low[4]=3
  │
  ├── 4→0: 0 is on stack! low[4] = min(3, 0) = 0
  │
  └── Visit 3: disc[3]=4, low[3]=4
               3 has no edges → low[3]=4
               low[3]==disc[3] → {3} is an SCC!

Back to 4: low[4] = min(0, 4) = 0
Back to 2: 2→4 processed, low[2] = min(2, 0) = 0
Back to 1: 1→2, 1→4 processed, low[1] = min(1, 0) = 0
Back to 0: low[0] = min(0, 0) = 0
           low[0]==disc[0] → {0,1,2,4} is an SCC!

SCCs: [{3}, {0,1,2,4}]
```

### Implementation

```python
def tarjan_scc(n, edges):
    """
    Tarjan's Algorithm for finding SCCs
    
    Args:
        n: number of vertices
        edges: list of (u, v) directed edges
    
    Returns:
        List of SCCs (each SCC is a list of vertices)
    """
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
    
    disc = [-1] * n        # Discovery time
    low = [-1] * n         # Low-link value
    on_stack = [False] * n # Is vertex on stack?
    stack = []             # Current path stack
    time = [0]             # Using list for mutability
    sccs = []
    
    def dfs(u):
        # Initialize discovery time and low-link
        disc[u] = low[u] = time[0]
        time[0] += 1
        
        stack.append(u)
        on_stack[u] = True
        
        for v in graph[u]:
            if disc[v] == -1:
                # v not yet visited
                dfs(v)
                low[u] = min(low[u], low[v])
            elif on_stack[v]:
                # v is on stack → back edge to current SCC
                low[u] = min(low[u], disc[v])
        
        # If u is root of SCC
        if low[u] == disc[u]:
            scc = []
            while True:
                v = stack.pop()
                on_stack[v] = False
                scc.append(v)
                if v == u:
                    break
            sccs.append(scc)
    
    for i in range(n):
        if disc[i] == -1:
            dfs(i)
    
    return sccs


# Example
edges = [
    (0, 1), (1, 2), (2, 0),  # Cycle 0-1-2
    (1, 3), (3, 4), (4, 3)   # Cycle 3-4, connected from 1
]
sccs = tarjan_scc(5, edges)
print(f"SCCs: {sccs}")
```

### Step-by-Step Tarjan Example

```python
def tarjan_scc_verbose(n, edges):
    """
    Verbose version for understanding
    """
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
    
    disc = [-1] * n
    low = [-1] * n
    on_stack = [False] * n
    stack = []
    time = [0]
    sccs = []
    
    def dfs(u, depth=0):
        indent = "  " * depth
        print(f"{indent}Visit {u}: disc={time[0]}")
        
        disc[u] = low[u] = time[0]
        time[0] += 1
        stack.append(u)
        on_stack[u] = True
        
        for v in graph[u]:
            if disc[v] == -1:
                print(f"{indent}  Tree edge {u}→{v}")
                dfs(v, depth + 1)
                low[u] = min(low[u], low[v])
                print(f"{indent}  Back from {v}, low[{u}]={low[u]}")
            elif on_stack[v]:
                print(f"{indent}  Back edge {u}→{v} (on stack)")
                low[u] = min(low[u], disc[v])
        
        if low[u] == disc[u]:
            scc = []
            print(f"{indent}  {u} is SCC root!")
            while True:
                v = stack.pop()
                on_stack[v] = False
                scc.append(v)
                if v == u:
                    break
            print(f"{indent}  SCC found: {scc}")
            sccs.append(scc)
    
    for i in range(n):
        if disc[i] == -1:
            dfs(i)
    
    return sccs


# Run verbose example
edges = [(0, 1), (1, 2), (2, 0), (1, 3)]
print("Finding SCCs:")
sccs = tarjan_scc_verbose(4, edges)
print(f"\nFinal SCCs: {sccs}")
```

### Complexity Analysis

```
Time Complexity:
- Each vertex visited once: O(V)
- Each edge examined once: O(E)
Total: O(V + E)

Space Complexity:
- disc, low, on_stack arrays: O(V)
- Stack: O(V)
- Graph: O(V + E)
Total: O(V + E)

Compared to Kosaraju's:
- Same time complexity
- Tarjan's uses less space (no reversed graph)
- Tarjan's is single-pass (can be faster in practice)
```

---

## 11.5 Kosaraju's vs Tarjan's

```
┌─────────────────────────────────────────────────────────────────┐
│              SCC Algorithm Comparison                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  KOSARAJU'S                       TARJAN'S                      │
│  ───────────                      ────────                      │
│  • Two DFS passes                 • Single DFS pass             │
│  • Needs reversed graph           • No extra graph needed       │
│  • Easier to understand           • More complex logic          │
│  • O(V + E) time                  • O(V + E) time               │
│  • O(V + E) space                 • O(V) extra space            │
│                                                                 │
│  Better when:                     Better when:                  │
│  • Conceptual clarity needed      • Memory is limited           │
│  • Already have reversed graph    • Single pass preferred       │
│  • Teaching/learning              • Competitive programming     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 11.6 Building the Condensation Graph

```python
def build_condensation_graph(n, edges, sccs):
    """
    Build DAG of SCCs (condensation graph)
    
    Returns:
        scc_graph: adjacency list of condensation graph
        vertex_to_scc: mapping from vertex to its SCC index
    """
    # Map each vertex to its SCC
    vertex_to_scc = {}
    for i, scc in enumerate(sccs):
        for v in scc:
            vertex_to_scc[v] = i
    
    # Build condensation graph
    scc_graph = defaultdict(set)
    
    for u, v in edges:
        scc_u = vertex_to_scc[u]
        scc_v = vertex_to_scc[v]
        
        if scc_u != scc_v:
            scc_graph[scc_u].add(scc_v)
    
    # Convert sets to lists
    scc_graph = {k: list(v) for k, v in scc_graph.items()}
    
    return scc_graph, vertex_to_scc


# Example
edges = [(0, 1), (1, 2), (2, 0), (2, 3), (3, 4), (4, 3)]
sccs = tarjan_scc(5, edges)
print(f"SCCs: {sccs}")  # e.g., [[3, 4], [0, 2, 1]]

scc_graph, v2scc = build_condensation_graph(5, edges, sccs)
print(f"Condensation graph: {scc_graph}")
print(f"Vertex to SCC: {v2scc}")
```

---

## 11.7 Applications and Interview Problems

### Application 1: 2-SAT Problem

```python
def solve_2sat(n, clauses):
    """
    Solve 2-SAT problem using SCCs
    
    n: number of variables (x1, x2, ..., xn)
    clauses: list of clauses, each is (lit1, lit2)
             where lit is 1 to n or -1 to -n
    
    Returns:
        List of True/False for each variable, or None if unsatisfiable
    """
    # Build implication graph
    # Variable i: node i (true), node i+n (false)
    # Clause (a OR b) → (¬a → b) AND (¬b → a)
    
    def var_to_node(lit):
        if lit > 0:
            return lit - 1  # True form
        else:
            return -lit - 1 + n  # False form
    
    def negation(node):
        if node < n:
            return node + n
        else:
            return node - n
    
    graph = defaultdict(list)
    
    for a, b in clauses:
        node_a = var_to_node(a)
        node_b = var_to_node(b)
        
        # ¬a → b
        graph[negation(node_a)].append(node_b)
        # ¬b → a
        graph[negation(node_b)].append(node_a)
    
    # Find SCCs
    # Using Kosaraju's for simplicity
    visited = [False] * (2 * n)
    finish_order = []
    
    def dfs1(u):
        visited[u] = True
        for v in graph[u]:
            if not visited[v]:
                dfs1(v)
        finish_order.append(u)
    
    for i in range(2 * n):
        if not visited[i]:
            dfs1(i)
    
    # Build reversed graph
    rev_graph = defaultdict(list)
    for u in graph:
        for v in graph[u]:
            rev_graph[v].append(u)
    
    visited = [False] * (2 * n)
    scc_id = [-1] * (2 * n)
    current_scc = 0
    
    def dfs2(u, scc):
        visited[u] = True
        scc_id[u] = scc
        for v in rev_graph[u]:
            if not visited[v]:
                dfs2(v, scc)
    
    for u in reversed(finish_order):
        if not visited[u]:
            dfs2(u, current_scc)
            current_scc += 1
    
    # Check satisfiability
    # If x and ¬x in same SCC → unsatisfiable
    for i in range(n):
        if scc_id[i] == scc_id[i + n]:
            return None
    
    # Assign values
    # Variable is true if its false-node is in earlier SCC
    result = []
    for i in range(n):
        result.append(scc_id[i] > scc_id[i + n])
    
    return result
```

### Application 2: Finding Minimum Vertices to Reach All Nodes

```python
def find_smallest_set_of_vertices(n, edges):
    """
    LeetCode 1557: Minimum Number of Vertices to Reach All Nodes
    In a DAG, find vertices with in-degree 0
    
    For general directed graph, find SCCs with in-degree 0
    and return one vertex from each
    """
    # If graph is already DAG (which problem guarantees)
    in_degree = [0] * n
    for u, v in edges:
        in_degree[v] += 1
    
    return [i for i in range(n) if in_degree[i] == 0]


def find_smallest_set_general(n, edges):
    """
    General case: Find SCCs, return one from each source SCC
    """
    # Find SCCs
    sccs = tarjan_scc(n, edges)
    
    # Build condensation graph and find source SCCs
    v2scc = {}
    for i, scc in enumerate(sccs):
        for v in scc:
            v2scc[v] = i
    
    scc_in_degree = [0] * len(sccs)
    for u, v in edges:
        if v2scc[u] != v2scc[v]:
            scc_in_degree[v2scc[v]] += 1
    
    # Return one vertex from each source SCC
    result = []
    for i, scc in enumerate(sccs):
        if scc_in_degree[i] == 0:
            result.append(scc[0])
    
    return result
```

### Application 3: Critical Connections Based on SCC

```python
def make_graph_strongly_connected(n, edges):
    """
    Find minimum edges to add to make graph strongly connected
    
    Approach: 
    1. Find SCCs
    2. Build condensation DAG
    3. Count sources (in-degree 0) and sinks (out-degree 0)
    4. Answer = max(sources, sinks) [or 0 if single SCC]
    """
    if n == 0:
        return 0
    
    sccs = tarjan_scc(n, edges)
    
    if len(sccs) == 1:
        return 0  # Already strongly connected
    
    # Map vertices to SCCs
    v2scc = {}
    for i, scc in enumerate(sccs):
        for v in scc:
            v2scc[v] = i
    
    num_sccs = len(sccs)
    in_degree = [0] * num_sccs
    out_degree = [0] * num_sccs
    
    for u, v in edges:
        scc_u, scc_v = v2scc[u], v2scc[v]
        if scc_u != scc_v:
            out_degree[scc_u] += 1
            in_degree[scc_v] += 1
    
    sources = sum(1 for d in in_degree if d == 0)
    sinks = sum(1 for d in out_degree if d == 0)
    
    return max(sources, sinks)
```

---

## 11.8 Summary

### Key Concepts

```
Strongly Connected Component (SCC):
- Maximal set of vertices where all pairs are mutually reachable
- Only applies to DIRECTED graphs
- Condensation graph (DAG of SCCs) is always acyclic

Two Main Algorithms:

Kosaraju's (Two-Pass DFS):
1. DFS to get finish order
2. DFS on reversed graph in reverse finish order
3. Each DFS tree in step 2 is an SCC

Tarjan's (Single-Pass DFS):
1. Track discovery time and low-link values
2. Vertex u is SCC root if low[u] == disc[u]
3. Pop stack to get SCC when root is found

Both: O(V + E) time and space
```

### Quick Reference

```python
# Kosaraju's Template
def kosaraju(n, graph):
    # Pass 1: Get finish order
    finish = []
    visited = [False] * n
    for i in range(n):
        if not visited[i]:
            dfs1(i)  # Appends to finish in post-order
    
    # Pass 2: DFS on reversed graph
    sccs = []
    visited = [False] * n
    for node in reversed(finish):
        if not visited[node]:
            scc = []
            dfs2_reversed(node, scc)
            sccs.append(scc)
    return sccs

# Tarjan's Template
def tarjan(n, graph):
    disc = [-1] * n
    low = [-1] * n
    on_stack = [False] * n
    stack = []
    sccs = []
    
    def dfs(u):
        disc[u] = low[u] = time
        stack.append(u)
        on_stack[u] = True
        
        for v in graph[u]:
            if disc[v] == -1:
                dfs(v)
                low[u] = min(low[u], low[v])
            elif on_stack[v]:
                low[u] = min(low[u], disc[v])
        
        if low[u] == disc[u]:
            scc = pop_until(u)
            sccs.append(scc)
```

---

## 11.9 Practice Problems

1. Critical Connections in a Network (LC 1192) - Related concept
2. Minimum Number of Vertices to Reach All Nodes (LC 1557)
3. 2-SAT Problem (Classic)
4. Longest Path in DAG after finding SCCs
5. Number of SCCs in a graph
6. Making graph strongly connected (minimum edges to add)
