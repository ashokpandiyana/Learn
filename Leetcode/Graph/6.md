# Chapter 6: All-Pairs Shortest Path (APSP)
## Finding Shortest Paths Between Every Pair of Vertices

---

## 6.1 Overview

### The Problem

Given a weighted graph, find the **shortest path between every pair of vertices**.

```
Problem:
         3
    (0)────────(1)
     │  \       │
   7 │   \ 2    │ 1
     │    \     │
    (2)────────(3)
         5

Find: Shortest distance from EVERY vertex to EVERY other vertex

Answer (Distance Matrix):
     0    1    2    3
0 [  0    3    6    4  ]
1 [  3    0    4    1  ]
2 [  6    4    0    5  ]
3 [  4    1    5    0  ]

dist[0][3] = 4 (path: 0→1→3 = 3+1)
dist[2][1] = 4 (path: 2→0→1 = 7+3? No! 2→3→1 = 5+1? No! 2→0→3→1 = 7+2+1? 
               Actually: need to check all possibilities)
```

### When to Use APSP

```
Use APSP when you need:
✓ Distance between ALL pairs of vertices
✓ Multiple shortest path queries
✓ Transitive closure (reachability)
✓ Detecting negative cycles

Don't use when:
✗ Only need distances from ONE source (use SSSP instead)
✗ Graph is very large (V > 500, usually)
✗ Graph is sparse (run Dijkstra V times instead)
```

### Algorithm Options

| Algorithm | Time | Space | Notes |
|-----------|------|-------|-------|
| Floyd-Warshall | O(V³) | O(V²) | Simple, handles negative edges |
| Run Dijkstra V times | O(V(V+E)logV) | O(V²) | Better for sparse graphs |
| Run Bellman-Ford V times | O(V²E) | O(V²) | Handles negative edges |
| Johnson's Algorithm | O(V²logV + VE) | O(V²) | Best for sparse + negative |

---

## 6.2 Floyd-Warshall Algorithm

### Concept

Floyd-Warshall uses **dynamic programming** with a beautiful idea:

```
Key Insight:
dist[i][j] through vertices {0, 1, ..., k} =
    min(
        dist[i][j] through {0, 1, ..., k-1},      // Don't use k
        dist[i][k] + dist[k][j]                    // Use k as intermediate
    )

We gradually allow more intermediate vertices!
```

### Visual Walkthrough

```
Graph:
    (0)──2──(1)
     │ \     │
   4 │  6    │ 3
     │   \   │
    (2)──1──(3)

Initial distance matrix (direct edges only):
     0    1    2    3
0 [  0    2    4    6  ]
1 [  2    0    ∞    3  ]
2 [  4    ∞    0    1  ]
3 [  6    3    1    0  ]

k=0: Allow paths through vertex 0
Check all pairs (i,j): can we improve using 0?
- dist[1][2] = min(∞, dist[1][0]+dist[0][2]) = min(∞, 2+4) = 6 ✓ Updated!
- dist[2][1] = min(∞, dist[2][0]+dist[0][1]) = min(∞, 4+2) = 6 ✓ Updated!

     0    1    2    3
0 [  0    2    4    6  ]
1 [  2    0    6    3  ]  ← Updated
2 [  4    6    0    1  ]  ← Updated
3 [  6    3    1    0  ]

k=1: Allow paths through vertices {0, 1}
- dist[0][3] = min(6, dist[0][1]+dist[1][3]) = min(6, 2+3) = 5 ✓
- dist[2][3] already 1, can't improve
- dist[3][0] = min(6, dist[3][1]+dist[1][0]) = min(6, 3+2) = 5 ✓

     0    1    2    3
0 [  0    2    4    5  ]  ← Updated
1 [  2    0    6    3  ]
2 [  4    6    0    1  ]
3 [  5    3    1    0  ]  ← Updated

k=2: Allow paths through vertices {0, 1, 2}
- dist[0][3] = min(5, dist[0][2]+dist[2][3]) = min(5, 4+1) = 5 (no change)
- dist[1][3] = min(3, dist[1][2]+dist[2][3]) = min(3, 6+1) = 3 (no change)
- dist[3][1] = min(3, dist[3][2]+dist[2][1]) = min(3, 1+6) = 3 (no change)

k=3: Allow paths through vertices {0, 1, 2, 3}
- dist[0][2] = min(4, dist[0][3]+dist[3][2]) = min(4, 5+1) = 4 (no change)
- dist[1][2] = min(6, dist[1][3]+dist[3][2]) = min(6, 3+1) = 4 ✓
- dist[2][1] = min(6, dist[2][3]+dist[3][1]) = min(6, 1+3) = 4 ✓

Final:
     0    1    2    3
0 [  0    2    4    5  ]
1 [  2    0    4    3  ]  ← Updated
2 [  4    4    0    1  ]  ← Updated
3 [  5    3    1    0  ]
```

### Implementation

```python
def floyd_warshall(n, edges):
    """
    Floyd-Warshall algorithm for all-pairs shortest paths
    
    Args:
        n: number of vertices (0 to n-1)
        edges: list of (u, v, weight) tuples
    
    Returns:
        dist: n×n matrix of shortest distances
        next_vertex: n×n matrix for path reconstruction
    """
    # Initialize distance matrix
    INF = float('inf')
    dist = [[INF] * n for _ in range(n)]
    next_vertex = [[None] * n for _ in range(n)]  # For path reconstruction
    
    # Distance to self is 0
    for i in range(n):
        dist[i][i] = 0
    
    # Initialize with direct edges
    for u, v, w in edges:
        dist[u][v] = w
        next_vertex[u][v] = v
        # For undirected graph, also add:
        # dist[v][u] = w
        # next_vertex[v][u] = u
    
    # Floyd-Warshall main loop
    # k MUST be the outermost loop!
    for k in range(n):
        for i in range(n):
            for j in range(n):
                # Can we improve dist[i][j] by going through k?
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    next_vertex[i][j] = next_vertex[i][k]
    
    return dist, next_vertex


def reconstruct_path(next_vertex, start, end):
    """
    Reconstruct shortest path from start to end
    """
    if next_vertex[start][end] is None:
        return []  # No path exists
    
    path = [start]
    current = start
    
    while current != end:
        current = next_vertex[current][end]
        path.append(current)
    
    return path


# Example Usage
edges = [
    (0, 1, 2), (1, 0, 2),  # 0 ↔ 1, weight 2
    (0, 2, 4), (2, 0, 4),  # 0 ↔ 2, weight 4
    (0, 3, 6), (3, 0, 6),  # 0 ↔ 3, weight 6
    (1, 3, 3), (3, 1, 3),  # 1 ↔ 3, weight 3
    (2, 3, 1), (3, 2, 1),  # 2 ↔ 3, weight 1
]

dist, next_v = floyd_warshall(4, edges)

print("Distance Matrix:")
for row in dist:
    print([x if x != float('inf') else '∞' for x in row])

print("\nShortest path from 1 to 2:")
path = reconstruct_path(next_v, 1, 2)
print(path)  # [1, 3, 2]
print(f"Distance: {dist[1][2]}")  # 4
```

### Why k Must Be Outermost Loop

```
CRITICAL: The order of loops matters!

CORRECT ✓:     for k:        // Allow intermediate vertex k
                 for i:      // For each source
                   for j:    // For each destination

WRONG ✗:       for i:
                 for j:
                   for k:    // This doesn't work!

Why?
When we compute dist[i][j] using vertex k as intermediate,
we need dist[i][k] and dist[k][j] to already consider 
all intermediate vertices {0, 1, ..., k-1}.

If k is innermost, we're updating dist[i][j] before 
dist[i][k] and dist[k][j] are properly computed!
```

### Detecting Negative Cycles

```python
def floyd_warshall_with_negative_cycle_detection(n, edges):
    """
    Floyd-Warshall that detects negative cycles
    """
    INF = float('inf')
    dist = [[INF] * n for _ in range(n)]
    
    for i in range(n):
        dist[i][i] = 0
    
    for u, v, w in edges:
        dist[u][v] = w
    
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] != INF and dist[k][j] != INF:
                    if dist[i][k] + dist[k][j] < dist[i][j]:
                        dist[i][j] = dist[i][k] + dist[k][j]
    
    # Check for negative cycles
    # If dist[i][i] < 0 for any i, there's a negative cycle
    has_negative_cycle = False
    for i in range(n):
        if dist[i][i] < 0:
            has_negative_cycle = True
            break
    
    return dist, has_negative_cycle


# Example with negative cycle
edges_neg = [
    (0, 1, 1),
    (1, 2, -1),
    (2, 0, -1)  # Cycle 0→1→2→0 has sum = 1-1-1 = -1 (negative!)
]

dist, has_neg_cycle = floyd_warshall_with_negative_cycle_detection(3, edges_neg)
print(f"Has negative cycle: {has_neg_cycle}")  # True
```

### Space-Optimized Version

```python
def floyd_warshall_optimized(n, edges):
    """
    Space-optimized Floyd-Warshall (in-place updates)
    Works because we only need current k values
    """
    INF = float('inf')
    dist = [[INF] * n for _ in range(n)]
    
    for i in range(n):
        dist[i][i] = 0
    
    for u, v, w in edges:
        dist[u][v] = min(dist[u][v], w)  # Handle multiple edges
    
    for k in range(n):
        for i in range(n):
            for j in range(n):
                # In-place update is safe because:
                # dist[i][k] and dist[k][j] don't change when j varies
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    
    return dist
```

---

## 6.3 Complexity Analysis

### Time Complexity

```
Three nested loops, each iterating n times:

for k in range(n):       // n iterations
    for i in range(n):   // n iterations
        for j in range(n): // n iterations
            // O(1) work

Total: O(n³)
```

### Space Complexity

```
Distance matrix: n × n = O(n²)
Next vertex matrix: n × n = O(n²)

Total: O(n²)

Note: Cannot do better than O(n²) because output is n×n matrix!
```

### When Floyd-Warshall is Efficient

```
Floyd-Warshall: O(V³)
V × Dijkstra:   O(V × (V+E)logV) = O(V²logV + VElogV)

For dense graphs (E ≈ V²):
- Floyd-Warshall: O(V³)
- V × Dijkstra: O(V³logV)
→ Floyd-Warshall is slightly better!

For sparse graphs (E ≈ V):
- Floyd-Warshall: O(V³)
- V × Dijkstra: O(V²logV)
→ Dijkstra V times is much better!

Rule of thumb:
- V ≤ 400-500: Floyd-Warshall is fine
- Sparse graph with large V: Use Dijkstra V times
```

---

## 6.4 Applications of Floyd-Warshall

### Application 1: Transitive Closure

Determine if there's a path between every pair of vertices.

```python
def transitive_closure(n, edges):
    """
    Compute transitive closure (reachability matrix)
    reach[i][j] = True if there's a path from i to j
    """
    reach = [[False] * n for _ in range(n)]
    
    # Self-reachability
    for i in range(n):
        reach[i][i] = True
    
    # Direct edges
    for u, v in edges:
        reach[u][v] = True
    
    # Floyd-Warshall style
    for k in range(n):
        for i in range(n):
            for j in range(n):
                reach[i][j] = reach[i][j] or (reach[i][k] and reach[k][j])
    
    return reach


# Example
edges = [(0, 1), (1, 2), (2, 3)]  # Path: 0→1→2→3
reach = transitive_closure(4, edges)

print("Can reach from 0 to 3?", reach[0][3])  # True
print("Can reach from 3 to 0?", reach[3][0])  # False
```

### Application 2: Finding Graph Diameter

```python
def graph_diameter(n, edges):
    """
    Find the diameter (longest shortest path) of a graph
    """
    dist = floyd_warshall_optimized(n, edges)
    
    diameter = 0
    for i in range(n):
        for j in range(n):
            if dist[i][j] != float('inf'):
                diameter = max(diameter, dist[i][j])
    
    return diameter
```

### Application 3: Finding Shortest Cycle

```python
def shortest_cycle(n, edges):
    """
    Find the length of shortest cycle in graph
    """
    INF = float('inf')
    dist = [[INF] * n for _ in range(n)]
    
    for u, v, w in edges:
        dist[u][v] = w
    # Note: Don't set dist[i][i] = 0 initially!
    
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] != INF and dist[k][j] != INF:
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    
    # Shortest cycle is minimum dist[i][i]
    min_cycle = INF
    for i in range(n):
        min_cycle = min(min_cycle, dist[i][i])
    
    return min_cycle if min_cycle != INF else -1
```

### Application 4: Minimax / Maximin Path

```python
def minimax_path(n, edges):
    """
    Find path minimizing maximum edge weight
    Useful for: "What's the minimum capacity truck needed?"
    """
    INF = float('inf')
    # dist[i][j] = minimum possible max-edge-weight from i to j
    dist = [[INF] * n for _ in range(n)]
    
    for i in range(n):
        dist[i][i] = 0
    
    for u, v, w in edges:
        dist[u][v] = w
        dist[v][u] = w
    
    for k in range(n):
        for i in range(n):
            for j in range(n):
                # max of path through k
                through_k = max(dist[i][k], dist[k][j])
                dist[i][j] = min(dist[i][j], through_k)
    
    return dist
```

---

## 6.5 Comparison with Other APSP Approaches

### Running Dijkstra V Times

```python
def all_pairs_dijkstra(graph, n):
    """
    Run Dijkstra from each vertex
    Better for sparse graphs
    """
    all_dist = []
    
    for source in range(n):
        dist = dijkstra_simple(graph, source, n)
        all_dist.append(dist)
    
    return all_dist

# Time: O(V × (V+E)logV)
# Space: O(V²) for output + O(V) for each Dijkstra
```

### When to Use Each

```
┌─────────────────────────────────────────────────────────────────┐
│                     APSP Algorithm Selection                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Is V small (≤ 400)?                                           │
│       │                                                         │
│       ├── YES → Use FLOYD-WARSHALL (simple, O(V³))             │
│       │                                                         │
│       └── NO → Is graph sparse (E << V²)?                      │
│                    │                                            │
│                    ├── YES → Are there negative edges?          │
│                    │          │                                 │
│                    │          ├── NO → Run DIJKSTRA V times    │
│                    │          │                                 │
│                    │          └── YES → JOHNSON'S Algorithm    │
│                    │                                            │
│                    └── NO (dense) → FLOYD-WARSHALL             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 6.6 Common Interview Problems

### Problem 1: Find the City With Smallest Number of Reachable Neighbors

```python
def find_the_city(n, edges, distance_threshold):
    """
    Find city with smallest number of cities reachable 
    within distance_threshold
    """
    INF = float('inf')
    dist = [[INF] * n for _ in range(n)]
    
    for i in range(n):
        dist[i][i] = 0
    
    for u, v, w in edges:
        dist[u][v] = w
        dist[v][u] = w
    
    # Floyd-Warshall
    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    
    # Count reachable cities for each city
    result = -1
    min_reachable = n + 1
    
    for i in range(n):
        count = sum(1 for j in range(n) 
                   if i != j and dist[i][j] <= distance_threshold)
        
        if count <= min_reachable:
            min_reachable = count
            result = i
    
    return result
```

### Problem 2: Minimum Cost to Connect All Cities

```python
def minimum_cost(n, connections):
    """
    Find minimum cost to connect all cities
    Returns -1 if impossible
    
    This is actually MST, but showing Floyd-Warshall 
    can verify connectivity
    """
    # Use Union-Find for MST (Kruskal's)
    # But can use Floyd-Warshall to check all-pairs connectivity
    
    INF = float('inf')
    dist = [[INF] * n for _ in range(n)]
    
    for i in range(n):
        dist[i][i] = 0
    
    for u, v, w in connections:
        dist[u-1][v-1] = min(dist[u-1][v-1], w)
        dist[v-1][u-1] = min(dist[v-1][u-1], w)
    
    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    
    # Check if all cities are connected
    for i in range(n):
        for j in range(n):
            if dist[i][j] == INF:
                return -1  # Not all connected
    
    # For actual minimum cost, use MST (Kruskal's/Prim's)
    # Floyd-Warshall just gives shortest paths, not MST cost
    pass
```

### Problem 3: Evaluate Division (Graph Problem)

```python
def calc_equation(equations, values, queries):
    """
    Given equations like a/b = 2.0, find values of queries like a/c
    Model as weighted graph: edge a→b with weight 2.0 means a/b = 2.0
    """
    # Build graph
    graph = defaultdict(dict)
    
    for (a, b), val in zip(equations, values):
        graph[a][b] = val
        graph[b][a] = 1 / val
        graph[a][a] = 1.0
        graph[b][b] = 1.0
    
    # Floyd-Warshall style
    nodes = list(graph.keys())
    
    for k in nodes:
        for i in nodes:
            for j in nodes:
                if k in graph[i] and j in graph[k]:
                    graph[i][j] = graph[i][k] * graph[k][j]
    
    # Answer queries
    result = []
    for a, b in queries:
        if a in graph and b in graph[a]:
            result.append(graph[a][b])
        else:
            result.append(-1.0)
    
    return result
```

---

## 6.7 Summary

### Key Points

```
Floyd-Warshall Algorithm:
1. Initialize: dist[i][j] = edge weight or ∞
2. For each intermediate vertex k:
   - For each pair (i, j):
   - dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
3. Result: dist[i][j] = shortest path from i to j

Properties:
✓ Simple to implement
✓ Handles negative edges
✓ Detects negative cycles (dist[i][i] < 0)
✗ O(V³) time - slow for large graphs
✗ O(V²) space - can be memory intensive
```

### Quick Reference

```python
# Floyd-Warshall Template
def floyd_warshall(n, edges):
    INF = float('inf')
    dist = [[INF] * n for _ in range(n)]
    
    for i in range(n):
        dist[i][i] = 0
    
    for u, v, w in edges:
        dist[u][v] = w
    
    for k in range(n):          # k MUST be outermost!
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    
    return dist
```

---

## 6.8 Practice Problems

### Floyd-Warshall Problems
1. Find the City With Smallest Number of Neighbors (LC 1334)
2. Network Delay Time - All Pairs variant
3. Evaluate Division (LC 399)
4. Course Schedule IV (LC 1462)

### APSP Concept Problems
1. Shortest Path Visiting All Nodes (LC 847)
2. Find Center of Star Graph (LC 1791)
3. Count Subtrees With Max Distance (LC 1617)
