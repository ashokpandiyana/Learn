# üìä Complete Graph Data Structure Mastery Guide
## From Beginner to Advanced - Interview Edition

---

# Part I: Foundations

## Chapter 1: Graph Fundamentals

### 1.1 What is a Graph?
A graph G = (V, E) consists of vertices (nodes) and edges (connections).

### 1.2 Graph Terminology
| Term | Definition |
|------|------------|
| Vertex/Node | Fundamental unit of a graph |
| Edge | Connection between two vertices |
| Degree | Number of edges connected to a vertex |
| In-degree | Edges coming INTO a vertex (directed) |
| Out-degree | Edges going OUT of a vertex (directed) |
| Path | Sequence of vertices connected by edges |
| Cycle | Path that starts and ends at the same vertex |
| Connected Component | Maximal set of connected vertices |

### 1.3 Types of Graphs

#### By Direction
- **Undirected Graph**: Edges have no direction (bidirectional)
- **Directed Graph (Digraph)**: Edges have direction (one-way)

#### By Weight
- **Unweighted Graph**: All edges have equal weight (or weight = 1)
- **Weighted Graph**: Edges have associated costs/weights

#### Special Types
- **Simple Graph**: No self-loops, no multiple edges
- **Multigraph**: Multiple edges between same vertices allowed
- **Complete Graph**: Every vertex connected to every other vertex
- **Bipartite Graph**: Vertices divisible into two disjoint sets
- **DAG (Directed Acyclic Graph)**: Directed graph with no cycles
- **Tree**: Connected acyclic undirected graph

> ‚ö†Ô∏è **IMPORTANT**: Trees are special graphs with N nodes and N-1 edges

---

## Chapter 2: Graph Representations

### 2.1 Adjacency Matrix

```
Space: O(V¬≤)
Check edge exists: O(1)
Find all neighbors: O(V)
Add edge: O(1)
```

**When to use**: Dense graphs, frequent edge lookups, small graphs

```python
# For graph with V vertices
matrix = [[0] * V for _ in range(V)]
matrix[u][v] = 1  # or weight for weighted graphs
```

### 2.2 Adjacency List

```
Space: O(V + E)
Check edge exists: O(degree)
Find all neighbors: O(degree)
Add edge: O(1)
```

**When to use**: Sparse graphs, most interview problems

```python
# Using dictionary/hashmap
graph = defaultdict(list)
graph[u].append(v)

# Using list of lists
graph = [[] for _ in range(V)]
graph[u].append(v)
```

### 2.3 Edge List

```python
edges = [(u1, v1, w1), (u2, v2, w2), ...]
```

**When to use**: Kruskal's algorithm, when iterating all edges

> üí° **TIP**: 90% of interview problems use Adjacency List representation

### 2.4 Implicit Graphs
Graphs where edges aren't explicitly stored but computed on-the-fly.

**Examples**: Grid problems, word ladder, state space exploration

---

# Part II: Graph Traversals

## Chapter 3: Breadth-First Search (BFS)

### 3.1 Core Algorithm
```python
def bfs(graph, start):
    visited = set([start])
    queue = deque([start])
    
    while queue:
        node = queue.popleft()
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
```

### 3.2 Time & Space Complexity
- **Time**: O(V + E)
- **Space**: O(V)

### 3.3 BFS Properties & Use Cases

| Use Case | Why BFS? |
|----------|----------|
| Shortest path (unweighted) | Explores level by level |
| Level order traversal | Natural level-by-level exploration |
| Finding connected components | Explores all reachable nodes |
| Bipartite checking | Alternate coloring at each level |
| Minimum steps/moves | Each level = one step |

> üî• **CRITICAL**: BFS guarantees shortest path ONLY in unweighted graphs

### 3.4 BFS Patterns

#### Pattern 1: Level-by-Level Processing
```python
def bfs_levels(graph, start):
    visited = set([start])
    queue = deque([start])
    level = 0
    
    while queue:
        level_size = len(queue)  # KEY: Process entire level
        for _ in range(level_size):
            node = queue.popleft()
            # Process node at current level
            for neighbor in graph[node]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        level += 1
```

#### Pattern 2: Multi-Source BFS
Start BFS from multiple sources simultaneously.

```python
def multi_source_bfs(graph, sources):
    visited = set(sources)
    queue = deque(sources)  # All sources start at level 0
    # Rest is same as normal BFS
```

**Problems**: Rotting Oranges, Walls and Gates, 01 Matrix

#### Pattern 3: BFS on Grid
```python
def bfs_grid(grid, start_row, start_col):
    rows, cols = len(grid), len(grid[0])
    directions = [(0,1), (0,-1), (1,0), (-1,0)]
    
    visited = set()
    visited.add((start_row, start_col))
    queue = deque([(start_row, start_col)])
    
    while queue:
        r, c = queue.popleft()
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                if (nr, nc) not in visited and grid[nr][nc] != obstacle:
                    visited.add((nr, nc))
                    queue.append((nr, nc))
```

---

## Chapter 4: Depth-First Search (DFS)

### 4.1 Core Algorithm

#### Recursive
```python
def dfs(graph, node, visited):
    visited.add(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
```

#### Iterative
```python
def dfs_iterative(graph, start):
    visited = set()
    stack = [start]
    
    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                if neighbor not in visited:
                    stack.append(neighbor)
```

### 4.2 Time & Space Complexity
- **Time**: O(V + E)
- **Space**: O(V) for visited + O(H) recursion stack (H = height)

### 4.3 DFS Properties & Use Cases

| Use Case | Why DFS? |
|----------|----------|
| Cycle detection | Track recursion stack |
| Topological sort | Post-order gives reverse topo order |
| Path finding | Explore complete paths |
| Connected components | Mark all reachable nodes |
| Strongly connected components | Kosaraju's, Tarjan's |
| Backtracking problems | Natural recursion structure |

### 4.4 DFS Edge Classification (Directed Graphs)

| Edge Type | Definition | Detection |
|-----------|------------|-----------|
| Tree Edge | Part of DFS tree | First visit |
| Back Edge | To ancestor | In current recursion stack |
| Forward Edge | To descendant (non-tree) | Discovered, not in stack, discovery[u] < discovery[v] |
| Cross Edge | To non-ancestor/descendant | Discovered, not in stack, discovery[u] > discovery[v] |

> ‚ö†Ô∏è **KEY INSIGHT**: Back edges indicate cycles!

### 4.5 DFS States Pattern (3-Color)
```python
WHITE = 0  # Unvisited
GRAY = 1   # In current DFS path (processing)
BLACK = 2  # Completely processed

def dfs_with_states(node):
    color[node] = GRAY
    for neighbor in graph[node]:
        if color[neighbor] == GRAY:
            # Back edge found - CYCLE!
            return True
        if color[neighbor] == WHITE:
            if dfs_with_states(neighbor):
                return True
    color[node] = BLACK
    return False
```

---

# Part III: Shortest Path Algorithms

## Chapter 5: Single Source Shortest Path (SSSP)

### 5.1 Algorithm Selection Guide

| Algorithm | Graph Type | Complexity | Use When |
|-----------|------------|------------|----------|
| BFS | Unweighted | O(V+E) | All edges weight = 1 |
| Dijkstra | Non-negative weights | O((V+E)logV) | No negative edges |
| Bellman-Ford | Any weights | O(VE) | Negative edges possible |
| 0-1 BFS | Weights 0 or 1 only | O(V+E) | Binary weights |

### 5.2 Dijkstra's Algorithm

```python
def dijkstra(graph, start):
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    pq = [(0, start)]  # (distance, node)
    
    while pq:
        d, u = heapq.heappop(pq)
        
        if d > dist[u]:  # Skip outdated entries
            continue
            
        for v, weight in graph[u]:
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                heapq.heappush(pq, (dist[v], v))
    
    return dist
```

> ‚ö†Ô∏è **CRITICAL**: Dijkstra FAILS with negative edge weights!

**Why?** Once a node is processed, Dijkstra assumes its distance is final. Negative edges can invalidate this.

### 5.3 Bellman-Ford Algorithm

```python
def bellman_ford(n, edges, start):
    dist = [float('inf')] * n
    dist[start] = 0
    
    # Relax all edges V-1 times
    for _ in range(n - 1):
        for u, v, w in edges:
            if dist[u] != float('inf') and dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
    
    # Check for negative cycles
    for u, v, w in edges:
        if dist[u] != float('inf') and dist[u] + w < dist[v]:
            return None  # Negative cycle exists!
    
    return dist
```

### 5.4 0-1 BFS (Deque Technique)

For graphs with edge weights of only 0 or 1:

```python
def zero_one_bfs(graph, start, n):
    dist = [float('inf')] * n
    dist[start] = 0
    dq = deque([start])
    
    while dq:
        u = dq.popleft()
        for v, w in graph[u]:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                if w == 0:
                    dq.appendleft(v)  # Weight 0: add to front
                else:
                    dq.append(v)      # Weight 1: add to back
    return dist
```

---

## Chapter 6: All-Pairs Shortest Path (APSP)

### 6.1 Floyd-Warshall Algorithm

```python
def floyd_warshall(n, edges):
    dist = [[float('inf')] * n for _ in range(n)]
    
    for i in range(n):
        dist[i][i] = 0
    
    for u, v, w in edges:
        dist[u][v] = w
    
    # KEY: k must be outermost loop
    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    
    return dist
```

**Complexity**: O(V¬≥) time, O(V¬≤) space

> üí° **TIP**: Can detect negative cycles if dist[i][i] < 0 after algorithm

---

# Part IV: Minimum Spanning Tree (MST)

## Chapter 7: MST Algorithms

### 7.1 Key Properties
- Connects all vertices with minimum total edge weight
- Has exactly V-1 edges
- May not be unique (multiple MSTs possible with equal weights)

### 7.2 Kruskal's Algorithm (Edge-based)

```python
def kruskal(n, edges):
    edges.sort(key=lambda x: x[2])  # Sort by weight
    parent = list(range(n))
    rank = [0] * n
    
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]
    
    def union(x, y):
        px, py = find(x), find(y)
        if px == py:
            return False
        if rank[px] < rank[py]:
            px, py = py, px
        parent[py] = px
        if rank[px] == rank[py]:
            rank[px] += 1
        return True
    
    mst_weight = 0
    mst_edges = []
    
    for u, v, w in edges:
        if union(u, v):
            mst_weight += w
            mst_edges.append((u, v, w))
            if len(mst_edges) == n - 1:
                break
    
    return mst_weight, mst_edges
```

**Complexity**: O(E log E) due to sorting

### 7.3 Prim's Algorithm (Vertex-based)

```python
def prim(graph, n):
    visited = [False] * n
    pq = [(0, 0)]  # (weight, node)
    mst_weight = 0
    edges_added = 0
    
    while pq and edges_added < n:
        weight, u = heapq.heappop(pq)
        
        if visited[u]:
            continue
            
        visited[u] = True
        mst_weight += weight
        edges_added += 1
        
        for v, w in graph[u]:
            if not visited[v]:
                heapq.heappush(pq, (w, v))
    
    return mst_weight
```

**Complexity**: O((V+E) log V)

### 7.4 When to Use Which?

| Kruskal's | Prim's |
|-----------|--------|
| Sparse graphs | Dense graphs |
| Edge list given | Adjacency list given |
| Need MST edges | Need only MST weight |

---

# Part V: Topological Sort

## Chapter 8: Topological Ordering

### 8.1 Definition
Linear ordering of vertices in DAG such that for every edge (u,v), u comes before v.

> ‚ö†Ô∏è **CRITICAL**: Only exists for DAGs (Directed Acyclic Graphs)

### 8.2 Kahn's Algorithm (BFS-based)

```python
def topological_sort_kahn(graph, n):
    in_degree = [0] * n
    for u in range(n):
        for v in graph[u]:
            in_degree[v] += 1
    
    queue = deque([i for i in range(n) if in_degree[i] == 0])
    topo_order = []
    
    while queue:
        u = queue.popleft()
        topo_order.append(u)
        
        for v in graph[u]:
            in_degree[v] -= 1
            if in_degree[v] == 0:
                queue.append(v)
    
    if len(topo_order) != n:
        return []  # Cycle exists!
    return topo_order
```

### 8.3 DFS-based Topological Sort

```python
def topological_sort_dfs(graph, n):
    visited = [False] * n
    stack = []
    
    def dfs(u):
        visited[u] = True
        for v in graph[u]:
            if not visited[v]:
                dfs(v)
        stack.append(u)  # Add AFTER processing all neighbors
    
    for i in range(n):
        if not visited[i]:
            dfs(i)
    
    return stack[::-1]  # Reverse for correct order
```

### 8.4 Applications
- Course scheduling (prerequisites)
- Build systems (dependencies)
- Task scheduling
- Compilation order

---

# Part VI: Union-Find (Disjoint Set Union)

## Chapter 9: Union-Find Data Structure

### 9.1 Basic Operations
- **Find**: Find the root/representative of a set
- **Union**: Merge two sets

### 9.2 Optimized Implementation

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.components = n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False
        
        # Union by rank
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1
        
        self.components -= 1
        return True
    
    def connected(self, x, y):
        return self.find(x) == self.find(y)
```

### 9.3 Complexity with Optimizations
- **Find**: O(Œ±(n)) ‚âà O(1) amortized
- **Union**: O(Œ±(n)) ‚âà O(1) amortized

Where Œ± is the inverse Ackermann function (practically constant)

### 9.4 Applications
- Kruskal's MST
- Cycle detection in undirected graphs
- Connected components (dynamic)
- Network connectivity
- Accounts merge problems

> üí° **TIP**: Use Union-Find when you need to dynamically track connectivity

---

# Part VII: Cycle Detection

## Chapter 10: Finding Cycles

### 10.1 Undirected Graph - Using DFS

```python
def has_cycle_undirected(graph, n):
    visited = [False] * n
    
    def dfs(node, parent):
        visited[node] = True
        for neighbor in graph[node]:
            if not visited[neighbor]:
                if dfs(neighbor, node):
                    return True
            elif neighbor != parent:  # Back edge to non-parent
                return True
        return False
    
    for i in range(n):
        if not visited[i]:
            if dfs(i, -1):
                return True
    return False
```

### 10.2 Undirected Graph - Using Union-Find

```python
def has_cycle_union_find(n, edges):
    uf = UnionFind(n)
    for u, v in edges:
        if uf.connected(u, v):
            return True  # Already connected = cycle!
        uf.union(u, v)
    return False
```

### 10.3 Directed Graph - Using DFS (3-Color)

```python
def has_cycle_directed(graph, n):
    WHITE, GRAY, BLACK = 0, 1, 2
    color = [WHITE] * n
    
    def dfs(node):
        color[node] = GRAY
        for neighbor in graph[node]:
            if color[neighbor] == GRAY:  # Back edge
                return True
            if color[neighbor] == WHITE and dfs(neighbor):
                return True
        color[node] = BLACK
        return False
    
    for i in range(n):
        if color[i] == WHITE:
            if dfs(i):
                return True
    return False
```

> ‚ö†Ô∏è **KEY DIFFERENCE**: In directed graphs, we need 3 colors. In undirected, 2 (visited/not) + parent tracking.

---

# Part VIII: Advanced Algorithms

## Chapter 11: Strongly Connected Components (SCC)

### 11.1 Definition
In a directed graph, SCC is a maximal set of vertices where every vertex is reachable from every other vertex.

### 11.2 Kosaraju's Algorithm

```python
def kosaraju(graph, n):
    # Step 1: Get finish order using DFS
    visited = [False] * n
    finish_order = []
    
    def dfs1(u):
        visited[u] = True
        for v in graph[u]:
            if not visited[v]:
                dfs1(v)
        finish_order.append(u)
    
    for i in range(n):
        if not visited[i]:
            dfs1(i)
    
    # Step 2: Build reverse graph
    reverse_graph = [[] for _ in range(n)]
    for u in range(n):
        for v in graph[u]:
            reverse_graph[v].append(u)
    
    # Step 3: DFS on reverse graph in reverse finish order
    visited = [False] * n
    sccs = []
    
    def dfs2(u, component):
        visited[u] = True
        component.append(u)
        for v in reverse_graph[u]:
            if not visited[v]:
                dfs2(v, component)
    
    for u in reversed(finish_order):
        if not visited[u]:
            component = []
            dfs2(u, component)
            sccs.append(component)
    
    return sccs
```

### 11.3 Tarjan's Algorithm (Single DFS)

```python
def tarjan_scc(graph, n):
    index_counter = [0]
    stack = []
    lowlink = [0] * n
    index = [0] * n
    on_stack = [False] * n
    index_initialized = [False] * n
    sccs = []
    
    def strongconnect(v):
        index[v] = index_counter[0]
        lowlink[v] = index_counter[0]
        index_counter[0] += 1
        index_initialized[v] = True
        stack.append(v)
        on_stack[v] = True
        
        for w in graph[v]:
            if not index_initialized[w]:
                strongconnect(w)
                lowlink[v] = min(lowlink[v], lowlink[w])
            elif on_stack[w]:
                lowlink[v] = min(lowlink[v], index[w])
        
        if lowlink[v] == index[v]:
            component = []
            while True:
                w = stack.pop()
                on_stack[w] = False
                component.append(w)
                if w == v:
                    break
            sccs.append(component)
    
    for v in range(n):
        if not index_initialized[v]:
            strongconnect(v)
    
    return sccs
```

---

## Chapter 12: Bridges and Articulation Points

### 12.1 Definitions
- **Bridge**: Edge whose removal disconnects the graph
- **Articulation Point**: Vertex whose removal disconnects the graph

### 12.2 Finding Bridges (Tarjan's)

```python
def find_bridges(graph, n):
    disc = [0] * n
    low = [0] * n
    visited = [False] * n
    bridges = []
    timer = [0]
    
    def dfs(u, parent):
        visited[u] = True
        disc[u] = low[u] = timer[0]
        timer[0] += 1
        
        for v in graph[u]:
            if not visited[v]:
                dfs(v, u)
                low[u] = min(low[u], low[v])
                
                if low[v] > disc[u]:  # Bridge condition
                    bridges.append((u, v))
            elif v != parent:
                low[u] = min(low[u], disc[v])
    
    for i in range(n):
        if not visited[i]:
            dfs(i, -1)
    
    return bridges
```

### 12.3 Finding Articulation Points

```python
def find_articulation_points(graph, n):
    disc = [0] * n
    low = [0] * n
    visited = [False] * n
    is_ap = [False] * n
    timer = [0]
    
    def dfs(u, parent):
        children = 0
        visited[u] = True
        disc[u] = low[u] = timer[0]
        timer[0] += 1
        
        for v in graph[u]:
            if not visited[v]:
                children += 1
                dfs(v, u)
                low[u] = min(low[u], low[v])
                
                # u is AP if:
                # 1. u is root and has 2+ children
                # 2. u is not root and low[v] >= disc[u]
                if parent == -1 and children > 1:
                    is_ap[u] = True
                if parent != -1 and low[v] >= disc[u]:
                    is_ap[u] = True
            elif v != parent:
                low[u] = min(low[u], disc[v])
    
    for i in range(n):
        if not visited[i]:
            dfs(i, -1)
    
    return [i for i in range(n) if is_ap[i]]
```

---

## Chapter 13: Bipartite Graph

### 13.1 Definition
Graph whose vertices can be divided into two disjoint sets such that every edge connects vertices from different sets.

### 13.2 Bipartite Check (BFS 2-Coloring)

```python
def is_bipartite(graph, n):
    color = [-1] * n
    
    for start in range(n):
        if color[start] != -1:
            continue
            
        queue = deque([start])
        color[start] = 0
        
        while queue:
            u = queue.popleft()
            for v in graph[u]:
                if color[v] == -1:
                    color[v] = 1 - color[u]
                    queue.append(v)
                elif color[v] == color[u]:
                    return False
    
    return True
```

> üí° **KEY INSIGHT**: A graph is bipartite if and only if it contains no odd-length cycles.

---

## Chapter 14: Network Flow

### 14.1 Max Flow - Ford-Fulkerson (BFS/Edmonds-Karp)

```python
def max_flow(capacity, source, sink, n):
    def bfs():
        parent = [-1] * n
        visited = [False] * n
        queue = deque([source])
        visited[source] = True
        
        while queue:
            u = queue.popleft()
            for v in range(n):
                if not visited[v] and capacity[u][v] > 0:
                    visited[v] = True
                    parent[v] = u
                    if v == sink:
                        return parent
                    queue.append(v)
        return None
    
    total_flow = 0
    
    while True:
        parent = bfs()
        if not parent:
            break
        
        # Find min capacity along path
        path_flow = float('inf')
        v = sink
        while v != source:
            u = parent[v]
            path_flow = min(path_flow, capacity[u][v])
            v = u
        
        # Update capacities
        v = sink
        while v != source:
            u = parent[v]
            capacity[u][v] -= path_flow
            capacity[v][u] += path_flow
            v = u
        
        total_flow += path_flow
    
    return total_flow
```

**Complexity**: O(VE¬≤) for Edmonds-Karp

---

# Part IX: Graph Patterns for Interviews

## Chapter 15: Essential Patterns

### Pattern 1: Grid as Graph
Treat each cell as a node, adjacent cells as edges.

```python
directions = [(0,1), (0,-1), (1,0), (-1,0)]  # 4-directional
directions_8 = [(0,1), (0,-1), (1,0), (-1,0), 
                (1,1), (1,-1), (-1,1), (-1,-1)]  # 8-directional
```

**Problems**: Number of Islands, Flood Fill, Surrounded Regions

### Pattern 2: State Space Graph
Each state is a node, valid transitions are edges.

**Problems**: Word Ladder, Open the Lock, Sliding Puzzle

### Pattern 3: Build Graph from Constraints
Convert relationships/constraints into graph edges.

**Problems**: Course Schedule, Alien Dictionary, Sequence Reconstruction

### Pattern 4: Multiple Sources/Destinations
Initialize BFS/DFS from multiple starting points.

**Problems**: 01 Matrix, Walls and Gates, Rotting Oranges

### Pattern 5: Bidirectional BFS
Search from both source and destination, meet in middle.

```python
def bidirectional_bfs(start, end):
    if start == end:
        return 0
    
    front = {start}
    back = {end}
    visited = {start, end}
    level = 0
    
    while front and back:
        level += 1
        # Always expand smaller set
        if len(front) > len(back):
            front, back = back, front
        
        next_front = set()
        for node in front:
            for neighbor in get_neighbors(node):
                if neighbor in back:
                    return level
                if neighbor not in visited:
                    visited.add(neighbor)
                    next_front.add(neighbor)
        front = next_front
    
    return -1
```

**Problems**: Word Ladder, Minimum Genetic Mutation

### Pattern 6: Dijkstra Variants

#### (a) K-Shortest Paths
Allow visiting nodes up to K times.

#### (b) Dijkstra with State
State = (node, additional_info)

```python
# Example: Shortest path with at most k stops
dist = {}  # (node, stops) -> distance
pq = [(0, start, 0)]  # (dist, node, stops)
```

**Problems**: Cheapest Flights Within K Stops, Path with Maximum Probability

### Pattern 7: Topological Sort + DP

Process nodes in topological order for DAG DP problems.

```python
def dag_shortest_path(graph, n, source):
    topo = topological_sort(graph, n)
    dist = [float('inf')] * n
    dist[source] = 0
    
    for u in topo:
        if dist[u] != float('inf'):
            for v, w in graph[u]:
                dist[v] = min(dist[v], dist[u] + w)
    
    return dist
```

**Problems**: Longest Path in DAG, All Paths from Source to Target

### Pattern 8: Graph Coloring / Bipartition

Use for grouping problems, scheduling with constraints.

**Problems**: Possible Bipartition, Is Graph Bipartite, Flower Planting

---

## Chapter 16: Common Interview Problems by Category

### 16.1 BFS Problems
| Problem | Key Insight |
|---------|-------------|
| Number of Islands | BFS/DFS from each unvisited land |
| Shortest Path in Binary Matrix | BFS with 8 directions |
| Word Ladder | Each word is node, transform = edge |
| Rotting Oranges | Multi-source BFS |
| 01 Matrix | Multi-source BFS from all 0s |
| Snakes and Ladders | BFS with jumps |

### 16.2 DFS Problems
| Problem | Key Insight |
|---------|-------------|
| Clone Graph | DFS with hashmap for cloning |
| All Paths Source to Target | DFS backtracking (DAG) |
| Surrounded Regions | DFS from border O's |
| Pacific Atlantic Water Flow | DFS from both oceans |
| Reconstruct Itinerary | DFS with sorted adjacency + backtrack |

### 16.3 Topological Sort Problems
| Problem | Key Insight |
|---------|-------------|
| Course Schedule | Cycle detection |
| Course Schedule II | Return topo order |
| Alien Dictionary | Build graph from word comparisons |
| Parallel Courses | Topo sort with level tracking |

### 16.4 Union-Find Problems
| Problem | Key Insight |
|---------|-------------|
| Number of Connected Components | Count components |
| Redundant Connection | Edge that creates cycle |
| Accounts Merge | Union emails, group by root |
| Number of Operations to Make Network Connected | Need n-1 edges for n nodes |

### 16.5 Shortest Path Problems
| Problem | Key Insight |
|---------|-------------|
| Network Delay Time | Dijkstra from source |
| Cheapest Flights Within K Stops | Dijkstra with state (stops) |
| Path with Maximum Probability | Dijkstra (maximize instead of minimize) |
| Swim in Rising Water | Binary search + BFS OR Dijkstra |

---

# Part X: Tips & Tricks

## Chapter 17: Interview Strategy

### 17.1 Problem Identification Checklist

1. **Is it a graph problem?**
   - Relationships between entities? ‚Üí Graph
   - Grid/Matrix traversal? ‚Üí Implicit graph
   - Dependencies? ‚Üí DAG
   - Connected components? ‚Üí Union-Find or DFS/BFS

2. **What type of traversal?**
   - Shortest path (unweighted)? ‚Üí BFS
   - Explore all paths? ‚Üí DFS
   - Level-by-level? ‚Üí BFS
   - Cycle detection? ‚Üí DFS with colors

3. **What algorithm?**
   - Shortest path with weights? ‚Üí Dijkstra/Bellman-Ford
   - Dependencies/ordering? ‚Üí Topological Sort
   - Connectivity queries? ‚Üí Union-Find
   - MST? ‚Üí Kruskal's/Prim's

### 17.2 Common Mistakes to Avoid

| Mistake | Solution |
|---------|----------|
| Forgetting to mark visited BEFORE adding to queue | Mark when adding, not when popping |
| Using Dijkstra with negative weights | Use Bellman-Ford instead |
| Infinite loop in DFS | Proper visited tracking |
| Wrong cycle detection in directed graph | Use 3 colors, not 2 |
| Not handling disconnected graphs | Loop through all nodes |
| Modifying graph while iterating | Create copy or use indices |

### 17.3 Complexity Quick Reference

| Algorithm | Time | Space |
|-----------|------|-------|
| BFS/DFS | O(V+E) | O(V) |
| Dijkstra (heap) | O((V+E)logV) | O(V) |
| Bellman-Ford | O(VE) | O(V) |
| Floyd-Warshall | O(V¬≥) | O(V¬≤) |
| Kruskal | O(ElogE) | O(V) |
| Prim (heap) | O((V+E)logV) | O(V) |
| Topological Sort | O(V+E) | O(V) |
| Tarjan SCC | O(V+E) | O(V) |
| Union-Find | O(Œ±(n)) per op | O(V) |

### 17.4 Template Mental Model

```
1. Build the graph (adjacency list usually)
2. Initialize data structures (visited, distances, etc.)
3. Choose traversal (BFS/DFS/Dijkstra)
4. Process nodes following the pattern
5. Return result
```

---

## Chapter 18: Practice Problem List (Difficulty Ordered)

### Easy
1. Find if Path Exists in Graph
2. Number of Islands
3. Flood Fill
4. Find the Town Judge
5. Find Center of Star Graph

### Medium
1. Clone Graph
2. Course Schedule I & II
3. Number of Provinces
4. Rotting Oranges
5. 01 Matrix
6. Word Ladder
7. Network Delay Time
8. Cheapest Flights Within K Stops
9. Redundant Connection
10. All Paths From Source to Target
11. Pacific Atlantic Water Flow
12. Accounts Merge
13. Evaluate Division
14. Minimum Height Trees
15. Graph Valid Tree

### Hard
1. Word Ladder II
2. Alien Dictionary
3. Reconstruct Itinerary
4. Critical Connections in a Network (Bridges)
5. Swim in Rising Water
6. Longest Increasing Path in a Matrix
7. Bus Routes
8. Shortest Path Visiting All Nodes
9. Cat and Mouse
10. Frog Position After T Seconds

---

> üéØ **FINAL TIP**: Master BFS and DFS thoroughly - they form the foundation for 80% of graph problems. Once comfortable, the advanced algorithms become variations and extensions of these core concepts.
