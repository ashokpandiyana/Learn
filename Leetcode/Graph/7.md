# Chapter 7: Minimum Spanning Tree (MST)
## Connecting All Vertices with Minimum Cost

---

## 7.1 What is a Spanning Tree?

### Definition

A **Spanning Tree** of a connected, undirected graph G is a subgraph that:
1. Includes **ALL vertices** of G
2. Is a **tree** (connected and acyclic)
3. Has exactly **V - 1 edges** (where V is number of vertices)

```
Original Graph:              A Spanning Tree:
      2                            2
  (A)───(B)                    (A)───(B)
   │\  / │                      │     │
  4│ \/3 │1                    4│     │1
   │ /\  │                      │     │
  (C)───(D)                    (C)   (D)
      5

Graph has 5 edges              Tree has 3 edges (V-1 = 4-1 = 3)
Multiple cycles                No cycles, all vertices connected
```

### What is a Minimum Spanning Tree?

A **Minimum Spanning Tree (MST)** is a spanning tree with the **minimum total edge weight**.

```
Graph with weights:
         4
    (A)─────(B)
     │\     /│
    2│ \3  / │6
     │  \ /  │
    (C)──X──(D)
     │  / \  │
    1│ /5  \7│3
     │/     \│
    (E)─────(F)
         8

MST (one possibility):
         4
    (A)─────(B)
     │       
    2│       │6
     │       │
    (C)     (D)
     │       │
    1│       │3
     │       │
    (E)     (F)

Wait, this isn't connected! Let me recalculate...

Correct MST:
    (A)     (B)
     │       │
    2│       │6
     │       │
    (C)──3──(D)
     │       │
    1│       │3
     │       │
    (E)     (F)

Total weight: 2 + 1 + 3 + 6 + 3 = 15
```

### Key Properties of MST

```
┌─────────────────────────────────────────────────────────────────┐
│ MST Properties                                                   │
├─────────────────────────────────────────────────────────────────┤
│ 1. Has exactly V - 1 edges                                      │
│ 2. No cycles                                                    │
│ 3. Connects all vertices                                        │
│ 4. May NOT be unique (multiple MSTs with same total weight)     │
│ 5. Cutting any edge disconnects the tree                        │
│ 6. Adding any edge creates exactly one cycle                    │
└─────────────────────────────────────────────────────────────────┘
```

### MST is NOT Unique

```
Graph:
    (A)──1──(B)
     │       │
    1│       │1
     │       │
    (C)──1──(D)

All edges have weight 1!

MST Option 1:        MST Option 2:        MST Option 3:
    (A)──1──(B)          (A)──1──(B)          (A)     (B)
     │                    │       │            │       │
    1│                   1│       │1          1│       │1
     │                    │       │            │       │
    (C)──1──(D)          (C)     (D)          (C)──1──(D)

Weight = 3            Weight = 3            Weight = 3

All are valid MSTs!
```

---

## 7.2 MST Algorithms Overview

### Two Main Approaches

```
┌─────────────────────────────────────────────────────────────────┐
│                    MST Algorithm Comparison                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  KRUSKAL'S ALGORITHM              PRIM'S ALGORITHM              │
│  ──────────────────               ────────────────              │
│  • Edge-centric                   • Vertex-centric              │
│  • Sort all edges                 • Grow tree from one vertex   │
│  • Add smallest edge if           • Add smallest edge to tree   │
│    it doesn't form cycle          • Uses priority queue         │
│  • Uses Union-Find                                              │
│                                                                 │
│  Time: O(E log E)                 Time: O((V+E) log V)          │
│  Best for: Sparse graphs          Best for: Dense graphs        │
│            Edge list input                  Adjacency list      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 7.3 Kruskal's Algorithm

### Concept

Kruskal's uses a **greedy approach**:
1. Sort all edges by weight (ascending)
2. Pick the smallest edge that doesn't form a cycle
3. Repeat until we have V-1 edges

```
Key Insight:
We use Union-Find to efficiently check if adding an edge creates a cycle.
If two vertices are already in the same component → adding edge creates cycle!
```

### Visual Walkthrough

```
Graph:
         4
    (A)─────(B)
     │\     /│
    2│ \8  /6│
     │  \ /  │
    (C)───────(D)
     │    3   │
    7│        │5
     │        │
    (E)───────(F)
         9

Step 1: Sort edges by weight
Edges: (A,C,2), (C,D,3), (A,B,4), (D,F,5), (B,D,6), (C,E,7), (A,D,8), (E,F,9)

Step 2: Process edges one by one

Edge (A,C,2): A,C in different sets → ADD ✓
    (A)     (B)          Components: {A,C}, {B}, {D}, {E}, {F}
     │       
    2│       
     │       
    (C)     (D)
            
            
            
    (E)     (F)

Edge (C,D,3): C,D in different sets → ADD ✓
    (A)     (B)          Components: {A,C,D}, {B}, {E}, {F}
     │       
    2│       
     │       
    (C)──3──(D)
            
            
            
    (E)     (F)

Edge (A,B,4): A,B in different sets → ADD ✓
         4
    (A)─────(B)          Components: {A,B,C,D}, {E}, {F}
     │       
    2│       
     │       
    (C)──3──(D)
            
            
            
    (E)     (F)

Edge (D,F,5): D,F in different sets → ADD ✓
         4
    (A)─────(B)          Components: {A,B,C,D,F}, {E}
     │       
    2│       
     │       
    (C)──3──(D)
             │
             │5
             │
    (E)     (F)

Edge (B,D,6): B,D in SAME set → SKIP ✗ (would create cycle)

Edge (C,E,7): C,E in different sets → ADD ✓
         4
    (A)─────(B)          Components: {A,B,C,D,E,F} - ALL CONNECTED!
     │       
    2│       
     │       
    (C)──3──(D)
     │       │
    7│       │5
     │       │
    (E)     (F)

We have V-1 = 5 edges. DONE!
MST weight = 2 + 3 + 4 + 5 + 7 = 21
```

### Implementation

```python
class UnionFind:
    """Union-Find data structure for Kruskal's algorithm"""
    
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        """Find with path compression"""
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        """Union by rank. Returns True if union performed (different sets)"""
        px, py = self.find(x), self.find(y)
        
        if px == py:
            return False  # Already in same set - would create cycle!
        
        # Union by rank
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        
        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1
        
        return True


def kruskal(n, edges):
    """
    Kruskal's MST Algorithm
    
    Args:
        n: number of vertices (0 to n-1)
        edges: list of (u, v, weight) tuples
    
    Returns:
        mst_weight: total weight of MST
        mst_edges: list of edges in MST
    """
    # Step 1: Sort edges by weight
    edges.sort(key=lambda x: x[2])
    
    # Step 2: Initialize Union-Find
    uf = UnionFind(n)
    
    mst_weight = 0
    mst_edges = []
    
    # Step 3: Process edges in order
    for u, v, weight in edges:
        # If u and v are in different components, add this edge
        if uf.union(u, v):
            mst_weight += weight
            mst_edges.append((u, v, weight))
            
            # Early termination: MST has exactly V-1 edges
            if len(mst_edges) == n - 1:
                break
    
    # Check if MST exists (graph must be connected)
    if len(mst_edges) != n - 1:
        return -1, []  # Graph is not connected
    
    return mst_weight, mst_edges


# Example Usage
edges = [
    (0, 1, 4),   # A-B
    (0, 2, 2),   # A-C
    (0, 3, 8),   # A-D
    (1, 3, 6),   # B-D
    (2, 3, 3),   # C-D
    (2, 4, 7),   # C-E
    (3, 5, 5),   # D-F
    (4, 5, 9),   # E-F
]

weight, mst = kruskal(6, edges)
print(f"MST Weight: {weight}")  # 21
print(f"MST Edges: {mst}")
# [(0, 2, 2), (2, 3, 3), (0, 1, 4), (3, 5, 5), (2, 4, 7)]
```

### Complexity Analysis

```
Time Complexity:
- Sorting edges: O(E log E)
- Processing edges: O(E × α(V)) ≈ O(E)
  where α is inverse Ackermann (practically constant)

Total: O(E log E) = O(E log V)  [since E ≤ V²]

Space Complexity:
- Sorted edges: O(E)
- Union-Find: O(V)

Total: O(E + V) = O(E) for connected graphs
```

---

## 7.4 Prim's Algorithm

### Concept

Prim's grows the MST from a **starting vertex**:
1. Start with any vertex
2. Add the minimum weight edge connecting tree to non-tree vertex
3. Repeat until all vertices are in the tree

```
Key Insight:
Use a min-heap to efficiently find the minimum edge to a non-tree vertex.
Similar to Dijkstra, but we track edge weight, not total distance!
```

### Visual Walkthrough

```
Graph (same as before):
         4
    (A)─────(B)
     │\     /│
    2│ \8  /6│
     │  \ /  │
    (C)───────(D)
     │    3   │
    7│        │5
     │        │
    (E)───────(F)
         9

Start from vertex A:

Step 1: Initialize
Tree vertices: {A}
Priority Queue: [(2,A,C), (4,A,B), (8,A,D)]

Step 2: Pop minimum (2,A,C) - Add C
Tree vertices: {A, C}
Add edges from C: (3,C,D), (7,C,E)
PQ: [(3,C,D), (4,A,B), (7,C,E), (8,A,D)]

         4
    (A)─────(B)
     │       
    2│       
     │       
    (C)     (D)

Step 3: Pop minimum (3,C,D) - Add D
Tree vertices: {A, C, D}
Add edges from D: (5,D,F), (6,D,B)
PQ: [(4,A,B), (5,D,F), (6,D,B), (7,C,E), (8,A,D)]

    (A)     (B)
     │       
    2│       
     │       
    (C)──3──(D)

Step 4: Pop minimum (4,A,B) - Add B
Tree vertices: {A, C, D, B}
B has no new edges to non-tree vertices
PQ: [(5,D,F), (6,D,B), (7,C,E), (8,A,D)]

         4
    (A)─────(B)
     │       
    2│       
     │       
    (C)──3──(D)

Step 5: Pop minimum (5,D,F) - Add F
Tree vertices: {A, C, D, B, F}
Add edges from F: (9,F,E)
PQ: [(6,D,B), (7,C,E), (8,A,D), (9,F,E)]

         4
    (A)─────(B)
     │       
    2│       
     │       
    (C)──3──(D)
             │
             │5
             │
            (F)

Step 6: Pop (6,D,B) - B already in tree, SKIP

Step 7: Pop minimum (7,C,E) - Add E
Tree vertices: {A, C, D, B, F, E} - ALL VERTICES!

         4
    (A)─────(B)
     │       
    2│       
     │       
    (C)──3──(D)
     │       │
    7│       │5
     │       │
    (E)     (F)

DONE! MST weight = 2 + 3 + 4 + 5 + 7 = 21
```

### Implementation

```python
import heapq
from collections import defaultdict

def prim(n, edges):
    """
    Prim's MST Algorithm using adjacency list and min-heap
    
    Args:
        n: number of vertices (0 to n-1)
        edges: list of (u, v, weight) tuples
    
    Returns:
        mst_weight: total weight of MST
        mst_edges: list of edges in MST
    """
    # Build adjacency list
    graph = defaultdict(list)
    for u, v, w in edges:
        graph[u].append((w, v))
        graph[v].append((w, u))
    
    # Initialize
    in_mst = [False] * n
    mst_weight = 0
    mst_edges = []
    
    # Min-heap: (weight, from_vertex, to_vertex)
    # Start from vertex 0
    pq = [(0, -1, 0)]  # (weight, from, to) - dummy "from" for start
    
    while pq and len(mst_edges) < n - 1:
        weight, from_v, to_v = heapq.heappop(pq)
        
        # Skip if vertex already in MST
        if in_mst[to_v]:
            continue
        
        # Add vertex to MST
        in_mst[to_v] = True
        mst_weight += weight
        
        if from_v != -1:  # Skip the initial dummy edge
            mst_edges.append((from_v, to_v, weight))
        
        # Add edges to non-MST vertices
        for edge_weight, neighbor in graph[to_v]:
            if not in_mst[neighbor]:
                heapq.heappush(pq, (edge_weight, to_v, neighbor))
    
    # Check if MST exists
    if len(mst_edges) != n - 1:
        return -1, []
    
    return mst_weight, mst_edges


# Alternative: Simpler version (just returns weight)
def prim_simple(n, edges):
    """Simplified Prim's - returns only MST weight"""
    graph = defaultdict(list)
    for u, v, w in edges:
        graph[u].append((w, v))
        graph[v].append((w, u))
    
    in_mst = [False] * n
    pq = [(0, 0)]  # (weight, vertex)
    mst_weight = 0
    edges_added = 0
    
    while pq and edges_added < n:
        weight, u = heapq.heappop(pq)
        
        if in_mst[u]:
            continue
        
        in_mst[u] = True
        mst_weight += weight
        edges_added += 1
        
        for w, v in graph[u]:
            if not in_mst[v]:
                heapq.heappush(pq, (w, v))
    
    return mst_weight if edges_added == n else -1


# Example
edges = [
    (0, 1, 4), (0, 2, 2), (0, 3, 8),
    (1, 3, 6), (2, 3, 3), (2, 4, 7),
    (3, 5, 5), (4, 5, 9)
]

weight, mst = prim(6, edges)
print(f"MST Weight: {weight}")  # 21
print(f"MST Edges: {mst}")
```

### Complexity Analysis

```
Time Complexity:
- Each vertex added to heap: O(V) times
- Each edge can cause one heap push: O(E) pushes
- Each heap operation: O(log V)

Total: O((V + E) log V)

For dense graphs (E ≈ V²): O(V² log V)
Can be improved to O(E + V log V) with Fibonacci heap

Space Complexity:
- Adjacency list: O(E)
- Priority queue: O(E) worst case
- in_mst array: O(V)

Total: O(E + V)
```

---

## 7.5 Kruskal's vs Prim's: When to Use Which?

### Comparison Table

| Aspect | Kruskal's | Prim's |
|--------|-----------|--------|
| Approach | Edge-centric | Vertex-centric |
| Data Structure | Union-Find | Priority Queue |
| Time Complexity | O(E log E) | O((V+E) log V) |
| Best for | Sparse graphs | Dense graphs |
| Input format | Edge list | Adjacency list |
| Implementation | Simpler | Slightly complex |
| Parallelizable | Yes (sort) | No |

### Decision Guide

```
┌─────────────────────────────────────────────────────────────────┐
│ Which MST Algorithm Should I Use?                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Is the graph sparse (E ≈ V)?                                  │
│       │                                                         │
│       ├── YES → KRUSKAL'S (edge-based is efficient)            │
│       │                                                         │
│       └── NO (dense, E ≈ V²) → PRIM'S                          │
│                                                                 │
│  Is input given as edge list?                                   │
│       │                                                         │
│       ├── YES → KRUSKAL'S (natural fit)                        │
│       │                                                         │
│       └── NO (adjacency list) → PRIM'S                         │
│                                                                 │
│  Need to find MST edges explicitly?                             │
│       │                                                         │
│       ├── YES → KRUSKAL'S (builds edge list naturally)         │
│       │                                                         │
│       └── NO (just weight) → Either works                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 7.6 MST Variations and Applications

### Application 1: Minimum Cost to Connect All Points

```python
def min_cost_connect_points(points):
    """
    Connect all points with minimum total Manhattan distance
    LeetCode 1584
    """
    n = len(points)
    
    # Build complete graph with Manhattan distances
    edges = []
    for i in range(n):
        for j in range(i + 1, n):
            dist = abs(points[i][0] - points[j][0]) + \
                   abs(points[i][1] - points[j][1])
            edges.append((i, j, dist))
    
    # Kruskal's MST
    edges.sort(key=lambda x: x[2])
    uf = UnionFind(n)
    
    total_cost = 0
    edges_added = 0
    
    for u, v, cost in edges:
        if uf.union(u, v):
            total_cost += cost
            edges_added += 1
            if edges_added == n - 1:
                break
    
    return total_cost
```

### Application 2: Minimum Spanning Tree with Constraints

```python
def mst_with_max_edge_constraint(n, edges, max_weight):
    """
    Find MST where all edges have weight ≤ max_weight
    Returns number of components if MST not possible
    """
    # Filter edges
    valid_edges = [(u, v, w) for u, v, w in edges if w <= max_weight]
    valid_edges.sort(key=lambda x: x[2])
    
    uf = UnionFind(n)
    
    for u, v, w in valid_edges:
        uf.union(u, v)
    
    # Count components
    components = len(set(uf.find(i) for i in range(n)))
    return components
```

### Application 3: Second Minimum Spanning Tree

```python
def second_mst(n, edges):
    """
    Find the second minimum spanning tree
    Approach: For each MST edge, find MST without that edge
    """
    # First, find MST
    edges.sort(key=lambda x: x[2])
    uf = UnionFind(n)
    mst_edges = []
    
    for u, v, w in edges:
        if uf.union(u, v):
            mst_edges.append((u, v, w))
    
    first_mst_weight = sum(e[2] for e in mst_edges)
    
    # Try removing each MST edge and find new MST
    second_mst_weight = float('inf')
    
    for excluded in mst_edges:
        uf = UnionFind(n)
        weight = 0
        count = 0
        
        for u, v, w in edges:
            if (u, v, w) == excluded:
                continue
            if uf.union(u, v):
                weight += w
                count += 1
        
        if count == n - 1:  # Valid spanning tree
            second_mst_weight = min(second_mst_weight, weight)
    
    return second_mst_weight
```

---

## 7.7 The Cut Property (Why Greedy Works)

### Understanding the Cut Property

```
Cut Property:
For any cut (partition of vertices into two sets), 
the minimum weight edge crossing the cut is in SOME MST.

Visual:
┌─────────────┐     ┌─────────────┐
│    Set S    │     │   Set V-S   │
│             │     │             │
│    (A)      │ 2   │     (D)     │
│     │       ├─────┤      │      │
│    (B)      │     │     (E)     │
│     │       │ 5   │             │
│    (C)──────┼─────┤             │
│             │     │             │
└─────────────┘     └─────────────┘

Edge with weight 2 crosses the cut
It's the minimum crossing edge
Therefore, it MUST be in some MST!

This is why both Kruskal's and Prim's work:
- Kruskal's: Each edge added is minimum across some cut
- Prim's: Each edge added is minimum crossing current tree boundary
```

---

## 7.8 Common Interview Problems

### Problem 1: Connecting Cities with Minimum Cost

```python
def minimum_cost(n, connections):
    """
    LeetCode 1135: Minimum Cost to Connect All Cities
    """
    # Kruskal's algorithm
    connections.sort(key=lambda x: x[2])
    uf = UnionFind(n + 1)  # Cities are 1-indexed
    
    total_cost = 0
    edges_used = 0
    
    for city1, city2, cost in connections:
        if uf.union(city1, city2):
            total_cost += cost
            edges_used += 1
            if edges_used == n - 1:
                return total_cost
    
    return -1  # Can't connect all cities
```

### Problem 2: Optimize Water Distribution

```python
def min_cost_to_supply_water(n, wells, pipes):
    """
    LeetCode 1168: Optimize Water Distribution
    
    Trick: Add virtual node 0 connected to each house
    with edge weight = well cost
    """
    edges = []
    
    # Add virtual edges (building wells)
    for i, cost in enumerate(wells):
        edges.append((0, i + 1, cost))
    
    # Add pipe edges
    for house1, house2, cost in pipes:
        edges.append((house1, house2, cost))
    
    # Kruskal's MST on n+1 vertices (including virtual node)
    edges.sort(key=lambda x: x[2])
    uf = UnionFind(n + 1)
    
    total_cost = 0
    for u, v, cost in edges:
        if uf.union(u, v):
            total_cost += cost
    
    return total_cost
```

### Problem 3: Find Critical and Pseudo-Critical Edges

```python
def find_critical_and_pseudo_critical_edges(n, edges):
    """
    LeetCode 1489
    Critical: Removing it increases MST weight
    Pseudo-critical: Can be in some MST but not all
    """
    # Add original indices
    indexed_edges = [(u, v, w, i) for i, (u, v, w) in enumerate(edges)]
    indexed_edges.sort(key=lambda x: x[2])
    
    def find_mst(n, edges, exclude=-1, include=-1):
        """Find MST weight, optionally excluding/including an edge"""
        uf = UnionFind(n)
        weight = 0
        
        # Force include edge first
        if include != -1:
            u, v, w, _ = indexed_edges[include]
            uf.union(u, v)
            weight += w
        
        for i, (u, v, w, _) in enumerate(indexed_edges):
            if i == exclude or i == include:
                continue
            if uf.union(u, v):
                weight += w
        
        # Check if all connected
        root = uf.find(0)
        if any(uf.find(i) != root for i in range(n)):
            return float('inf')
        
        return weight
    
    original_mst = find_mst(n, indexed_edges)
    
    critical = []
    pseudo_critical = []
    
    for i in range(len(edges)):
        # Check if critical (removing increases weight)
        if find_mst(n, indexed_edges, exclude=i) > original_mst:
            critical.append(indexed_edges[i][3])
        # Check if pseudo-critical (including doesn't increase weight)
        elif find_mst(n, indexed_edges, include=i) == original_mst:
            pseudo_critical.append(indexed_edges[i][3])
    
    return [critical, pseudo_critical]
```

---

## 7.9 Summary

### Key Takeaways

```
MST Essentials:
1. Connects all V vertices with V-1 edges
2. Minimizes total edge weight
3. May not be unique

Kruskal's: Sort edges, add if no cycle (use Union-Find)
          O(E log E), best for sparse graphs

Prim's: Grow from vertex, add minimum edge to tree (use heap)
        O((V+E) log V), best for dense graphs

Both work because of the Cut Property:
The minimum edge crossing any cut is in some MST.
```

### Quick Reference

```python
# Kruskal's Template
def kruskal(n, edges):
    edges.sort(key=lambda x: x[2])
    uf = UnionFind(n)
    mst_weight = 0
    
    for u, v, w in edges:
        if uf.union(u, v):
            mst_weight += w
    
    return mst_weight

# Prim's Template
def prim(n, graph):
    in_mst = [False] * n
    pq = [(0, 0)]
    mst_weight = 0
    
    while pq:
        w, u = heapq.heappop(pq)
        if in_mst[u]:
            continue
        in_mst[u] = True
        mst_weight += w
        for weight, v in graph[u]:
            if not in_mst[v]:
                heapq.heappush(pq, (weight, v))
    
    return mst_weight
```

---

## 7.10 Practice Problems

1. Min Cost to Connect All Points (LC 1584)
2. Connecting Cities With Minimum Cost (LC 1135)
3. Optimize Water Distribution in a Village (LC 1168)
4. Find Critical and Pseudo-Critical Edges (LC 1489)
5. Minimum Spanning Tree (basic implementation)
6. Number of Operations to Make Network Connected (LC 1319)
