# Chapter 14: Network Flow
## Maximum Flow and Minimum Cut Problems

---

## 14.1 Introduction to Network Flow

### The Problem

Given a **directed graph** with:
- A **source** vertex (s) - where flow originates
- A **sink** vertex (t) - where flow terminates
- **Capacity** on each edge - maximum flow that can pass through

Find the **maximum flow** that can be sent from source to sink.

```
Network Flow Visualization:

        ┌──── 10 ────┐
        │            ▼
       (A)          (B)
        │            │
       5│            │8
        │            │
        ▼            ▼
  S ── 15 ──→(C)── 10 ──→(D)── 15 ──→ T
                     │            ▲
                    4│            │
                     │            │
                     ▼            │
                    (E)─── 10 ────┘

Capacities shown on edges.
Goal: Maximize flow from S to T.
```

### Real-World Applications

```
1. TRANSPORTATION
   - Cities = vertices
   - Roads = edges
   - Capacity = road capacity (vehicles/hour)
   - Find: Maximum traffic flow

2. NETWORK BANDWIDTH
   - Routers = vertices
   - Cables = edges
   - Capacity = bandwidth
   - Find: Maximum data transfer rate

3. BIPARTITE MATCHING (as flow!)
   - Add source connected to all left vertices
   - Add sink connected to all right vertices
   - All capacities = 1
   - Max flow = Maximum matching

4. PROJECT SELECTION
   - Dependencies between projects
   - Profits and costs
   - Min cut = optimal selection
```

---

## 14.2 Key Concepts

### Flow Properties

```
┌─────────────────────────────────────────────────────────────────┐
│ FLOW CONSTRAINTS                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│ 1. CAPACITY CONSTRAINT                                          │
│    0 ≤ flow(u,v) ≤ capacity(u,v)                               │
│    Flow on edge cannot exceed its capacity                      │
│                                                                 │
│ 2. FLOW CONSERVATION                                            │
│    For all vertices except s and t:                             │
│    Σ flow_in = Σ flow_out                                      │
│    (Flow in equals flow out)                                    │
│                                                                 │
│ 3. SKEW SYMMETRY                                                │
│    flow(u,v) = -flow(v,u)                                      │
│    (Used in residual graph representation)                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Residual Graph

The **residual graph** shows remaining capacity on each edge.

```
Original Graph:
    u ──── capacity: 10 ────→ v
           flow: 6

Residual Graph:
    u ──── residual: 4 ────→ v    (can send 4 more)
    u ←─── residual: 6 ───── v    (can "undo" 6)

Residual capacity:
- Forward: capacity - flow = 10 - 6 = 4
- Backward: flow = 6 (can cancel existing flow)
```

### Augmenting Path

An **augmenting path** is a path from source to sink in the residual graph where all edges have positive residual capacity.

```
Residual Graph:
    S ──5──→ A ──3──→ T
    │        ↑
    2        4
    │        │
    └──→ B ──┘

Augmenting paths:
1. S → A → T (bottleneck = min(5,3) = 3)
2. S → B → A → T (bottleneck = min(2,4,3) = 2)

Finding augmenting paths and pushing flow = Ford-Fulkerson method!
```

---

## 14.3 Ford-Fulkerson Method

### Algorithm

```
1. Start with zero flow
2. While there exists an augmenting path from s to t:
   a. Find the path
   b. Find bottleneck (minimum residual capacity on path)
   c. Augment flow along the path by bottleneck amount
   d. Update residual graph
3. Return total flow
```

### Visual Walkthrough

```
Initial Graph (capacities):
         10
    S ────────→ A
    │           │
   10           10
    │           │
    ▼     5     ▼
    B ────────→ T

Step 1: Find augmenting path S → A → T
Bottleneck = min(10, 10) = 10
Push 10 units of flow

After Step 1:
         0 (residual: 10-10=0, back=10)
    S ─ ─ ─ ─ → A
    │           │
   10           0 (residual: 10-10=0, back=10)
    │           │
    ▼     5     ▼
    B ────────→ T

Flow so far: 10

Step 2: Find augmenting path S → B → T
Bottleneck = min(10, 5) = 5
Push 5 units of flow

After Step 2:
         0
    S ─ ─ ─ ─ → A
    │           │
    5           0
    │           │
    ▼     0     ▼
    B ─ ─ ─ ─→ T

Flow so far: 10 + 5 = 15

Step 3: No more augmenting paths!
Maximum flow = 15
```

### Implementation: Edmonds-Karp (BFS-based Ford-Fulkerson)

```python
from collections import deque

def max_flow_edmonds_karp(capacity, source, sink, n):
    """
    Edmonds-Karp algorithm (Ford-Fulkerson with BFS)
    
    Args:
        capacity: n×n matrix where capacity[u][v] = edge capacity
        source: source vertex
        sink: sink vertex
        n: number of vertices
    
    Returns:
        Maximum flow value
    """
    # Create residual capacity matrix (copy of capacity)
    residual = [row[:] for row in capacity]
    
    def bfs():
        """Find augmenting path using BFS, return path if exists"""
        parent = [-1] * n
        visited = [False] * n
        
        queue = deque([source])
        visited[source] = True
        
        while queue:
            u = queue.popleft()
            
            for v in range(n):
                if not visited[v] and residual[u][v] > 0:
                    visited[v] = True
                    parent[v] = u
                    
                    if v == sink:
                        return parent
                    
                    queue.append(v)
        
        return None
    
    total_flow = 0
    
    while True:
        # Find augmenting path
        parent = bfs()
        
        if parent is None:
            break  # No more augmenting paths
        
        # Find bottleneck (minimum residual capacity on path)
        path_flow = float('inf')
        v = sink
        while v != source:
            u = parent[v]
            path_flow = min(path_flow, residual[u][v])
            v = u
        
        # Update residual capacities
        v = sink
        while v != source:
            u = parent[v]
            residual[u][v] -= path_flow  # Decrease forward edge
            residual[v][u] += path_flow  # Increase backward edge
            v = u
        
        total_flow += path_flow
    
    return total_flow


# Example
n = 4  # Vertices: 0=S, 1=A, 2=B, 3=T
capacity = [
    [0, 10, 10, 0],   # S→A:10, S→B:10
    [0, 0, 0, 10],    # A→T:10
    [0, 0, 0, 5],     # B→T:5
    [0, 0, 0, 0]      # T (sink)
]

result = max_flow_edmonds_karp(capacity, 0, 3, 4)
print(f"Maximum flow: {result}")  # 15
```

### Complexity

```
Edmonds-Karp (BFS-based):
- Each BFS: O(E)
- Number of augmenting paths: O(V × E)
- Total: O(V × E²)

Why O(V × E) augmenting paths?
- BFS finds shortest augmenting path
- Shortest path length can only increase
- At most O(E) times before length increases
- Length can increase at most O(V) times
```

---

## 14.4 Adjacency List Implementation

```python
from collections import defaultdict, deque

class MaxFlow:
    """
    Max Flow implementation using adjacency list
    More efficient for sparse graphs
    """
    
    def __init__(self, n):
        self.n = n
        self.graph = defaultdict(list)  # graph[u] = [(v, capacity, rev_idx), ...]
    
    def add_edge(self, u, v, capacity):
        """Add directed edge u→v with given capacity"""
        # Forward edge
        self.graph[u].append([v, capacity, len(self.graph[v])])
        # Backward edge (for residual graph)
        self.graph[v].append([u, 0, len(self.graph[u]) - 1])
    
    def bfs(self, source, sink, parent):
        """BFS to find augmenting path"""
        visited = [False] * self.n
        visited[source] = True
        queue = deque([source])
        
        while queue:
            u = queue.popleft()
            
            for i, (v, cap, _) in enumerate(self.graph[u]):
                if not visited[v] and cap > 0:
                    visited[v] = True
                    parent[v] = (u, i)
                    
                    if v == sink:
                        return True
                    
                    queue.append(v)
        
        return False
    
    def max_flow(self, source, sink):
        """Compute maximum flow from source to sink"""
        parent = [None] * self.n
        total_flow = 0
        
        while self.bfs(source, sink, parent):
            # Find bottleneck
            path_flow = float('inf')
            v = sink
            
            while v != source:
                u, idx = parent[v]
                path_flow = min(path_flow, self.graph[u][idx][1])
                v = u
            
            # Update residual capacities
            v = sink
            while v != source:
                u, idx = parent[v]
                rev_idx = self.graph[u][idx][2]
                
                self.graph[u][idx][1] -= path_flow      # Decrease forward
                self.graph[v][rev_idx][1] += path_flow  # Increase backward
                
                v = u
            
            total_flow += path_flow
        
        return total_flow


# Example Usage
mf = MaxFlow(6)
# Vertices: 0=S, 1=A, 2=B, 3=C, 4=D, 5=T
mf.add_edge(0, 1, 10)  # S→A
mf.add_edge(0, 2, 10)  # S→B
mf.add_edge(1, 3, 4)   # A→C
mf.add_edge(1, 2, 2)   # A→B
mf.add_edge(2, 4, 8)   # B→D
mf.add_edge(3, 5, 10)  # C→T
mf.add_edge(4, 3, 6)   # D→C
mf.add_edge(4, 5, 10)  # D→T

print(f"Maximum flow: {mf.max_flow(0, 5)}")  # 18
```

---

## 14.5 Max-Flow Min-Cut Theorem

### The Theorem

```
┌─────────────────────────────────────────────────────────────────┐
│ MAX-FLOW MIN-CUT THEOREM                                         │
│                                                                 │
│ In any flow network:                                            │
│ Maximum Flow = Minimum Cut                                       │
│                                                                 │
│ A CUT is a partition of vertices into two sets S and T          │
│ where source ∈ S and sink ∈ T                                   │
│                                                                 │
│ Cut capacity = sum of capacities of edges from S to T           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Visual Example

```
Network:
         10
    S ────────→ A
    │           │
   10           10
    │           │
    ▼     5     ▼
    B ────────→ T

Cut 1: S = {S}, T = {A, B, T}
Edges crossing: S→A (10), S→B (10)
Cut capacity = 20

Cut 2: S = {S, A, B}, T = {T}
Edges crossing: A→T (10), B→T (5)
Cut capacity = 15  ← This is minimum!

Maximum flow = 15 = Minimum cut capacity ✓
```

### Finding Minimum Cut

```python
def min_cut(capacity, source, sink, n):
    """
    Find minimum cut edges after computing max flow
    """
    # First, compute max flow (modifies residual graph)
    residual = [row[:] for row in capacity]
    
    # ... (run max flow algorithm on residual)
    # After max flow, residual graph has updated capacities
    
    # BFS from source in residual graph
    # Vertices reachable from source are in set S
    visited = [False] * n
    queue = deque([source])
    visited[source] = True
    
    while queue:
        u = queue.popleft()
        for v in range(n):
            if not visited[v] and residual[u][v] > 0:
                visited[v] = True
                queue.append(v)
    
    # Find cut edges: edges from visited to unvisited
    # with positive original capacity
    cut_edges = []
    for u in range(n):
        for v in range(n):
            if visited[u] and not visited[v] and capacity[u][v] > 0:
                cut_edges.append((u, v))
    
    return cut_edges
```

---

## 14.6 Applications

### Application 1: Bipartite Matching as Max Flow

```python
def max_bipartite_matching_flow(left, right, edges):
    """
    Solve maximum bipartite matching using max flow
    
    Args:
        left: number of vertices on left side
        right: number of vertices on right side
        edges: list of (l, r) edges between sides
    
    Returns:
        Maximum matching size
    """
    # Create flow network
    # Vertices: 0 = source, 1..left = left side, 
    #          left+1..left+right = right side, left+right+1 = sink
    
    source = 0
    sink = left + right + 1
    n = sink + 1
    
    mf = MaxFlow(n)
    
    # Source to all left vertices (capacity 1)
    for i in range(1, left + 1):
        mf.add_edge(source, i, 1)
    
    # All right vertices to sink (capacity 1)
    for i in range(left + 1, left + right + 1):
        mf.add_edge(i, sink, 1)
    
    # Edges between left and right (capacity 1)
    for l, r in edges:
        # l is 0-indexed, map to 1-indexed
        # r is 0-indexed, map to left+1+r
        mf.add_edge(l + 1, left + 1 + r, 1)
    
    return mf.max_flow(source, sink)


# Example: Workers and Jobs
# Workers: 0, 1, 2 (left side)
# Jobs: 0, 1, 2 (right side)
edges = [(0, 0), (0, 1), (1, 0), (1, 2), (2, 1), (2, 2)]
result = max_bipartite_matching_flow(3, 3, edges)
print(f"Maximum matching: {result}")  # 3
```

### Application 2: Edge-Disjoint Paths

```python
def max_edge_disjoint_paths(n, edges, source, sink):
    """
    Find maximum number of edge-disjoint paths from source to sink
    
    Solution: Each edge has capacity 1
    Max flow = number of edge-disjoint paths
    """
    mf = MaxFlow(n)
    
    for u, v in edges:
        mf.add_edge(u, v, 1)
    
    return mf.max_flow(source, sink)
```

### Application 3: Vertex-Disjoint Paths

```python
def max_vertex_disjoint_paths(n, edges, source, sink):
    """
    Find maximum number of vertex-disjoint paths from source to sink
    
    Solution: Split each vertex v into v_in and v_out
    Add edge v_in → v_out with capacity 1
    """
    # Vertex v becomes: v_in = 2*v, v_out = 2*v + 1
    mf = MaxFlow(2 * n)
    
    # Internal vertex edges (capacity 1)
    for v in range(n):
        if v != source and v != sink:
            mf.add_edge(2*v, 2*v + 1, 1)  # v_in → v_out
        else:
            # Source and sink have infinite internal capacity
            mf.add_edge(2*v, 2*v + 1, float('inf'))
    
    # Original edges
    for u, v in edges:
        mf.add_edge(2*u + 1, 2*v, 1)  # u_out → v_in
    
    return mf.max_flow(2*source, 2*sink + 1)
```

---

## 14.7 Dinic's Algorithm (Faster Max Flow)

### Concept

Dinic's algorithm improves upon Edmonds-Karp by:
1. Building a **level graph** using BFS
2. Finding **blocking flow** using DFS (multiple augmenting paths at once)

```
Level Graph:
Vertices are assigned levels based on BFS distance from source.
Only edges going from level i to level i+1 are included.

This eliminates "useless" edges that don't help reach sink faster.
```

### Implementation

```python
from collections import deque

class Dinic:
    """
    Dinic's Algorithm for Maximum Flow
    Time: O(V² × E)
    For unit capacity graphs: O(E × √V)
    """
    
    def __init__(self, n):
        self.n = n
        self.graph = [[] for _ in range(n)]
    
    def add_edge(self, u, v, cap):
        self.graph[u].append([v, cap, len(self.graph[v])])
        self.graph[v].append([u, 0, len(self.graph[u]) - 1])
    
    def bfs(self, source, sink):
        """Build level graph"""
        self.level = [-1] * self.n
        self.level[source] = 0
        queue = deque([source])
        
        while queue:
            u = queue.popleft()
            for v, cap, _ in self.graph[u]:
                if cap > 0 and self.level[v] < 0:
                    self.level[v] = self.level[u] + 1
                    queue.append(v)
        
        return self.level[sink] >= 0
    
    def dfs(self, u, sink, pushed):
        """Find blocking flow"""
        if u == sink:
            return pushed
        
        while self.iter[u] < len(self.graph[u]):
            edge = self.graph[u][self.iter[u]]
            v, cap, rev = edge
            
            if cap > 0 and self.level[v] == self.level[u] + 1:
                d = self.dfs(v, sink, min(pushed, cap))
                
                if d > 0:
                    edge[1] -= d
                    self.graph[v][rev][1] += d
                    return d
            
            self.iter[u] += 1
        
        return 0
    
    def max_flow(self, source, sink):
        flow = 0
        
        while self.bfs(source, sink):
            self.iter = [0] * self.n
            
            while True:
                f = self.dfs(source, sink, float('inf'))
                if f == 0:
                    break
                flow += f
        
        return flow


# Example
dinic = Dinic(4)
dinic.add_edge(0, 1, 10)
dinic.add_edge(0, 2, 10)
dinic.add_edge(1, 3, 10)
dinic.add_edge(2, 3, 5)
dinic.add_edge(1, 2, 2)

print(f"Maximum flow: {dinic.max_flow(0, 3)}")  # 15
```

### Complexity Comparison

| Algorithm | Time Complexity | Best For |
|-----------|-----------------|----------|
| Ford-Fulkerson (DFS) | O(E × max_flow) | Small flows |
| Edmonds-Karp (BFS) | O(V × E²) | General |
| Dinic's | O(V² × E) | General |
| Dinic's (unit cap) | O(E × √V) | Bipartite matching |

---

## 14.8 Common Interview Problems

### Problem 1: Maximum Flow (Template)

```python
def solve_max_flow(n, edges, source, sink):
    """
    Generic max flow problem solver
    edges: [(u, v, capacity), ...]
    """
    mf = MaxFlow(n)
    
    for u, v, cap in edges:
        mf.add_edge(u, v, cap)
    
    return mf.max_flow(source, sink)
```

### Problem 2: Escape from Grid (Multi-source Multi-sink)

```python
def can_escape(grid, guards, escapees):
    """
    Check if all escapees can reach border without crossing guards
    
    Solution:
    - Create super-source connected to all escapees
    - Create super-sink connected to all border cells
    - Max flow ≥ number of escapees means all can escape
    """
    rows, cols = len(grid), len(grid[0])
    
    def cell_id(r, c):
        return r * cols + c
    
    n = rows * cols + 2
    source = rows * cols
    sink = rows * cols + 1
    
    mf = MaxFlow(n)
    
    # Connect source to escapees
    for r, c in escapees:
        mf.add_edge(source, cell_id(r, c), 1)
    
    # Connect border cells to sink
    for r in range(rows):
        for c in range(cols):
            if r == 0 or r == rows-1 or c == 0 or c == cols-1:
                if (r, c) not in guards:
                    mf.add_edge(cell_id(r, c), sink, 1)
    
    # Connect adjacent cells
    for r in range(rows):
        for c in range(cols):
            if (r, c) in guards:
                continue
            for dr, dc in [(0,1), (1,0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols:
                    if (nr, nc) not in guards:
                        mf.add_edge(cell_id(r, c), cell_id(nr, nc), 1)
                        mf.add_edge(cell_id(nr, nc), cell_id(r, c), 1)
    
    return mf.max_flow(source, sink) >= len(escapees)
```

---

## 14.9 Summary

### Key Takeaways

```
Network Flow Essentials:
- Find maximum flow from source to sink
- Respects capacity constraints
- Conserves flow at intermediate vertices

Key Algorithms:
- Ford-Fulkerson: Find augmenting paths, push flow
- Edmonds-Karp: BFS for augmenting paths, O(VE²)
- Dinic's: Level graph + blocking flow, O(V²E)

Max-Flow Min-Cut Theorem:
- Maximum flow = Minimum cut capacity
- Finding min cut: BFS from source in residual graph

Applications:
- Bipartite matching
- Edge/vertex disjoint paths
- Network reliability
- Assignment problems
```

### Quick Reference

```python
# Max Flow Template (Edmonds-Karp)
def max_flow(capacity, source, sink, n):
    residual = [row[:] for row in capacity]
    total = 0
    
    while True:
        # BFS for augmenting path
        parent = bfs(residual, source, sink)
        if not parent:
            break
        
        # Find bottleneck
        flow = trace_and_find_min(parent, residual, source, sink)
        
        # Update residual
        update_residual(parent, residual, source, sink, flow)
        
        total += flow
    
    return total
```

---

## 14.10 Practice Problems

1. Maximum Flow (basic implementation)
2. Minimum Cut (find the cut edges)
3. Bipartite Matching via Flow
4. Edge-Disjoint Paths
5. Circulation with Demands
6. Project Selection Problem
