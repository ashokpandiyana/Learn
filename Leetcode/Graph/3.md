# Chapter 3: Breadth-First Search (BFS)
## The Foundation of Graph Exploration

---

## 3.1 What is BFS?

### Concept

**Breadth-First Search (BFS)** explores a graph **level by level**, visiting all neighbors of a vertex before moving to the next level.

Think of it like ripples in a pond - you explore outward in concentric circles.

```
Starting from vertex 0:

Level 0:        Level 1:        Level 2:
    (0)             (0)             (0)
                   / | \           / | \
                 (1)(2)(3)       (1)(2)(3)
                                  |       |
                                 (4)     (5)

First visit 0, then ALL neighbors (1,2,3), then THEIR neighbors (4,5)
```

### Visual: BFS vs DFS

```
Graph:          BFS Order:           DFS Order:
    (0)         0 ‚Üí 1 ‚Üí 2 ‚Üí 3        0 ‚Üí 1 ‚Üí 3 ‚Üí 2
   / \          (level by level)     (depth first)
 (1) (2)
  |
 (3)

BFS visits ALL of level N before level N+1
DFS goes as DEEP as possible before backtracking
```

---

## 3.2 Core BFS Algorithm

### The Key Data Structure: Queue

BFS uses a **queue** (First-In-First-Out) to maintain the order of exploration.

```
Queue behavior:
[1, 2, 3]  ‚Üí  pop(1)  ‚Üí  [2, 3]  ‚Üí  add(4)  ‚Üí  [2, 3, 4]
  front                             back

First In = First Out
Items added last are processed last ‚Üí Level order maintained!
```

### Basic BFS Template

```python
from collections import deque

def bfs(graph, start):
    """
    Basic BFS traversal
    Returns: list of vertices in BFS order
    """
    visited = set()      # Track visited vertices
    queue = deque()      # Queue for BFS
    result = []          # Store traversal order
    
    # Initialize: mark start as visited and enqueue
    visited.add(start)
    queue.append(start)
    
    while queue:
        # Dequeue a vertex
        vertex = queue.popleft()
        result.append(vertex)
        
        # Visit all unvisited neighbors
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)      # Mark visited BEFORE enqueueing
                queue.append(neighbor)
    
    return result

# Example
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 4],
    3: [1],
    4: [1, 2]
}

print(bfs(graph, 0))  # [0, 1, 2, 3, 4]
```

### Step-by-Step Execution

```
Graph:
    (0)
   / \
 (1) (2)
 /|   |
(3)(4)-+

Starting BFS from vertex 0:

Step 1: Initialize
        visited = {0}
        queue = [0]
        
Step 2: Process 0
        Dequeue 0
        Add neighbors 1, 2 to queue
        visited = {0, 1, 2}
        queue = [1, 2]
        
Step 3: Process 1
        Dequeue 1
        Add neighbors 3, 4 (0 already visited)
        visited = {0, 1, 2, 3, 4}
        queue = [2, 3, 4]
        
Step 4: Process 2
        Dequeue 2
        4 already visited, skip
        queue = [3, 4]
        
Step 5: Process 3
        Dequeue 3
        1 already visited
        queue = [4]
        
Step 6: Process 4
        Dequeue 4
        1, 2 already visited
        queue = []
        
DONE! BFS order: 0 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 4
```

> ‚ö†Ô∏è **CRITICAL MISTAKE TO AVOID**: Always mark a vertex as visited **WHEN YOU ADD IT TO THE QUEUE**, not when you process it. This prevents adding the same vertex multiple times.

```python
# WRONG ‚ùå
if neighbor not in visited:
    queue.append(neighbor)
# Later: visited.add(vertex) when dequeuing
# Problem: Same vertex can be added to queue multiple times!

# CORRECT ‚úì
if neighbor not in visited:
    visited.add(neighbor)    # Mark visited immediately
    queue.append(neighbor)
```

---

## 3.3 Time and Space Complexity

### Analysis

```
BFS visits each vertex exactly once: O(V) vertex processing
BFS examines each edge exactly once (or twice for undirected): O(E) edge checks

Total Time: O(V + E)
```

### Space Complexity

```
visited set: O(V) - stores all vertices
queue: O(V) - at worst, entire level in queue
        ‚Üì
       (0)
      / | \        If vertex 0 connects to all others,
    (1)(2)(3)...   queue holds V-1 vertices at once

Total Space: O(V)
```

### Complexity Summary

| Aspect | Complexity |
|--------|------------|
| Time | O(V + E) |
| Space | O(V) |
| Queue operations | O(1) each with deque |

---

## 3.4 BFS for Shortest Path (Unweighted)

### Why BFS Finds Shortest Path

In an **unweighted graph**, BFS naturally finds the shortest path because it explores vertices **in order of their distance** from the source.

```
Level 0: distance 0 from source
Level 1: distance 1 from source
Level 2: distance 2 from source
...

First time we reach a vertex = shortest path to that vertex!
```

### Shortest Path Template

```python
from collections import deque

def bfs_shortest_path(graph, start, end):
    """
    Find shortest path from start to end in unweighted graph
    Returns: (distance, path) or (-1, []) if no path
    """
    if start == end:
        return (0, [start])
    
    visited = {start}
    queue = deque([(start, [start])])  # (current_vertex, path_so_far)
    
    while queue:
        vertex, path = queue.popleft()
        
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                new_path = path + [neighbor]
                
                if neighbor == end:
                    return (len(new_path) - 1, new_path)
                
                visited.add(neighbor)
                queue.append((neighbor, new_path))
    
    return (-1, [])  # No path found

# Example
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

distance, path = bfs_shortest_path(graph, 'A', 'F')
print(f"Distance: {distance}")  # 2
print(f"Path: {path}")          # ['A', 'C', 'F']
```

### Memory-Efficient Version (Using Parent Pointers)

```python
from collections import deque

def bfs_shortest_path_efficient(graph, start, end):
    """
    Memory-efficient shortest path using parent pointers
    """
    if start == end:
        return [start]
    
    visited = {start}
    parent = {start: None}  # Track how we reached each vertex
    queue = deque([start])
    
    while queue:
        vertex = queue.popleft()
        
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor] = vertex
                
                if neighbor == end:
                    # Reconstruct path
                    path = []
                    current = end
                    while current is not None:
                        path.append(current)
                        current = parent[current]
                    return path[::-1]  # Reverse to get start‚Üíend
                
                queue.append(neighbor)
    
    return []  # No path

# Example
path = bfs_shortest_path_efficient(graph, 'A', 'F')
print(path)  # ['A', 'C', 'F']
```

### Distance to All Vertices

```python
from collections import deque

def bfs_distances(graph, start):
    """
    Calculate shortest distance from start to ALL vertices
    """
    distances = {start: 0}
    queue = deque([start])
    
    while queue:
        vertex = queue.popleft()
        
        for neighbor in graph[vertex]:
            if neighbor not in distances:
                distances[neighbor] = distances[vertex] + 1
                queue.append(neighbor)
    
    return distances

# Example
distances = bfs_distances(graph, 'A')
print(distances)
# {'A': 0, 'B': 1, 'C': 1, 'D': 2, 'E': 2, 'F': 2}
```

---

## 3.5 BFS Patterns

### Pattern 1: Level-by-Level Processing

Process all vertices at the same level together. Essential for problems asking "minimum steps" or "level by level."

```python
from collections import deque

def bfs_level_by_level(graph, start):
    """
    Process graph level by level
    Returns: list of levels, each level is a list of vertices
    """
    visited = {start}
    queue = deque([start])
    levels = []
    
    while queue:
        level_size = len(queue)  # KEY: Capture current level size
        current_level = []
        
        for _ in range(level_size):  # Process exactly this many
            vertex = queue.popleft()
            current_level.append(vertex)
            
            for neighbor in graph[vertex]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        levels.append(current_level)
    
    return levels

# Example
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 5],
    3: [1],
    4: [1],
    5: [2]
}

levels = bfs_level_by_level(graph, 0)
print(levels)  # [[0], [1, 2], [3, 4, 5]]
```

```
Visualization:
Level 0:    (0)           ‚Üí [0]
           / \
Level 1: (1) (2)          ‚Üí [1, 2]
         /|   \
Level 2:(3)(4) (5)        ‚Üí [3, 4, 5]
```

### Pattern 2: Multi-Source BFS

Start BFS from **multiple sources simultaneously**. All sources start at level 0.

```python
from collections import deque

def multi_source_bfs(graph, sources):
    """
    BFS starting from multiple sources at once
    Returns: distance from NEAREST source to each vertex
    """
    distances = {}
    queue = deque()
    
    # Initialize all sources at distance 0
    for source in sources:
        distances[source] = 0
        queue.append(source)
    
    while queue:
        vertex = queue.popleft()
        
        for neighbor in graph[vertex]:
            if neighbor not in distances:
                distances[neighbor] = distances[vertex] + 1
                queue.append(neighbor)
    
    return distances

# Example: Find distance to nearest hospital
# Hospitals are at vertices 2 and 5
graph = {
    0: [1], 1: [0, 2, 3], 2: [1, 4], 
    3: [1], 4: [2, 5], 5: [4]
}
hospitals = [2, 5]

distances = multi_source_bfs(graph, hospitals)
print(distances)
# {2: 0, 5: 0, 1: 1, 4: 1, 0: 2, 3: 2}
# Vertex 0 is 2 steps from nearest hospital (2)
# Vertex 3 is 2 steps from nearest hospital (2)
```

```
Visualization:
Sources (hospitals) at 2 and 5:

(0)‚Äî(1)‚Äî(2*)‚Äî(4)‚Äî(5*)
     |
    (3)

* = source
Distances spread outward from BOTH sources simultaneously
```

**Classic Problems:**
- üçä **Rotting Oranges**: Multi-source from all rotten oranges
- üß± **Walls and Gates**: Multi-source from all gates
- üìä **01 Matrix**: Multi-source from all zeros

### Pattern 3: BFS on Grid (2D Matrix)

Treat each cell as a vertex, adjacent cells as edges.

```python
from collections import deque

def bfs_grid(grid, start_row, start_col):
    """
    BFS on a 2D grid
    Returns: visited cells in BFS order
    """
    if not grid or not grid[0]:
        return []
    
    rows, cols = len(grid), len(grid[0])
    
    # 4-directional movement: right, left, down, up
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    visited = set()
    visited.add((start_row, start_col))
    queue = deque([(start_row, start_col)])
    result = []
    
    while queue:
        row, col = queue.popleft()
        result.append((row, col))
        
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            # Check bounds
            if 0 <= new_row < rows and 0 <= new_col < cols:
                # Check if not visited and not obstacle
                if (new_row, new_col) not in visited:
                    if grid[new_row][new_col] != '#':  # '#' = obstacle
                        visited.add((new_row, new_col))
                        queue.append((new_row, new_col))
    
    return result

# Example
grid = [
    ['.', '.', '#', '.'],
    ['.', '#', '.', '.'],
    ['.', '.', '.', '#'],
    ['#', '.', '.', '.']
]

path = bfs_grid(grid, 0, 0)
print(path)
# [(0, 0), (0, 1), (1, 0), (2, 0), (2, 1), (3, 1), (2, 2), (3, 2), (1, 2), (3, 3), (0, 3), (1, 3)]
```

### Grid BFS with Distance Tracking

```python
from collections import deque

def shortest_path_grid(grid, start, end):
    """
    Find shortest path in grid from start to end
    start, end: (row, col) tuples
    Returns: minimum distance or -1 if impossible
    """
    rows, cols = len(grid), len(grid[0])
    sr, sc = start
    er, ec = end
    
    if grid[sr][sc] == '#' or grid[er][ec] == '#':
        return -1
    
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    visited = set()
    visited.add(start)
    queue = deque([(sr, sc, 0)])  # (row, col, distance)
    
    while queue:
        row, col, dist = queue.popleft()
        
        if (row, col) == end:
            return dist
        
        for dr, dc in directions:
            nr, nc = row + dr, col + dc
            
            if 0 <= nr < rows and 0 <= nc < cols:
                if (nr, nc) not in visited and grid[nr][nc] != '#':
                    visited.add((nr, nc))
                    queue.append((nr, nc, dist + 1))
    
    return -1  # No path found

# Example
grid = [
    ['.', '.', '.', '.'],
    ['.', '#', '#', '.'],
    ['.', '.', '.', '.'],
]

distance = shortest_path_grid(grid, (0, 0), (2, 3))
print(f"Shortest path: {distance}")  # 5
```

```
Grid visualization:
. . . .     Start: (0,0) marked 'S'
. # # .     End: (2,3) marked 'E'
. . . .

S ‚Üí ‚Üí ‚Üì     Path: (0,0)‚Üí(0,1)‚Üí(0,2)‚Üí(0,3)‚Üí(1,3)‚Üí(2,3)
. # # ‚Üì     Distance: 5
. . . E
```

### Pattern 4: BFS with State

Sometimes we need to track additional state beyond just the vertex.

```python
from collections import deque

def bfs_with_keys(grid, start):
    """
    BFS where state includes collected keys
    Example: Maze with locked doors and keys
    """
    rows, cols = len(grid), len(grid[0])
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    # State: (row, col, keys_collected)
    # keys_collected is a frozenset of key characters
    
    initial_state = (start[0], start[1], frozenset())
    visited = {initial_state}
    queue = deque([(start[0], start[1], frozenset(), 0)])  # +distance
    
    while queue:
        row, col, keys, dist = queue.popleft()
        cell = grid[row][col]
        
        # Collect key if present
        if cell.islower():  # 'a', 'b', etc. are keys
            keys = keys | {cell}
        
        # Check if goal reached (found all keys, etc.)
        # ...
        
        for dr, dc in directions:
            nr, nc = row + dr, col + dc
            
            if 0 <= nr < rows and 0 <= nc < cols:
                next_cell = grid[nr][nc]
                
                # Can't go through walls
                if next_cell == '#':
                    continue
                
                # Can't go through locked door without key
                if next_cell.isupper() and next_cell.lower() not in keys:
                    continue
                
                new_state = (nr, nc, keys)
                if new_state not in visited:
                    visited.add(new_state)
                    queue.append((nr, nc, keys, dist + 1))
    
    return -1  # Goal not reached
```

---

## 3.6 Common BFS Interview Problems

### Problem 1: Number of Islands

```python
from collections import deque

def numIslands(grid):
    """
    Count number of islands in a grid
    '1' = land, '0' = water
    """
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    visited = set()
    islands = 0
    
    def bfs(r, c):
        queue = deque([(r, c)])
        visited.add((r, c))
        
        while queue:
            row, col = queue.popleft()
            directions = [(0,1), (0,-1), (1,0), (-1,0)]
            
            for dr, dc in directions:
                nr, nc = row + dr, col + dc
                if (0 <= nr < rows and 0 <= nc < cols and 
                    (nr, nc) not in visited and grid[nr][nc] == '1'):
                    visited.add((nr, nc))
                    queue.append((nr, nc))
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1' and (r, c) not in visited:
                bfs(r, c)
                islands += 1
    
    return islands

# Example
grid = [
    ['1','1','0','0','0'],
    ['1','1','0','0','0'],
    ['0','0','1','0','0'],
    ['0','0','0','1','1']
]
print(numIslands(grid))  # 3
```

### Problem 2: Rotting Oranges

```python
from collections import deque

def orangesRotting(grid):
    """
    Multi-source BFS from all rotten oranges
    Return: minutes until all oranges rotten, or -1 if impossible
    """
    rows, cols = len(grid), len(grid[0])
    queue = deque()
    fresh = 0
    
    # Find all rotten oranges and count fresh
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:
                queue.append((r, c, 0))  # (row, col, time)
            elif grid[r][c] == 1:
                fresh += 1
    
    if fresh == 0:
        return 0
    
    directions = [(0,1), (0,-1), (1,0), (-1,0)]
    max_time = 0
    
    while queue:
        r, c, time = queue.popleft()
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:
                grid[nr][nc] = 2  # Mark as rotten
                fresh -= 1
                queue.append((nr, nc, time + 1))
                max_time = max(max_time, time + 1)
    
    return max_time if fresh == 0 else -1

# Example
grid = [
    [2,1,1],
    [1,1,0],
    [0,1,1]
]
print(orangesRotting(grid))  # 4
```

### Problem 3: Word Ladder

```python
from collections import deque

def ladderLength(beginWord, endWord, wordList):
    """
    Find shortest transformation sequence from beginWord to endWord
    Each step changes one letter, intermediate words must be in wordList
    """
    wordSet = set(wordList)
    if endWord not in wordSet:
        return 0
    
    queue = deque([(beginWord, 1)])  # (word, length)
    visited = {beginWord}
    
    while queue:
        word, length = queue.popleft()
        
        if word == endWord:
            return length
        
        # Try changing each character
        for i in range(len(word)):
            for c in 'abcdefghijklmnopqrstuvwxyz':
                if c != word[i]:
                    newWord = word[:i] + c + word[i+1:]
                    
                    if newWord in wordSet and newWord not in visited:
                        visited.add(newWord)
                        queue.append((newWord, length + 1))
    
    return 0  # No transformation possible

# Example
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log","cog"]
print(ladderLength(beginWord, endWord, wordList))  # 5
# hit ‚Üí hot ‚Üí dot ‚Üí dog ‚Üí cog
```

---

## 3.7 BFS Properties Summary

### When to Use BFS

| Scenario | Why BFS? |
|----------|----------|
| Shortest path (unweighted) | Level-by-level = shortest distance |
| Minimum steps/moves | Each level = one step |
| Level order traversal | Natural level exploration |
| Finding nearest X | First found = nearest |
| Spreading/propagation | Multi-source BFS |
| Checking connectivity | Explore all reachable |

### BFS vs DFS Quick Comparison

| Aspect | BFS | DFS |
|--------|-----|-----|
| Data structure | Queue | Stack/Recursion |
| Exploration | Wide first | Deep first |
| Shortest path | ‚úì Yes (unweighted) | ‚úó No |
| Space (worst) | O(width) | O(depth) |
| Memory for trees | More (wide) | Less (deep) |
| Use for | Shortest path, levels | Paths, cycles, backtrack |

---

## 3.8 Common Mistakes and Tips

### Mistake 1: Marking Visited Too Late

```python
# WRONG ‚ùå
while queue:
    node = queue.popleft()
    if node in visited:  # Checking AFTER dequeue
        continue
    visited.add(node)
    # ...

# CORRECT ‚úì
visited.add(start)  # Mark before adding to queue
queue.append(start)
while queue:
    node = queue.popleft()
    for neighbor in graph[node]:
        if neighbor not in visited:
            visited.add(neighbor)  # Mark IMMEDIATELY
            queue.append(neighbor)
```

### Mistake 2: Using List Instead of Deque

```python
# SLOW ‚ùå
queue = []
queue.append(item)
item = queue.pop(0)  # O(n) operation!

# FAST ‚úì
from collections import deque
queue = deque()
queue.append(item)
item = queue.popleft()  # O(1) operation
```

### Mistake 3: Forgetting Disconnected Components

```python
# Handle disconnected graphs by starting BFS from each unvisited vertex
def bfs_all_components(graph):
    visited = set()
    components = []
    
    for vertex in graph:
        if vertex not in visited:
            component = bfs(graph, vertex, visited)
            components.append(component)
    
    return components
```

---

## 3.9 Practice Problems (Ordered by Difficulty)

### Easy
1. **Flood Fill** (LC 733)
2. **Number of Islands** (LC 200)
3. **Maximum Depth of N-ary Tree** (LC 559)

### Medium
1. **Rotting Oranges** (LC 994)
2. **01 Matrix** (LC 542)
3. **Word Ladder** (LC 127)
4. **Shortest Path in Binary Matrix** (LC 1091)
5. **Open the Lock** (LC 752)
6. **Snakes and Ladders** (LC 909)
7. **Minimum Knight Moves** (LC 1197)

### Hard
1. **Word Ladder II** (LC 126)
2. **Shortest Path to Get All Keys** (LC 864)
3. **Sliding Puzzle** (LC 773)
4. **Bus Routes** (LC 815)

---

## 3.10 Quick Reference Template

```python
from collections import deque

def bfs_template(graph, start):
    """
    Universal BFS template - customize as needed
    """
    # 1. Initialize
    visited = set([start])
    queue = deque([start])
    level = 0
    
    # 2. BFS Loop
    while queue:
        # Optional: Process level by level
        level_size = len(queue)
        
        for _ in range(level_size):
            node = queue.popleft()
            
            # 3. Process current node
            # (check goal, collect result, etc.)
            
            # 4. Add neighbors
            for neighbor in get_neighbors(node):
                if neighbor not in visited:
                    # Optional: Check if valid
                    if is_valid(neighbor):
                        visited.add(neighbor)
                        queue.append(neighbor)
        
        level += 1
    
    # 5. Return result
    return result
```
