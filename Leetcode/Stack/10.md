# Chapter 10: Interview Preparation

## 10.1 Pattern Recognition Guide

### Decision Tree: When to Use Stack

```
                    START
                      â”‚
                      â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ Need LIFO behavior? â”‚
            â”‚ (Last In First Out) â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ YES               â”‚ NO
            â–¼                   â–¼
     Use Stack!           Other DS
            â”‚
            â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚        WHAT TYPE OF STACK?            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚       â”‚       â”‚           â”‚           â”‚
    â–¼       â–¼       â–¼           â–¼           â–¼
 Basic  Monotonic  Two      Min/Max    Design
 Stack   Stack    Stacks    Stack      Problem
```

### Pattern Recognition Cheatsheet

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              KEYWORDS â†’ STACK PATTERN                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                    â”‚
â”‚  KEYWORD/PHRASE              â†’  PATTERN                            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚
â”‚  "Matching parentheses"      â†’  Basic stack (push open, pop close)â”‚
â”‚  "Valid brackets/pairs"      â†’  Basic stack                       â”‚
â”‚  "Next greater element"      â†’  Monotonic DECREASING stack        â”‚
â”‚  "Next smaller element"      â†’  Monotonic INCREASING stack        â”‚
â”‚  "Previous greater/smaller"  â†’  Monotonic stack (answer is top)   â”‚
â”‚  "Span/consecutive days"     â†’  Previous greater/smaller          â”‚
â”‚  "Histogram/rectangle"       â†’  PSE + NSE boundaries              â”‚
â”‚  "Trapping water"            â†’  Decreasing stack OR two pointers  â”‚
â”‚  "Sum of subarray min/max"   â†’  Contribution technique            â”‚
â”‚  "Decode nested string"      â†’  Stack of states (num + str)       â”‚
â”‚  "Evaluate expression"       â†’  Two stacks OR recursive           â”‚
â”‚  "Calculator"                â†’  Number stack + Operator stack     â”‚
â”‚  "Undo/Redo"                 â†’  Two stacks (undo + redo)          â”‚
â”‚  "Browser back/forward"      â†’  Two stacks                        â”‚
â”‚  "DFS traversal"             â†’  Explicit stack                    â”‚
â”‚  "Iterative tree traversal"  â†’  Stack replaces recursion          â”‚
â”‚  "Smallest/largest number"   â†’  Monotonic stack                   â”‚
â”‚  "Collision/interaction"     â†’  Process with stack, compare       â”‚
â”‚  "O(1) getMin/getMax"        â†’  Auxiliary min/max stack           â”‚
â”‚  "Most frequent element"     â†’  Frequency stack                   â”‚
â”‚                                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Quick Decision Guide

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   QUICK PATTERN DECISION                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                    â”‚
â”‚  Q: What should I store in the stack?                              â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚
â”‚  â€¢ VALUES: When you need actual data                               â”‚
â”‚  â€¢ INDICES: When you need positions/distances/widths               â”‚
â”‚  â€¢ (VALUE, INDEX): When you need both                              â”‚
â”‚  â€¢ (VALUE, COUNT): When tracking consecutive occurrences           â”‚
â”‚  â€¢ (VALUE, STATE): When tracking additional metadata               â”‚
â”‚                                                                    â”‚
â”‚  Q: Monotonic INCREASING or DECREASING?                            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚
â”‚  â€¢ Finding GREATER elements â†’ DECREASING stack                     â”‚
â”‚  â€¢ Finding SMALLER elements â†’ INCREASING stack                     â”‚
â”‚                                                                    â”‚
â”‚  â€¢ Decreasing: Big at bottom, small at top                         â”‚
â”‚    Pop when current is BIGGER (found NGE for popped)               â”‚
â”‚                                                                    â”‚
â”‚  â€¢ Increasing: Small at bottom, big at top                         â”‚
â”‚    Pop when current is SMALLER (found NSE for popped)              â”‚
â”‚                                                                    â”‚
â”‚  Q: How to handle duplicates?                                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚
â”‚  â€¢ Use STRICT inequality (<) on one side                           â”‚
â”‚  â€¢ Use NON-STRICT (<=) on the other side                           â”‚
â”‚  â€¢ This ensures each element counted exactly once                  â”‚
â”‚                                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 10.2 Common Mistakes and How to Avoid Them

### Mistake #1: Empty Stack Check

```python
# âŒ WRONG: No empty check
def wrong_approach(nums):
    stack = []
    for num in nums:
        if stack[-1] < num:  # IndexError if empty!
            stack.pop()
        stack.append(num)

# âœ… CORRECT: Always check before accessing
def correct_approach(nums):
    stack = []
    for num in nums:
        if stack and stack[-1] < num:  # Check first!
            stack.pop()
        stack.append(num)
```

### Mistake #2: Storing Values vs Indices

```python
# âŒ WRONG: Storing values when indices needed
def wrong_histogram(heights):
    stack = []
    for h in heights:
        while stack and h < stack[-1]:
            height = stack.pop()
            # How do we calculate WIDTH? We don't have positions!
            width = ???  # Can't compute!

# âœ… CORRECT: Store indices
def correct_histogram(heights):
    stack = []  # Store INDICES
    for i, h in enumerate(heights):
        while stack and h < heights[stack[-1]]:
            idx = stack.pop()
            height = heights[idx]
            left = stack[-1] if stack else -1
            width = i - left - 1  # Now we can compute!
```

### Mistake #3: Wrong Comparison Direction

```python
# For Next GREATER Element:
# âŒ WRONG: Using wrong comparison
while stack and nums[i] < nums[stack[-1]]:  # Wrong!
    stack.pop()

# âœ… CORRECT: Pop smaller elements (current is GREATER)
while stack and nums[i] > nums[stack[-1]]:  # Current > top
    popped = stack.pop()
    result[popped] = nums[i]  # Found NGE!
```

### Mistake #4: Forgetting to Process Remaining Stack

```python
# âŒ WRONG: Elements left in stack not processed
def wrong_nge(nums):
    result = [-1] * len(nums)
    stack = []
    for i, num in enumerate(nums):
        while stack and num > nums[stack[-1]]:
            result[stack.pop()] = num
        stack.append(i)
    return result
    # Stack may still have elements with no NGE!
    # But that's okay since result is initialized to -1

# But for other problems like histogram:
def wrong_histogram(heights):
    heights = heights + [0]  # â† SENTINEL to force processing!
    # Without this, some bars never get processed
```

### Mistake #5: Off-by-One Errors

```python
# Width calculation in histogram:
# âŒ WRONG
width = right - left  # Off by one!

# âœ… CORRECT
width = right - left - 1  # Subtract both boundaries

# Boundary check:
# âŒ WRONG
left = stack[-1]  # What if stack is empty?

# âœ… CORRECT  
left = stack[-1] if stack else -1  # Use -1 as virtual boundary
```

### Mistake #6: Duplicate Handling

```python
# Sum of subarray minimums - handling duplicates:

# âŒ WRONG: Using same comparison on both sides
# This causes double counting!
while stack and arr[stack[-1]] > arr[i]:  # Left boundary
    ...
while stack and arr[stack[-1]] > arr[i]:  # Right boundary
    ...

# âœ… CORRECT: Different comparison on each side
# Left: strictly greater (>)
while stack and arr[stack[-1]] > arr[i]:
    stack.pop()
# Right: greater or equal (>=)
while stack and arr[stack[-1]] >= arr[i]:
    stack.pop()
```

---

## 10.3 Interview Problem-Solving Framework

### Step-by-Step Approach

```
STACK PROBLEM-SOLVING FRAMEWORK:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STEP 1: RECOGNIZE THE PATTERN
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Read problem carefully
â€¢ Identify keywords (next greater, matching, nested, etc.)
â€¢ Ask: Is there LIFO behavior?

STEP 2: DETERMINE STACK TYPE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Basic stack? Monotonic? Multiple stacks?
â€¢ If monotonic: Increasing or Decreasing?
â€¢ What to store: values, indices, or pairs?

STEP 3: WRITE THE TEMPLATE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
stack = []
for i, element in enumerate(arr):
    while stack and CONDITION:
        # Process popped element
        ...
    stack.append(i)  # or element

STEP 4: HANDLE EDGE CASES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Empty input
â€¢ Single element
â€¢ All same elements
â€¢ All increasing/decreasing
â€¢ Elements remaining in stack

STEP 5: VERIFY WITH EXAMPLES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Trace through small example
â€¢ Check edge cases
â€¢ Verify time/space complexity
```

### Interview Communication Template

```
WHAT TO SAY IN INTERVIEW:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. UNDERSTAND THE PROBLEM:
"Let me make sure I understand. We need to find... 
For this input [...], the output should be [...]"

2. IDENTIFY THE PATTERN:
"This looks like a [next greater element / matching pairs / etc.] 
problem. I think we can use a [monotonic / basic] stack because..."

3. EXPLAIN YOUR APPROACH:
"My approach is to iterate through the array and maintain 
a [increasing/decreasing] stack. When we see [condition], 
we [action]. This works because..."

4. DISCUSS COMPLEXITY:
"Time complexity is O(n) because each element is pushed 
and popped at most once. Space complexity is O(n) for the stack."

5. CODE AND EXPLAIN:
"Let me code this up. First I'll initialize... 
Then for each element... The key insight here is..."

6. TEST:
"Let me trace through with the example: [trace step by step]"
```

---

## 10.4 Time and Space Complexity Summary

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             TIME & SPACE COMPLEXITY REFERENCE                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                    â”‚
â”‚  OPERATION              TIME        SPACE       NOTE               â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚
â”‚  push/pop/peek          O(1)        -           Per operation      â”‚
â”‚  Basic stack traverse   O(n)        O(n)        Single pass        â”‚
â”‚  Monotonic stack        O(n)        O(n)        Each elem once     â”‚
â”‚  Expression eval        O(n)        O(n)        Two stacks         â”‚
â”‚  Tree traversal         O(n)        O(h)        h = height         â”‚
â”‚  Histogram max rect     O(n)        O(n)        Single pass        â”‚
â”‚  Valid parentheses      O(n)        O(n)        Worst case all '(' â”‚
â”‚                                                                    â”‚
â”‚  WHY MONOTONIC STACK IS O(n):                                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚
â”‚  â€¢ Each element is pushed exactly ONCE                             â”‚
â”‚  â€¢ Each element is popped at most ONCE                             â”‚
â”‚  â€¢ Total operations: 2n = O(n)                                     â”‚
â”‚  â€¢ Even though there's a while loop inside for loop!               â”‚
â”‚                                                                    â”‚
â”‚  AMORTIZED ANALYSIS:                                               â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚
â”‚  â€¢ Queue using two stacks:                                         â”‚
â”‚    - push: O(1)                                                    â”‚
â”‚    - pop: O(1) amortized (O(n) worst case, but each element        â”‚
â”‚           transferred only once)                                   â”‚
â”‚                                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 10.5 8-Week Practice Roadmap

### Week 1-2: Foundations
```
GOAL: Master basic stack operations and simple problems

Day 1-2: Implementation
â–¡ Implement Stack using Array
â–¡ Implement Stack using Linked List  
â–¡ Implement Queue using Stacks (LC 232)

Day 3-4: Parentheses Problems
â–¡ Valid Parentheses (LC 20)
â–¡ Minimum Add to Make Parentheses Valid (LC 921)
â–¡ Remove Invalid Parentheses (LC 301)

Day 5-7: Basic Stack Problems
â–¡ Min Stack (LC 155)
â–¡ Daily Temperatures (LC 739)
â–¡ Remove All Adjacent Duplicates (LC 1047)
â–¡ Backspace String Compare (LC 844)

CHECKPOINT: Can you explain LIFO and implement basic stack?
```

### Week 3-4: Monotonic Stack
```
GOAL: Master monotonic stack pattern

Day 1-3: Next Greater/Smaller Element
â–¡ Next Greater Element I (LC 496)
â–¡ Next Greater Element II (LC 503)
â–¡ Next Greater Node In Linked List (LC 1019)

Day 4-5: Stock Problems
â–¡ Stock Span Problem (LC 901)
â–¡ Online Stock Span (LC 901)

Day 6-7: Histogram Problems â­â­â­
â–¡ Largest Rectangle in Histogram (LC 84) - CRITICAL!
â–¡ Maximal Rectangle (LC 85)
â–¡ Trapping Rain Water (LC 42)

CHECKPOINT: Can you identify when to use mono stack?
```

### Week 5-6: Expression & String
```
GOAL: Master expression evaluation and string manipulation

Day 1-2: Expression Evaluation
â–¡ Evaluate Reverse Polish Notation (LC 150)
â–¡ Basic Calculator (LC 224)
â–¡ Basic Calculator II (LC 227)

Day 3-4: String Manipulation
â–¡ Decode String (LC 394)
â–¡ Remove Duplicate Letters (LC 316)
â–¡ Remove K Digits (LC 402)

Day 5-7: Advanced String
â–¡ Simplify Path (LC 71)
â–¡ Score of Parentheses (LC 856)
â–¡ Longest Valid Parentheses (LC 32)

CHECKPOINT: Can you handle nested structures and precedence?
```

### Week 7-8: Advanced & Hard
```
GOAL: Solve hard problems and master all patterns

Day 1-2: Contribution Technique
â–¡ Sum of Subarray Minimums (LC 907)
â–¡ Sum of Subarray Ranges (LC 2104)

Day 3-4: Design Problems
â–¡ Max Stack (LC 716)
â–¡ Maximum Frequency Stack (LC 895)
â–¡ Custom Stack with Increment (LC 1381)

Day 5-7: Hard Problems
â–¡ 132 Pattern (LC 456)
â–¡ Number of Visible People in Queue (LC 1944)
â–¡ Maximum Width Ramp (LC 962)
â–¡ Create Maximum Number (LC 321)

CHECKPOINT: Can you solve hard problems in 45 minutes?
```

---

## 10.6 Quick Reference Card (Print This!)

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                 STACK INTERVIEW QUICK REFERENCE                    â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                    â•‘
â•‘  CORE OPERATIONS: All O(1)                                         â•‘
â•‘  push(x) | pop() | peek() | isEmpty() | size()                    â•‘
â•‘                                                                    â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â•‘
â•‘                                                                    â•‘
â•‘  MONOTONIC STACK PATTERNS:                                         â•‘
â•‘                                                                    â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â•‘
â•‘  â”‚ Find             â”‚ Use Stack        â”‚ Pop When               â”‚  â•‘
â•‘  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â•‘
â•‘  â”‚ Next Greater     â”‚ DECREASING       â”‚ current > top          â”‚  â•‘
â•‘  â”‚ Next Smaller     â”‚ INCREASING       â”‚ current < top          â”‚  â•‘
â•‘  â”‚ Prev Greater     â”‚ DECREASING       â”‚ current >= top         â”‚  â•‘
â•‘  â”‚ Prev Smaller     â”‚ INCREASING       â”‚ current <= top         â”‚  â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â•‘
â•‘                                                                    â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â•‘
â•‘                                                                    â•‘
â•‘  COMMON TEMPLATES:                                                 â•‘
â•‘                                                                    â•‘
â•‘  # Next Greater Element                                            â•‘
â•‘  for i in range(n):                                                â•‘
â•‘      while stack and nums[i] > nums[stack[-1]]:                    â•‘
â•‘          result[stack.pop()] = nums[i]                             â•‘
â•‘      stack.append(i)                                               â•‘
â•‘                                                                    â•‘
â•‘  # Histogram Max Rectangle                                         â•‘
â•‘  heights.append(0)  # Sentinel                                     â•‘
â•‘  for i, h in enumerate(heights):                                   â•‘
â•‘      while stack and h < heights[stack[-1]]:                       â•‘
â•‘          height = heights[stack.pop()]                             â•‘
â•‘          width = i - stack[-1] - 1 if stack else i                 â•‘
â•‘          area = max(area, height * width)                          â•‘
â•‘      stack.append(i)                                               â•‘
â•‘                                                                    â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â•‘
â•‘                                                                    â•‘
â•‘  REMEMBER:                                                         â•‘
â•‘  âœ“ Store INDICES when calculating widths/distances                 â•‘
â•‘  âœ“ Use strict (<) on one side for duplicates                       â•‘
â•‘  âœ“ Check stack empty before pop/peek                               â•‘
â•‘  âœ“ Process remaining elements after loop                           â•‘
â•‘  âœ“ Use sentinel (0 or infinity) to force final processing          â•‘
â•‘                                                                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## 10.7 Final Tips

### Before the Interview
```
1. Review this quick reference card
2. Practice writing monotonic stack template from memory
3. Review 2-3 hard problems (Histogram, Calculator, Sum of Mins)
4. Make sure you can explain WHY stack works for each pattern
```

### During the Interview
```
1. Take time to understand the problem
2. Identify the pattern before coding
3. Communicate your thought process
4. Start with brute force, then optimize with stack
5. Test with small example, then edge cases
```

### Common Follow-up Questions
```
Q: "Can you do it in O(1) space?"
â†’ Sometimes possible with two-pointer or math tricks

Q: "What if there are duplicates?"
â†’ Use strict inequality on one side

Q: "Can you do it iteratively instead of recursively?"
â†’ Use explicit stack (shown in Chapter 7)

Q: "How would you handle very large input?"
â†’ Discuss streaming/online algorithms if applicable
```

---

## 10.8 Problem Index by Company

```
AMAZON:
â”œâ”€â”€ Largest Rectangle in Histogram
â”œâ”€â”€ Trapping Rain Water
â”œâ”€â”€ Basic Calculator
â”œâ”€â”€ Min Stack
â””â”€â”€ Daily Temperatures

GOOGLE:
â”œâ”€â”€ Remove K Digits
â”œâ”€â”€ Remove Duplicate Letters
â”œâ”€â”€ Maximum Width Ramp
â”œâ”€â”€ Car Fleet
â””â”€â”€ Decode String

FACEBOOK/META:
â”œâ”€â”€ Valid Parentheses
â”œâ”€â”€ Basic Calculator III
â”œâ”€â”€ Number of Visible People
â”œâ”€â”€ Maximum Frequency Stack
â””â”€â”€ Exclusive Time of Functions

MICROSOFT:
â”œâ”€â”€ Valid Parentheses
â”œâ”€â”€ Min Stack
â”œâ”€â”€ Evaluate RPN
â”œâ”€â”€ Longest Valid Parentheses
â””â”€â”€ Simplify Path

APPLE:
â”œâ”€â”€ Daily Temperatures
â”œâ”€â”€ Asteroid Collision
â”œâ”€â”€ Remove All Adjacent Duplicates
â””â”€â”€ Score of Parentheses
```

---

**Good luck with your interviews! ğŸš€**

Remember: Stack problems are about recognizing patterns. 
Once you see the pattern, the solution follows naturally.
