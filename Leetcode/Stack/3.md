# Chapter 3: Monotonic Stack Pattern

> ğŸ”¥ **This is the MOST IMPORTANT stack pattern for hard interviews!**

## 3.1 What is a Monotonic Stack?

A **Monotonic Stack** is a stack where elements are arranged in a specific order (increasing or decreasing) from bottom to top.

### Visual Comparison

```
REGULAR STACK:              MONOTONIC INCREASING:      MONOTONIC DECREASING:
(no order constraint)       (bottom to top: smallâ†’big) (bottom to top: bigâ†’small)

    â”Œâ”€â”€â”€â”                       â”Œâ”€â”€â”€â”                       â”Œâ”€â”€â”€â”
    â”‚ 2 â”‚                       â”‚ 8 â”‚                       â”‚ 1 â”‚
    â”œâ”€â”€â”€â”¤                       â”œâ”€â”€â”€â”¤                       â”œâ”€â”€â”€â”¤
    â”‚ 7 â”‚                       â”‚ 5 â”‚                       â”‚ 3 â”‚
    â”œâ”€â”€â”€â”¤                       â”œâ”€â”€â”€â”¤                       â”œâ”€â”€â”€â”¤
    â”‚ 3 â”‚                       â”‚ 3 â”‚                       â”‚ 5 â”‚
    â”œâ”€â”€â”€â”¤                       â”œâ”€â”€â”€â”¤                       â”œâ”€â”€â”€â”¤
    â”‚ 9 â”‚                       â”‚ 1 â”‚                       â”‚ 9 â”‚
    â””â”€â”€â”€â”˜                       â””â”€â”€â”€â”˜                       â””â”€â”€â”€â”˜
    
    No pattern             1 < 3 < 5 < 8              9 > 5 > 3 > 1
```

### The Key Insight

```
WHEN AN ELEMENT IS POPPED FROM MONOTONIC STACK,
WE'VE FOUND SOMETHING IMPORTANT!

For Monotonic DECREASING stack (finding Next Greater):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
When we pop element X because of element Y:
â†’ Y is the NEXT GREATER element for X!

Array: [2, 1, 4, 3]

Processing 4:
Stack before: [2, 1]  (decreasing: 2 > 1)
4 > 1, so pop 1 â†’ 4 is next greater for 1
4 > 2, so pop 2 â†’ 4 is next greater for 2
Stack after: [4]
```

---

## 3.2 Types of Monotonic Stack

### The Four Fundamental Queries

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MONOTONIC STACK QUERIES                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Query                â”‚ Stack Type        â”‚ What Gets Popped?       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Next Greater (NGE)   â”‚ Decreasing        â”‚ Elements < current      â”‚
â”‚ Next Smaller (NSE)   â”‚ Increasing        â”‚ Elements > current      â”‚
â”‚ Previous Greater(PGE)â”‚ Decreasing        â”‚ Elements â‰¤ current      â”‚
â”‚ Previous Smaller(PSE)â”‚ Increasing        â”‚ Elements â‰¥ current      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Visual Memory Aid

```
DECREASING STACK â†’ GREATER element queries
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    â–¼ Big on bottom
    â”Œâ”€â”€â”€â”
    â”‚ 2 â”‚ â† Small on top
    â”œâ”€â”€â”€â”¤
    â”‚ 5 â”‚
    â”œâ”€â”€â”€â”¤
    â”‚ 8 â”‚ â† Big
    â””â”€â”€â”€â”˜
    
When small element is popped by bigger one,
we found NEXT GREATER!


INCREASING STACK â†’ SMALLER element queries
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    â–¼ Small on bottom
    â”Œâ”€â”€â”€â”
    â”‚ 8 â”‚ â† Big on top
    â”œâ”€â”€â”€â”¤
    â”‚ 5 â”‚
    â”œâ”€â”€â”€â”¤
    â”‚ 2 â”‚ â† Small
    â””â”€â”€â”€â”˜
    
When big element is popped by smaller one,
we found NEXT SMALLER!
```

---

## 3.3 Next Greater Element (NGE)

### Problem Definition

For each element, find the first element to its RIGHT that is GREATER.

```
Array:  [4, 5, 2, 10, 8]
NGE:    [5, 10, 10, -1, -1]

Explanation:
- 4 â†’ 5 (first greater to right)
- 5 â†’ 10
- 2 â†’ 10
- 10 â†’ -1 (nothing greater)
- 8 â†’ -1 (nothing to right)
```

### Algorithm Visualization

```
Array: [4, 5, 2, 10, 8]
Using DECREASING stack (stores indices)

Step-by-step:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
i â”‚ arr[i] â”‚ Stack (indices) â”‚ Stack (values) â”‚ Action
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
0 â”‚   4    â”‚ []              â”‚ []             â”‚ Push 0
  â”‚        â”‚ [0]             â”‚ [4]            â”‚
â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1 â”‚   5    â”‚ [0]             â”‚ [4]            â”‚ 5 > 4, pop 0
  â”‚        â”‚                 â”‚                â”‚ â†’ NGE[0] = 5
  â”‚        â”‚ [1]             â”‚ [5]            â”‚ Push 1
â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2 â”‚   2    â”‚ [1]             â”‚ [5]            â”‚ 2 < 5, just push
  â”‚        â”‚ [1, 2]          â”‚ [5, 2]         â”‚ Push 2
â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3 â”‚   10   â”‚ [1, 2]          â”‚ [5, 2]         â”‚ 10 > 2, pop 2
  â”‚        â”‚                 â”‚                â”‚ â†’ NGE[2] = 10
  â”‚        â”‚ [1]             â”‚ [5]            â”‚ 10 > 5, pop 1
  â”‚        â”‚                 â”‚                â”‚ â†’ NGE[1] = 10
  â”‚        â”‚ [3]             â”‚ [10]           â”‚ Push 3
â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4 â”‚   8    â”‚ [3]             â”‚ [10]           â”‚ 8 < 10, just push
  â”‚        â”‚ [3, 4]          â”‚ [10, 8]        â”‚ Push 4
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
END: Remaining in stack have no NGE â†’ -1
     NGE[3] = -1, NGE[4] = -1

Result: [5, 10, 10, -1, -1]
```

### Implementation

```python
def next_greater_element(nums):
    """
    Find next greater element for each position
    
    Algorithm:
    - Use DECREASING stack (stores indices)
    - When current > stack top: pop and record answer
    - Push current index
    
    Time: O(n) - each element pushed and popped at most once
    Space: O(n)
    """
    n = len(nums)
    result = [-1] * n  # Default: no greater element
    stack = []  # Stores INDICES, not values
    
    for i in range(n):
        # Pop all smaller elements - current is their NGE
        while stack and nums[i] > nums[stack[-1]]:
            popped_idx = stack.pop()
            result[popped_idx] = nums[i]
        
        stack.append(i)
    
    # Remaining elements in stack have no NGE (already -1)
    return result


# Test
print(next_greater_element([4, 5, 2, 10, 8]))
# Output: [5, 10, 10, -1, -1]
```

---

## 3.4 Next Smaller Element (NSE)

### Problem Definition

For each element, find the first element to its RIGHT that is SMALLER.

```
Array:  [4, 2, 5, 7, 3]
NSE:    [2, -1, 3, 3, -1]
```

### Implementation

```python
def next_smaller_element(nums):
    """
    Find next smaller element using INCREASING stack
    
    Key difference from NGE:
    - Use INCREASING stack
    - Pop when current < stack top
    """
    n = len(nums)
    result = [-1] * n
    stack = []  # Stores indices
    
    for i in range(n):
        # Pop all LARGER elements - current is their NSE
        while stack and nums[i] < nums[stack[-1]]:
            popped_idx = stack.pop()
            result[popped_idx] = nums[i]
        
        stack.append(i)
    
    return result


# Visualization for [4, 2, 5, 7, 3]:
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# i â”‚ val â”‚ Stack(vals) â”‚ Action
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 0 â”‚  4  â”‚ []          â”‚ Push â†’ [4]
# 1 â”‚  2  â”‚ [4]         â”‚ 2 < 4, pop â†’ NSE[0]=2
#   â”‚     â”‚ []          â”‚ Push â†’ [2]
# 2 â”‚  5  â”‚ [2]         â”‚ 5 > 2, Push â†’ [2,5]
# 3 â”‚  7  â”‚ [2,5]       â”‚ 7 > 5, Push â†’ [2,5,7]
# 4 â”‚  3  â”‚ [2,5,7]     â”‚ 3 < 7, pop â†’ NSE[3]=3
#   â”‚     â”‚ [2,5]       â”‚ 3 < 5, pop â†’ NSE[2]=3
#   â”‚     â”‚ [2]         â”‚ 3 > 2, Push â†’ [2,3]
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Result: [2, -1, 3, 3, -1]
```

---

## 3.5 Previous Greater/Smaller Elements

### The Key Difference

```
NEXT vs PREVIOUS:

NEXT:     The answer is the CURRENT element (for those being popped)
PREVIOUS: The answer is the STACK TOP (for the current element)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  NEXT queries:     When we pop X because of Y              â”‚
â”‚                    â†’ Y is the answer for X                 â”‚
â”‚                                                            â”‚
â”‚  PREVIOUS queries: After popping, look at new stack top    â”‚
â”‚                    â†’ Stack top is the answer for current   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Implementation

```python
def previous_greater_element(nums):
    """
    Find previous greater element (first greater to the LEFT)
    
    Key insight: After popping smaller elements,
    the stack top (if exists) is the previous greater!
    """
    n = len(nums)
    result = [-1] * n
    stack = []  # Decreasing stack
    
    for i in range(n):
        # Pop smaller or equal elements
        while stack and nums[stack[-1]] <= nums[i]:
            stack.pop()
        
        # Stack top is previous greater (if exists)
        if stack:
            result[i] = nums[stack[-1]]
        
        stack.append(i)
    
    return result


def previous_smaller_element(nums):
    """
    Find previous smaller element (first smaller to the LEFT)
    """
    n = len(nums)
    result = [-1] * n
    stack = []  # Increasing stack
    
    for i in range(n):
        # Pop larger or equal elements
        while stack and nums[stack[-1]] >= nums[i]:
            stack.pop()
        
        # Stack top is previous smaller (if exists)
        if stack:
            result[i] = nums[stack[-1]]
        
        stack.append(i)
    
    return result


# Example: [3, 7, 1, 4, 2]
# Previous Greater: [-1, -1, 7, 7, 4]
# Previous Smaller: [-1, 3, -1, 1, 1]
```

---

## 3.6 The Template

### Universal Monotonic Stack Template

```python
def monotonic_stack_template(nums, find_greater=True, find_next=True):
    """
    Universal template for all four queries
    
    Parameters:
    - find_greater: True for greater, False for smaller
    - find_next: True for next, False for previous
    """
    n = len(nums)
    result = [-1] * n
    stack = []
    
    for i in range(n):
        # Determine comparison based on query type
        while stack and should_pop(nums, stack[-1], i, find_greater):
            if find_next:
                # For NEXT queries: current is answer for popped
                popped_idx = stack.pop()
                result[popped_idx] = nums[i]
            else:
                stack.pop()
        
        if not find_next and stack:
            # For PREVIOUS queries: stack top is answer for current
            result[i] = nums[stack[-1]]
        
        stack.append(i)
    
    return result


def should_pop(nums, stack_top_idx, current_idx, find_greater):
    """Determine if we should pop based on query type"""
    if find_greater:
        # For GREATER queries: pop smaller elements
        return nums[current_idx] > nums[stack_top_idx]
    else:
        # For SMALLER queries: pop larger elements
        return nums[current_idx] < nums[stack_top_idx]
```

---

## 3.7 Classic Problem: Daily Temperatures â­

**LeetCode 739**

Given temperatures, find days until warmer temperature.

```
Input:  [73, 74, 75, 71, 69, 72, 76, 73]
Output: [1,  1,  4,  2,  1,  1,  0,  0]

Explanation:
- Day 0 (73Â°): Wait 1 day â†’ Day 1 (74Â°)
- Day 2 (75Â°): Wait 4 days â†’ Day 6 (76Â°)
- Day 7 (73Â°): No warmer day â†’ 0
```

```python
def daily_temperatures(temperatures):
    """
    Find days until warmer temperature
    
    This is Next Greater Element, but return DISTANCE instead of value
    
    Time: O(n), Space: O(n)
    """
    n = len(temperatures)
    result = [0] * n  # Default: no warmer day
    stack = []  # Decreasing stack of indices
    
    for i in range(n):
        # Current temp is warmer than stack top
        while stack and temperatures[i] > temperatures[stack[-1]]:
            prev_day = stack.pop()
            result[prev_day] = i - prev_day  # Distance, not value!
        
        stack.append(i)
    
    return result


# Visual trace for [73, 74, 75, 71, 69, 72, 76, 73]:
"""
Day â”‚ Temp â”‚ Stack (temps)     â”‚ Action              â”‚ Result update
â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 0  â”‚  73  â”‚ []                â”‚ Push                â”‚
 1  â”‚  74  â”‚ [73]              â”‚ 74>73, pop 0        â”‚ R[0]=1-0=1
    â”‚      â”‚ []                â”‚ Push                â”‚
 2  â”‚  75  â”‚ [74]              â”‚ 75>74, pop 1        â”‚ R[1]=2-1=1
    â”‚      â”‚ []                â”‚ Push                â”‚
 3  â”‚  71  â”‚ [75]              â”‚ 71<75, Push         â”‚
 4  â”‚  69  â”‚ [75,71]           â”‚ 69<71, Push         â”‚
 5  â”‚  72  â”‚ [75,71,69]        â”‚ 72>69, pop 4        â”‚ R[4]=5-4=1
    â”‚      â”‚ [75,71]           â”‚ 72>71, pop 3        â”‚ R[3]=5-3=2
    â”‚      â”‚ [75]              â”‚ 72<75, Push         â”‚
 6  â”‚  76  â”‚ [75,72]           â”‚ 76>72, pop 5        â”‚ R[5]=6-5=1
    â”‚      â”‚ [75]              â”‚ 76>75, pop 2        â”‚ R[2]=6-2=4
    â”‚      â”‚ []                â”‚ Push                â”‚
 7  â”‚  73  â”‚ [76]              â”‚ 73<76, Push         â”‚

Result: [1, 1, 4, 2, 1, 1, 0, 0]
"""
```

---

## 3.8 Classic Problem: Stock Span â­

**LeetCode 901**

Find consecutive days with price â‰¤ today (including today).

```
Prices: [100, 80, 60, 70, 60, 75, 85]
Spans:  [1,   1,  1,  2,  1,  4,  6]

Day 5 (75): Days 4,3,2 all â‰¤ 75, span = 4
Day 6 (85): Days 5,4,3,2,1 all â‰¤ 85, span = 6
```

```python
class StockSpanner:
    """
    Online stock span calculator
    
    Key insight: Span = distance to previous greater element + 1
    
    If no previous greater: span = days since start
    """
    
    def __init__(self):
        self.stack = []  # Stores (price, index)
        self.day = 0
    
    def next(self, price: int) -> int:
        # Pop all smaller or equal prices
        while self.stack and self.stack[-1][0] <= price:
            self.stack.pop()
        
        # Calculate span
        if self.stack:
            # Distance to previous greater
            span = self.day - self.stack[-1][1]
        else:
            # No previous greater, span is all days + 1
            span = self.day + 1
        
        self.stack.append((price, self.day))
        self.day += 1
        
        return span


# Alternative: Store span directly in stack
class StockSpannerOptimized:
    """
    Optimized: Store (price, span) pairs
    When popping, accumulate their spans
    """
    
    def __init__(self):
        self.stack = []  # (price, accumulated_span)
    
    def next(self, price: int) -> int:
        span = 1  # At least today
        
        # Pop smaller prices and add their spans
        while self.stack and self.stack[-1][0] <= price:
            span += self.stack.pop()[1]
        
        self.stack.append((price, span))
        return span


# Trace for [100, 80, 60, 70, 60, 75, 85]:
"""
Priceâ”‚ Stack before      â”‚ Pops & accumulate â”‚ Final span â”‚ Stack after
â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
100  â”‚ []                â”‚ none              â”‚ 1          â”‚ [(100,1)]
80   â”‚ [(100,1)]         â”‚ none              â”‚ 1          â”‚ [(100,1),(80,1)]
60   â”‚ [(100,1),(80,1)]  â”‚ none              â”‚ 1          â”‚ [(100,1),(80,1),(60,1)]
70   â”‚ [...,(60,1)]      â”‚ pop (60,1)â†’+1     â”‚ 2          â”‚ [(100,1),(80,1),(70,2)]
60   â”‚ [...,(70,2)]      â”‚ none              â”‚ 1          â”‚ [(100,1),(80,1),(70,2),(60,1)]
75   â”‚ [...,(60,1)]      â”‚ pop (60,1)â†’+1     â”‚            â”‚
     â”‚ [...,(70,2)]      â”‚ pop (70,2)â†’+2     â”‚            â”‚
     â”‚ [(100,1),(80,1)]  â”‚ pop (80,1)â†’+1     â”‚ 4          â”‚ [(100,1),(75,4)]
85   â”‚ [(100,1),(75,4)]  â”‚ pop (75,4)â†’+4     â”‚            â”‚
     â”‚ [(100,1)]         â”‚ pop (100,1)â†’+1    â”‚ 6          â”‚ [(85,6)]
"""
```

---

## 3.9 Classic Problem: Largest Rectangle in Histogram â­â­â­

**LeetCode 84** - One of the most important stack problems!

```
Heights: [2, 1, 5, 6, 2, 3]

Visual:
        â”Œâ”€â”€â”€â”
        â”‚   â”‚
    â”Œâ”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚   â”‚       â”Œâ”€â”€â”€â”
    â”‚   â”‚   â”‚   â”Œâ”€â”€â”€â”¤   â”‚
â”Œâ”€â”€â”€â”¤   â”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€â”€â”¤   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
  2   1   5   6   2   3

Maximum rectangle = 10 (5Ã—2 or 6+5-1 area)
```

### The Key Insight

```
FOR EACH BAR:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
To find the maximum rectangle with bar[i] as the HEIGHT:

1. Find LEFT boundary: first bar shorter than bar[i]
2. Find RIGHT boundary: first bar shorter than bar[i]
3. Width = right_boundary - left_boundary - 1
4. Area = height Ã— width

This is Previous Smaller + Next Smaller problem!
```

### Approach 1: Two Pass (Clearer)

```python
def largest_rectangle_two_pass(heights):
    """
    Two-pass approach:
    Pass 1: Find previous smaller element (left boundary)
    Pass 2: Find next smaller element (right boundary)
    
    Time: O(n), Space: O(n)
    """
    n = len(heights)
    if n == 0:
        return 0
    
    # Find left boundaries (previous smaller element index)
    left = [-1] * n  # -1 means no smaller on left
    stack = []
    for i in range(n):
        while stack and heights[stack[-1]] >= heights[i]:
            stack.pop()
        left[i] = stack[-1] if stack else -1
        stack.append(i)
    
    # Find right boundaries (next smaller element index)
    right = [n] * n  # n means no smaller on right
    stack = []
    for i in range(n - 1, -1, -1):
        while stack and heights[stack[-1]] >= heights[i]:
            stack.pop()
        right[i] = stack[-1] if stack else n
        stack.append(i)
    
    # Calculate max area
    max_area = 0
    for i in range(n):
        width = right[i] - left[i] - 1
        area = heights[i] * width
        max_area = max(max_area, area)
    
    return max_area


# Trace for [2, 1, 5, 6, 2, 3]:
"""
Index:     0    1    2    3    4    5
Heights:   2    1    5    6    2    3

Left boundary (prev smaller):
i=0: stack=[], left[0]=-1, push 0
i=1: heights[0]=2 >= 1, pop; stack=[], left[1]=-1, push 1
i=2: heights[1]=1 < 5, left[2]=1, push 2
i=3: heights[2]=5 < 6, left[3]=2, push 3
i=4: heights[3]=6 >= 2, pop; heights[2]=5 >= 2, pop;
     heights[1]=1 < 2, left[4]=1, push 4
i=5: heights[4]=2 < 3, left[5]=4, push 5

Left: [-1, -1, 1, 2, 1, 4]

Right boundary (next smaller):
i=5: stack=[], right[5]=6, push 5
i=4: heights[5]=3 >= 2, pop; stack=[], right[4]=6, push 4
i=3: heights[4]=2 < 6, right[3]=4, push 3
i=2: heights[3]=6 >= 5, pop; heights[4]=2 < 5, right[2]=4, push 2
i=1: heights[2]=5 >= 1, pop; heights[4]=2 >= 1, pop;
     stack=[], right[1]=6, push 1
i=0: heights[1]=1 < 2, right[0]=1, push 0

Right: [1, 6, 4, 4, 6, 6]

Calculate areas:
i=0: width = 1-(-1)-1 = 1, area = 2Ã—1 = 2
i=1: width = 6-(-1)-1 = 6, area = 1Ã—6 = 6
i=2: width = 4-1-1 = 2, area = 5Ã—2 = 10 â† MAX
i=3: width = 4-2-1 = 1, area = 6Ã—1 = 6
i=4: width = 6-1-1 = 4, area = 2Ã—4 = 8
i=5: width = 6-4-1 = 1, area = 3Ã—1 = 3

Maximum Area = 10
"""
```

### Approach 2: Single Pass (More Efficient)

```python
def largest_rectangle_single_pass(heights):
    """
    Single pass approach:
    - When we pop a bar, we know both its boundaries
    - Left boundary: new stack top (or -1)
    - Right boundary: current index
    
    Trick: Add 0 at end to force popping all remaining bars
    
    Time: O(n), Space: O(n)
    """
    heights = heights + [0]  # Sentinel to pop everything at end
    n = len(heights)
    stack = []  # Increasing stack of indices
    max_area = 0
    
    for i in range(n):
        while stack and heights[i] < heights[stack[-1]]:
            # Pop the bar
            h = heights[stack.pop()]
            
            # Calculate width
            # Left boundary is new stack top (or -1 if empty)
            left = stack[-1] if stack else -1
            right = i
            width = right - left - 1
            
            area = h * width
            max_area = max(max_area, area)
        
        stack.append(i)
    
    return max_area


# Visual trace for [2, 1, 5, 6, 2, 3] + [0]:
"""
i â”‚ h[i]â”‚ Stack(h) â”‚ Pop & Calculate
â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
0 â”‚  2  â”‚ []       â”‚ Push â†’ [2]
1 â”‚  1  â”‚ [2]      â”‚ 1<2, pop 0: h=2, w=1-(-1)-1=1, a=2
  â”‚     â”‚ []       â”‚ Push â†’ [1]
2 â”‚  5  â”‚ [1]      â”‚ 5>1, Push â†’ [1,5]
3 â”‚  6  â”‚ [1,5]    â”‚ 6>5, Push â†’ [1,5,6]
4 â”‚  2  â”‚ [1,5,6]  â”‚ 2<6, pop 3: h=6, w=4-2-1=1, a=6
  â”‚     â”‚ [1,5]    â”‚ 2<5, pop 2: h=5, w=4-1-1=2, a=10 âœ“
  â”‚     â”‚ [1]      â”‚ 2>1, Push â†’ [1,2]
5 â”‚  3  â”‚ [1,2]    â”‚ 3>2, Push â†’ [1,2,3]
6 â”‚  0  â”‚ [1,2,3]  â”‚ 0<3, pop 5: h=3, w=6-4-1=1, a=3
  â”‚     â”‚ [1,2]    â”‚ 0<2, pop 4: h=2, w=6-1-1=4, a=8
  â”‚     â”‚ [1]      â”‚ 0<1, pop 1: h=1, w=6-(-1)-1=6, a=6
  â”‚     â”‚ []       â”‚ Push â†’ [0]

Maximum = 10
"""
```

---

## 3.10 Classic Problem: Trapping Rain Water â­â­

**LeetCode 42**

```
Height: [0,1,0,2,1,0,1,3,2,1,2,1]

Visual:
                  â”Œâ”€â”€â”€â”
          â”Œâ”€â”€â”€â”â‰ˆâ‰ˆâ‰ˆâ”‚   â”‚
          â”‚   â”‚â‰ˆâ‰ˆâ‰ˆâ”‚   â”œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”
      â”Œâ”€â”€â”€â”¤   â”‚â‰ˆâ‰ˆâ‰ˆâ”‚   â”‚   â”œâ”€â”€â”€â”¤   â”œâ”€â”€â”€â”
      â”‚   â”‚â‰ˆâ‰ˆâ‰ˆâ”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚
  â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€
   0   1   0   2   1   0   1   3   2   1   2   1

â‰ˆ represents trapped water
Total water = 6 units
```

### Stack Solution

```python
def trap_water_stack(height):
    """
    Stack approach for trapping rain water
    
    Key insight:
    - Use decreasing stack
    - When we find a taller bar, water is trapped between it
      and the previous taller bar
    
    Time: O(n), Space: O(n)
    """
    stack = []  # Decreasing stack of indices
    water = 0
    
    for i in range(len(height)):
        # Current bar can trap water with bars in stack
        while stack and height[i] > height[stack[-1]]:
            bottom = stack.pop()  # This becomes the bottom
            
            if not stack:
                break  # No left boundary
            
            left = stack[-1]  # Left boundary
            
            # Calculate water trapped above 'bottom'
            width = i - left - 1
            h = min(height[left], height[i]) - height[bottom]
            water += width * h
        
        stack.append(i)
    
    return water


# Alternative: Two Pointer (More space efficient)
def trap_water_two_pointer(height):
    """
    Two pointer approach - O(1) space
    
    Key insight: Water at position i depends on
    min(max_left, max_right) - height[i]
    """
    if not height:
        return 0
    
    left, right = 0, len(height) - 1
    left_max, right_max = height[left], height[right]
    water = 0
    
    while left < right:
        if left_max < right_max:
            left += 1
            left_max = max(left_max, height[left])
            water += left_max - height[left]
        else:
            right -= 1
            right_max = max(right_max, height[right])
            water += right_max - height[right]
    
    return water
```

---

## 3.11 Sum of Subarray Minimums â­â­

**LeetCode 907** - Uses the "Contribution" technique!

```
Array: [3, 1, 2, 4]
Subarrays and their minimums:
[3]=3, [1]=1, [2]=2, [4]=4
[3,1]=1, [1,2]=1, [2,4]=2
[3,1,2]=1, [1,2,4]=1
[3,1,2,4]=1

Sum = 3+1+2+4+1+1+2+1+1+1 = 17
```

### The Contribution Technique

```
KEY INSIGHT:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Instead of iterating all O(nÂ²) subarrays,
calculate each element's CONTRIBUTION to final sum.

For element arr[i]:
- Find how many subarrays have arr[i] as MINIMUM
- Contribution = arr[i] Ã— (count of such subarrays)

Count = left_count Ã— right_count
Where:
- left_count = distance to previous smaller element
- right_count = distance to next smaller element
```

```python
def sum_of_subarray_mins(arr):
    """
    Sum of minimum elements of all subarrays
    
    Using contribution technique:
    contribution[i] = arr[i] Ã— left_count Ã— right_count
    
    Time: O(n), Space: O(n)
    """
    MOD = 10**9 + 7
    n = len(arr)
    
    # Previous smaller element distances
    # left[i] = number of elements to left where arr[i] is min
    left = [0] * n
    stack = []
    for i in range(n):
        while stack and arr[stack[-1]] > arr[i]:  # Strictly greater
            stack.pop()
        left[i] = i - stack[-1] if stack else i + 1
        stack.append(i)
    
    # Next smaller element distances
    # right[i] = number of elements to right where arr[i] is min
    right = [0] * n
    stack = []
    for i in range(n - 1, -1, -1):
        while stack and arr[stack[-1]] >= arr[i]:  # Greater or equal!
            stack.pop()
        right[i] = stack[-1] - i if stack else n - i
        stack.append(i)
    
    # Calculate total sum
    result = 0
    for i in range(n):
        contribution = arr[i] * left[i] * right[i]
        result = (result + contribution) % MOD
    
    return result


# Trace for [3, 1, 2, 4]:
"""
Array: [3, 1, 2, 4]
Index:  0  1  2  3

Left distances (prev smaller):
i=0: no prev smaller, left[0] = 0+1 = 1
i=1: no prev smaller, left[1] = 1+1 = 2
i=2: prev smaller is index 1, left[2] = 2-1 = 1
i=3: prev smaller is index 1, left[3] = 3-1 = 2

Left: [1, 2, 1, 2]

Right distances (next smaller or equal):
i=3: no next smaller, right[3] = 4-3 = 1
i=2: next smaller is none, right[2] = 4-2 = 2
i=1: no next smaller, right[1] = 4-1 = 3
i=0: next smaller is index 1, right[0] = 1-0 = 1

Right: [1, 3, 2, 1]

Contributions:
arr[0]=3: 3 Ã— 1 Ã— 1 = 3   (subarrays: [3])
arr[1]=1: 1 Ã— 2 Ã— 3 = 6   (subarrays with 1 as min: 6)
arr[2]=2: 2 Ã— 1 Ã— 2 = 4   (subarrays: [2], [2,4])
arr[3]=4: 4 Ã— 2 Ã— 1 = 4   (subarrays: [4], [2,4]... wait)

Hmm, let me recalculate...

Actually for arr[3]=4: left[3]=2 means subarrays starting from
indices {2,3}, right[3]=1 means ending at {3}
Combinations: [2,4] uses min of 2, not 4!

The contribution calculation accounts for when arr[i] IS the minimum.
Total = 3 + 6 + 4 + 4 = 17 âœ“
"""
```

---

## 3.12 Pattern Recognition Cheatsheet

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              MONOTONIC STACK CHEATSHEET                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  KEYWORDS â†’ PATTERN:                                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                         â”‚
â”‚  "Next greater/larger"      â†’ Decreasing stack, left to right    â”‚
â”‚  "Next smaller"             â†’ Increasing stack, left to right    â”‚
â”‚  "Previous greater"         â†’ Decreasing stack, answer is top    â”‚
â”‚  "Previous smaller"         â†’ Increasing stack, answer is top    â”‚
â”‚  "Span/Range"               â†’ Previous greater/smaller           â”‚
â”‚  "Histogram/Rectangle"      â†’ Prev & Next smaller                â”‚
â”‚  "Water/Container"          â†’ Stack or two pointers              â”‚
â”‚  "Sum of subarray min/max"  â†’ Contribution technique             â”‚
â”‚                                                                  â”‚
â”‚  WHAT TO STORE:                                                  â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                         â”‚
â”‚  â€¢ Usually INDICES (for calculating distances/widths)            â”‚
â”‚  â€¢ Sometimes (value, index) pairs                                â”‚
â”‚  â€¢ Sometimes (value, accumulated_count)                          â”‚
â”‚                                                                  â”‚
â”‚  HANDLING DUPLICATES:                                            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                         â”‚
â”‚  Use strict inequality (<) on one side,                          â”‚
â”‚  non-strict (<=) on the other to avoid double counting           â”‚
â”‚                                                                  â”‚
â”‚  TIME COMPLEXITY: Always O(n)                                    â”‚
â”‚  Each element pushed once, popped once â†’ 2n operations           â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Practice Problems by Difficulty

### Easy-Medium
| Problem | Key Pattern |
|---------|-------------|
| Next Greater Element I | Basic NGE |
| Daily Temperatures | NGE with distance |
| Stock Span | Previous greater |

### Medium
| Problem | Key Pattern |
|---------|-------------|
| Next Greater Element II (circular) | NGE + 2n iteration |
| Online Stock Span | Streaming + aggregation |
| Remove K Digits | Monotonic increasing |
| Remove Duplicate Letters | Monotonic + constraints |

### Hard
| Problem | Key Pattern |
|---------|-------------|
| Largest Rectangle in Histogram | PSE + NSE |
| Maximal Rectangle | Histogram per row |
| Trapping Rain Water | Decreasing stack |
| Sum of Subarray Minimums | Contribution technique |
| Sum of Subarray Ranges | Contribution (max - min) |
| Number of Visible People | Decreasing stack |
| Maximum Width Ramp | Monotonic + binary search |
