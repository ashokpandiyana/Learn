# Chapter 1: Stack Fundamentals

## 1.1 What is a Stack?

A **Stack** is a linear data structure that follows a particular order for operations. This order is called **LIFO** (Last In, First Out) or **FILO** (First In, Last Out).

### Visual Representation

```
    ┌─────────┐
    │    4    │  ← TOP (Last In, First Out)
    ├─────────┤
    │    3    │
    ├─────────┤
    │    2    │
    ├─────────┤
    │    1    │  ← BOTTOM (First In, Last Out)
    └─────────┘
    
    Push order: 1 → 2 → 3 → 4
    Pop order:  4 → 3 → 2 → 1
```

### Real-World Analogies

```
1. STACK OF PLATES
   ┌───┐
   │ 3 │ ← Take from here (last placed)
   ├───┤
   │ 2 │
   ├───┤
   │ 1 │ ← First plate placed
   └───┘

2. BROWSER BACK BUTTON
   Page1 → Page2 → Page3 → Page4
                              ↑
                         Current Page
   
   Press Back: Page4 → Page3 → Page2 → Page1

3. UNDO OPERATION (Ctrl+Z)
   Action1 → Action2 → Action3
   Undo:     Action3 undone first!

4. FUNCTION CALL STACK
   main() calls → foo() calls → bar()
   Returns:       bar() → foo() → main()
```

### Why Use a Stack?

| Use Case | Why Stack? |
|----------|------------|
| Undo/Redo | Need to reverse the order of operations |
| Backtracking | Return to previous state (DFS, maze solving) |
| Expression Parsing | Handle nested structures (parentheses) |
| Function Calls | Track return addresses (call stack) |
| Browser History | Navigate backward in LIFO order |

---

## 1.2 Core Operations

### The Five Essential Operations

```
┌────────────────────────────────────────────────────────────────┐
│                     STACK OPERATIONS                           │
├────────────┬───────────────────────────────┬──────────────────┤
│ Operation  │ Description                   │ Time Complexity  │
├────────────┼───────────────────────────────┼──────────────────┤
│ push(x)    │ Add element x to the top      │ O(1)             │
│ pop()      │ Remove and return top element │ O(1)             │
│ peek/top() │ Return top without removing   │ O(1)             │
│ isEmpty()  │ Check if stack is empty       │ O(1)             │
│ size()     │ Return number of elements     │ O(1)             │
└────────────┴───────────────────────────────┴──────────────────┘
```

### Visual Operation Flow

```
PUSH Operation (push 5):
                                    
Before:         After:
┌───┐           ┌───┐
│ 3 │ ← top     │ 5 │ ← top (new)
├───┤           ├───┤
│ 2 │           │ 3 │
├───┤           ├───┤
│ 1 │           │ 2 │
└───┘           ├───┤
                │ 1 │
                └───┘

═══════════════════════════════════════

POP Operation:

Before:         After:          Returns: 5
┌───┐           ┌───┐
│ 5 │ ← top     │ 3 │ ← top
├───┤           ├───┤
│ 3 │           │ 2 │
├───┤           ├───┤
│ 2 │           │ 1 │
├───┤           └───┘
│ 1 │           
└───┘           

═══════════════════════════════════════

PEEK Operation:

┌───┐
│ 5 │ ← top     Returns: 5 (stack unchanged)
├───┤
│ 3 │
├───┤
│ 2 │
└───┘
```

---

## 1.3 Implementation Approaches

### Approach 1: Array-Based Implementation

```
ARRAY-BASED STACK VISUALIZATION:

Index:    0     1     2     3     4     5     6     7
        ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
Array:  │  1  │  2  │  3  │  4  │     │     │     │     │
        └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
                            ↑
                           top = 3
                           
Push(5): top becomes 4, array[4] = 5
Pop():   return array[3], top becomes 2
```

#### Python Implementation (Array-Based)

```python
class ArrayStack:
    """
    Stack implementation using Python list (dynamic array)
    
    Advantages:
    - Cache-friendly (contiguous memory)
    - Simple indexing
    - No pointer overhead
    
    Disadvantages:
    - May need resizing (amortized O(1))
    - Fixed size in static array implementation
    """
    
    def __init__(self, capacity=None):
        """
        Initialize stack with optional capacity limit
        
        Args:
            capacity: Maximum size (None for unlimited)
        """
        self.stack = []
        self.capacity = capacity
    
    def push(self, item):
        """
        Add item to top of stack
        
        Time Complexity: O(1) amortized
        Space Complexity: O(1)
        
        Raises:
            OverflowError: If stack is at capacity
        """
        if self.capacity and len(self.stack) >= self.capacity:
            raise OverflowError("Stack is full")
        self.stack.append(item)
    
    def pop(self):
        """
        Remove and return top item
        
        Time Complexity: O(1)
        
        Raises:
            IndexError: If stack is empty
        """
        if self.is_empty():
            raise IndexError("Pop from empty stack")
        return self.stack.pop()
    
    def peek(self):
        """
        Return top item without removing
        
        Time Complexity: O(1)
        
        Raises:
            IndexError: If stack is empty
        """
        if self.is_empty():
            raise IndexError("Peek from empty stack")
        return self.stack[-1]
    
    def is_empty(self):
        """Check if stack is empty - O(1)"""
        return len(self.stack) == 0
    
    def size(self):
        """Return number of elements - O(1)"""
        return len(self.stack)
    
    def __str__(self):
        """String representation for debugging"""
        return f"Stack(top→{self.stack[::-1]})"


# === DEMONSTRATION ===

if __name__ == "__main__":
    stack = ArrayStack()
    
    # Push operations
    print("=== Push Operations ===")
    for val in [10, 20, 30, 40]:
        stack.push(val)
        print(f"Pushed {val}: {stack}")
    
    # Output:
    # Pushed 10: Stack(top→[10])
    # Pushed 20: Stack(top→[20, 10])
    # Pushed 30: Stack(top→[30, 20, 10])
    # Pushed 40: Stack(top→[40, 30, 20, 10])
    
    print(f"\nPeek: {stack.peek()}")  # 40
    print(f"Size: {stack.size()}")    # 4
    
    # Pop operations
    print("\n=== Pop Operations ===")
    while not stack.is_empty():
        print(f"Popped: {stack.pop()}, Remaining: {stack}")
    
    # Output:
    # Popped: 40, Remaining: Stack(top→[30, 20, 10])
    # Popped: 30, Remaining: Stack(top→[20, 10])
    # Popped: 20, Remaining: Stack(top→[10])
    # Popped: 10, Remaining: Stack(top→[])
```

#### Fixed-Size Array Implementation (Interview Classic)

```python
class FixedArrayStack:
    """
    Stack with fixed capacity - commonly asked in interviews
    
    This demonstrates manual index management without
    relying on Python's dynamic list
    """
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.array = [None] * capacity  # Pre-allocate
        self.top_index = -1  # -1 indicates empty stack
    
    def push(self, item):
        if self.top_index >= self.capacity - 1:
            raise OverflowError("Stack Overflow!")
        self.top_index += 1
        self.array[self.top_index] = item
    
    def pop(self):
        if self.top_index < 0:
            raise IndexError("Stack Underflow!")
        item = self.array[self.top_index]
        self.array[self.top_index] = None  # Help garbage collection
        self.top_index -= 1
        return item
    
    def peek(self):
        if self.top_index < 0:
            raise IndexError("Stack is empty")
        return self.array[self.top_index]
    
    def is_empty(self):
        return self.top_index == -1
    
    def is_full(self):
        return self.top_index == self.capacity - 1
    
    def size(self):
        return self.top_index + 1
```

---

### Approach 2: Linked List-Based Implementation

```
LINKED LIST STACK VISUALIZATION:

Push order: 1 → 2 → 3 → 4

       TOP
        ↓
    ┌───────┐    ┌───────┐    ┌───────┐    ┌───────┐
    │   4   │───→│   3   │───→│   2   │───→│   1   │───→ NULL
    └───────┘    └───────┘    └───────┘    └───────┘
    
Push(5):
       TOP
        ↓
    ┌───────┐    ┌───────┐    ┌───────┐    ┌───────┐    ┌───────┐
    │   5   │───→│   4   │───→│   3   │───→│   2   │───→│   1   │───→ NULL
    └───────┘    └───────┘    └───────┘    └───────┘    └───────┘
    (new node)

Pop():
       TOP (moved)
        ↓
    ┌───────┐    ┌───────┐    ┌───────┐    ┌───────┐
    │   4   │───→│   3   │───→│   2   │───→│   1   │───→ NULL
    └───────┘    └───────┘    └───────┘    └───────┘
    
    Returns: 5 (node deleted)
```

#### Python Implementation (Linked List-Based)

```python
class Node:
    """Node for linked list stack"""
    
    __slots__ = ['data', 'next']  # Memory optimization
    
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedListStack:
    """
    Stack implementation using singly linked list
    
    Advantages:
    - True O(1) push/pop (no resizing ever)
    - Dynamic size (limited only by memory)
    - No wasted space
    
    Disadvantages:
    - Extra memory for pointers
    - Not cache-friendly (nodes scattered in memory)
    - Slightly more complex implementation
    """
    
    def __init__(self):
        self.top = None  # Pointer to top node
        self._size = 0
    
    def push(self, item):
        """
        Add new node at the top
        
        Time Complexity: O(1) - always
        Space Complexity: O(1)
        
        Visual:
        Before: top → [3] → [2] → [1] → None
        After:  top → [4] → [3] → [2] → [1] → None
        """
        new_node = Node(item)
        new_node.next = self.top  # Link to current top
        self.top = new_node       # Update top pointer
        self._size += 1
    
    def pop(self):
        """
        Remove and return top node's data
        
        Time Complexity: O(1)
        
        Visual:
        Before: top → [4] → [3] → [2] → [1] → None
        After:  top → [3] → [2] → [1] → None
        Returns: 4
        """
        if self.is_empty():
            raise IndexError("Pop from empty stack")
        
        item = self.top.data
        self.top = self.top.next  # Move top to next node
        self._size -= 1
        return item
    
    def peek(self):
        """Return top element without removing - O(1)"""
        if self.is_empty():
            raise IndexError("Peek from empty stack")
        return self.top.data
    
    def is_empty(self):
        """Check if stack is empty - O(1)"""
        return self.top is None
    
    def size(self):
        """Return number of elements - O(1)"""
        return self._size
    
    def __str__(self):
        """Visualize stack for debugging"""
        elements = []
        current = self.top
        while current:
            elements.append(str(current.data))
            current = current.next
        return "TOP → " + " → ".join(elements) + " → None"


# === DEMONSTRATION ===

if __name__ == "__main__":
    stack = LinkedListStack()
    
    print("=== Linked List Stack Demo ===\n")
    
    # Push operations
    for val in [1, 2, 3, 4]:
        stack.push(val)
        print(f"After push({val}): {stack}")
    
    # Output:
    # After push(1): TOP → 1 → None
    # After push(2): TOP → 2 → 1 → None
    # After push(3): TOP → 3 → 2 → 1 → None
    # After push(4): TOP → 4 → 3 → 2 → 1 → None
    
    print(f"\nPeek: {stack.peek()}")  # 4
    
    # Pop operations
    print("\n=== Popping all elements ===")
    while not stack.is_empty():
        val = stack.pop()
        print(f"Popped {val}: {stack}")
```

---

## 1.4 Comparison: Array vs Linked List

```
┌─────────────────┬──────────────────────┬──────────────────────┐
│   Aspect        │   Array-Based        │   Linked List        │
├─────────────────┼──────────────────────┼──────────────────────┤
│ Push            │ O(1) amortized*      │ O(1) always          │
│ Pop             │ O(1)                 │ O(1)                 │
│ Peek            │ O(1)                 │ O(1)                 │
│ Memory          │ Contiguous           │ Scattered            │
│ Cache           │ Cache-friendly       │ Cache-unfriendly     │
│ Extra Space     │ None                 │ Pointer per node     │
│ Size Limit      │ Need resizing        │ Limited by memory    │
│ Implementation  │ Simpler              │ Slightly complex     │
└─────────────────┴──────────────────────┴──────────────────────┘

* Amortized O(1): Usually O(1), but occasionally O(n) when resizing
  Average over many operations is still O(1)
```

### Memory Layout Visualization

```
ARRAY-BASED (Contiguous Memory):
┌─────────────────────────────────────────┐
│ Memory Address: 1000  1004  1008  1012  │
│                 ┌────┬────┬────┬────┐   │
│                 │ 10 │ 20 │ 30 │ 40 │   │
│                 └────┴────┴────┴────┘   │
│                 Excellent cache locality │
└─────────────────────────────────────────┘

LINKED LIST (Scattered Memory):
┌─────────────────────────────────────────┐
│ Address 1000: [40|ptr]──┐               │
│                         ↓               │
│ Address 5000: [30|ptr]──┐               │
│                         ↓               │
│ Address 2500: [20|ptr]──┐               │
│                         ↓               │
│ Address 8000: [10|null]                 │
│                                         │
│ Poor cache locality, more memory used   │
└─────────────────────────────────────────┘
```

---

## 1.5 Stack Using Python's Built-in Structures

### Using list (Recommended for Interviews)

```python
# Simple and efficient - USE THIS IN INTERVIEWS
stack = []

stack.append(1)     # Push
stack.append(2)
stack.append(3)

top = stack[-1]     # Peek → 3
val = stack.pop()   # Pop → 3

is_empty = len(stack) == 0  # Check empty
```

### Using collections.deque (Slightly Faster)

```python
from collections import deque

stack = deque()

stack.append(1)     # Push - O(1)
stack.append(2)
stack.append(3)

top = stack[-1]     # Peek → 3
val = stack.pop()   # Pop → 3

# deque is implemented as doubly-linked list
# Guaranteed O(1) for append/pop from both ends
```

### Using queue.LifoQueue (Thread-Safe)

```python
from queue import LifoQueue

stack = LifoQueue()

stack.put(1)        # Push
stack.put(2)
stack.put(3)

val = stack.get()   # Pop → 3

# Thread-safe, useful for concurrent programs
# Has blocking operations with timeout
```

---

## 1.6 Common Pitfalls & Best Practices

### ❌ Common Mistakes

```python
# MISTAKE 1: Not checking empty before pop/peek
stack = []
val = stack.pop()  # IndexError: pop from empty list

# MISTAKE 2: Using wrong end of list
stack = []
stack.insert(0, 1)  # O(n) - WRONG! Use append()
stack.pop(0)        # O(n) - WRONG! Use pop()

# MISTAKE 3: Confusing peek and pop
stack = [1, 2, 3]
top = stack.pop()   # Stack is now [1, 2] - element removed!
# Should use: top = stack[-1]
```

### ✅ Best Practices

```python
# PRACTICE 1: Always check before pop/peek
def safe_pop(stack):
    if stack:  # or: if len(stack) > 0
        return stack.pop()
    return None  # or raise custom exception

# PRACTICE 2: Use helper functions for clarity
def push(stack, item):
    stack.append(item)

def pop(stack):
    return stack.pop() if stack else None

def peek(stack):
    return stack[-1] if stack else None

def is_empty(stack):
    return len(stack) == 0

# PRACTICE 3: Document stack contents
# Stack stores: (value, timestamp) tuples
stack = []
stack.append((42, 1234567890))
```

---

## 1.7 Interview Tips for Stack Fundamentals

### What Interviewers Look For:

```
1. CORRECTNESS
   - Handle empty stack cases
   - Maintain LIFO property
   
2. EFFICIENCY
   - All operations should be O(1)
   - Know when to use array vs linked list
   
3. CODE QUALITY
   - Clean, readable implementation
   - Proper error handling
   
4. COMMUNICATION
   - Explain your design choices
   - Discuss trade-offs
```

### Quick Reference Card

```
┌─────────────────────────────────────────────────────┐
│          STACK FUNDAMENTALS CHEATSHEET              │
├─────────────────────────────────────────────────────┤
│                                                     │
│  LIFO = Last In, First Out                          │
│                                                     │
│  OPERATIONS:          TIME:                         │
│  ─────────────────────────────                      │
│  push(x)              O(1)                          │
│  pop()                O(1)                          │
│  peek() / top()       O(1)                          │
│  isEmpty()            O(1)                          │
│  size()               O(1)                          │
│                                                     │
│  PYTHON QUICK USAGE:                                │
│  ─────────────────────────────                      │
│  stack = []                                         │
│  stack.append(x)      # push                        │
│  stack.pop()          # pop                         │
│  stack[-1]            # peek                        │
│  len(stack) == 0      # isEmpty                     │
│                                                     │
│  ALWAYS CHECK: if stack: before pop/peek            │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

## Practice Problems for Chapter 1

| Problem | Difficulty | Key Concept |
|---------|------------|-------------|
| Implement Stack using Array | Easy | Basic implementation |
| Implement Stack using Linked List | Easy | Pointer manipulation |
| Implement Two Stacks in One Array | Medium | Space optimization |
| Design Stack with getMin() O(1) | Medium | Auxiliary data structure |
| Implement Stack using Queues | Medium | Data structure conversion |
