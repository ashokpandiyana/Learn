# Chapter 2: Basic Stack Problems

## 2.1 The Parentheses Matching Family

This is the most fundamental stack problem family. Master this, and you'll understand why stacks exist!

### The Core Insight

```
WHY STACK FOR PARENTHESES?

Consider: ( ( ) ( ( ) ) )
          1 2 3 4 5 6 7 8

When we see ')' at position 3, which '(' does it match?
→ The MOST RECENT unmatched '(' (position 2)

This is LIFO behavior → Perfect for Stack!

MATCHING VISUALIZATION:
        
( ( ) ( ( ) ) )
│ │ │ │ │ │ │ │
│ └─┘ │ │ └─┘ │   Inner pairs match first
│     └───────┘   Then outer pairs
└───────────────┘ 
```

---

### Problem 1: Valid Parentheses (Single Type)

**Problem**: Check if string of `(` and `)` is valid.

```
Valid:   "(())"  "()()"  "((()))"
Invalid: "(()"   ")("    "())("
```

#### Solution Walkthrough

```
Input: "((()))"

Step-by-step:
─────────────────────────────────────────────────────
Char │ Action              │ Stack      │ Valid?
─────────────────────────────────────────────────────
 (   │ Push '('            │ [(]        │ ...
 (   │ Push '('            │ [(, (]     │ ...
 (   │ Push '('            │ [(, (, (]  │ ...
 )   │ Match! Pop          │ [(, (]     │ ...
 )   │ Match! Pop          │ [(]        │ ...
 )   │ Match! Pop          │ []         │ ...
─────────────────────────────────────────────────────
END  │ Stack empty?        │ YES        │ ✓ VALID
```

```python
def is_valid_parentheses_single(s: str) -> bool:
    """
    Check if string with only '(' and ')' is valid
    
    Time Complexity: O(n) - single pass
    Space Complexity: O(n) - worst case all opening
    
    Example:
        "(())" → True
        "(()"  → False
    """
    stack = []
    
    for char in s:
        if char == '(':
            # Opening bracket: push to stack
            stack.append(char)
        elif char == ')':
            # Closing bracket: need a matching opening
            if not stack:
                # No opening bracket to match
                return False
            stack.pop()  # Match found, remove opening
    
    # Valid only if all openings are matched
    return len(stack) == 0


# Test cases
print(is_valid_parentheses_single("(())"))    # True
print(is_valid_parentheses_single("()()"))    # True
print(is_valid_parentheses_single("(()"))     # False (extra opening)
print(is_valid_parentheses_single("())"))     # False (extra closing)
print(is_valid_parentheses_single(")("))      # False (wrong order)
```

---

### Problem 2: Valid Parentheses (Multiple Types) ⭐

**LeetCode 20** - Most common interview question!

**Problem**: Check if string with `()`, `{}`, `[]` is valid.

```
Valid:   "()[]{}"  "{[]}"  "([{}])"
Invalid: "(]"      "([)]"  "{[}"
```

#### Visual Understanding

```
Input: "([{}])"

VALID NESTING:              INVALID CROSSING:
    ┌─────┐                     ┌───┐
    │  {} │                     │ ( │
  ┌─┴────┴─┐                  ┌─┼───┼─┐
  │  []    │                  │ │ [ │ │
┌─┴────────┴─┐                │ └─┬─┘ │
│    ()      │                │   │   │
└────────────┘                │   ] ) │
                              └───────┘
Brackets properly nested     Brackets CROSS - Invalid!
```

#### Solution

```python
def is_valid_parentheses(s: str) -> bool:
    """
    Valid Parentheses with multiple bracket types
    
    Key Insight: Each closing bracket must match the 
    MOST RECENT unmatched opening bracket (LIFO)
    
    Time: O(n), Space: O(n)
    """
    # Mapping: closing → opening
    bracket_map = {
        ')': '(',
        '}': '{',
        ']': '['
    }
    
    stack = []
    
    for char in s:
        if char in bracket_map:
            # It's a closing bracket
            # Check if it matches the most recent opening
            if not stack:
                return False  # Nothing to match
            
            top = stack.pop()
            if top != bracket_map[char]:
                return False  # Wrong type of bracket
        else:
            # It's an opening bracket
            stack.append(char)
    
    return len(stack) == 0


# Trace through "([)]" (INVALID):
# ─────────────────────────────────────────────────
# Char │ Action              │ Stack     │ Result
# ─────────────────────────────────────────────────
#  (   │ Push                │ ['(']     │ 
#  [   │ Push                │ ['(','['] │ 
#  )   │ Pop '[', check      │ -         │ FAIL!
#      │ ')' needs '(' but   │           │
#      │ got '['             │           │
# ─────────────────────────────────────────────────


# Alternative: Store expected closing bracket
def is_valid_alternative(s: str) -> bool:
    """
    Alternative approach: push expected closing bracket
    """
    stack = []
    
    for char in s:
        if char == '(':
            stack.append(')')  # Expect ')' later
        elif char == '{':
            stack.append('}')
        elif char == '[':
            stack.append(']')
        elif not stack or stack.pop() != char:
            # Closing doesn't match expected
            return False
    
    return len(stack) == 0
```

---

### Problem 3: Minimum Add to Make Valid

**Problem**: Return minimum insertions to make parentheses valid.

```
"())" → 1  (add '(' at start)
"(((" → 3  (add ')))')
"()()" → 0 (already valid)
```

#### Visual Solution

```
Input: "())(("

Analysis:
─────────────────────────────────────────────────────
Char │ Stack │ Unmatched ')' │ Need
─────────────────────────────────────────────────────
 (   │ [(]   │ 0             │
 )   │ []    │ 0             │ Matched!
 )   │ []    │ 1             │ No '(' to match
 (   │ [(]   │ 1             │
 (   │ [(,(] │ 1             │
─────────────────────────────────────────────────────
END: Stack has 2 unmatched '('
     Plus 1 unmatched ')'
     Total needed: 2 + 1 = 3
```

```python
def min_add_to_make_valid(s: str) -> int:
    """
    Count minimum brackets needed to make valid
    
    Key Insight:
    - Track unmatched '(' in stack
    - Track unmatched ')' separately (no '(' to pop)
    
    Time: O(n), Space: O(n)
    """
    stack = []          # Unmatched opening brackets
    unmatched_close = 0  # Closing brackets without match
    
    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if stack:
                stack.pop()  # Match found
            else:
                unmatched_close += 1  # No '(' to match
    
    # Need: one ')' for each '(' in stack
    #       one '(' for each unmatched ')'
    return len(stack) + unmatched_close


# Space-optimized version (no actual stack needed)
def min_add_to_make_valid_optimized(s: str) -> int:
    """
    We only need COUNT, not actual brackets
    """
    open_count = 0    # Unmatched '(' count
    close_needed = 0  # ')' without matching '('
    
    for char in s:
        if char == '(':
            open_count += 1
        elif char == ')':
            if open_count > 0:
                open_count -= 1
            else:
                close_needed += 1
    
    return open_count + close_needed
```

---

### Problem 4: Minimum Remove to Make Valid

**LeetCode 1249** - Facebook favorite!

**Problem**: Remove minimum characters to make valid. Return the result string.

```
"lee(t(c)o)de)" → "lee(t(c)o)de"  (remove last ')')
"a)b(c)d" → "ab(c)d"              (remove first ')')
"))((" → ""                        (remove all)
```

#### Solution Strategy

```
TWO-PASS APPROACH:

Input: "a)b(c)d("

Pass 1 (Left to Right): Mark invalid ')'
─────────────────────────────────────────────────────
a  )  b  (  c  )  d  (
   ✗           ✓        →  balance = 0, ')' invalid!

Pass 2 (Right to Left): Mark invalid '('
─────────────────────────────────────────────────────
a  )  b  (  c  )  d  (
               ✓     ✗  →  balance = 0, '(' invalid!

Result: "ab(c)d"
```

```python
def min_remove_to_make_valid(s: str) -> str:
    """
    Remove minimum parentheses to make string valid
    
    Strategy: Use stack to track indices of invalid brackets
    
    Time: O(n), Space: O(n)
    """
    s = list(s)  # Convert to list for modification
    stack = []   # Store INDICES of '('
    
    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)  # Store index
        elif char == ')':
            if stack:
                stack.pop()  # Found matching '('
            else:
                s[i] = ''    # Mark for removal (no '(' to match)
    
    # Remaining items in stack are unmatched '('
    for i in stack:
        s[i] = ''
    
    return ''.join(s)


# Alternative: Two-pass approach
def min_remove_two_pass(s: str) -> str:
    """
    Two-pass: First remove invalid ')', then invalid '('
    """
    def remove_invalid(string, open_bracket, close_bracket):
        """Remove invalid close brackets (reading left to right)"""
        result = []
        balance = 0
        
        for char in string:
            if char == open_bracket:
                balance += 1
                result.append(char)
            elif char == close_bracket:
                if balance > 0:
                    balance -= 1
                    result.append(char)
                # else: skip this invalid close bracket
            else:
                result.append(char)
        
        return ''.join(result)
    
    # Pass 1: Remove invalid ')' (left to right)
    temp = remove_invalid(s, '(', ')')
    
    # Pass 2: Remove invalid '(' (right to left)
    # Trick: Reverse, swap brackets, process, reverse back
    reversed_temp = temp[::-1]
    result = remove_invalid(reversed_temp, ')', '(')
    
    return result[::-1]


# Test
print(min_remove_to_make_valid("lee(t(c)o)de)"))  # "lee(t(c)o)de"
print(min_remove_to_make_valid("a)b(c)d"))        # "ab(c)d"
print(min_remove_to_make_valid("))(("))           # ""
```

---

### Problem 5: Longest Valid Parentheses ⭐⭐ (Hard)

**LeetCode 32** - Classic hard problem!

**Problem**: Find length of longest valid parentheses substring.

```
"(()" → 2      (the "()")
")()())" → 4   (the "()()")
"()(())" → 6   (entire string)
```

#### Key Insight

```
STORE INDICES, NOT CHARACTERS!

Why? We need to calculate LENGTHS between positions.

Input: ")()())"
Index:  0 1 2 3 4 5

Stack stores: INDICES of unmatched '(' 
              AND a "base" index for length calculation

─────────────────────────────────────────────────────
i │ s[i] │ Action              │ Stack    │ Max Length
─────────────────────────────────────────────────────
- │  -   │ Initialize          │ [-1]     │ 0
0 │  )   │ Pop -1, push 0      │ [0]      │ 0
1 │  (   │ Push index          │ [0,1]    │ 0
2 │  )   │ Pop 1, len=2-0=2    │ [0]      │ 2
3 │  (   │ Push index          │ [0,3]    │ 2
4 │  )   │ Pop 3, len=4-0=4    │ [0]      │ 4
5 │  )   │ Pop 0, push 5       │ [5]      │ 4
─────────────────────────────────────────────────────
Answer: 4
```

```python
def longest_valid_parentheses(s: str) -> int:
    """
    Find longest valid parentheses substring
    
    Key Insight: Stack stores INDICES
    - Push -1 initially as base for length calculation
    - For '(': push index
    - For ')': pop, then:
        - If stack empty: push current index as new base
        - Else: current length = i - stack[-1]
    
    Time: O(n), Space: O(n)
    """
    stack = [-1]  # Base index for length calculation
    max_length = 0
    
    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)
        else:  # char == ')'
            stack.pop()
            
            if not stack:
                # No matching '(', use current as new base
                stack.append(i)
            else:
                # Valid pair found, calculate length
                length = i - stack[-1]
                max_length = max(max_length, length)
    
    return max_length


# Alternative: Dynamic Programming approach
def longest_valid_dp(s: str) -> int:
    """
    DP approach: dp[i] = length of longest valid ending at i
    
    Transitions:
    - If s[i] == '(' : dp[i] = 0 (can't end with '(')
    - If s[i] == ')':
        - If s[i-1] == '(': dp[i] = dp[i-2] + 2
        - If s[i-1] == ')' and s[i-dp[i-1]-1] == '(':
          dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]
    """
    if not s:
        return 0
    
    n = len(s)
    dp = [0] * n
    max_length = 0
    
    for i in range(1, n):
        if s[i] == ')':
            if s[i-1] == '(':
                # Pattern: ...()
                dp[i] = (dp[i-2] if i >= 2 else 0) + 2
            elif i - dp[i-1] - 1 >= 0 and s[i - dp[i-1] - 1] == '(':
                # Pattern: ...))
                dp[i] = dp[i-1] + 2
                if i - dp[i-1] - 2 >= 0:
                    dp[i] += dp[i - dp[i-1] - 2]
            
            max_length = max(max_length, dp[i])
    
    return max_length


# Test
print(longest_valid_parentheses("(()"))      # 2
print(longest_valid_parentheses(")()())"))   # 4
print(longest_valid_parentheses("()(())"))   # 6
```

---

### Problem 6: Score of Parentheses

**LeetCode 856**

**Problem**: Calculate score where `()` = 1, `AB` = A+B, `(A)` = 2*A

```
"()" → 1
"(())" → 2        (2 * 1)
"()()" → 2        (1 + 1)
"(()(()))" → 6    (2 * (1 + 2))
```

```python
def score_of_parentheses(s: str) -> int:
    """
    Score parentheses string
    
    Stack approach:
    - '(' : Push current score, reset to 0
    - ')' : Pop and calculate: prev + max(2*current, 1)
    
    Time: O(n), Space: O(n)
    """
    stack = []
    current = 0
    
    for char in s:
        if char == '(':
            # Save current score, start new scope
            stack.append(current)
            current = 0
        else:  # char == ')'
            # Calculate score for this pair
            # If current == 0: it's "()" worth 1
            # Else: it's "(A)" worth 2*A
            prev = stack.pop()
            current = prev + max(2 * current, 1)
    
    return current


# Alternative: Depth-based approach
def score_depth_based(s: str) -> int:
    """
    Key insight: Only "()" contributes, worth 2^depth
    
    "((()))" → "()" at depth 2 → 2^2 = 4
    """
    score = 0
    depth = 0
    
    for i, char in enumerate(s):
        if char == '(':
            depth += 1
        else:
            depth -= 1
            if s[i-1] == '(':  # Found "()"
                score += 2 ** depth
    
    return score
```

---

## 2.2 Basic Expression and String Problems

### Problem 1: Reverse String Using Stack

```python
def reverse_string(s: str) -> str:
    """
    Reverse string using stack (demonstrating LIFO)
    
    Note: In real interviews, use s[::-1] or two pointers
    This is for understanding stack behavior
    """
    stack = []
    
    # Push all characters
    for char in s:
        stack.append(char)
    
    # Pop all characters (reverse order)
    result = []
    while stack:
        result.append(stack.pop())
    
    return ''.join(result)


# Visual:
# Input: "hello"
# Push: h → e → l → l → o   Stack: [h,e,l,l,o]
# Pop:  o → l → l → e → h   Result: "olleh"
```

---

### Problem 2: Remove Adjacent Duplicates

**LeetCode 1047**

```
"abbaca" → "ca"
Explanation: "abbaca" → "aaca" → "ca"
```

```python
def remove_duplicates(s: str) -> str:
    """
    Remove adjacent duplicate characters
    
    Stack stores characters. When current matches top, pop instead of push.
    
    Time: O(n), Space: O(n)
    """
    stack = []
    
    for char in s:
        if stack and stack[-1] == char:
            stack.pop()  # Remove pair
        else:
            stack.append(char)
    
    return ''.join(stack)


# Trace "abbaca":
# ─────────────────────────────────────────
# Char │ Action           │ Stack
# ─────────────────────────────────────────
#  a   │ Push            │ [a]
#  b   │ Push            │ [a, b]
#  b   │ Match! Pop      │ [a]
#  a   │ Match! Pop      │ []
#  c   │ Push            │ [c]
#  a   │ Push            │ [c, a]
# ─────────────────────────────────────────
# Result: "ca"
```

---

### Problem 3: Remove All Adjacent Duplicates II

**LeetCode 1209** - Harder version!

```
"deeedbbcccbdaa", k=3 → "aa"
Remove 3+ consecutive duplicates
```

```python
def remove_duplicates_k(s: str, k: int) -> str:
    """
    Remove k adjacent duplicates
    
    Stack stores: (character, count) pairs
    
    Time: O(n), Space: O(n)
    """
    # Stack of [char, count] pairs
    stack = []
    
    for char in s:
        if stack and stack[-1][0] == char:
            stack[-1][1] += 1  # Increment count
            if stack[-1][1] == k:
                stack.pop()    # Remove k duplicates
        else:
            stack.append([char, 1])
    
    # Rebuild string
    return ''.join(char * count for char, count in stack)


# Trace "deeedbbcccbdaa" with k=3:
# ─────────────────────────────────────────────────
# Char │ Action                │ Stack
# ─────────────────────────────────────────────────
#  d   │ Push (d,1)           │ [(d,1)]
#  e   │ Push (e,1)           │ [(d,1),(e,1)]
#  e   │ Inc to (e,2)         │ [(d,1),(e,2)]
#  e   │ Inc to (e,3) → POP   │ [(d,1)]
#  d   │ Inc to (d,2)         │ [(d,2)]
#  b   │ Push (b,1)           │ [(d,2),(b,1)]
#  b   │ Inc to (b,2)         │ [(d,2),(b,2)]
#  c   │ Push (c,1)           │ [(d,2),(b,2),(c,1)]
#  c   │ Inc to (c,2)         │ [(d,2),(b,2),(c,2)]
#  c   │ Inc to (c,3) → POP   │ [(d,2),(b,2)]
#  b   │ Inc to (b,3) → POP   │ [(d,2)]
#  d   │ Inc to (d,3) → POP   │ []
#  a   │ Push (a,1)           │ [(a,1)]
#  a   │ Inc to (a,2)         │ [(a,2)]
# ─────────────────────────────────────────────────
# Result: "aa"
```

---

### Problem 4: Decode String ⭐

**LeetCode 394** - Very common!

```
"3[a]2[bc]" → "aaabcbc"
"3[a2[c]]" → "accaccacc"
"2[abc]3[cd]ef" → "abcabccdcdcdef"
```

```python
def decode_string(s: str) -> str:
    """
    Decode nested encoded string
    
    Two stacks:
    - num_stack: stores repeat counts
    - str_stack: stores string built before '['
    
    Time: O(n * max_k), Space: O(n)
    """
    num_stack = []   # Stack for numbers
    str_stack = []   # Stack for strings
    current_str = "" # Current string being built
    current_num = 0  # Current number being parsed
    
    for char in s:
        if char.isdigit():
            # Build multi-digit number
            current_num = current_num * 10 + int(char)
        
        elif char == '[':
            # Save current state and start new scope
            num_stack.append(current_num)
            str_stack.append(current_str)
            current_num = 0
            current_str = ""
        
        elif char == ']':
            # Complete current scope
            # Pop repeat count and previous string
            repeat = num_stack.pop()
            prev_str = str_stack.pop()
            current_str = prev_str + current_str * repeat
        
        else:
            # Regular character
            current_str += char
    
    return current_str


# Trace "3[a2[c]]":
# ─────────────────────────────────────────────────────────
# Char│ num_stack │ str_stack │ curr_num │ curr_str
# ─────────────────────────────────────────────────────────
#  3  │ []        │ []        │ 3        │ ""
#  [  │ [3]       │ [""]      │ 0        │ ""
#  a  │ [3]       │ [""]      │ 0        │ "a"
#  2  │ [3]       │ [""]      │ 2        │ "a"
#  [  │ [3,2]     │ ["","a"]  │ 0        │ ""
#  c  │ [3,2]     │ ["","a"]  │ 0        │ "c"
#  ]  │ [3]       │ [""]      │ 0        │ "a"+"cc"="acc"
#  ]  │ []        │ []        │ 0        │ ""+"accaccacc"
# ─────────────────────────────────────────────────────────
# Result: "accaccacc"


# Alternative: Recursive approach
def decode_string_recursive(s: str) -> str:
    """
    Recursive approach using implicit call stack
    """
    def helper(index):
        result = ""
        num = 0
        
        while index < len(s):
            char = s[index]
            
            if char.isdigit():
                num = num * 10 + int(char)
            elif char == '[':
                # Recurse into nested structure
                substring, index = helper(index + 1)
                result += num * substring
                num = 0
            elif char == ']':
                # End of current scope
                return result, index
            else:
                result += char
            
            index += 1
        
        return result, index
    
    return helper(0)[0]
```

---

### Problem 5: Simplify Path

**LeetCode 71** - Unix path simplification

```
"/home/" → "/home"
"/../" → "/"
"/home//foo/" → "/home/foo"
"/a/./b/../../c/" → "/c"
```

```python
def simplify_path(path: str) -> str:
    """
    Simplify Unix-style absolute path
    
    Rules:
    - '.' means current directory (ignore)
    - '..' means parent directory (pop from stack)
    - Multiple slashes treated as single
    - Empty parts ignored
    
    Time: O(n), Space: O(n)
    """
    stack = []
    
    # Split by '/' and process each component
    components = path.split('/')
    
    for component in components:
        if component == '' or component == '.':
            # Empty (from //) or current dir - ignore
            continue
        elif component == '..':
            # Parent directory - go up if possible
            if stack:
                stack.pop()
        else:
            # Valid directory name
            stack.append(component)
    
    return '/' + '/'.join(stack)


# Trace "/a/./b/../../c/":
# Split: ['', 'a', '.', 'b', '..', '..', 'c', '']
# ─────────────────────────────────────────
# Component │ Action      │ Stack
# ─────────────────────────────────────────
# ''        │ Ignore      │ []
# 'a'       │ Push        │ ['a']
# '.'       │ Ignore      │ ['a']
# 'b'       │ Push        │ ['a', 'b']
# '..'      │ Pop         │ ['a']
# '..'      │ Pop         │ []
# 'c'       │ Push        │ ['c']
# ''        │ Ignore      │ ['c']
# ─────────────────────────────────────────
# Result: "/" + "c" = "/c"
```

---

### Problem 6: Backspace String Compare

**LeetCode 844**

```
"ab#c" vs "ad#c" → True (both become "ac")
"ab##" vs "c#d#" → True (both become "")
"a#c" vs "b" → False ("c" vs "b")
```

```python
def backspace_compare(s: str, t: str) -> bool:
    """
    Compare two strings with backspace (#)
    
    Time: O(n + m), Space: O(n + m)
    """
    def process(string):
        stack = []
        for char in string:
            if char == '#':
                if stack:
                    stack.pop()
            else:
                stack.append(char)
        return ''.join(stack)
    
    return process(s) == process(t)


# Space-optimized: O(1) space using two pointers
def backspace_compare_optimal(s: str, t: str) -> bool:
    """
    O(1) space solution: Process from right to left
    """
    def get_next_valid_index(string, index):
        """Get next valid character index (skipping backspaces)"""
        skip = 0
        while index >= 0:
            if string[index] == '#':
                skip += 1
                index -= 1
            elif skip > 0:
                skip -= 1
                index -= 1
            else:
                break
        return index
    
    i, j = len(s) - 1, len(t) - 1
    
    while i >= 0 or j >= 0:
        i = get_next_valid_index(s, i)
        j = get_next_valid_index(t, j)
        
        # Both exhausted
        if i < 0 and j < 0:
            return True
        # One exhausted
        if i < 0 or j < 0:
            return False
        # Characters don't match
        if s[i] != t[j]:
            return False
        
        i -= 1
        j -= 1
    
    return True
```

---

## 2.3 Pattern Summary

### When to Use Stack for String Problems

```
┌──────────────────────────────────────────────────────────────┐
│              STACK FOR STRING PROBLEMS                       │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  USE STACK WHEN:                                             │
│  ─────────────────                                           │
│  ✓ Matching pairs (parentheses, tags)                        │
│  ✓ Nested structures (decode, parse)                         │
│  ✓ Most recent matters (backspace, undo)                     │
│  ✓ Need to reverse order                                     │
│  ✓ Adjacent elements interact (remove duplicates)            │
│                                                              │
│  WHAT TO STORE:                                              │
│  ─────────────────                                           │
│  • Characters - when you need the actual values              │
│  • Indices - when you need positions/lengths                 │
│  • (char, count) - when counting consecutive items           │
│  • (value, state) - when tracking additional info            │
│                                                              │
│  COMMON PATTERNS:                                            │
│  ─────────────────                                           │
│  1. Push opening, pop on closing (parentheses)               │
│  2. Push all, then pop to reverse                            │
│  3. Compare top before push (duplicates)                     │
│  4. Save state on '[', restore on ']' (decode)               │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

---

## Practice Problems

| Problem | Difficulty | Key Technique |
|---------|------------|---------------|
| Valid Parentheses | Easy | Basic matching |
| Min Add for Valid | Easy | Count unmatched |
| Remove Invalid Parentheses | Hard | BFS + Stack |
| Longest Valid Parentheses | Hard | Stack with indices |
| Remove Duplicates | Easy | Compare with top |
| Remove Duplicates II (k) | Medium | Stack of (char, count) |
| Decode String | Medium | Two stacks |
| Basic Calculator | Hard | Nested expressions |
