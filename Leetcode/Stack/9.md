# Chapter 9: Hard Interview Problems

## 9.1 Remove K Digits (LeetCode 402) ⭐⭐

```
PROBLEM:
═══════════════════════════════════════════════════════════════

Remove k digits from num to make smallest possible number.

Input: num = "1432219", k = 3
Output: "1219"
Explanation: Remove 4, 3, 2 → "1219"

Input: num = "10200", k = 1
Output: "200"
Explanation: Remove 1 → "0200" → "200"
```

### Key Insight

```
GREEDY + MONOTONIC STACK:
═══════════════════════════════════════════════════════════════

To minimize number, we want SMALLER digits at the FRONT.

When do we remove a digit?
→ When current digit is SMALLER than previous digit
→ Previous digit makes number larger, remove it!

Example: "1432219"
- See 1, push → [1]
- See 4, 4 > 1, push → [1,4]
- See 3, 3 < 4, pop 4, push → [1,3]
- See 2, 2 < 3, pop 3, push → [1,2]
- See 2, 2 = 2, push → [1,2,2]
- See 1, 1 < 2, pop 2, push → [1,2,1]
  (k exhausted at this point in reality)
...

Result is monotonically increasing (mostly)!
```

### Implementation

```python
def removeKdigits(num, k):
    """
    Remove k digits to make smallest number
    
    Use MONOTONICALLY INCREASING stack
    Pop larger digits when smaller digit arrives
    
    Time: O(n), Space: O(n)
    """
    stack = []
    
    for digit in num:
        # Pop while: have removals left, stack not empty, 
        # and current digit is smaller
        while k > 0 and stack and stack[-1] > digit:
            stack.pop()
            k -= 1
        
        stack.append(digit)
    
    # If k > 0, remove from end (already increasing)
    while k > 0:
        stack.pop()
        k -= 1
    
    # Build result, remove leading zeros
    result = ''.join(stack).lstrip('0')
    
    return result if result else '0'


# DETAILED TRACE: num = "1432219", k = 3
"""
digit='1': stack=[], push → ['1']
digit='4': 4 > 1, push → ['1','4']
digit='3': 3 < 4, pop '4', k=2 → ['1']
           push → ['1','3']
digit='2': 2 < 3, pop '3', k=1 → ['1']
           push → ['1','2']
digit='2': 2 = 2, push → ['1','2','2']
digit='1': 1 < 2, pop '2', k=0 → ['1','2']
           push → ['1','2','1']
digit='9': 9 > 1, push → ['1','2','1','9']

k=0, no more pops

Result: "1219" ✓
"""


# EDGE CASE: Decreasing sequence
"""
num = "9876", k = 2

digit='9': push → ['9']
digit='8': 8 < 9, pop, k=1 → []
           push → ['8']
digit='7': 7 < 8, pop, k=0 → []
           push → ['7']
digit='6': push → ['7','6']

Result: "76"
"""
```

---

## 9.2 Remove Duplicate Letters (LeetCode 316) ⭐⭐

```
PROBLEM:
═══════════════════════════════════════════════════════════════

Remove duplicate letters to make smallest lexicographical string
Each letter appears exactly ONCE in result.

Input: "bcabc" → Output: "abc"
Input: "cbacdcbc" → Output: "acdb"
```

### Key Insight

```
CONSTRAINTS:
1. Each letter appears exactly once
2. Result should be lexicographically smallest
3. Must maintain relative order

APPROACH: Monotonic stack with constraints
- Try to keep stack increasing (lexicographical)
- BUT can only remove if letter appears later
- AND can't add if letter already in stack
```

### Implementation

```python
def removeDuplicateLetters(s):
    """
    Smallest string with each letter appearing once
    
    Monotonic increasing stack with:
    - Count of remaining letters
    - Set of letters in stack
    
    Time: O(n), Space: O(1) - 26 letters max
    """
    # Count remaining occurrences
    remaining = {}
    for c in s:
        remaining[c] = remaining.get(c, 0) + 1
    
    stack = []
    in_stack = set()
    
    for char in s:
        remaining[char] -= 1
        
        # Skip if already in result
        if char in in_stack:
            continue
        
        # Pop larger letters if they appear later
        while stack and stack[-1] > char and remaining[stack[-1]] > 0:
            in_stack.remove(stack.pop())
        
        stack.append(char)
        in_stack.add(char)
    
    return ''.join(stack)


# TRACE: "cbacdcbc"
"""
remaining = {c:4, b:2, a:1, d:1}

char='c': remaining={c:3,...}
          stack=[], push → ['c']
          in_stack={'c'}

char='b': remaining={...,b:1,...}
          b < c and remaining[c]=3 > 0
          pop 'c' → [], in_stack={}
          push → ['b'], in_stack={'b'}

char='a': remaining={...,a:0,...}
          a < b and remaining[b]=1 > 0
          pop 'b' → [], in_stack={}
          push → ['a'], in_stack={'a'}

char='c': remaining={c:2,...}
          c > a, push → ['a','c'], in_stack={'a','c'}

char='d': remaining={...,d:0}
          d > c, push → ['a','c','d'], in_stack={'a','c','d'}

char='c': already in stack, skip

char='b': remaining={...,b:0}
          b < d but remaining[d]=0, can't pop
          push → ['a','c','d','b'], in_stack={'a','c','d','b'}

char='c': already in stack, skip

Result: "acdb" ✓
"""
```

---

## 9.3 Create Maximum Number (LeetCode 321) ⭐⭐⭐

```
PROBLEM:
═══════════════════════════════════════════════════════════════

Given two arrays, create maximum number of length k.
Maintain relative order within each array.

nums1 = [3, 4, 6, 5], nums2 = [9, 1, 2, 5, 8, 3], k = 5
Output: [9, 8, 6, 5, 3]

Strategy:
- Take i digits from nums1 (max possible from nums1)
- Take k-i digits from nums2 (max possible from nums2)
- Merge optimally
- Try all valid combinations of i
```

### Implementation

```python
def maxNumber(nums1, nums2, k):
    """
    Create maximum number of length k from two arrays
    
    1. For each split (i from nums1, k-i from nums2):
       a. Get max subsequence of length i from nums1
       b. Get max subsequence of length k-i from nums2
       c. Merge two subsequences optimally
    2. Return the best result
    
    Time: O(k * (m + n + k^2)), Space: O(k)
    """
    def maxSubsequence(nums, length):
        """
        Get maximum subsequence of given length
        Using monotonic stack (similar to Remove K Digits)
        """
        if length == 0:
            return []
        
        drop = len(nums) - length  # Number of digits to remove
        stack = []
        
        for num in nums:
            while drop > 0 and stack and stack[-1] < num:
                stack.pop()
                drop -= 1
            stack.append(num)
        
        return stack[:length]
    
    def merge(arr1, arr2):
        """
        Merge two arrays to form maximum number
        Greedy: always pick from array that's lexicographically larger
        """
        result = []
        i, j = 0, 0
        
        while i < len(arr1) or j < len(arr2):
            # Compare remaining portions
            if arr1[i:] > arr2[j:]:
                result.append(arr1[i])
                i += 1
            else:
                result.append(arr2[j])
                j += 1
        
        return result
    
    m, n = len(nums1), len(nums2)
    best = []
    
    # Try all valid splits
    for i in range(k + 1):
        j = k - i
        
        # Check if split is valid
        if i > m or j > n:
            continue
        
        # Get max subsequences
        sub1 = maxSubsequence(nums1, i)
        sub2 = maxSubsequence(nums2, j)
        
        # Merge and compare
        merged = merge(sub1, sub2)
        if merged > best:
            best = merged
    
    return best


# TRACE:
"""
nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5

Try i=0: sub1=[], sub2=[9,8,5,3,?] → not enough
Try i=1: sub1=[6], sub2=[9,8,5,3]
         merge → [9,8,6,5,3]
Try i=2: sub1=[6,5], sub2=[9,8,3]
         merge → [9,8,6,5,3]
Try i=3: sub1=[6,5,?]... etc.

Best: [9,8,6,5,3] ✓
"""
```

---

## 9.4 Number of Visible People in Queue (LeetCode 1944) ⭐⭐

```
PROBLEM:
═══════════════════════════════════════════════════════════════

People in queue with heights. Person i can see person j if:
- j > i (person j is to the right)
- Everyone between i and j is shorter than both i and j

Return count of visible people for each person.

heights = [10, 6, 8, 5, 11, 9]
Output:   [3,  1, 2, 1, 1,  0]

Person 0 (h=10): Can see 6, 8, 11 (not 5 because blocked by 8)
Person 1 (h=6):  Can see 8 only (blocked by 8)
Person 2 (h=8):  Can see 5, 11
...
```

### Implementation

```python
def canSeePersonsCount(heights):
    """
    Count visible people using decreasing monotonic stack
    
    Process from right to left.
    For each person, pop (and count) all shorter people they can see.
    If stack still has someone, they can see that person too.
    
    Time: O(n), Space: O(n)
    """
    n = len(heights)
    result = [0] * n
    stack = []  # Decreasing stack of heights
    
    # Process from right to left
    for i in range(n - 1, -1, -1):
        count = 0
        
        # Pop and count all shorter people (visible)
        while stack and heights[i] > stack[-1]:
            stack.pop()
            count += 1
        
        # If stack not empty, can see one more person (taller one)
        if stack:
            count += 1
        
        result[i] = count
        stack.append(heights[i])
    
    return result


# TRACE: [10, 6, 8, 5, 11, 9]
"""
Processing right to left:

i=5, h=9:  stack=[], count=0
           push → [9], result[5]=0

i=4, h=11: 11 > 9, pop, count=1
           stack=[], one more if stack: no
           push → [11], result[4]=1

i=3, h=5:  5 < 11, no pop
           stack not empty: count=1
           push → [11,5], result[3]=1

i=2, h=8:  8 > 5, pop, count=1
           8 < 11, stop
           stack not empty: count=2
           push → [11,8], result[2]=2

i=1, h=6:  6 < 8, no pop
           stack not empty: count=1
           push → [11,8,6], result[1]=1

i=0, h=10: 10 > 6, pop, count=1
           10 > 8, pop, count=2
           10 < 11, stop
           stack not empty: count=3
           push → [11,10], result[0]=3

Result: [3, 1, 2, 1, 1, 0] ✓
"""
```

---

## 9.5 Maximum Width Ramp (LeetCode 962) ⭐⭐

```
PROBLEM:
═══════════════════════════════════════════════════════════════

A ramp is pair (i, j) where i < j and nums[i] <= nums[j].
Find maximum width j - i.

nums = [6, 0, 8, 2, 1, 5]
Output: 4 (i=1, j=5, nums[1]=0 <= nums[5]=5)
```

### Key Insight

```
TWO-PASS APPROACH:
═══════════════════════════════════════════════════════════════

Pass 1: Build decreasing stack of CANDIDATES for left end
        (Only decreasing values can be start of max ramp)

Pass 2: Scan from right, match with stack candidates

Why decreasing? If nums[i] > nums[j] where j > i,
then any ramp starting at i could start at j instead (better width).
```

### Implementation

```python
def maxWidthRamp(nums):
    """
    Maximum width ramp using monotonic stack
    
    Pass 1: Build decreasing stack of left candidates
    Pass 2: Scan right to left, find matches
    
    Time: O(n), Space: O(n)
    """
    n = len(nums)
    
    # Pass 1: Build decreasing stack of indices
    stack = []
    for i in range(n):
        if not stack or nums[i] < nums[stack[-1]]:
            stack.append(i)
    
    # Pass 2: Scan from right, find ramps
    max_width = 0
    for j in range(n - 1, -1, -1):
        while stack and nums[j] >= nums[stack[-1]]:
            i = stack.pop()
            max_width = max(max_width, j - i)
    
    return max_width


# TRACE: [6, 0, 8, 2, 1, 5]
"""
Pass 1 - Build decreasing stack:
i=0, nums[0]=6: stack=[0]
i=1, nums[1]=0 < 6: stack=[0,1]
i=2, nums[2]=8 > 0: skip
i=3, nums[3]=2 > 0: skip
i=4, nums[4]=1 > 0: skip
i=5, nums[5]=5 > 0: skip

Decreasing stack: [0, 1] (values: [6, 0])

Pass 2 - Find ramps from right:
j=5, nums[5]=5:
  5 >= nums[1]=0? Yes, pop 1, width=5-1=4
  5 >= nums[0]=6? No
  max_width = 4

j=4, nums[4]=1:
  1 >= nums[0]=6? No

... continue (no more matches)

Result: 4 ✓
"""


# Alternative: Binary Search approach
def maxWidthRamp_binary(nums):
    """
    Using binary search on decreasing stack
    """
    n = len(nums)
    stack = []  # Decreasing stack
    
    # Build stack
    for i in range(n):
        if not stack or nums[i] < nums[stack[-1]]:
            stack.append(i)
    
    max_width = 0
    
    # For each right end, binary search for leftmost valid start
    for j in range(n - 1, -1, -1):
        # Binary search in stack for largest i where nums[i] <= nums[j]
        lo, hi = 0, len(stack) - 1
        while lo < hi:
            mid = (lo + hi) // 2
            if nums[stack[mid]] <= nums[j]:
                hi = mid
            else:
                lo = mid + 1
        
        if nums[stack[lo]] <= nums[j]:
            max_width = max(max_width, j - stack[lo])
    
    return max_width
```

---

## 9.6 Sum of Total Strength of Wizards (LeetCode 2281) ⭐⭐⭐

```
PROBLEM:
═══════════════════════════════════════════════════════════════

Strength of group = min(strengths) × sum(strengths)
Return sum of strengths of ALL contiguous groups.

This is the hardest variant of contribution technique!

strength = [1, 3, 1, 2]

Groups and strengths:
[1] = 1×1 = 1
[3] = 3×3 = 9
[1] = 1×1 = 1
[2] = 2×2 = 4
[1,3] = 1×4 = 4
[3,1] = 1×4 = 4
[1,2] = 1×3 = 3
[1,3,1] = 1×5 = 5
[3,1,2] = 1×6 = 6
[1,3,1,2] = 1×7 = 7

Sum = 1+9+1+4+4+4+3+5+6+7 = 44
```

### Key Insight

```
CONTRIBUTION WITH PREFIX SUMS:
═══════════════════════════════════════════════════════════════

For each element s[i] as the minimum:
- Find left boundary L[i]: previous smaller element
- Find right boundary R[i]: next smaller or equal element

For all subarrays where s[i] is minimum:
- Left endpoints: L[i]+1 to i
- Right endpoints: i to R[i]-1

Need to compute sum of:
s[i] × (sum of all subarray sums)

This requires PREFIX SUM of PREFIX SUMS!
```

### Implementation

```python
def totalStrength(strength):
    """
    Sum of total strength using advanced contribution technique
    
    For each element as minimum, calculate contribution to all subarrays.
    Uses prefix sum of prefix sums for efficient computation.
    
    Time: O(n), Space: O(n)
    """
    MOD = 10**9 + 7
    n = len(strength)
    s = strength
    
    # Prefix sum
    prefix = [0] * (n + 1)
    for i in range(n):
        prefix[i + 1] = prefix[i] + s[i]
    
    # Prefix sum of prefix sum
    prefix_prefix = [0] * (n + 2)
    for i in range(n + 1):
        prefix_prefix[i + 1] = prefix_prefix[i] + prefix[i]
    
    # Find previous smaller element indices
    left = [-1] * n
    stack = []
    for i in range(n):
        while stack and s[stack[-1]] >= s[i]:
            stack.pop()
        left[i] = stack[-1] if stack else -1
        stack.append(i)
    
    # Find next smaller or equal element indices
    right = [n] * n
    stack = []
    for i in range(n - 1, -1, -1):
        while stack and s[stack[-1]] > s[i]:
            stack.pop()
        right[i] = stack[-1] if stack else n
        stack.append(i)
    
    # Calculate total strength
    result = 0
    for i in range(n):
        L = left[i]
        R = right[i]
        
        # Number of left endpoints: i - L
        # Number of right endpoints: R - i
        left_count = i - L
        right_count = R - i
        
        # Sum contribution using prefix sum formula
        # Left sum: prefix_prefix[i+1] - prefix_prefix[L+1]
        # Right sum: prefix_prefix[R+1] - prefix_prefix[i+1]
        
        left_sum = prefix_prefix[i + 1] - prefix_prefix[L + 1]
        right_sum = prefix_prefix[R + 1] - prefix_prefix[i + 1]
        
        contribution = s[i] * (right_count * left_sum - left_count * right_sum)
        result = (result + contribution) % MOD
    
    return result
```

---

## 9.7 Longest Valid Parentheses (LeetCode 32) ⭐⭐

```python
def longestValidParentheses(s):
    """
    Find longest valid parentheses substring
    
    Stack stores INDICES, not characters
    Initialize with -1 as base for length calculation
    
    Time: O(n), Space: O(n)
    """
    stack = [-1]  # Base index
    max_length = 0
    
    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)
        else:
            stack.pop()
            
            if not stack:
                # No match, use current as new base
                stack.append(i)
            else:
                # Calculate length from last unmatched
                max_length = max(max_length, i - stack[-1])
    
    return max_length


# O(1) Space Solution
def longestValidParentheses_optimal(s):
    """
    Two-pass solution with O(1) space
    """
    def count(s, open_char, close_char):
        max_len = 0
        opens = closes = 0
        
        for char in s:
            if char == open_char:
                opens += 1
            else:
                closes += 1
            
            if opens == closes:
                max_len = max(max_len, 2 * opens)
            elif closes > opens:
                opens = closes = 0
        
        return max_len
    
    # Left to right, then right to left
    return max(count(s, '(', ')'), count(s[::-1], ')', '('))


# TRACE: ")()())"
"""
Stack approach:

i=0, ')': pop -1, stack empty, push 0 → [0]
i=1, '(': push 1 → [0, 1]
i=2, ')': pop 1, length = 2-0 = 2, max=2 → [0]
i=3, '(': push 3 → [0, 3]
i=4, ')': pop 3, length = 4-0 = 4, max=4 → [0]
i=5, ')': pop 0, stack empty, push 5 → [5]

Result: 4 ✓
"""
```

---

## 9.8 Trapping Rain Water II (3D Version) (LeetCode 407)

```python
import heapq

def trapRainWater(heightMap):
    """
    3D trapping rain water using min-heap + BFS
    
    Different from stack-based 1D version!
    Start from boundary (lowest points), work inward.
    
    Time: O(mn log(mn)), Space: O(mn)
    """
    if not heightMap or not heightMap[0]:
        return 0
    
    m, n = len(heightMap), len(heightMap[0])
    visited = [[False] * n for _ in range(m)]
    
    # Min-heap: (height, row, col)
    heap = []
    
    # Add all boundary cells
    for i in range(m):
        for j in range(n):
            if i == 0 or i == m - 1 or j == 0 or j == n - 1:
                heapq.heappush(heap, (heightMap[i][j], i, j))
                visited[i][j] = True
    
    water = 0
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    while heap:
        height, row, col = heapq.heappop(heap)
        
        for dr, dc in directions:
            nr, nc = row + dr, col + dc
            
            if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc]:
                visited[nr][nc] = True
                
                # Water trapped = boundary height - cell height
                water += max(0, height - heightMap[nr][nc])
                
                # Add cell with max of its height and boundary height
                new_height = max(height, heightMap[nr][nc])
                heapq.heappush(heap, (new_height, nr, nc))
    
    return water
```

---

## 9.9 Summary: Hard Problem Patterns

```
┌────────────────────────────────────────────────────────────────────┐
│              HARD STACK PROBLEMS CHEATSHEET                        │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│ REMOVE DIGITS/LETTERS:                                             │
│ ─────────────────────────────                                      │
│ • Monotonic INCREASING for smallest result                         │
│ • Track remaining counts for remove duplicate letters              │
│ • Remove from end if k > 0 after processing                        │
│                                                                    │
│ CREATE MAXIMUM NUMBER:                                             │
│ ─────────────────────────────                                      │
│ • Split + Max subsequence + Merge                                  │
│ • Try all valid splits                                             │
│ • Merge greedily comparing remaining arrays                        │
│                                                                    │
│ VISIBLE PEOPLE:                                                    │
│ ─────────────────────────────                                      │
│ • Process right to left with decreasing stack                      │
│ • Count pops + 1 if stack not empty                                │
│                                                                    │
│ MAXIMUM WIDTH RAMP:                                                │
│ ─────────────────────────────                                      │
│ • Build decreasing stack of left candidates                        │
│ • Match from right, pop and calculate width                        │
│                                                                    │
│ WIZARD STRENGTH:                                                   │
│ ─────────────────────────────                                      │
│ • Contribution technique with prefix sum of prefix sums            │
│ • Most complex variant of monotonic stack problems                 │
│                                                                    │
│ LONGEST VALID PARENTHESES:                                         │
│ ─────────────────────────────                                      │
│ • Stack of INDICES, not characters                                 │
│ • Initialize with -1 as base                                       │
│ • O(1) space with two-pass counting                                │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

---

## Must-Practice Hard Problems

| Problem | Company | Key Insight |
|---------|---------|-------------|
| Remove K Digits | Google | Monotonic increasing |
| Remove Duplicate Letters | Google, FB | Count + In-stack set |
| Create Maximum Number | Google | Split + Merge |
| Largest Rectangle in Histogram | Amazon | PSE + NSE |
| Maximal Rectangle | Amazon, Google | Histogram per row |
| Trapping Rain Water | Amazon, Google | Decreasing stack |
| Sum of Subarray Minimums | Amazon | Contribution |
| Number of Visible People | FB | Process right to left |
| Maximum Width Ramp | Google | Two-pass stack |
| Basic Calculator III | FB, Amazon | Recursion + Stack |
| 132 Pattern | Amazon | Track second largest |
| Car Fleet II | Google | Collision times |
