# Chapter 2: Queue Variants - In-Depth Explanation

## 2.1 Circular Queue (Ring Buffer) - Advanced Details

### Deep Dive: Why Circular Queue?

**Problem Recap:**
```
Simple Queue Problem:
[_, _, 30, 40, 50]  ‚Üê Cannot add more even with empty slots!
        ‚Üë          ‚Üë
      front      rear

Solution: Make it circular!
[60, _, 30, 40, 50]  ‚Üê rear wrapped to index 0!
 ‚Üë       ‚Üë
rear   front
```

### Advanced Circular Queue Implementation

```python
class AdvancedCircularQueue:
    """
    Advanced Circular Queue with additional features:
    - Detailed state tracking
    - Multiple full/empty detection methods
    - Visualization support
    """
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.queue = [None] * capacity
        self.front = 0
        self.rear = -1
        self.size = 0
    
    def is_empty(self):
        return self.size == 0
    
    def is_full(self):
        return self.size == self.capacity
    
    def enqueue(self, data):
        if self.is_full():
            raise Exception("Queue is full!")
        
        self.rear = (self.rear + 1) % self.capacity
        self.queue[self.rear] = data
        self.size += 1
        return True
    
    def dequeue(self):
        if self.is_empty():
            raise Exception("Queue is empty!")
        
        data = self.queue[self.front]
        self.queue[self.front] = None
        self.front = (self.front + 1) % self.capacity
        self.size -= 1
        return data
    
    def peek(self):
        if self.is_empty():
            raise Exception("Queue is empty!")
        return self.queue[self.front]
    
    def get_elements(self):
        """Return elements in logical order"""
        if self.is_empty():
            return []
        
        elements = []
        index = self.front
        for _ in range(self.size):
            elements.append(self.queue[index])
            index = (index + 1) % self.capacity
        return elements
    
    def visualize(self):
        """Visual representation of circular queue"""
        print(f"\n{'='*50}")
        print(f"Capacity: {self.capacity} | Size: {self.size} | "
              f"Front: {self.front} | Rear: {self.rear}")
        print(f"{'='*50}")
        
        # Physical array view
        print("Physical Array:")
        print(f"  Index:    {' '.join(f'[{i}]' for i in range(self.capacity))}")
        print(f"  Values:   {' '.join(f' {str(v) if v else '_'} ' for v in self.queue)}")
        
        # Markers
        markers = []
        for i in range(self.capacity):
            if i == self.front and i == self.rear and not self.is_empty():
                markers.append(' FR')
            elif i == self.front:
                markers.append(' F ')
            elif i == self.rear:
                markers.append(' R ')
            else:
                markers.append('   ')
        print(f"  Markers:  {' '.join(markers)}")
        
        # Logical order
        print(f"\nLogical Order: {self.get_elements()}")
        print(f"{'='*50}\n")


# ============ DEMONSTRATION ============

print("=" * 60)
print("CIRCULAR QUEUE - COMPLETE WALKTHROUGH")
print("=" * 60)

cq = AdvancedCircularQueue(5)

print("\nüìù SCENARIO 1: Initial Enqueues")
print("-" * 60)
for val in [10, 20, 30]:
    cq.enqueue(val)
    print(f"Enqueued: {val}")
cq.visualize()

print("\nüìù SCENARIO 2: Dequeue Some Elements")
print("-" * 60)
for _ in range(2):
    val = cq.dequeue()
    print(f"Dequeued: {val}")
cq.visualize()

print("\nüìù SCENARIO 3: Fill and Demonstrate Wrap-Around")
print("-" * 60)
for val in [40, 50, 60, 70]:
    cq.enqueue(val)
    print(f"Enqueued: {val}")
    if val == 60:
        print("  ‚ö†Ô∏è Notice: Next enqueue will wrap to index 0!")
cq.visualize()

print("\nüìù SCENARIO 4: Queue is Full")
print("-" * 60)
try:
    cq.enqueue(80)
except Exception as e:
    print(f"‚ùå Cannot enqueue: {e}")
print(f"Queue is at full capacity: {cq.is_full()}")

print("\nüìù SCENARIO 5: Make Space and Add More")
print("-" * 60)
cq.dequeue()
cq.dequeue()
cq.visualize()
cq.enqueue(80)
print(f"Enqueued: 80")
cq.visualize()

print("=" * 60)
```

---

## 2.2 Double-Ended Queue (Deque)

### Understanding Deque

**Definition**: A Deque (Double-Ended Queue) allows insertion and deletion from both ends.

```
Visual Representation:

    addFirst()  ‚Üê  [10, 20, 30, 40]  ‚Üí  addLast()
   removeFirst() ‚Üê                   ‚Üí removeLast()
                     ‚Üë            ‚Üë
                   Front        Rear
```

**Operations:**
- `addFirst(x)` / `addLast(x)` - Add to front/rear
- `removeFirst()` / `removeLast()` - Remove from front/rear  
- `peekFirst()` / `peekLast()` - View front/rear
- All operations: **O(1)**

### Deque Implementation Using Doubly Linked List

```python
class Node:
    """Node for doubly linked list"""
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None


class Deque:
    """
    Double-Ended Queue implementation using doubly linked list.
    Allows O(1) operations at both ends.
    """
    
    def __init__(self):
        self.front = None
        self.rear = None
        self.size = 0
    
    def is_empty(self):
        return self.size == 0
    
    def get_size(self):
        return self.size
    
    def add_first(self, data):
        """Add element at front"""
        new_node = Node(data)
        
        if self.is_empty():
            self.front = self.rear = new_node
        else:
            new_node.next = self.front
            self.front.prev = new_node
            self.front = new_node
        
        self.size += 1
        print(f"‚úì Added {data} at front")
    
    def add_last(self, data):
        """Add element at rear"""
        new_node = Node(data)
        
        if self.is_empty():
            self.front = self.rear = new_node
        else:
            new_node.prev = self.rear
            self.rear.next = new_node
            self.rear = new_node
        
        self.size += 1
        print(f"‚úì Added {data} at rear")
    
    def remove_first(self):
        """Remove and return element from front"""
        if self.is_empty():
            raise Exception("Deque is empty!")
        
        data = self.front.data
        self.front = self.front.next
        
        if self.front is None:
            self.rear = None
        else:
            self.front.prev = None
        
        self.size -= 1
        print(f"‚úì Removed {data} from front")
        return data
    
    def remove_last(self):
        """Remove and return element from rear"""
        if self.is_empty():
            raise Exception("Deque is empty!")
        
        data = self.rear.data
        self.rear = self.rear.prev
        
        if self.rear is None:
            self.front = None
        else:
            self.rear.next = None
        
        self.size -= 1
        print(f"‚úì Removed {data} from rear")
        return data
    
    def peek_first(self):
        """Return front element without removing"""
        if self.is_empty():
            raise Exception("Deque is empty!")
        return self.front.data
    
    def peek_last(self):
        """Return rear element without removing"""
        if self.is_empty():
            raise Exception("Deque is empty!")
        return self.rear.data
    
    def display(self):
        """Display deque elements"""
        if self.is_empty():
            print("Deque is empty")
            return
        
        elements = []
        current = self.front
        while current:
            elements.append(current.data)
            current = current.next
        
        print(f"\nDeque (size={self.size}):")
        print(f"  Front ‚Üí {' ‚Üî '.join(map(str, elements))} ‚Üê Rear")
        print(f"  Elements: {elements}")


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("DEQUE DEMONSTRATION")
print("=" * 60)

dq = Deque()

print("\nüìù SCENARIO 1: Add from both ends")
print("-" * 60)
dq.add_last(20)
dq.add_last(30)
dq.add_first(10)
dq.add_last(40)
dq.add_first(5)
dq.display()

print("\nüìù SCENARIO 2: Peek both ends")
print("-" * 60)
print(f"First element: {dq.peek_first()}")
print(f"Last element: {dq.peek_last()}")

print("\nüìù SCENARIO 3: Remove from both ends")
print("-" * 60)
dq.remove_first()
dq.remove_last()
dq.display()

print("\nüìù SCENARIO 4: Use as Stack (LIFO)")
print("-" * 60)
print("Adding: 100, 200, 300 (using add_last)")
dq.add_last(100)
dq.add_last(200)
dq.add_last(300)
dq.display()
print("\nRemoving from same end (using remove_last):")
dq.remove_last()
dq.remove_last()
dq.display()

print("\nüìù SCENARIO 5: Use as Queue (FIFO)")
print("-" * 60)
print("Adding: 400, 500 (using add_last)")
dq.add_last(400)
dq.add_last(500)
dq.display()
print("\nRemoving from opposite end (using remove_first):")
dq.remove_first()
dq.remove_first()
dq.display()

print("\n" + "=" * 60)


# ============ DEQUE USING PYTHON collections ============

from collections import deque

print("\n" + "=" * 60)
print("PYTHON collections.deque")
print("=" * 60)

# Create deque
pydq = deque()

print("\n--- Operations ---")
pydq.append(10)        # Add to right
pydq.append(20)
pydq.appendleft(5)     # Add to left
pydq.append(30)
print(f"Deque: {list(pydq)}")

print(f"Pop right: {pydq.pop()}")      # Remove from right
print(f"Pop left: {pydq.popleft()}")   # Remove from left
print(f"Deque: {list(pydq)}")

# Deque with max length
print("\n--- Deque with maxlen ---")
limited_dq = deque(maxlen=3)
for i in range(5):
    limited_dq.append(i)
    print(f"After append({i}): {list(limited_dq)}")

print("\n" + "=" * 60)
```

---

## 2.3 Priority Queue

### Understanding Priority Queue

**Definition**: Elements have priorities; highest (or lowest) priority element is dequeued first.

```
Max Priority Queue:
Enqueue: 30, 10, 50, 20, 40

Internal (Max Heap):
       50
      /  \
    40    30
   / \
  10  20

Dequeue order: 50, 40, 30, 20, 10 (descending)

Min Priority Queue:
Dequeue order: 10, 20, 30, 40, 50 (ascending)
```

### Priority Queue Implementation Using Heap

```python
import heapq

class PriorityQueue:
    """
    Priority Queue implementation using Python's heapq (min-heap).
    Lower values have higher priority by default.
    """
    
    def __init__(self):
        self.heap = []
        self.size = 0
    
    def is_empty(self):
        return self.size == 0
    
    def enqueue(self, priority, data):
        """
        Add element with priority.
        Lower priority value = higher priority
        """
        heapq.heappush(self.heap, (priority, data))
        self.size += 1
        print(f"‚úì Enqueued: {data} (priority={priority})")
    
    def dequeue(self):
        """Remove and return highest priority element"""
        if self.is_empty():
            raise Exception("Priority Queue is empty!")
        
        priority, data = heapq.heappop(self.heap)
        self.size -= 1
        print(f"‚úì Dequeued: {data} (priority={priority})")
        return data
    
    def peek(self):
        """Return highest priority element without removing"""
        if self.is_empty():
            raise Exception("Priority Queue is empty!")
        return self.heap[0][1]
    
    def peek_with_priority(self):
        """Return (priority, data) of highest priority element"""
        if self.is_empty():
            raise Exception("Priority Queue is empty!")
        return self.heap[0]
    
    def display(self):
        """Display all elements with priorities"""
        if self.is_empty():
            print("Priority Queue is empty")
            return
        
        print(f"\nPriority Queue (size={self.size}):")
        sorted_items = sorted(self.heap)
        for priority, data in sorted_items:
            print(f"  Priority {priority}: {data}")


class MaxPriorityQueue:
    """
    Max Priority Queue - higher values have higher priority.
    Implemented by negating priorities.
    """
    
    def __init__(self):
        self.heap = []
        self.size = 0
    
    def is_empty(self):
        return self.size == 0
    
    def enqueue(self, priority, data):
        """Add element with priority (higher = more priority)"""
        # Negate priority to simulate max-heap
        heapq.heappush(self.heap, (-priority, data))
        self.size += 1
        print(f"‚úì Enqueued: {data} (priority={priority})")
    
    def dequeue(self):
        """Remove and return highest priority element"""
        if self.is_empty():
            raise Exception("Priority Queue is empty!")
        
        neg_priority, data = heapq.heappop(self.heap)
        self.size -= 1
        print(f"‚úì Dequeued: {data} (priority={-neg_priority})")
        return data
    
    def peek(self):
        if self.is_empty():
            raise Exception("Priority Queue is empty!")
        return self.heap[0][1]
    
    def display(self):
        if self.is_empty():
            print("Max Priority Queue is empty")
            return
        
        print(f"\nMax Priority Queue (size={self.size}):")
        # Sort by negated priority (descending actual priority)
        sorted_items = sorted(self.heap, reverse=True)
        for neg_priority, data in sorted_items:
            print(f"  Priority {-neg_priority}: {data}")


# ============ MIN PRIORITY QUEUE DEMO ============

print("=" * 60)
print("MIN PRIORITY QUEUE (Lower priority = Higher precedence)")
print("=" * 60)

pq = PriorityQueue()

print("\nüìù Hospital Emergency Room Example")
print("-" * 60)
print("Priority levels: 1=Critical, 2=Urgent, 3=Minor\n")

patients = [
    (3, "Patient A - Minor injury"),
    (1, "Patient B - Critical condition"),
    (2, "Patient C - Urgent care"),
    (1, "Patient D - Critical condition"),
    (3, "Patient E - Minor checkup"),
]

for priority, patient in patients:
    pq.enqueue(priority, patient)

pq.display()

print("\nüìù Processing patients (highest priority first):")
print("-" * 60)
while not pq.is_empty():
    patient = pq.dequeue()
    print(f"  Treating: {patient}")

print("\n" + "=" * 60)


# ============ MAX PRIORITY QUEUE DEMO ============

print("\n" + "=" * 60)
print("MAX PRIORITY QUEUE (Higher priority = Higher precedence)")
print("=" * 60)

maxpq = MaxPriorityQueue()

print("\nüìù Task Scheduler Example")
print("-" * 60)
print("Priority levels: Higher number = More important\n")

tasks = [
    (5, "Deploy to production"),
    (3, "Code review"),
    (8, "Fix critical bug"),
    (2, "Update documentation"),
    (7, "Security patch"),
]

for priority, task in tasks:
    maxpq.enqueue(priority, task)

maxpq.display()

print("\nüìù Executing tasks (highest priority first):")
print("-" * 60)
while not maxpq.is_empty():
    task = maxpq.dequeue()
    print(f"  Executing: {task}")

print("\n" + "=" * 60)
```

### Priority Queue with Custom Objects

```python
import heapq
from dataclasses import dataclass, field
from typing import Any

@dataclass(order=True)
class PrioritizedItem:
    """Wrapper class for priority queue items"""
    priority: int
    data: Any = field(compare=False)
    
    def __repr__(self):
        return f"Item(priority={self.priority}, data={self.data})"


class CustomPriorityQueue:
    """Priority Queue supporting custom objects"""
    
    def __init__(self):
        self.heap = []
        self.counter = 0  # Tie-breaker for same priorities
    
    def enqueue(self, priority, data):
        # Use counter to break ties (FIFO for same priority)
        item = (priority, self.counter, data)
        heapq.heappush(self.heap, item)
        self.counter += 1
        print(f"‚úì Enqueued: {data} (priority={priority})")
    
    def dequeue(self):
        if not self.heap:
            raise Exception("Queue is empty!")
        priority, _, data = heapq.heappop(self.heap)
        print(f"‚úì Dequeued: {data} (priority={priority})")
        return data
    
    def is_empty(self):
        return len(self.heap) == 0


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("PRIORITY QUEUE WITH TIE-BREAKING")
print("=" * 60)

cpq = CustomPriorityQueue()

print("\nüìù Adding items with same priorities")
print("-" * 60)
cpq.enqueue(2, "Task A")
cpq.enqueue(1, "Task B")
cpq.enqueue(2, "Task C")  # Same priority as Task A
cpq.enqueue(1, "Task D")  # Same priority as Task B
cpq.enqueue(2, "Task E")  # Same priority as Task A

print("\nüìù Processing (same priority = FIFO order):")
print("-" * 60)
while not cpq.is_empty():
    cpq.dequeue()

print("\n" + "=" * 60)
```

---

## 2.4 Monotonic Queue

### Understanding Monotonic Queue

**Definition**: A deque where elements are maintained in increasing or decreasing order.

```
Monotonic Decreasing Queue (for finding maximum):

Adding elements: [3, 1, 4, 3, 5]

Step 1: Add 3
Queue: [3]

Step 2: Add 1
Queue: [3, 1]  (maintain decreasing order)

Step 3: Add 4
Remove 1, 3 (both < 4)
Queue: [4]

Step 4: Add 3
Queue: [4, 3]

Step 5: Add 5
Remove 3, 4 (both < 5)
Queue: [5]

Front of queue always has maximum!
```

### Monotonic Queue Implementation

```python
from collections import deque

class MonotonicQueue:
    """
    Monotonic Queue for sliding window maximum/minimum problems.
    Maintains decreasing order for maximum (front = max).
    Maintains increasing order for minimum (front = min).
    """
    
    def __init__(self, mode='max'):
        """
        mode: 'max' for decreasing queue (finds maximum)
              'min' for increasing queue (finds minimum)
        """
        self.queue = deque()
        self.mode = mode
    
    def push(self, value):
        """
        Add value while maintaining monotonic property.
        For max mode: remove all smaller values from rear.
        For min mode: remove all larger values from rear.
        """
        if self.mode == 'max':
            # Remove all elements smaller than current
            while self.queue and self.queue[-1] < value:
                removed = self.queue.pop()
                print(f"  Removed {removed} (smaller than {value})")
        else:  # min mode
            # Remove all elements larger than current
            while self.queue and self.queue[-1] > value:
                removed = self.queue.pop()
                print(f"  Removed {removed} (larger than {value})")
        
        self.queue.append(value)
        print(f"‚úì Pushed {value}, Queue: {list(self.queue)}")
    
    def pop(self, value):
        """
        Remove value from front if it matches.
        Used when sliding window moves.
        """
        if self.queue and self.queue[0] == value:
            removed = self.queue.popleft()
            print(f"‚úì Popped {removed} from front")
    
    def get_extremum(self):
        """Return maximum (max mode) or minimum (min mode)"""
        if not self.queue:
            return None
        return self.queue[0]
    
    def display(self):
        print(f"Queue: {list(self.queue)}")


# ============ DEMONSTRATION: FINDING MAXIMUM ============

print("=" * 60)
print("MONOTONIC QUEUE - FINDING MAXIMUM")
print("=" * 60)

mq_max = MonotonicQueue(mode='max')

print("\nüìù Building monotonic decreasing queue:")
print("-" * 60)
values = [3, 1, 4, 1, 5, 9, 2, 6]

for val in values:
    print(f"\nAdding {val}:")
    mq_max.push(val)
    print(f"Current maximum: {mq_max.get_extremum()}")

print("\n" + "=" * 60)


# ============ DEMONSTRATION: FINDING MINIMUM ============

print("\n" + "=" * 60)
print("MONOTONIC QUEUE - FINDING MINIMUM")
print("=" * 60)

mq_min = MonotonicQueue(mode='min')

print("\nüìù Building monotonic increasing queue:")
print("-" * 60)

for val in values:
    print(f"\nAdding {val}:")
    mq_min.push(val)
    print(f"Current minimum: {mq_min.get_extremum()}")

print("\n" + "=" * 60)


# ============ SLIDING WINDOW MAXIMUM PROBLEM ============

def sliding_window_maximum(arr, k):
    """
    Find maximum in each window of size k.
    Uses monotonic decreasing queue.
    Time: O(n), each element pushed/popped once.
    """
    if not arr or k <= 0:
        return []
    
    result = []
    mq = MonotonicQueue(mode='max')
    
    print(f"\nArray: {arr}, Window size: {k}")
    print("=" * 60)
    
    # Process first window
    for i in range(k):
        mq.push(arr[i])
    result.append(mq.get_extremum())
    print(f"\nWindow [0:{k}] = {arr[0:k]}, Max = {result[-1]}")
    
    # Process remaining elements
    for i in range(k, len(arr)):
        # Remove element going out of window
        mq.pop(arr[i - k])
        
        # Add new element
        mq.push(arr[i])
        
        # Record maximum
        max_val = mq.get_extremum()
        result.append(max_val)
        print(f"Window [{i-k+1}:{i+1}] = {arr[i-k+1:i+1]}, Max = {max_val}")
    
    return result


print("\n" + "=" * 60)
print("SLIDING WINDOW MAXIMUM PROBLEM")
print("=" * 60)

arr = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3

result = sliding_window_maximum(arr, k)
print(f"\nResult: {result}")

print("\n" + "=" * 60)
```

---

## Summary & Comparison

```python
print("\n" + "=" * 60)
print("QUEUE VARIANTS COMPARISON")
print("=" * 60)

comparison = """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë   Queue Variant     ‚ïë  Insert Time  ‚ïë  Delete Time   ‚ïë   Use Case    ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë Regular Queue       ‚ïë     O(1)      ‚ïë     O(1)       ‚ïë FIFO order    ‚ïë
‚ïë Circular Queue      ‚ïë     O(1)      ‚ïë     O(1)       ‚ïë Fixed buffer  ‚ïë
‚ïë Deque               ‚ïë     O(1)      ‚ïë     O(1)       ‚ïë Both ends     ‚ïë
‚ïë Priority Queue      ‚ïë   O(log n)    ‚ïë   O(log n)     ‚ïë By priority   ‚ïë
‚ïë Monotonic Queue     ‚ïë     O(1)*     ‚ïë     O(1)*      ‚ïë Sliding window‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

* Amortized time complexity

KEY INSIGHTS:

1. CIRCULAR QUEUE:
   - Solves space wastage problem
   - Formula: (index + 1) % capacity

2. DEQUE:
   - Most versatile - can be used as queue or stack
   - Python's collections.deque is highly optimized

3. PRIORITY QUEUE:
   - Not strictly FIFO
   - Implemented using heap
   - Applications: Dijkstra's, task scheduling, event simulation

4. MONOTONIC QUEUE:
   - Specialized for sliding window problems
   - Maintains order while allowing O(1) extremum queries
   - Classic problem: Sliding Window Maximum
"""

print(comparison)

print("\n" + "=" * 60)
print("CHAPTER 2 COMPLETE! Next: Chapter 3 - Standard Patterns")
print("=" * 60)
```

---

## Practice Problems for Chapter 2

1. **Implement Circular Queue** - LeetCode #622
2. **Implement Deque** - From scratch and using collections
3. **Design Priority Queue** - Using heap
4. **Sliding Window Maximum** - LeetCode #239 (Monotonic Queue)
5. **Task Scheduler** - Priority queue application
6. **Design Hit Counter** - Using deque
7. **Moving Average** - Sliding window with queue
8. **First Negative in Window** - Monotonic queue

Ready for Chapter 3: Standard Queue Patterns!