# Chapter 5: Sliding Window with Queue - In-Depth Explanation

## 5.1 Sliding Window Maximum/Minimum

### Understanding the Problem

**Problem Statement:**
Given an array and window size K, find the maximum element in each window.

```
Example:
Array: [1, 3, -1, -3, 5, 3, 6, 7]
K = 3

Windows:
[1  3  -1] -3  5  3  6  7  â†’ Max = 3
 1 [3  -1  -3] 5  3  6  7  â†’ Max = 3
 1  3 [-1  -3  5] 3  6  7  â†’ Max = 5
 1  3  -1 [-3  5  3] 6  7  â†’ Max = 5
 1  3  -1  -3 [5  3  6] 7  â†’ Max = 6
 1  3  -1  -3  5 [3  6  7] â†’ Max = 7

Output: [3, 3, 5, 5, 6, 7]
```

### Approach 1: Brute Force (For Understanding)

```python
def sliding_window_max_brute_force(arr, k):
    """
    Brute force approach: Check every window.
    
    Time: O(n Ã— k)
    Space: O(1)
    """
    if not arr or k <= 0:
        return []
    
    result = []
    n = len(arr)
    
    print("Brute Force Approach:")
    print("=" * 60)
    
    for i in range(n - k + 1):
        window = arr[i:i+k]
        max_val = max(window)
        result.append(max_val)
        print(f"Window {i}: {window} â†’ Max = {max_val}")
    
    return result


# ============ DEMONSTRATION ============

print("=" * 60)
print("SLIDING WINDOW MAXIMUM - BRUTE FORCE")
print("=" * 60)

arr = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3

result = sliding_window_max_brute_force(arr, k)
print(f"\nResult: {result}")
print(f"Time Complexity: O(n Ã— k) = O({len(arr)} Ã— {k}) = O({len(arr)*k})")
print("=" * 60)
```

---

### Approach 2: Monotonic Deque (OPTIMAL) â­

**Key Insight:**
- Maintain a deque with elements in **decreasing order**
- Front of deque always has the maximum
- When new element comes:
  1. Remove elements outside window from front
  2. Remove elements smaller than new element from back
  3. Add new element to back

**Why This Works:**
```
If arr[i] â‰¥ arr[j] and i > j, then arr[j] can NEVER be maximum!
So we remove arr[j] from consideration.

Visualization:
Adding elements to decreasing deque:

Add 3:  Deque = [3]
Add 1:  Deque = [3, 1]  (1 might be useful later)
Add 4:  Remove 1, 3 (both < 4), Deque = [4]
Add 2:  Deque = [4, 2]  (2 might be useful when 4 slides out)

Front of deque = Current maximum!
```

#### Complete Implementation with Visualization

```python
from collections import deque

class MonotonicDeque:
    """
    Monotonic Decreasing Deque for Sliding Window Maximum.
    Maintains indices (not values) for easy window management.
    """
    
    def __init__(self):
        self.deque = deque()
    
    def push(self, index, value, arr):
        """Add element while maintaining decreasing order"""
        # Remove all smaller elements from back
        while self.deque and arr[self.deque[-1]] < value:
            removed_idx = self.deque.pop()
            print(f"    Removed index {removed_idx} (value={arr[removed_idx]}) "
                  f"because {value} is larger")
        
        self.deque.append(index)
        print(f"    Added index {index} (value={value})")
        print(f"    Deque indices: {list(self.deque)}")
        print(f"    Deque values: {[arr[i] for i in self.deque]}")
    
    def pop_front_if_outside_window(self, window_start):
        """Remove front if it's outside current window"""
        if self.deque and self.deque[0] < window_start:
            removed = self.deque.popleft()
            print(f"    Removed index {removed} (outside window)")
    
    def get_max(self, arr):
        """Get maximum (front element)"""
        if self.deque:
            return arr[self.deque[0]]
        return None


def sliding_window_maximum(arr, k):
    """
    Find maximum in each sliding window using monotonic deque.
    
    Time: O(n) - each element added and removed at most once
    Space: O(k) - deque size at most k
    
    This is OPTIMAL for sliding window max/min problems!
    """
    if not arr or k <= 0:
        return []
    
    n = len(arr)
    result = []
    dq = MonotonicDeque()
    
    print("\nSliding Window Maximum - Optimal Approach")
    print("=" * 70)
    print(f"Array: {arr}")
    print(f"Window size: {k}")
    print("=" * 70)
    
    # Process each element
    for i in range(n):
        print(f"\nğŸ”¹ Step {i+1}: Processing index {i}, value = {arr[i]}")
        
        # Remove elements outside window
        window_start = i - k + 1
        if window_start > 0:
            dq.pop_front_if_outside_window(window_start)
        
        # Add current element
        dq.push(i, arr[i], arr)
        
        # If we've formed a complete window, record maximum
        if i >= k - 1:
            max_val = dq.get_max(arr)
            result.append(max_val)
            window_range = arr[i-k+1:i+1]
            print(f"  âœ… Window [{i-k+1}:{i+1}] = {window_range}, Max = {max_val}")
    
    return result


# ============ DEMONSTRATION ============

print("\n" + "=" * 70)
print("SLIDING WINDOW MAXIMUM - MONOTONIC DEQUE APPROACH")
print("=" * 70)

arr = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3

result = sliding_window_maximum(arr, k)

print("\n" + "=" * 70)
print(f"Final Result: {result}")
print(f"\nTime Complexity: O(n) = O({len(arr)})")
print(f"Space Complexity: O(k) = O({k})")
print("=" * 70)
```

---

### Sliding Window Minimum (Same Technique!)

```python
def sliding_window_minimum(arr, k):
    """
    Find minimum in each sliding window.
    
    Change: Maintain INCREASING order (opposite of max)
    Time: O(n), Space: O(k)
    """
    if not arr or k <= 0:
        return []
    
    n = len(arr)
    result = []
    deque_indices = deque()
    
    print("\nSliding Window Minimum:")
    print("=" * 60)
    
    for i in range(n):
        # Remove outside window
        if deque_indices and deque_indices[0] <= i - k:
            deque_indices.popleft()
        
        # Remove all larger elements (maintain increasing order)
        while deque_indices and arr[deque_indices[-1]] > arr[i]:
            deque_indices.pop()
        
        deque_indices.append(i)
        
        # Record minimum when window is complete
        if i >= k - 1:
            min_val = arr[deque_indices[0]]
            result.append(min_val)
            print(f"Window [{i-k+1}:{i+1}] = {arr[i-k+1:i+1]}, Min = {min_val}")
    
    return result


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("SLIDING WINDOW MINIMUM")
print("=" * 60)

arr = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3

result = sliding_window_minimum(arr, k)
print(f"\nResult: {result}")
print("=" * 60)
```

---

## 5.2 First Negative in Every Window

**Problem:** Find the first negative number in each window of size K.

```python
def first_negative_in_window(arr, k):
    """
    Find first negative number in each window.
    
    Approach: Use simple queue to track negative numbers.
    Time: O(n), Space: O(k)
    """
    if not arr or k <= 0:
        return []
    
    n = len(arr)
    result = []
    negatives = deque()  # Store indices of negative numbers
    
    print("First Negative in Each Window:")
    print("=" * 60)
    
    for i in range(n):
        # Add current element if negative
        if arr[i] < 0:
            negatives.append(i)
        
        # Remove elements outside window
        while negatives and negatives[0] <= i - k:
            negatives.popleft()
        
        # If window is complete
        if i >= k - 1:
            window = arr[i-k+1:i+1]
            if negatives:
                first_neg = arr[negatives[0]]
            else:
                first_neg = 0  # No negative in window
            
            result.append(first_neg)
            print(f"Window {window} â†’ First negative = {first_neg}")
    
    return result


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("FIRST NEGATIVE NUMBER IN EVERY WINDOW")
print("=" * 60)

arr = [12, -1, -7, 8, -15, 30, 16, 28]
k = 3

result = first_negative_in_window(arr, k)
print(f"\nResult: {result}")
print("=" * 60)
```

---

## 5.3 Sum of Minimum and Maximum in All Subarrays

**Problem:** Find sum of (min + max) for all subarrays of size K.

```python
def sum_of_min_max_in_windows(arr, k):
    """
    For each window, add (min + max) to result.
    
    Approach: Use two monotonic deques simultaneously!
    - One for maximum (decreasing)
    - One for minimum (increasing)
    
    Time: O(n), Space: O(k)
    """
    if not arr or k <= 0:
        return 0
    
    n = len(arr)
    max_deque = deque()  # Decreasing deque for max
    min_deque = deque()  # Increasing deque for min
    total_sum = 0
    
    print("Sum of Min and Max in All Windows:")
    print("=" * 60)
    
    for i in range(n):
        # Maintain max deque (decreasing)
        while max_deque and arr[max_deque[-1]] < arr[i]:
            max_deque.pop()
        max_deque.append(i)
        
        # Maintain min deque (increasing)
        while min_deque and arr[min_deque[-1]] > arr[i]:
            min_deque.pop()
        min_deque.append(i)
        
        # Remove elements outside window
        if max_deque[0] <= i - k:
            max_deque.popleft()
        if min_deque[0] <= i - k:
            min_deque.popleft()
        
        # If window is complete
        if i >= k - 1:
            window_max = arr[max_deque[0]]
            window_min = arr[min_deque[0]]
            window_sum = window_max + window_min
            total_sum += window_sum
            
            window = arr[i-k+1:i+1]
            print(f"Window {window}: Max={window_max}, Min={window_min}, "
                  f"Sum={window_sum}")
    
    return total_sum


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("SUM OF MIN + MAX IN ALL WINDOWS")
print("=" * 60)

arr = [2, 5, -1, 7, -3, -1, -2]
k = 3

result = sum_of_min_max_in_windows(arr, k)
print(f"\nTotal Sum: {result}")
print("=" * 60)
```

---

## 5.4 Longest Subarray with Difference â‰¤ Limit

**Problem:** Find the longest subarray where max - min â‰¤ limit.

```python
def longest_subarray_with_limit(arr, limit):
    """
    Find longest contiguous subarray where (max - min) â‰¤ limit.
    
    Approach: Two monotonic deques + sliding window
    Time: O(n), Space: O(n)
    """
    max_deque = deque()  # Decreasing
    min_deque = deque()  # Increasing
    left = 0
    max_length = 0
    
    print(f"Finding Longest Subarray with difference â‰¤ {limit}:")
    print("=" * 60)
    
    for right in range(len(arr)):
        # Maintain deques
        while max_deque and arr[max_deque[-1]] < arr[right]:
            max_deque.pop()
        max_deque.append(right)
        
        while min_deque and arr[min_deque[-1]] > arr[right]:
            min_deque.pop()
        min_deque.append(right)
        
        # Shrink window if difference exceeds limit
        while (arr[max_deque[0]] - arr[min_deque[0]]) > limit:
            if max_deque[0] == left:
                max_deque.popleft()
            if min_deque[0] == left:
                min_deque.popleft()
            left += 1
        
        # Update max length
        current_length = right - left + 1
        if current_length > max_length:
            max_length = current_length
            subarray = arr[left:right+1]
            curr_max = arr[max_deque[0]]
            curr_min = arr[min_deque[0]]
            print(f"New longest: {subarray} (length={max_length})")
            print(f"  Max={curr_max}, Min={curr_min}, Diff={curr_max-curr_min}")
    
    return max_length


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("LONGEST SUBARRAY WITH MAX-MIN â‰¤ LIMIT")
print("=" * 60)

arr = [8, 2, 4, 7]
limit = 4

result = longest_subarray_with_limit(arr, limit)
print(f"\nLongest Subarray Length: {result}")
print("=" * 60)
```

---

## 5.5 Advanced: Sliding Window Median

**Problem:** Find median in each sliding window.

```python
import heapq
from collections import defaultdict

class SlidingWindowMedian:
    """
    Find median in each sliding window.
    
    Approach: Two heaps (max heap for lower half, min heap for upper half)
    Time: O(n log k), Space: O(k)
    """
    
    def __init__(self):
        self.max_heap = []  # Lower half (negated for max heap)
        self.min_heap = []  # Upper half
        self.delayed = defaultdict(int)  # Lazy deletion
        self.max_heap_size = 0
        self.min_heap_size = 0
    
    def add(self, num):
        """Add number to heaps"""
        if not self.max_heap or num <= -self.max_heap[0]:
            heapq.heappush(self.max_heap, -num)
            self.max_heap_size += 1
        else:
            heapq.heappush(self.min_heap, num)
            self.min_heap_size += 1
        
        self.rebalance()
    
    def remove(self, num):
        """Lazy deletion: mark for removal"""
        self.delayed[num] += 1
        
        if num <= -self.max_heap[0]:
            self.max_heap_size -= 1
        else:
            self.min_heap_size -= 1
        
        self.rebalance()
    
    def rebalance(self):
        """Balance heap sizes"""
        # Move from max_heap to min_heap
        if self.max_heap_size > self.min_heap_size + 1:
            num = -heapq.heappop(self.max_heap)
            heapq.heappush(self.min_heap, num)
            self.max_heap_size -= 1
            self.min_heap_size += 1
        
        # Move from min_heap to max_heap
        elif self.min_heap_size > self.max_heap_size:
            num = heapq.heappop(self.min_heap)
            heapq.heappush(self.max_heap, -num)
            self.min_heap_size += 1
            self.max_heap_size -= 1
        
        # Clean tops
        self.prune(self.max_heap)
        self.prune(self.min_heap)
    
    def prune(self, heap):
        """Remove invalid tops"""
        while heap:
            if heap == self.max_heap:
                num = -heap[0]
            else:
                num = heap[0]
            
            if self.delayed[num] > 0:
                self.delayed[num] -= 1
                heapq.heappop(heap)
            else:
                break
    
    def get_median(self):
        """Get current median"""
        self.prune(self.max_heap)
        self.prune(self.min_heap)
        
        if self.max_heap_size == self.min_heap_size:
            return (-self.max_heap[0] + self.min_heap[0]) / 2
        return -self.max_heap[0]


def sliding_window_median(arr, k):
    """Find median in each window"""
    result = []
    swm = SlidingWindowMedian()
    
    print("Sliding Window Median:")
    print("=" * 60)
    
    for i in range(len(arr)):
        swm.add(arr[i])
        
        if i >= k:
            swm.remove(arr[i - k])
        
        if i >= k - 1:
            median = swm.get_median()
            result.append(median)
            window = arr[i-k+1:i+1]
            print(f"Window {window} â†’ Median = {median}")
    
    return result


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("SLIDING WINDOW MEDIAN (HARD PROBLEM)")
print("=" * 60)

arr = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3

result = sliding_window_median(arr, k)
print(f"\nMedians: {result}")
print("=" * 60)
```

---

## Summary & Key Patterns

```python
print("\n" + "=" * 60)
print("CHAPTER 5: SLIDING WINDOW PATTERNS SUMMARY")
print("=" * 60)

summary = """
ğŸ¯ MONOTONIC DEQUE PATTERN:

For Maximum in Window:
  1. Maintain DECREASING order
  2. Remove smaller elements from back
  3. Front = maximum

For Minimum in Window:
  1. Maintain INCREASING order
  2. Remove larger elements from back
  3. Front = minimum

ğŸ“Š PROBLEM PATTERNS:

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         Problem            â•‘   Time    â•‘     Technique      â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Sliding Window Maximum     â•‘   O(n)    â•‘ Decreasing deque   â•‘
â•‘ Sliding Window Minimum     â•‘   O(n)    â•‘ Increasing deque   â•‘
â•‘ First Negative in Window   â•‘   O(n)    â•‘ Simple queue       â•‘
â•‘ Sum Min+Max in Windows     â•‘   O(n)    â•‘ Two deques         â•‘
â•‘ Longest with Limit         â•‘   O(n)    â•‘ Two deques + 2ptr  â•‘
â•‘ Sliding Window Median      â•‘ O(n log k)â•‘ Two heaps          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ’¡ KEY INSIGHTS:

âœ“ Monotonic deque is OPTIMAL for window extremum
âœ“ Each element added/removed at most once â†’ O(n)
âœ“ Store INDICES not values (easier window management)
âœ“ For max: decreasing deque, For min: increasing deque
âœ“ Two deques can track both min and max simultaneously
âœ“ Median requires heaps, not deque (O(n log k))

ğŸ”‘ PATTERN RECOGNITION:

"Find max/min in sliding window" â†’ Monotonic Deque
"Find first X in window" â†’ Simple Queue
"Track both max and min" â†’ Two Monotonic Deques
"Find median in window" â†’ Two Heaps (not queue)

âš ï¸ COMMON MISTAKES:

âœ— Using values instead of indices
âœ— Forgetting to remove elements outside window
âœ— Using wrong order (increasing vs decreasing)
âœ— Not maintaining deque property when adding
"""

print(summary)

print("\n" + "=" * 60)
print("CHAPTER 5 COMPLETE!")
print("Next: Chapter 6 - Advanced Queue Patterns")
print("=" * 60)
```

---

## Practice Problems for Chapter 5

### Easy Level:
1. âœ“ First Negative in Every Window
2. Maximum of All Subarrays of Size K

### Medium Level:
3. âœ“ Sliding Window Maximum - LeetCode #239 â­â­
4. âœ“ Longest Subarray with Absolute Diff â‰¤ Limit - LeetCode #1438
5. âœ“ Sum of Min and Max in Windows
6. Constrained Subsequence Sum - LeetCode #1425
7. Jump Game VI - LeetCode #1696

### Hard Level:
8. âœ“ Sliding Window Median - LeetCode #480 â­â­
9. Shortest Subarray with Sum at Least K - LeetCode #862
10. Minimum Window Substring - LeetCode #76

**Ready for Chapter 6**: Advanced queue patterns including design problems and bidirectional BFS!