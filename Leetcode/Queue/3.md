# Chapter 3: Standard Queue Patterns - In-Depth Explanation

## 3.1 Basic Queue Operations Pattern

### Pattern Overview

This pattern involves implementing queues using different data structures and understanding their trade-offs.

### Problem 1: Implement Queue using Two Stacks

**Concept:**
```
Stack 1 (for enqueue):  [1, 2, 3] â† push here
Stack 2 (for dequeue):  [] â† pop from here

When dequeue is called and Stack 2 is empty:
  Transfer all from Stack 1 to Stack 2
  
Stack 1: []
Stack 2: [3, 2, 1] â† now front is at top!
```

#### Implementation with Detailed Analysis

```python
class QueueUsingStacks:
    """
    Queue implementation using two stacks.
    
    Approach 1: Costly Enqueue - O(n) enqueue, O(1) dequeue
    Approach 2: Costly Dequeue - O(1) enqueue, Amortized O(1) dequeue âœ“ BETTER
    
    We'll implement Approach 2.
    """
    
    def __init__(self):
        self.stack1 = []  # For enqueue
        self.stack2 = []  # For dequeue
    
    def enqueue(self, data):
        """
        Push to stack1.
        Time: O(1)
        """
        self.stack1.append(data)
        print(f"âœ“ Enqueued {data}")
    
    def dequeue(self):
        """
        Pop from stack2. If stack2 is empty, transfer from stack1.
        Time: Amortized O(1)
        """
        # If both stacks empty
        if not self.stack1 and not self.stack2:
            raise Exception("Queue is empty!")
        
        # If stack2 is empty, transfer from stack1
        if not self.stack2:
            print("  [Transfer] Moving elements from stack1 to stack2")
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        
        data = self.stack2.pop()
        print(f"âœ“ Dequeued {data}")
        return data
    
    def peek(self):
        """Return front element without removing"""
        if not self.stack1 and not self.stack2:
            raise Exception("Queue is empty!")
        
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        
        return self.stack2[-1]
    
    def is_empty(self):
        return not self.stack1 and not self.stack2
    
    def display(self):
        """Display current state"""
        print(f"\nQueue State:")
        print(f"  Stack1 (enqueue): {self.stack1}")
        print(f"  Stack2 (dequeue): {self.stack2}")
        
        # Show logical queue order
        if not self.is_empty():
            queue_order = self.stack2[::-1] + self.stack1
            print(f"  Logical order: {queue_order}")
            print(f"  Front â†’ {queue_order[0]}")


# ============ DEMONSTRATION ============

print("=" * 60)
print("QUEUE USING TWO STACKS")
print("=" * 60)

q = QueueUsingStacks()

print("\nğŸ“ PHASE 1: Enqueue Operations")
print("-" * 60)
for val in [10, 20, 30, 40]:
    q.enqueue(val)
q.display()

print("\nğŸ“ PHASE 2: Dequeue Operations")
print("-" * 60)
print("First dequeue triggers transfer:")
q.dequeue()
q.display()

print("\nSubsequent dequeues are O(1):")
q.dequeue()
q.display()

print("\nğŸ“ PHASE 3: Mixed Operations")
print("-" * 60)
q.enqueue(50)
q.enqueue(60)
q.display()

q.dequeue()
q.display()

print("\nğŸ“ PHASE 4: Amortized Analysis")
print("-" * 60)
print("""
Amortized Analysis:
- Each element is pushed to stack1 once: O(1)
- Each element is moved to stack2 at most once: O(1)
- Each element is popped from stack2 once: O(1)

Total operations per element: 3 (all O(1))
Therefore: Amortized O(1) per operation!
""")

print("=" * 60)
```

### Problem 2: Implement Stack using Queues

**Concept:**
```
Approach 1: Costly Push
  Queue: [1, 2, 3]
  Push(4): Add 4, then rotate 3 times
  Queue: [4, 1, 2, 3] â† 4 is now at front!

Approach 2: Costly Pop
  Queue: [1, 2, 3]
  Pop(): Dequeue and enqueue n-1 times
  After: [3], then dequeue 3
```

#### Implementation

```python
from collections import deque

class StackUsingQueues:
    """
    Stack implementation using queues.
    Approach: Costly push (better for interviews)
    Push: O(n), Pop: O(1)
    """
    
    def __init__(self):
        self.queue = deque()
    
    def push(self, data):
        """
        Add element and rotate to make it front.
        Time: O(n)
        """
        size = len(self.queue)
        self.queue.append(data)
        
        # Rotate: move all old elements behind new one
        for _ in range(size):
            self.queue.append(self.queue.popleft())
        
        print(f"âœ“ Pushed {data}")
    
    def pop(self):
        """
        Remove from front (which is top of stack).
        Time: O(1)
        """
        if self.is_empty():
            raise Exception("Stack is empty!")
        
        data = self.queue.popleft()
        print(f"âœ“ Popped {data}")
        return data
    
    def top(self):
        """Return top element"""
        if self.is_empty():
            raise Exception("Stack is empty!")
        return self.queue[0]
    
    def is_empty(self):
        return len(self.queue) == 0
    
    def display(self):
        print(f"Stack (using queue): {list(self.queue)}")
        if not self.is_empty():
            print(f"Top â†’ {self.queue[0]}")


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("STACK USING QUEUES")
print("=" * 60)

stack = StackUsingQueues()

print("\nğŸ“ Push operations:")
print("-" * 60)
for val in [10, 20, 30, 40]:
    stack.push(val)
    stack.display()
    print()

print("\nğŸ“ Pop operations (LIFO order):")
print("-" * 60)
while not stack.is_empty():
    stack.pop()
    if not stack.is_empty():
        stack.display()

print("\n" + "=" * 60)
```

---

## 3.2 Queue Reversal Pattern

### Understanding Queue Reversal

**Concept:**
```
Original Queue: [10, 20, 30, 40]
                 â†‘              â†‘
               front          rear

Reversed Queue: [40, 30, 20, 10]
                 â†‘              â†‘
               front          rear
```

### Method 1: Using Stack

```python
from collections import deque

def reverse_queue_using_stack(queue):
    """
    Reverse queue using a stack.
    Time: O(n), Space: O(n)
    
    Algorithm:
    1. Dequeue all elements and push to stack
    2. Pop all from stack and enqueue back
    """
    print("\n--- Reversing Queue using Stack ---")
    print(f"Original: {list(queue)}")
    
    stack = []
    
    # Step 1: Queue â†’ Stack
    print("\nStep 1: Transfer to stack")
    while queue:
        elem = queue.popleft()
        stack.append(elem)
        print(f"  Dequeued {elem}, Stack: {stack}")
    
    # Step 2: Stack â†’ Queue
    print("\nStep 2: Transfer back to queue")
    while stack:
        elem = stack.pop()
        queue.append(elem)
        print(f"  Popped {elem}, Queue: {list(queue)}")
    
    print(f"\nReversed: {list(queue)}")
    return queue


# ============ DEMONSTRATION ============

print("=" * 60)
print("QUEUE REVERSAL USING STACK")
print("=" * 60)

q = deque([10, 20, 30, 40, 50])
reverse_queue_using_stack(q)

print("\n" + "=" * 60)
```

### Method 2: Using Recursion

```python
def reverse_queue_recursive(queue):
    """
    Reverse queue using recursion.
    Time: O(n), Space: O(n) - call stack
    """
    if not queue:
        return
    
    # Remove front element
    front = queue.popleft()
    print(f"  Recursive call with front={front}")
    
    # Reverse remaining queue
    reverse_queue_recursive(queue)
    
    # Add front to rear
    queue.append(front)
    print(f"  Added {front} to rear, Queue: {list(queue)}")


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("QUEUE REVERSAL USING RECURSION")
print("=" * 60)

q2 = deque([10, 20, 30, 40])
print(f"Original: {list(q2)}\n")

print("Recursion trace:")
reverse_queue_recursive(q2)

print(f"\nReversed: {list(q2)}")
print("=" * 60)
```

### Reverse First K Elements

```python
def reverse_first_k_elements(queue, k):
    """
    Reverse only first k elements of queue.
    
    Algorithm:
    1. Dequeue first k elements and push to stack
    2. Enqueue them back (now reversed)
    3. Rotate remaining (n-k) elements to back
    
    Time: O(n), Space: O(k)
    """
    if k <= 0 or k > len(queue):
        return queue
    
    print(f"\nOriginal: {list(queue)}")
    print(f"Reversing first {k} elements")
    
    stack = []
    
    # Step 1: First k elements to stack
    print("\nStep 1: First k to stack")
    for i in range(k):
        elem = queue.popleft()
        stack.append(elem)
        print(f"  Moved {elem} to stack: {stack}")
    
    # Step 2: Stack back to queue (reversed)
    print("\nStep 2: Stack to queue (reversed)")
    while stack:
        elem = stack.pop()
        queue.append(elem)
        print(f"  Enqueued {elem}, Queue: {list(queue)}")
    
    # Step 3: Rotate remaining elements
    print("\nStep 3: Rotate remaining elements")
    remaining = len(queue) - k
    for i in range(remaining):
        elem = queue.popleft()
        queue.append(elem)
        print(f"  Rotated {elem}, Queue: {list(queue)}")
    
    print(f"\nFinal: {list(queue)}")
    return queue


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("REVERSE FIRST K ELEMENTS")
print("=" * 60)

q3 = deque([10, 20, 30, 40, 50])
reverse_first_k_elements(q3, 3)

print("\n" + "=" * 60)
```

### Interleave First and Second Half

```python
def interleave_queue(queue):
    """
    Interleave first and second half of queue.
    
    Example:
    Input:  [1, 2, 3, 4, 5, 6]
    Output: [1, 4, 2, 5, 3, 6]
    
    Algorithm:
    1. Move first half to temporary queue
    2. Interleave elements from both queues
    
    Time: O(n), Space: O(n/2)
    """
    if len(queue) % 2 != 0:
        raise ValueError("Queue must have even length")
    
    print(f"\nOriginal: {list(queue)}")
    
    n = len(queue)
    half = n // 2
    
    # Step 1: Move first half to temp queue
    temp = deque()
    print("\nStep 1: Move first half to temp")
    for i in range(half):
        elem = queue.popleft()
        temp.append(elem)
        print(f"  Moved {elem}, Temp: {list(temp)}, Main: {list(queue)}")
    
    # Step 2: Interleave
    print("\nStep 2: Interleave")
    result = deque()
    for i in range(half):
        # From first half (temp)
        elem1 = temp.popleft()
        result.append(elem1)
        print(f"  Added {elem1} from temp")
        
        # From second half (queue)
        elem2 = queue.popleft()
        result.append(elem2)
        print(f"  Added {elem2} from queue")
        print(f"  Result so far: {list(result)}")
    
    print(f"\nInterleaved: {list(result)}")
    return result


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("INTERLEAVE FIRST AND SECOND HALF")
print("=" * 60)

q4 = deque([1, 2, 3, 4, 5, 6])
interleave_queue(q4)

print("\n" + "=" * 60)
```

---

## 3.3 Generate Numbers Pattern

### Pattern Overview

Use queue to generate sequences of numbers based on specific rules.

### Problem 1: Generate Binary Numbers from 1 to N

**Concept:**
```
Pattern: Start with "1"
From "1" generate: "10", "11"
From "10" generate: "100", "101"
From "11" generate: "110", "111"

Queue approach:
1. Enqueue "1"
2. While generating:
   - Dequeue front
   - Print it
   - Enqueue front + "0"
   - Enqueue front + "1"
```

#### Implementation

```python
from collections import deque

def generate_binary_numbers(n):
    """
    Generate binary representations from 1 to n.
    
    Time: O(n), Space: O(n)
    """
    if n <= 0:
        return []
    
    print(f"\nGenerating binary numbers from 1 to {n}")
    print("=" * 60)
    
    result = []
    queue = deque(["1"])
    
    for i in range(n):
        # Dequeue front
        front = queue.popleft()
        result.append(front)
        
        # Generate next numbers
        next1 = front + "0"
        next2 = front + "1"
        
        queue.append(next1)
        queue.append(next2)
        
        print(f"Step {i+1}: Processed '{front}' â†’ Queue: {list(queue)[:5]}...")
    
    return result


# ============ DEMONSTRATION ============

print("=" * 60)
print("GENERATE BINARY NUMBERS")
print("=" * 60)

binary_nums = generate_binary_numbers(10)
print(f"\nBinary representations from 1 to 10:")
for i, binary in enumerate(binary_nums, 1):
    print(f"  {i:2d} = {binary}")

print("\n" + "=" * 60)


# Verify correctness
print("\n--- Verification ---")
for i, binary in enumerate(binary_nums, 1):
    decimal = int(binary, 2)
    print(f"{binary} (binary) = {decimal} (decimal) {'âœ“' if decimal == i else 'âœ—'}")

print("=" * 60)
```

### Problem 2: Generate Numbers with Given Digits

```python
def generate_numbers_with_digits(n, digits):
    """
    Generate all numbers up to n using only given digits.
    
    Example: digits = [5, 6], n = 100
    Output: [5, 6, 55, 56, 65, 66]
    
    Time: O(log n), Space: O(log n)
    """
    print(f"\nGenerating numbers â‰¤ {n} using digits {digits}")
    print("=" * 60)
    
    result = []
    queue = deque(digits)
    
    while queue:
        num = queue.popleft()
        
        if num > n:
            continue
        
        result.append(num)
        print(f"Added {num}, Queue: {list(queue)[:10]}...")
        
        # Generate next numbers
        for digit in digits:
            next_num = num * 10 + digit
            if next_num <= n:
                queue.append(next_num)
    
    return sorted(result)


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("GENERATE NUMBERS WITH SPECIFIC DIGITS")
print("=" * 60)

nums = generate_numbers_with_digits(100, [5, 6])
print(f"\nNumbers â‰¤ 100 using digits [5, 6]:")
print(nums)

print("\n" + "-" * 60)

nums2 = generate_numbers_with_digits(500, [1, 2, 3])
print(f"\nNumbers â‰¤ 500 using digits [1, 2, 3]:")
print(nums2)

print("=" * 60)
```

### Problem 3: First Non-Repeating Character in Stream

```python
from collections import deque, defaultdict

class FirstNonRepeating:
    """
    Find first non-repeating character in a stream.
    
    Use queue to maintain order of non-repeating characters.
    Use hash map to track character frequencies.
    """
    
    def __init__(self):
        self.queue = deque()
        self.freq = defaultdict(int)
    
    def add_character(self, char):
        """
        Add character to stream and return first non-repeating.
        Time: O(1) amortized
        """
        # Update frequency
        self.freq[char] += 1
        
        # Add to queue if first occurrence
        if self.freq[char] == 1:
            self.queue.append(char)
        
        # Remove repeating characters from front
        while self.queue and self.freq[self.queue[0]] > 1:
            self.queue.popleft()
        
        # Return first non-repeating
        if self.queue:
            return self.queue[0]
        return None
    
    def process_stream(self, stream):
        """Process entire stream and show results"""
        print(f"\nProcessing stream: '{stream}'")
        print("=" * 60)
        
        for i, char in enumerate(stream):
            result = self.add_character(char)
            print(f"After '{char}': First non-repeating = "
                  f"'{result if result else 'None'}' "
                  f"(Queue: {list(self.queue)})")


# ============ DEMONSTRATION ============

print("\n" + "=" * 60)
print("FIRST NON-REPEATING CHARACTER IN STREAM")
print("=" * 60)

fnr = FirstNonRepeating()
fnr.process_stream("aabccbd")

print("\n" + "-" * 60)

fnr2 = FirstNonRepeating()
fnr2.process_stream("aabbcc")

print("\n" + "=" * 60)
```

---

## Summary & Key Patterns

```python
print("\n" + "=" * 60)
print("CHAPTER 3: PATTERN SUMMARY")
print("=" * 60)

summary = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         Pattern           â•‘     Time     â•‘      Key Technique      â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Queue using Stacks        â•‘ Amort. O(1)  â•‘ Two stacks, lazy xfer   â•‘
â•‘ Stack using Queues        â•‘ O(n) push    â•‘ Rotate after each push  â•‘
â•‘ Queue Reversal            â•‘ O(n)         â•‘ Stack or recursion      â•‘
â•‘ Reverse First K           â•‘ O(n)         â•‘ Stack + rotation        â•‘
â•‘ Interleave Halves         â•‘ O(n)         â•‘ Temp queue + merge      â•‘
â•‘ Generate Binary           â•‘ O(n)         â•‘ Append "0" and "1"      â•‘
â•‘ Generate with Digits      â•‘ O(log n)     â•‘ Build numbers in queue  â•‘
â•‘ First Non-Repeating       â•‘ O(1) amort.  â•‘ Queue + frequency map   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¯ KEY INSIGHTS:

1. QUEUE + STACK COMBINATION:
   - Powerful for reversal operations
   - Can implement one using the other

2. GENERATION PATTERNS:
   - Use queue to maintain candidates
   - Process front, generate new candidates
   - Classic BFS-like approach

3. STREAM PROCESSING:
   - Queue maintains order
   - Hash map tracks frequency/state
   - Remove invalid elements from front

4. AMORTIZED ANALYSIS:
   - Important for queue using stacks
   - Each element touched constant times
   - Average O(1) per operation

ğŸ’¡ PROBLEM-SOLVING TIPS:

â†’ If problem needs order + generation â†’ Think Queue
â†’ If problem needs reversal â†’ Think Stack + Queue
â†’ If problem involves stream â†’ Think Queue + HashMap
â†’ If problem needs FIFO + some property â†’ Think specialized Queue
"""

print(summary)

print("\n" + "=" * 60)
print("CHAPTER 3 COMPLETE!")
print("Next: Chapter 4 - BFS and Level-Order Traversal Patterns")
print("=" * 60)
```

---

## Practice Problems for Chapter 3

### Easy Level
1. âœ“ Implement Queue using Stacks - LeetCode #232
2. âœ“ Implement Stack using Queues - LeetCode #225
3. âœ“ Reverse Queue using Stack
4. âœ“ Generate Binary Numbers

### Medium Level
5. âœ“ Reverse First K Elements
6. âœ“ Interleave First and Second Half
7. âœ“ First Non-Repeating Character in Stream
8. Generate Numbers with Given Digits
9. First Unique Character in String - LeetCode #387
10. Design Hit Counter - LeetCode #362

### Hard Level
11. Sliding Window Maximum - LeetCode #239 (Preview for next chapter)
12. Design Circular Deque - LeetCode #641

**Ready for Chapter 4**: BFS patterns, tree/graph traversals, and shortest path problems!