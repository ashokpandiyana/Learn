# Chapter 12: String Recursion Patterns (Advanced)

## 12.1 String Subsequence Problems

### Understanding Subsequences vs Substrings

**Key Differences:**
```
String: "ABC"

Subsequences (can skip chars, maintain order):
"", "A", "B", "C", "AB", "AC", "BC", "ABC"
Total: 2^n

Substrings (must be contiguous):
"", "A", "B", "C", "AB", "BC", "ABC"
Total: n(n+1)/2
```

### Pattern 1: Longest Common Subsequence (LCS)

**Problem:** Find length of longest subsequence present in both strings.

```python
def lcs_recursive(s1, s2, i=0, j=0):
    """
    Longest Common Subsequence using recursion
    
    Time: O(2^(m+n)) - exponential without memoization
    Space: O(m+n) - recursion depth
    """
    # BASE CASE: Reached end of either string
    if i >= len(s1) or j >= len(s2):
        return 0
    
    # If characters match
    if s1[i] == s2[j]:
        # Include this character + LCS of remaining
        return 1 + lcs_recursive(s1, s2, i + 1, j + 1)
    else:
        # Try skipping character from either string
        skip_s1 = lcs_recursive(s1, s2, i + 1, j)
        skip_s2 = lcs_recursive(s1, s2, i, j + 1)
        return max(skip_s1, skip_s2)

# Test
s1 = "ABCDGH"
s2 = "AEDFHR"
print(f"LCS length: {lcs_recursive(s1, s2)}")  # 3 (ADH)
```

**Recursion Tree (Partial):**
```
s1 = "ABC", s2 = "AC"

                    lcs(0, 0) [A,A]
                         |
                    1 + lcs(1, 1) [B,C]
                    /              \
            lcs(2, 1) [C,C]    lcs(1, 2) [B,end]
                 |                  |
            1 + lcs(3, 2)          0
                 |
                 0

Result: 1 + 1 = 2 (subsequence "AC")
```

**With Memoization:**
```python
def lcs_memo(s1, s2):
    """
    Optimized LCS with memoization
    
    Time: O(m√ón), Space: O(m√ón)
    """
    memo = {}
    
    def helper(i, j):
        if (i, j) in memo:
            return memo[(i, j)]
        
        if i >= len(s1) or j >= len(s2):
            return 0
        
        if s1[i] == s2[j]:
            result = 1 + helper(i + 1, j + 1)
        else:
            result = max(helper(i + 1, j), helper(i, j + 1))
        
        memo[(i, j)] = result
        return result
    
    return helper(0, 0)

# Test
s1 = "ABCDGH"
s2 = "AEDFHR"
print(f"LCS length: {lcs_memo(s1, s2)}")  # 3
```

**Print LCS:**
```python
def print_lcs(s1, s2):
    """
    Print the actual longest common subsequence
    
    Time: O(m√ón), Space: O(m√ón)
    """
    memo = {}
    
    def helper(i, j):
        if (i, j) in memo:
            return memo[(i, j)]
        
        if i >= len(s1) or j >= len(s2):
            return ""
        
        if s1[i] == s2[j]:
            result = s1[i] + helper(i + 1, j + 1)
        else:
            lcs1 = helper(i + 1, j)
            lcs2 = helper(i, j + 1)
            result = lcs1 if len(lcs1) > len(lcs2) else lcs2
        
        memo[(i, j)] = result
        return result
    
    return helper(0, 0)

# Test
s1 = "ABCDGH"
s2 = "AEDFHR"
print(f"LCS: {print_lcs(s1, s2)}")  # "ADH"
```

---

### Pattern 2: Edit Distance (Levenshtein Distance)

**Problem:** Minimum operations (insert, delete, replace) to convert s1 to s2.

```python
def edit_distance(s1, s2, i=0, j=0):
    """
    Calculate edit distance using recursion
    
    Time: O(3^(m+n)) without memoization
    Space: O(m+n)
    """
    # BASE CASE: One string is empty
    if i >= len(s1):
        return len(s2) - j  # Insert remaining chars
    if j >= len(s2):
        return len(s1) - i  # Delete remaining chars
    
    # If characters match, no operation needed
    if s1[i] == s2[j]:
        return edit_distance(s1, s2, i + 1, j + 1)
    
    # Try all three operations
    insert = 1 + edit_distance(s1, s2, i, j + 1)
    delete = 1 + edit_distance(s1, s2, i + 1, j)
    replace = 1 + edit_distance(s1, s2, i + 1, j + 1)
    
    return min(insert, delete, replace)

# Test
s1 = "horse"
s2 = "ros"
print(f"Edit distance: {edit_distance(s1, s2)}")  # 3
```

**Step-by-Step Example:**
```
Convert "horse" to "ros":

1. Replace 'h' with 'r': "rorse"
2. Delete 'r': "rose"
3. Delete 'e': "ros"

Total: 3 operations
```

**With Memoization:**
```python
def edit_distance_memo(s1, s2):
    """
    Optimized edit distance
    
    Time: O(m√ón), Space: O(m√ón)
    """
    memo = {}
    
    def helper(i, j):
        if (i, j) in memo:
            return memo[(i, j)]
        
        if i >= len(s1):
            return len(s2) - j
        if j >= len(s2):
            return len(s1) - i
        
        if s1[i] == s2[j]:
            result = helper(i + 1, j + 1)
        else:
            insert = 1 + helper(i, j + 1)
            delete = 1 + helper(i + 1, j)
            replace = 1 + helper(i + 1, j + 1)
            result = min(insert, delete, replace)
        
        memo[(i, j)] = result
        return result
    
    return helper(0, 0)
```

---

### Pattern 3: Distinct Subsequences

**Problem:** Count distinct subsequences of t in s.

```python
def num_distinct(s, t, i=0, j=0):
    """
    Count distinct subsequences
    
    Example: s="rabbbit", t="rabbit"
    Answer: 3 (rabb_it, rab_bit, ra_bbit)
    
    Time: O(2^m), Space: O(m)
    """
    # BASE CASE: Found complete match of t
    if j >= len(t):
        return 1
    
    # BASE CASE: s exhausted but t not
    if i >= len(s):
        return 0
    
    count = 0
    
    # If characters match, we have two choices:
    if s[i] == t[j]:
        # 1. Use this character
        count += num_distinct(s, t, i + 1, j + 1)
        # 2. Don't use this character (look for another match)
        count += num_distinct(s, t, i + 1, j)
    else:
        # Character doesn't match, skip in s
        count += num_distinct(s, t, i + 1, j)
    
    return count

# Test
s = "rabbbit"
t = "rabbit"
print(f"Distinct subsequences: {num_distinct(s, t)}")  # 3
```

**Visualization:**
```
s = "rabbbit", t = "rabbit"

Finding "rabbit" in "rabbbit":

1. r a b b b i t
   ^           ^
   Match all: "rabbit"

2. r a b b b i t
   ^         ^ ^
   Skip middle b: "rabbit"

3. r a b b b i t
   ^       ^ ^ ^
   Skip first b: "rabbit"

Total: 3 distinct ways
```

**With Memoization:**
```python
def num_distinct_memo(s, t):
    """
    Optimized with memoization
    
    Time: O(m√ón), Space: O(m√ón)
    """
    memo = {}
    
    def helper(i, j):
        if (i, j) in memo:
            return memo[(i, j)]
        
        if j >= len(t):
            return 1
        if i >= len(s):
            return 0
        
        if s[i] == t[j]:
            result = helper(i + 1, j + 1) + helper(i + 1, j)
        else:
            result = helper(i + 1, j)
        
        memo[(i, j)] = result
        return result
    
    return helper(0, 0)
```

---

### Pattern 4: Shortest Common Supersequence

**Problem:** Find shortest string that has both s1 and s2 as subsequences.

```python
def shortest_common_supersequence(s1, s2):
    """
    Find shortest common supersequence
    
    Example: s1="abac", s2="cab"
    Answer: "cabac" (contains both as subsequences)
    
    Time: O(m√ón), Space: O(m√ón)
    """
    # First find LCS
    memo = {}
    
    def lcs_length(i, j):
        if (i, j) in memo:
            return memo[(i, j)]
        
        if i >= len(s1) or j >= len(s2):
            return 0
        
        if s1[i] == s2[j]:
            result = 1 + lcs_length(i + 1, j + 1)
        else:
            result = max(lcs_length(i + 1, j), lcs_length(i, j + 1))
        
        memo[(i, j)] = result
        return result
    
    lcs_len = lcs_length(0, 0)
    
    # Length of SCS = len(s1) + len(s2) - len(LCS)
    return len(s1) + len(s2) - lcs_len

# Test
s1 = "abac"
s2 = "cab"
print(f"SCS length: {shortest_common_supersequence(s1, s2)}")  # 5
```

**Print SCS:**
```python
def print_scs(s1, s2):
    """Print the actual SCS string"""
    memo = {}
    
    def helper(i, j):
        if (i, j) in memo:
            return memo[(i, j)]
        
        # BASE CASES: One string exhausted
        if i >= len(s1):
            return s2[j:]
        if j >= len(s2):
            return s1[i:]
        
        # If characters match, include once
        if s1[i] == s2[j]:
            result = s1[i] + helper(i + 1, j + 1)
        else:
            # Try both options, pick shorter
            include_s1 = s1[i] + helper(i + 1, j)
            include_s2 = s2[j] + helper(i, j + 1)
            result = include_s1 if len(include_s1) <= len(include_s2) else include_s2
        
        memo[(i, j)] = result
        return result
    
    return helper(0, 0)

# Test
s1 = "abac"
s2 = "cab"
print(f"SCS: {print_scs(s1, s2)}")  # "cabac" or similar
```

---

## 12.2 Pattern Matching

### Pattern 1: Wildcard Pattern Matching

**Problem:** Match string with pattern containing '?' (single char) and '*' (any sequence).

```python
def wildcard_match(s, p, i=0, j=0):
    """
    Wildcard pattern matching
    '?' matches single character
    '*' matches any sequence (including empty)
    
    Time: O(2^n) without memoization
    Space: O(m+n)
    """
    # BASE CASE: Both exhausted
    if i >= len(s) and j >= len(p):
        return True
    
    # BASE CASE: Pattern exhausted
    if j >= len(p):
        return False
    
    # BASE CASE: String exhausted, pattern must be all '*'
    if i >= len(s):
        return all(c == '*' for c in p[j:])
    
    # Match single character or '?'
    if p[j] == '?' or s[i] == p[j]:
        return wildcard_match(s, p, i + 1, j + 1)
    
    # Handle '*'
    if p[j] == '*':
        # Two options:
        # 1. '*' matches empty (move to next pattern char)
        # 2. '*' matches current char (move to next string char)
        return (wildcard_match(s, p, i, j + 1) or
                wildcard_match(s, p, i + 1, j))
    
    return False

# Test
print(wildcard_match("aa", "a"))        # False
print(wildcard_match("aa", "*"))        # True
print(wildcard_match("cb", "?a"))       # False
print(wildcard_match("adceb", "*a*b"))  # True
```

**With Memoization:**
```python
def wildcard_match_memo(s, p):
    """
    Optimized wildcard matching
    
    Time: O(m√ón), Space: O(m√ón)
    """
    memo = {}
    
    def helper(i, j):
        if (i, j) in memo:
            return memo[(i, j)]
        
        if i >= len(s) and j >= len(p):
            return True
        if j >= len(p):
            return False
        if i >= len(s):
            result = all(c == '*' for c in p[j:])
            memo[(i, j)] = result
            return result
        
        if p[j] == '?' or s[i] == p[j]:
            result = helper(i + 1, j + 1)
        elif p[j] == '*':
            result = helper(i, j + 1) or helper(i + 1, j)
        else:
            result = False
        
        memo[(i, j)] = result
        return result
    
    return helper(0, 0)
```

---

### Pattern 2: Regular Expression Matching

**Problem:** Match with '.' (any char) and '*' (zero or more of preceding element).

```python
def regex_match(s, p, i=0, j=0):
    """
    Regular expression matching
    '.' matches any single character
    '*' matches zero or more of preceding element
    
    Time: O(2^(m+n)) without memoization
    Space: O(m+n)
    """
    # BASE CASE: Both exhausted
    if j >= len(p):
        return i >= len(s)
    
    # Check if first characters match
    first_match = i < len(s) and (p[j] == s[i] or p[j] == '.')
    
    # Handle '*'
    if j + 1 < len(p) and p[j + 1] == '*':
        # Two options:
        # 1. '*' matches zero occurrences (skip pattern)
        # 2. '*' matches one or more (use if first matches)
        return (regex_match(s, p, i, j + 2) or
                (first_match and regex_match(s, p, i + 1, j)))
    else:
        # No '*', must match current character
        return first_match and regex_match(s, p, i + 1, j + 1)

# Test
print(regex_match("aa", "a"))        # False
print(regex_match("aa", "a*"))       # True
print(regex_match("ab", ".*"))       # True
print(regex_match("mississippi", "mis*is*p*."))  # False
```

**Step-by-Step Example:**
```
s = "aab", p = "c*a*b"

Match process:
1. c* matches empty ‚Üí ""
2. a* matches "aa" ‚Üí "aa"
3. b matches "b" ‚Üí "aab"
Result: True

Recursion tree:
regex("aab", "c*a*b", 0, 0)
‚îú‚îÄ Skip c*: regex("aab", "a*b", 0, 2)
   ‚îú‚îÄ Skip a*: regex("aab", "b", 0, 4)
   ‚îÇ  ‚îî‚îÄ 'a' ‚â† 'b': False
   ‚îî‚îÄ Match a: regex("ab", "a*b", 1, 2)
      ‚îî‚îÄ Match a: regex("b", "a*b", 2, 2)
         ‚îú‚îÄ Skip a*: regex("b", "b", 2, 4)
         ‚îÇ  ‚îî‚îÄ Match b: True ‚úì
```

**With Memoization:**
```python
def regex_match_memo(s, p):
    """
    Optimized regex matching
    
    Time: O(m√ón), Space: O(m√ón)
    """
    memo = {}
    
    def helper(i, j):
        if (i, j) in memo:
            return memo[(i, j)]
        
        if j >= len(p):
            return i >= len(s)
        
        first_match = i < len(s) and (p[j] == s[i] or p[j] == '.')
        
        if j + 1 < len(p) and p[j + 1] == '*':
            result = (helper(i, j + 2) or
                     (first_match and helper(i + 1, j)))
        else:
            result = first_match and helper(i + 1, j + 1)
        
        memo[(i, j)] = result
        return result
    
    return helper(0, 0)
```

---

### Pattern 3: String Interleaving

**Problem:** Check if s3 is formed by interleaving s1 and s2.

```python
def is_interleave(s1, s2, s3, i=0, j=0, k=0):
    """
    Check if s3 is interleaving of s1 and s2
    
    Example: s1="aabcc", s2="dbbca", s3="aadbbcbcac"
    Answer: True (a-a-d-b-b-c-b-c-a-c)
    
    Time: O(2^(m+n)) without memoization
    Space: O(m+n)
    """
    # BASE CASE: All strings exhausted
    if i >= len(s1) and j >= len(s2) and k >= len(s3):
        return True
    
    # BASE CASE: s3 exhausted but s1 or s2 not
    if k >= len(s3):
        return False
    
    # Try matching s1[i] with s3[k]
    match_s1 = False
    if i < len(s1) and s1[i] == s3[k]:
        match_s1 = is_interleave(s1, s2, s3, i + 1, j, k + 1)
    
    # Try matching s2[j] with s3[k]
    match_s2 = False
    if j < len(s2) and s2[j] == s3[k]:
        match_s2 = is_interleave(s1, s2, s3, i, j + 1, k + 1)
    
    return match_s1 or match_s2

# Test
s1 = "aabcc"
s2 = "dbbca"
s3 = "aadbbcbcac"
print(is_interleave(s1, s2, s3))  # True
```

**With Memoization:**
```python
def is_interleave_memo(s1, s2, s3):
    """
    Optimized interleaving check
    
    Time: O(m√ón), Space: O(m√ón)
    """
    if len(s1) + len(s2) != len(s3):
        return False
    
    memo = {}
    
    def helper(i, j):
        if (i, j) in memo:
            return memo[(i, j)]
        
        k = i + j
        
        if k >= len(s3):
            return i >= len(s1) and j >= len(s2)
        
        match_s1 = (i < len(s1) and s1[i] == s3[k] and
                   helper(i + 1, j))
        match_s2 = (j < len(s2) and s2[j] == s3[k] and
                   helper(i, j + 1))
        
        result = match_s1 or match_s2
        memo[(i, j)] = result
        return result
    
    return helper(0, 0)
```

---

## 12.3 Palindrome Problems

### Pattern 1: Longest Palindromic Subsequence

```python
def longest_palindrome_subsequence(s, left=0, right=None):
    """
    Find length of longest palindromic subsequence
    
    Example: "bbbab" ‚Üí 4 ("bbbb")
    
    Time: O(2^n) without memoization
    Space: O(n)
    """
    if right is None:
        right = len(s) - 1
    
    # BASE CASE: Single character
    if left == right:
        return 1
    
    # BASE CASE: Two characters
    if left + 1 == right:
        return 2 if s[left] == s[right] else 1
    
    # If characters match
    if s[left] == s[right]:
        return 2 + longest_palindrome_subsequence(s, left + 1, right - 1)
    
    # Try removing from either end
    skip_left = longest_palindrome_subsequence(s, left + 1, right)
    skip_right = longest_palindrome_subsequence(s, left, right - 1)
    
    return max(skip_left, skip_right)

# Test
print(longest_palindrome_subsequence("bbbab"))  # 4
```

**With Memoization:**
```python
def longest_palindrome_subseq_memo(s):
    """
    Optimized LPS
    
    Time: O(n¬≤), Space: O(n¬≤)
    """
    memo = {}
    
    def helper(left, right):
        if (left, right) in memo:
            return memo[(left, right)]
        
        if left == right:
            return 1
        if left > right:
            return 0
        
        if s[left] == s[right]:
            result = 2 + helper(left + 1, right - 1)
        else:
            result = max(helper(left + 1, right), helper(left, right - 1))
        
        memo[(left, right)] = result
        return result
    
    return helper(0, len(s) - 1)
```

---

### Pattern 2: Palindrome Partitioning

**Problem:** Partition string into palindromic substrings (all ways).

```python
def partition_palindrome(s, start=0, current=None, result=None):
    """
    Find all palindrome partitions
    
    Example: "aab" ‚Üí [["a","a","b"], ["aa","b"]]
    
    Time: O(n√ó2^n), Space: O(n)
    """
    if current is None:
        current = []
    if result is None:
        result = []
    
    # BASE CASE: Reached end
    if start >= len(s):
        result.append(current[:])
        return result
    
    # Try all possible partitions
    for end in range(start + 1, len(s) + 1):
        substring = s[start:end]
        
        # If substring is palindrome
        if is_palindrome(substring):
            current.append(substring)
            partition_palindrome(s, end, current, result)
            current.pop()  # Backtrack
    
    return result

def is_palindrome(s):
    return s == s[::-1]

# Test
partitions = partition_palindrome("aab")
print("Palindrome partitions:", partitions)
# Output: [['a', 'a', 'b'], ['aa', 'b']]
```

---

### Pattern 3: Minimum Cuts for Palindrome Partitioning

```python
def min_cut(s, start=0):
    """
    Minimum cuts to partition into palindromes
    
    Example: "aab" ‚Üí 1 (aa|b)
    
    Time: O(2^n) without memoization
    Space: O(n)
    """
    # BASE CASE: Reached end or entire string is palindrome
    if start >= len(s) or is_palindrome(s[start:]):
        return 0
    
    min_cuts = float('inf')
    
    # Try all possible cuts
    for end in range(start + 1, len(s) + 1):
        if is_palindrome(s[start:end]):
            cuts = 1 + min_cut(s, end)
            min_cuts = min(min_cuts, cuts)
    
    return min_cuts

# Test
print(min_cut("aab"))  # 1
```

**With Memoization:**
```python
def min_cut_memo(s):
    """
    Optimized minimum cuts
    
    Time: O(n¬≥), Space: O(n)
    """
    memo = {}
    
    def helper(start):
        if start in memo:
            return memo[start]
        
        if start >= len(s) or is_palindrome(s[start:]):
            return 0
        
        min_cuts = float('inf')
        for end in range(start + 1, len(s) + 1):
            if is_palindrome(s[start:end]):
                cuts = 1 + helper(end)
                min_cuts = min(min_cuts, cuts)
        
        memo[start] = min_cuts
        return min_cuts
    
    return helper(0)
```

---

## Key Takeaways from Chapter 12

### 1. Pattern Recognition

| Problem Type | Key Feature | Approach |
|--------------|-------------|----------|
| **Subsequence** | Can skip chars | Two pointers, include/exclude |
| **Pattern Match** | Wildcards | Handle special chars separately |
| **Palindrome** | Symmetry | Two pointers from ends |
| **Edit Distance** | Transform operations | Try all operations |
| **Interleaving** | Merge two strings | Try both sources |

### 2. Memoization Keys

```python
# Single string, one pointer
memo[i] = result

# Single string, two pointers
memo[(left, right)] = result

# Two strings
memo[(i, j)] = result

# Three strings (interleaving)
memo[(i, j)] = result  # k = i + j
```

### 3. Complexity Summary

| Problem | Without Memo | With Memo |
|---------|--------------|-----------|
| **LCS** | O(2^(m+n)) | O(m√ón) |
| **Edit Distance** | O(3^(m+n)) | O(m√ón) |
| **Wildcard Match** | O(2^n) | O(m√ón) |
| **Regex Match** | O(2^(m+n)) | O(m√ón) |
| **Palindrome LPS** | O(2^n) | O(n¬≤) |

---

## Practice Problems

### Easy
1. Is subsequence
2. Delete operation for two strings
3. Minimum ASCII delete sum
4. Longest palindrome by concatenating
5. Valid palindrome II

### Medium
6. Longest common subsequence
7. Edit distance
8. Distinct subsequences
9. Interleaving string
10. Palindrome partitioning

### Hard
11. Regular expression matching
12. Wildcard matching
13. Shortest common supersequence
14. Minimum cuts for palindrome partitioning
15. Count palindromic subsequences

### Challenge
16. Longest palindromic subsequence with k replacements
17. Number of ways to split string
18. Scramble string
19. Minimum window subsequence
20. Word break II

Master these advanced string patterns and you'll handle the toughest string problems! üî§
