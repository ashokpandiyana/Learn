# Chapter 8: Grid and Matrix Recursion

## 8.1 Path Finding Problems

### Understanding Grid Navigation

In grid problems, we typically:
- Start at a position (usually top-left)
- Move in allowed directions (right, down, up, left)
- Reach a target (usually bottom-right)
- May have obstacles or constraints

**Common Movement Patterns:**
```python
# 2 Directions (only right and down)
moves_2d = [(0, 1), (1, 0)]

# 4 Directions (right, down, left, up)
moves_4d = [(0, 1), (1, 0), (0, -1), (-1, 0)]

# 8 Directions (including diagonals)
moves_8d = [(0,1), (1,0), (0,-1), (-1,0), (1,1), (1,-1), (-1,1), (-1,-1)]
```

### Pattern 1: Unique Paths (No Obstacles)

**Problem:** Count paths from top-left to bottom-right (only right/down moves).

```python
def unique_paths(m, n, row=0, col=0):
    """
    Count unique paths in m√ón grid
    Can only move right or down
    
    Time: O(2^(m+n)), Space: O(m+n)
    """
    # BASE CASE: Reached destination
    if row == m - 1 and col == n - 1:
        return 1
    
    # BASE CASE: Out of bounds
    if row >= m or col >= n:
        return 0
    
    # Move right + Move down
    right_paths = unique_paths(m, n, row, col + 1)
    down_paths = unique_paths(m, n, row + 1, col)
    
    return right_paths + down_paths

# Test
print(unique_paths(3, 3))  # 6 paths
```

**Recursion Tree (3√ó3 grid):**
```
                    (0,0)
                  /        \
            (0,1)            (1,0)
           /     \          /     \
       (0,2)   (1,1)    (1,1)   (2,0)
         |     /   \      /  \      |
       (1,2) (1,2)(2,1)(1,2)(2,1) (2,1)
         |     |    |    |    |     |
       (2,2) (2,2)(2,2)(2,2)(2,2) (2,2)
         1     1    1    1    1     1

Total: 6 paths
```

**Visualization of Paths:**
```
3√ó3 Grid - All paths from (0,0) to (2,2):

Path 1: R‚ÜíR‚ÜíD‚ÜíD    Path 4: D‚ÜíR‚ÜíD‚ÜíR
S . .              S . .
. . .              ‚Üì . .
. . E              . . E

Path 2: R‚ÜíD‚ÜíR‚ÜíD    Path 5: D‚ÜíR‚ÜíR‚ÜíD
S ‚Üí .              S . .
  ‚Üì .              ‚Üì ‚Üí ‚Üí
  . E                . E

Path 3: R‚ÜíD‚ÜíD‚ÜíR    Path 6: D‚ÜíD‚ÜíR‚ÜíR
S ‚Üí .              S . .
  ‚Üì .              ‚Üì . .
  . E              ‚Üì ‚Üí E
```

#### With Memoization (Optimization)

```python
def unique_paths_memo(m, n):
    """
    Optimized with memoization
    
    Time: O(m√ón), Space: O(m√ón)
    """
    memo = {}
    
    def helper(row, col):
        # Check memo
        if (row, col) in memo:
            return memo[(row, col)]
        
        # Base cases
        if row == m - 1 and col == n - 1:
            return 1
        if row >= m or col >= n:
            return 0
        
        # Calculate and store
        paths = helper(row, col + 1) + helper(row + 1, col)
        memo[(row, col)] = paths
        return paths
    
    return helper(0, 0)

# Test
print(unique_paths_memo(3, 7))  # Fast even for large grids!
```

---

### Pattern 2: Unique Paths with Obstacles

**Problem:** Count paths in grid with obstacles (marked as 1).

```python
def unique_paths_with_obstacles(grid, row=0, col=0):
    """
    Count paths avoiding obstacles
    grid[i][j] = 1 means obstacle
    
    Time: O(2^(m+n)), Space: O(m+n)
    """
    m, n = len(grid), len(grid[0])
    
    # BASE CASE: Out of bounds or obstacle
    if row >= m or col >= n or grid[row][col] == 1:
        return 0
    
    # BASE CASE: Reached destination
    if row == m - 1 and col == n - 1:
        return 1
    
    # Move right + Move down
    right_paths = unique_paths_with_obstacles(grid, row, col + 1)
    down_paths = unique_paths_with_obstacles(grid, row + 1, col)
    
    return right_paths + down_paths

# Test
grid = [
    [0, 0, 0],
    [0, 1, 0],
    [0, 0, 0]
]
print(unique_paths_with_obstacles(grid))  # 2 paths
```

**Visualization:**
```
Grid (0=open, 1=obstacle):
S 0 0
0 X 0    X = obstacle
0 0 E

Valid paths:
Path 1: R‚ÜíR‚ÜíD‚ÜíD
S ‚Üí ‚Üí
  ‚Üì X .
  . . E

Path 2: D‚ÜíD‚ÜíR‚ÜíR
S . .
‚Üì X .
‚Üì ‚Üí E

Total: 2 paths (Path through middle is blocked)
```

---

### Pattern 3: Minimum Path Sum

**Problem:** Find path with minimum sum from top-left to bottom-right.

```python
def min_path_sum(grid, row=0, col=0):
    """
    Find minimum sum path
    
    Time: O(2^(m+n)), Space: O(m+n)
    """
    m, n = len(grid), len(grid[0])
    
    # BASE CASE: Reached destination
    if row == m - 1 and col == n - 1:
        return grid[row][col]
    
    # BASE CASE: Out of bounds
    if row >= m or col >= n:
        return float('inf')
    
    # Current cell + min of (right path, down path)
    current = grid[row][col]
    right = min_path_sum(grid, row, col + 1)
    down = min_path_sum(grid, row + 1, col)
    
    return current + min(right, down)

# Test
grid = [
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1]
]
print(min_path_sum(grid))  # 7 (path: 1‚Üí3‚Üí1‚Üí1‚Üí1)
```

**Visualization:**
```
Grid with costs:
1  3  1
1  5  1
4  2  1

Optimal path (sum = 7):
1‚Üí 3‚Üí 1
      ‚Üì
      1
      ‚Üì
      1

Other paths:
1‚Üí1‚Üí5‚Üí1‚Üí1 = 9
1‚Üí1‚Üí4‚Üí2‚Üí1 = 9
```

#### With Memoization

```python
def min_path_sum_memo(grid):
    """
    Optimized minimum path sum
    
    Time: O(m√ón), Space: O(m√ón)
    """
    m, n = len(grid), len(grid[0])
    memo = {}
    
    def helper(row, col):
        if (row, col) in memo:
            return memo[(row, col)]
        
        if row == m - 1 and col == n - 1:
            return grid[row][col]
        
        if row >= m or col >= n:
            return float('inf')
        
        current = grid[row][col]
        result = current + min(helper(row, col + 1), helper(row + 1, col))
        memo[(row, col)] = result
        return result
    
    return helper(0, 0)
```

---

### Pattern 4: All Paths with Path Tracking

**Problem:** Print all paths from source to destination.

```python
def print_all_paths(m, n, row=0, col=0, path=""):
    """
    Print all paths with their routes
    
    Time: O(2^(m+n)), Space: O(m+n)
    """
    # BASE CASE: Reached destination
    if row == m - 1 and col == n - 1:
        print(path)
        return
    
    # BASE CASE: Out of bounds
    if row >= m or col >= n:
        return
    
    # Move right
    print_all_paths(m, n, row, col + 1, path + "R")
    
    # Move down
    print_all_paths(m, n, row + 1, col, path + "D")

# Test
print("All paths in 3√ó3 grid:")
print_all_paths(3, 3)
```

**Output:**
```
All paths in 3√ó3 grid:
RRDD
RDRD
RDDR
DRRD
DRDR
DDRR
```

#### Return Paths as List

```python
def get_all_paths(m, n, row=0, col=0):
    """Return all paths as list of coordinate lists"""
    # BASE CASE: Reached destination
    if row == m - 1 and col == n - 1:
        return [[(row, col)]]
    
    # BASE CASE: Out of bounds
    if row >= m or col >= n:
        return []
    
    paths = []
    
    # Right paths
    right_paths = get_all_paths(m, n, row, col + 1)
    for path in right_paths:
        paths.append([(row, col)] + path)
    
    # Down paths
    down_paths = get_all_paths(m, n, row + 1, col)
    for path in down_paths:
        paths.append([(row, col)] + path)
    
    return paths

# Test
paths = get_all_paths(3, 3)
print(f"Total paths: {len(paths)}")
print("\nFirst path:")
print(paths[0])
```

---

## 8.2 Flood Fill and Connected Components

### Understanding Flood Fill

Flood fill is like the paint bucket tool in graphics programs:
- Start at a cell
- Spread to all connected cells of same color
- Mark them as visited or change their value

### Pattern 1: Basic Flood Fill

**Problem:** Change color of all connected cells.

```python
def flood_fill(image, sr, sc, new_color):
    """
    Flood fill starting from (sr, sc)
    
    Time: O(m√ón), Space: O(m√ón)
    """
    m, n = len(image), len(image[0])
    original_color = image[sr][sc]
    
    # If already the target color, no need to fill
    if original_color == new_color:
        return image
    
    def fill(row, col):
        # BASE CASE: Out of bounds or different color
        if (row < 0 or row >= m or col < 0 or col >= n or
            image[row][col] != original_color):
            return
        
        # CHOOSE: Change color
        image[row][col] = new_color
        
        # EXPLORE: Fill in 4 directions
        fill(row + 1, col)  # Down
        fill(row - 1, col)  # Up
        fill(row, col + 1)  # Right
        fill(row, col - 1)  # Left
    
    fill(sr, sc)
    return image

# Test
image = [
    [1, 1, 1],
    [1, 1, 0],
    [1, 0, 1]
]
result = flood_fill(image, 1, 1, 2)
print("After flood fill:")
for row in result:
    print(row)
```

**Output:**
```
After flood fill:
[2, 2, 2]
[2, 2, 0]
[2, 0, 1]
```

**Visualization:**
```
Original (fill starting at (1,1) with color 2):
1 1 1
1 1 0    Start at center 1
1 0 1

Step-by-step:
1 1 1        2 1 1        2 2 1        2 2 2
1 2 0   ‚Üí    1 2 0   ‚Üí    1 2 0   ‚Üí    2 2 0
1 0 1        1 0 1        1 0 1        2 0 1

Spreads to all connected cells with value 1
```

---

### Pattern 2: Number of Islands

**Problem:** Count distinct islands in a grid (1=land, 0=water).

```python
def num_islands(grid):
    """
    Count number of islands using DFS
    
    Time: O(m√ón), Space: O(m√ón)
    """
    if not grid:
        return 0
    
    m, n = len(grid), len(grid[0])
    count = 0
    
    def dfs(row, col):
        # BASE CASE: Out of bounds or water
        if (row < 0 or row >= m or col < 0 or col >= n or
            grid[row][col] == '0'):
            return
        
        # CHOOSE: Mark as visited
        grid[row][col] = '0'
        
        # EXPLORE: Visit all 4 directions
        dfs(row + 1, col)
        dfs(row - 1, col)
        dfs(row, col + 1)
        dfs(row, col - 1)
    
    # Check each cell
    for i in range(m):
        for j in range(n):
            if grid[i][j] == '1':
                count += 1
                dfs(i, j)  # Mark entire island as visited
    
    return count

# Test
grid = [
    ["1","1","0","0","0"],
    ["1","1","0","0","0"],
    ["0","0","1","0","0"],
    ["0","0","0","1","1"]
]
print(f"Number of islands: {num_islands(grid)}")  # 3
```

**Visualization:**
```
Grid (1=land, 0=water):
1 1 0 0 0    Island 1
1 1 0 0 0
0 0 1 0 0    Island 2
0 0 0 1 1    Island 3

Process:
1. Find first '1' at (0,0)
2. DFS marks all connected '1's as '0' (island 1)
3. Find next '1' at (2,2)
4. DFS marks it as '0' (island 2)
5. Find next '1' at (3,3)
6. DFS marks connected '1's as '0' (island 3)
7. No more '1's found

Total: 3 islands
```

---

### Pattern 3: Number of Closed Islands

**Problem:** Count islands completely surrounded by water (not touching boundary).

```python
def closed_islands(grid):
    """
    Count closed islands (not touching boundary)
    
    Time: O(m√ón), Space: O(m√ón)
    """
    if not grid:
        return 0
    
    m, n = len(grid), len(grid[0])
    
    def dfs(row, col):
        # Out of bounds means touches boundary
        if row < 0 or row >= m or col < 0 or col >= n:
            return False
        
        # Water or already visited
        if grid[row][col] == 0:
            return True
        
        # Mark as visited
        grid[row][col] = 0
        
        # Check all 4 directions
        top = dfs(row - 1, col)
        bottom = dfs(row + 1, col)
        left = dfs(row, col - 1)
        right = dfs(row, col + 1)
        
        # Island is closed only if all directions are valid
        return top and bottom and left and right
    
    count = 0
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                if dfs(i, j):
                    count += 1
    
    return count

# Test
grid = [
    [0,0,0,0,0,0,0,0],
    [0,1,1,1,1,1,0,0],
    [0,1,0,0,0,1,0,0],
    [0,1,1,1,1,1,0,0],
    [0,0,0,0,0,0,0,0]
]
print(f"Closed islands: {closed_islands(grid)}")  # 2
```

**Visualization:**
```
0 0 0 0 0 0 0 0
0 1 1 1 1 1 0 0  ‚Üê Outer ring (closed island 1)
0 1 0 0 0 1 0 0  ‚Üê Inner hole (closed island 2)
0 1 1 1 1 1 0 0
0 0 0 0 0 0 0 0

Island 1: Outer ring of 1s
Island 2: Inner hole of 0s (surrounded by 1s)
Both are closed (don't touch boundary)
```

---

### Pattern 4: Word Search in Grid

**Problem:** Check if word exists in grid (can move in 4 directions).

```python
def word_search(board, word):
    """
    Search for word in grid using backtracking
    
    Time: O(m√ón√ó4^L) where L is word length
    Space: O(L)
    """
    if not board or not word:
        return False
    
    m, n = len(board), len(board[0])
    
    def backtrack(row, col, index):
        # BASE CASE: Found entire word
        if index == len(word):
            return True
        
        # BASE CASE: Out of bounds or wrong character
        if (row < 0 or row >= m or col < 0 or col >= n or
            board[row][col] != word[index]):
            return False
        
        # CHOOSE: Mark cell as visited (use a marker)
        temp = board[row][col]
        board[row][col] = '#'
        
        # EXPLORE: Try all 4 directions
        found = (backtrack(row + 1, col, index + 1) or
                backtrack(row - 1, col, index + 1) or
                backtrack(row, col + 1, index + 1) or
                backtrack(row, col - 1, index + 1))
        
        # UNCHOOSE: Restore cell (backtrack)
        board[row][col] = temp
        
        return found
    
    # Try starting from each cell
    for i in range(m):
        for j in range(n):
            if backtrack(i, j, 0):
                return True
    
    return False

# Test
board = [
    ['A','B','C','E'],
    ['S','F','C','S'],
    ['A','D','E','E']
]
print(word_search(board, "ABCCED"))  # True
print(word_search(board, "SEE"))     # True
print(word_search(board, "ABCB"))    # False
```

**Visualization for "ABCCED":**
```
A B C E    Start at A(0,0)
S F C S    
A D E E

Path:
A ‚Üí B ‚Üí C ‚Üí C ‚Üí E ‚Üí D
(0,0)‚Üí(0,1)‚Üí(0,2)‚Üí(1,2)‚Üí(2,2)‚Üí(2,1)

Step-by-step:
1. Start at A(0,0), mark as '#'
2. Move to B(0,1), mark as '#'
3. Move to C(0,2), mark as '#'
4. Move to C(1,2), mark as '#'
5. Move to E(2,2), mark as '#'
6. Move to D(2,1), mark as '#'
7. Word complete! Backtrack and restore all cells
```

---

## 8.3 Word Break and Pattern Matching

### Pattern 1: Word Break (String in Dictionary)

**Problem:** Check if string can be segmented into dictionary words.

```python
def word_break(s, word_dict, start=0):
    """
    Check if string can be broken into dictionary words
    
    Time: O(2^n), Space: O(n)
    """
    # BASE CASE: Reached end of string
    if start == len(s):
        return True
    
    # Try all possible words starting from current position
    for end in range(start + 1, len(s) + 1):
        word = s[start:end]
        
        # If word is in dictionary
        if word in word_dict:
            # Check if remaining string can be broken
            if word_break(s, word_dict, end):
                return True
    
    return False

# Test
s = "leetcode"
word_dict = {"leet", "code"}
print(word_break(s, word_dict))  # True (leet + code)

s = "applepenapple"
word_dict = {"apple", "pen"}
print(word_break(s, word_dict))  # True (apple + pen + apple)
```

**With Memoization:**

```python
def word_break_memo(s, word_dict):
    """
    Optimized with memoization
    
    Time: O(n¬≤), Space: O(n)
    """
    word_set = set(word_dict)
    memo = {}
    
    def helper(start):
        if start in memo:
            return memo[start]
        
        if start == len(s):
            return True
        
        for end in range(start + 1, len(s) + 1):
            word = s[start:end]
            if word in word_set and helper(end):
                memo[start] = True
                return True
        
        memo[start] = False
        return False
    
    return helper(0)
```

**Recursion Tree for "leetcode":**
```
                    "leetcode"
                  /           \
            "code"             (try other splits)
           (found!)
              |
            "" (success!)

Process:
1. Try "l" - not in dict
2. Try "le" - not in dict
3. Try "lee" - not in dict
4. Try "leet" - in dict! Recurse with "code"
   5. Try "c" - not in dict
   6. Try "co" - not in dict
   7. Try "cod" - not in dict
   8. Try "code" - in dict! Recurse with ""
      9. Empty string - success!
```

---

### Pattern 2: Pattern Matching with Wildcards

**Problem:** Match pattern with wildcards ('?' matches one char, '*' matches any sequence).

```python
def wildcard_match(s, p, i=0, j=0):
    """
    Match string with wildcard pattern
    '?' matches single character
    '*' matches any sequence (including empty)
    
    Time: O(m√ón), Space: O(m√ón)
    """
    # BASE CASE: Both strings exhausted
    if i == len(s) and j == len(p):
        return True
    
    # BASE CASE: Pattern exhausted but string remains
    if j == len(p):
        return False
    
    # BASE CASE: String exhausted, pattern must be all '*'
    if i == len(s):
        return all(c == '*' for c in p[j:])
    
    # If characters match or pattern has '?'
    if p[j] == '?' or s[i] == p[j]:
        return wildcard_match(s, p, i + 1, j + 1)
    
    # If pattern has '*'
    if p[j] == '*':
        # Try two options:
        # 1. '*' matches empty (move to next pattern char)
        # 2. '*' matches current char (move to next string char)
        return (wildcard_match(s, p, i, j + 1) or
                wildcard_match(s, p, i + 1, j))
    
    return False

# Test
print(wildcard_match("aa", "a"))      # False
print(wildcard_match("aa", "*"))      # True
print(wildcard_match("cb", "?a"))     # False
print(wildcard_match("adceb", "*a*b")) # True
```

**With Memoization:**

```python
def wildcard_match_memo(s, p):
    """
    Optimized wildcard matching
    
    Time: O(m√ón), Space: O(m√ón)
    """
    memo = {}
    
    def helper(i, j):
        if (i, j) in memo:
            return memo[(i, j)]
        
        if i == len(s) and j == len(p):
            return True
        
        if j == len(p):
            return False
        
        if i == len(s):
            result = all(c == '*' for c in p[j:])
            memo[(i, j)] = result
            return result
        
        if p[j] == '?' or s[i] == p[j]:
            result = helper(i + 1, j + 1)
        elif p[j] == '*':
            result = helper(i, j + 1) or helper(i + 1, j)
        else:
            result = False
        
        memo[(i, j)] = result
        return result
    
    return helper(0, 0)
```

---

## Key Takeaways from Chapter 8

### 1. Grid Problem Patterns

| Pattern | Technique | Directions | Visited Tracking |
|---------|-----------|------------|------------------|
| **Path counting** | Count all paths | 2 (right/down) | Not needed |
| **Path finding** | Find specific path | 2 or 4 | Not needed (bounds check) |
| **Flood fill** | Spread to connected | 4 | Modify in-place |
| **Island counting** | Count components | 4 | Mark as visited |
| **Word search** | Find pattern | 4 | Temporary marking |

### 2. Common Techniques

**Boundary Checking:**
```python
if row < 0 or row >= m or col < 0 or col >= n:
    return  # or return appropriate value
```

**Visited Tracking:**
```python
# Method 1: Modify in-place
original = grid[row][col]
grid[row][col] = '#'  # Mark visited
# ... explore ...
grid[row][col] = original  # Restore

# Method 2: Separate visited set
visited = set()
if (row, col) not in visited:
    visited.add((row, col))
    # ... explore ...
    visited.remove((row, col))
```

**Four Direction Movement:**
```python
directions = [(0,1), (1,0), (0,-1), (-1,0)]  # R, D, L, U
for dr, dc in directions:
    new_row, new_col = row + dr, col + dc
    explore(new_row, new_col)
```

### 3. Optimization: Memoization

**When to memoize:**
- Overlapping subproblems (visiting same cell multiple times)
- Path counting problems
- Optimization problems (min/max path)

**When NOT to memoize:**
- Problems requiring all solutions
- State depends on path taken (not just position)

### 4. Complexity Analysis

| Problem Type | Time | Space | Note |
|--------------|------|-------|------|
| Path counting | O(2^(m+n)) ‚Üí O(m√ón)* | O(m+n) | *with memo |
| Flood fill | O(m√ón) | O(m√ón) | Each cell visited once |
| Word search | O(m√ón√ó4^L) | O(L) | L = word length |
| Island counting | O(m√ón) | O(m√ón) | DFS on each cell |

---

## Practice Problems

### Easy
1. Island perimeter
2. Max area of island
3. Flood fill variations
4. Path exists (simple)
5. Count negative numbers in sorted matrix

### Medium
6. Surrounded regions
7. Number of enclaves
8. Pacific Atlantic water flow
9. Longest increasing path in matrix
10. Unique paths III (visit all cells)

### Hard
11. Word search II (multiple words)
12. Robot room cleaner
13. Cherry pickup
14. Shortest path in binary matrix with obstacles
15. Minimum path sum in triangle

### Challenge
16. Shortest path visiting all nodes
17. Dungeon game
18. Number of distinct islands
19. Escape a large maze
20. Count paths with target sum

---

## Common Mistakes

‚ùå **Not checking boundaries**
```python
# Wrong
def dfs(row, col):
    if grid[row][col] == 0:  # May go out of bounds!
        return

# Right
def dfs(row, col):
    if row < 0 or row >= m or col < 0 or col >= n:
        return
    if grid[row][col] == 0:
        return
```

‚ùå **Not restoring state in backtracking**
```python
# Wrong
grid[row][col] = '#'
backtrack(...)
# Missing: grid[row][col] = original

# Right
temp = grid[row][col]
grid[row][col] = '#'
backtrack(...)
grid[row][col] = temp
```

‚ùå **Infinite recursion (not marking visited)**
```python
# Wrong - infinite loop!
def dfs(row, col):
    dfs(row+1, col)  # Can come back to same cell!

# Right
def dfs(row, col):
    grid[row][col] = 0  # Mark visited
    dfs(row+1, col)
```

Master grid recursion and you'll handle 2D array problems with ease! üó∫Ô∏è
