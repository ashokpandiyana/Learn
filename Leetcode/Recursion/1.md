# Chapter 1: Fundamentals of Recursion

## 1.1 Introduction to Recursion

### What is Recursion?

Recursion is a programming technique where a function calls itself to solve a problem by breaking it down into smaller, similar subproblems. Think of it like Russian nesting dolls - each doll contains a smaller version of itself until you reach the smallest one.

### Core Components of Recursion

Every recursive function has two essential parts:

#### 1. Base Case (Termination Condition)
The condition that stops the recursion. Without it, the function would call itself infinitely.

#### 2. Recursive Case
The part where the function calls itself with modified parameters, moving toward the base case.

### Simple Example: Countdown

```python
def countdown(n):
    # Base case: stop when n reaches 0
    if n == 0:
        print("Blast off!")
        return
    
    # Recursive case: print and call with n-1
    print(n)
    countdown(n - 1)

# Function call
countdown(5)
```

**Output:**
```
5
4
3
2
1
Blast off!
```

### How It Works - The Call Stack

```
Call Stack Visualization:

countdown(5)
  |
  ├─> prints 5
  └─> calls countdown(4)
        |
        ├─> prints 4
        └─> calls countdown(3)
              |
              ├─> prints 3
              └─> calls countdown(2)
                    |
                    ├─> prints 2
                    └─> calls countdown(1)
                          |
                          ├─> prints 1
                          └─> calls countdown(0)
                                |
                                └─> prints "Blast off!" and returns
```

### The Three Laws of Recursion

1. **A recursive function must have a base case**
2. **A recursive function must change its state and move toward the base case**
3. **A recursive function must call itself**

### Example: Factorial Calculation

```python
def factorial(n):
    """
    Calculate n! = n × (n-1) × (n-2) × ... × 1
    Base case: 0! = 1, 1! = 1
    """
    # Base case
    if n == 0 or n == 1:
        return 1
    
    # Recursive case: n! = n × (n-1)!
    return n * factorial(n - 1)

# Test
print(factorial(5))  # Output: 120
```

**Recursion Tree for factorial(5):**
```
                    factorial(5)
                         |
                    5 × factorial(4)
                         |
                    5 × 4 × factorial(3)
                         |
                    5 × 4 × 3 × factorial(2)
                         |
                    5 × 4 × 3 × 2 × factorial(1)
                         |
                    5 × 4 × 3 × 2 × 1 = 120
```

### Stack Memory and Recursion

Each recursive call is stored on the call stack with its own set of local variables.

```python
def print_with_depth(n, depth=0):
    """Demonstrates stack depth"""
    indent = "  " * depth
    print(f"{indent}Entering: n={n}, depth={depth}")
    
    if n == 0:
        print(f"{indent}Base case reached!")
        return
    
    print_with_depth(n - 1, depth + 1)
    print(f"{indent}Returning: n={n}, depth={depth}")

print_with_depth(3)
```

**Output:**
```
Entering: n=3, depth=0
  Entering: n=2, depth=1
    Entering: n=1, depth=2
      Entering: n=0, depth=3
      Base case reached!
    Returning: n=1, depth=2
  Returning: n=2, depth=1
Returning: n=3, depth=0
```

**Memory Stack Visualization:**
```
Step 1: print_with_depth(3)
Stack: [print_with_depth(3)]

Step 2: Calls print_with_depth(2)
Stack: [print_with_depth(3), print_with_depth(2)]

Step 3: Calls print_with_depth(1)
Stack: [print_with_depth(3), print_with_depth(2), print_with_depth(1)]

Step 4: Calls print_with_depth(0)
Stack: [print_with_depth(3), print_with_depth(2), print_with_depth(1), print_with_depth(0)]

Step 5: Base case returns
Stack: [print_with_depth(3), print_with_depth(2), print_with_depth(1)]

Step 6: Returns back
Stack: [print_with_depth(3), print_with_depth(2)]

Step 7: Returns back
Stack: [print_with_depth(3)]

Step 8: Final return
Stack: []
```

---

## 1.2 Recursion vs Iteration

### Comparison

| Aspect | Recursion | Iteration |
|--------|-----------|-----------|
| **Approach** | Function calls itself | Loop repeats |
| **Termination** | Base case | Loop condition |
| **Space Complexity** | O(n) - call stack | O(1) - typically |
| **Readability** | Often cleaner for complex problems | Better for simple loops |
| **Performance** | Function call overhead | Generally faster |
| **Use Case** | Tree/Graph traversal, Divide & Conquer | Simple repetitive tasks |

### Example: Sum of N Natural Numbers

**Recursive Approach:**
```python
def sum_recursive(n):
    """Sum = 1 + 2 + 3 + ... + n"""
    if n == 0:
        return 0
    return n + sum_recursive(n - 1)

print(sum_recursive(5))  # Output: 15
```

**Iterative Approach:**
```python
def sum_iterative(n):
    """Sum = 1 + 2 + 3 + ... + n"""
    total = 0
    for i in range(1, n + 1):
        total += i
    return total

print(sum_iterative(5))  # Output: 15
```

**Space Complexity Comparison:**
- Recursive: O(n) - n function calls on stack
- Iterative: O(1) - only total variable

### When to Use Recursion

✅ **Use Recursion When:**
- Problem has recursive structure (trees, graphs)
- Problem can be divided into similar subproblems
- Divide and conquer approach is natural
- Code clarity is more important than minor performance gains

❌ **Avoid Recursion When:**
- Simple iterative solution exists
- Stack overflow is a concern (very deep recursion)
- Performance is critical
- Problem doesn't have recursive structure

### Example: Fibonacci (Poor Recursion Choice)

```python
def fibonacci_recursive(n):
    """Inefficient - many repeated calculations"""
    if n <= 1:
        return n
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)

# Time Complexity: O(2^n) - exponential!
print(fibonacci_recursive(6))  # Output: 8
```

**Why it's inefficient:**
```
                    fib(5)
                  /        \
            fib(4)          fib(3)
           /      \        /      \
       fib(3)   fib(2)  fib(2)  fib(1)
       /    \    /   \   /   \
   fib(2) fib(1) ...        ...
   /   \
fib(1) fib(0)

Notice: fib(3) is calculated twice, fib(2) three times!
```

**Iterative Solution (Better):**
```python
def fibonacci_iterative(n):
    """Efficient - O(n) time, O(1) space"""
    if n <= 1:
        return n
    
    prev, curr = 0, 1
    for _ in range(2, n + 1):
        prev, curr = curr, prev + curr
    
    return curr

print(fibonacci_iterative(6))  # Output: 8
```

---

## 1.3 The Recursion Tree

### What is a Recursion Tree?

A recursion tree is a visual representation of recursive calls where:
- Each node represents a function call
- Children nodes represent recursive calls made by parent
- Leaves are base cases

### Example: Sum of Array Elements

```python
def array_sum(arr, n):
    """Sum of first n elements"""
    # Base case
    if n == 0:
        return 0
    
    # Recursive case: last element + sum of rest
    return arr[n - 1] + array_sum(arr, n - 1)

arr = [1, 2, 3, 4, 5]
print(array_sum(arr, 5))  # Output: 15
```

**Recursion Tree:**
```
                    array_sum([1,2,3,4,5], 5)
                              |
                    5 + array_sum([1,2,3,4], 4)
                              |
                    5 + 4 + array_sum([1,2,3], 3)
                              |
                    5 + 4 + 3 + array_sum([1,2], 2)
                              |
                    5 + 4 + 3 + 2 + array_sum([1], 1)
                              |
                    5 + 4 + 3 + 2 + 1 + array_sum([], 0)
                              |
                    5 + 4 + 3 + 2 + 1 + 0 = 15
```

**Characteristics:**
- Height of tree: 5 (number of recursive calls)
- Space complexity: O(5) = O(n)
- Time complexity: O(5) = O(n) - one operation per node

### Understanding Branching Factor

The branching factor is the number of recursive calls made in each function call.

#### Linear Recursion (Branching Factor = 1)

```python
def print_n(n):
    if n == 0:
        return
    print(n)
    print_n(n - 1)  # Single recursive call
```

**Tree Structure:**
```
    n
    |
   n-1
    |
   n-2
    |
   ...
    |
    0
```

#### Binary Recursion (Branching Factor = 2)

```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)  # Two recursive calls
```

**Tree Structure:**
```
                    fib(4)
                  /        \
            fib(3)          fib(2)
           /      \        /      \
       fib(2)   fib(1)  fib(1)  fib(0)
       /    \
   fib(1) fib(0)
```

### Analyzing Time Complexity Using Recursion Trees

**Formula:**
```
Time Complexity = (Number of nodes in tree) × (Work per node)
```

**Example 1: Linear Recursion**
```python
def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)
```
- Nodes in tree: n
- Work per node: O(1) - just multiplication
- **Total Time: O(n)**

**Example 2: Binary Recursion**
```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)
```
- Nodes in tree: ~2^n (exponential)
- Work per node: O(1)
- **Total Time: O(2^n)**

### Example: Power Function

```python
def power(x, n):
    """Calculate x^n"""
    # Base case
    if n == 0:
        return 1
    
    # Recursive case
    return x * power(x, n - 1)

print(power(2, 4))  # Output: 16
```

**Recursion Tree:**
```
                    power(2, 4)
                         |
                    2 × power(2, 3)
                         |
                    2 × 2 × power(2, 2)
                         |
                    2 × 2 × 2 × power(2, 1)
                         |
                    2 × 2 × 2 × 2 × power(2, 0)
                         |
                    2 × 2 × 2 × 2 × 1 = 16
```

**Analysis:**
- Height: n
- Nodes: n
- Time: O(n)
- Space: O(n) - recursion stack

**Optimized Version (Divide & Conquer):**
```python
def power_optimized(x, n):
    """Calculate x^n using divide and conquer"""
    if n == 0:
        return 1
    
    half = power_optimized(x, n // 2)
    
    if n % 2 == 0:
        return half * half
    else:
        return x * half * half

print(power_optimized(2, 4))  # Output: 16
```

**Optimized Tree:**
```
                    power(2, 4)
                         |
                    power(2, 2)²
                         |
                    power(2, 1)²
                         |
                    (2 × power(2, 0)²)²
                         |
                    (2 × 1)² ² = 16
```

**Analysis:**
- Height: log(n)
- Nodes: log(n)
- Time: O(log n) - much better!
- Space: O(log n)

---

## 1.4 Types of Recursion

### 1. Direct Recursion

Function calls itself directly.

```python
def direct_example(n):
    if n == 0:
        return
    print(n)
    direct_example(n - 1)  # Calls itself
```

### 2. Indirect Recursion

Functions call each other in a cycle: A → B → A

```python
def function_a(n):
    if n > 0:
        print(f"A: {n}")
        function_b(n - 1)

def function_b(n):
    if n > 0:
        print(f"B: {n}")
        function_a(n - 1)

function_a(5)
```

**Output:**
```
A: 5
B: 4
A: 3
B: 2
A: 1
```

**Call Pattern:**
```
function_a(5) → function_b(4) → function_a(3) → function_b(2) → function_a(1) → function_b(0)
```

### 3. Tail Recursion

The recursive call is the **last operation** in the function.

```python
def tail_recursive_sum(n, accumulator=0):
    """Tail recursive - last operation is recursive call"""
    if n == 0:
        return accumulator
    # Last operation is the recursive call (no operations after)
    return tail_recursive_sum(n - 1, accumulator + n)

print(tail_recursive_sum(5))  # Output: 15
```

**Key Point:** No operations happen after the recursive call returns.

**Tail Call Optimization (TCO):**
Some compilers can optimize tail recursion to use O(1) space instead of O(n) by reusing the same stack frame.

### 4. Non-Tail Recursion

Operations occur **after** the recursive call returns.

```python
def non_tail_recursive_sum(n):
    """Non-tail recursive - operation after recursive call"""
    if n == 0:
        return 0
    # Operation (addition) happens AFTER recursive call returns
    return n + non_tail_recursive_sum(n - 1)

print(non_tail_recursive_sum(5))  # Output: 15
```

**Key Point:** Addition happens after the recursive call returns.

**Comparison:**
```
Tail Recursive:
tail_sum(5, 0)
tail_sum(4, 5)
tail_sum(3, 9)
tail_sum(2, 12)
tail_sum(1, 14)
tail_sum(0, 15) → returns 15

Non-Tail Recursive:
non_tail_sum(5)
  5 + non_tail_sum(4)
    5 + 4 + non_tail_sum(3)
      5 + 4 + 3 + non_tail_sum(2)
        5 + 4 + 3 + 2 + non_tail_sum(1)
          5 + 4 + 3 + 2 + 1 + non_tail_sum(0)
          5 + 4 + 3 + 2 + 1 + 0
          5 + 4 + 3 + 2 + 1
          5 + 4 + 3 + 3
          5 + 4 + 6
          5 + 10
          15
```

### 5. Linear Recursion

Function makes **at most one** recursive call.

```python
def linear_search(arr, target, index=0):
    """Linear recursion - one recursive call"""
    if index >= len(arr):
        return -1
    if arr[index] == target:
        return index
    # Only one recursive call
    return linear_search(arr, target, index + 1)

arr = [1, 3, 5, 7, 9]
print(linear_search(arr, 5))  # Output: 2
```

### 6. Tree Recursion (Binary/Multiple Recursion)

Function makes **two or more** recursive calls.

```python
def binary_tree_recursion(n):
    """Tree recursion - two recursive calls"""
    if n <= 0:
        return
    print(n)
    binary_tree_recursion(n - 1)  # First recursive call
    binary_tree_recursion(n - 2)  # Second recursive call

binary_tree_recursion(3)
```

**Output:**
```
3
2
1
1
```

**Recursion Tree:**
```
                    f(3)
                  /      \
              f(2)        f(1)
             /    \
         f(1)    f(0)
```

### Practical Example: Tower of Hanoi

Classic example of tree recursion.

```python
def tower_of_hanoi(n, source, destination, auxiliary):
    """
    Move n disks from source to destination using auxiliary
    """
    if n == 1:
        print(f"Move disk 1 from {source} to {destination}")
        return
    
    # Move n-1 disks from source to auxiliary using destination
    tower_of_hanoi(n - 1, source, auxiliary, destination)
    
    # Move the largest disk from source to destination
    print(f"Move disk {n} from {source} to {destination}")
    
    # Move n-1 disks from auxiliary to destination using source
    tower_of_hanoi(n - 1, auxiliary, destination, source)

# Test with 3 disks
tower_of_hanoi(3, 'A', 'C', 'B')
```

**Output:**
```
Move disk 1 from A to C
Move disk 2 from A to B
Move disk 1 from C to B
Move disk 3 from A to C
Move disk 1 from B to A
Move disk 2 from B to C
Move disk 1 from A to C
```

**Recursion Tree for tower_of_hanoi(3, A, C, B):**
```
                        TOH(3, A→C, B)
                       /       |       \
            TOH(2, A→B, C)   Move 3   TOH(2, B→C, A)
             /     |     \              /     |     \
    TOH(1,A→C) Move2 TOH(1,C→B)  TOH(1,B→A) Move2 TOH(1,A→C)
```

**Time Complexity:** O(2^n) - Each disk requires 2^k - 1 moves
**Space Complexity:** O(n) - Maximum recursion depth

---

## Key Takeaways from Chapter 1

1. **Recursion = Base Case + Recursive Case + Progress toward base case**

2. **Stack Memory:** Each recursive call uses stack space. Deep recursion can cause stack overflow.

3. **Recursion vs Iteration:**
   - Recursion: Better for tree/graph problems, cleaner code
   - Iteration: Better for simple loops, more efficient

4. **Recursion Trees:** Visualize the flow, calculate complexity
   - Height → Space complexity
   - Nodes → Time complexity

5. **Types of Recursion:**
   - Tail recursion: Can be optimized to O(1) space
   - Linear recursion: O(n) time and space
   - Tree recursion: Often O(2^n) time

6. **Always Ask:**
   - What's the base case?
   - How do we move toward base case?
   - What's returned from each call?
   - What's the time and space complexity?

---

## Practice Problems

1. Write recursive function to reverse a string
2. Calculate GCD using recursion (Euclidean algorithm)
3. Check if a number is prime using recursion
4. Print all digits of a number using recursion
5. Convert tail recursive functions to non-tail and vice versa
