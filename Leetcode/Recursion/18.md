# Chapter 18: Interview-Specific Patterns

## 18.1 Pattern Recognition

### Identifying Recursive Problems

**Key Question:** "Can this problem be broken down into smaller similar subproblems?"

### Recognition Patterns

#### Pattern 1: Keywords That Indicate Recursion

**Direct Keywords:**
- "All possible combinations/permutations"
- "Count all ways"
- "Generate all solutions"
- "Find all paths"
- "Explore all possibilities"

**Structural Keywords:**
- Tree/graph traversal
- "Subset" or "subsequence"
- "Partition"
- "Parentheses matching"
- "Expression evaluation"

**Example:**
```
"Find all possible ways to climb n stairs"
                ‚Üë
Keyword: "all possible ways" ‚Üí Try recursion with exploration
```

---

#### Pattern 2: Problem Structure Indicators

**Tree/Graph Structure:**
```python
# If problem involves:
# - Nodes and edges
# - Parent-child relationships
# - Hierarchical data
‚Üí Think DFS/Recursion

Example: "Print all root-to-leaf paths"
```

**Decision Tree Structure:**
```python
# If at each step you have choices:
# - Include or exclude
# - Take left or right
# - Try multiple options
‚Üí Think Backtracking/Recursion

Example: "Place N queens on board"
```

**Divide and Conquer Structure:**
```python
# If problem can be:
# - Split into independent parts
# - Solved separately
# - Combined efficiently
‚Üí Think Divide & Conquer

Example: "Sort an array efficiently"
```

---

### Pattern 3: Problem Categories

**Category 1: Generation Problems**
```
Generate all X that satisfy condition Y
‚Üí Backtracking with conditions

Examples:
- Generate all valid parentheses
- Generate all subsets
- Generate all permutations
```

**Category 2: Search Problems**
```
Find if X exists / Find X that maximizes Y
‚Üí DFS with pruning or memoization

Examples:
- Word search in grid
- Path exists with sum K
- Longest increasing subsequence
```

**Category 3: Counting Problems**
```
Count number of ways to do X
‚Üí Recursion with memoization (DP)

Examples:
- Coin change (count ways)
- Climbing stairs
- Decode ways
```

**Category 4: Optimization Problems**
```
Find minimum/maximum value
‚Üí Recursion with memoization + min/max

Examples:
- Edit distance
- Minimum path sum
- Maximum profit
```

---

## 18.2 Problem-Solving Framework

### The 7-Step Approach

**Step 1: Understand the Problem**
```
‚úì Read carefully
‚úì Identify inputs and outputs
‚úì Ask clarifying questions
‚úì Work through examples
```

**Step 2: Identify Base Cases**
```
Ask: "What's the simplest version?"
- Empty input
- Single element
- Zero/negative values
- Already solved state
```

**Step 3: Define Recursive Relation**
```
Ask: "How does solution depend on smaller problems?"
- What choices do I have?
- How do I reduce problem size?
- How do I combine sub-solutions?
```

**Step 4: Ensure Progress**
```
Ask: "Am I moving toward base case?"
- Problem size decreasing?
- Index changing?
- State changing?
```

**Step 5: Check for Overlapping Subproblems**
```
Ask: "Am I solving same subproblem multiple times?"
- Draw recursion tree
- Look for repeated states
- Consider memoization
```

**Step 6: Write Code**
```
Template:
def solve(params):
    # Base case(s)
    if base_condition:
        return base_value
    
    # Recursive case(s)
    result = combine(
        solve(smaller_problem_1),
        solve(smaller_problem_2)
    )
    return result
```

**Step 7: Analyze Complexity**
```
‚úì Draw recursion tree
‚úì Calculate time complexity
‚úì Calculate space complexity
‚úì Consider optimization
```

---

### Detailed Example: Unique Paths

**Problem:** Count paths from top-left to bottom-right in m√ón grid (only right/down moves).

**Step 1: Understand**
```
Input: m=3, n=2 (3 rows, 2 columns)
Output: Number of unique paths

Grid:
S . .
. . E

Example paths:
R ‚Üí R ‚Üí D
R ‚Üí D ‚Üí R
D ‚Üí R ‚Üí R
```

**Step 2: Identify Base Cases**
```
Base case 1: Reached destination (m=1, n=1)
  ‚Üí Return 1 (found one path)

Base case 2: Out of bounds (m=0 or n=0)
  ‚Üí Return 0 (invalid path)
```

**Step 3: Define Recursive Relation**
```
At any cell, I can:
1. Move right: paths(m, n-1)
2. Move down: paths(m-1, n)

Total paths = paths(m, n-1) + paths(m-1, n)
```

**Step 4: Ensure Progress**
```
‚úì m decreases (moving down)
‚úì n decreases (moving right)
‚úì Both move toward base case (1, 1)
```

**Step 5: Check Overlapping Subproblems**
```
paths(3, 3)
‚îú‚îÄ paths(3, 2)
‚îÇ  ‚îú‚îÄ paths(3, 1)
‚îÇ  ‚îî‚îÄ paths(2, 2)
‚îÇ     ‚îî‚îÄ paths(2, 1) ‚Üê Repeated!
‚îî‚îÄ paths(2, 3)
   ‚îî‚îÄ paths(2, 2)
      ‚îî‚îÄ paths(2, 1) ‚Üê Repeated!

YES, overlapping! Need memoization.
```

**Step 6: Write Code**
```python
def unique_paths(m, n, memo=None):
    """
    Count unique paths with memoization
    
    Time: O(m√ón), Space: O(m√ón)
    """
    if memo is None:
        memo = {}
    
    # Check memo
    if (m, n) in memo:
        return memo[(m, n)]
    
    # Base case: reached destination
    if m == 1 and n == 1:
        return 1
    
    # Base case: out of bounds
    if m <= 0 or n <= 0:
        return 0
    
    # Recursive case
    paths = unique_paths(m, n - 1, memo) + unique_paths(m - 1, n, memo)
    memo[(m, n)] = paths
    return paths

# Test
print(unique_paths(3, 7))  # 28
```

**Step 7: Analyze**
```
Time: O(m√ón) with memoization (each state computed once)
Space: O(m√ón) for memo + O(m+n) for recursion
Total: O(m√ón)
```

---

## 18.3 Common Interview Problems

### Problem 1: Generate Valid IP Addresses

**Problem:** Generate all valid IP addresses from string of digits.

```python
def restore_ip_addresses(s):
    """
    Generate all valid IP addresses
    
    Example: "25525511135"
    Output: ["255.255.11.135", "255.255.111.35"]
    
    Time: O(1) - max 3^4 combinations
    Space: O(1) - max depth 4
    """
    result = []
    
    def is_valid_segment(segment):
        """Check if segment is valid (0-255, no leading zeros)"""
        if not segment:
            return False
        if len(segment) > 1 and segment[0] == '0':
            return False
        return 0 <= int(segment) <= 255
    
    def backtrack(start, path, segments):
        """
        start: current position in string
        path: current IP being built
        segments: number of segments used
        """
        # BASE CASE: Used 4 segments
        if segments == 4:
            if start == len(s):
                result.append(path[:-1])  # Remove trailing dot
            return
        
        # Try all possible segment lengths (1-3 digits)
        for length in range(1, 4):
            if start + length > len(s):
                break
            
            segment = s[start:start + length]
            if is_valid_segment(segment):
                backtrack(start + length, path + segment + '.', segments + 1)
    
    backtrack(0, "", 0)
    return result

# Test
s = "25525511135"
ips = restore_ip_addresses(s)
print("Valid IP addresses:")
for ip in ips:
    print(f"  {ip}")
```

**Key Insights:**
- Fixed depth (4 segments) ‚Üí bounded recursion
- Try all segment lengths (1-3 digits)
- Validate before recursing (pruning)

---

### Problem 2: Remove Invalid Parentheses

**Problem:** Remove minimum number of parentheses to make valid.

```python
def remove_invalid_parentheses(s):
    """
    Remove minimum parentheses to make valid
    
    Example: "()())()"
    Output: ["()()()", "(())()"]
    
    Time: O(2^n), Space: O(n)
    """
    def is_valid(string):
        """Check if parentheses are balanced"""
        count = 0
        for char in string:
            if char == '(':
                count += 1
            elif char == ')':
                count -= 1
                if count < 0:
                    return False
        return count == 0
    
    def count_invalid(string):
        """Count minimum removals needed"""
        left_remove = right_remove = 0
        left_count = 0
        
        for char in string:
            if char == '(':
                left_count += 1
            elif char == ')':
                if left_count > 0:
                    left_count -= 1
                else:
                    right_remove += 1
        
        left_remove = left_count
        return left_remove, right_remove
    
    # Count minimum removals
    left_rem, right_rem = count_invalid(s)
    result = set()
    
    def backtrack(index, path, left_rem, right_rem, open_count):
        """
        index: current position
        path: current string being built
        left_rem: '(' still need to remove
        right_rem: ')' still need to remove
        open_count: current open parentheses count
        """
        # BASE CASE: Processed entire string
        if index == len(s):
            if left_rem == 0 and right_rem == 0 and open_count == 0:
                result.add(path)
            return
        
        char = s[index]
        
        # Option 1: Remove current character (if it's a parenthesis)
        if char == '(' and left_rem > 0:
            backtrack(index + 1, path, left_rem - 1, right_rem, open_count)
        if char == ')' and right_rem > 0:
            backtrack(index + 1, path, left_rem, right_rem - 1, open_count)
        
        # Option 2: Keep current character
        if char != '(' and char != ')':
            backtrack(index + 1, path + char, left_rem, right_rem, open_count)
        elif char == '(':
            backtrack(index + 1, path + char, left_rem, right_rem, open_count + 1)
        elif char == ')' and open_count > 0:
            backtrack(index + 1, path + char, left_rem, right_rem, open_count - 1)
    
    backtrack(0, "", left_rem, right_rem, 0)
    return list(result)

# Test
s = "()())()"
results = remove_invalid_parentheses(s)
print("Valid strings:")
for r in results:
    print(f"  {r}")
```

---

### Problem 3: Word Ladder

**Problem:** Find shortest transformation sequence from beginWord to endWord.

```python
def word_ladder(begin_word, end_word, word_list):
    """
    Find shortest transformation sequence
    
    Example:
    begin = "hit", end = "cog"
    wordList = ["hot","dot","dog","lot","log","cog"]
    Output: 5 (hit ‚Üí hot ‚Üí dot ‚Üí dog ‚Üí cog)
    
    Time: O(M¬≤ √ó N) where M=word length, N=word list size
    Space: O(N)
    """
    word_set = set(word_list)
    if end_word not in word_set:
        return 0
    
    def get_neighbors(word):
        """Get all words that differ by one character"""
        neighbors = []
        for i in range(len(word)):
            for c in 'abcdefghijklmnopqrstuvwxyz':
                new_word = word[:i] + c + word[i+1:]
                if new_word in word_set:
                    neighbors.append(new_word)
        return neighbors
    
    # BFS for shortest path
    from collections import deque
    queue = deque([(begin_word, 1)])
    visited = {begin_word}
    
    while queue:
        word, length = queue.popleft()
        
        if word == end_word:
            return length
        
        for neighbor in get_neighbors(word):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, length + 1))
    
    return 0

# Test
begin = "hit"
end = "cog"
word_list = ["hot","dot","dog","lot","log","cog"]
result = word_ladder(begin, end, word_list)
print(f"Shortest path length: {result}")
```

**Note:** While BFS is better for shortest path, understanding the recursive/backtracking approach is valuable for similar problems.

---

### Problem 4: Course Schedule (Topological Sort)

**Problem:** Can you finish all courses given prerequisites?

```python
def can_finish_courses(num_courses, prerequisites):
    """
    Check if all courses can be finished (cycle detection)
    
    Example:
    numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
    0 ‚Üí 1 ‚Üí 3
    0 ‚Üí 2 ‚Üí 3
    Output: True (valid order: 0,1,2,3 or 0,2,1,3)
    
    Time: O(V + E), Space: O(V + E)
    """
    # Build graph
    graph = {i: [] for i in range(num_courses)}
    for course, prereq in prerequisites:
        graph[prereq].append(course)
    
    # States: 0=unvisited, 1=visiting, 2=visited
    state = [0] * num_courses
    
    def has_cycle(course):
        """DFS to detect cycle"""
        if state[course] == 1:
            return True  # Back edge ‚Üí cycle
        if state[course] == 2:
            return False  # Already processed
        
        # Mark as visiting
        state[course] = 1
        
        # Check all neighbors
        for neighbor in graph[course]:
            if has_cycle(neighbor):
                return True
        
        # Mark as visited
        state[course] = 2
        return False
    
    # Check all courses
    for course in range(num_courses):
        if state[course] == 0:
            if has_cycle(course):
                return False
    
    return True

# Test
num_courses = 4
prerequisites = [[1,0],[2,0],[3,1],[3,2]]
print(f"Can finish: {can_finish_courses(num_courses, prerequisites)}")
```

---

### Problem 5: Critical Connections (Bridges)

**Problem:** Find all critical connections in a network.

```python
def critical_connections(n, connections):
    """
    Find bridges in network using Tarjan's algorithm
    
    Time: O(V + E), Space: O(V + E)
    """
    # Build graph
    graph = {i: [] for i in range(n)}
    for u, v in connections:
        graph[u].append(v)
        graph[v].append(u)
    
    discovery_time = [-1] * n
    low = [-1] * n
    time = [0]
    bridges = []
    
    def dfs(node, parent):
        """
        node: current node
        parent: parent node in DFS tree
        """
        discovery_time[node] = low[node] = time[0]
        time[0] += 1
        
        for neighbor in graph[node]:
            if neighbor == parent:
                continue
            
            if discovery_time[neighbor] == -1:
                # Neighbor not visited
                dfs(neighbor, node)
                
                # Update low value
                low[node] = min(low[node], low[neighbor])
                
                # Check if bridge
                if low[neighbor] > discovery_time[node]:
                    bridges.append([node, neighbor])
            else:
                # Neighbor already visited (back edge)
                low[node] = min(low[node], discovery_time[neighbor])
    
    # Start DFS from node 0
    dfs(0, -1)
    
    return bridges

# Test
n = 4
connections = [[0,1],[1,2],[2,0],[1,3]]
bridges = critical_connections(n, connections)
print(f"Critical connections: {bridges}")
# Output: [[1, 3]] (removing this disconnects the graph)
```

---

## 18.4 Debugging Recursive Code

### Technique 1: Add Print Statements

```python
def debug_fibonacci(n, depth=0):
    """Fibonacci with debug output"""
    indent = "  " * depth
    print(f"{indent}‚Üí fib({n})")
    
    if n <= 1:
        print(f"{indent}‚Üê return {n} (base case)")
        return n
    
    print(f"{indent}  Computing fib({n-1}) and fib({n-2})")
    left = debug_fibonacci(n - 1, depth + 1)
    right = debug_fibonacci(n - 2, depth + 1)
    
    result = left + right
    print(f"{indent}‚Üê return {result}")
    return result

# Test
debug_fibonacci(4)
```

**Output:**
```
‚Üí fib(4)
  Computing fib(3) and fib(2)
  ‚Üí fib(3)
    Computing fib(2) and fib(1)
    ‚Üí fib(2)
      Computing fib(1) and fib(0)
      ‚Üí fib(1)
      ‚Üê return 1 (base case)
      ‚Üí fib(0)
      ‚Üê return 0 (base case)
    ‚Üê return 1
    ‚Üí fib(1)
    ‚Üê return 1 (base case)
  ‚Üê return 2
  ‚Üí fib(2)
    Computing fib(1) and fib(0)
    ‚Üí fib(1)
    ‚Üê return 1 (base case)
    ‚Üí fib(0)
    ‚Üê return 0 (base case)
  ‚Üê return 1
‚Üê return 3
```

---

### Technique 2: Visualize Recursion Tree

```python
def visualize_calls(func_name, params, result=None):
    """Helper to visualize recursive calls"""
    import sys
    
    frame = sys._getframe(1)
    depth = 0
    while frame.f_back:
        if frame.f_code.co_name == func_name:
            depth += 1
        frame = frame.f_back
    
    indent = "‚îÇ   " * depth
    if result is None:
        print(f"{indent}‚îú‚îÄ‚îÄ {func_name}({params})")
    else:
        print(f"{indent}‚îî‚îÄ‚îÄ {func_name}({params}) = {result}")
```

---

### Technique 3: Check Invariants

```python
def backtrack_with_checks(state, path):
    """Backtracking with invariant checks"""
    # Check invariants
    assert is_valid_state(state), f"Invalid state: {state}"
    assert len(path) <= max_depth, f"Path too long: {path}"
    
    # Base case
    if is_solution(state):
        return path
    
    # Recursive case
    for choice in get_choices(state):
        # Make choice
        new_state = apply(state, choice)
        path.append(choice)
        
        # Recurse
        result = backtrack_with_checks(new_state, path)
        if result:
            return result
        
        # Backtrack
        path.pop()
        # Check invariant: state unchanged
        assert state == undo(new_state, choice), "Failed to backtrack!"
    
    return None
```

---

## 18.5 Interview Communication Tips

### What to Say During Interview

**1. Problem Understanding (2-3 minutes)**
```
"Let me make sure I understand:
- Input is... [repeat]
- Output should be... [repeat]
- Edge cases include... [mention]
- Can I assume... [clarify]"
```

**2. Example Walkthrough (2-3 minutes)**
```
"Let me work through an example:
For input [1, 2, 3]...
- At step 1, we do...
- This leads to...
- Final result is..."
```

**3. Solution Approach (3-5 minutes)**
```
"I'm thinking recursion because:
- We have choices at each step
- Problem breaks into subproblems
- Base case is...
- Recursive relation is..."
```

**4. Complexity Analysis (1-2 minutes)**
```
"Time complexity:
- Without memoization: O(2^n) because...
- With memoization: O(n) because...

Space complexity:
- Recursion depth is...
- Memoization needs..."
```

**5. Optimization Discussion (2-3 minutes)**
```
"We could optimize by:
- Adding memoization to avoid recomputation
- Pruning branches that can't lead to solution
- Converting to iterative for space efficiency"
```

---

## Key Takeaways from Chapter 18

### 1. Pattern Recognition Checklist

```
‚ñ° Read problem carefully
‚ñ° Identify keywords (all, count, generate, etc.)
‚ñ° Check for tree/graph structure
‚ñ° Look for choices at each step
‚ñ° Consider if problem divides naturally
‚ñ° Think about overlapping subproblems
```

### 2. Problem-Solving Template

```python
# 1. Understand & Examples
# 2. Base cases
# 3. Recursive relation
# 4. Code
def solve(params, memo=None):
    # Check memo
    if state in memo:
        return memo[state]
    
    # Base case
    if base_condition:
        return base_value
    
    # Recursive case
    result = process_subproblems()
    
    # Store & return
    memo[state] = result
    return result

# 5. Test & Debug
# 6. Analyze complexity
# 7. Optimize
```

### 3. Common Interview Patterns

| Pattern | When to Use | Template |
|---------|-------------|----------|
| **Backtracking** | Generate all solutions | Try choice, recurse, undo |
| **DFS** | Tree/graph traversal | Visit, mark, recurse on neighbors |
| **Divide & Conquer** | Independent subproblems | Split, solve, merge |
| **Memoization** | Overlapping subproblems | Check cache, compute, store |

---

## Practice Interview Problems

### Easy (20-30 min)
1. Fibonacci with memoization
2. Climbing stairs
3. Power(x, n)
4. Reverse linked list
5. Tree traversals

### Medium (30-45 min)
6. Generate parentheses
7. Word search
8. Course schedule
9. Combination sum
10. Unique paths

### Hard (45-60 min)
11. N-Queens
12. Sudoku solver
13. Word ladder II
14. Expression add operators
15. Remove invalid parentheses

### Mock Interview Scenarios
16. Unexpected follow-up questions
17. Time pressure situations
18. Explaining to non-technical interviewer
19. Debugging on the spot
20. Handling "I don't know"

---

## Final Interview Tips

### Do's ‚úÖ
- Think out loud
- Start with brute force
- Draw diagrams
- Test with examples
- Communicate clearly
- Ask clarifying questions
- Discuss tradeoffs
- Acknowledge mistakes

### Don'ts ‚ùå
- Jump to code immediately
- Assume without asking
- Stay silent for long
- Give up easily
- Ignore edge cases
- Skip complexity analysis
- Argue with interviewer
- Panic under pressure

Master these patterns and you'll ace any recursion interview question! üéØ
