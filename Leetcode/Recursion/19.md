# Chapter 19: Hard-Level Problems by Category

## 19.1 Backtracking Hard Problems

### Problem 1: N-Queens II (Optimize for Count)

**Problem:** Count total number of N-Queens solutions (optimized).

```python
def total_n_queens(n):
    """
    Count N-Queens solutions using bit manipulation
    
    Optimization: Use bits instead of sets for O(1) operations
    
    Time: O(N!), Space: O(N)
    """
    def backtrack(row, cols, diag1, diag2):
        """
        cols: bitmask for blocked columns
        diag1: bitmask for blocked / diagonals
        diag2: bitmask for blocked \ diagonals
        """
        # BASE CASE: All queens placed
        if row == n:
            return 1
        
        count = 0
        # Available positions = positions not blocked
        available = ((1 << n) - 1) & ~(cols | diag1 | diag2)
        
        while available:
            # Get rightmost available position
            position = available & -available
            available -= position  # Remove this position
            
            # Place queen and recurse
            count += backtrack(
                row + 1,
                cols | position,
                (diag1 | position) << 1,
                (diag2 | position) >> 1
            )
        
        return count
    
    return backtrack(0, 0, 0, 0)

# Test
for n in range(1, 10):
    count = total_n_queens(n)
    print(f"N={n}: {count} solutions")
```

**Key Optimizations:**
1. Bit manipulation for O(1) set operations
2. No board array needed
3. Diagonal checking using bit shifts

**Complexity:**
- Time: O(N!) - must try all valid placements
- Space: O(N) - recursion depth only

---

### Problem 2: Sudoku Solver (Optimized)

**Problem:** Solve Sudoku with advanced optimizations.

```python
def solve_sudoku_optimized(board):
    """
    Optimized Sudoku solver
    
    Optimizations:
    1. Track available numbers per row/col/box
    2. Choose cell with fewest candidates
    3. Early pruning
    
    Time: O(9^m) where m = empty cells
    Space: O(1) - modify in place
    """
    # Precompute available numbers
    rows = [set(range(1, 10)) for _ in range(9)]
    cols = [set(range(1, 10)) for _ in range(9)]
    boxes = [set(range(1, 10)) for _ in range(9)]
    
    empty_cells = []
    
    # Initialize constraints
    for i in range(9):
        for j in range(9):
            if board[i][j] != '.':
                num = int(board[i][j])
                rows[i].discard(num)
                cols[j].discard(num)
                boxes[(i // 3) * 3 + j // 3].discard(num)
            else:
                empty_cells.append((i, j))
    
    def get_candidates(row, col):
        """Get valid candidates for cell"""
        box_idx = (row // 3) * 3 + col // 3
        return rows[row] & cols[col] & boxes[box_idx]
    
    def backtrack(cell_idx):
        """Solve using backtracking"""
        # BASE CASE: All cells filled
        if cell_idx == len(empty_cells):
            return True
        
        row, col = empty_cells[cell_idx]
        box_idx = (row // 3) * 3 + col // 3
        
        # Try each valid candidate
        for num in get_candidates(row, col):
            # Place number
            board[row][col] = str(num)
            rows[row].discard(num)
            cols[col].discard(num)
            boxes[box_idx].discard(num)
            
            # Recurse
            if backtrack(cell_idx + 1):
                return True
            
            # Backtrack
            board[row][col] = '.'
            rows[row].add(num)
            cols[col].add(num)
            boxes[box_idx].add(num)
        
        return False
    
    backtrack(0)
    return board

# Test
board = [
    ["5","3",".",".","7",".",".",".","."],
    ["6",".",".","1","9","5",".",".","."],
    [".","9","8",".",".",".",".","6","."],
    ["8",".",".",".","6",".",".",".","3"],
    ["4",".",".","8",".","3",".",".","1"],
    ["7",".",".",".","2",".",".",".","6"],
    [".","6",".",".",".",".","2","8","."],
    [".",".",".","4","1","9",".",".","5"],
    [".",".",".",".","8",".",".","7","9"]
]

solve_sudoku_optimized(board)
print("Solved Sudoku:")
for row in board:
    print(' '.join(row))
```

---

### Problem 3: Word Search II (Multiple Words with Trie)

**Problem:** Find all words from dictionary in 2D board.

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.word = None

def find_words(board, words):
    """
    Find all words in board using Trie + DFS
    
    Time: O(MÃ—NÃ—4^L) where L = max word length
    Space: O(WÃ—L) for Trie
    """
    # Build Trie
    root = TrieNode()
    for word in words:
        node = root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.word = word
    
    m, n = len(board), len(board[0])
    result = set()
    
    def dfs(row, col, node):
        """DFS with Trie pruning"""
        # Boundary check
        if row < 0 or row >= m or col < 0 or col >= n:
            return
        
        char = board[row][col]
        
        # Already visited or not in Trie
        if char == '#' or char not in node.children:
            return
        
        node = node.children[char]
        
        # Found a word
        if node.word:
            result.add(node.word)
            # Don't return - might be prefix of another word
        
        # Mark visited
        board[row][col] = '#'
        
        # Explore 4 directions
        dfs(row + 1, col, node)
        dfs(row - 1, col, node)
        dfs(row, col + 1, node)
        dfs(row, col - 1, node)
        
        # Restore
        board[row][col] = char
        
        # Optimization: Remove leaf nodes
        if not node.children:
            del node
    
    # Start DFS from each cell
    for i in range(m):
        for j in range(n):
            if board[i][j] in root.children:
                dfs(i, j, root)
    
    return list(result)

# Test
board = [
    ['o','a','a','n'],
    ['e','t','a','e'],
    ['i','h','k','r'],
    ['i','f','l','v']
]
words = ["oath","pea","eat","rain"]
found = find_words(board, words)
print(f"Found words: {found}")  # ["oath", "eat"]
```

**Key Techniques:**
1. Trie for efficient prefix checking
2. DFS from each cell
3. Prune Trie nodes after use
4. Mark visited with '#'

---

## 19.2 Tree Hard Problems

### Problem 1: Binary Tree Maximum Path Sum

**Problem:** Find maximum sum path (any node to any node).

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def max_path_sum(root):
    """
    Maximum path sum in binary tree
    Path doesn't need to go through root
    
    Time: O(N), Space: O(H)
    """
    max_sum = [float('-inf')]
    
    def max_gain(node):
        """
        Return max gain from this node (going down)
        Update global max_sum considering path through node
        """
        if not node:
            return 0
        
        # Max gain from left and right (ignore negative)
        left_gain = max(max_gain(node.left), 0)
        right_gain = max(max_gain(node.right), 0)
        
        # Path sum through current node
        path_sum = node.val + left_gain + right_gain
        
        # Update global maximum
        max_sum[0] = max(max_sum[0], path_sum)
        
        # Return max gain going down one side
        return node.val + max(left_gain, right_gain)
    
    max_gain(root)
    return max_sum[0]

# Test
# Tree:      -10
#           /    \
#          9      20
#                /  \
#              15    7
root = TreeNode(-10)
root.left = TreeNode(9)
root.right = TreeNode(20)
root.right.left = TreeNode(15)
root.right.right = TreeNode(7)

print(f"Max path sum: {max_path_sum(root)}")  # 42 (15â†’20â†’7)
```

**Key Insight:**
- At each node, consider:
  1. Path through this node (left + node + right)
  2. Best path going down (for parent to use)

---

### Problem 2: Serialize and Deserialize Binary Tree

**Problem:** Convert tree to string and back.

```python
def serialize(root):
    """
    Serialize tree to string
    
    Time: O(N), Space: O(N)
    """
    def helper(node):
        if not node:
            return ['null']
        
        result = [str(node.val)]
        result.extend(helper(node.left))
        result.extend(helper(node.right))
        return result
    
    return ','.join(helper(root))

def deserialize(data):
    """
    Deserialize string to tree
    
    Time: O(N), Space: O(N)
    """
    def helper(values):
        val = next(values)
        if val == 'null':
            return None
        
        node = TreeNode(int(val))
        node.left = helper(values)
        node.right = helper(values)
        return node
    
    values = iter(data.split(','))
    return helper(values)

# Test
# Tree:    1
#         / \
#        2   3
#           / \
#          4   5
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.right.left = TreeNode(4)
root.right.right = TreeNode(5)

serialized = serialize(root)
print(f"Serialized: {serialized}")

deserialized = deserialize(serialized)
print(f"Deserialized: {serialize(deserialized)}")
```

---

### Problem 3: Binary Tree Cameras

**Problem:** Minimum cameras to monitor all nodes.

```python
def min_camera_cover(root):
    """
    Minimum cameras to cover all nodes
    
    States:
    0 = Not monitored
    1 = Monitored (no camera)
    2 = Has camera
    
    Time: O(N), Space: O(H)
    """
    cameras = [0]
    
    def dfs(node):
        """Return state of node"""
        if not node:
            return 1  # Null is monitored
        
        left = dfs(node.left)
        right = dfs(node.right)
        
        # If any child not monitored, place camera here
        if left == 0 or right == 0:
            cameras[0] += 1
            return 2
        
        # If any child has camera, this is monitored
        if left == 2 or right == 2:
            return 1
        
        # Both children monitored but no camera, this is not monitored
        return 0
    
    # If root not monitored, place camera there
    if dfs(root) == 0:
        cameras[0] += 1
    
    return cameras[0]

# Test
# Tree:      0
#           / \
#          0   0
#             / \
#            0   0
root = TreeNode(0)
root.left = TreeNode(0)
root.right = TreeNode(0)
root.right.left = TreeNode(0)
root.right.right = TreeNode(0)

print(f"Minimum cameras: {min_camera_cover(root)}")  # 2
```

---

## 19.3 Graph Hard Problems

### Problem 1: Word Ladder II (All Shortest Paths)

**Problem:** Find ALL shortest transformation sequences.

```python
def find_ladders(begin_word, end_word, word_list):
    """
    Find all shortest transformation sequences
    
    Time: O(MÂ² Ã— N) for BFS + O(paths) for backtracking
    Space: O(M Ã— N)
    """
    word_set = set(word_list)
    if end_word not in word_set:
        return []
    
    # Build graph using BFS
    from collections import defaultdict, deque
    
    graph = defaultdict(set)
    distance = {begin_word: 0}
    queue = deque([begin_word])
    found = False
    
    while queue and not found:
        level_size = len(queue)
        level_words = set()
        
        for _ in range(level_size):
            word = queue.popleft()
            current_dist = distance[word]
            
            # Try all transformations
            for i in range(len(word)):
                for c in 'abcdefghijklmnopqrstuvwxyz':
                    next_word = word[:i] + c + word[i+1:]
                    
                    if next_word in word_set:
                        if next_word == end_word:
                            found = True
                        
                        if next_word not in distance:
                            distance[next_word] = current_dist + 1
                            level_words.add(next_word)
                        
                        if distance[next_word] == current_dist + 1:
                            graph[word].add(next_word)
        
        queue.extend(level_words)
    
    if not found:
        return []
    
    # Backtrack to find all paths
    result = []
    
    def backtrack(word, path):
        if word == end_word:
            result.append(path[:])
            return
        
        for next_word in graph[word]:
            path.append(next_word)
            backtrack(next_word, path)
            path.pop()
    
    backtrack(begin_word, [begin_word])
    return result

# Test
begin = "hit"
end = "cog"
word_list = ["hot","dot","dog","lot","log","cog"]
paths = find_ladders(begin, end, word_list)
print("All shortest paths:")
for path in paths:
    print(" â†’ ".join(path))
```

---

### Problem 2: Alien Dictionary

**Problem:** Derive order of characters from sorted alien words.

```python
def alien_order(words):
    """
    Find character order from sorted alien dictionary
    
    Time: O(C) where C = total characters
    Space: O(1) - at most 26 letters
    """
    # Build graph
    graph = {c: set() for word in words for c in word}
    in_degree = {c: 0 for c in graph}
    
    # Compare adjacent words
    for i in range(len(words) - 1):
        word1, word2 = words[i], words[i + 1]
        min_len = min(len(word1), len(word2))
        
        # Invalid case: prefix comes after full word
        if len(word1) > len(word2) and word1[:min_len] == word2[:min_len]:
            return ""
        
        # Find first different character
        for j in range(min_len):
            if word1[j] != word2[j]:
                if word2[j] not in graph[word1[j]]:
                    graph[word1[j]].add(word2[j])
                    in_degree[word2[j]] += 1
                break
    
    # Topological sort using Kahn's algorithm
    from collections import deque
    queue = deque([c for c in in_degree if in_degree[c] == 0])
    result = []
    
    while queue:
        char = queue.popleft()
        result.append(char)
        
        for neighbor in graph[char]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    # Check if valid (no cycle)
    if len(result) != len(graph):
        return ""
    
    return ''.join(result)

# Test
words = ["wrt","wrf","er","ett","rftt"]
order = alien_order(words)
print(f"Character order: {order}")  # "wertf"
```

---

### Problem 3: Swim in Rising Water

**Problem:** Find minimum time to swim from top-left to bottom-right.

```python
def swim_in_water(grid):
    """
    Minimum time to reach bottom-right
    
    Use binary search + DFS or Dijkstra's
    
    Time: O(NÂ² log N), Space: O(NÂ²)
    """
    import heapq
    
    n = len(grid)
    visited = set()
    heap = [(grid[0][0], 0, 0)]  # (time, row, col)
    
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    while heap:
        time, row, col = heapq.heappop(heap)
        
        if (row, col) in visited:
            continue
        
        visited.add((row, col))
        
        # Reached destination
        if row == n - 1 and col == n - 1:
            return time
        
        # Explore neighbors
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            if (0 <= new_row < n and 0 <= new_col < n and
                (new_row, new_col) not in visited):
                new_time = max(time, grid[new_row][new_col])
                heapq.heappush(heap, (new_time, new_row, new_col))
    
    return -1

# Test
grid = [
    [0,2],
    [1,3]
]
print(f"Minimum time: {swim_in_water(grid)}")  # 3
```

---

## 19.4 String Hard Problems

### Problem 1: Edit Distance

**Problem:** Minimum operations to convert s1 to s2.

```python
def min_distance(word1, word2):
    """
    Edit distance with memoization
    
    Time: O(MÃ—N), Space: O(MÃ—N)
    """
    memo = {}
    
    def helper(i, j):
        if (i, j) in memo:
            return memo[(i, j)]
        
        # Base cases
        if i == len(word1):
            return len(word2) - j
        if j == len(word2):
            return len(word1) - i
        
        # Characters match
        if word1[i] == word2[j]:
            result = helper(i + 1, j + 1)
        else:
            # Try all operations
            insert = 1 + helper(i, j + 1)
            delete = 1 + helper(i + 1, j)
            replace = 1 + helper(i + 1, j + 1)
            result = min(insert, delete, replace)
        
        memo[(i, j)] = result
        return result
    
    return helper(0, 0)

# Test
word1 = "horse"
word2 = "ros"
print(f"Edit distance: {min_distance(word1, word2)}")  # 3
```

---

### Problem 2: Regular Expression Matching

**Problem:** Match string with '.' and '*' wildcards.

```python
def is_match(s, p):
    """
    Regular expression matching
    
    Time: O(MÃ—N), Space: O(MÃ—N)
    """
    memo = {}
    
    def helper(i, j):
        if (i, j) in memo:
            return memo[(i, j)]
        
        # Pattern exhausted
        if j == len(p):
            return i == len(s)
        
        # First character matches
        first_match = i < len(s) and (p[j] == s[i] or p[j] == '.')
        
        # Handle '*'
        if j + 1 < len(p) and p[j + 1] == '*':
            # Two options:
            # 1. '*' matches zero occurrences
            # 2. '*' matches one or more (if first matches)
            result = (helper(i, j + 2) or
                     (first_match and helper(i + 1, j)))
        else:
            # No '*', must match current character
            result = first_match and helper(i + 1, j + 1)
        
        memo[(i, j)] = result
        return result
    
    return helper(0, 0)

# Test
print(is_match("aa", "a"))        # False
print(is_match("aa", "a*"))       # True
print(is_match("ab", ".*"))       # True
```

---

## 19.5 Array Hard Problems

### Problem 1: Median of Two Sorted Arrays

**Problem:** Find median in O(log(min(m,n))) time.

```python
def find_median_sorted_arrays(nums1, nums2):
    """
    Find median using binary search
    
    Time: O(log(min(m,n))), Space: O(1)
    """
    # Ensure nums1 is smaller
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1
    
    m, n = len(nums1), len(nums2)
    low, high = 0, m
    
    while low <= high:
        partition1 = (low + high) // 2
        partition2 = (m + n + 1) // 2 - partition1
        
        max_left1 = float('-inf') if partition1 == 0 else nums1[partition1 - 1]
        min_right1 = float('inf') if partition1 == m else nums1[partition1]
        
        max_left2 = float('-inf') if partition2 == 0 else nums2[partition2 - 1]
        min_right2 = float('inf') if partition2 == n else nums2[partition2]
        
        # Found correct partition
        if max_left1 <= min_right2 and max_left2 <= min_right1:
            # Odd total length
            if (m + n) % 2 == 1:
                return max(max_left1, max_left2)
            # Even total length
            return (max(max_left1, max_left2) + min(min_right1, min_right2)) / 2
        elif max_left1 > min_right2:
            high = partition1 - 1
        else:
            low = partition1 + 1
    
    return -1

# Test
nums1 = [1, 3]
nums2 = [2]
print(f"Median: {find_median_sorted_arrays(nums1, nums2)}")  # 2.0
```

---

## Key Takeaways from Chapter 19

### 1. Problem Categories Summary

| Category | Key Techniques | Typical Complexity |
|----------|----------------|-------------------|
| **Backtracking** | Pruning, bit manipulation | O(N!), O(2^N) |
| **Tree** | Postorder, state tracking | O(N) |
| **Graph** | DFS+BFS combo, Trie | O(V+E), O(NÂ²) |
| **String** | DP, two pointers | O(MÃ—N) |
| **Array** | Binary search, D&C | O(log N), O(N log N) |

### 2. Optimization Checklist

âœ… Memoization for overlapping subproblems  
âœ… Pruning for backtracking  
âœ… Bit manipulation for space  
âœ… Trie for string problems  
âœ… Binary search for sorted data  
âœ… Greedy when possible  

### 3. Common Hard Problem Patterns

**Pattern Recognition:**
- Multiple constraints â†’ Backtracking
- Shortest path in unweighted graph â†’ BFS
- All shortest paths â†’ BFS + DFS
- Tree path problems â†’ Postorder traversal
- String matching â†’ DP or Trie

---

## Practice Strategy

### Week-by-Week Plan

**Week 1: Backtracking Mastery**
- N-Queens variations
- Sudoku variants
- Word search problems

**Week 2: Tree Problems**
- Path sum variations
- Serialize/deserialize
- Tree construction

**Week 3: Graph Problems**
- Topological sort
- Shortest path
- Critical connections

**Week 4: String/Array**
- Edit distance
- Pattern matching
- Median finding

Master these hard problems and you'll be ready for any technical interview! ðŸ’ª
