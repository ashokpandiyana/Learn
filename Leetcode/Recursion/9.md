# Chapter 9: Tree Recursion

## Why Trees are Perfect for Recursion

Trees are **inherently recursive structures**:
- Each node is the root of its own subtree
- Operations on tree = operation on root + recursive operations on subtrees
- Natural base case: null/leaf nodes

**Tree Node Definition:**
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```

---

## 9.1 Binary Tree Basics

### Pattern 1: Tree Traversals

Tree traversals are the foundation of tree recursion.

#### Inorder Traversal (Left ‚Üí Root ‚Üí Right)

```python
def inorder_traversal(root, result=None):
    """
    Inorder: Left subtree ‚Üí Root ‚Üí Right subtree
    For BST: gives sorted order
    
    Time: O(n), Space: O(h) where h is height
    """
    if result is None:
        result = []
    
    # BASE CASE: Empty tree
    if root is None:
        return result
    
    # Recursive case
    inorder_traversal(root.left, result)   # Left
    result.append(root.val)                # Root
    inorder_traversal(root.right, result)  # Right
    
    return result
```

**Example:**
```
Tree:
      1
     / \
    2   3
   / \
  4   5

Inorder: [4, 2, 5, 1, 3]
```

**Execution Flow:**
```
inorder(1)
‚îú‚îÄ inorder(2)
‚îÇ  ‚îú‚îÄ inorder(4)
‚îÇ  ‚îÇ  ‚îú‚îÄ inorder(null) ‚Üí return
‚îÇ  ‚îÇ  ‚îú‚îÄ append 4
‚îÇ  ‚îÇ  ‚îî‚îÄ inorder(null) ‚Üí return
‚îÇ  ‚îú‚îÄ append 2
‚îÇ  ‚îî‚îÄ inorder(5)
‚îÇ     ‚îú‚îÄ inorder(null) ‚Üí return
‚îÇ     ‚îú‚îÄ append 5
‚îÇ     ‚îî‚îÄ inorder(null) ‚Üí return
‚îú‚îÄ append 1
‚îî‚îÄ inorder(3)
   ‚îú‚îÄ inorder(null) ‚Üí return
   ‚îú‚îÄ append 3
   ‚îî‚îÄ inorder(null) ‚Üí return

Result: [4, 2, 5, 1, 3]
```

#### Preorder Traversal (Root ‚Üí Left ‚Üí Right)

```python
def preorder_traversal(root, result=None):
    """
    Preorder: Root ‚Üí Left subtree ‚Üí Right subtree
    Used for: tree copying, serialization
    
    Time: O(n), Space: O(h)
    """
    if result is None:
        result = []
    
    if root is None:
        return result
    
    result.append(root.val)                 # Root
    preorder_traversal(root.left, result)   # Left
    preorder_traversal(root.right, result)  # Right
    
    return result
```

**Example:**
```
Tree:
      1
     / \
    2   3
   / \
  4   5

Preorder: [1, 2, 4, 5, 3]
```

#### Postorder Traversal (Left ‚Üí Right ‚Üí Root)

```python
def postorder_traversal(root, result=None):
    """
    Postorder: Left subtree ‚Üí Right subtree ‚Üí Root
    Used for: deletion, bottom-up calculations
    
    Time: O(n), Space: O(h)
    """
    if result is None:
        result = []
    
    if root is None:
        return result
    
    postorder_traversal(root.left, result)   # Left
    postorder_traversal(root.right, result)  # Right
    result.append(root.val)                  # Root
    
    return result
```

**Example:**
```
Tree:
      1
     / \
    2   3
   / \
  4   5

Postorder: [4, 5, 2, 3, 1]
```

**When to Use Which Traversal:**
- **Inorder:** BST ‚Üí sorted order, expression evaluation
- **Preorder:** Tree copying, prefix expression, serialization
- **Postorder:** Tree deletion, postfix expression, subtree calculations

---

### Pattern 2: Height/Depth of Tree

```python
def max_depth(root):
    """
    Calculate maximum depth (height) of tree
    
    Time: O(n), Space: O(h)
    """
    # BASE CASE: Empty tree
    if root is None:
        return 0
    
    # Recursive case: 1 + max of left and right subtree depths
    left_depth = max_depth(root.left)
    right_depth = max_depth(root.right)
    
    return 1 + max(left_depth, right_depth)
```

**Example:**
```
Tree:
        1
       / \
      2   3
     / \
    4   5

Execution:
max_depth(1)
‚îú‚îÄ max_depth(2)
‚îÇ  ‚îú‚îÄ max_depth(4) = 1
‚îÇ  ‚îî‚îÄ max_depth(5) = 1
‚îÇ  ‚îî‚îÄ return 1 + max(1, 1) = 2
‚îî‚îÄ max_depth(3) = 1
‚îî‚îÄ return 1 + max(2, 1) = 3

Height: 3
```

**Visualization:**
```
        1         Height: 3
       / \
      2   3       Height from 2: 2
     / \          Height from 3: 1
    4   5         Height from 4,5: 1
                  Height from null: 0
```

---

### Pattern 3: Diameter of Tree

**Problem:** Find longest path between any two nodes.

```python
def diameter_of_tree(root):
    """
    Calculate diameter (longest path between any two nodes)
    Path doesn't have to pass through root
    
    Time: O(n), Space: O(h)
    """
    diameter = [0]  # Use list to modify in nested function
    
    def height(node):
        if node is None:
            return 0
        
        # Get heights of left and right subtrees
        left_height = height(node.left)
        right_height = height(node.right)
        
        # Update diameter (path through this node)
        diameter[0] = max(diameter[0], left_height + right_height)
        
        # Return height of this subtree
        return 1 + max(left_height, right_height)
    
    height(root)
    return diameter[0]
```

**Example:**
```
Tree:
        1
       / \
      2   3
     / \
    4   5

Diameter calculation at each node:
Node 4: left=0, right=0, diameter=0, height=1
Node 5: left=0, right=0, diameter=0, height=1
Node 2: left=1, right=1, diameter=2, height=2
Node 3: left=0, right=0, diameter=0, height=1
Node 1: left=2, right=1, diameter=3, height=3

Maximum diameter: 3 (path: 4‚Üí2‚Üí5 or 4‚Üí2‚Üí1)
```

**Visualization:**
```
        1
       / \
      2   3
     / \
    4   5

Longest paths:
1. 4 ‚Üí 2 ‚Üí 5 (length 2 edges)
2. 4 ‚Üí 2 ‚Üí 1 ‚Üí 3 (length 3 edges)

Path 2 is longer, diameter = 3
```

---

### Pattern 4: Check if Balanced

**Problem:** Check if tree is height-balanced (left and right subtree heights differ by at most 1).

```python
def is_balanced(root):
    """
    Check if tree is balanced
    Balanced: For every node, |left_height - right_height| ‚â§ 1
    
    Time: O(n), Space: O(h)
    """
    def check_height(node):
        # BASE CASE: Empty tree is balanced with height 0
        if node is None:
            return 0
        
        # Check left subtree
        left_height = check_height(node.left)
        if left_height == -1:  # Left subtree not balanced
            return -1
        
        # Check right subtree
        right_height = check_height(node.right)
        if right_height == -1:  # Right subtree not balanced
            return -1
        
        # Check if current node is balanced
        if abs(left_height - right_height) > 1:
            return -1  # Not balanced
        
        # Return height of current subtree
        return 1 + max(left_height, right_height)
    
    return check_height(root) != -1
```

**Example:**
```
Balanced Tree:
        1
       / \
      2   3
     / \
    4   5

Node 4: height=1, balanced‚úì
Node 5: height=1, balanced‚úì
Node 2: left=1, right=1, diff=0‚úì, balanced‚úì
Node 3: height=1, balanced‚úì
Node 1: left=2, right=1, diff=1‚úì, balanced‚úì

Result: True

Unbalanced Tree:
        1
       /
      2
     /
    3

Node 3: height=1
Node 2: left=1, right=0, diff=1‚úì
Node 1: left=2, right=0, diff=2‚úó

Result: False
```

---

### Pattern 5: Symmetric Tree Check

**Problem:** Check if tree is mirror of itself.

```python
def is_symmetric(root):
    """
    Check if tree is symmetric (mirror of itself)
    
    Time: O(n), Space: O(h)
    """
    def is_mirror(left, right):
        # BASE CASE: Both null
        if left is None and right is None:
            return True
        
        # BASE CASE: One null, other not
        if left is None or right is None:
            return False
        
        # Check: values equal and subtrees are mirrors
        return (left.val == right.val and
                is_mirror(left.left, right.right) and
                is_mirror(left.right, right.left))
    
    if root is None:
        return True
    
    return is_mirror(root.left, root.right)
```

**Example:**
```
Symmetric Tree:
        1
       / \
      2   2
     / \ / \
    3  4 4  3

Check:
- 2 == 2 ‚úì
- left.left (3) == right.right (3) ‚úì
- left.right (4) == right.left (4) ‚úì

Result: True

Not Symmetric:
        1
       / \
      2   2
       \   \
        3   3

Check:
- 2 == 2 ‚úì
- left.left (null) == right.right (3) ‚úó

Result: False
```

---

## 9.2 Path-Based Tree Problems

### Pattern 1: Root to Leaf Paths

```python
def all_root_to_leaf_paths(root, path=None, result=None):
    """
    Find all root-to-leaf paths
    
    Time: O(n), Space: O(h)
    """
    if path is None:
        path = []
    if result is None:
        result = []
    
    # BASE CASE: Empty node
    if root is None:
        return result
    
    # Add current node to path
    path.append(root.val)
    
    # BASE CASE: Leaf node
    if root.left is None and root.right is None:
        result.append(path[:])  # Copy path
    else:
        # Explore left and right subtrees
        all_root_to_leaf_paths(root.left, path, result)
        all_root_to_leaf_paths(root.right, path, result)
    
    # Backtrack: remove current node
    path.pop()
    
    return result
```

**Example:**
```
Tree:
        1
       / \
      2   3
     / \
    4   5

All paths:
[1, 2, 4]
[1, 2, 5]
[1, 3]
```

**Execution Flow:**
```
Start: path=[]
‚îú‚îÄ Visit 1: path=[1]
   ‚îú‚îÄ Visit 2: path=[1,2]
   ‚îÇ  ‚îú‚îÄ Visit 4: path=[1,2,4]
   ‚îÇ  ‚îÇ  ‚îî‚îÄ Leaf! Add [1,2,4] to result
   ‚îÇ  ‚îÇ  ‚îî‚îÄ Backtrack: path=[1,2]
   ‚îÇ  ‚îú‚îÄ Visit 5: path=[1,2,5]
   ‚îÇ  ‚îÇ  ‚îî‚îÄ Leaf! Add [1,2,5] to result
   ‚îÇ  ‚îÇ  ‚îî‚îÄ Backtrack: path=[1,2]
   ‚îÇ  ‚îî‚îÄ Backtrack: path=[1]
   ‚îú‚îÄ Visit 3: path=[1,3]
   ‚îÇ  ‚îî‚îÄ Leaf! Add [1,3] to result
   ‚îÇ  ‚îî‚îÄ Backtrack: path=[1]
   ‚îî‚îÄ Backtrack: path=[]
```

---

### Pattern 2: Path Sum

**Problem:** Check if there exists root-to-leaf path with given sum.

```python
def has_path_sum(root, target_sum):
    """
    Check if path exists with given sum
    
    Time: O(n), Space: O(h)
    """
    # BASE CASE: Empty tree
    if root is None:
        return False
    
    # BASE CASE: Leaf node
    if root.left is None and root.right is None:
        return root.val == target_sum
    
    # Recursive case: check left or right subtree
    remaining = target_sum - root.val
    return (has_path_sum(root.left, remaining) or
            has_path_sum(root.right, remaining))
```

**Example:**
```
Tree:              Target: 8
      5
     / \
    4   8
   /   / \
  11  13  4
 / \      \
7   2      1

Check paths:
1. 5‚Üí4‚Üí11‚Üí7 = 27 ‚úó
2. 5‚Üí4‚Üí11‚Üí2 = 22 ‚úó
3. 5‚Üí8‚Üí13 = 26 ‚úó
4. 5‚Üí8‚Üí4‚Üí1 = 18 ‚úó

None equal 8, return False

For target 22:
Path 5‚Üí4‚Üí11‚Üí2 = 22 ‚úì
```

---

### Pattern 3: Path Sum II (All Paths)

```python
def path_sum_all(root, target_sum, path=None, result=None):
    """
    Find all root-to-leaf paths with given sum
    
    Time: O(n), Space: O(h)
    """
    if path is None:
        path = []
    if result is None:
        result = []
    
    if root is None:
        return result
    
    # Add current node
    path.append(root.val)
    
    # Check if leaf with target sum
    if (root.left is None and root.right is None and
        sum(path) == target_sum):
        result.append(path[:])
    
    # Explore subtrees
    path_sum_all(root.left, target_sum, path, result)
    path_sum_all(root.right, target_sum, path, result)
    
    # Backtrack
    path.pop()
    
    return result
```

---

### Pattern 4: Binary Tree Maximum Path Sum

**Problem:** Find maximum sum path (path can start and end at any node).

```python
def max_path_sum(root):
    """
    Find maximum path sum (can start/end anywhere)
    
    Time: O(n), Space: O(h)
    """
    max_sum = [float('-inf')]  # Use list for modification
    
    def max_gain(node):
        if node is None:
            return 0
        
        # Get max gain from left and right (ignore negative)
        left_gain = max(max_gain(node.left), 0)
        right_gain = max(max_gain(node.right), 0)
        
        # Path through current node
        path_sum = node.val + left_gain + right_gain
        
        # Update global maximum
        max_sum[0] = max(max_sum[0], path_sum)
        
        # Return max gain if we include this node in path
        return node.val + max(left_gain, right_gain)
    
    max_gain(root)
    return max_sum[0]
```

**Example:**
```
Tree:
       -10
       / \
      9   20
         /  \
        15   7

Calculations:
Node 9: max_sum=-10+9=‚àí1, gain=9
Node 15: max_sum=15, gain=15
Node 7: max_sum=7, gain=7
Node 20: max_sum=20+15+7=42, gain=20+15=35
Node -10: max_sum=-10+9+35=34

Maximum path sum: 42 (path: 15‚Üí20‚Üí7)
```

---

## 9.3 Tree Construction and Modification

### Pattern 1: Construct from Traversals

**Problem:** Build tree from inorder and preorder traversals.

```python
def build_tree(preorder, inorder):
    """
    Construct tree from preorder and inorder traversals
    
    Time: O(n), Space: O(n)
    """
    # Create index map for O(1) lookup
    inorder_map = {val: idx for idx, val in enumerate(inorder)}
    
    def helper(pre_start, pre_end, in_start, in_end):
        # BASE CASE: Empty range
        if pre_start > pre_end:
            return None
        
        # Root is first element in preorder
        root_val = preorder[pre_start]
        root = TreeNode(root_val)
        
        # Find root in inorder
        root_idx = inorder_map[root_val]
        left_size = root_idx - in_start
        
        # Build left subtree
        root.left = helper(pre_start + 1,
                          pre_start + left_size,
                          in_start,
                          root_idx - 1)
        
        # Build right subtree
        root.right = helper(pre_start + left_size + 1,
                           pre_end,
                           root_idx + 1,
                           in_end)
        
        return root
    
    return helper(0, len(preorder) - 1, 0, len(inorder) - 1)
```

**Example:**
```
Preorder: [3, 9, 20, 15, 7]
Inorder:  [9, 3, 15, 20, 7]

Step 1: Root = 3 (first in preorder)
        Find 3 in inorder ‚Üí index 1
        Left: [9], Right: [15, 20, 7]

Step 2: Left subtree
        Preorder: [9]
        Inorder: [9]
        Root = 9 (leaf)

Step 3: Right subtree
        Preorder: [20, 15, 7]
        Inorder: [15, 20, 7]
        Root = 20
        Left: [15], Right: [7]

Result:
      3
     / \
    9   20
       / \
      15  7
```

---

### Pattern 2: Invert Binary Tree

```python
def invert_tree(root):
    """
    Invert (mirror) binary tree
    
    Time: O(n), Space: O(h)
    """
    # BASE CASE: Empty tree
    if root is None:
        return None
    
    # Swap left and right subtrees
    root.left, root.right = root.right, root.left
    
    # Recursively invert subtrees
    invert_tree(root.left)
    invert_tree(root.right)
    
    return root
```

**Example:**
```
Original:
      4
     / \
    2   7
   / \ / \
  1  3 6  9

Inverted:
      4
     / \
    7   2
   / \ / \
  9  6 3  1
```

---

### Pattern 3: Flatten Tree to Linked List

```python
def flatten(root):
    """
    Flatten tree to linked list (in-place)
    Following preorder traversal
    
    Time: O(n), Space: O(h)
    """
    def flatten_helper(node):
        if node is None:
            return None
        
        # Flatten left and right subtrees
        left_tail = flatten_helper(node.left)
        right_tail = flatten_helper(node.right)
        
        # If left subtree exists, rewire connections
        if node.left:
            left_tail.right = node.right
            node.right = node.left
            node.left = None
        
        # Return tail of flattened tree
        return right_tail or left_tail or node
    
    flatten_helper(root)
```

**Example:**
```
Original:
      1
     / \
    2   5
   / \   \
  3   4   6

Flattened:
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

---

## Key Takeaways from Chapter 9

### 1. Tree Recursion Patterns

| Pattern | Key Idea | Returns |
|---------|----------|---------|
| **Traversal** | Visit all nodes | void/list |
| **Height/Depth** | Measure from leaf | int |
| **Diameter** | Path through node | int |
| **Path sum** | Accumulate along path | bool/list |
| **Construction** | Build from traversals | TreeNode |
| **Modification** | Transform structure | TreeNode |

### 2. Common Techniques

**Postorder for Bottom-Up:**
```python
def postorder_pattern(node):
    if node is None:
        return base_value
    
    left_result = postorder_pattern(node.left)
    right_result = postorder_pattern(node.right)
    
    # Process with results from children
    current_result = process(node, left_result, right_result)
    return current_result
```

**Preorder for Top-Down:**
```python
def preorder_pattern(node, accumulated):
    if node is None:
        return
    
    # Process current with accumulated value
    new_accumulated = process(node, accumulated)
    
    # Pass down to children
    preorder_pattern(node.left, new_accumulated)
    preorder_pattern(node.right, new_accumulated)
```

### 3. Space Complexity

- **Best case:** O(log n) for balanced tree
- **Worst case:** O(n) for skewed tree
- **Average:** O(h) where h is height

### 4. When to Use Which Approach

‚úÖ **Use recursion for:**
- Tree traversals
- Tree property checking
- Path finding
- Tree construction

‚ùå **Consider iterative for:**
- Level-order traversal (BFS)
- Very deep trees (stack overflow risk)
- Space-critical applications

---

## Practice Problems

### Easy
1. Maximum depth of binary tree
2. Minimum depth of binary tree
3. Same tree check
4. Symmetric tree
5. Count nodes

### Medium
6. Path sum (all variations)
7. Lowest common ancestor
8. Binary tree right side view
9. Construct from traversals
10. Sum root to leaf numbers

### Hard
11. Maximum path sum
12. Binary tree cameras
13. Distribute coins
14. All nodes distance K
15. Serialize and deserialize tree

### Challenge
16. Recover BST
17. Vertical order traversal
18. Binary tree maximum width
19. Sum of distances in tree
20. Count complete tree nodes (O(log¬≤n))

Master tree recursion, and you master one of the most elegant patterns in computer science! üå≥
