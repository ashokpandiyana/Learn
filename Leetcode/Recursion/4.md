# Chapter 4: Recursion on Strings

## 4.1 Basic String Recursion

### Pattern 1: Print All Characters

```python
def print_chars(s, index=0):
    """
    Print all characters of string one by one
    
    Time: O(n), Space: O(n)
    """
    # Base case
    if index >= len(s):
        return
    
    # Print current character
    print(s[index], end=" ")
    
    # Recurse for rest
    print_chars(s, index + 1)

# Test
print_chars("hello")  # Output: h e l l o
```

#### Print in Reverse

```python
def print_chars_reverse(s, index=0):
    """Print characters in reverse using backtracking"""
    # Base case
    if index >= len(s):
        return
    
    # Recurse first
    print_chars_reverse(s, index + 1)
    
    # Print during backtrack
    print(s[index], end=" ")

# Test
print_chars_reverse("hello")  # Output: o l l e h
```

---

### Pattern 2: Check Palindrome

```python
def is_palindrome(s, left=0, right=None):
    """
    Check if string is palindrome using two pointers
    
    Time: O(n/2) = O(n)
    Space: O(n/2) = O(n) - recursion depth
    """
    if right is None:
        right = len(s) - 1
    
    # Base case: pointers meet or cross
    if left >= right:
        return True
    
    # If characters don't match
    if s[left] != s[right]:
        return False
    
    # Check remaining substring
    return is_palindrome(s, left + 1, right - 1)

# Test
print(is_palindrome("racecar"))    # True
print(is_palindrome("hello"))      # False
print(is_palindrome("madam"))      # True
print(is_palindrome("a"))          # True
print(is_palindrome(""))           # True
```

**Step-by-Step for "racecar":**
```
Step 1: "racecar"
         â†‘     â†‘
         l     r
         r == r âœ“

Step 2: "racecar"
          â†‘   â†‘
          l   r
          a == a âœ“

Step 3: "racecar"
           â†‘ â†‘
           l r
           c == c âœ“

Step 4: "racecar"
            â†‘
           l/r
           left >= right â†’ True
```

#### Case-Insensitive Palindrome

```python
def is_palindrome_ignore_case(s, left=0, right=None):
    """Check palindrome ignoring case"""
    if right is None:
        right = len(s) - 1
    
    if left >= right:
        return True
    
    # Compare in lowercase
    if s[left].lower() != s[right].lower():
        return False
    
    return is_palindrome_ignore_case(s, left + 1, right - 1)

# Test
print(is_palindrome_ignore_case("RaceCar"))  # True
```

---

### Pattern 3: Reverse a String

```python
def reverse_string(s, index=0):
    """
    Reverse string using recursion
    Build reversed string during backtracking
    
    Time: O(n), Space: O(n)
    """
    # Base case
    if index >= len(s):
        return ""
    
    # Recurse first, then add current character
    return reverse_string(s, index + 1) + s[index]

# Test
print(reverse_string("hello"))    # "olleh"
print(reverse_string("world"))    # "dlrow"
```

**Recursion Tree:**
```
reverse_string("abc", 0)
â””â”€ reverse_string("abc", 1) + "a"
   â””â”€ reverse_string("abc", 2) + "b" + "a"
      â””â”€ reverse_string("abc", 3) + "c" + "b" + "a"
         â””â”€ "" + "c" + "b" + "a"
         â””â”€ "cba"
```

#### Two-Pointer In-Place Reversal

```python
def reverse_string_inplace(s, left=0, right=None):
    """
    Reverse string in-place (convert to list first)
    More efficient - O(n) time, O(n) space for recursion only
    """
    # Convert to list if string
    if isinstance(s, str):
        s_list = list(s)
        result = reverse_string_inplace(s_list, left, len(s_list) - 1)
        return ''.join(result)
    
    if right is None:
        right = len(s) - 1
    
    # Base case
    if left >= right:
        return s
    
    # Swap
    s[left], s[right] = s[right], s[left]
    
    # Recurse
    return reverse_string_inplace(s, left + 1, right - 1)

# Test
print(reverse_string_inplace("hello"))  # "olleh"
```

---

### Pattern 4: Count Vowels/Consonants

```python
def count_vowels(s, index=0):
    """
    Count number of vowels in string
    
    Time: O(n), Space: O(n)
    """
    # Base case
    if index >= len(s):
        return 0
    
    # Check if current character is vowel
    vowels = "aeiouAEIOU"
    current_count = 1 if s[index] in vowels else 0
    
    # Add count from rest
    return current_count + count_vowels(s, index + 1)

# Test
print(count_vowels("hello world"))  # 3
print(count_vowels("aeiou"))        # 5
```

#### Count Consonants

```python
def count_consonants(s, index=0):
    """Count consonants (alphabetic characters that are not vowels)"""
    # Base case
    if index >= len(s):
        return 0
    
    # Check if consonant
    vowels = "aeiouAEIOU"
    is_consonant = s[index].isalpha() and s[index] not in vowels
    current_count = 1 if is_consonant else 0
    
    return current_count + count_consonants(s, index + 1)

# Test
print(count_consonants("hello world"))  # 7
```

---

### Pattern 5: Remove Character from String

```python
def remove_char(s, char, index=0):
    """
    Remove all occurrences of a character from string
    
    Time: O(n), Space: O(n)
    """
    # Base case
    if index >= len(s):
        return ""
    
    # Get result from rest of string
    rest_result = remove_char(s, char, index + 1)
    
    # If current character is not the one to remove
    if s[index] != char:
        return s[index] + rest_result
    
    return rest_result

# Test
print(remove_char("hello", 'l'))     # "heo"
print(remove_char("aabbcc", 'b'))    # "aacc"
```

#### Remove All Vowels

```python
def remove_vowels(s, index=0):
    """Remove all vowels from string"""
    if index >= len(s):
        return ""
    
    vowels = "aeiouAEIOU"
    rest_result = remove_vowels(s, index + 1)
    
    if s[index] not in vowels:
        return s[index] + rest_result
    
    return rest_result

# Test
print(remove_vowels("hello world"))  # "hll wrld"
```

---

## 4.2 String Manipulation Patterns

### Pattern 1: Remove Consecutive Duplicates

```python
def remove_consecutive_duplicates(s, index=0):
    """
    Remove consecutive duplicate characters
    "aabbcc" â†’ "abc"
    
    Time: O(n), Space: O(n)
    """
    # Base case
    if index >= len(s):
        return ""
    
    # Get result from rest
    rest_result = remove_consecutive_duplicates(s, index + 1)
    
    # If current char same as next char, skip current
    if index < len(s) - 1 and s[index] == s[index + 1]:
        return rest_result
    
    # Otherwise include current char
    return s[index] + rest_result

# Test
print(remove_consecutive_duplicates("aabbcc"))      # "abc"
print(remove_consecutive_duplicates("aaaa"))        # "a"
print(remove_consecutive_duplicates("aabbbaac"))    # "abac"
```

**Visualization:**
```
remove_consecutive_duplicates("aabbcc", 0)
â”œâ”€ s[0] = 'a', s[1] = 'a' (same) â†’ skip
â””â”€ rest = remove_consecutive_duplicates("aabbcc", 1)
   â”œâ”€ s[1] = 'a', s[2] = 'b' (different) â†’ include 'a'
   â””â”€ 'a' + remove_consecutive_duplicates("aabbcc", 2)
      â”œâ”€ s[2] = 'b', s[3] = 'b' (same) â†’ skip
      â””â”€ rest = remove_consecutive_duplicates("aabbcc", 3)
         â”œâ”€ s[3] = 'b', s[4] = 'c' (different) â†’ include 'b'
         â””â”€ 'b' + remove_consecutive_duplicates("aabbcc", 4)
            â”œâ”€ s[4] = 'c', s[5] = 'c' (same) â†’ skip
            â””â”€ rest = remove_consecutive_duplicates("aabbcc", 5)
               â”œâ”€ s[5] = 'c', no next (end) â†’ include 'c'
               â””â”€ 'c' + "" = "c"
            
Final: "abc"
```

---

### Pattern 2: Replace Characters

```python
def replace_char(s, old_char, new_char, index=0):
    """
    Replace all occurrences of old_char with new_char
    
    Time: O(n), Space: O(n)
    """
    # Base case
    if index >= len(s):
        return ""
    
    # Get result from rest
    rest_result = replace_char(s, old_char, new_char, index + 1)
    
    # Replace if matches, otherwise keep original
    if s[index] == old_char:
        return new_char + rest_result
    else:
        return s[index] + rest_result

# Test
print(replace_char("hello", 'l', 'x'))    # "hexxo"
print(replace_char("aabbcc", 'b', 'z'))   # "aazzcc"
```

---

### Pattern 3: Check if String Contains Substring

```python
def contains_substring(s, sub, s_index=0, sub_index=0):
    """
    Check if string s contains substring sub
    
    Time: O(n * m) worst case
    Space: O(n) for recursion
    """
    # If we've matched entire substring
    if sub_index >= len(sub):
        return True
    
    # If we've exhausted main string
    if s_index >= len(s):
        return False
    
    # If characters match
    if s[s_index] == sub[sub_index]:
        # Try to match rest of substring
        if contains_substring(s, sub, s_index + 1, sub_index + 1):
            return True
    
    # Try matching substring from next position in main string
    return contains_substring(s, sub, s_index + 1, 0)

# Test
print(contains_substring("hello world", "world"))  # True
print(contains_substring("hello world", "wor"))    # True
print(contains_substring("hello world", "xyz"))    # False
```

---

### Pattern 4: String to Integer Conversion

```python
def string_to_int(s, index=0):
    """
    Convert string to integer using recursion
    "123" â†’ 123
    
    Time: O(n), Space: O(n)
    """
    # Base case: empty or reached end
    if index >= len(s):
        return 0
    
    # Get integer value of rest of string
    rest_value = string_to_int(s, index + 1)
    
    # Calculate power of 10 for current position
    power = len(s) - index - 1
    
    # Current digit value + rest value
    current_digit = int(s[index])
    return current_digit * (10 ** power) + rest_value

# Test
print(string_to_int("123"))   # 123
print(string_to_int("4567"))  # 4567
```

**Step-by-Step for "123":**
```
string_to_int("123", 0)
â”œâ”€ current = '1', power = 2
â””â”€ 1 * 100 + string_to_int("123", 1)
   â”œâ”€ current = '2', power = 1
   â””â”€ 100 + 2 * 10 + string_to_int("123", 2)
      â”œâ”€ current = '3', power = 0
      â””â”€ 100 + 20 + 3 * 1 + string_to_int("123", 3)
         â””â”€ 100 + 20 + 3 + 0 = 123
```

#### Cleaner Version (Building from Right)

```python
def string_to_int_clean(s, index=None):
    """Build integer from right to left"""
    if index is None:
        index = len(s) - 1
    
    # Base case
    if index < 0:
        return 0
    
    # Current digit + 10 * rest
    return int(s[index]) + 10 * string_to_int_clean(s, index - 1)

# Test
print(string_to_int_clean("123"))  # 123
```

---

## 4.3 Advanced String Problems

### Pattern 1: All Subsequences of a String

**Key Concept:** Subsequence maintains order but can skip characters.
For string "abc": "", "a", "b", "c", "ab", "ac", "bc", "abc"

```python
def print_subsequences(s, current="", index=0):
    """
    Print all subsequences of string
    Pick / Not-Pick pattern
    
    Time: O(2^n), Space: O(n) - recursion depth
    Total subsequences: 2^n
    """
    # Base case: processed all characters
    if index >= len(s):
        print(f"'{current}'")
        return
    
    # Not pick: don't include current character
    print_subsequences(s, current, index + 1)
    
    # Pick: include current character
    print_subsequences(s, current + s[index], index + 1)

# Test
print("Subsequences of 'abc':")
print_subsequences("abc")
```

**Output:**
```
Subsequences of 'abc':
''
'c'
'b'
'bc'
'a'
'ac'
'ab'
'abc'
```

**Recursion Tree:**
```
                        ("", 0)
                      /          \
               ("", 1)            ("a", 1)
              /        \          /        \
         ("", 2)    ("b", 2)  ("a", 2)  ("ab", 2)
         /    \      /    \    /    \     /     \
     ""   "c"  "b"  "bc" "a" "ac" "ab"  "abc"
```

#### Return as List

```python
def get_subsequences(s, index=0):
    """
    Return all subsequences as a list
    """
    # Base case
    if index >= len(s):
        return [""]
    
    # Get subsequences of rest
    rest_subsequences = get_subsequences(s, index + 1)
    
    # Current character
    current_char = s[index]
    
    # Add current character to all subsequences from rest
    with_current = [current_char + sub for sub in rest_subsequences]
    
    # Return both: without current + with current
    return rest_subsequences + with_current

# Test
result = get_subsequences("abc")
print(f"Total: {len(result)}")
print(sorted(result))
```

**Output:**
```
Total: 8
['', 'a', 'ab', 'abc', 'ac', 'b', 'bc', 'c']
```

---

### Pattern 2: All Permutations of a String

**Key Concept:** Permutation changes order. "abc" â†’ "abc", "acb", "bac", "bca", "cab", "cba"

#### Approach 1: Fix First, Permute Rest

```python
def permutations(s, current="", remaining=None):
    """
    Generate all permutations of string
    
    Time: O(n! * n), Space: O(n)
    Total permutations: n!
    """
    if remaining is None:
        remaining = s
    
    # Base case: no more characters to add
    if len(remaining) == 0:
        print(current)
        return
    
    # Try each character in remaining as next character
    for i in range(len(remaining)):
        # Pick character at index i
        next_char = remaining[i]
        # Rest of string (excluding picked character)
        new_remaining = remaining[:i] + remaining[i+1:]
        # Recurse
        permutations(s, current + next_char, new_remaining)

# Test
print("Permutations of 'abc':")
permutations("abc")
```

**Output:**
```
Permutations of 'abc':
abc
acb
bac
bca
cab
cba
```

**Recursion Tree (Partial):**
```
                    ("", "abc")
            /           |           \
    ("a", "bc")    ("b", "ac")    ("c", "ab")
      /    \         /    \          /    \
("ab","c")("ac","b")("ba","c")("bc","a")("ca","b")("cb","a")
    |       |        |       |        |       |
  "abc"   "acb"    "bac"   "bca"    "cab"   "cba"
```

#### Approach 2: Swap Method

```python
def permutations_swap(s, left=0):
    """
    Generate permutations using swap method
    Swap each character with all positions after it
    """
    # Convert to list for swapping
    s_list = list(s) if isinstance(s, str) else s
    
    # Base case: reached end
    if left >= len(s_list):
        print(''.join(s_list))
        return
    
    # Try swapping with each position from left to end
    for i in range(left, len(s_list)):
        # Swap
        s_list[left], s_list[i] = s_list[i], s_list[left]
        
        # Recurse
        permutations_swap(s_list, left + 1)
        
        # Backtrack (undo swap)
        s_list[left], s_list[i] = s_list[i], s_list[left]

# Test
print("Permutations of 'abc':")
permutations_swap("abc")
```

#### Return as List

```python
def get_permutations(s):
    """Return all permutations as a list"""
    # Base case
    if len(s) <= 1:
        return [s]
    
    result = []
    
    # Fix each character and permute rest
    for i in range(len(s)):
        # Current character
        char = s[i]
        # Remaining characters
        remaining = s[:i] + s[i+1:]
        
        # Get permutations of remaining
        for perm in get_permutations(remaining):
            result.append(char + perm)
    
    return result

# Test
result = get_permutations("abc")
print(f"Total: {len(result)}")
print(sorted(result))
```

**Output:**
```
Total: 6
['abc', 'acb', 'bac', 'bca', 'cab', 'cba']
```

---

### Pattern 3: Print All Substrings

**Key Concept:** Substring must be contiguous.
For "abc": "a", "ab", "abc", "b", "bc", "c"

```python
def print_substrings(s, start=0, end=1):
    """
    Print all substrings of string
    
    Time: O(nÂ²), Space: O(n)
    Total substrings: n(n+1)/2
    """
    # Base case: processed all start positions
    if start >= len(s):
        return
    
    # Base case: end exceeds string length
    if end > len(s):
        # Move to next start position
        print_substrings(s, start + 1, start + 2)
        return
    
    # Print current substring
    print(s[start:end])
    
    # Extend end
    print_substrings(s, start, end + 1)

# Test
print("Substrings of 'abc':")
print_substrings("abc")
```

**Output:**
```
Substrings of 'abc':
a
ab
abc
b
bc
c
```

#### Alternative: Generate All at Once

```python
def get_all_substrings(s, start=0):
    """Get all substrings starting from start index"""
    # Base case
    if start >= len(s):
        return []
    
    # Generate all substrings starting at current position
    current_substrings = []
    for end in range(start + 1, len(s) + 1):
        current_substrings.append(s[start:end])
    
    # Get substrings from next positions
    rest_substrings = get_all_substrings(s, start + 1)
    
    return current_substrings + rest_substrings

# Test
result = get_all_substrings("abc")
print(f"Total: {len(result)}")
print(result)
```

---

### Pattern 4: Longest Palindromic Substring (Recursive)

```python
def is_palindrome_range(s, left, right):
    """Check if substring s[left:right+1] is palindrome"""
    if left >= right:
        return True
    if s[left] != s[right]:
        return False
    return is_palindrome_range(s, left + 1, right - 1)

def longest_palindrome_substring(s, start=0, end=None):
    """
    Find longest palindromic substring
    
    Time: O(nÂ³), Space: O(n)
    (This is not optimal, just for learning recursion)
    """
    if end is None:
        end = len(s) - 1
    
    # Base case: single character
    if start > end:
        return ""
    
    # Check if entire substring is palindrome
    if is_palindrome_range(s, start, end):
        return s[start:end+1]
    
    # Try smaller substrings
    # Remove from end
    option1 = longest_palindrome_substring(s, start, end - 1)
    # Remove from start
    option2 = longest_palindrome_substring(s, start + 1, end)
    
    # Return longer one
    return option1 if len(option1) >= len(option2) else option2

# Test
print(longest_palindrome_substring("babad"))    # "bab" or "aba"
print(longest_palindrome_substring("cbbd"))     # "bb"
```

---

## Key Takeaways from Chapter 4

### 1. String Recursion Patterns

| Pattern | Key Technique | Complexity |
|---------|---------------|------------|
| **Traversal** | Index parameter | O(n) |
| **Palindrome** | Two pointers | O(n) |
| **Manipulation** | Build during return | O(n) |
| **Subsequences** | Pick/Not-pick | O(2^n) |
| **Permutations** | Fix one, permute rest | O(n!) |
| **Substrings** | Nested loops or recursion | O(nÂ²) |

### 2. Important Distinctions

```
Subsequence: Can skip characters, maintains order
"abc" â†’ "", "a", "b", "c", "ab", "ac", "bc", "abc" (2^n)

Substring: Must be contiguous
"abc" â†’ "a", "ab", "abc", "b", "bc", "c" (n(n+1)/2)

Permutation: All arrangements, different order
"abc" â†’ "abc", "acb", "bac", "bca", "cab", "cba" (n!)
```

### 3. Common Techniques

âœ… **Forward Processing:** Print/process before recursion
```python
def forward(s, i):
    print(s[i])  # Process first
    forward(s, i+1)  # Then recurse
```

âœ… **Backward Processing:** Process during backtracking
```python
def backward(s, i):
    backward(s, i+1)  # Recurse first
    print(s[i])  # Process during return
```

âœ… **Two Pointers:** For symmetry problems
```python
def two_pointer(s, left, right):
    if left >= right: return
    # Process from both ends
    two_pointer(s, left+1, right-1)
```

### 4. Complexity Summary

- **Linear operations:** O(n) time, O(n) space
- **Subsequences:** O(2^n) time, O(n) space
- **Permutations:** O(n!) time, O(n) space
- **Substrings:** O(nÂ²) time, O(n) space

---

## Practice Problems

### Easy
1. Count uppercase letters
2. Convert string to uppercase/lowercase
3. Remove spaces from string
4. Check if two strings are anagrams
5. Find first non-repeating character

### Medium
6. Generate all strings of length N with 'a' and 'b'
7. Print all palindromic substrings
8. Longest common prefix of strings
9. String compression ("aaabb" â†’ "a3b2")
10. Decode string ("3[a2[c]]" â†’ "accaccacc")

### Hard
11. Edit distance (minimum operations to convert s1 to s2)
12. Wildcard pattern matching
13. Word break problem
14. Palindrome partitioning (all ways)
15. Shortest palindrome (add minimum chars to make palindrome)

### Challenge
16. Generate all valid parentheses combinations
17. Letter combinations of phone number
18. Regular expression matching
19. Scrambled string (check if s2 is scrambled version of s1)
20. Distinct subsequences (count distinct subsequences of t in s)

---

## Common Mistakes to Avoid

âŒ **String Concatenation in Loop:** Creates many objects
```python
# Bad
result = ""
for char in s:
    result += char  # O(nÂ²) time
```

âœ… **Better:** Build during recursion return
```python
# Good
return char + recursive_call()  # Natural with recursion
```

âŒ **Not Handling Empty Strings**
```python
# Always check
if len(s) == 0:
    return base_value
```

âŒ **Forgetting to Backtrack in Permutations**
```python
# Must undo changes after exploring
swap(i, j)
recurse()
swap(i, j)  # Backtrack!
```

---

## Summary of Key Patterns

```python
# 1. Linear Processing
def process_linear(s, i=0):
    if i >= len(s): return
    process(s[i])
    process_linear(s, i+1)

# 2. Two Pointer
def two_pointer(s, l=0, r=None):
    if r is None: r = len(s)-1
    if l >= r: return
    process(s[l], s[r])
    two_pointer(s, l+1, r-1)

# 3. Subsequence (Pick/Not-Pick)
def subsequence(s, i=0, current=""):
    if i >= len(s):
        print(current)
        return
    subsequence(s, i+1, current)  # Not pick
    subsequence(s, i+1, current+s[i])  # Pick

# 4. Permutation (Fix and Permute)
def permutation(s, i=0):
    if i >= len(s):
        print(s)
        return
    for j in range(i, len(s)):
        swap(i, j)
        permutation(s, i+1)
        swap(i, j)  # Backtrack
```

Master these patterns, and string recursion becomes intuitive! ðŸš€
