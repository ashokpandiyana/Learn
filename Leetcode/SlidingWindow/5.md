# Chapter 5: Counting Windows Pattern

## 5.1 Introduction: The Counting Problem

### The Challenge

Many problems ask you to **count** subarrays/substrings that satisfy a condition, rather than finding the longest/shortest one.

```
COUNTING vs OPTIMIZATION:
════════════════════════════════════════════════════════════════

OPTIMIZATION (Previous chapters):
─────────────────────────────────
"Find the LONGEST substring with at most K distinct characters"
→ Return a single value (the length)

COUNTING (This chapter):
────────────────────────
"COUNT all substrings with exactly K distinct characters"
→ Return total number of valid subarrays

The challenge: There could be O(n²) subarrays!
How do we count them in O(n) time?
```

### Key Insight: Count at Each Position

```
┌─────────────────────────────────────────────────────────────┐
│                    THE COUNTING INSIGHT                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  At each position 'right', count subarrays ENDING at right  │
│                                                             │
│  Array:    [a] [b] [c] [d] [e]                               │
│                         ↑                                   │
│                       right=3                               │
│             ↑                                               │
│            left=1                                           │
│                                                             │
│  Valid window: [b, c, d]                                    │
│                                                             │
│  Subarrays ending at right=3:                               │
│    • [d]        (from index 3 to 3)                         │
│    • [c, d]     (from index 2 to 3)                         │
│    • [b, c, d]  (from index 1 to 3)                         │
│                                                             │
│  Count = right - left + 1 = 3 - 1 + 1 = 3                   │
│                                                             │
│  ★ This formula counts ALL valid subarrays ending at right! │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 5.2 The "At Most K" Pattern

### Core Concept

**"At Most K"** means subarrays with 0, 1, 2, ..., up to K of something (distinct elements, zeros, etc.)

```
"AT MOST K" INCLUDES:
════════════════════════════════════════════════════════════════

If K = 3, "at most K distinct" includes:
  • 0 distinct: []  (empty, usually not counted)
  • 1 distinct: [a], [a,a], [a,a,a], ...
  • 2 distinct: [a,b], [a,b,a], [a,b,b,a], ...
  • 3 distinct: [a,b,c], [a,b,c,a], ...

All of these are valid under "at most 3 distinct"
```

### Template: At Most K Distinct Elements

```python
from collections import defaultdict

def at_most_k_distinct(nums, k):
    """
    Count subarrays with AT MOST K distinct elements.
    
    Key insight: For each valid window [left, right],
    ALL subarrays ending at 'right' are valid.
    Count = right - left + 1
    
    Time: O(n)
    Space: O(k)
    """
    freq = defaultdict(int)
    left = 0
    count = 0
    
    for right in range(len(nums)):
        # Add element at right
        freq[nums[right]] += 1
        
        # Shrink while we have more than k distinct
        while len(freq) > k:
            freq[nums[left]] -= 1
            if freq[nums[left]] == 0:
                del freq[nums[left]]
            left += 1
        
        # Count all subarrays ending at 'right'
        # These are: [left,right], [left+1,right], ..., [right,right]
        count += right - left + 1
    
    return count
```

### Visual Walkthrough: At Most 2 Distinct

```
nums = [1, 2, 1, 2, 3], k = 2

═══════════════════════════════════════════════════════════════
right=0: num=1
─────────────────────────────────────────────────────────────
  [1]  2   1   2   3
   ↑
  left=0, right=0
  
  freq = {1: 1}, distinct = 1 ≤ 2 ✓
  
  Subarrays ending at right=0:
    [1]                          ← count: 1
  
  count += 0 - 0 + 1 = 1
  Total count = 1

═══════════════════════════════════════════════════════════════
right=1: num=2
─────────────────────────────────────────────────────────────
  [1   2]  1   2   3
       ↑
  left=0, right=1
  
  freq = {1: 1, 2: 1}, distinct = 2 ≤ 2 ✓
  
  Subarrays ending at right=1:
    [2]                          ← from index 1
    [1, 2]                       ← from index 0
                                    count: 2
  
  count += 1 - 0 + 1 = 2
  Total count = 1 + 2 = 3

═══════════════════════════════════════════════════════════════
right=2: num=1
─────────────────────────────────────────────────────────────
  [1   2   1]  2   3
           ↑
  left=0, right=2
  
  freq = {1: 2, 2: 1}, distinct = 2 ≤ 2 ✓
  
  Subarrays ending at right=2:
    [1]                          ← from index 2
    [2, 1]                       ← from index 1
    [1, 2, 1]                    ← from index 0
                                    count: 3
  
  count += 2 - 0 + 1 = 3
  Total count = 3 + 3 = 6

═══════════════════════════════════════════════════════════════
right=3: num=2
─────────────────────────────────────────────────────────────
  [1   2   1   2]  3
               ↑
  left=0, right=3
  
  freq = {1: 2, 2: 2}, distinct = 2 ≤ 2 ✓
  
  Subarrays ending at right=3:
    [2]                          ← from index 3
    [1, 2]                       ← from index 2
    [2, 1, 2]                    ← from index 1
    [1, 2, 1, 2]                 ← from index 0
                                    count: 4
  
  count += 3 - 0 + 1 = 4
  Total count = 6 + 4 = 10

═══════════════════════════════════════════════════════════════
right=4: num=3
─────────────────────────────────────────────────────────────
  [1   2   1   2   3]
                   ↑
  left=0, right=4
  
  freq = {1: 2, 2: 2, 3: 1}, distinct = 3 > 2 ✗
  
  CONTRACT:
    Remove 1: freq = {1: 1, 2: 2, 3: 1}, left=1, distinct=3 > 2
    Remove 2: freq = {1: 1, 2: 1, 3: 1}, left=2, distinct=3 > 2
    Remove 1: freq = {2: 1, 3: 1}, left=3, distinct=2 ≤ 2 ✓
  
  Window is now [2, 3] (indices 3-4)
  
  Subarrays ending at right=4:
    [3]                          ← from index 4
    [2, 3]                       ← from index 3
                                    count: 2
  
  count += 4 - 3 + 1 = 2
  Total count = 10 + 2 = 12

═══════════════════════════════════════════════════════════════
FINAL: 12 subarrays with at most 2 distinct elements
```

---

## 5.3 The "Exactly K" Pattern (⭐ CRITICAL)

### The Brilliant Insight

**"Exactly K"** problems seem harder, but they can be solved using **"At Most K"**!

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│    ★ EXACTLY K = AT_MOST(K) - AT_MOST(K-1) ★                │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Why does this work?                                        │
│                                                             │
│  AT_MOST(K) counts subarrays with:                          │
│    0, 1, 2, 3, ..., K-1, K distinct elements               │
│                                                             │
│  AT_MOST(K-1) counts subarrays with:                        │
│    0, 1, 2, 3, ..., K-1 distinct elements                  │
│                                                             │
│  Subtracting removes everything except EXACTLY K:           │
│    (0,1,2,...,K-1,K) - (0,1,2,...,K-1) = K only            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Visual Proof

```
EXACTLY K = AT_MOST(K) - AT_MOST(K-1)
════════════════════════════════════════════════════════════════

Example: K = 2

AT_MOST(2):                    AT_MOST(1):
┌────────────────────┐         ┌────────────────────┐
│ 0 distinct         │         │ 0 distinct         │
│ 1 distinct         │         │ 1 distinct         │
│ 2 distinct ←       │         │                    │
└────────────────────┘         └────────────────────┘

         AT_MOST(2)        -        AT_MOST(1)
   ┌──────────────────┐       ┌──────────────────┐
   │  ░░░░░░░░░░░░░░  │       │  ░░░░░░░░░░░░░░  │
   │  ░░ 0 distinct ░░│   -   │  ░░ 0 distinct ░░│
   │  ░░░░░░░░░░░░░░  │       │  ░░░░░░░░░░░░░░  │
   │  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓  │       │  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓  │
   │  ▓▓ 1 distinct ▓▓│   -   │  ▓▓ 1 distinct ▓▓│
   │  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓  │       │  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓  │
   │  ████████████████│       │                  │
   │  ██ 2 distinct ██│   -   │    (nothing)     │
   │  ████████████████│       │                  │
   └──────────────────┘       └──────────────────┘
   
         =  EXACTLY 2 DISTINCT  
   ┌──────────────────┐
   │  ████████████████│
   │  ██ 2 distinct ██│
   │  ████████████████│
   └──────────────────┘
```

### Implementation

```python
from collections import defaultdict

def exactly_k_distinct(nums, k):
    """
    Count subarrays with EXACTLY K distinct elements.
    
    LeetCode 992: Subarrays with K Different Integers
    
    Time: O(n) - two passes of at_most
    Space: O(k)
    """
    
    def at_most_k(arr, k):
        """Helper: count subarrays with at most k distinct"""
        if k < 0:
            return 0
        
        freq = defaultdict(int)
        left = 0
        count = 0
        
        for right in range(len(arr)):
            freq[arr[right]] += 1
            
            while len(freq) > k:
                freq[arr[left]] -= 1
                if freq[arr[left]] == 0:
                    del freq[arr[left]]
                left += 1
            
            count += right - left + 1
        
        return count
    
    # The magic formula!
    return at_most_k(nums, k) - at_most_k(nums, k - 1)
```

### Complete Example: Subarrays with K Different Integers

```
nums = [1, 2, 1, 2, 3], k = 2

═══════════════════════════════════════════════════════════════
Step 1: Calculate at_most(2)
─────────────────────────────────────────────────────────────

(From previous example)
at_most(2) = 12

═══════════════════════════════════════════════════════════════
Step 2: Calculate at_most(1)
─────────────────────────────────────────────────────────────

right=0: [1], distinct=1 ≤ 1 ✓, count += 1       Total: 1
right=1: [1,2], distinct=2 > 1, contract
         [2], distinct=1 ≤ 1 ✓, count += 1       Total: 2
right=2: [2,1], distinct=2 > 1, contract  
         [1], distinct=1 ≤ 1 ✓, count += 1       Total: 3
right=3: [1,2], distinct=2 > 1, contract
         [2], distinct=1 ≤ 1 ✓, count += 1       Total: 4
right=4: [2,3], distinct=2 > 1, contract
         [3], distinct=1 ≤ 1 ✓, count += 1       Total: 5

at_most(1) = 5

═══════════════════════════════════════════════════════════════
Step 3: Calculate exactly(2)
─────────────────────────────────────────────────────────────

exactly(2) = at_most(2) - at_most(1)
           = 12 - 5
           = 7

═══════════════════════════════════════════════════════════════
Verification - All subarrays with EXACTLY 2 distinct:
─────────────────────────────────────────────────────────────

[1,2]       ✓  (indices 0-1)
[2,1]       ✓  (indices 1-2)
[1,2,1]     ✓  (indices 0-2)
[1,2]       ✓  (indices 2-3)
[2,1,2]     ✓  (indices 1-3)
[1,2,1,2]   ✓  (indices 0-3)
[2,3]       ✓  (indices 3-4)

Total: 7 ✓
```

---

## 5.4 Variations of the Counting Pattern

### Variation 1: Count Subarrays with Sum Equals K

```python
def subarray_sum_equals_k(nums, k):
    """
    LeetCode 560: Subarray Sum Equals K
    
    NOTE: This uses PREFIX SUM, not sliding window!
    Why? Because elements can be negative, so window
    can't be simply expanded/contracted.
    
    But it's a counting pattern you should know.
    """
    prefix_sum = 0
    count = 0
    prefix_count = {0: 1}  # Empty prefix has sum 0
    
    for num in nums:
        prefix_sum += num
        
        # If prefix_sum - k exists, we found subarrays
        if prefix_sum - k in prefix_count:
            count += prefix_count[prefix_sum - k]
        
        # Record current prefix sum
        prefix_count[prefix_sum] = prefix_count.get(prefix_sum, 0) + 1
    
    return count
```

### Variation 2: Count Subarrays with Bounded Sum

```python
def count_subarrays_bounded_sum(nums, lower, upper):
    """
    Count subarrays with sum in range [lower, upper].
    
    Uses the "at most" pattern with sums!
    count(sum ≤ upper) - count(sum ≤ lower-1)
    
    NOTE: Only works for positive numbers!
    """
    
    def at_most_sum(arr, target):
        if target < 0:
            return 0
        
        left = 0
        current_sum = 0
        count = 0
        
        for right in range(len(arr)):
            current_sum += arr[right]
            
            while current_sum > target:
                current_sum -= arr[left]
                left += 1
            
            count += right - left + 1
        
        return count
    
    return at_most_sum(nums, upper) - at_most_sum(nums, lower - 1)
```

### Variation 3: Count Subarrays with Product Less Than K

```python
def num_subarray_product_less_than_k(nums, k):
    """
    LeetCode 713: Subarray Product Less Than K
    
    Count subarrays where product < k
    This is directly "at most" (product < k means at most k-1)
    """
    if k <= 1:
        return 0
    
    product = 1
    left = 0
    count = 0
    
    for right in range(len(nums)):
        product *= nums[right]
        
        while product >= k:
            product //= nums[left]
            left += 1
        
        count += right - left + 1
    
    return count
```

---

## 5.5 Advanced: Count Subarrays with Fixed Bounds

### Problem: LeetCode 2444

```python
def count_subarrays_with_fixed_bounds(nums, minK, maxK):
    """
    LeetCode 2444: Count Subarrays With Fixed Bounds
    
    Count subarrays where min = minK AND max = maxK
    
    This requires tracking positions, not just counts!
    """
    count = 0
    bad_idx = -1      # Last index of element outside [minK, maxK]
    min_idx = -1      # Last index where we saw minK
    max_idx = -1      # Last index where we saw maxK
    
    for i, num in enumerate(nums):
        # If num is outside valid range, reset
        if num < minK or num > maxK:
            bad_idx = i
        
        # Track positions of minK and maxK
        if num == minK:
            min_idx = i
        if num == maxK:
            max_idx = i
        
        # Valid subarrays end at i and start after bad_idx
        # but must include both minK and maxK
        # Start can be from (bad_idx + 1) to min(min_idx, max_idx)
        valid_start = min(min_idx, max_idx)
        
        if valid_start > bad_idx:
            count += valid_start - bad_idx
    
    return count
```

### Visual Explanation

```
nums = [1, 3, 5, 2, 7, 5], minK = 1, maxK = 5

═══════════════════════════════════════════════════════════════
i=0: num=1 (= minK)
─────────────────────────────────────────────────────────────
  [1]  3   5   2   7   5
   ↑
  
  bad_idx = -1 (1 is in range [1,5])
  min_idx = 0  (found minK at 0)
  max_idx = -1 (haven't seen maxK)
  
  valid_start = min(0, -1) = -1
  -1 > -1? No → count += 0
  
  count = 0

═══════════════════════════════════════════════════════════════
i=1: num=3
─────────────────────────────────────────────────────────────
   1  [3]  5   2   7   5
       ↑
  
  bad_idx = -1
  min_idx = 0
  max_idx = -1
  
  valid_start = min(0, -1) = -1
  count += 0
  
  count = 0

═══════════════════════════════════════════════════════════════
i=2: num=5 (= maxK)
─────────────────────────────────────────────────────────────
   1   3  [5]  2   7   5
           ↑
  
  bad_idx = -1
  min_idx = 0
  max_idx = 2  (found maxK!)
  
  valid_start = min(0, 2) = 0
  0 > -1? Yes! → count += 0 - (-1) = 1
  
  Valid subarray: [1, 3, 5] (must include both 1 and 5)
  
  count = 1

═══════════════════════════════════════════════════════════════
i=3: num=2
─────────────────────────────────────────────────────────────
   1   3   5  [2]  7   5
               ↑
  
  bad_idx = -1
  min_idx = 0
  max_idx = 2
  
  valid_start = min(0, 2) = 0
  count += 0 - (-1) = 1
  
  Valid subarrays ending at 3:
    [1, 3, 5, 2] - contains minK=1 and maxK=5 ✓
  
  count = 2

═══════════════════════════════════════════════════════════════
i=4: num=7 (> maxK, OUT OF RANGE!)
─────────────────────────────────────────────────────────────
   1   3   5   2  [7]  5
                   ↑
  
  bad_idx = 4  (7 is outside [1,5])
  min_idx = 0
  max_idx = 2
  
  valid_start = min(0, 2) = 0
  0 > 4? No → count += 0
  
  count = 2

═══════════════════════════════════════════════════════════════
i=5: num=5 (= maxK)
─────────────────────────────────────────────────────────────
   1   3   5   2   7  [5]
                       ↑
  
  bad_idx = 4
  min_idx = 0
  max_idx = 5
  
  valid_start = min(0, 5) = 0
  0 > 4? No → count += 0
  
  No valid subarrays (would need to cross the 7)
  
  count = 2

═══════════════════════════════════════════════════════════════
FINAL: 2
```

---

## 5.6 Common Mistakes

### Mistake 1: Forgetting k=0 or k-1 Edge Cases

```python
# ❌ WRONG
def exactly_k(nums, k):
    return at_most(nums, k) - at_most(nums, k - 1)
    # If k=0, at_most(k-1) = at_most(-1) might break!

# ✅ CORRECT
def at_most(nums, k):
    if k < 0:
        return 0  # Handle negative k
    # ... rest of implementation
```

### Mistake 2: Wrong Counting Formula

```python
# ❌ WRONG
count += right - left  # Missing +1!

# ✅ CORRECT
count += right - left + 1  # Counts [left,right], [left+1,right], ..., [right,right]
```

### Mistake 3: Using "Exactly K" Directly

```python
# ❌ WRONG - Trying to count "exactly K" directly is complex
while len(freq) != k:  # Hard to maintain exactly k!
    # ...

# ✅ CORRECT - Use the subtraction method
return at_most(k) - at_most(k - 1)
```

---

## 5.7 Chapter Summary

```
┌─────────────────────────────────────────────────────────────┐
│             COUNTING WINDOWS KEY POINTS                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ★ KEY FORMULA: Subarrays ending at 'right' = right-left+1  │
│                                                             │
│  ★ AT MOST K: Contract when count > k, add right-left+1     │
│                                                             │
│  ★ EXACTLY K = AT_MOST(K) - AT_MOST(K-1)                    │
│    This is the MOST IMPORTANT pattern for hard problems!    │
│                                                             │
│  ★ Handle edge case: at_most(negative) should return 0      │
│                                                             │
│  ★ Works for: distinct elements, sum bounds, products       │
│                                                             │
│  ★ For negative numbers in sum problems: use prefix sum     │
│    instead of sliding window                                │
│                                                             │
│  Time Complexity: O(n) for at_most, O(n) for exactly        │
│  Space Complexity: O(k) for hashmap                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 5.8 Practice Problems

| Problem | Pattern | Difficulty |
|---------|---------|------------|
| Subarrays with K Different Integers (LC 992) | Exactly K | Hard |
| Subarray Product Less Than K (LC 713) | At Most | Medium |
| Count Number of Nice Subarrays (LC 1248) | Exactly K | Medium |
| Binary Subarrays With Sum (LC 930) | Exactly K | Medium |
| Number of Substrings with Only 1s (LC 1513) | Counting | Medium |
| Count Subarrays With Fixed Bounds (LC 2444) | Position Tracking | Hard |
