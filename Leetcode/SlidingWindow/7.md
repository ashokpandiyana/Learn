# Chapter 7: Sliding Window with Binary Search

## 7.1 Introduction: Combining Two Powerful Techniques

### When to Combine Sliding Window + Binary Search

```
COMBINATION SCENARIOS:
════════════════════════════════════════════════════════════════

1. FINDING OPTIMAL WINDOW SIZE
   "What's the minimum window size where condition X is satisfied?"
   → Binary search on window size
   → Sliding window to check if size works

2. MONOTONIC PROPERTIES
   "Is there a window of size K satisfying property P?"
   → If "yes" for size K implies "yes" for size K+1 (or K-1)
   → Binary search is applicable!

3. THRESHOLD FINDING
   "Find minimum K such that all windows of size K satisfy..."
   → Binary search on K
   → O(n) check for each candidate K

4. COMPLEX CONSTRAINTS WITH SORTED DATA
   "Find window with specific sum using prefix sums"
   → Prefix sums create sorted structure
   → Binary search to find matching prefix
```

### Why This Combination Works

```
┌─────────────────────────────────────────────────────────────┐
│                 MONOTONICITY IS KEY                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Binary search requires MONOTONIC relationship:              │
│                                                             │
│  "If window of size K satisfies the condition,              │
│   then window of size K+1 also satisfies it"                │
│                                                             │
│  OR                                                         │
│                                                             │
│  "If window of size K doesn't satisfy the condition,        │
│   then window of size K-1 also doesn't satisfy it"          │
│                                                             │
│  This allows us to binary search on the window size!        │
│                                                             │
│  Time: O(n log n) instead of O(n²)                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 7.2 Pattern 1: Binary Search on Window Size

### Template

```python
def binary_search_window_size(arr, condition_param):
    """
    Find the minimum (or maximum) window size satisfying a condition.
    
    Time: O(n log n) - O(log n) binary search × O(n) check
    """
    
    def can_satisfy(window_size):
        """
        Check if ANY window of this size satisfies the condition.
        This is a standard fixed-size sliding window.
        Returns True/False.
        """
        # Implement fixed-size window check here
        pass
    
    # Binary search on window size
    left, right = 1, len(arr)
    result = -1  # or len(arr) + 1, depending on min/max
    
    while left <= right:
        mid = (left + right) // 2
        
        if can_satisfy(mid):
            result = mid
            right = mid - 1  # Looking for MINIMUM size
            # Use left = mid + 1 if looking for MAXIMUM size
        else:
            left = mid + 1  # Need larger window
            # Use right = mid - 1 if looking for maximum
    
    return result
```

### Example: Minimum Window Size with Sum ≥ Target

```python
def min_window_size_for_sum(arr, target):
    """
    Find minimum window size such that some window has sum ≥ target.
    
    Note: This specific problem is better solved with variable window,
    but this demonstrates the binary search pattern.
    
    Monotonic property: 
    If window of size K has sum ≥ target, K+1 also CAN (same window + 1 more)
    But this isn't guaranteed for ALL windows of size K+1.
    
    We check: "Does ANY window of size K satisfy?"
    If yes for size K, we might find smaller.
    If no for size K, we need larger.
    """
    
    def has_window_with_sum(size):
        """Check if any window of given size has sum ≥ target"""
        if size > len(arr):
            return False
        
        window_sum = sum(arr[:size])
        if window_sum >= target:
            return True
        
        for i in range(size, len(arr)):
            window_sum += arr[i] - arr[i - size]
            if window_sum >= target:
                return True
        
        return False
    
    left, right = 1, len(arr)
    result = -1
    
    while left <= right:
        mid = (left + right) // 2
        
        if has_window_with_sum(mid):
            result = mid
            right = mid - 1  # Try smaller
        else:
            left = mid + 1  # Need larger
    
    return result
```

### Visual: Binary Search Process

```
arr = [2, 3, 1, 2, 4, 3], target = 7

═══════════════════════════════════════════════════════════════
Binary search on window size: range [1, 6]
═══════════════════════════════════════════════════════════════

Iteration 1: mid = (1+6)/2 = 3
─────────────────────────────────────────────────────────────
Check windows of size 3:
  [2,3,1] = 6 < 7 ✗
  [3,1,2] = 6 < 7 ✗
  [1,2,4] = 7 ≥ 7 ✓  Found!

has_window_with_sum(3) = True
result = 3
Search smaller: right = 2

Iteration 2: mid = (1+2)/2 = 1
─────────────────────────────────────────────────────────────
Check windows of size 1:
  [2] = 2 < 7 ✗
  [3] = 3 < 7 ✗
  [1] = 1 < 7 ✗
  [2] = 2 < 7 ✗
  [4] = 4 < 7 ✗
  [3] = 3 < 7 ✗

has_window_with_sum(1) = False
Search larger: left = 2

Iteration 3: mid = (2+2)/2 = 2
─────────────────────────────────────────────────────────────
Check windows of size 2:
  [2,3] = 5 < 7 ✗
  [3,1] = 4 < 7 ✗
  [1,2] = 3 < 7 ✗
  [2,4] = 6 < 7 ✗
  [4,3] = 7 ≥ 7 ✓  Found!

has_window_with_sum(2) = True
result = 2
Search smaller: right = 1

Iteration 4: left=2 > right=1, EXIT
─────────────────────────────────────────────────────────────

FINAL: result = 2
Minimum window size = 2 (window [4,3] has sum 7 ≥ 7)
```

---

## 7.3 Pattern 2: Prefix Sum + Binary Search

### Core Concept

```
PREFIX SUM CREATES MONOTONIC STRUCTURE:
════════════════════════════════════════════════════════════════

For array with all POSITIVE numbers:
Prefix sum is STRICTLY INCREASING

arr:        [2,  3,  1,  4,  2]
prefix:  [0, 2,  5,  6, 10, 12]
              ↑   ↑   ↑   ↑   ↑
          Strictly increasing!

This allows binary search to find:
"First prefix sum ≥ current_prefix - target"
which gives us "subarray sum ≥ target"
```

### Example: Shortest Subarray with Sum at Least K (Positive Numbers)

```python
import bisect

def shortest_subarray_positive(nums, k):
    """
    Find shortest subarray with sum ≥ k.
    ASSUMES ALL NUMBERS ARE POSITIVE.
    
    For each ending position, binary search for the rightmost
    starting position where sum ≥ k.
    
    Time: O(n log n)
    """
    n = len(nums)
    
    # Build prefix sum
    prefix = [0] * (n + 1)
    for i in range(n):
        prefix[i + 1] = prefix[i] + nums[i]
    
    # prefix is sorted (all positive nums)
    # For subarray [i, j]: sum = prefix[j+1] - prefix[i]
    # We want: prefix[j+1] - prefix[i] >= k
    # i.e., prefix[i] <= prefix[j+1] - k
    
    min_len = float('inf')
    
    for j in range(n):
        target = prefix[j + 1] - k
        # Find rightmost i where prefix[i] <= target
        # Using bisect_right - 1
        i = bisect.bisect_right(prefix, target, 0, j + 1) - 1
        
        if i >= 0:  # Found valid starting point
            min_len = min(min_len, j - i + 1)
    
    return min_len if min_len != float('inf') else -1
```

### Visual: Prefix Sum Binary Search

```
nums = [2, 3, 1, 2, 4, 3], k = 7

prefix = [0, 2, 5, 6, 8, 12, 15]
          0  1  2  3  4   5   6

═══════════════════════════════════════════════════════════════
j=0: prefix[1]=2, target=2-7=-5
─────────────────────────────────────────────────────────────
Find prefix[i] <= -5 in prefix[0:1] = [0]
No such prefix (0 > -5)
No valid subarray ending at j=0

═══════════════════════════════════════════════════════════════
j=1: prefix[2]=5, target=5-7=-2
─────────────────────────────────────────────────────────────
Find prefix[i] <= -2 in prefix[0:2] = [0, 2]
No such prefix
No valid subarray ending at j=1

═══════════════════════════════════════════════════════════════
j=2: prefix[3]=6, target=6-7=-1
─────────────────────────────────────────────────────────────
Find prefix[i] <= -1 in prefix[0:3] = [0, 2, 5]
No such prefix
No valid subarray ending at j=2

═══════════════════════════════════════════════════════════════
j=3: prefix[4]=8, target=8-7=1
─────────────────────────────────────────────────────────────
Find prefix[i] <= 1 in prefix[0:4] = [0, 2, 5, 6]
prefix[0]=0 ≤ 1 ✓
bisect_right([0,2,5,6], 1) = 1, i = 1-1 = 0

Subarray [0, 3]: sum = prefix[4] - prefix[0] = 8 - 0 = 8 ≥ 7 ✓
Length = 4
min_len = 4

═══════════════════════════════════════════════════════════════
j=4: prefix[5]=12, target=12-7=5
─────────────────────────────────────────────────────────────
Find prefix[i] <= 5 in prefix[0:5] = [0, 2, 5, 6, 8]
prefix[2]=5 ≤ 5 ✓
bisect_right returns 3, i = 3-1 = 2

Subarray [2, 4]: sum = prefix[5] - prefix[2] = 12 - 5 = 7 ≥ 7 ✓
Length = 3
min_len = min(4, 3) = 3

═══════════════════════════════════════════════════════════════
j=5: prefix[6]=15, target=15-7=8
─────────────────────────────────────────────────────────────
Find prefix[i] <= 8 in prefix[0:6] = [0, 2, 5, 6, 8, 12]
prefix[4]=8 ≤ 8 ✓
bisect_right returns 5, i = 5-1 = 4

Subarray [4, 5]: sum = prefix[6] - prefix[4] = 15 - 8 = 7 ≥ 7 ✓
Length = 2
min_len = min(3, 2) = 2

═══════════════════════════════════════════════════════════════
FINAL: min_len = 2 (subarray [4, 3] at indices 4-5)
```

---

## 7.4 Pattern 3: Monotonic Deque + Binary Search (Hard Problems)

### When Prefix Sum Isn't Sorted

When array contains **negative numbers**, prefix sum is NOT sorted. We need a **monotonic deque** to maintain a sorted structure for binary search.

### Example: Shortest Subarray with Sum at Least K (With Negatives)

```python
from collections import deque
import bisect

def shortest_subarray_with_negatives(nums, k):
    """
    LeetCode 862: Shortest Subarray with Sum at Least K
    
    Handles NEGATIVE numbers!
    
    Key insight:
    - Maintain a deque of (prefix_sum, index) pairs
    - Deque is sorted by prefix_sum (increasing)
    - For each new prefix, binary search for valid start
    - Remove prefixes that are dominated (larger prefix, smaller index)
    
    Time: O(n log n) with binary search, O(n) with two-pointer optimization
    """
    n = len(nums)
    
    # Build prefix sum
    prefix = [0]
    for num in nums:
        prefix.append(prefix[-1] + num)
    
    min_len = float('inf')
    dq = deque()  # Stores indices, prefix[index] in increasing order
    
    for i in range(n + 1):
        # For current prefix[i], find leftmost j where prefix[i] - prefix[j] >= k
        # i.e., prefix[j] <= prefix[i] - k
        
        # Optimization: Remove from front while sum >= k
        while dq and prefix[i] - prefix[dq[0]] >= k:
            min_len = min(min_len, i - dq[0])
            dq.popleft()  # This j won't be better for future i
        
        # Maintain increasing order: remove larger prefixes from back
        while dq and prefix[dq[-1]] >= prefix[i]:
            dq.pop()
        
        dq.append(i)
    
    return min_len if min_len != float('inf') else -1
```

### Why This Works

```
KEY INSIGHT: Monotonic Deque for Non-Sorted Prefix Sums
════════════════════════════════════════════════════════════════

Problem: prefix sums aren't sorted when negatives exist
Solution: Maintain ONLY "useful" prefix sums in sorted order

Which prefix sums are "useful"?
─────────────────────────────────────────────────────────────

Consider two indices i < j:
If prefix[i] >= prefix[j], then prefix[i] is NEVER useful!

Why? For any future index k:
  - If prefix[k] - prefix[i] >= K, then prefix[k] - prefix[j] >= K too
  - AND j > i means shorter subarray!

So we only keep prefixes in INCREASING order.

Example:
─────────────────────────────────────────────────────────────

prefix = [0, 5, 3, 8, 2, 10]
          0  1  2  3  4   5

Index 0: dq = [0]           prefix values: [0]
Index 1: dq = [0, 1]        prefix values: [0, 5]
Index 2: 3 < 5, pop 1       
         dq = [0, 2]        prefix values: [0, 3]
Index 3: dq = [0, 2, 3]     prefix values: [0, 3, 8]
Index 4: 2 < 8, pop 3
         2 < 3, pop 2       
         dq = [0, 4]        prefix values: [0, 2]
Index 5: dq = [0, 4, 5]     prefix values: [0, 2, 10]

Deque always has prefixes in INCREASING order!
```

---

## 7.5 Pattern 4: Binary Search Answer with Window Validation

### Example: Kth Smallest Prime Fraction

```python
import bisect

def kth_smallest_prime_fraction(arr, k):
    """
    LeetCode 786: K-th Smallest Prime Fraction
    
    Binary search on the ANSWER (the fraction value).
    For each candidate value, count how many fractions are smaller.
    
    This demonstrates binary search on a continuous value,
    validated by a window-like counting mechanism.
    """
    n = len(arr)
    
    def count_smaller(mid):
        """Count fractions smaller than mid, and track the largest one"""
        count = 0
        max_frac = 0
        max_pair = (0, 1)
        j = n - 1
        
        for i in range(n):
            # Find largest j where arr[i]/arr[j] < mid
            while j >= 0 and arr[i] / arr[j] >= mid:
                j -= 1
            
            # All fractions arr[i]/arr[k] for k > j are < mid
            count += n - 1 - j
            
            # Track largest fraction < mid
            if j >= 0 and j > i:
                frac = arr[i] / arr[j + 1] if j + 1 < n else 0
                if j + 1 < n and frac > max_frac:
                    max_frac = frac
                    max_pair = (arr[i], arr[j + 1])
        
        return count, max_pair
    
    # Binary search on fraction value
    left, right = 0, 1
    
    while right - left > 1e-9:
        mid = (left + right) / 2
        count, pair = count_smaller(mid)
        
        if count < k:
            left = mid
        else:
            right = mid
    
    # Find exact k-th fraction
    _, result = count_smaller(right)
    return list(result)
```

---

## 7.6 Pattern 5: Sliding Window Maximum/Minimum with Binary Search

### Using Sorted Containers

```python
from sortedcontainers import SortedList

def max_sliding_window_sorted(nums, k):
    """
    Alternative to monotonic deque: use sorted container.
    
    Time: O(n log k) - each insert/remove is O(log k)
    Space: O(k)
    
    Useful when you need MORE than just max/min
    (e.g., median, k-th element, etc.)
    """
    if not nums:
        return []
    
    window = SortedList()
    result = []
    
    for i in range(len(nums)):
        window.add(nums[i])
        
        if i >= k:
            window.remove(nums[i - k])
        
        if i >= k - 1:
            result.append(window[-1])  # Maximum
            # For minimum: window[0]
            # For median: window[len(window)//2]
    
    return result
```

### Finding K-th Element in Window

```python
from sortedcontainers import SortedList

def kth_element_in_windows(nums, k, kth):
    """
    Find k-th smallest element in each window of size k.
    
    Time: O(n log k)
    """
    window = SortedList()
    result = []
    
    for i in range(len(nums)):
        window.add(nums[i])
        
        if i >= k:
            window.remove(nums[i - k])
        
        if i >= k - 1:
            result.append(window[kth - 1])  # kth smallest (1-indexed)
    
    return result
```

---

## 7.7 Complexity Analysis

```
┌─────────────────────────────────────────────────────────────┐
│            TIME COMPLEXITY COMPARISON                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Pure Sliding Window:              O(n)                     │
│  Binary Search on Size:            O(n log n)               │
│  Prefix Sum + Binary Search:       O(n log n)               │
│  Sorted Container Window:          O(n log k)               │
│  Monotonic Deque (optimized):      O(n)                     │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  When to use which:                                         │
│                                                             │
│  O(n) possible → Use pure sliding window or monotonic deque │
│                                                             │
│  O(n log n) acceptable, need sorted → Binary search combo   │
│                                                             │
│  Need k-th element, median → Sorted container               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 7.8 Decision Framework

```
WHEN TO COMBINE BINARY SEARCH + SLIDING WINDOW:
════════════════════════════════════════════════════════════════

                    Is the property MONOTONIC
                    with respect to window size?
                              │
                ┌─────────────┴─────────────┐
                │                           │
               YES                          NO
                │                           │
                ▼                           ▼
    ┌───────────────────────┐    Can you transform to
    │ Binary Search on      │    monotonic structure?
    │ Window Size           │    (sorted container,
    │                       │     monotonic deque)
    │ Time: O(n log n)      │           │
    └───────────────────────┘    ┌──────┴──────┐
                                 │             │
                                YES           NO
                                 │             │
                                 ▼             ▼
                    ┌──────────────────┐  Consider
                    │ Use transformed  │  different
                    │ structure +      │  approach
                    │ binary search    │  (DP, etc.)
                    └──────────────────┘
```

---

## 7.9 Chapter Summary

```
┌─────────────────────────────────────────────────────────────┐
│        SLIDING WINDOW + BINARY SEARCH KEY POINTS             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. MONOTONICITY IS REQUIRED                                │
│     Binary search only works if property is monotonic       │
│     with respect to window size                             │
│                                                             │
│  2. BINARY SEARCH ON WINDOW SIZE                            │
│     • Check if ANY window of size K satisfies condition     │
│     • Search for optimal K                                  │
│     • Time: O(n log n)                                      │
│                                                             │
│  3. PREFIX SUM + BINARY SEARCH                              │
│     • Works when all numbers positive (sorted prefix)       │
│     • For negatives: use monotonic deque                    │
│                                                             │
│  4. SORTED CONTAINERS                                       │
│     • SortedList for k-th element, median queries           │
│     • Time: O(n log k)                                      │
│                                                             │
│  5. COMMON APPLICATIONS                                     │
│     • Minimum window size for condition                     │
│     • Shortest subarray with sum ≥ K                        │
│     • K-th smallest in windows                              │
│     • Median of sliding window                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 7.10 Practice Problems

| Problem | Technique | Difficulty |
|---------|-----------|------------|
| Shortest Subarray with Sum ≥ K (LC 862) | Monotonic Deque | Hard |
| Sliding Window Median (LC 480) | Two Heaps / SortedList | Hard |
| K-th Smallest Prime Fraction (LC 786) | Binary Search Answer | Medium |
| Maximum Average Subarray II (LC 644) | Binary Search on Answer | Hard |
| Minimum Number of Days to Make m Bouquets (LC 1482) | Binary Search + Window | Medium |
| Split Array Largest Sum (LC 410) | Binary Search + Greedy | Hard |
| Koko Eating Bananas (LC 875) | Binary Search + Validation | Medium |
