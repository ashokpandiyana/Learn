# Chapter 13: Problem-Solving Framework

## 13.1 The Complete Decision Process

### Master Flowchart

```
SLIDING WINDOW DECISION FLOWCHART:
════════════════════════════════════════════════════════════════

                    ┌─────────────────────┐
                    │ Is it about a       │
                    │ CONTIGUOUS sequence?│
                    └──────────┬──────────┘
                               │
                ┌──────────────┴──────────────┐
                │                             │
               YES                            NO
                │                             │
                ▼                             ▼
        ┌───────────────┐             Consider other
        │ Does it ask   │             techniques:
        │ for optimal   │             • Two Pointers
        │ or counting?  │             • Dynamic Programming
        └───────┬───────┘             • Binary Search
                │                     • Divide & Conquer
        ┌───────┴───────┐
        │               │
       YES              NO
        │               │
        ▼               ▼
    ┌─────────┐    Might not be
    │ SLIDING │    sliding window
    │ WINDOW! │
    └────┬────┘
         │
         ▼
    ┌─────────────────────────────────────┐
    │ Check for NEGATIVE numbers or       │
    │ EXACT sum requirement               │
    └─────────────────┬───────────────────┘
                      │
          ┌───────────┴───────────┐
          │                       │
         YES                      NO
          │                       │
          ▼                       ▼
    ┌──────────────┐      ┌──────────────┐
    │ PREFIX SUM   │      │ PURE SLIDING │
    │ + HashMap    │      │ WINDOW       │
    └──────────────┘      └──────┬───────┘
                                 │
              ┌──────────────────┴──────────────────┐
              │                                     │
        Fixed size K given?                   Size depends on
              │                               content/condition
              ▼                                     │
        ┌──────────────┐                           ▼
        │ FIXED-SIZE   │                    ┌──────────────┐
        │ WINDOW       │                    │ VARIABLE-SIZE│
        └──────────────┘                    │ WINDOW       │
                                            └──────┬───────┘
                                                   │
                                    ┌──────────────┴──────────────┐
                                    │                             │
                              Finding MINIMUM            Finding MAXIMUM
                              or COUNTING                    only
                                    │                             │
                                    ▼                             ▼
                              ┌──────────────┐           ┌──────────────┐
                              │ SHRINKABLE   │           │ Can use      │
                              │ (while loop) │           │ NON-SHRINK   │
                              └──────────────┘           │ (if okay)    │
                                                         └──────────────┘
```

---

## 13.2 Step-by-Step Problem Analysis

### The 6-Step Framework

```
STEP-BY-STEP ANALYSIS:
════════════════════════════════════════════════════════════════

STEP 1: IDENTIFY
────────────────
Ask: "Is this a sliding window problem?"

Look for keywords:
□ "subarray" or "substring"
□ "contiguous"
□ "consecutive"
□ "maximum/minimum length"
□ "longest/shortest"
□ "count subarrays/substrings"
□ "sum/product of contiguous elements"


STEP 2: CLASSIFY
────────────────
Determine the type:

□ Fixed-size window?
  → "of size k", "exactly k elements"
  
□ Variable-size window?
  → "at most", "at least", "containing"

□ Needs prefix sum?
  → Negative numbers, exact sum


STEP 3: DEFINE STATE
────────────────────
What information to track in window?

□ Sum → single variable
□ Frequency → HashMap
□ Distinct count → HashMap + counter
□ Max/Min → Monotonic deque
□ Existence → HashSet


STEP 4: IDENTIFY CONDITIONS
───────────────────────────
What makes window valid/invalid?

□ When to expand? (always move right)
□ When to contract? (condition violated)
□ When is window valid?


STEP 5: DETERMINE UPDATE TIMING
───────────────────────────────
When to update the result?

□ MINIMUM: Update INSIDE while loop (while valid)
□ MAXIMUM: Update OUTSIDE while loop (after fixing)
□ COUNTING: Add count inside or use "at most" pattern


STEP 6: HANDLE EDGE CASES
─────────────────────────
□ Empty array
□ k > array length
□ All elements same
□ No valid window exists
□ Single element
```

---

## 13.3 Pattern Recognition Guide

### Quick Pattern Matcher

```
PATTERN RECOGNITION CHEAT SHEET:
════════════════════════════════════════════════════════════════

IF YOU SEE...                    → USE THIS PATTERN
────────────────────────────────────────────────────────────────

"maximum sum subarray of size k" → Fixed window, track sum
"all anagrams of pattern"        → Fixed window, freq comparison
"sliding window maximum"         → Fixed window + monotonic deque

"longest substring without..."   → Variable window + Set/HashMap
"minimum window containing..."   → Variable window + have/need
"longest with at most k..."      → Variable window + freq count

"count subarrays with exactly k" → at_most(k) - at_most(k-1)
"number of subarrays where..."   → Counting pattern

"subarray sum equals k"          → Prefix sum + HashMap
"divisible by k"                 → Prefix sum + remainder map

"circular array"                 → Double array or complement

"find all/count" + "exactly k"   → Convert to "at most" pattern
```

### Problem Type → Template Mapping

```
┌────────────────────────────────────────────────────────────────┐
│                    TEMPLATE SELECTION                          │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  Problem Type              │ Template                          │
│  ─────────────────────────────────────────────────────────────│
│                                                                │
│  Max/Min in window         │ Monotonic Deque                   │
│  Sum of window             │ Running sum variable              │
│  Distinct elements         │ HashMap + counter                 │
│  Character matching        │ Two HashMaps (have/need)          │
│  At most K distinct        │ HashMap + len() check             │
│  Exactly K distinct        │ atMost(k) - atMost(k-1)           │
│  Contains all of pattern   │ Have/Need + formed counter        │
│  No duplicates             │ HashSet or HashMap                │
│  Product constraint        │ Running product (watch for 0)     │
│  Difference constraint     │ Two monotonic deques (max & min)  │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 13.4 Common Mistakes Checklist

### Pre-Coding Checklist

```
BEFORE YOU CODE - CHECK THESE:
════════════════════════════════════════════════════════════════

□ Confirmed it's a sliding window problem (contiguous!)
□ Identified fixed vs variable window
□ Chose correct state structure (sum? map? deque?)
□ Know when to expand vs contract
□ Know when to update result
□ Considered edge cases
```

### During-Coding Checklist

```
WHILE CODING - WATCH FOR:
════════════════════════════════════════════════════════════════

□ OFF-BY-ONE ERRORS
  • Window size = right - left + 1 (not right - left!)
  • Remove index: i - k (for fixed window)
  
□ HASHMAP CLEANUP
  • Delete key when count becomes 0
  freq[x] -= 1
  if freq[x] == 0:
      del freq[x]  # Don't forget!
      
□ RESULT UPDATE TIMING
  • Minimum: inside while loop
  • Maximum: outside while loop
  
□ LOOP BOUNDS
  • Fixed: for i in range(k, n)
  • Variable: for right in range(n)
  
□ INITIALIZATION
  • min result: float('inf')
  • max result: 0 or float('-inf')
  • prefix_count: {0: 1}
```

### Post-Coding Checklist

```
AFTER CODING - VERIFY:
════════════════════════════════════════════════════════════════

□ Test with small example (trace through)
□ Test edge cases:
  • Empty array → []
  • Single element → [5]
  • k larger than array → k=10, arr=[1,2,3]
  • No valid answer exists
  • All elements same → [3,3,3,3]
  
□ Check time complexity (should be O(n) usually)
□ Check space complexity
```

---

## 13.5 Interview Strategy

### The 4-Phase Approach

```
PHASE 1: UNDERSTAND (2-3 minutes)
════════════════════════════════════════════════════════════════

□ Repeat the problem in your own words
□ Ask clarifying questions:
  • "Can the array contain negative numbers?"
  • "What if no valid window exists?"
  • "Are elements integers only?"
  • "What's the range of input size?"
□ Work through the given example


PHASE 2: PLAN (3-5 minutes)
════════════════════════════════════════════════════════════════

□ Identify pattern: "This looks like a [pattern] problem"
□ State approach clearly:
  "I'll use a sliding window with a hashmap to track..."
□ Mention time/space complexity goal
□ Discuss edge cases briefly


PHASE 3: IMPLEMENT (10-15 minutes)
════════════════════════════════════════════════════════════════

□ Write clean, readable code
□ Use meaningful variable names
□ Add brief comments for key steps
□ Talk through your code as you write


PHASE 4: VERIFY (5 minutes)
════════════════════════════════════════════════════════════════

□ Trace through with given example
□ Test edge case mentally
□ Confirm complexity
□ Ask if interviewer wants optimizations
```

### What to Say During Interview

```
COMMUNICATION SCRIPTS:
════════════════════════════════════════════════════════════════

IDENTIFYING THE PATTERN:
"I notice this problem asks for [longest/shortest/count] of 
 [contiguous subarray/substring] with [condition]. This suggests
 a sliding window approach."

EXPLAINING YOUR APPROACH:
"I'll use a [fixed/variable] size window. I'll track [state] 
 using a [data structure]. The window expands by [how], and 
 contracts when [condition]."

DISCUSSING COMPLEXITY:
"Each element is added to the window once and removed at most 
 once, so the time complexity is O(n). Space is O(k) for the 
 hashmap where k is [what k represents]."

HANDLING EDGE CASES:
"Let me consider edge cases: if the array is empty, I'll return 
 [value]. If k is larger than the array, I'll [handle how]."
```

---

## 13.6 Debugging Guide

### When Your Solution Fails

```
DEBUGGING FLOWCHART:
════════════════════════════════════════════════════════════════

                    Solution giving wrong answer?
                              │
                              ▼
            ┌─────────────────────────────────┐
            │ Is the logic fundamentally      │
            │ correct? (trace small example)  │
            └────────────────┬────────────────┘
                             │
              ┌──────────────┴──────────────┐
              │                             │
             YES                            NO
              │                             │
              ▼                             ▼
        Check these:                   Re-think approach:
        ┌─────────────┐               ┌─────────────────┐
        │□ Off-by-one │               │ Wrong pattern?  │
        │□ Update     │               │ Missing case?   │
        │  timing     │               │ Wrong condition?│
        │□ HashMap    │               └─────────────────┘
        │  cleanup    │
        │□ Edge case  │
        │  not handled│
        └─────────────┘
```

### Common Bug Patterns

```
BUG: Getting length 0 or negative
─────────────────────────────────
Likely cause: Window size calculation
Fix: Ensure using (right - left + 1)


BUG: Missing some valid windows
─────────────────────────────────
Likely cause: Result update in wrong place
Fix: 
  • For minimum: update INSIDE while loop
  • For maximum: update OUTSIDE while loop


BUG: Count is higher than expected
─────────────────────────────────
Likely cause: HashMap not cleaned up
Fix: Delete keys when count becomes 0


BUG: Index out of bounds
─────────────────────────────────
Likely cause: Accessing arr[i-k] when i < k
Fix: Start loop from k, or add boundary check


BUG: Infinite loop
─────────────────────────────────
Likely cause: Left pointer not moving
Fix: Ensure left++ is inside while loop


BUG: Wrong answer for exact sum with negatives
─────────────────────────────────
Likely cause: Using sliding window instead of prefix sum
Fix: Use prefix sum + hashmap approach
```

---

## 13.7 Optimization Techniques

### When O(n) Isn't Fast Enough

```
OPTIMIZATION STRATEGIES:
════════════════════════════════════════════════════════════════

1. REDUCE CONSTANT FACTOR
   • Use array instead of HashMap for small charset
   • Use "matches" counter instead of map comparison
   • Avoid string slicing (track indices instead)

2. SPACE OPTIMIZATION
   • Use variables instead of deque when possible
   • Use non-shrinkable window (eliminates max tracking)
   • Process in place if allowed

3. EARLY TERMINATION
   • Return immediately when optimal found
   • Skip impossible windows
   • Break when no better solution possible

4. PREPROCESSING
   • Build frequency map of target once
   • Compute prefix sums once
   • Sort if it helps (usually for different technique)
```

### Code Optimization Examples

```python
# BEFORE: O(26) comparison each time
if s_count == p_count:
    result.append(i)

# AFTER: O(1) comparison using matches
if matches == 26:
    result.append(i)


# BEFORE: String slicing creates new string
result = s[left:right+1]

# AFTER: Track indices, slice only at end
result_left, result_right = left, right
# ... at the end:
return s[result_left:result_right+1]


# BEFORE: Multiple passes
max_val = max(window)
min_val = min(window)

# AFTER: Monotonic deques for O(1)
max_val = nums[max_deque[0]]
min_val = nums[min_deque[0]]
```

---

## 13.8 Practice Problem Walkthrough

### Example: Solve a Problem Step-by-Step

```
PROBLEM: Find the longest substring with at most 2 distinct 
         characters in "eceba"

═══════════════════════════════════════════════════════════════
STEP 1: IDENTIFY
═══════════════════════════════════════════════════════════════

Keywords: "longest", "substring", "at most 2 distinct"
→ This is a sliding window problem! ✓
→ Variable-size (finding longest)
→ "At most K" pattern


═══════════════════════════════════════════════════════════════
STEP 2: CLASSIFY
═══════════════════════════════════════════════════════════════

Type: Variable-size window
Goal: Find maximum length
Constraint: At most 2 distinct characters
→ Shrinkable window with HashMap for frequency


═══════════════════════════════════════════════════════════════
STEP 3: DEFINE STATE
═══════════════════════════════════════════════════════════════

Need to track:
• Current characters in window → HashMap {char: count}
• Number of distinct → len(HashMap)
• Current window boundaries → left, right


═══════════════════════════════════════════════════════════════
STEP 4: IDENTIFY CONDITIONS
═══════════════════════════════════════════════════════════════

Expand: Always (for loop with right)
Contract: When len(freq) > 2 (too many distinct)
Valid: When len(freq) <= 2


═══════════════════════════════════════════════════════════════
STEP 5: DETERMINE UPDATE TIMING
═══════════════════════════════════════════════════════════════

Finding MAXIMUM → Update AFTER while loop
(After window becomes valid again)


═══════════════════════════════════════════════════════════════
STEP 6: CODE
═══════════════════════════════════════════════════════════════

from collections import defaultdict

def longest_k_distinct(s, k=2):
    freq = defaultdict(int)
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        # Expand
        freq[s[right]] += 1
        
        # Contract while invalid
        while len(freq) > k:
            freq[s[left]] -= 1
            if freq[s[left]] == 0:
                del freq[s[left]]
            left += 1
        
        # Update (window is valid)
        max_length = max(max_length, right - left + 1)
    
    return max_length


═══════════════════════════════════════════════════════════════
STEP 7: VERIFY WITH EXAMPLE
═══════════════════════════════════════════════════════════════

s = "eceba", k = 2

right=0 'e': freq={'e':1}, valid, max=1
right=1 'c': freq={'e':1,'c':1}, valid, max=2
right=2 'e': freq={'e':2,'c':1}, valid, max=3
right=3 'b': freq={'e':2,'c':1,'b':1}, invalid!
  contract: remove 'e', freq={'e':1,'c':1,'b':1}, still invalid
  contract: remove 'c', freq={'e':1,'b':1}, valid
  max = max(3, 2) = 3
right=4 'a': freq={'e':1,'b':1,'a':1}, invalid!
  contract: remove 'e', freq={'b':1,'a':1}, valid
  max = max(3, 2) = 3

Answer: 3 ("ece") ✓
```

---

## 13.9 Chapter Summary

```
┌─────────────────────────────────────────────────────────────┐
│         PROBLEM-SOLVING FRAMEWORK KEY POINTS                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. THE 6-STEP PROCESS                                      │
│     Identify → Classify → Define State →                    │
│     Identify Conditions → Update Timing → Edge Cases        │
│                                                             │
│  2. PATTERN RECOGNITION                                     │
│     • Keywords: contiguous, subarray, longest, count        │
│     • Fixed vs Variable: "size k" vs "at most k"            │
│     • Prefix sum needed: negatives, exact sum               │
│                                                             │
│  3. COMMON MISTAKES                                         │
│     • Off-by-one: window size = right - left + 1            │
│     • HashMap cleanup: delete when count = 0                │
│     • Update timing: min=inside, max=outside while          │
│                                                             │
│  4. INTERVIEW STRATEGY                                      │
│     • Understand → Plan → Implement → Verify                │
│     • Communicate pattern recognition                       │
│     • Discuss complexity and edge cases                     │
│                                                             │
│  5. DEBUGGING                                               │
│     • Trace with small example                              │
│     • Check common bug patterns                             │
│     • Verify edge cases                                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```
