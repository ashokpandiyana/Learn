# Chapter 4: Window State Management

## 4.1 Introduction: What is Window State?

### The Concept

The **window state** is the data structure that tracks information about the current window's contents. As the window slides, we update this state incrementally rather than recalculating from scratch.

```
┌─────────────────────────────────────────────────────────────┐
│                    WINDOW STATE CONCEPT                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  The "state" answers: "What do I need to know about the     │
│  current window to solve this problem?"                     │
│                                                             │
│  Array: [ 3 | 1 | 4 | 1 | 5 | 9 | 2 | 6 ]                   │
│              └─────────────────┘                            │
│                   WINDOW                                    │
│                                                             │
│  Possible States:                                           │
│  ┌──────────────────┬────────────────────────────────┐      │
│  │ Problem Type     │ State to Track                 │      │
│  ├──────────────────┼────────────────────────────────┤      │
│  │ Sum              │ current_sum = 20               │      │
│  │ Distinct count   │ freq = {1:2, 4:1, 5:1, 9:1}    │      │
│  │ Max element      │ deque = [9, 5, 4, 1]           │      │
│  │ Has duplicates?  │ set = {1, 4, 5, 9}             │      │
│  └──────────────────┴────────────────────────────────┘      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Choosing the Right Data Structure

```
STATE SELECTION GUIDE:
════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────┐
│  What do you need to know?          →  Use this structure   │
├─────────────────────────────────────────────────────────────┤
│  Sum/Product of elements            →  Single variable      │
│  Count of specific element          →  Single variable      │
│  Frequency of each element          →  HashMap/Dictionary   │
│  Number of distinct elements        →  HashMap + counter    │
│  Max/Min in window (O(1) query)     →  Monotonic Deque      │
│  Element exists in window?          →  HashSet              │
│  First/Last occurrence              →  Deque of indices     │
│  Character matching (anagrams)      →  Two HashMaps         │
└─────────────────────────────────────────────────────────────┘
```

---

## 4.2 Using HashMap/Dictionary

### When to Use HashMap

HashMap is the **most versatile** state structure for sliding windows. Use it when you need to:
- Track frequency of elements
- Count distinct elements
- Match character patterns
- Check if window contains required elements

### Basic HashMap Operations in Window

```python
from collections import defaultdict

class WindowWithHashMap:
    """
    Template for using HashMap as window state.
    """
    
    def __init__(self):
        self.freq = defaultdict(int)
        self.distinct_count = 0
    
    def add(self, element):
        """Add element to window - O(1)"""
        if self.freq[element] == 0:
            self.distinct_count += 1  # New distinct element
        self.freq[element] += 1
    
    def remove(self, element):
        """Remove element from window - O(1)"""
        self.freq[element] -= 1
        if self.freq[element] == 0:
            self.distinct_count -= 1  # Lost a distinct element
            del self.freq[element]    # Clean up (important!)
    
    def get_distinct_count(self):
        """Get number of distinct elements - O(1)"""
        return self.distinct_count
    
    def get_frequency(self, element):
        """Get frequency of specific element - O(1)"""
        return self.freq[element]
```

### Visual: HashMap State Changes

```
String: "aababc", tracking character frequencies

Window slides through string:
═══════════════════════════════════════════════════════════════

Position 0-2: "aab"
┌─────────────────────────────────────────┐
│  a   a   b   a   b   c                  │
│  └───────┘                              │
│                                         │
│  freq = {'a': 2, 'b': 1}                │
│  distinct_count = 2                     │
└─────────────────────────────────────────┘

Position 1-3: "aba" (remove 'a' at 0, add 'a' at 3)
┌─────────────────────────────────────────┐
│  a   a   b   a   b   c                  │
│      └───────┘                          │
│                                         │
│  remove 'a': freq['a'] = 2-1 = 1        │
│  add 'a':    freq['a'] = 1+1 = 2        │
│                                         │
│  freq = {'a': 2, 'b': 1}                │
│  distinct_count = 2 (unchanged)         │
└─────────────────────────────────────────┘

Position 2-4: "bab" (remove 'a' at 1, add 'b' at 4)
┌─────────────────────────────────────────┐
│  a   a   b   a   b   c                  │
│          └───────┘                      │
│                                         │
│  remove 'a': freq['a'] = 2-1 = 1        │
│  add 'b':    freq['b'] = 1+1 = 2        │
│                                         │
│  freq = {'a': 1, 'b': 2}                │
│  distinct_count = 2                     │
└─────────────────────────────────────────┘

Position 3-5: "abc" (remove 'b' at 2, add 'c' at 5)
┌─────────────────────────────────────────┐
│  a   a   b   a   b   c                  │
│              └───────┘                  │
│                                         │
│  remove 'b': freq['b'] = 2-1 = 1        │
│  add 'c':    freq['c'] = 0+1 = 1        │
│              distinct_count++ → 3       │
│                                         │
│  freq = {'a': 1, 'b': 1, 'c': 1}        │
│  distinct_count = 3                     │
└─────────────────────────────────────────┘
```

### Complete Example: Longest Substring with K Distinct

```python
from collections import defaultdict

def longest_k_distinct(s, k):
    """
    Find longest substring with at most K distinct characters.
    
    Example: s = "eceba", k = 2
    Answer: 3 ("ece")
    """
    freq = defaultdict(int)
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        # ADD to window
        char = s[right]
        if freq[char] == 0:
            pass  # New distinct character entering
        freq[char] += 1
        
        # CONTRACT while too many distinct
        while len(freq) > k:
            left_char = s[left]
            freq[left_char] -= 1
            if freq[left_char] == 0:
                del freq[left_char]  # ⚠️ CRITICAL: Must delete!
            left += 1
        
        # UPDATE result
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

### ⚠️ Critical: HashMap Cleanup Pattern

```
THE CLEANUP PROBLEM:
════════════════════════════════════════════════════════════════

Why we MUST delete keys when count becomes 0:

WRONG (No cleanup):
─────────────────────────────────────────────────────────────
freq = {'a': 2, 'b': 1}
freq['a'] -= 1  → freq = {'a': 1, 'b': 1}
freq['a'] -= 1  → freq = {'a': 0, 'b': 1}  ← 'a' still exists!

len(freq) = 2  ← WRONG! Should be 1

CORRECT (With cleanup):
─────────────────────────────────────────────────────────────
freq = {'a': 2, 'b': 1}
freq['a'] -= 1  → freq = {'a': 1, 'b': 1}
freq['a'] -= 1  → freq = {'a': 0, 'b': 1}
del freq['a']   → freq = {'b': 1}  ← 'a' removed!

len(freq) = 1  ← CORRECT!

┌─────────────────────────────────────────────────────────────┐
│  ALWAYS use this pattern when removing:                     │
│                                                             │
│  freq[element] -= 1                                         │
│  if freq[element] == 0:                                     │
│      del freq[element]                                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 4.3 Using Monotonic Deque

### What is a Monotonic Deque?

A **Monotonic Deque** maintains elements in sorted order (either increasing or decreasing) to enable O(1) access to maximum or minimum values.

```
MONOTONIC DEQUE CONCEPT:
════════════════════════════════════════════════════════════════

DECREASING DEQUE (for Maximum queries):
─────────────────────────────────────────────────────────────
Elements are stored in decreasing order.
Front always contains the MAXIMUM.

    FRONT ────────────────────────────► BACK
    ┌─────┬─────┬─────┬─────┬─────┐
    │  9  │  7  │  5  │  3  │  2  │    9 > 7 > 5 > 3 > 2
    └─────┴─────┴─────┴─────┴─────┘
      ↑
    Maximum

When adding element 6:
- Remove all elements < 6 from back (2, 3, 5)
- Add 6 to back

    ┌─────┬─────┬─────┐
    │  9  │  7  │  6  │    Still decreasing!
    └─────┴─────┴─────┘


INCREASING DEQUE (for Minimum queries):
─────────────────────────────────────────────────────────────
Elements are stored in increasing order.
Front always contains the MINIMUM.

    FRONT ────────────────────────────► BACK
    ┌─────┬─────┬─────┬─────┬─────┐
    │  1  │  3  │  5  │  7  │  9  │    1 < 3 < 5 < 7 < 9
    └─────┴─────┴─────┴─────┴─────┘
      ↑
    Minimum
```

### Why Store Indices, Not Values?

```
┌─────────────────────────────────────────────────────────────┐
│  KEY INSIGHT: Store INDICES in deque, not values!           │
│                                                             │
│  Why? We need to know if an element is still in the window. │
│                                                             │
│  With indices:                                              │
│  - Can get value: arr[deque[0]]                             │
│  - Can check if in window: deque[0] >= left                 │
│                                                             │
│  With values only:                                          │
│  - Cannot determine position                                │
│  - Cannot know if element left the window                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Template: Sliding Window Maximum

```python
from collections import deque

def max_sliding_window(nums, k):
    """
    Find maximum in each window of size k.
    
    LeetCode 239: Sliding Window Maximum
    
    Example: nums = [1,3,-1,-3,5,3,6,7], k = 3
    Output: [3,3,5,5,6,7]
    
    Time: O(n) - each element added/removed from deque once
    Space: O(k) - deque stores at most k elements
    """
    if not nums:
        return []
    
    dq = deque()  # Store INDICES, maintain decreasing order of VALUES
    result = []
    
    for i in range(len(nums)):
        # 1. REMOVE elements outside window (from front)
        #    Window is [i-k+1, i], so indices <= i-k are outside
        while dq and dq[0] <= i - k:
            dq.popleft()
        
        # 2. MAINTAIN decreasing order (remove smaller from back)
        #    Remove elements smaller than current (they can never be max)
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        
        # 3. ADD current index
        dq.append(i)
        
        # 4. RECORD result (after first window is complete)
        if i >= k - 1:
            result.append(nums[dq[0]])  # Front has maximum
    
    return result
```

### Visual Walkthrough: Sliding Window Maximum

```
nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3

═══════════════════════════════════════════════════════════════
i=0: num=1
─────────────────────────────────────────────────────────────
  [1] 3  -1  -3   5   3   6   7
   ↑
   
  Deque empty, just add index 0
  dq = [0]  (values: [1])
  
  i < k-1, no result yet

═══════════════════════════════════════════════════════════════
i=1: num=3
─────────────────────────────────────────────────────────────
  [1   3] -1  -3   5   3   6   7
       ↑
   
  nums[dq[-1]]=1 < 3, pop from back
  dq = [] → add 1
  dq = [1]  (values: [3])
  
  i < k-1, no result yet

═══════════════════════════════════════════════════════════════
i=2: num=-1
─────────────────────────────────────────────────────────────
  [1   3  -1] -3   5   3   6   7
   └───────┘   First complete window!
   
  nums[dq[-1]]=3 > -1, keep it
  dq = [1, 2]  (values: [3, -1])
  
  i >= k-1, record result: nums[dq[0]] = nums[1] = 3
  result = [3]

═══════════════════════════════════════════════════════════════
i=3: num=-3
─────────────────────────────────────────────────────────────
      [3  -1  -3] 5   3   6   7
       └────────┘
   
  dq[0]=1 > i-k=0? Yes (1 > 0), front still in window
  nums[dq[-1]]=-1 > -3, keep it
  dq = [1, 2, 3]  (values: [3, -1, -3])
  
  result: nums[dq[0]] = 3
  result = [3, 3]

═══════════════════════════════════════════════════════════════
i=4: num=5
─────────────────────────────────────────────────────────────
          [-1  -3   5] 3   6   7
           └─────────┘
   
  dq[0]=1 <= i-k=1? Yes! Remove front (index 1 is outside)
  dq = [2, 3]
  
  Now maintain decreasing:
  nums[dq[-1]]=-3 < 5, pop → dq = [2]
  nums[dq[-1]]=-1 < 5, pop → dq = []
  Add 4: dq = [4]  (values: [5])
  
  result: nums[dq[0]] = 5
  result = [3, 3, 5]

═══════════════════════════════════════════════════════════════
i=5: num=3
─────────────────────────────────────────────────────────────
              [-3   5   3] 6   7
               └─────────┘
   
  dq[0]=4 > i-k=2, still in window
  nums[dq[-1]]=5 > 3, keep it
  dq = [4, 5]  (values: [5, 3])
  
  result: nums[dq[0]] = 5
  result = [3, 3, 5, 5]

═══════════════════════════════════════════════════════════════
i=6: num=6
─────────────────────────────────────────────────────────────
                  [5   3   6] 7
                   └─────────┘
   
  dq[0]=4 > i-k=3, still in window
  nums[dq[-1]]=3 < 6, pop → dq = [4]
  nums[dq[-1]]=5 < 6, pop → dq = []
  Add 6: dq = [6]  (values: [6])
  
  result: nums[dq[0]] = 6
  result = [3, 3, 5, 5, 6]

═══════════════════════════════════════════════════════════════
i=7: num=7
─────────────────────────────────────────────────────────────
                      [3   6   7]
                       └─────────┘
   
  dq[0]=6 > i-k=4, still in window
  nums[dq[-1]]=6 < 7, pop → dq = []
  Add 7: dq = [7]  (values: [7])
  
  result: nums[dq[0]] = 7
  result = [3, 3, 5, 5, 6, 7]

═══════════════════════════════════════════════════════════════
FINAL: [3, 3, 5, 5, 6, 7]
```

### Template: Sliding Window Minimum

```python
from collections import deque

def min_sliding_window(nums, k):
    """
    Find minimum in each window of size k.
    Only difference: maintain INCREASING order (pop larger elements)
    """
    dq = deque()  # Store indices, maintain INCREASING order
    result = []
    
    for i in range(len(nums)):
        # Remove outside window
        while dq and dq[0] <= i - k:
            dq.popleft()
        
        # Maintain INCREASING order (remove LARGER from back)
        while dq and nums[dq[-1]] > nums[i]:  # Changed: > instead of <
            dq.pop()
        
        dq.append(i)
        
        if i >= k - 1:
            result.append(nums[dq[0]])  # Front has minimum
    
    return result
```

### Deque Operations Summary

```
┌─────────────────────────────────────────────────────────────┐
│              MONOTONIC DEQUE OPERATIONS                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  FOR MAXIMUM (Decreasing Deque):                            │
│  ─────────────────────────────                              │
│  • Pop from BACK while nums[back] < current                 │
│  • Pop from FRONT if index outside window                   │
│  • Maximum is always at FRONT                               │
│                                                             │
│  FOR MINIMUM (Increasing Deque):                            │
│  ─────────────────────────────                              │
│  • Pop from BACK while nums[back] > current                 │
│  • Pop from FRONT if index outside window                   │
│  • Minimum is always at FRONT                               │
│                                                             │
│  Time: O(1) amortized per operation                         │
│  Space: O(k) for window of size k                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 4.4 Using HashSet

### When to Use Set

Use HashSet when you need:
- O(1) membership testing ("Is X in window?")
- Track unique elements (no frequency needed)
- Detect duplicates

### Example: Contains Duplicate II

```python
def contains_nearby_duplicate(nums, k):
    """
    LeetCode 219: Contains Duplicate II
    
    Check if there are two distinct indices i and j such that
    nums[i] == nums[j] and abs(i - j) <= k
    
    Example: nums = [1,2,3,1], k = 3 → True
             nums = [1,0,1,1], k = 1 → True
             nums = [1,2,3,1,2,3], k = 2 → False
    """
    window = set()
    
    for i in range(len(nums)):
        # Check if current element already in window
        if nums[i] in window:
            return True
        
        # Add current element to window
        window.add(nums[i])
        
        # Maintain window size of k
        if len(window) > k:
            window.remove(nums[i - k])
    
    return False
```

### Visual: Set-Based Window

```
nums = [1, 2, 3, 1], k = 3

═══════════════════════════════════════════════════════════════
i=0: num=1
─────────────────────────────────────────────────────────────
  [1]  2   3   1
   ↑
   
  1 in set? No
  Add 1: window = {1}
  Size = 1 ≤ k, no removal

═══════════════════════════════════════════════════════════════
i=1: num=2
─────────────────────────────────────────────────────────────
  [1   2]  3   1
       ↑
   
  2 in set? No
  Add 2: window = {1, 2}
  Size = 2 ≤ k, no removal

═══════════════════════════════════════════════════════════════
i=2: num=3
─────────────────────────────────────────────────────────────
  [1   2   3]  1
           ↑
   
  3 in set? No
  Add 3: window = {1, 2, 3}
  Size = 3 ≤ k, no removal

═══════════════════════════════════════════════════════════════
i=3: num=1
─────────────────────────────────────────────────────────────
  [1   2   3   1]
               ↑
   
  1 in set? YES! → Return True
  
  Found duplicate within k distance!
═══════════════════════════════════════════════════════════════
```

### Set vs HashMap: When to Use Which?

```
┌─────────────────────────────────────────────────────────────┐
│                    SET vs HASHMAP                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Use SET when:                                              │
│  ─────────────                                              │
│  • Only need to check existence                             │
│  • Don't need frequency counts                              │
│  • Simpler duplicate detection                              │
│                                                             │
│  Use HASHMAP when:                                          │
│  ────────────────                                           │
│  • Need to count occurrences                                │
│  • Need to track "how many" of each element                 │
│  • Checking "at most K distinct" (need len(map))            │
│  • Window can have duplicate elements                       │
│                                                             │
│  Example Decision:                                          │
│  • "Any duplicate in window?" → Set                         │
│  • "At most 2 of each element?" → HashMap                   │
│  • "Exactly 3 distinct elements?" → HashMap                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 4.5 Combined State: Multiple Data Structures

### When to Use Multiple Structures

Complex problems often require tracking multiple aspects of the window simultaneously.

### Example: Longest Subarray with Bounded Difference

```python
from collections import deque

def longest_subarray(nums, limit):
    """
    LeetCode 1438: Longest Continuous Subarray With 
    Absolute Diff Less Than or Equal to Limit
    
    Find longest subarray where max - min <= limit
    
    Need to track BOTH max AND min efficiently!
    Solution: Use TWO monotonic deques
    """
    max_dq = deque()  # Decreasing - front is max
    min_dq = deque()  # Increasing - front is min
    left = 0
    result = 0
    
    for right in range(len(nums)):
        # Maintain max deque (decreasing)
        while max_dq and nums[max_dq[-1]] < nums[right]:
            max_dq.pop()
        max_dq.append(right)
        
        # Maintain min deque (increasing)
        while min_dq and nums[min_dq[-1]] > nums[right]:
            min_dq.pop()
        min_dq.append(right)
        
        # Contract while difference exceeds limit
        while nums[max_dq[0]] - nums[min_dq[0]] > limit:
            left += 1
            # Remove if front is outside window
            if max_dq[0] < left:
                max_dq.popleft()
            if min_dq[0] < left:
                min_dq.popleft()
        
        result = max(result, right - left + 1)
    
    return result
```

### Visual: Dual Deque State

```
nums = [8, 2, 4, 7], limit = 4

═══════════════════════════════════════════════════════════════
i=0: num=8
─────────────────────────────────────────────────────────────
  [8]  2   4   7
   ↑
  
  max_dq = [0]  → max = 8
  min_dq = [0]  → min = 8
  
  diff = 8 - 8 = 0 ≤ 4 ✓
  result = 1

═══════════════════════════════════════════════════════════════
i=1: num=2
─────────────────────────────────────────────────────────────
  [8   2]  4   7
       ↑
  
  max_dq: 8 > 2, keep → [0, 1]  → max = 8
  min_dq: 8 > 2, pop 0, add 1 → [1]  → min = 2
  
  diff = 8 - 2 = 6 > 4 ✗
  Contract: left = 1
  max_dq[0] = 0 < left = 1, pop → max_dq = [1]
  
  diff = 2 - 2 = 0 ≤ 4 ✓
  result = max(1, 1) = 1

═══════════════════════════════════════════════════════════════
i=2: num=4
─────────────────────────────────────────────────────────────
       [2   4]  7
            ↑
  
  max_dq: 2 < 4, pop 1, add 2 → [2]  → max = 4
  min_dq: 2 < 4, keep → [1, 2]  → min = 2
  
  diff = 4 - 2 = 2 ≤ 4 ✓
  result = max(1, 2) = 2

═══════════════════════════════════════════════════════════════
i=3: num=7
─────────────────────────────────────────────────────────────
       [2   4   7]
                ↑
  
  max_dq: 4 < 7, pop 2, add 3 → [3]  → max = 7
  min_dq: 4 < 7, keep → [1, 2, 3]  → min = 2
  
  diff = 7 - 2 = 5 > 4 ✗
  Contract: left = 2
  min_dq[0] = 1 < left = 2, pop → min_dq = [2, 3]
  
  diff = 7 - 4 = 3 ≤ 4 ✓
  result = max(2, 2) = 2

═══════════════════════════════════════════════════════════════
FINAL: 2
```

---

## 4.6 State Update Patterns Summary

```
┌─────────────────────────────────────────────────────────────┐
│            WINDOW STATE PATTERNS CHEAT SHEET                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  SINGLE VARIABLE:                                           │
│  ────────────────                                           │
│  sum += new; sum -= old                                     │
│  product *= new; product /= old                             │
│                                                             │
│  HASHMAP (Frequency):                                       │
│  ────────────────────                                       │
│  freq[new] += 1                                             │
│  freq[old] -= 1; if freq[old] == 0: del freq[old]           │
│                                                             │
│  HASHMAP (Distinct Count):                                  │
│  ─────────────────────────                                  │
│  if freq[new] == 0: distinct++; freq[new] += 1              │
│  freq[old] -= 1; if freq[old] == 0: distinct--; del         │
│                                                             │
│  MONOTONIC DEQUE (Max):                                     │
│  ──────────────────────                                     │
│  while dq and nums[dq[-1]] < new: dq.pop()                  │
│  dq.append(new_index)                                       │
│  while dq[0] outside window: dq.popleft()                   │
│                                                             │
│  SET:                                                       │
│  ────                                                       │
│  if new in set: found duplicate                             │
│  set.add(new); set.remove(old)                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 4.7 Practice Problems

| Problem | State Structure | Difficulty |
|---------|-----------------|------------|
| Sliding Window Maximum (LC 239) | Monotonic Deque | Hard |
| Contains Duplicate II (LC 219) | HashSet | Easy |
| Longest Substring Without Repeating (LC 3) | HashMap/Set | Medium |
| Longest Subarray with Limit (LC 1438) | Two Deques | Medium |
| Fruit Into Baskets (LC 904) | HashMap | Medium |
| Max Consecutive Ones III (LC 1004) | Counter Variable | Medium |
