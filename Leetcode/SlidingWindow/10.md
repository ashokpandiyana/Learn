# Chapter 10: Shrinkable vs Non-Shrinkable Windows

## 10.1 Introduction: Two Window Behaviors

### The Core Distinction

There are two fundamentally different ways to handle window contraction:

```
TWO CONTRACTION STRATEGIES:
════════════════════════════════════════════════════════════════

SHRINKABLE (Standard):
──────────────────────
while invalid():
    contract()
    
• Window shrinks as much as needed
• Window size goes UP and DOWN
• Finds ALL valid windows
• Use when you need: minimum, all windows, or exact counts

NON-SHRINKABLE (Optimized):
───────────────────────────
if invalid():
    contract_once()
    
• Window shrinks at most once per expansion
• Window size only GROWS or STAYS SAME
• Maintains the LARGEST seen window size
• Use when you only need: maximum length
```

### Visual Comparison

```
Array: [1, 2, 3, 4, 5], finding longest subarray (some condition)

═══════════════════════════════════════════════════════════════
SHRINKABLE WINDOW:
═══════════════════════════════════════════════════════════════

Window sizes over time:

    [1] → [1,2] → [1,2,3] → [2,3] → [2,3,4] → [3,4] → [3,4,5]
     1      2        3        2        3         2        3
                     ↑                 ↑
                  shrinks           shrinks
                  
Size pattern: 1 → 2 → 3 → 2 → 3 → 2 → 3
Window can SHRINK when condition violated.

═══════════════════════════════════════════════════════════════
NON-SHRINKABLE WINDOW:
═══════════════════════════════════════════════════════════════

Window sizes over time:

    [1] → [1,2] → [1,2,3] → [_2,3,4] → [__3,4,5]
     1      2        3          3          3
                     ↑          ↑          ↑
                   valid     slides      slides
                   
Size pattern: 1 → 2 → 3 → 3 → 3
Window NEVER shrinks below maximum valid size found.
```

---

## 10.2 Shrinkable Window (Standard Approach)

### When to Use

```
USE SHRINKABLE WINDOW WHEN:
════════════════════════════════════════════════════════════════

1. Finding MINIMUM length
   • Need to shrink to find smallest valid window
   • Example: Minimum Window Substring

2. Finding ALL valid windows
   • Need to explore all possibilities
   • Example: Find All Anagrams

3. COUNTING subarrays
   • Need exact count of all valid subarrays
   • Example: Subarrays with K Different Integers

4. BOTH expand and contract affect the answer
   • Can't afford to miss any valid configuration
```

### Template: Shrinkable Window

```python
def shrinkable_window(arr, condition_param):
    """
    Standard shrinkable window template.
    Window can shrink multiple times per expansion.
    """
    left = 0
    result = 0  # or float('inf') for minimum
    state = initialize_state()
    
    for right in range(len(arr)):
        # Expand: add arr[right]
        update_state_add(state, arr[right])
        
        # Contract: shrink WHILE invalid
        while is_invalid(state, condition_param):
            update_state_remove(state, arr[left])
            left += 1
        
        # Update result (window is now valid)
        result = max(result, right - left + 1)
    
    return result
```

### Example: Longest Substring with At Most K Distinct

```python
from collections import defaultdict

def longest_k_distinct_shrinkable(s, k):
    """
    Shrinkable version - window can shrink multiple times.
    """
    freq = defaultdict(int)
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        # Expand
        freq[s[right]] += 1
        
        # Contract WHILE too many distinct (may shrink multiple times)
        while len(freq) > k:
            freq[s[left]] -= 1
            if freq[s[left]] == 0:
                del freq[s[left]]
            left += 1
        
        # Update result
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

### Visual: Shrinkable Behavior

```
s = "eceba", k = 2

═══════════════════════════════════════════════════════════════
right=0, char='e'
─────────────────────────────────────────────────────────────
  [e]  c   e   b   a
   ↑
  left=0, freq={'e':1}, distinct=1 ≤ 2 ✓
  max_length = 1

═══════════════════════════════════════════════════════════════
right=1, char='c'
─────────────────────────────────────────────────────────────
  [e   c]  e   b   a
       ↑
  left=0, freq={'e':1,'c':1}, distinct=2 ≤ 2 ✓
  max_length = 2

═══════════════════════════════════════════════════════════════
right=2, char='e'
─────────────────────────────────────────────────────────────
  [e   c   e]  b   a
           ↑
  left=0, freq={'e':2,'c':1}, distinct=2 ≤ 2 ✓
  max_length = 3

═══════════════════════════════════════════════════════════════
right=3, char='b'
─────────────────────────────────────────────────────────────
  [e   c   e   b]  a
               ↑
  left=0, freq={'e':2,'c':1,'b':1}, distinct=3 > 2 ✗
  
  CONTRACT (while loop):
  ┌─────────────────────────────────────────────────────────┐
  │ Iteration 1: Remove 'e'                                 │
  │   freq={'e':1,'c':1,'b':1}, distinct=3 > 2, continue    │
  │   left=1                                                │
  │                                                         │
  │ Iteration 2: Remove 'c'                                 │
  │   freq={'e':1,'b':1}, distinct=2 ≤ 2, STOP              │
  │   left=2                                                │
  └─────────────────────────────────────────────────────────┘
  
  Window is now [e, b] (indices 2-3)
  Size SHRUNK from 4 to 2
  max_length = max(3, 2) = 3

═══════════════════════════════════════════════════════════════
right=4, char='a'
─────────────────────────────────────────────────────────────
       [e   b   a]
                ↑
  left=2, freq={'e':1,'b':1,'a':1}, distinct=3 > 2 ✗
  
  CONTRACT:
  Remove 'e': freq={'b':1,'a':1}, distinct=2 ≤ 2, STOP
  left=3
  
  Window is now [b, a] (indices 3-4)
  max_length = max(3, 2) = 3

═══════════════════════════════════════════════════════════════
FINAL: max_length = 3
```

---

## 10.3 Non-Shrinkable Window (Optimized Approach)

### When to Use

```
USE NON-SHRINKABLE WINDOW WHEN:
════════════════════════════════════════════════════════════════

1. Finding MAXIMUM length ONLY
   • Don't need to know all valid windows
   • Just need the longest one

2. Answer is MONOTONIC with window size
   • If size K works, we don't care about smaller sizes
   • Only want to grow or maintain the window

3. Optimization for cleaner/faster code
   • Single left movement per right movement
   • Slightly simpler logic

CRITICAL: The answer must ONLY be the maximum!
Cannot use for minimum, counting, or finding all windows.
```

### Template: Non-Shrinkable Window

```python
def non_shrinkable_window(arr, condition_param):
    """
    Non-shrinkable window template.
    Window maintains or grows, never shrinks below max seen.
    """
    left = 0
    state = initialize_state()
    
    for right in range(len(arr)):
        # Expand: add arr[right]
        update_state_add(state, arr[right])
        
        # Contract: move left IF invalid (not WHILE!)
        if is_invalid(state, condition_param):
            update_state_remove(state, arr[left])
            left += 1
        
        # Window size is always: right - left + 1
        # No need to track max - final size IS the answer!
    
    # Return final window size
    return len(arr) - left
```

### Key Insight: Why This Works

```
THE MONOTONICITY PRINCIPLE:
════════════════════════════════════════════════════════════════

If we've found a valid window of size K:
  • We NEVER need a smaller window (we want MAXIMUM)
  • Future windows should be size K or larger

So when window becomes invalid:
  • Instead of shrinking to find a smaller valid window...
  • We just SLIDE the window (maintain size)
  • We're waiting for a chance to grow again

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  SHRINKABLE:     while invalid(): left++                    │
│                  Window can become any size                 │
│                                                             │
│  NON-SHRINKABLE: if invalid(): left++                       │
│                  Window maintains minimum size of max found │
│                                                             │
└─────────────────────────────────────────────────────────────┘

The magic: "if" instead of "while"!
```

### Example: Longest Repeating Character Replacement

```python
def character_replacement_non_shrinkable(s, k):
    """
    LeetCode 424: Longest Repeating Character Replacement
    
    Non-shrinkable version - cleaner and slightly faster.
    
    Key insight: We only care about the MAXIMUM window.
    If current window is invalid, we don't need smaller windows.
    """
    freq = {}
    left = 0
    max_freq = 0  # Max frequency of any single character in window
    
    for right in range(len(s)):
        # Expand
        freq[s[right]] = freq.get(s[right], 0) + 1
        max_freq = max(max_freq, freq[s[right]])
        
        # Check validity: characters to replace = window_size - max_freq
        # Valid if: (right - left + 1) - max_freq <= k
        
        # Contract IF invalid (not WHILE!)
        if (right - left + 1) - max_freq > k:
            freq[s[left]] -= 1
            left += 1
            # Note: We DON'T update max_freq here!
        
        # Window size is implicitly tracked
    
    # Final window size is the answer
    return len(s) - left
```

### Why We Don't Update max_freq When Contracting

```
SUBTLE BUT IMPORTANT:
════════════════════════════════════════════════════════════════

When we remove a character, max_freq might become stale
(the actual max might be lower now).

BUT this is okay because:

1. If max_freq is HIGHER than reality:
   • Window appears MORE valid than it is
   • We might skip some contractions
   • But window size stays the same (just slides)

2. If we later find a TRULY larger valid window:
   • max_freq will update correctly when we add characters
   • We'll grow the window

3. The answer is the MAXIMUM window ever seen:
   • We found that size when max_freq was accurate
   • Stale max_freq only affects sliding, not the answer

This is why non-shrinkable works ONLY for maximum problems!
```

### Visual: Non-Shrinkable Behavior

```
s = "AABABBA", k = 1

═══════════════════════════════════════════════════════════════
right=0, char='A'
─────────────────────────────────────────────────────────────
  [A]  A   B   A   B   B   A
   ↑
  left=0, freq={'A':1}, max_freq=1
  window_size=1, chars_to_replace=1-1=0 ≤ 1 ✓
  
  Window size: 1

═══════════════════════════════════════════════════════════════
right=1, char='A'
─────────────────────────────────────────────────────────────
  [A   A]  B   A   B   B   A
       ↑
  left=0, freq={'A':2}, max_freq=2
  window_size=2, chars_to_replace=2-2=0 ≤ 1 ✓
  
  Window size: 2

═══════════════════════════════════════════════════════════════
right=2, char='B'
─────────────────────────────────────────────────────────────
  [A   A   B]  A   B   B   A
           ↑
  left=0, freq={'A':2,'B':1}, max_freq=2
  window_size=3, chars_to_replace=3-2=1 ≤ 1 ✓
  
  Window size: 3

═══════════════════════════════════════════════════════════════
right=3, char='A'
─────────────────────────────────────────────────────────────
  [A   A   B   A]  B   B   A
               ↑
  left=0, freq={'A':3,'B':1}, max_freq=3
  window_size=4, chars_to_replace=4-3=1 ≤ 1 ✓
  
  Window size: 4 ← MAXIMUM SO FAR

═══════════════════════════════════════════════════════════════
right=4, char='B'
─────────────────────────────────────────────────────────────
  [A   A   B   A   B]  B   A
                   ↑
  left=0, freq={'A':3,'B':2}, max_freq=3
  window_size=5, chars_to_replace=5-3=2 > 1 ✗
  
  INVALID! Use "if" to contract ONCE:
  Remove 'A': freq={'A':2,'B':2}, left=1
  
  Window size: 4 (maintained!)
  
  ┌─────────────────────────────────────────────────────────┐
  │ Note: max_freq stays 3 (stale), but that's okay!       │
  │ We're just sliding, maintaining size 4.                │
  └─────────────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════
right=5, char='B'
─────────────────────────────────────────────────────────────
      [A   B   A   B   B]  A
                       ↑
  left=1, freq={'A':2,'B':3}, max_freq=3
  window_size=5, chars_to_replace=5-3=2 > 1 ✗
  
  INVALID! Contract once:
  Remove 'A': freq={'A':1,'B':3}, left=2
  
  Window size: 4

═══════════════════════════════════════════════════════════════
right=6, char='A'
─────────────────────────────────────────────────────────────
          [B   A   B   B   A]
                           ↑
  left=2, freq={'A':2,'B':3}, max_freq=3
  window_size=5, chars_to_replace=5-3=2 > 1 ✗
  
  INVALID! Contract once:
  Remove 'B': freq={'A':2,'B':2}, left=3
  
  Window size: 4

═══════════════════════════════════════════════════════════════
FINAL: Window size = 7 - 3 = 4

Answer: 4 (window "AABA" can become "AAAA" with 1 replacement)
```

---

## 10.4 Side-by-Side Comparison

### Same Problem, Two Approaches

```python
def longest_ones_shrinkable(nums, k):
    """
    LeetCode 1004: Max Consecutive Ones III
    SHRINKABLE version
    """
    left = 0
    zeros = 0
    max_length = 0
    
    for right in range(len(nums)):
        if nums[right] == 0:
            zeros += 1
        
        # WHILE too many zeros
        while zeros > k:
            if nums[left] == 0:
                zeros -= 1
            left += 1
        
        max_length = max(max_length, right - left + 1)
    
    return max_length


def longest_ones_non_shrinkable(nums, k):
    """
    LeetCode 1004: Max Consecutive Ones III
    NON-SHRINKABLE version
    """
    left = 0
    zeros = 0
    
    for right in range(len(nums)):
        if nums[right] == 0:
            zeros += 1
        
        # IF too many zeros (not WHILE!)
        if zeros > k:
            if nums[left] == 0:
                zeros -= 1
            left += 1
    
    return len(nums) - left
```

### Behavior Comparison

```
nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2

═══════════════════════════════════════════════════════════════
SHRINKABLE:
═══════════════════════════════════════════════════════════════

Window sizes: 1→2→3→4→5→4→5→6→7→8→7→8→...
              ↑       ↑     ↑       ↑
           growing  shrink grow  shrink

Final max_length tracked: 8


═══════════════════════════════════════════════════════════════
NON-SHRINKABLE:
═══════════════════════════════════════════════════════════════

Window sizes: 1→2→3→4→5→6→6→6→6→6→6→6
                        ↑
                     max reached, then slides
                     
Final size = len(nums) - left = 6

Wait, this gives 6, not 8! What happened?

═══════════════════════════════════════════════════════════════
ANALYSIS:
═══════════════════════════════════════════════════════════════

Actually, let me trace more carefully...

Position:  0 1 2 3 4 5 6 7 8 9 10
Array:    [1,1,1,0,0,0,1,1,1,1,0]
                    ↑     ↑
               3 zeros  nice run of 1s

With k=2, we can flip 2 zeros.

Best window: indices 3-10: [0,0,0,1,1,1,1,0]
Wait, that has 4 zeros. Let me reconsider...

Actually best is: [1,1,1,0,0,_,1,1,1,1] - flip positions 3,4
Giving: [1,1,1,1,1,_,1,1,1,1]

Or: [_,_,_,0,0,0,1,1,1,1,0] flip positions 5,10
Giving: 6 ones...

Let me trace shrinkable properly:

r=0-2: window=[1,1,1], zeros=0, size=3
r=3: window=[1,1,1,0], zeros=1, size=4
r=4: window=[1,1,1,0,0], zeros=2, size=5
r=5: window=[1,1,1,0,0,0], zeros=3>2
     shrink until zeros≤2: remove 1,1,1,0 → left=4
     window=[0,0], zeros=2, size=2
r=6: window=[0,0,1], zeros=2, size=3
...

Both approaches give same ANSWER (6), just different paths!
```

---

## 10.5 When Non-Shrinkable Fails

### Case 1: Minimum Problems

```python
# ❌ NON-SHRINKABLE FAILS FOR MINIMUM
def min_window_wrong(s, t):
    """
    WRONG! Cannot use non-shrinkable for minimum window.
    """
    # This would give MAXIMUM window, not minimum!
    pass

# ✅ MUST USE SHRINKABLE FOR MINIMUM
def min_window_correct(s, t):
    """
    Must shrink as much as possible to find minimum.
    """
    while formed == required:
        update_min()  # Need this inside while
        contract()
```

### Case 2: Counting Problems

```python
# ❌ NON-SHRINKABLE FAILS FOR COUNTING
def count_subarrays_wrong(arr, k):
    """
    WRONG! Cannot use non-shrinkable for counting.
    """
    # Would miss many valid subarrays!
    pass

# ✅ MUST USE SHRINKABLE FOR COUNTING
def count_subarrays_correct(arr, k):
    """
    Need to find ALL valid windows to count them.
    """
    while valid():
        count += right - left + 1  # Count all subarrays
        contract()
```

### Case 3: Finding All Valid Windows

```python
# ❌ NON-SHRINKABLE FAILS FOR "FIND ALL"
def find_all_anagrams_wrong(s, p):
    """
    WRONG! Would miss some anagram positions.
    """
    pass

# ✅ MUST USE SHRINKABLE FOR "FIND ALL"
def find_all_anagrams_correct(s, p):
    """
    Need to check every valid window position.
    """
    # Fixed-size window checks every position
    pass
```

---

## 10.6 Decision Framework

```
CHOOSING BETWEEN SHRINKABLE AND NON-SHRINKABLE:
════════════════════════════════════════════════════════════════

                What are you finding?
                        │
        ┌───────────────┼───────────────┐
        │               │               │
    MAXIMUM         MINIMUM          COUNT/ALL
        │               │               │
        ▼               ▼               ▼
 ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
 │ Can use     │ │ MUST use    │ │ MUST use    │
 │ EITHER      │ │ SHRINKABLE  │ │ SHRINKABLE  │
 │             │ │             │ │             │
 │ Non-shrink  │ │ while loop  │ │ while loop  │
 │ is simpler  │ │ required    │ │ required    │
 └─────────────┘ └─────────────┘ └─────────────┘

For MAXIMUM problems, choose based on preference:
• Shrinkable: More intuitive, explicitly tracks max
• Non-shrinkable: Cleaner code, implicit max tracking
```

---

## 10.7 Advanced: Converting Between Forms

### From Shrinkable to Non-Shrinkable

```python
# SHRINKABLE (original)
def solution_shrinkable(arr, k):
    left = 0
    max_len = 0
    state = 0
    
    for right in range(len(arr)):
        state += arr[right]
        
        while state > k:           # WHILE
            state -= arr[left]
            left += 1
        
        max_len = max(max_len, right - left + 1)  # Track max
    
    return max_len


# NON-SHRINKABLE (converted)
def solution_non_shrinkable(arr, k):
    left = 0
    state = 0
    
    for right in range(len(arr)):
        state += arr[right]
        
        if state > k:              # IF (changed!)
            state -= arr[left]
            left += 1
        
        # No need to track max - removed!
    
    return len(arr) - left         # Implicit max (changed!)
```

### Conversion Checklist

```
┌─────────────────────────────────────────────────────────────┐
│         CONVERSION: SHRINKABLE → NON-SHRINKABLE              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. Change "while" to "if"                                  │
│     while invalid():  →  if invalid():                      │
│                                                             │
│  2. Remove max tracking variable                            │
│     max_len = 0                                             │
│     max_len = max(max_len, ...)  →  (remove both)           │
│                                                             │
│  3. Change return statement                                 │
│     return max_len  →  return len(arr) - left               │
│                                                             │
│  4. VERIFY: Problem asks for MAXIMUM only                   │
│     If minimum/count/all → Cannot convert!                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 10.8 Performance Comparison

```
PERFORMANCE ANALYSIS:
════════════════════════════════════════════════════════════════

Both are O(n) time, but non-shrinkable has slightly less work:

SHRINKABLE:
───────────────────────────────────────────────────────────────
• May contract multiple times per expansion
• max() called at every iteration
• More comparisons overall
• Extra variable for tracking max

NON-SHRINKABLE:
───────────────────────────────────────────────────────────────
• At most one contraction per expansion
• No max() calls
• Fewer comparisons
• Fewer variables

In practice:
• Difference is usually negligible
• Both are equally acceptable in interviews
• Choose based on clarity and personal preference
```

---

## 10.9 Chapter Summary

```
┌─────────────────────────────────────────────────────────────┐
│       SHRINKABLE vs NON-SHRINKABLE KEY POINTS                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  SHRINKABLE (while loop):                                   │
│  ─────────────────────────                                  │
│  • Window can shrink multiple times                         │
│  • Use for: minimum, counting, finding all                  │
│  • More versatile, always correct                           │
│  • Template: while invalid(): contract()                    │
│                                                             │
│  NON-SHRINKABLE (if statement):                             │
│  ───────────────────────────────                            │
│  • Window only slides, never shrinks                        │
│  • Use for: maximum length ONLY                             │
│  • Cleaner code, implicit max tracking                      │
│  • Template: if invalid(): contract_once()                  │
│                                                             │
│  KEY DIFFERENCE:                                            │
│  • "while" → shrinks until valid                            │
│  • "if" → slides to maintain size                           │
│                                                             │
│  CONVERSION:                                                │
│  • while → if                                               │
│  • Remove max tracking                                      │
│  • Return: len(arr) - left                                  │
│                                                             │
│  CAUTION:                                                   │
│  • Non-shrinkable ONLY works for maximum problems           │
│  • Using it for minimum/count will give wrong answers       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 10.10 Practice Problems

| Problem | Can Use Non-Shrinkable? | Why? |
|---------|------------------------|------|
| Max Consecutive Ones III (LC 1004) | ✅ Yes | Maximum length |
| Longest Repeating Char Replacement (LC 424) | ✅ Yes | Maximum length |
| Longest Substring K Distinct (LC 340) | ✅ Yes | Maximum length |
| Minimum Window Substring (LC 76) | ❌ No | Minimum length |
| Subarrays with K Different (LC 992) | ❌ No | Counting |
| Find All Anagrams (LC 438) | ❌ No | Finding all |
| Minimum Size Subarray Sum (LC 209) | ❌ No | Minimum length |
| Fruit Into Baskets (LC 904) | ✅ Yes | Maximum length |
