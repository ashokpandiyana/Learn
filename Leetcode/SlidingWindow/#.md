# Mastering the Sliding Window Pattern
## A Complete Guide from Beginner to Advanced

---

# Part 1: Foundations

## Chapter 1: Introduction to Sliding Window

### 1.1 What is Sliding Window?
A technique that converts nested loops (O(n²)) into a single loop (O(n)) by maintaining a "window" that slides over data.

### 1.2 When to Use Sliding Window
✦ **Key Indicators:**
- Problems involving contiguous sequences (subarrays/substrings)
- Keywords: "maximum," "minimum," "longest," "shortest," "contains"
- Finding subarrays/substrings with specific properties
- Problems asking for optimization over all contiguous segments

### 1.3 Core Concept
Instead of recalculating from scratch, **add the new element** and **remove the old element** as the window moves.

```
Array: [1, 3, 5, 7, 9, 2]
Window size 3:
  [1, 3, 5] → sum = 9
     [3, 5, 7] → sum = 9 - 1 + 7 = 15
        [5, 7, 9] → sum = 15 - 3 + 9 = 21
```

---

# Part 2: Types of Sliding Window

## Chapter 2: Fixed-Size Window

### 2.1 Definition
Window size remains constant throughout traversal.

### 2.2 Template
```python
def fixed_window(arr, k):
    n = len(arr)
    # Build initial window
    window_sum = sum(arr[:k])
    result = window_sum
    
    # Slide the window
    for i in range(k, n):
        window_sum += arr[i] - arr[i - k]  # Add new, remove old
        result = max(result, window_sum)
    
    return result
```

### 2.3 Common Problems
- Maximum sum subarray of size K
- First negative in every window of size K
- Maximum of all subarrays of size K
- Count distinct elements in every window
- Sliding window average

### 2.4 Important Notes
⚠️ **Edge Case:** Always check if `k > len(arr)`
⚠️ **Initialization:** Build the first window before sliding
⚠️ **Off-by-one:** Element to remove is at index `i - k`, not `i - k + 1`

---

## Chapter 3: Variable-Size Window (Dynamic)

### 3.1 Definition
Window size expands or contracts based on conditions.

### 3.2 Two Pointer Approach
```python
def variable_window(arr, target):
    left = 0
    current = 0
    result = float('inf')  # or 0, depending on problem
    
    for right in range(len(arr)):
        # Expand: add arr[right] to window
        current += arr[right]
        
        # Contract: shrink window while condition violated
        while condition_violated(current, target):
            current -= arr[left]
            left += 1
        
        # Update result
        result = min(result, right - left + 1)
    
    return result
```

### 3.3 The Expand-Contract Pattern
1. **Expand** the window by moving `right` pointer
2. **Check** if window violates constraint
3. **Contract** from `left` until constraint satisfied
4. **Update** result at valid window state

### 3.4 Important Notes
⚠️ **When to update result:** Depends on finding minimum vs maximum
- **Minimum length:** Update AFTER contracting (valid window)
- **Maximum length:** Update BEFORE/WHILE contracting

---

# Part 3: Core Techniques

## Chapter 4: Window State Management

### 4.1 Using HashMap/Dictionary
Track frequency of elements in current window.

```python
from collections import defaultdict

def window_with_hashmap(s, k):
    freq = defaultdict(int)
    left = 0
    
    for right in range(len(s)):
        freq[s[right]] += 1  # Add to window
        
        while len(freq) > k:  # Constraint check
            freq[s[left]] -= 1
            if freq[s[left]] == 0:
                del freq[s[left]]
            left += 1
        
        # Process valid window
```

### 4.2 Using Deque (Monotonic)
Maintain maximum/minimum efficiently in O(1).

```python
from collections import deque

def max_in_window(arr, k):
    dq = deque()  # Store indices
    result = []
    
    for i in range(len(arr)):
        # Remove elements outside window
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # Maintain decreasing order
        while dq and arr[dq[-1]] < arr[i]:
            dq.pop()
        
        dq.append(i)
        
        if i >= k - 1:
            result.append(arr[dq[0]])
    
    return result
```

### 4.3 Using Set
Track unique elements or check membership.

### 4.4 Important Notes
⚠️ **Memory cleanup:** Always remove from hashmap when count becomes 0
⚠️ **Deque stores indices, not values** (to check if element is in window)

---

## Chapter 5: Counting Windows Pattern

### 5.1 "At Most K" Pattern
Count subarrays with **at most** K distinct elements.

```python
def at_most_k(arr, k):
    left = 0
    freq = defaultdict(int)
    count = 0
    
    for right in range(len(arr)):
        freq[arr[right]] += 1
        
        while len(freq) > k:
            freq[arr[left]] -= 1
            if freq[arr[left]] == 0:
                del freq[arr[left]]
            left += 1
        
        # All subarrays ending at 'right' with at most k distinct
        count += right - left + 1
    
    return count
```

### 5.2 "Exactly K" Pattern
```python
def exactly_k(arr, k):
    return at_most_k(arr, k) - at_most_k(arr, k - 1)
```

### 5.3 Why This Works
- `at_most(k)` includes all windows with 0, 1, 2, ... k distinct
- `at_most(k-1)` includes all windows with 0, 1, 2, ... k-1 distinct
- Difference = windows with exactly k distinct

### 5.4 Important Notes
⚠️ This pattern is **extremely common** in hard problems
⚠️ Reduces "exactly K" (hard) to "at most K" (easier)

---

# Part 4: Advanced Patterns

## Chapter 6: Two Sliding Windows

### 6.1 When to Use
- Need to track multiple constraints simultaneously
- Problems requiring comparison between two ranges
- Maintaining min and max conditions together

### 6.2 Template: Longest Subarray with Bounded Difference
```python
from collections import deque

def longest_subarray(arr, limit):
    max_dq = deque()  # Decreasing
    min_dq = deque()  # Increasing
    left = 0
    result = 0
    
    for right in range(len(arr)):
        while max_dq and arr[max_dq[-1]] < arr[right]:
            max_dq.pop()
        while min_dq and arr[min_dq[-1]] > arr[right]:
            min_dq.pop()
        
        max_dq.append(right)
        min_dq.append(right)
        
        while arr[max_dq[0]] - arr[min_dq[0]] > limit:
            left += 1
            if max_dq[0] < left:
                max_dq.popleft()
            if min_dq[0] < left:
                min_dq.popleft()
        
        result = max(result, right - left + 1)
    
    return result
```

---

## Chapter 7: Sliding Window with Binary Search

### 7.1 When to Use
- Window sum/property has monotonic behavior
- Need to find optimal window size
- Combined with prefix sums

### 7.2 Pattern
```python
def binary_search_window(arr, target):
    def can_achieve(window_size):
        # Check if any window of this size satisfies condition
        pass
    
    left, right = 1, len(arr)
    result = 0
    
    while left <= right:
        mid = (left + right) // 2
        if can_achieve(mid):
            result = mid
            left = mid + 1  # or right = mid - 1
        else:
            right = mid - 1  # or left = mid + 1
    
    return result
```

---

## Chapter 8: Sliding Window on Strings

### 8.1 Anagram/Permutation Pattern
```python
def find_anagrams(s, p):
    from collections import Counter
    
    p_count = Counter(p)
    s_count = Counter()
    result = []
    k = len(p)
    
    for i in range(len(s)):
        # Add to window
        s_count[s[i]] += 1
        
        # Remove from window
        if i >= k:
            char = s[i - k]
            s_count[char] -= 1
            if s_count[char] == 0:
                del s_count[char]
        
        # Compare
        if s_count == p_count:
            result.append(i - k + 1)
    
    return result
```

### 8.2 Optimized Matching Counter
```python
def check_inclusion(s1, s2):
    from collections import Counter
    
    need = Counter(s1)
    have = 0
    required = len(need)
    left = 0
    
    for right in range(len(s2)):
        char = s2[right]
        if char in need:
            need[char] -= 1
            if need[char] == 0:
                have += 1
        
        while have == required:
            if right - left + 1 == len(s1):
                return True
            
            left_char = s2[left]
            if left_char in need:
                if need[left_char] == 0:
                    have -= 1
                need[left_char] += 1
            left += 1
    
    return False
```

### 8.3 Important Notes
⚠️ **Counter comparison is O(26) for lowercase, O(1) amortized**
⚠️ Use `have/need` pattern to avoid comparing entire hashmaps

---

## Chapter 9: Minimum Window Pattern

### 9.1 Minimum Window Substring Template
```python
def min_window(s, t):
    from collections import Counter
    
    need = Counter(t)
    have = 0
    required = len(need)
    
    left = 0
    min_len = float('inf')
    result = ""
    
    for right in range(len(s)):
        char = s[right]
        if char in need:
            need[char] -= 1
            if need[char] == 0:
                have += 1
        
        # Contract while valid
        while have == required:
            # Update result
            if right - left + 1 < min_len:
                min_len = right - left + 1
                result = s[left:right + 1]
            
            # Remove left
            left_char = s[left]
            if left_char in need:
                if need[left_char] == 0:
                    have -= 1
                need[left_char] += 1
            left += 1
    
    return result
```

### 9.2 Key Insight
- `need[char]` can go negative (have more than needed)
- Only decrement `have` when `need[char]` was exactly 0

---

# Part 5: Special Techniques

## Chapter 10: Shrinkable vs Non-Shrinkable Windows

### 10.1 Shrinkable Window (Standard)
```python
for right in range(n):
    # Add arr[right]
    while invalid():
        # Remove arr[left]
        left += 1
    # Update result
```

### 10.2 Non-Shrinkable Window (Advanced)
Window never shrinks; maintains maximum valid window size.

```python
for right in range(n):
    # Add arr[right]
    if invalid():
        # Remove arr[left]
        left += 1
    # Window size = right - left + 1 (always)
```

### 10.3 When to Use Non-Shrinkable
- Only need the **maximum** window size (not all windows)
- The answer is monotonic with window size
- Optimization for cleaner code

---

## Chapter 11: Sliding Window with Prefix Sum

### 11.1 Subarray Sum Equals K
```python
def subarray_sum(arr, k):
    prefix = 0
    count = 0
    prefix_count = {0: 1}
    
    for num in arr:
        prefix += num
        
        # If prefix - k exists, we found a subarray
        if prefix - k in prefix_count:
            count += prefix_count[prefix - k]
        
        prefix_count[prefix] = prefix_count.get(prefix, 0) + 1
    
    return count
```

### 11.2 Important Notes
⚠️ **Not a traditional sliding window** but solves similar problems
⚠️ Works when elements can be negative
⚠️ Initialize with `{0: 1}` to handle subarrays starting from index 0

---

## Chapter 12: Sliding Window on Circular Arrays

### 12.1 Technique 1: Double the Array
```python
def circular_window(arr, k):
    doubled = arr + arr
    # Apply standard sliding window on doubled array
    # Ensure window doesn't exceed original length
```

### 12.2 Technique 2: Complement Approach
For max sum circular subarray:
```
max_circular = total_sum - min_subarray_sum
answer = max(max_normal, max_circular)
```

---

# Part 6: Problem-Solving Framework

## Chapter 13: Decision Framework

### 13.1 Step-by-Step Approach
1. **Identify** if it's a sliding window problem (contiguous + optimization)
2. **Determine** fixed or variable window
3. **Define** window state (what to track)
4. **Identify** expand/contract conditions
5. **Determine** when to update result
6. **Handle** edge cases

### 13.2 Common Mistakes
❌ Forgetting to handle empty input
❌ Off-by-one errors in window boundaries
❌ Not cleaning up hashmap (count = 0)
❌ Wrong order: update result before/after contraction
❌ Infinite loop: forgetting to move left pointer

---

## Chapter 14: Complexity Analysis

### 14.1 Time Complexity
| Pattern | Time | Explanation |
|---------|------|-------------|
| Fixed Window | O(n) | Each element visited once |
| Variable Window | O(n) | Each element added/removed at most once |
| With HashMap | O(n) | Amortized O(1) operations |
| With Deque | O(n) | Each element pushed/popped once |
| With Binary Search | O(n log n) | Binary search × window check |

### 14.2 Space Complexity
| Data Structure | Space |
|----------------|-------|
| Variables only | O(1) |
| HashMap (k keys) | O(k) |
| Deque | O(k) for window size k |

---

# Part 7: Practice Problem Categories

## Chapter 15: Problem Classification

### 15.1 Easy Level
- Maximum sum subarray of size K
- Average of subarrays of size K
- Contains duplicate II
- Longest substring without repeating (intro)

### 15.2 Medium Level
- Longest substring without repeating characters
- Longest repeating character replacement
- Max consecutive ones III
- Fruit into baskets
- Permutation in string
- Find all anagrams in a string
- Subarray product less than K

### 15.3 Hard Level
- Minimum window substring
- Sliding window maximum
- Substring with concatenation of all words
- Subarrays with K different integers
- Longest substring with at most K distinct characters
- Minimum window subsequence
- Count subarrays with fixed bounds
- Maximum sum of 3 non-overlapping subarrays
- Shortest subarray with sum at least K (with negative numbers)

---

# Part 8: Quick Reference

## Chapter 16: Templates Summary

### Template 1: Fixed Window
```python
for i in range(k, n):
    add(arr[i])
    remove(arr[i-k])
    update_result()
```

### Template 2: Variable Window (Find Minimum)
```python
for right in range(n):
    add(arr[right])
    while valid():
        update_result()  # Update here for minimum
        remove(arr[left])
        left += 1
```

### Template 3: Variable Window (Find Maximum)
```python
for right in range(n):
    add(arr[right])
    while invalid():
        remove(arr[left])
        left += 1
    update_result()  # Update here for maximum
```

### Template 4: Counting (Exactly K)
```python
def exactly_k(k):
    return at_most(k) - at_most(k-1)
```

### Template 5: String Matching
```python
have, required = 0, len(need)
# Increment have when need[char] becomes 0
# Decrement have when need[char] was 0 before incrementing
```

---

## Chapter 17: Key Takeaways

### Golden Rules
1. **Every element is processed at most twice** (added once, removed once)
2. **The window always maintains a valid state** or is being fixed
3. **Choose update timing based on optimization goal** (min vs max)
4. **"Exactly K" = "At Most K" - "At Most K-1"**
5. **When stuck, ask: What makes the window invalid?**

### Interview Tips
- Start by clarifying: "Is the input sorted? Can elements be negative?"
- State the brute force first, then optimize with sliding window
- Draw the window movement on paper
- Test with small examples before coding
- Watch for edge cases: empty array, k > n, all same elements

---

*"The sliding window technique transforms quadratic problems into linear ones by reusing computations. Master it, and you'll solve 15% of array/string problems with ease."*
