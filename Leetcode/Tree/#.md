# ğŸŒ³ Complete Tree Data Structure Mastery Guide
## From Beginner to Advanced â€” Interview Edition

---

# Part I: Foundations

## Chapter 1: Introduction to Trees

### 1.1 What is a Tree?
- Non-linear hierarchical data structure
- Collection of nodes connected by edges
- One root node, zero or more child nodes

### 1.2 Tree Terminology
| Term | Definition |
|------|------------|
| **Root** | Topmost node with no parent |
| **Parent** | Node with child(ren) below it |
| **Child** | Node directly connected below another |
| **Leaf** | Node with no children |
| **Sibling** | Nodes sharing the same parent |
| **Ancestor** | Any node on path from root to current node |
| **Descendant** | Any node in the subtree of current node |
| **Depth** | Distance from root (root depth = 0) |
| **Height** | Longest path from node to any leaf |
| **Level** | All nodes at same depth |
| **Subtree** | Tree formed by a node and all its descendants |
| **Degree** | Number of children of a node |

> âš ï¸ **Important**: Height of tree = Height of root node. Height of empty tree is -1 or 0 (convention varies).

### 1.3 Tree Properties
- N nodes â†’ N-1 edges
- Exactly one path between any two nodes
- Tree with N nodes has exactly N-1 edges

### 1.4 Types of Trees Overview
- Binary Tree
- Binary Search Tree (BST)
- Balanced Trees (AVL, Red-Black)
- N-ary Tree
- Trie (Prefix Tree)
- Segment Tree
- Fenwick Tree (BIT)
- B-Tree / B+ Tree

---

## Chapter 2: Binary Trees

### 2.1 Definition
- Each node has at most 2 children (left and right)

### 2.2 Binary Tree Node Structure
```
class TreeNode:
    val: int
    left: TreeNode
    right: TreeNode
```

### 2.3 Types of Binary Trees

#### 2.3.1 Full Binary Tree
- Every node has 0 or 2 children
- No node has only 1 child

#### 2.3.2 Complete Binary Tree
- All levels completely filled except possibly last
- Last level filled from left to right

> ğŸ’¡ **Interview Tip**: Heaps are always complete binary trees

#### 2.3.3 Perfect Binary Tree
- All internal nodes have 2 children
- All leaves at same level
- Nodes at level h: 2^h
- Total nodes: 2^(h+1) - 1

#### 2.3.4 Balanced Binary Tree
- Height difference between left and right subtree â‰¤ 1 for every node

#### 2.3.5 Degenerate (Skewed) Tree
- Each parent has only one child
- Essentially a linked list
- Worst case for BST operations: O(n)

### 2.4 Binary Tree Properties
| Property | Formula |
|----------|---------|
| Min height (n nodes) | âŒŠlogâ‚‚(n)âŒ‹ |
| Max height (n nodes) | n - 1 |
| Max nodes at level L | 2^L |
| Max nodes with height H | 2^(H+1) - 1 |
| Min nodes with height H | H + 1 |

---

## Chapter 3: Tree Traversals

### 3.1 Depth-First Search (DFS)

#### 3.1.1 Preorder (Root â†’ Left â†’ Right)
```
Visit root â†’ Traverse left subtree â†’ Traverse right subtree
```
**Use Cases**: Create copy of tree, prefix expression, serialize tree

#### 3.1.2 Inorder (Left â†’ Root â†’ Right)
```
Traverse left subtree â†’ Visit root â†’ Traverse right subtree
```
**Use Cases**: BST gives sorted order, infix expression

> ğŸ”¥ **Critical**: Inorder traversal of BST always gives sorted sequence

#### 3.1.3 Postorder (Left â†’ Right â†’ Root)
```
Traverse left subtree â†’ Traverse right subtree â†’ Visit root
```
**Use Cases**: Delete tree, postfix expression, calculate directory size

### 3.2 Breadth-First Search (BFS) / Level Order
- Visit nodes level by level
- Uses Queue data structure
- **Time**: O(n), **Space**: O(w) where w = max width

### 3.3 Traversal Implementations

#### Recursive vs Iterative
| Approach | Pros | Cons |
|----------|------|------|
| Recursive | Clean, intuitive | Stack overflow risk |
| Iterative | No stack overflow | More complex code |

> âš ï¸ **Interview Must-Know**: Always be ready to convert recursive to iterative using explicit stack

### 3.4 Morris Traversal
- **Space Complexity**: O(1)
- Uses threaded binary tree concept
- Temporarily modifies tree structure

> ğŸ’¡ **Advanced**: Morris traversal is asked in hard interviews for O(1) space inorder/preorder

### 3.5 Vertical Order Traversal
- Group nodes by horizontal distance from root
- Uses BFS + HashMap

### 3.6 Boundary Traversal
- Left boundary + Leaves + Right boundary (reverse)

### 3.7 Diagonal Traversal
- Nodes in same diagonal have same (row - col) value

---

## Chapter 4: Binary Search Tree (BST)

### 4.1 BST Property
- Left subtree contains only nodes with keys < node's key
- Right subtree contains only nodes with keys > node's key
- Both subtrees are also BSTs

### 4.2 BST Operations Complexity
| Operation | Average | Worst (Skewed) |
|-----------|---------|----------------|
| Search | O(log n) | O(n) |
| Insert | O(log n) | O(n) |
| Delete | O(log n) | O(n) |
| Find Min/Max | O(log n) | O(n) |

### 4.3 BST Insertion
- Compare with root, go left if smaller, right if larger
- Insert at appropriate leaf position

### 4.4 BST Deletion (Three Cases)

#### Case 1: Node is Leaf
- Simply remove

#### Case 2: Node has One Child
- Replace node with its child

#### Case 3: Node has Two Children
- Find inorder successor (or predecessor)
- Copy successor's value to node
- Delete successor

> ğŸ”¥ **Critical**: Inorder successor = smallest in right subtree (leftmost node)

### 4.5 BST Validation
- Check if inorder traversal is strictly increasing
- OR recursively check with min/max bounds

> âš ï¸ **Common Mistake**: Checking only immediate children is WRONG

### 4.6 Important BST Problems
- Kth smallest/largest element
- LCA (Lowest Common Ancestor)
- Floor and Ceiling
- Two Sum in BST
- Convert Sorted Array to BST
- Recover BST (two nodes swapped)

---

# Part II: Intermediate Concepts

## Chapter 5: Lowest Common Ancestor (LCA)

### 5.1 LCA in Binary Tree
**Approach**: Recursively search left and right subtrees
- If both return non-null â†’ current node is LCA
- If one returns non-null â†’ that's the LCA

**Time**: O(n), **Space**: O(h)

### 5.2 LCA in BST
**Approach**: Use BST property
- If both nodes < root â†’ search left
- If both nodes > root â†’ search right
- Otherwise â†’ root is LCA

**Time**: O(h), **Space**: O(1) iterative

### 5.3 LCA with Parent Pointers
- Convert to "intersection of two linked lists" problem

### 5.4 Binary Lifting for LCA
- Preprocessing: O(n log n)
- Query: O(log n)
- Used for multiple LCA queries

> ğŸ’¡ **Advanced**: Binary lifting is essential for hard tree problems involving path queries

---

## Chapter 6: Tree Construction Problems

### 6.1 From Traversals

| Given | Can Construct Unique Tree? |
|-------|---------------------------|
| Inorder + Preorder | âœ… Yes |
| Inorder + Postorder | âœ… Yes |
| Preorder + Postorder | âŒ No (only for full binary tree) |
| Only Inorder | âŒ No |
| Only Preorder | âŒ No |

> ğŸ”¥ **Critical**: Inorder is ALWAYS needed to uniquely construct a binary tree

### 6.2 Construction Algorithm Pattern
1. First/Last element of preorder/postorder is root
2. Find root in inorder â†’ splits into left and right subtrees
3. Recursively construct

### 6.3 Construct BST from Preorder
- Use min/max bounds approach
- Time: O(n)

### 6.4 Serialize and Deserialize Binary Tree
- Preorder with null markers
- Level order with null markers

---

## Chapter 7: Path Problems

### 7.1 Root-to-Leaf Paths
- Path Sum (exact sum exists?)
- Path Sum II (all paths with sum)
- Sum Root to Leaf Numbers

### 7.2 Any-to-Any Path
- Maximum Path Sum
- Path with Maximum Sum (can start/end anywhere)

> âš ï¸ **Pattern**: For any-to-any paths, at each node consider:
> 1. Path through left child only
> 2. Path through right child only  
> 3. Path through both children (current node is highest point)
> 4. Start fresh from current node

### 7.3 Diameter of Binary Tree
- Longest path between any two nodes
- May or may not pass through root
- At each node: max(left_height + right_height)

### 7.4 Path Sum Patterns
```
Pattern: Carry current sum down, check at leaves or nodes
Use HashMap for "path sum equals K" type problems
```

---

## Chapter 8: Tree Transformations

### 8.1 Invert/Mirror Binary Tree
- Swap left and right children recursively

### 8.2 Flatten Binary Tree to Linked List
- Preorder traversal structure
- Right pointer as next, left as null

### 8.3 Convert BST to Sorted Doubly Linked List
- Inorder traversal
- Track predecessor node

### 8.4 Convert Binary Tree to BST
- Store inorder, sort it, replace values

### 8.5 Merge Two BSTs
- Inorder both â†’ merge sorted arrays â†’ construct balanced BST

---

## Chapter 9: Balanced Trees

### 9.1 AVL Tree

#### 9.1.1 Properties
- Self-balancing BST
- Balance Factor (BF) = Height(left) - Height(right)
- BF âˆˆ {-1, 0, 1} for all nodes

#### 9.1.2 Rotations
| Imbalance Type | Rotation |
|----------------|----------|
| Left-Left (LL) | Right Rotation |
| Right-Right (RR) | Left Rotation |
| Left-Right (LR) | Left then Right |
| Right-Left (RL) | Right then Left |

> ğŸ’¡ **Memory Trick**: 
> - If imbalance is "outside" (LL or RR) â†’ single rotation
> - If imbalance is "inside" (LR or RL) â†’ double rotation

#### 9.1.3 AVL Operations
- All operations: O(log n) guaranteed
- Max height: ~1.44 * logâ‚‚(n)

### 9.2 Red-Black Tree

#### 9.2.1 Properties
1. Every node is Red or Black
2. Root is always Black
3. No two adjacent Red nodes
4. Every path from node to NULL has same Black nodes
5. All NULL leaves are Black

#### 9.2.2 Complexity
- All operations: O(log n)
- Less strictly balanced than AVL
- Faster insertions/deletions than AVL

> ğŸ’¡ **Interview Tip**: Red-Black trees are used in TreeMap, TreeSet (Java), map/set (C++ STL)

### 9.3 AVL vs Red-Black Tree
| Factor | AVL | Red-Black |
|--------|-----|-----------|
| Balance | Stricter | Relaxed |
| Search | Faster | Slightly slower |
| Insert/Delete | More rotations | Fewer rotations |
| Use Case | Read-heavy | Write-heavy |

---

# Part III: Advanced Data Structures

## Chapter 10: Heap / Priority Queue

### 10.1 Heap Properties
- Complete Binary Tree
- Max-Heap: Parent â‰¥ Children
- Min-Heap: Parent â‰¤ Children

### 10.2 Array Representation
```
Parent(i) = (i-1) / 2
Left(i) = 2*i + 1
Right(i) = 2*i + 2
```

### 10.3 Heap Operations
| Operation | Complexity |
|-----------|------------|
| Insert (heapify up) | O(log n) |
| Extract Max/Min | O(log n) |
| Get Max/Min | O(1) |
| Build Heap | O(n) |
| Heapify | O(log n) |

> ğŸ”¥ **Critical**: Building heap is O(n), NOT O(n log n)

### 10.4 Heap Applications
- Priority Queue implementation
- Heap Sort: O(n log n), in-place
- Kth largest/smallest element
- Merge K sorted arrays
- Median in stream
- Top K frequent elements

### 10.5 Two-Heap Pattern
- Use Max-Heap + Min-Heap for median finding
- Max-heap for smaller half, Min-heap for larger half

---

## Chapter 11: Trie (Prefix Tree)

### 11.1 Structure
- Each node contains array/map of children
- Boolean flag for end of word
- Root is empty

### 11.2 Trie Node
```
class TrieNode:
    children: HashMap<char, TrieNode>
    isEndOfWord: boolean
```

### 11.3 Trie Operations
| Operation | Complexity |
|-----------|------------|
| Insert | O(L) |
| Search | O(L) |
| Prefix Search | O(L) |
| Delete | O(L) |

Where L = length of word

### 11.4 Trie Applications
- Autocomplete
- Spell checker
- IP routing (Longest prefix match)
- Word games (Boggle)
- Search engine suggestions

### 11.5 Trie Variations

#### 11.5.1 Compressed Trie (Radix Tree)
- Merge chains of single-child nodes
- Space efficient

#### 11.5.2 Suffix Trie
- Insert all suffixes of a string
- Pattern matching in O(m) after O(nÂ²) build

#### 11.5.3 Suffix Tree
- Compressed suffix trie
- Build in O(n) using Ukkonen's algorithm

> ğŸ’¡ **Advanced**: Suffix trees/arrays are asked in very hard interviews

### 11.6 Trie Problem Patterns
- Word Search II (use Trie + DFS)
- Longest Common Prefix
- Maximum XOR (using bit-trie)
- Stream of Characters
- Palindrome Pairs

---

## Chapter 12: Segment Tree

### 12.1 Purpose
- Range queries: O(log n)
- Point updates: O(log n)
- Build: O(n)

### 12.2 When to Use
- Multiple range queries
- Point updates
- Range: sum, min, max, GCD, etc.

### 12.3 Structure
- Full binary tree
- Leaf nodes = array elements
- Internal nodes = aggregate of children
- Size = 4 * n (safe allocation)

### 12.4 Build Process
```
build(node, start, end):
    if start == end:
        tree[node] = arr[start]
    else:
        mid = (start + end) / 2
        build(2*node, start, mid)
        build(2*node+1, mid+1, end)
        tree[node] = tree[2*node] + tree[2*node+1]
```

### 12.5 Query Process
```
query(node, start, end, L, R):
    if R < start or L > end: return 0  # Outside
    if L <= start and end <= R: return tree[node]  # Complete overlap
    # Partial overlap
    mid = (start + end) / 2
    return query(left) + query(right)
```

### 12.6 Lazy Propagation
- For range updates
- Defer updates until needed
- Essential for range update queries

> ğŸ”¥ **Critical**: Without lazy propagation, range updates are O(n). With lazy: O(log n)

### 12.7 Segment Tree Problems
- Range Sum Query - Mutable
- Count of Smaller Numbers After Self
- Range Minimum Query
- Rectangle Area (2D)

---

## Chapter 13: Fenwick Tree (Binary Indexed Tree)

### 13.1 Purpose
- Point update: O(log n)
- Prefix sum: O(log n)
- Range sum: O(log n)
- Build: O(n log n) or O(n)

### 13.2 Advantages over Segment Tree
- Less space: O(n) vs O(4n)
- Simpler implementation
- Better constants

### 13.3 Limitations
- Only for operations with inverse (sum, XOR)
- Cannot do range min/max efficiently

### 13.4 Key Operations
```
LSB(i) = i & (-i)  # Lowest Set Bit

Update(i, delta):
    while i <= n:
        BIT[i] += delta
        i += LSB(i)

PrefixSum(i):
    sum = 0
    while i > 0:
        sum += BIT[i]
        i -= LSB(i)
    return sum
```

### 13.5 2D Fenwick Tree
- For 2D range sum queries
- Update: O(log n * log m)
- Query: O(log n * log m)

---

## Chapter 14: N-ary Trees

### 14.1 Structure
```
class Node:
    val: int
    children: List[Node]
```

### 14.2 N-ary Tree Traversals
- Preorder: root â†’ children (left to right)
- Postorder: children (left to right) â†’ root
- Level Order: BFS with queue

### 14.3 Encode/Decode N-ary to Binary
- Left-child right-sibling representation
- First child â†’ left child
- Next sibling â†’ right child

---

# Part IV: Tree Patterns & Techniques

## Chapter 15: Essential Tree Patterns

### 15.1 Pattern: Recursive DFS
```
def dfs(node):
    if not node: return base_case
    
    left = dfs(node.left)
    right = dfs(node.right)
    
    return combine(left, right, node.val)
```

### 15.2 Pattern: Level Order BFS
```
def bfs(root):
    queue = [root]
    while queue:
        level_size = len(queue)
        for _ in range(level_size):
            node = queue.pop(0)
            process(node)
            if node.left: queue.append(node.left)
            if node.right: queue.append(node.right)
```

### 15.3 Pattern: Tree DP
- State at each node depends on subtrees
- Process children first (postorder style)
- Examples: House Robber III, Max Path Sum

### 15.4 Pattern: Iterative with Stack
```
def iterative_preorder(root):
    stack = [root]
    while stack:
        node = stack.pop()
        process(node)
        if node.right: stack.append(node.right)  # Right first
        if node.left: stack.append(node.left)
```

### 15.5 Pattern: Parent Pointers / BFS from Node
- Treat tree as graph
- BFS to find nodes at distance K

### 15.6 Pattern: Serialize/Deserialize
- Preorder + null markers
- Level order + null markers

---

## Chapter 16: Common Techniques

### 16.1 Using HashMap in Trees
- Store node values for O(1) lookup
- Prefix sums in path problems
- Vertical/diagonal traversal

### 16.2 Using Global Variables
- Track max/min across recursive calls
- Diameter, max path sum problems

### 16.3 Using Return Value vs Side Effect
- Return value: cleaner, functional
- Side effect: sometimes necessary for complex state

### 16.4 Top-Down vs Bottom-Up
| Top-Down | Bottom-Up |
|----------|-----------|
| Pass info from root to leaves | Gather info from leaves to root |
| Use parameters | Use return values |
| Preorder style | Postorder style |

### 16.5 Binary Lifting Technique
- Precompute 2^i-th ancestor for each node
- Answer LCA, kth ancestor in O(log n)

---

## Chapter 17: Hard Interview Problems

### 17.1 Must-Solve Problems List

#### Traversal & Views
- [ ] Binary Tree Right Side View
- [ ] Vertical Order Traversal
- [ ] Boundary Traversal
- [ ] Zigzag Level Order

#### Construction
- [ ] Construct from Inorder + Preorder
- [ ] Construct from Inorder + Postorder
- [ ] Serialize and Deserialize Binary Tree
- [ ] Serialize and Deserialize BST

#### BST Problems
- [ ] Validate BST
- [ ] Recover BST
- [ ] Kth Smallest in BST
- [ ] Convert BST to Greater Tree

#### Path Problems
- [ ] Binary Tree Maximum Path Sum
- [ ] Path Sum III (count paths with sum K)
- [ ] Longest Univalue Path
- [ ] Sum of Distances in Tree

#### LCA & Distance
- [ ] LCA of Binary Tree
- [ ] LCA of Deepest Leaves
- [ ] All Nodes Distance K

#### Advanced
- [ ] Count Complete Tree Nodes (O(logÂ²n))
- [ ] Populating Next Right Pointers
- [ ] Binary Tree Cameras
- [ ] Maximum Sum BST in Binary Tree

### 17.2 Google/Meta Level Problems
- [ ] Amount of Time to Infect Binary Tree
- [ ] Number of Good Leaf Nodes Pairs
- [ ] Operations on Tree
- [ ] Step-By-Step Directions

---

## Chapter 18: Time & Space Complexity Summary

### 18.1 Common Operations
| Structure | Search | Insert | Delete |
|-----------|--------|--------|--------|
| BST (avg) | O(log n) | O(log n) | O(log n) |
| BST (worst) | O(n) | O(n) | O(n) |
| AVL/RB Tree | O(log n) | O(log n) | O(log n) |
| Heap | O(n) | O(log n) | O(log n) |
| Trie | O(L) | O(L) | O(L) |

### 18.2 Traversal Complexities
| Traversal | Time | Space (Recursive) | Space (Iterative) |
|-----------|------|-------------------|-------------------|
| DFS | O(n) | O(h) | O(h) |
| BFS | O(n) | - | O(w) |
| Morris | O(n) | O(1) | O(1) |

Where h = height, w = max width

### 18.3 Advanced Structures
| Structure | Build | Query | Update |
|-----------|-------|-------|--------|
| Segment Tree | O(n) | O(log n) | O(log n) |
| Fenwick Tree | O(n log n) | O(log n) | O(log n) |
| Sparse Table | O(n log n) | O(1) | N/A |

---

## Chapter 19: Interview Tips & Tricks

### 19.1 Before Coding
1. Clarify: binary tree or BST?
2. Ask about duplicates
3. Confirm input constraints
4. Discuss approach before coding

### 19.2 Common Mistakes to Avoid
- âŒ Forgetting null checks
- âŒ Not handling empty tree
- âŒ Confusing height vs depth
- âŒ Wrong base case in recursion
- âŒ Not considering skewed trees

### 19.3 Optimization Hints
- If asked for O(1) space â†’ Think Morris Traversal
- If asked for O(n) with constant queries â†’ Precompute
- If multiple queries â†’ Think preprocessing
- If modification needed â†’ Think lazy propagation

### 19.4 Pattern Recognition
| Problem Asks For | Think About |
|-----------------|-------------|
| Sorted order | Inorder traversal |
| Level-by-level | BFS |
| Path from root | DFS with backtrack |
| Any-to-any path | DP at each node |
| Range queries | Segment Tree / BIT |
| Prefix search | Trie |

---

## Quick Reference Card

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  TREE CHEAT SHEET                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Traversals:                                             â”‚
â”‚   Pre:  Root â†’ L â†’ R    (Copy tree, serialize)          â”‚
â”‚   In:   L â†’ Root â†’ R    (BST sorted, validate)          â”‚
â”‚   Post: L â†’ R â†’ Root    (Delete, calc size)             â”‚
â”‚   BFS:  Level by level  (Right view, zigzag)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ BST Delete: Leafâ†’remove, 1-childâ†’replace, 2â†’successor   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Balance Factor = Height(L) - Height(R)                  â”‚
â”‚ AVL: |BF| â‰¤ 1 for all nodes                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Heap: Parent=(i-1)/2, Left=2i+1, Right=2i+2            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Segment Tree: Build O(n), Query O(log n), Update O(log n)â”‚
â”‚ Fenwick Tree:  O(log n) prefix sum and point update     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ LCA(BST): Split point where p,q diverge â†’ O(h)          â”‚
â”‚ LCA(BT):  Recursive search both subtrees â†’ O(n)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Construction needs: INORDER + (PREORDER or POSTORDER)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

*Master these concepts, practice the patterns, and you'll be ready for any tree problem in your interview!*
