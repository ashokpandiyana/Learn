# Chapter 2: JavaScript Fundamentals for Design Patterns

## 2.1 Core Concepts (Prerequisites)

Before implementing design patterns, you must master these JavaScript fundamentals. These concepts are the building blocks of every pattern.

---

### First-Class Functions

In JavaScript, functions are **first-class citizens**. This means functions can be:
- Assigned to variables
- Passed as arguments to other functions
- Returned from other functions
- Stored in data structures

```javascript
// 1. Assigned to variables
const greet = function(name) {
  return `Hello, ${name}!`;
};

// 2. Passed as arguments (callback)
function processUser(user, callback) {
  // Process user...
  callback(user);
}

processUser({ name: 'John' }, (user) => {
  console.log(`Processed: ${user.name}`);
});

// 3. Returned from functions (Higher-Order Function)
function createMultiplier(multiplier) {
  return function(number) {
    return number * multiplier;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15

// 4. Stored in data structures
const operations = {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b,
  multiply: (a, b) => a * b,
};

console.log(operations.add(5, 3)); // 8
```

> ðŸ’¡ **Pattern Connection:** First-class functions enable Strategy, Command, and Factory patterns in JavaScript without needing traditional class hierarchies.

---

### Closures and Lexical Scope

A **closure** is a function that has access to variables from its outer (enclosing) scope, even after the outer function has returned.

```javascript
// Basic Closure Example
function createCounter() {
  let count = 0; // Private variable
  
  return {
    increment() {
      count++;
      return count;
    },
    decrement() {
      count--;
      return count;
    },
    getCount() {
      return count;
    }
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount());  // 2
console.log(counter.count);       // undefined (private!)
```

#### Visualizing Closure Scope

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    GLOBAL SCOPE                              â”‚
â”‚                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚          createCounter() SCOPE                       â”‚   â”‚
â”‚   â”‚                                                     â”‚   â”‚
â”‚   â”‚   let count = 0  â—„â”€â”€â”€ Private variable              â”‚   â”‚
â”‚   â”‚                                                     â”‚   â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚   â”‚   â”‚     increment() SCOPE                       â”‚   â”‚   â”‚
â”‚   â”‚   â”‚                                             â”‚   â”‚   â”‚
â”‚   â”‚   â”‚     Has access to 'count' via closure â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
â”‚   â”‚   â”‚                                             â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚   â”‚                                                     â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Practical Pattern: Module Pattern with Closures

```javascript
// The Module Pattern - Foundation of many design patterns
const UserModule = (function() {
  // Private members
  const users = [];
  let nextId = 1;
  
  function validateEmail(email) {
    return email.includes('@');
  }
  
  // Public API (revealed)
  return {
    addUser(name, email) {
      if (!validateEmail(email)) {
        throw new Error('Invalid email');
      }
      const user = { id: nextId++, name, email };
      users.push(user);
      return user;
    },
    
    getUser(id) {
      return users.find(u => u.id === id);
    },
    
    getAllUsers() {
      return [...users]; // Return copy to prevent mutation
    }
  };
})();

UserModule.addUser('Alice', 'alice@example.com');
console.log(UserModule.getAllUsers());
// users array is not directly accessible
console.log(UserModule.users); // undefined
```

---

### The `this` Keyword and Context Binding

Understanding `this` is crucial for patterns involving object methods and callbacks.

#### Rules for `this` Binding

```javascript
// Rule 1: Default Binding (Global object or undefined in strict mode)
function showThis() {
  console.log(this);
}
showThis(); // Window (browser) or global (Node.js) or undefined (strict)

// Rule 2: Implicit Binding (Object method)
const obj = {
  name: 'MyObject',
  getName() {
    return this.name;
  }
};
console.log(obj.getName()); // 'MyObject'

// Rule 3: Explicit Binding (call, apply, bind)
function greet(greeting) {
  return `${greeting}, ${this.name}`;
}

const person = { name: 'John' };

console.log(greet.call(person, 'Hello'));    // 'Hello, John'
console.log(greet.apply(person, ['Hi']));    // 'Hi, John'

const boundGreet = greet.bind(person);
console.log(boundGreet('Hey'));              // 'Hey, John'

// Rule 4: new Binding (Constructor)
function User(name) {
  this.name = name;
}
const user = new User('Alice');
console.log(user.name); // 'Alice'

// Rule 5: Arrow Functions (Lexical this - inherits from parent)
const team = {
  name: 'Developers',
  members: ['Alice', 'Bob'],
  
  // Regular function loses 'this' context
  showMembersBad() {
    this.members.forEach(function(member) {
      console.log(`${member} is in ${this.name}`); // this.name is undefined!
    });
  },
  
  // Arrow function preserves 'this' context
  showMembersGood() {
    this.members.forEach((member) => {
      console.log(`${member} is in ${this.name}`); // Works!
    });
  }
};
```

#### Common `this` Pitfalls and Solutions

```javascript
class EventHandler {
  constructor() {
    this.count = 0;
  }
  
  // Problem: 'this' is lost when method is passed as callback
  handleClick() {
    this.count++;
    console.log(`Clicked ${this.count} times`);
  }
}

const handler = new EventHandler();

// âŒ WRONG: 'this' will be undefined or wrong context
// button.addEventListener('click', handler.handleClick);

// âœ… Solution 1: Bind in constructor
class EventHandlerFixed1 {
  constructor() {
    this.count = 0;
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() { /* ... */ }
}

// âœ… Solution 2: Arrow function class field
class EventHandlerFixed2 {
  count = 0;
  handleClick = () => {
    this.count++;
    console.log(`Clicked ${this.count} times`);
  }
}

// âœ… Solution 3: Bind at call site
// button.addEventListener('click', handler.handleClick.bind(handler));

// âœ… Solution 4: Arrow wrapper
// button.addEventListener('click', () => handler.handleClick());
```

---

### Prototypal Inheritance vs Classical Inheritance

JavaScript uses **prototypal inheritance**, not classical inheritance like Java or C++.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              CLASSICAL vs PROTOTYPAL INHERITANCE             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  CLASSICAL (Java, C++)          PROTOTYPAL (JavaScript)     â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚
â”‚                                                             â”‚
â”‚  Class â†’ Instance               Object â†’ Object             â”‚
â”‚  Blueprint â†’ Copy               Prototype â†’ Link            â”‚
â”‚  Rigid hierarchy                Flexible chain              â”‚
â”‚  Compile-time                   Runtime modification        â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```javascript
// Understanding the Prototype Chain
const animal = {
  eats: true,
  walk() {
    console.log('Walking...');
  }
};

const dog = Object.create(animal);
dog.barks = true;

console.log(dog.eats);    // true (inherited from animal)
console.log(dog.barks);   // true (own property)
dog.walk();               // 'Walking...' (inherited method)

// Prototype chain visualization
console.log(dog.__proto__ === animal);              // true
console.log(animal.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__);            // null (end of chain)
```

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PROTOTYPE CHAIN                           â”‚
â”‚                                                             â”‚
â”‚   dog                                                       â”‚
â”‚   â”œâ”€â”€ barks: true                                           â”‚
â”‚   â””â”€â”€ [[Prototype]] â”€â”€â–º animal                              â”‚
â”‚                         â”œâ”€â”€ eats: true                      â”‚
â”‚                         â”œâ”€â”€ walk: function                  â”‚
â”‚                         â””â”€â”€ [[Prototype]] â”€â”€â–º Object.prototype
â”‚                                               â”œâ”€â”€ toString  â”‚
â”‚                                               â”œâ”€â”€ hasOwnProperty
â”‚                                               â””â”€â”€ [[Prototype]] â”€â”€â–º null
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ES6 Classes (Syntactic Sugar)

ES6 classes are syntactic sugar over JavaScript's prototype-based inheritance.

```javascript
// ES6 Class Syntax
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    console.log(`${this.name} makes a sound`);
  }
  
  // Static method (on class, not instances)
  static isAnimal(obj) {
    return obj instanceof Animal;
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // Call parent constructor
    this.breed = breed;
  }
  
  speak() {
    console.log(`${this.name} barks!`);
  }
  
  // Method unique to Dog
  fetch() {
    console.log(`${this.name} fetches the ball`);
  }
}

const rex = new Dog('Rex', 'German Shepherd');
rex.speak();  // 'Rex barks!'
rex.fetch();  // 'Rex fetches the ball'
console.log(Animal.isAnimal(rex)); // true

// Under the hood, it's still prototypes!
console.log(rex.__proto__ === Dog.prototype);        // true
console.log(Dog.prototype.__proto__ === Animal.prototype); // true
```

---

## 2.2 Object Creation Techniques

JavaScript offers multiple ways to create objects. Each has its use case.

```javascript
// 1. Object Literals (Simple, ad-hoc objects)
const user1 = {
  name: 'Alice',
  greet() { return `Hello, ${this.name}`; }
};

// 2. Constructor Functions (Pre-ES6 pattern)
function User(name) {
  this.name = name;
}
User.prototype.greet = function() {
  return `Hello, ${this.name}`;
};
const user2 = new User('Bob');

// 3. Object.create() (Explicit prototype setting)
const userProto = {
  greet() { return `Hello, ${this.name}`; }
};
const user3 = Object.create(userProto);
user3.name = 'Charlie';

// 4. ES6 Classes (Modern, readable syntax)
class UserClass {
  constructor(name) {
    this.name = name;
  }
  greet() { return `Hello, ${this.name}`; }
}
const user4 = new UserClass('Diana');

// 5. Factory Functions (No 'new' keyword, flexible)
function createUser(name) {
  return {
    name,
    greet() { return `Hello, ${this.name}`; }
  };
}
const user5 = createUser('Eve');
```

### Comparison Table

| Method | Uses `new` | Prototype Chain | Private Data | Flexibility |
|--------|-----------|-----------------|--------------|-------------|
| Object Literal | No | Object.prototype | Closure trick | Low |
| Constructor Function | Yes | Custom | Closure/WeakMap | Medium |
| Object.create | No | Custom | No | High |
| ES6 Class | Yes | Custom | Private fields (#) | Medium |
| Factory Function | No | Object.prototype | Closure | Very High |

---

## 2.3 Advanced JavaScript Concepts

### IIFE (Immediately Invoked Function Expressions)

```javascript
// Creates a new scope immediately
(function() {
  const privateVar = 'I am private';
  console.log('IIFE executed!');
})();

// With arrow function
(() => {
  console.log('Arrow IIFE');
})();

// Returning a value
const counter = (function() {
  let count = 0;
  return {
    increment: () => ++count,
    decrement: () => --count,
    get: () => count
  };
})();
```

### Higher-Order Functions

Functions that take or return other functions.

```javascript
// Takes function as argument
function repeat(n, action) {
  for (let i = 0; i < n; i++) {
    action(i);
  }
}

repeat(3, console.log); // 0, 1, 2

// Returns function
function unless(test, then) {
  if (!test) then();
}

// Array methods are higher-order functions
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2);
const evens = numbers.filter(n => n % 2 === 0);
const sum = numbers.reduce((acc, n) => acc + n, 0);
```

### Currying and Partial Application

```javascript
// Currying: Transform f(a, b, c) to f(a)(b)(c)
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    return function(...moreArgs) {
      return curried.apply(this, args.concat(moreArgs));
    };
  };
}

function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3));   // 6
console.log(curriedAdd(1, 2)(3));   // 6
console.log(curriedAdd(1)(2, 3));   // 6

// Practical use: Creating specialized functions
const log = curry((date, importance, message) => {
  console.log(`[${date.toISOString()}] [${importance}] ${message}`);
});

const logNow = log(new Date());
const logNowInfo = logNow('INFO');

logNowInfo('User logged in');   // [2024-01-01T...] [INFO] User logged in
logNowInfo('Data processed');   // [2024-01-01T...] [INFO] Data processed
```

### Memoization

Caching function results for expensive computations.

```javascript
function memoize(fn) {
  const cache = new Map();
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      console.log('Cache hit!');
      return cache.get(key);
    }
    
    console.log('Computing...');
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// Example: Expensive Fibonacci
const fibonacci = memoize(function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
});

console.log(fibonacci(40)); // Fast with memoization
console.log(fibonacci(40)); // Cache hit!
```

### Proxy and Reflect API

```javascript
// Proxy: Intercept and customize object operations
const user = {
  name: 'John',
  age: 30
};

const userProxy = new Proxy(user, {
  get(target, property) {
    console.log(`Getting ${property}`);
    return Reflect.get(target, property);
  },
  
  set(target, property, value) {
    console.log(`Setting ${property} to ${value}`);
    if (property === 'age' && typeof value !== 'number') {
      throw new TypeError('Age must be a number');
    }
    return Reflect.set(target, property, value);
  }
});

userProxy.name;        // "Getting name"
userProxy.age = 31;    // "Setting age to 31"
userProxy.age = 'old'; // TypeError: Age must be a number
```

### WeakMap and WeakSet for Private Data

```javascript
// Private data without memory leaks
const privateData = new WeakMap();

class Person {
  constructor(name, ssn) {
    this.name = name;
    // SSN is truly private - not accessible outside
    privateData.set(this, { ssn });
  }
  
  getSSNLastFour() {
    const data = privateData.get(this);
    return data.ssn.slice(-4);
  }
}

const person = new Person('John', '123-45-6789');
console.log(person.name);           // 'John'
console.log(person.getSSNLastFour()); // '6789'
console.log(person.ssn);            // undefined
console.log(privateData.get(person)); // Only accessible if you have WeakMap ref
```

### Symbols for Unique Property Keys

```javascript
// Symbols create unique, non-enumerable keys
const id = Symbol('id');
const secretKey = Symbol('secret');

const user = {
  name: 'Alice',
  [id]: 12345,
  [secretKey]: 'classified'
};

console.log(user.name);      // 'Alice'
console.log(user[id]);       // 12345
console.log(Object.keys(user)); // ['name'] - Symbols not included

// Well-known Symbols for metaprogramming
class Collection {
  constructor() {
    this.items = [];
  }
  
  add(item) {
    this.items.push(item);
  }
  
  // Make the class iterable
  [Symbol.iterator]() {
    let index = 0;
    const items = this.items;
    
    return {
      next() {
        if (index < items.length) {
          return { value: items[index++], done: false };
        }
        return { done: true };
      }
    };
  }
}

const collection = new Collection();
collection.add('a');
collection.add('b');

for (const item of collection) {
  console.log(item); // 'a', 'b'
}
```

---

## Key Takeaways

1. **First-class functions** enable functional patterns in JavaScript
2. **Closures** are fundamental to Module, Singleton, and Factory patterns
3. **`this`** binding rules affect how object methods work in callbacks
4. **Prototypal inheritance** differs from classical - understand the chain
5. **ES6 classes** are syntactic sugar over prototypes
6. **Multiple object creation techniques** suit different patterns
7. **Advanced features** (Proxy, WeakMap, Symbol) enable sophisticated patterns

> ðŸŽ¯ **Interview Tip:** Be ready to explain the difference between `__proto__`, `prototype`, and `Object.getPrototypeOf()`. Interviewers love this question!

```javascript
// The answer:
function Foo() {}
const foo = new Foo();

// prototype: Property on constructor function
console.log(Foo.prototype); // The prototype object

// __proto__: Internal link to prototype (deprecated, use Object.getPrototypeOf)
console.log(foo.__proto__ === Foo.prototype); // true

// Object.getPrototypeOf: Modern way to get prototype
console.log(Object.getPrototypeOf(foo) === Foo.prototype); // true
```
