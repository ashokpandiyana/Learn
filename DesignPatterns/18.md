# Chapter 18: Mediator Pattern

## 18.1 Concept

### What is the Mediator Pattern?

The Mediator Pattern defines an object that **encapsulates how a set of objects interact**. It promotes loose coupling by preventing objects from referring to each other explicitly, letting you vary their interaction independently.

Think of an **air traffic controller**: planes don't communicate directly with each other; they communicate through the controller who coordinates all interactions.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MEDIATOR PATTERN                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   WITHOUT MEDIATOR:              WITH MEDIATOR:             â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â”‚
â”‚                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”         â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”      â”‚
â”‚   â”‚ A â”‚â”€â”€â”€â”‚ B â”‚â”€â”€â”€â”‚ C â”‚         â”‚ A â”‚   â”‚ B â”‚   â”‚ C â”‚      â”‚
â”‚   â””â”€â”¬â”€â”˜   â””â”€â”¬â”€â”˜   â””â”€â”¬â”€â”˜         â””â”€â”¬â”€â”˜   â””â”€â”¬â”€â”˜   â””â”€â”¬â”€â”˜      â”‚
â”‚     â”‚   â•²   â”‚   â•±   â”‚             â”‚       â”‚       â”‚        â”‚
â”‚     â”‚    â•²  â”‚  â•±    â”‚             â”‚       â”‚       â”‚        â”‚
â”‚     â”‚     â•² â”‚ â•±     â”‚             â–¼       â–¼       â–¼        â”‚
â”‚   â”Œâ”€â”´â”€â”   â”Œâ”€â”´â”€â”   â”Œâ”€â”´â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚ D â”‚â”€â”€â”€â”‚ E â”‚â”€â”€â”€â”‚ F â”‚         â”‚      MEDIATOR       â”‚    â”‚
â”‚   â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜         â”‚   (Coordinator)     â”‚    â”‚
â”‚                                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚   Every object knows            Objects only know          â”‚
â”‚   about every other             about mediator             â”‚
â”‚   N(N-1)/2 connections          N connections              â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Mediator vs Observer vs Pub/Sub

| Pattern | Communication | Coupling | Direction |
|---------|--------------|----------|-----------|
| **Observer** | Subject â†’ Observers | Subject knows observers | One-to-many |
| **Pub/Sub** | Through broker | Complete decoupling | Many-to-many |
| **Mediator** | Through mediator | Colleagues know mediator | Many-to-many, bidirectional |

### When to Use Mediator

- Objects communicate in **complex but well-defined ways**
- Reusing objects is difficult due to **many interconnections**
- Behavior distributed between classes should be **customizable**
- You want to **avoid tight coupling** between interacting objects

---

## 18.2 Implementation

### Chat Room Example

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MEDIATOR INTERFACE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class ChatMediator {
  sendMessage(message, sender) {
    throw new Error('Must implement sendMessage');
  }
  
  addUser(user) {
    throw new Error('Must implement addUser');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONCRETE MEDIATOR: Chat Room
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class ChatRoom extends ChatMediator {
  constructor(name) {
    super();
    this.name = name;
    this.users = new Map();
    this.messageHistory = [];
  }
  
  addUser(user) {
    this.users.set(user.name, user);
    user.setMediator(this);
    
    // Notify existing users
    this.broadcast(`${user.name} has joined the chat`, null);
    
    console.log(`[${this.name}] ${user.name} joined`);
  }
  
  removeUser(user) {
    this.users.delete(user.name);
    this.broadcast(`${user.name} has left the chat`, null);
    console.log(`[${this.name}] ${user.name} left`);
  }
  
  sendMessage(message, sender) {
    const formattedMessage = {
      from: sender?.name || 'System',
      text: message,
      timestamp: new Date().toISOString(),
      type: 'message'
    };
    
    this.messageHistory.push(formattedMessage);
    
    // Send to all users except sender
    this.users.forEach((user, name) => {
      if (name !== sender?.name) {
        user.receive(formattedMessage);
      }
    });
  }
  
  sendPrivateMessage(message, sender, recipientName) {
    const recipient = this.users.get(recipientName);
    
    if (!recipient) {
      sender.receive({
        from: 'System',
        text: `User "${recipientName}" not found`,
        type: 'error'
      });
      return;
    }
    
    const formattedMessage = {
      from: sender.name,
      text: message,
      timestamp: new Date().toISOString(),
      type: 'private'
    };
    
    recipient.receive(formattedMessage);
    sender.receive({ ...formattedMessage, text: `(To ${recipientName}): ${message}` });
  }
  
  broadcast(message, sender) {
    const formattedMessage = {
      from: sender?.name || 'System',
      text: message,
      timestamp: new Date().toISOString(),
      type: 'broadcast'
    };
    
    this.users.forEach(user => {
      if (user !== sender) {
        user.receive(formattedMessage);
      }
    });
  }
  
  getUserList() {
    return [...this.users.keys()];
  }
  
  getHistory(limit = 10) {
    return this.messageHistory.slice(-limit);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLLEAGUE: User
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class User {
  constructor(name) {
    this.name = name;
    this.mediator = null;
    this.inbox = [];
  }
  
  setMediator(mediator) {
    this.mediator = mediator;
  }
  
  send(message) {
    console.log(`[${this.name}] Sending: "${message}"`);
    this.mediator.sendMessage(message, this);
  }
  
  sendPrivate(message, recipientName) {
    console.log(`[${this.name}] Private to ${recipientName}: "${message}"`);
    this.mediator.sendPrivateMessage(message, this, recipientName);
  }
  
  receive(message) {
    this.inbox.push(message);
    
    const prefix = message.type === 'private' ? '(Private) ' : '';
    console.log(`[${this.name}] Received ${prefix}from ${message.from}: "${message.text}"`);
  }
  
  showInbox() {
    console.log(`\n[${this.name}]'s Inbox:`);
    this.inbox.forEach(msg => {
      console.log(`  ${msg.from}: ${msg.text}`);
    });
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USAGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const chatRoom = new ChatRoom('General');

const alice = new User('Alice');
const bob = new User('Bob');
const charlie = new User('Charlie');

// Users join the chat (through mediator)
chatRoom.addUser(alice);
chatRoom.addUser(bob);
chatRoom.addUser(charlie);

console.log('\n--- Messages ---\n');

// Public messages (go through mediator)
alice.send('Hello everyone!');
bob.send('Hi Alice!');

// Private message
charlie.sendPrivate('Hey Alice, got a minute?', 'Alice');

// Bob doesn't see the private message
console.log('\n--- User List ---');
console.log('Online users:', chatRoom.getUserList());

// Show inboxes
alice.showInbox();
bob.showInbox();
charlie.showInbox();
```

### Form Validation Mediator

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FORM MEDIATOR: Coordinates form field interactions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class FormMediator {
  constructor() {
    this.fields = new Map();
    this.submitButton = null;
    this.errors = new Map();
  }
  
  registerField(field) {
    this.fields.set(field.name, field);
    field.setMediator(this);
  }
  
  registerSubmitButton(button) {
    this.submitButton = button;
    button.setMediator(this);
  }
  
  // Called when any field changes
  fieldChanged(field, value) {
    console.log(`[Mediator] Field "${field.name}" changed to "${value}"`);
    
    // Validate the changed field
    const error = field.validate();
    if (error) {
      this.errors.set(field.name, error);
    } else {
      this.errors.delete(field.name);
    }
    
    // Handle field dependencies
    this.#handleDependencies(field, value);
    
    // Update submit button state
    this.#updateSubmitButton();
  }
  
  #handleDependencies(changedField, value) {
    // Country â†’ State dependency
    if (changedField.name === 'country') {
      const stateField = this.fields.get('state');
      if (stateField) {
        stateField.updateOptions(this.#getStatesForCountry(value));
        stateField.clear();
      }
    }
    
    // Password â†’ Confirm Password dependency
    if (changedField.name === 'password') {
      const confirmField = this.fields.get('confirmPassword');
      if (confirmField && confirmField.getValue()) {
        const error = confirmField.validate();
        if (error) {
          this.errors.set('confirmPassword', error);
        } else {
          this.errors.delete('confirmPassword');
        }
      }
    }
    
    // Email â†’ Username suggestion
    if (changedField.name === 'email' && value.includes('@')) {
      const usernameField = this.fields.get('username');
      if (usernameField && !usernameField.getValue()) {
        const suggestedUsername = value.split('@')[0];
        usernameField.setSuggestion(suggestedUsername);
      }
    }
  }
  
  #getStatesForCountry(country) {
    const states = {
      'USA': ['California', 'New York', 'Texas', 'Florida'],
      'Canada': ['Ontario', 'Quebec', 'British Columbia'],
      'UK': ['England', 'Scotland', 'Wales']
    };
    return states[country] || [];
  }
  
  #updateSubmitButton() {
    if (!this.submitButton) return;
    
    // Check if all required fields are filled
    let allFilled = true;
    this.fields.forEach(field => {
      if (field.required && !field.getValue()) {
        allFilled = false;
      }
    });
    
    // Enable button only if no errors and all required fields filled
    const canSubmit = this.errors.size === 0 && allFilled;
    this.submitButton.setEnabled(canSubmit);
  }
  
  validateAll() {
    this.errors.clear();
    
    this.fields.forEach(field => {
      const error = field.validate();
      if (error) {
        this.errors.set(field.name, error);
      }
    });
    
    return this.errors.size === 0;
  }
  
  getFormData() {
    const data = {};
    this.fields.forEach((field, name) => {
      data[name] = field.getValue();
    });
    return data;
  }
  
  getErrors() {
    return Object.fromEntries(this.errors);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FORM FIELDS (Colleagues)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class FormField {
  constructor(name, options = {}) {
    this.name = name;
    this.value = '';
    this.required = options.required || false;
    this.validators = options.validators || [];
    this.mediator = null;
    this.suggestion = null;
  }
  
  setMediator(mediator) {
    this.mediator = mediator;
  }
  
  setValue(value) {
    this.value = value;
    this.suggestion = null;
    // Notify mediator
    this.mediator.fieldChanged(this, value);
  }
  
  getValue() {
    return this.value;
  }
  
  clear() {
    this.value = '';
    this.suggestion = null;
  }
  
  setSuggestion(suggestion) {
    this.suggestion = suggestion;
    console.log(`[${this.name}] Suggestion: "${suggestion}"`);
  }
  
  acceptSuggestion() {
    if (this.suggestion) {
      this.setValue(this.suggestion);
    }
  }
  
  validate() {
    if (this.required && !this.value) {
      return `${this.name} is required`;
    }
    
    for (const validator of this.validators) {
      const error = validator(this.value);
      if (error) return error;
    }
    
    return null;
  }
}

class SelectField extends FormField {
  constructor(name, options = {}) {
    super(name, options);
    this.options = options.options || [];
  }
  
  updateOptions(options) {
    this.options = options;
    console.log(`[${this.name}] Options updated:`, options);
  }
  
  getOptions() {
    return this.options;
  }
}

class PasswordField extends FormField {
  constructor(name, options = {}) {
    super(name, options);
    this.confirmField = options.confirmField;
  }
  
  validate() {
    const baseError = super.validate();
    if (baseError) return baseError;
    
    if (this.name === 'confirmPassword') {
      const passwordField = this.mediator.fields.get('password');
      if (passwordField && this.value !== passwordField.getValue()) {
        return 'Passwords do not match';
      }
    }
    
    return null;
  }
}

class SubmitButton {
  constructor(label) {
    this.label = label;
    this.enabled = false;
    this.mediator = null;
  }
  
  setMediator(mediator) {
    this.mediator = mediator;
  }
  
  setEnabled(enabled) {
    this.enabled = enabled;
    console.log(`[Submit Button] ${enabled ? 'ENABLED' : 'DISABLED'}`);
  }
  
  click() {
    if (!this.enabled) {
      console.log('[Submit Button] Cannot submit - button disabled');
      return;
    }
    
    if (this.mediator.validateAll()) {
      console.log('[Submit Button] Form submitted!');
      console.log('Form Data:', this.mediator.getFormData());
    } else {
      console.log('[Submit Button] Validation failed');
      console.log('Errors:', this.mediator.getErrors());
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USAGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const formMediator = new FormMediator();

// Create fields
const emailField = new FormField('email', {
  required: true,
  validators: [
    (value) => {
      if (value && !value.includes('@')) return 'Invalid email format';
      return null;
    }
  ]
});

const usernameField = new FormField('username', {
  required: true,
  validators: [
    (value) => {
      if (value && value.length < 3) return 'Username must be at least 3 characters';
      return null;
    }
  ]
});

const passwordField = new PasswordField('password', {
  required: true,
  validators: [
    (value) => {
      if (value && value.length < 8) return 'Password must be at least 8 characters';
      return null;
    }
  ]
});

const confirmPasswordField = new PasswordField('confirmPassword', {
  required: true
});

const countryField = new SelectField('country', {
  required: true,
  options: ['USA', 'Canada', 'UK']
});

const stateField = new SelectField('state', {
  required: true,
  options: []
});

const submitButton = new SubmitButton('Register');

// Register with mediator
formMediator.registerField(emailField);
formMediator.registerField(usernameField);
formMediator.registerField(passwordField);
formMediator.registerField(confirmPasswordField);
formMediator.registerField(countryField);
formMediator.registerField(stateField);
formMediator.registerSubmitButton(submitButton);

// Simulate user interaction
console.log('\n=== User Filling Form ===\n');

emailField.setValue('john.doe@example.com'); // Should suggest username
usernameField.acceptSuggestion();             // Accept suggestion

passwordField.setValue('secret123');
confirmPasswordField.setValue('secret12');    // Mismatch!

countryField.setValue('USA');                 // Should update state options
stateField.setValue('California');

// Try to submit
console.log('\n=== Attempting Submit ===\n');
submitButton.click();

// Fix password
console.log('\n=== Fixing Password ===\n');
confirmPasswordField.setValue('secret123');   // Now matches

// Submit again
submitButton.click();
```

---

## 18.3 Dialog/Modal Coordinator

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DIALOG MEDIATOR: Coordinates dialog components
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class DialogMediator {
  constructor() {
    this.components = new Map();
    this.state = {
      isValid: false,
      isDirty: false,
      isSubmitting: false
    };
  }
  
  register(name, component) {
    this.components.set(name, component);
    component.setMediator(this);
  }
  
  notify(sender, event, data) {
    console.log(`[DialogMediator] ${sender.constructor.name} triggered "${event}"`);
    
    switch (event) {
      case 'input:change':
        this.state.isDirty = true;
        this.#validateForm();
        this.#updateComponents();
        break;
        
      case 'submit:click':
        if (this.state.isValid && !this.state.isSubmitting) {
          this.#handleSubmit();
        }
        break;
        
      case 'cancel:click':
        this.#handleCancel();
        break;
        
      case 'validation:complete':
        this.state.isValid = data.isValid;
        this.#updateComponents();
        break;
    }
  }
  
  #validateForm() {
    let isValid = true;
    
    this.components.forEach((component, name) => {
      if (component.validate && !component.validate()) {
        isValid = false;
      }
    });
    
    this.state.isValid = isValid;
  }
  
  #updateComponents() {
    // Update submit button
    const submitBtn = this.components.get('submitButton');
    if (submitBtn) {
      submitBtn.setEnabled(this.state.isValid && !this.state.isSubmitting);
    }
    
    // Update cancel button
    const cancelBtn = this.components.get('cancelButton');
    if (cancelBtn && this.state.isDirty) {
      cancelBtn.setWarning(true);
    }
    
    // Update status
    const status = this.components.get('statusBar');
    if (status) {
      if (this.state.isSubmitting) {
        status.showLoading('Submitting...');
      } else if (!this.state.isValid) {
        status.showError('Please fix errors before submitting');
      } else {
        status.showReady();
      }
    }
  }
  
  async #handleSubmit() {
    this.state.isSubmitting = true;
    this.#updateComponents();
    
    try {
      // Gather data from input components
      const data = {};
      this.components.forEach((component, name) => {
        if (component.getValue) {
          data[name] = component.getValue();
        }
      });
      
      console.log('[DialogMediator] Submitting:', data);
      
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      console.log('[DialogMediator] Submit successful!');
      this.#closeDialog(true);
      
    } catch (error) {
      console.error('[DialogMediator] Submit failed:', error);
      const status = this.components.get('statusBar');
      if (status) {
        status.showError('Submission failed. Please try again.');
      }
    } finally {
      this.state.isSubmitting = false;
      this.#updateComponents();
    }
  }
  
  #handleCancel() {
    if (this.state.isDirty) {
      const confirmDialog = this.components.get('confirmDialog');
      if (confirmDialog) {
        confirmDialog.show('Discard changes?', () => {
          this.#closeDialog(false);
        });
        return;
      }
    }
    this.#closeDialog(false);
  }
  
  #closeDialog(success) {
    console.log(`[DialogMediator] Dialog closed (success: ${success})`);
    // Reset state
    this.state = { isValid: false, isDirty: false, isSubmitting: false };
  }
}

// Simple component implementations
class DialogInput {
  constructor(name) {
    this.name = name;
    this.value = '';
    this.mediator = null;
  }
  
  setMediator(m) { this.mediator = m; }
  getValue() { return this.value; }
  
  setValue(value) {
    this.value = value;
    this.mediator.notify(this, 'input:change', { name: this.name, value });
  }
  
  validate() { return this.value.length > 0; }
}

class DialogButton {
  constructor(name, action) {
    this.name = name;
    this.action = action;
    this.enabled = true;
    this.warning = false;
    this.mediator = null;
  }
  
  setMediator(m) { this.mediator = m; }
  setEnabled(enabled) { 
    this.enabled = enabled;
    console.log(`[${this.name}] ${enabled ? 'enabled' : 'disabled'}`);
  }
  setWarning(warning) { this.warning = warning; }
  
  click() {
    if (this.enabled) {
      this.mediator.notify(this, `${this.action}:click`, {});
    }
  }
}

class StatusBar {
  constructor() { this.mediator = null; }
  setMediator(m) { this.mediator = m; }
  
  showLoading(msg) { console.log(`[Status] â³ ${msg}`); }
  showError(msg) { console.log(`[Status] âŒ ${msg}`); }
  showReady() { console.log(`[Status] âœ… Ready`); }
}

// Usage
const dialogMediator = new DialogMediator();

const titleInput = new DialogInput('title');
const descInput = new DialogInput('description');
const submitBtn = new DialogButton('submitButton', 'submit');
const cancelBtn = new DialogButton('cancelButton', 'cancel');
const statusBar = new StatusBar();

dialogMediator.register('title', titleInput);
dialogMediator.register('description', descInput);
dialogMediator.register('submitButton', submitBtn);
dialogMediator.register('cancelButton', cancelBtn);
dialogMediator.register('statusBar', statusBar);

console.log('\n=== Dialog Interaction ===\n');
titleInput.setValue('My Task');
descInput.setValue('Task description here');
submitBtn.click();
```

---

## Key Takeaways

1. **Mediator centralizes communication** - Objects don't talk directly
2. **Reduces coupling** - N connections instead of N(N-1)/2
3. **Single point of control** - Easy to modify interaction logic
4. **Can become God Object** - Keep mediator focused
5. **Use for**: Complex forms, chat systems, wizards, game coordination

> âš ï¸ **Warning:** Mediator can become a "God Object" if it handles too much logic. Keep it focused on coordination, not business logic.

> ðŸ’¡ **Interview Tip:** Explain with the air traffic controller analogy. Planes (colleagues) communicate through the controller (mediator), not directly.
