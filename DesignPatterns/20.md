# Chapter 20: Strategy Pattern

## 20.1 Concept

### What is the Strategy Pattern?

The Strategy Pattern defines a **family of algorithms**, encapsulates each one, and makes them **interchangeable**. It lets the algorithm vary independently from clients that use it.

Think of it like different routes to work: driving, bus, or bike are all "getting to work" strategies. You can swap between them based on weather, traffic, or mood.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    STRATEGY PATTERN                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   WITHOUT STRATEGY:              WITH STRATEGY:             â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”‚
â”‚                                                             â”‚
â”‚   class Shipping {               class Shipping {           â”‚
â”‚     calculate(pkg) {               constructor(strategy) {  â”‚
â”‚       if (type === 'ground')         this.strategy = strategy
â”‚         // ground logic            }                        â”‚
â”‚       else if (type === 'air')     calculate(pkg) {         â”‚
â”‚         // air logic                 return this.strategy   â”‚
â”‚       else if (type === 'sea')              .calculate(pkg) â”‚
â”‚         // sea logic               }                        â”‚
â”‚       // ... more ifs            }                          â”‚
â”‚     }                                                       â”‚
â”‚   }                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚                                  â”‚<<Strategy>> â”‚            â”‚
â”‚   Problems:                      â”‚ calculate() â”‚            â”‚
â”‚   â€¢ Hard to extend               â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚   â€¢ Violates Open/Closed             â”Œâ”€â”€â”´â”€â”€â”               â”‚
â”‚   â€¢ Complex conditionals          â”Œâ”€â”€â”´â”€â” â”Œâ”´â”€â”€â” â”Œâ”€â”€â”€â”       â”‚
â”‚                                   â”‚Air â”‚ â”‚Seaâ”‚ â”‚Gndâ”‚       â”‚
â”‚                                   â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜       â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Benefits

| Benefit | Description |
|---------|-------------|
| **Eliminates Conditionals** | Replace if/else chains with polymorphism |
| **Open/Closed Principle** | Add new strategies without modifying context |
| **Runtime Flexibility** | Switch algorithms at runtime |
| **Reusability** | Strategies can be reused across contexts |
| **Testability** | Test strategies independently |

### Strategy vs State

| Aspect | Strategy | State |
|--------|----------|-------|
| **Purpose** | Choose algorithm | Change behavior based on state |
| **Switching** | Client switches strategy | State switches itself |
| **Awareness** | Strategies unaware of each other | States know about transitions |
| **Typical Use** | Payment methods, sorting | Workflow states, game states |

---

## 20.2 Implementation

### Payment Processing System

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STRATEGY INTERFACE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class PaymentStrategy {
  pay(amount) {
    throw new Error('Must implement pay()');
  }
  
  validate() {
    throw new Error('Must implement validate()');
  }
  
  getName() {
    throw new Error('Must implement getName()');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONCRETE STRATEGIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class CreditCardStrategy extends PaymentStrategy {
  constructor(cardNumber, cvv, expiryDate) {
    super();
    this.cardNumber = cardNumber;
    this.cvv = cvv;
    this.expiryDate = expiryDate;
  }
  
  validate() {
    // Luhn algorithm check (simplified)
    if (this.cardNumber.length !== 16) {
      return { valid: false, error: 'Card number must be 16 digits' };
    }
    if (this.cvv.length !== 3) {
      return { valid: false, error: 'CVV must be 3 digits' };
    }
    return { valid: true };
  }
  
  pay(amount) {
    const validation = this.validate();
    if (!validation.valid) {
      throw new Error(validation.error);
    }
    
    console.log(`[CreditCard] Processing $${amount.toFixed(2)}`);
    console.log(`  Card: **** **** **** ${this.cardNumber.slice(-4)}`);
    
    // Simulate processing
    return {
      success: true,
      transactionId: 'CC_' + Date.now(),
      method: 'Credit Card',
      last4: this.cardNumber.slice(-4),
      amount
    };
  }
  
  getName() {
    return 'Credit Card';
  }
}

class PayPalStrategy extends PaymentStrategy {
  constructor(email, password) {
    super();
    this.email = email;
    this.password = password;
    this.authenticated = false;
  }
  
  validate() {
    if (!this.email || !this.email.includes('@')) {
      return { valid: false, error: 'Invalid PayPal email' };
    }
    return { valid: true };
  }
  
  #authenticate() {
    console.log(`[PayPal] Authenticating ${this.email}...`);
    // Simulate OAuth
    this.authenticated = true;
    return true;
  }
  
  pay(amount) {
    const validation = this.validate();
    if (!validation.valid) {
      throw new Error(validation.error);
    }
    
    if (!this.authenticated) {
      this.#authenticate();
    }
    
    console.log(`[PayPal] Processing $${amount.toFixed(2)}`);
    console.log(`  Account: ${this.email}`);
    
    return {
      success: true,
      transactionId: 'PP_' + Date.now(),
      method: 'PayPal',
      email: this.email,
      amount
    };
  }
  
  getName() {
    return 'PayPal';
  }
}

class CryptoStrategy extends PaymentStrategy {
  constructor(walletAddress, coinType = 'BTC') {
    super();
    this.walletAddress = walletAddress;
    this.coinType = coinType;
    this.exchangeRates = {
      BTC: 45000,
      ETH: 2500,
      USDT: 1
    };
  }
  
  validate() {
    if (!this.walletAddress || this.walletAddress.length < 26) {
      return { valid: false, error: 'Invalid wallet address' };
    }
    if (!this.exchangeRates[this.coinType]) {
      return { valid: false, error: 'Unsupported cryptocurrency' };
    }
    return { valid: true };
  }
  
  pay(amount) {
    const validation = this.validate();
    if (!validation.valid) {
      throw new Error(validation.error);
    }
    
    const cryptoAmount = amount / this.exchangeRates[this.coinType];
    
    console.log(`[Crypto] Processing $${amount.toFixed(2)}`);
    console.log(`  ${cryptoAmount.toFixed(8)} ${this.coinType}`);
    console.log(`  Wallet: ${this.walletAddress.slice(0, 10)}...`);
    
    return {
      success: true,
      transactionId: 'CRYPTO_' + Date.now(),
      method: `Cryptocurrency (${this.coinType})`,
      walletAddress: this.walletAddress,
      cryptoAmount,
      coinType: this.coinType,
      amount
    };
  }
  
  getName() {
    return `Crypto (${this.coinType})`;
  }
}

class BankTransferStrategy extends PaymentStrategy {
  constructor(accountNumber, routingNumber, accountName) {
    super();
    this.accountNumber = accountNumber;
    this.routingNumber = routingNumber;
    this.accountName = accountName;
  }
  
  validate() {
    if (!this.accountNumber || this.accountNumber.length < 8) {
      return { valid: false, error: 'Invalid account number' };
    }
    if (!this.routingNumber || this.routingNumber.length !== 9) {
      return { valid: false, error: 'Invalid routing number' };
    }
    return { valid: true };
  }
  
  pay(amount) {
    const validation = this.validate();
    if (!validation.valid) {
      throw new Error(validation.error);
    }
    
    console.log(`[BankTransfer] Processing $${amount.toFixed(2)}`);
    console.log(`  Account: ****${this.accountNumber.slice(-4)}`);
    console.log(`  Name: ${this.accountName}`);
    console.log(`  Note: Transfer will complete in 1-3 business days`);
    
    return {
      success: true,
      transactionId: 'ACH_' + Date.now(),
      method: 'Bank Transfer',
      last4: this.accountNumber.slice(-4),
      amount,
      pending: true
    };
  }
  
  getName() {
    return 'Bank Transfer';
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONTEXT: Shopping Cart
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class ShoppingCart {
  constructor() {
    this.items = [];
    this.paymentStrategy = null;
  }
  
  addItem(item) {
    this.items.push(item);
    console.log(`Added: ${item.name} - $${item.price.toFixed(2)}`);
  }
  
  getTotal() {
    return this.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  }
  
  setPaymentStrategy(strategy) {
    this.paymentStrategy = strategy;
    console.log(`Payment method set to: ${strategy.getName()}`);
  }
  
  checkout() {
    if (!this.paymentStrategy) {
      throw new Error('Please select a payment method');
    }
    
    if (this.items.length === 0) {
      throw new Error('Cart is empty');
    }
    
    const total = this.getTotal();
    console.log(`\n${'='.repeat(40)}`);
    console.log('CHECKOUT');
    console.log('='.repeat(40));
    console.log(`Items: ${this.items.length}`);
    console.log(`Total: $${total.toFixed(2)}`);
    console.log(`Payment: ${this.paymentStrategy.getName()}`);
    console.log('='.repeat(40) + '\n');
    
    const result = this.paymentStrategy.pay(total);
    
    if (result.success) {
      console.log('\nâœ… Payment successful!');
      console.log(`Transaction ID: ${result.transactionId}`);
      this.items = []; // Clear cart
    }
    
    return result;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USAGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const cart = new ShoppingCart();

// Add items
cart.addItem({ name: 'Laptop', price: 999.99, quantity: 1 });
cart.addItem({ name: 'Mouse', price: 29.99, quantity: 2 });
cart.addItem({ name: 'Keyboard', price: 79.99, quantity: 1 });

console.log(`\nCart Total: $${cart.getTotal().toFixed(2)}\n`);

// Pay with Credit Card
console.log('\n--- Paying with Credit Card ---');
cart.setPaymentStrategy(
  new CreditCardStrategy('4111111111111111', '123', '12/25')
);
// cart.checkout();

// Or pay with PayPal
console.log('\n--- Paying with PayPal ---');
cart.setPaymentStrategy(
  new PayPalStrategy('john@example.com', 'password123')
);
// cart.checkout();

// Or pay with Crypto
console.log('\n--- Paying with Cryptocurrency ---');
cart.setPaymentStrategy(
  new CryptoStrategy('bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh', 'BTC')
);
cart.checkout();
```

### Sorting Strategies

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SORTING STRATEGIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SortStrategy {
  sort(data) {
    throw new Error('Must implement sort()');
  }
  
  getName() {
    throw new Error('Must implement getName()');
  }
}

class BubbleSortStrategy extends SortStrategy {
  sort(data) {
    const arr = [...data]; // Don't mutate original
    const n = arr.length;
    
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        }
      }
    }
    
    return arr;
  }
  
  getName() { return 'Bubble Sort'; }
}

class QuickSortStrategy extends SortStrategy {
  sort(data) {
    const arr = [...data];
    return this.#quickSort(arr, 0, arr.length - 1);
  }
  
  #quickSort(arr, low, high) {
    if (low < high) {
      const pivotIndex = this.#partition(arr, low, high);
      this.#quickSort(arr, low, pivotIndex - 1);
      this.#quickSort(arr, pivotIndex + 1, high);
    }
    return arr;
  }
  
  #partition(arr, low, high) {
    const pivot = arr[high];
    let i = low - 1;
    
    for (let j = low; j < high; j++) {
      if (arr[j] <= pivot) {
        i++;
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }
    
    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
    return i + 1;
  }
  
  getName() { return 'Quick Sort'; }
}

class MergeSortStrategy extends SortStrategy {
  sort(data) {
    const arr = [...data];
    return this.#mergeSort(arr);
  }
  
  #mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    const mid = Math.floor(arr.length / 2);
    const left = this.#mergeSort(arr.slice(0, mid));
    const right = this.#mergeSort(arr.slice(mid));
    
    return this.#merge(left, right);
  }
  
  #merge(left, right) {
    const result = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
      if (left[i] <= right[j]) {
        result.push(left[i++]);
      } else {
        result.push(right[j++]);
      }
    }
    
    return result.concat(left.slice(i)).concat(right.slice(j));
  }
  
  getName() { return 'Merge Sort'; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONTEXT: Sorter with strategy selection
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Sorter {
  constructor() {
    this.strategy = null;
    this.strategies = {
      bubble: new BubbleSortStrategy(),
      quick: new QuickSortStrategy(),
      merge: new MergeSortStrategy()
    };
  }
  
  setStrategy(strategyName) {
    this.strategy = this.strategies[strategyName];
    if (!this.strategy) {
      throw new Error(`Unknown strategy: ${strategyName}`);
    }
    console.log(`Strategy set to: ${this.strategy.getName()}`);
  }
  
  // Auto-select strategy based on data size
  autoSelectStrategy(dataSize) {
    if (dataSize < 10) {
      this.setStrategy('bubble'); // Simple for small data
    } else if (dataSize < 1000) {
      this.setStrategy('quick');  // Fast for medium data
    } else {
      this.setStrategy('merge');  // Stable for large data
    }
  }
  
  sort(data) {
    if (!this.strategy) {
      this.autoSelectStrategy(data.length);
    }
    
    console.log(`Sorting ${data.length} elements with ${this.strategy.getName()}`);
    
    const start = performance.now();
    const result = this.strategy.sort(data);
    const duration = performance.now() - start;
    
    console.log(`Completed in ${duration.toFixed(2)}ms`);
    return result;
  }
}

// Usage
const sorter = new Sorter();

const smallArray = [64, 34, 25, 12, 22, 11, 90];
const largeArray = Array.from({ length: 1000 }, () => Math.floor(Math.random() * 1000));

console.log('\n=== Sorting Demo ===\n');

// Manual strategy selection
sorter.setStrategy('bubble');
console.log('Result:', sorter.sort(smallArray));

// Auto selection based on size
console.log('\n--- Auto-selected strategy ---');
sorter.strategy = null; // Reset
sorter.sort(largeArray);
```

---

## 20.3 Validation Strategies

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VALIDATION STRATEGY SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ValidationStrategy {
  validate(value) {
    throw new Error('Must implement validate()');
  }
}

// Individual validators
class RequiredValidator extends ValidationStrategy {
  validate(value) {
    if (value === null || value === undefined || value === '') {
      return { valid: false, message: 'This field is required' };
    }
    return { valid: true };
  }
}

class EmailValidator extends ValidationStrategy {
  validate(value) {
    if (!value) return { valid: true }; // Let RequiredValidator handle empty
    
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(value)) {
      return { valid: false, message: 'Please enter a valid email address' };
    }
    return { valid: true };
  }
}

class MinLengthValidator extends ValidationStrategy {
  constructor(minLength) {
    super();
    this.minLength = minLength;
  }
  
  validate(value) {
    if (!value) return { valid: true };
    
    if (value.length < this.minLength) {
      return { 
        valid: false, 
        message: `Must be at least ${this.minLength} characters` 
      };
    }
    return { valid: true };
  }
}

class MaxLengthValidator extends ValidationStrategy {
  constructor(maxLength) {
    super();
    this.maxLength = maxLength;
  }
  
  validate(value) {
    if (!value) return { valid: true };
    
    if (value.length > this.maxLength) {
      return { 
        valid: false, 
        message: `Must be no more than ${this.maxLength} characters` 
      };
    }
    return { valid: true };
  }
}

class PatternValidator extends ValidationStrategy {
  constructor(pattern, message) {
    super();
    this.pattern = pattern;
    this.message = message;
  }
  
  validate(value) {
    if (!value) return { valid: true };
    
    if (!this.pattern.test(value)) {
      return { valid: false, message: this.message };
    }
    return { valid: true };
  }
}

class RangeValidator extends ValidationStrategy {
  constructor(min, max) {
    super();
    this.min = min;
    this.max = max;
  }
  
  validate(value) {
    const num = Number(value);
    if (isNaN(num)) {
      return { valid: false, message: 'Must be a number' };
    }
    if (num < this.min || num > this.max) {
      return { 
        valid: false, 
        message: `Must be between ${this.min} and ${this.max}` 
      };
    }
    return { valid: true };
  }
}

class CustomValidator extends ValidationStrategy {
  constructor(validatorFn, message) {
    super();
    this.validatorFn = validatorFn;
    this.message = message;
  }
  
  validate(value) {
    if (this.validatorFn(value)) {
      return { valid: true };
    }
    return { valid: false, message: this.message };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPOSITE VALIDATOR (Multiple strategies)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class FieldValidator {
  constructor(fieldName) {
    this.fieldName = fieldName;
    this.strategies = [];
  }
  
  addStrategy(strategy) {
    this.strategies.push(strategy);
    return this; // Chainable
  }
  
  required() {
    return this.addStrategy(new RequiredValidator());
  }
  
  email() {
    return this.addStrategy(new EmailValidator());
  }
  
  minLength(length) {
    return this.addStrategy(new MinLengthValidator(length));
  }
  
  maxLength(length) {
    return this.addStrategy(new MaxLengthValidator(length));
  }
  
  pattern(regex, message) {
    return this.addStrategy(new PatternValidator(regex, message));
  }
  
  range(min, max) {
    return this.addStrategy(new RangeValidator(min, max));
  }
  
  custom(fn, message) {
    return this.addStrategy(new CustomValidator(fn, message));
  }
  
  validate(value) {
    const errors = [];
    
    for (const strategy of this.strategies) {
      const result = strategy.validate(value);
      if (!result.valid) {
        errors.push(result.message);
      }
    }
    
    return {
      field: this.fieldName,
      valid: errors.length === 0,
      errors
    };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FORM VALIDATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class FormValidator {
  constructor() {
    this.fields = new Map();
  }
  
  field(name) {
    const validator = new FieldValidator(name);
    this.fields.set(name, validator);
    return validator;
  }
  
  validate(data) {
    const results = {
      valid: true,
      errors: {}
    };
    
    this.fields.forEach((validator, fieldName) => {
      const result = validator.validate(data[fieldName]);
      if (!result.valid) {
        results.valid = false;
        results.errors[fieldName] = result.errors;
      }
    });
    
    return results;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USAGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const userFormValidator = new FormValidator();

// Define validation rules using fluent API
userFormValidator
  .field('username')
  .required()
  .minLength(3)
  .maxLength(20)
  .pattern(/^[a-zA-Z0-9_]+$/, 'Only letters, numbers, and underscores allowed');

userFormValidator
  .field('email')
  .required()
  .email();

userFormValidator
  .field('password')
  .required()
  .minLength(8)
  .pattern(/[A-Z]/, 'Must contain at least one uppercase letter')
  .pattern(/[0-9]/, 'Must contain at least one number');

userFormValidator
  .field('age')
  .required()
  .range(18, 120);

userFormValidator
  .field('website')
  .custom(
    (value) => !value || value.startsWith('http'),
    'Website must start with http:// or https://'
  );

// Test validation
console.log('\n=== Form Validation Demo ===\n');

const validData = {
  username: 'john_doe',
  email: 'john@example.com',
  password: 'Secret123',
  age: '25',
  website: 'https://example.com'
};

const invalidData = {
  username: 'jo',
  email: 'invalid-email',
  password: 'weak',
  age: '15',
  website: 'not-a-url'
};

console.log('Valid data result:');
console.log(JSON.stringify(userFormValidator.validate(validData), null, 2));

console.log('\nInvalid data result:');
console.log(JSON.stringify(userFormValidator.validate(invalidData), null, 2));
```

---

## 20.4 Compression Strategies

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE COMPRESSION WITH STRATEGIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CompressionStrategy {
  compress(data) { throw new Error('Must implement'); }
  decompress(data) { throw new Error('Must implement'); }
  getName() { throw new Error('Must implement'); }
  getExtension() { throw new Error('Must implement'); }
}

class ZipStrategy extends CompressionStrategy {
  compress(data) {
    // Simulate ZIP compression
    console.log('[ZIP] Compressing data...');
    return `ZIP_HEADER_${btoa(data)}_ZIP_FOOTER`;
  }
  
  decompress(data) {
    console.log('[ZIP] Decompressing data...');
    const content = data.replace('ZIP_HEADER_', '').replace('_ZIP_FOOTER', '');
    return atob(content);
  }
  
  getName() { return 'ZIP'; }
  getExtension() { return '.zip'; }
}

class GzipStrategy extends CompressionStrategy {
  compress(data) {
    console.log('[GZIP] Compressing data...');
    return `GZIP_${btoa(data)}_GZIP`;
  }
  
  decompress(data) {
    console.log('[GZIP] Decompressing data...');
    return atob(data.replace('GZIP_', '').replace('_GZIP', ''));
  }
  
  getName() { return 'GZIP'; }
  getExtension() { return '.gz'; }
}

class NoCompressionStrategy extends CompressionStrategy {
  compress(data) { return data; }
  decompress(data) { return data; }
  getName() { return 'None'; }
  getExtension() { return ''; }
}

// Context
class FileCompressor {
  constructor() {
    this.strategies = {
      zip: new ZipStrategy(),
      gzip: new GzipStrategy(),
      none: new NoCompressionStrategy()
    };
    this.strategy = this.strategies.gzip; // Default
  }
  
  setStrategy(name) {
    if (!this.strategies[name]) {
      throw new Error(`Unknown compression: ${name}`);
    }
    this.strategy = this.strategies[name];
  }
  
  compress(filename, data) {
    console.log(`\nCompressing "${filename}" with ${this.strategy.getName()}...`);
    const compressed = this.strategy.compress(data);
    const newFilename = filename + this.strategy.getExtension();
    
    console.log(`Original size: ${data.length} bytes`);
    console.log(`Compressed size: ${compressed.length} bytes`);
    console.log(`Output: ${newFilename}`);
    
    return { filename: newFilename, data: compressed };
  }
  
  decompress(compressedData) {
    return this.strategy.decompress(compressedData);
  }
}

// Usage
const compressor = new FileCompressor();
const testData = 'Hello World! '.repeat(100);

compressor.setStrategy('zip');
const zipped = compressor.compress('document.txt', testData);

compressor.setStrategy('gzip');
const gzipped = compressor.compress('document.txt', testData);
```

---

## Key Takeaways

1. **Strategy = Interchangeable Algorithms** - Same interface, different implementations
2. **Eliminates Conditionals** - No if/else chains for algorithm selection
3. **Open/Closed** - Add new strategies without modifying existing code
4. **Runtime Switching** - Change algorithm on the fly
5. **Composition** - Can combine multiple strategies
6. **Use for**: Payment methods, sorting, validation, authentication

> ğŸ’¡ **Interview Tip:** Show how Strategy eliminates complex conditionals. Demonstrate with a payment processing or validation example.

> ğŸ­ **Production Note:** Passport.js is a famous example - it uses Strategy pattern for different authentication methods (Local, OAuth, JWT, etc.).
