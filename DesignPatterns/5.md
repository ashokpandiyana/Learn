# Chapter 5: Builder Pattern

## 5.1 Concept and Motivation

### What is the Builder Pattern?

The Builder Pattern separates the **construction of a complex object** from its **representation**. It allows you to create different representations using the same construction process.

### The Problem It Solves

```javascript
// ‚ùå PROBLEM: Constructor with too many parameters (Telescoping Constructor)
class Pizza {
  constructor(size, cheese, pepperoni, bacon, mushrooms, onions, peppers, 
              olives, spinach, tomatoes, anchovies, extraCheese, 
              thinCrust, stuffedCrust, garlicCrust) {
    this.size = size;
    this.cheese = cheese;
    this.pepperoni = pepperoni;
    // ... 12 more assignments
  }
}

// Usage is confusing - what does each boolean mean?
const pizza = new Pizza('large', true, true, false, true, false, 
                         true, false, false, true, false, true,
                         false, true, false);
// ü§Ø Which parameter is which?!
```

### Problems with Telescoping Constructors

1. **Readability**: Hard to understand what each parameter means
2. **Maintainability**: Adding new parameters breaks existing code
3. **Error-prone**: Easy to mix up parameter order
4. **Inflexibility**: Must provide all parameters even if not needed
5. **No validation**: Can't validate combinations of parameters

### The Solution: Builder Pattern

```javascript
// ‚úÖ SOLUTION: Builder Pattern
class Pizza {
  constructor(builder) {
    this.size = builder.size;
    this.cheese = builder.cheese;
    this.toppings = builder.toppings;
    this.crust = builder.crust;
    this.extras = builder.extras;
  }
  
  describe() {
    return `${this.size} pizza with ${this.crust} crust, ` +
           `${this.cheese} cheese, topped with: ${this.toppings.join(', ')}`;
  }
}

class PizzaBuilder {
  constructor(size) {
    this.size = size;
    this.cheese = 'mozzarella';
    this.toppings = [];
    this.crust = 'regular';
    this.extras = [];
  }
  
  setCheese(cheese) {
    this.cheese = cheese;
    return this; // Enable chaining
  }
  
  addTopping(topping) {
    this.toppings.push(topping);
    return this;
  }
  
  setCrust(crust) {
    this.crust = crust;
    return this;
  }
  
  addExtra(extra) {
    this.extras.push(extra);
    return this;
  }
  
  build() {
    // Validation before building
    if (!this.size) {
      throw new Error('Pizza size is required');
    }
    return new Pizza(this);
  }
}

// Usage - Clear, readable, flexible!
const pizza = new PizzaBuilder('large')
  .setCheese('four cheese')
  .setCrust('stuffed')
  .addTopping('pepperoni')
  .addTopping('mushrooms')
  .addTopping('bell peppers')
  .addExtra('garlic dipping sauce')
  .build();

console.log(pizza.describe());
// "large pizza with stuffed crust, four cheese cheese, 
//  topped with: pepperoni, mushrooms, bell peppers"
```

### Visual Comparison

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          TELESCOPING CONSTRUCTOR vs BUILDER                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                             ‚îÇ
‚îÇ  TELESCOPING CONSTRUCTOR:                                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ new Pizza('lg', true, true, false, true, false...) ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ            ‚Üë                                                ‚îÇ
‚îÇ            ‚îÇ Confusing! What's true? What's false?          ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  BUILDER PATTERN:                                           ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ new PizzaBuilder('large')                           ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   .setCheese('four cheese')     ‚Üê Clear intent      ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   .addTopping('pepperoni')      ‚Üê Self-documenting  ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   .setCrust('stuffed')          ‚Üê Flexible order    ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   .build()                      ‚Üê Validation point  ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 5.2 Implementation Approaches

### Approach 1: Classic Builder with Director

The classic GoF pattern includes a **Director** that orchestrates the building process.

```javascript
// Product
class House {
  constructor() {
    this.parts = [];
  }
  
  addPart(part) {
    this.parts.push(part);
  }
  
  showParts() {
    console.log(`House parts: ${this.parts.join(', ')}`);
  }
}

// Abstract Builder
class HouseBuilder {
  constructor() {
    this.reset();
  }
  
  reset() {
    this.house = new House();
  }
  
  buildFoundation() { throw new Error('Must implement'); }
  buildWalls() { throw new Error('Must implement'); }
  buildRoof() { throw new Error('Must implement'); }
  buildGarage() { throw new Error('Must implement'); }
  buildGarden() { throw new Error('Must implement'); }
  buildSwimmingPool() { throw new Error('Must implement'); }
  
  getResult() {
    const result = this.house;
    this.reset(); // Ready for next build
    return result;
  }
}

// Concrete Builders
class StandardHouseBuilder extends HouseBuilder {
  buildFoundation() { 
    this.house.addPart('Concrete Foundation');
    return this;
  }
  buildWalls() { 
    this.house.addPart('Brick Walls');
    return this;
  }
  buildRoof() { 
    this.house.addPart('Shingle Roof');
    return this;
  }
  buildGarage() { 
    this.house.addPart('Single Garage');
    return this;
  }
  buildGarden() { 
    this.house.addPart('Basic Garden');
    return this;
  }
  buildSwimmingPool() { 
    // Standard house doesn't have pool
    return this;
  }
}

class LuxuryHouseBuilder extends HouseBuilder {
  buildFoundation() { 
    this.house.addPart('Reinforced Concrete Foundation');
    return this;
  }
  buildWalls() { 
    this.house.addPart('Stone & Glass Walls');
    return this;
  }
  buildRoof() { 
    this.house.addPart('Solar Panel Roof');
    return this;
  }
  buildGarage() { 
    this.house.addPart('3-Car Smart Garage');
    return this;
  }
  buildGarden() { 
    this.house.addPart('Landscaped Garden with Fountain');
    return this;
  }
  buildSwimmingPool() { 
    this.house.addPart('Infinity Pool with Jacuzzi');
    return this;
  }
}

// Director - Knows HOW to build
class HouseDirector {
  constructor() {
    this.builder = null;
  }
  
  setBuilder(builder) {
    this.builder = builder;
  }
  
  // Different construction sequences
  buildMinimalHouse() {
    return this.builder
      .buildFoundation()
      .buildWalls()
      .buildRoof()
      .getResult();
  }
  
  buildFullHouse() {
    return this.builder
      .buildFoundation()
      .buildWalls()
      .buildRoof()
      .buildGarage()
      .buildGarden()
      .getResult();
  }
  
  buildLuxuryHouse() {
    return this.builder
      .buildFoundation()
      .buildWalls()
      .buildRoof()
      .buildGarage()
      .buildGarden()
      .buildSwimmingPool()
      .getResult();
  }
}

// Usage
const director = new HouseDirector();

// Build standard house
director.setBuilder(new StandardHouseBuilder());
const standardHouse = director.buildFullHouse();
standardHouse.showParts();
// House parts: Concrete Foundation, Brick Walls, Shingle Roof, 
//              Single Garage, Basic Garden

// Build luxury house
director.setBuilder(new LuxuryHouseBuilder());
const luxuryHouse = director.buildLuxuryHouse();
luxuryHouse.showParts();
// House parts: Reinforced Concrete Foundation, Stone & Glass Walls,
//              Solar Panel Roof, 3-Car Smart Garage, 
//              Landscaped Garden with Fountain, Infinity Pool with Jacuzzi
```

### Diagram: Classic Builder with Director

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 CLASSIC BUILDER PATTERN                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    directs    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ  ‚îÇ  Director ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ   Builder         ‚îÇ          ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§               ‚îÇ   (Abstract)      ‚îÇ          ‚îÇ
‚îÇ  ‚îÇbuildMinimal‚îÇ               ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§          ‚îÇ
‚îÇ  ‚îÇbuildFull() ‚îÇ               ‚îÇbuildFoundation() ‚îÇ          ‚îÇ
‚îÇ  ‚îÇbuildLuxury ‚îÇ               ‚îÇbuildWalls()      ‚îÇ          ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îÇbuildRoof()       ‚îÇ          ‚îÇ
‚îÇ                              ‚îÇgetResult()       ‚îÇ          ‚îÇ
‚îÇ                              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îÇ                                       ‚îÇ                     ‚îÇ
‚îÇ                        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
‚îÇ                        ‚ñº                             ‚ñº      ‚îÇ
‚îÇ               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               ‚îÇStandardBuilder  ‚îÇ           ‚îÇLuxuryBuilder    ‚îÇ
‚îÇ               ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§           ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ               ‚îÇbuildFoundation()‚îÇ           ‚îÇbuildFoundation()‚îÇ
‚îÇ               ‚îÇ‚Üí Concrete       ‚îÇ           ‚îÇ‚Üí Reinforced     ‚îÇ
‚îÇ               ‚îÇbuildWalls()     ‚îÇ           ‚îÇbuildWalls()     ‚îÇ
‚îÇ               ‚îÇ‚Üí Brick          ‚îÇ           ‚îÇ‚Üí Stone & Glass  ‚îÇ
‚îÇ               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ                        ‚îÇ                             ‚îÇ        
‚îÇ                        ‚ñº                             ‚ñº        
‚îÇ               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               ‚îÇ  Standard House ‚îÇ           ‚îÇ  Luxury House   ‚îÇ
‚îÇ               ‚îÇ    (Product)    ‚îÇ           ‚îÇ    (Product)    ‚îÇ
‚îÇ               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Approach 2: Fluent Builder (Most Common in JavaScript)

The fluent interface pattern returns `this` from each method, enabling method chaining.

```javascript
class QueryBuilder {
  constructor() {
    this.query = {
      type: 'SELECT',
      columns: ['*'],
      table: null,
      conditions: [],
      orderBy: null,
      limit: null,
      offset: null,
      joins: []
    };
  }
  
  select(...columns) {
    this.query.columns = columns.length > 0 ? columns : ['*'];
    return this;
  }
  
  from(table) {
    this.query.table = table;
    return this;
  }
  
  where(condition, value) {
    this.query.conditions.push({ condition, value, type: 'AND' });
    return this;
  }
  
  orWhere(condition, value) {
    this.query.conditions.push({ condition, value, type: 'OR' });
    return this;
  }
  
  join(table, on, type = 'INNER') {
    this.query.joins.push({ table, on, type });
    return this;
  }
  
  leftJoin(table, on) {
    return this.join(table, on, 'LEFT');
  }
  
  orderBy(column, direction = 'ASC') {
    this.query.orderBy = { column, direction };
    return this;
  }
  
  limit(count) {
    this.query.limit = count;
    return this;
  }
  
  offset(count) {
    this.query.offset = count;
    return this;
  }
  
  build() {
    if (!this.query.table) {
      throw new Error('FROM clause is required');
    }
    
    let sql = `SELECT ${this.query.columns.join(', ')} FROM ${this.query.table}`;
    
    // Add joins
    for (const join of this.query.joins) {
      sql += ` ${join.type} JOIN ${join.table} ON ${join.on}`;
    }
    
    // Add conditions
    if (this.query.conditions.length > 0) {
      const whereClauses = this.query.conditions.map((c, i) => {
        const prefix = i === 0 ? 'WHERE' : c.type;
        return `${prefix} ${c.condition}`;
      });
      sql += ` ${whereClauses.join(' ')}`;
    }
    
    // Add ORDER BY
    if (this.query.orderBy) {
      sql += ` ORDER BY ${this.query.orderBy.column} ${this.query.orderBy.direction}`;
    }
    
    // Add LIMIT and OFFSET
    if (this.query.limit) {
      sql += ` LIMIT ${this.query.limit}`;
    }
    if (this.query.offset) {
      sql += ` OFFSET ${this.query.offset}`;
    }
    
    return sql;
  }
  
  // Helper to get a fresh builder
  static create() {
    return new QueryBuilder();
  }
}

// Usage Examples
const query1 = QueryBuilder.create()
  .select('id', 'name', 'email')
  .from('users')
  .where('active = ?', true)
  .where('age > ?', 18)
  .orderBy('name')
  .limit(10)
  .build();

console.log(query1);
// SELECT id, name, email FROM users WHERE active = ? AND age > ? 
// ORDER BY name ASC LIMIT 10

const query2 = QueryBuilder.create()
  .select('u.name', 'o.total', 'o.date')
  .from('users u')
  .leftJoin('orders o', 'u.id = o.user_id')
  .where('o.total > ?', 100)
  .orWhere('u.vip = ?', true)
  .orderBy('o.date', 'DESC')
  .limit(50)
  .offset(10)
  .build();

console.log(query2);
// SELECT u.name, o.total, o.date FROM users u 
// LEFT JOIN orders o ON u.id = o.user_id 
// WHERE o.total > ? OR u.vip = ? 
// ORDER BY o.date DESC LIMIT 50 OFFSET 10
```

### Approach 3: Builder with Validation

```javascript
class FormBuilder {
  constructor() {
    this.fields = [];
    this.validators = [];
    this.submitHandler = null;
    this.formOptions = {
      method: 'POST',
      action: '',
      enctype: 'application/x-www-form-urlencoded'
    };
  }
  
  // Field methods
  addTextField(name, label, options = {}) {
    this.fields.push({
      type: 'text',
      name,
      label,
      ...options
    });
    return this;
  }
  
  addEmailField(name, label, options = {}) {
    this.fields.push({
      type: 'email',
      name,
      label,
      ...options
    });
    // Auto-add email validation
    this.addValidator(name, (value) => {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return emailRegex.test(value) || 'Invalid email format';
    });
    return this;
  }
  
  addPasswordField(name, label, options = {}) {
    this.fields.push({
      type: 'password',
      name,
      label,
      minLength: options.minLength || 8,
      ...options
    });
    return this;
  }
  
  addSelectField(name, label, choices, options = {}) {
    this.fields.push({
      type: 'select',
      name,
      label,
      choices,
      ...options
    });
    return this;
  }
  
  addCheckbox(name, label, options = {}) {
    this.fields.push({
      type: 'checkbox',
      name,
      label,
      ...options
    });
    return this;
  }
  
  // Validation methods
  addValidator(fieldName, validatorFn) {
    this.validators.push({ fieldName, validatorFn });
    return this;
  }
  
  required(fieldName, message = 'This field is required') {
    return this.addValidator(fieldName, (value) => {
      return value && value.trim() !== '' ? true : message;
    });
  }
  
  minLength(fieldName, length, message) {
    return this.addValidator(fieldName, (value) => {
      return value.length >= length ? true : 
        (message || `Minimum ${length} characters required`);
    });
  }
  
  // Form options
  setMethod(method) {
    this.formOptions.method = method;
    return this;
  }
  
  setAction(action) {
    this.formOptions.action = action;
    return this;
  }
  
  enableFileUpload() {
    this.formOptions.enctype = 'multipart/form-data';
    return this;
  }
  
  onSubmit(handler) {
    this.submitHandler = handler;
    return this;
  }
  
  // Build the form
  build() {
    // Validate configuration
    if (this.fields.length === 0) {
      throw new Error('Form must have at least one field');
    }
    
    return {
      fields: [...this.fields],
      validators: [...this.validators],
      options: { ...this.formOptions },
      submitHandler: this.submitHandler,
      
      validate(data) {
        const errors = {};
        
        for (const { fieldName, validatorFn } of this.validators) {
          const value = data[fieldName];
          const result = validatorFn(value);
          
          if (result !== true) {
            errors[fieldName] = errors[fieldName] || [];
            errors[fieldName].push(result);
          }
        }
        
        return {
          isValid: Object.keys(errors).length === 0,
          errors
        };
      },
      
      render() {
        // Would generate HTML in real implementation
        return `<form method="${this.options.method}" action="${this.options.action}">
          ${this.fields.map(f => `<input type="${f.type}" name="${f.name}" />`).join('\n')}
        </form>`;
      }
    };
  }
}

// Usage
const loginForm = new FormBuilder()
  .addEmailField('email', 'Email Address')
  .required('email')
  .addPasswordField('password', 'Password', { minLength: 8 })
  .required('password')
  .minLength('password', 8)
  .addCheckbox('remember', 'Remember me')
  .setMethod('POST')
  .setAction('/api/login')
  .onSubmit((data) => console.log('Login:', data))
  .build();

// Validate form data
const validation = loginForm.validate({
  email: 'invalid-email',
  password: '123'
});

console.log(validation);
// {
//   isValid: false,
//   errors: {
//     email: ['Invalid email format'],
//     password: ['Minimum 8 characters required']
//   }
// }
```

---

## 5.3 Real-World Use Cases

### Use Case 1: HTTP Request Builder

```javascript
class HttpRequestBuilder {
  constructor(baseURL = '') {
    this.config = {
      baseURL,
      url: '',
      method: 'GET',
      headers: {},
      params: {},
      data: null,
      timeout: 30000,
      withCredentials: false,
      responseType: 'json'
    };
  }
  
  // HTTP Methods
  get(url) {
    this.config.method = 'GET';
    this.config.url = url;
    return this;
  }
  
  post(url) {
    this.config.method = 'POST';
    this.config.url = url;
    return this;
  }
  
  put(url) {
    this.config.method = 'PUT';
    this.config.url = url;
    return this;
  }
  
  delete(url) {
    this.config.method = 'DELETE';
    this.config.url = url;
    return this;
  }
  
  patch(url) {
    this.config.method = 'PATCH';
    this.config.url = url;
    return this;
  }
  
  // Configuration
  header(key, value) {
    this.config.headers[key] = value;
    return this;
  }
  
  headers(headers) {
    this.config.headers = { ...this.config.headers, ...headers };
    return this;
  }
  
  bearerAuth(token) {
    return this.header('Authorization', `Bearer ${token}`);
  }
  
  basicAuth(username, password) {
    const credentials = btoa(`${username}:${password}`);
    return this.header('Authorization', `Basic ${credentials}`);
  }
  
  contentType(type) {
    return this.header('Content-Type', type);
  }
  
  json() {
    return this.contentType('application/json');
  }
  
  query(params) {
    this.config.params = { ...this.config.params, ...params };
    return this;
  }
  
  body(data) {
    this.config.data = data;
    return this;
  }
  
  jsonBody(data) {
    return this.json().body(JSON.stringify(data));
  }
  
  timeout(ms) {
    this.config.timeout = ms;
    return this;
  }
  
  withCredentials() {
    this.config.withCredentials = true;
    return this;
  }
  
  // Build and execute
  build() {
    return { ...this.config };
  }
  
  async send() {
    const config = this.build();
    const url = new URL(config.url, config.baseURL);
    
    // Add query params
    Object.entries(config.params).forEach(([key, value]) => {
      url.searchParams.append(key, value);
    });
    
    const response = await fetch(url.toString(), {
      method: config.method,
      headers: config.headers,
      body: config.data,
      credentials: config.withCredentials ? 'include' : 'same-origin'
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    return config.responseType === 'json' 
      ? response.json() 
      : response.text();
  }
  
  static create(baseURL) {
    return new HttpRequestBuilder(baseURL);
  }
}

// Usage
const api = HttpRequestBuilder.create('https://api.example.com');

// GET request with query params
const users = await api
  .get('/users')
  .query({ page: 1, limit: 10, sort: 'name' })
  .bearerAuth('my-token')
  .send();

// POST request with JSON body
const newUser = await api
  .post('/users')
  .bearerAuth('my-token')
  .jsonBody({ name: 'John', email: 'john@example.com' })
  .send();

// Complex request
const result = await api
  .put('/users/123')
  .headers({
    'X-Custom-Header': 'value',
    'Accept-Language': 'en-US'
  })
  .bearerAuth('my-token')
  .jsonBody({ name: 'Updated Name' })
  .timeout(5000)
  .withCredentials()
  .send();
```

### Use Case 2: Test Data Builder

```javascript
class UserBuilder {
  constructor() {
    this.user = {
      id: this.#generateId(),
      firstName: 'John',
      lastName: 'Doe',
      email: 'john.doe@example.com',
      age: 30,
      role: 'user',
      active: true,
      createdAt: new Date(),
      profile: {
        avatar: null,
        bio: '',
        social: {}
      },
      settings: {
        notifications: true,
        theme: 'light',
        language: 'en'
      }
    };
  }
  
  #generateId() {
    return 'user_' + Math.random().toString(36).substr(2, 9);
  }
  
  withId(id) {
    this.user.id = id;
    return this;
  }
  
  withName(firstName, lastName) {
    this.user.firstName = firstName;
    this.user.lastName = lastName;
    this.user.email = `${firstName.toLowerCase()}.${lastName.toLowerCase()}@example.com`;
    return this;
  }
  
  withEmail(email) {
    this.user.email = email;
    return this;
  }
  
  withAge(age) {
    this.user.age = age;
    return this;
  }
  
  asAdmin() {
    this.user.role = 'admin';
    return this;
  }
  
  asModerator() {
    this.user.role = 'moderator';
    return this;
  }
  
  inactive() {
    this.user.active = false;
    return this;
  }
  
  withAvatar(url) {
    this.user.profile.avatar = url;
    return this;
  }
  
  withBio(bio) {
    this.user.profile.bio = bio;
    return this;
  }
  
  withSocialLinks(links) {
    this.user.profile.social = links;
    return this;
  }
  
  withSettings(settings) {
    this.user.settings = { ...this.user.settings, ...settings };
    return this;
  }
  
  darkMode() {
    this.user.settings.theme = 'dark';
    return this;
  }
  
  createdDaysAgo(days) {
    const date = new Date();
    date.setDate(date.getDate() - days);
    this.user.createdAt = date;
    return this;
  }
  
  build() {
    return { ...this.user };
  }
  
  static create() {
    return new UserBuilder();
  }
}

// Usage in Tests
describe('UserService', () => {
  test('should deactivate user', () => {
    const user = UserBuilder.create()
      .withName('Alice', 'Smith')
      .build();
    
    const result = userService.deactivate(user.id);
    expect(result.active).toBe(false);
  });
  
  test('should not allow non-admin to delete users', () => {
    const regularUser = UserBuilder.create()
      .withName('Bob', 'Jones')
      .build(); // Default role is 'user'
    
    expect(() => userService.deleteUser('123', regularUser))
      .toThrow('Unauthorized');
  });
  
  test('admin should be able to delete users', () => {
    const admin = UserBuilder.create()
      .withName('Admin', 'User')
      .asAdmin()
      .build();
    
    expect(() => userService.deleteUser('123', admin))
      .not.toThrow();
  });
  
  test('should handle old inactive users', () => {
    const oldUser = UserBuilder.create()
      .inactive()
      .createdDaysAgo(365)
      .build();
    
    const shouldArchive = userService.shouldArchive(oldUser);
    expect(shouldArchive).toBe(true);
  });
});
```

### Use Case 3: Configuration Builder

```javascript
class ServerConfigBuilder {
  constructor() {
    this.config = {
      port: 3000,
      host: 'localhost',
      ssl: null,
      cors: null,
      rateLimit: null,
      logging: {
        level: 'info',
        format: 'json'
      },
      database: null,
      cache: null,
      middleware: []
    };
  }
  
  port(port) {
    this.config.port = port;
    return this;
  }
  
  host(host) {
    this.config.host = host;
    return this;
  }
  
  // SSL Configuration
  enableSSL(certPath, keyPath) {
    this.config.ssl = { certPath, keyPath };
    return this;
  }
  
  // CORS Configuration
  enableCORS(options = {}) {
    this.config.cors = {
      origin: options.origin || '*',
      methods: options.methods || ['GET', 'POST', 'PUT', 'DELETE'],
      credentials: options.credentials || false,
      ...options
    };
    return this;
  }
  
  // Rate Limiting
  enableRateLimit(windowMs = 60000, max = 100) {
    this.config.rateLimit = { windowMs, max };
    return this;
  }
  
  // Logging
  logLevel(level) {
    this.config.logging.level = level;
    return this;
  }
  
  logFormat(format) {
    this.config.logging.format = format;
    return this;
  }
  
  // Database
  connectDatabase(type, connectionString, options = {}) {
    this.config.database = {
      type,
      connectionString,
      pool: options.pool || { min: 2, max: 10 },
      ...options
    };
    return this;
  }
  
  // Cache
  enableCache(type, config = {}) {
    this.config.cache = { type, ...config };
    return this;
  }
  
  useRedis(host, port = 6379) {
    return this.enableCache('redis', { host, port });
  }
  
  useMemoryCache(maxSize = 100) {
    return this.enableCache('memory', { maxSize });
  }
  
  // Middleware
  use(middleware) {
    this.config.middleware.push(middleware);
    return this;
  }
  
  // Environment presets
  development() {
    return this
      .port(3000)
      .logLevel('debug')
      .logFormat('dev')
      .useMemoryCache();
  }
  
  production() {
    return this
      .port(process.env.PORT || 8080)
      .logLevel('warn')
      .logFormat('json')
      .enableRateLimit(60000, 100);
  }
  
  build() {
    // Validation
    if (this.config.ssl && (!this.config.ssl.certPath || !this.config.ssl.keyPath)) {
      throw new Error('SSL requires both certificate and key paths');
    }
    
    return Object.freeze({ ...this.config });
  }
  
  static create() {
    return new ServerConfigBuilder();
  }
}

// Usage
const devConfig = ServerConfigBuilder.create()
  .development()
  .enableCORS({ origin: 'http://localhost:3000' })
  .connectDatabase('postgres', 'postgres://localhost/myapp_dev')
  .build();

const prodConfig = ServerConfigBuilder.create()
  .production()
  .host('0.0.0.0')
  .enableSSL('/path/to/cert.pem', '/path/to/key.pem')
  .enableCORS({ origin: 'https://myapp.com', credentials: true })
  .enableRateLimit(60000, 1000)
  .connectDatabase('postgres', process.env.DATABASE_URL, {
    pool: { min: 5, max: 20 },
    ssl: true
  })
  .useRedis(process.env.REDIS_HOST, 6379)
  .build();
```

---

## 5.4 Best Practices and Tips

### 1. Method Naming Conventions

```javascript
// ‚úÖ Good: Clear, action-oriented names
builder
  .withName('John')      // Setting properties
  .addItem(item)         // Adding to collections
  .enableFeature()       // Enabling flags
  .asAdmin()             // Setting modes/types
  .build()               // Final construction

// ‚ùå Bad: Inconsistent or unclear names
builder
  .name('John')          // Unclear if setting or getting
  .item(item)            // Is this add, set, or get?
  .feature()             // What does this do?
  .admin()               // Is this a check or a setter?
```

### 2. Immutable vs Mutable Builders

```javascript
// Mutable Builder (standard) - Modifies same instance
class MutableBuilder {
  withName(name) {
    this.name = name;
    return this; // Same instance
  }
}

// Immutable Builder - Returns new instance each time
class ImmutableBuilder {
  withName(name) {
    return new ImmutableBuilder({
      ...this.config,
      name
    });
  }
}

// Immutable is useful for:
// - Sharing partial configurations
// - Thread safety (less relevant in JS)
// - Functional programming style
```

### 3. Required vs Optional Parameters

```javascript
class EmailBuilder {
  constructor(to) { // Required in constructor
    this.email = { to, subject: '', body: '', attachments: [] };
  }
  
  subject(subject) { // Fluent methods for optional
    this.email.subject = subject;
    return this;
  }
  
  build() {
    // Validate required fields
    if (!this.email.to) throw new Error('Recipient required');
    if (!this.email.subject) throw new Error('Subject required');
    return this.email;
  }
}

// Usage - 'to' is required, rest is optional
new EmailBuilder('user@example.com')
  .subject('Hello')
  .body('...')
  .build();
```

---

## Key Takeaways

1. **Builder separates construction from representation** - Same process, different results
2. **Fluent interface** - Method chaining improves readability
3. **Use Builder when**:
   - Object has many parameters
   - Object has complex construction logic
   - You want to prevent invalid object states
4. **Director is optional** - In JavaScript, often omitted for simpler builders
5. **Validation in build()** - Ensure complete, valid objects
6. **Consider immutability** - For shareable, reusable configurations

> üí° **Interview Tip:** Be ready to explain the difference between Builder and Factory patterns. Factory focuses on WHICH object to create, while Builder focuses on HOW to create a complex object step by step.

> üè≠ **Production Note:** Builder pattern is heavily used in libraries like Knex.js (query building), Axios (request configuration), Jest (test setup), and many configuration systems.
