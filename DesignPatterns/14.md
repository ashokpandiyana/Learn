# Chapter 14: Flyweight Pattern

## 14.1 Concept

### What is the Flyweight Pattern?

The Flyweight Pattern **minimizes memory usage** by sharing as much data as possible between similar objects. It separates object state into **intrinsic** (shared) and **extrinsic** (unique) parts.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FLYWEIGHT PATTERN                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   WITHOUT FLYWEIGHT:              WITH FLYWEIGHT:           â”‚
â”‚                                                             â”‚
â”‚   Object 1    Object 2           Shared Flyweight           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚   â”‚Color:R â”‚  â”‚Color:R â”‚         â”‚ Intrinsic Data â”‚         â”‚
â”‚   â”‚Shape:â— â”‚  â”‚Shape:â— â”‚    â—„â”€â”€â”€â”€â”‚ â€¢ Color: Red   â”‚         â”‚
â”‚   â”‚Font:A  â”‚  â”‚Font:A  â”‚         â”‚ â€¢ Shape: Circleâ”‚         â”‚
â”‚   â”‚Size:12 â”‚  â”‚Size:14 â”‚         â”‚ â€¢ Font: Arial  â”‚         â”‚
â”‚   â”‚X: 10   â”‚  â”‚X: 50   â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚   â”‚Y: 20   â”‚  â”‚Y: 30   â”‚               â–²    â–²              â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚    â”‚              â”‚
â”‚   (Duplicated)(Duplicated)        â”Œâ”€â”€â”€â”€â”´â”  â”Œâ”´â”€â”€â”€â”€â”         â”‚
â”‚                                   â”‚Ext 1â”‚  â”‚Ext 2â”‚         â”‚
â”‚   Memory: 2x full object          â”‚X:10 â”‚  â”‚X:50 â”‚         â”‚
â”‚                                   â”‚Y:20 â”‚  â”‚Y:30 â”‚         â”‚
â”‚                                   â”‚Sz:12â”‚  â”‚Sz:14â”‚         â”‚
â”‚                                   â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                             â”‚
â”‚                                   Memory: 1 shared +        â”‚
â”‚                                           2 small contexts  â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Intrinsic vs Extrinsic State

| State Type | Description | Storage | Example |
|------------|-------------|---------|---------|
| **Intrinsic** | Shared, immutable, context-independent | In flyweight | Character glyph, sprite image |
| **Extrinsic** | Unique, varies by context | Passed in by client | Position, size, color variation |

### When to Use Flyweight

- Application uses **large number of similar objects**
- Storage costs are high due to **object quantity**
- Most object state can be made **extrinsic**
- Groups of objects can be **replaced by few shared objects**
- Application doesn't depend on **object identity**

---

## 14.2 Implementation

### Text Editor Characters Example

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FLYWEIGHT: Shared character representation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class CharacterFlyweight {
  constructor(char, fontFamily, fontStyle) {
    // Intrinsic state - shared across all instances
    this.char = char;
    this.fontFamily = fontFamily;
    this.fontStyle = fontStyle;
    
    // Expensive data that would be duplicated
    this.glyphData = this.#loadGlyph();
  }
  
  #loadGlyph() {
    // Simulate loading font glyph data
    console.log(`Loading glyph for "${this.char}" in ${this.fontFamily} ${this.fontStyle}`);
    return `glyph_${this.char}_${this.fontFamily}_${this.fontStyle}`;
  }
  
  // Render using extrinsic state (position, size, color)
  render(x, y, fontSize, color) {
    console.log(
      `Rendering "${this.char}" at (${x}, ${y}) ` +
      `size: ${fontSize}px, color: ${color}, ` +
      `font: ${this.fontFamily} ${this.fontStyle}`
    );
  }
  
  getKey() {
    return `${this.char}-${this.fontFamily}-${this.fontStyle}`;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FLYWEIGHT FACTORY: Creates and manages flyweights
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class CharacterFactory {
  constructor() {
    this.flyweights = new Map();
  }
  
  getFlyweight(char, fontFamily, fontStyle) {
    const key = `${char}-${fontFamily}-${fontStyle}`;
    
    if (!this.flyweights.has(key)) {
      console.log(`Creating new flyweight for: ${key}`);
      this.flyweights.set(key, new CharacterFlyweight(char, fontFamily, fontStyle));
    } else {
      console.log(`Reusing existing flyweight: ${key}`);
    }
    
    return this.flyweights.get(key);
  }
  
  getFlyweightCount() {
    return this.flyweights.size;
  }
  
  listFlyweights() {
    return [...this.flyweights.keys()];
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONTEXT: Stores extrinsic state
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class CharacterContext {
  constructor(flyweight, x, y, fontSize, color) {
    this.flyweight = flyweight;  // Reference to shared flyweight
    // Extrinsic state - unique per instance
    this.x = x;
    this.y = y;
    this.fontSize = fontSize;
    this.color = color;
  }
  
  render() {
    this.flyweight.render(this.x, this.y, this.fontSize, this.color);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEXT EDITOR: Uses flyweights for characters
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class TextEditor {
  constructor() {
    this.factory = new CharacterFactory();
    this.characters = []; // Array of CharacterContext
    this.currentFont = 'Arial';
    this.currentStyle = 'normal';
    this.currentSize = 12;
    this.currentColor = 'black';
    this.cursorX = 0;
    this.cursorY = 0;
  }
  
  setFont(family, style = 'normal') {
    this.currentFont = family;
    this.currentStyle = style;
  }
  
  setSize(size) {
    this.currentSize = size;
  }
  
  setColor(color) {
    this.currentColor = color;
  }
  
  insertCharacter(char) {
    const flyweight = this.factory.getFlyweight(
      char,
      this.currentFont,
      this.currentStyle
    );
    
    const context = new CharacterContext(
      flyweight,
      this.cursorX,
      this.cursorY,
      this.currentSize,
      this.currentColor
    );
    
    this.characters.push(context);
    this.cursorX += this.currentSize * 0.6; // Advance cursor
  }
  
  insertText(text) {
    for (const char of text) {
      if (char === '\n') {
        this.cursorX = 0;
        this.cursorY += this.currentSize * 1.2;
      } else {
        this.insertCharacter(char);
      }
    }
  }
  
  render() {
    console.log('\n=== Rendering Document ===\n');
    this.characters.forEach(context => context.render());
  }
  
  getStats() {
    return {
      totalCharacters: this.characters.length,
      uniqueFlyweights: this.factory.getFlyweightCount(),
      memorySaved: `${((1 - this.factory.getFlyweightCount() / this.characters.length) * 100).toFixed(1)}%`
    };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USAGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const editor = new TextEditor();

// Type some text
editor.setFont('Arial', 'normal');
editor.setColor('black');
editor.insertText('Hello ');

editor.setFont('Arial', 'bold');
editor.setColor('red');
editor.insertText('World');

editor.setFont('Arial', 'normal');
editor.setColor('black');
editor.insertText('! Hello again!');

// Statistics
console.log('\n=== Statistics ===');
const stats = editor.getStats();
console.log(`Total characters: ${stats.totalCharacters}`);
console.log(`Unique flyweights: ${stats.uniqueFlyweights}`);
console.log(`Memory saved: ${stats.memorySaved}`);
console.log(`Flyweights:`, editor.factory.listFlyweights());

// Without flyweight: 18 full character objects
// With flyweight: 9 unique flyweights + 18 tiny contexts
```

### Game Particles Example

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FLYWEIGHT: Shared particle type data
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class ParticleType {
  constructor(name, sprite, color, physics) {
    // Intrinsic state - shared across all particles of this type
    this.name = name;
    this.sprite = sprite;           // Large sprite image data
    this.color = color;
    this.physics = physics;         // Physics properties
    this.animations = this.#loadAnimations();
    
    console.log(`Created particle type: ${name}`);
  }
  
  #loadAnimations() {
    // Simulate loading heavy animation data
    return {
      frames: new Array(60).fill(null).map((_, i) => `frame_${i}`),
      duration: 1000
    };
  }
  
  // Draw particle using extrinsic state
  draw(context, x, y, scale, rotation, alpha) {
    // In real code, this would draw to canvas
    console.log(
      `Drawing ${this.name} particle at (${x.toFixed(1)}, ${y.toFixed(1)}) ` +
      `scale: ${scale.toFixed(2)}, rotation: ${rotation.toFixed(2)}Â°, alpha: ${alpha.toFixed(2)}`
    );
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FLYWEIGHT FACTORY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class ParticleTypeFactory {
  static #types = new Map();
  
  static getType(name, sprite, color, physics) {
    const key = name;
    
    if (!this.#types.has(key)) {
      this.#types.set(key, new ParticleType(name, sprite, color, physics));
    }
    
    return this.#types.get(key);
  }
  
  static getTypeCount() {
    return this.#types.size;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PARTICLE: Contains extrinsic state
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Particle {
  constructor(type, x, y) {
    this.type = type;      // Reference to flyweight
    
    // Extrinsic state - unique per particle
    this.x = x;
    this.y = y;
    this.velocityX = (Math.random() - 0.5) * 10;
    this.velocityY = (Math.random() - 0.5) * 10;
    this.scale = 0.5 + Math.random() * 0.5;
    this.rotation = Math.random() * 360;
    this.alpha = 1;
    this.life = 1;         // 1 = full life, 0 = dead
    this.maxLife = 2000 + Math.random() * 3000; // ms
  }
  
  update(deltaTime) {
    // Update extrinsic state
    this.x += this.velocityX * (deltaTime / 16);
    this.y += this.velocityY * (deltaTime / 16);
    this.velocityY += this.type.physics.gravity * (deltaTime / 16);
    this.rotation += this.type.physics.spin * (deltaTime / 16);
    
    this.life -= deltaTime / this.maxLife;
    this.alpha = Math.max(0, this.life);
    this.scale *= 0.999;
    
    return this.life > 0;
  }
  
  draw(context) {
    this.type.draw(context, this.x, this.y, this.scale, this.rotation, this.alpha);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PARTICLE SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class ParticleSystem {
  constructor() {
    this.particles = [];
  }
  
  emit(typeName, x, y, count = 10) {
    // Get or create the particle type flyweight
    const type = ParticleTypeFactory.getType(
      typeName,
      `${typeName}_sprite.png`,
      this.#getColorForType(typeName),
      this.#getPhysicsForType(typeName)
    );
    
    // Create particles with shared type
    for (let i = 0; i < count; i++) {
      this.particles.push(new Particle(type, x, y));
    }
  }
  
  #getColorForType(type) {
    const colors = {
      fire: '#ff4400',
      smoke: '#888888',
      spark: '#ffff00',
      water: '#0088ff',
      blood: '#880000'
    };
    return colors[type] || '#ffffff';
  }
  
  #getPhysicsForType(type) {
    const physics = {
      fire: { gravity: -0.1, spin: 2 },
      smoke: { gravity: -0.05, spin: 1 },
      spark: { gravity: 0.2, spin: 5 },
      water: { gravity: 0.3, spin: 0 },
      blood: { gravity: 0.4, spin: 0 }
    };
    return physics[type] || { gravity: 0.1, spin: 0 };
  }
  
  update(deltaTime) {
    this.particles = this.particles.filter(p => p.update(deltaTime));
  }
  
  draw(context) {
    this.particles.forEach(p => p.draw(context));
  }
  
  getStats() {
    const memoryPerFullParticle = 500; // bytes (estimated)
    const memoryPerFlyweight = 5000;   // bytes (with sprite/animations)
    const memoryPerContext = 50;       // bytes (just numbers)
    
    const withoutFlyweight = this.particles.length * memoryPerFullParticle;
    const withFlyweight = (
      ParticleTypeFactory.getTypeCount() * memoryPerFlyweight +
      this.particles.length * memoryPerContext
    );
    
    return {
      particleCount: this.particles.length,
      typeCount: ParticleTypeFactory.getTypeCount(),
      memoryWithout: `${(withoutFlyweight / 1024).toFixed(1)} KB`,
      memoryWith: `${(withFlyweight / 1024).toFixed(1)} KB`,
      savings: `${((1 - withFlyweight / withoutFlyweight) * 100).toFixed(1)}%`
    };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USAGE: Game simulation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const particleSystem = new ParticleSystem();

// Simulate explosions and effects
console.log('\n=== Creating Particles ===\n');

// Explosion creates fire and smoke
particleSystem.emit('fire', 100, 100, 50);
particleSystem.emit('smoke', 100, 100, 30);
particleSystem.emit('spark', 100, 100, 100);

// Blood splatter
particleSystem.emit('blood', 200, 150, 40);

// Waterfall
particleSystem.emit('water', 300, 50, 200);

// More fire
particleSystem.emit('fire', 400, 200, 100);

console.log('\n=== Statistics ===');
const stats = particleSystem.getStats();
console.log(`Total particles: ${stats.particleCount}`);
console.log(`Unique particle types: ${stats.typeCount}`);
console.log(`Memory without flyweight: ${stats.memoryWithout}`);
console.log(`Memory with flyweight: ${stats.memoryWith}`);
console.log(`Memory savings: ${stats.savings}`);

// Simulate a few frames
console.log('\n=== Simulating 3 frames ===\n');
for (let frame = 0; frame < 3; frame++) {
  console.log(`Frame ${frame + 1}:`);
  particleSystem.update(16); // 16ms per frame (60fps)
  console.log(`  Active particles: ${particleSystem.particles.length}`);
}
```

---

## 14.3 Tree Rendering Example

```javascript
// Forest with thousands of trees using flyweight
class TreeType {
  constructor(name, color, texture) {
    this.name = name;
    this.color = color;
    this.texture = texture;
    this.meshData = this.#generateMesh();
    console.log(`Created tree type: ${name}`);
  }
  
  #generateMesh() {
    // Simulate heavy 3D mesh data
    return new Array(10000).fill(0).map(() => Math.random());
  }
  
  draw(canvas, x, y, age) {
    // Scale based on age
    const scale = 0.5 + age * 0.1;
    console.log(`Drawing ${this.name} tree at (${x}, ${y}), scale: ${scale.toFixed(2)}`);
  }
}

class TreeFactory {
  static #types = new Map();
  
  static getTreeType(name, color, texture) {
    const key = `${name}_${color}_${texture}`;
    if (!this.#types.has(key)) {
      this.#types.set(key, new TreeType(name, color, texture));
    }
    return this.#types.get(key);
  }
  
  static getTypeCount() {
    return this.#types.size;
  }
}

class Tree {
  constructor(x, y, age, type) {
    this.x = x;
    this.y = y;
    this.age = age;
    this.type = type; // Flyweight reference
  }
  
  draw(canvas) {
    this.type.draw(canvas, this.x, this.y, this.age);
  }
}

class Forest {
  constructor() {
    this.trees = [];
  }
  
  plantTree(x, y, age, name, color, texture) {
    const type = TreeFactory.getTreeType(name, color, texture);
    this.trees.push(new Tree(x, y, age, type));
  }
  
  draw(canvas) {
    this.trees.forEach(tree => tree.draw(canvas));
  }
  
  getStats() {
    return {
      totalTrees: this.trees.length,
      treeTypes: TreeFactory.getTypeCount()
    };
  }
}

// Usage
const forest = new Forest();

// Plant 1000 trees of 3 types
console.log('\n=== Planting Forest ===\n');
for (let i = 0; i < 1000; i++) {
  const x = Math.random() * 1000;
  const y = Math.random() * 1000;
  const age = Math.random() * 10;
  
  const treeTypes = [
    ['Oak', 'green', 'oak.png'],
    ['Pine', 'darkgreen', 'pine.png'],
    ['Birch', 'lightgreen', 'birch.png']
  ];
  
  const [name, color, texture] = treeTypes[Math.floor(Math.random() * 3)];
  forest.plantTree(x, y, age, name, color, texture);
}

console.log('\n=== Forest Statistics ===');
const stats = forest.getStats();
console.log(`Total trees: ${stats.totalTrees}`);
console.log(`Tree types (flyweights): ${stats.treeTypes}`);
console.log(`Memory savings: ~99.7% (3 flyweights vs 1000 full objects)`);
```

---

## 14.4 Flyweight vs Object Pool

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              FLYWEIGHT vs OBJECT POOL                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  FLYWEIGHT:                      OBJECT POOL:               â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€               â”‚
â”‚  â€¢ Shares objects               â€¢ Reuses objects            â”‚
â”‚  â€¢ For immutable shared state   â€¢ For expensive creation    â”‚
â”‚  â€¢ Many clients use same object â€¢ Objects checked out/in    â”‚
â”‚  â€¢ Read-only shared data        â€¢ Objects are modified      â”‚
â”‚                                                             â”‚
â”‚  USE FLYWEIGHT WHEN:            USE POOL WHEN:              â”‚
â”‚  â€¢ Large number of objects      â€¢ Object creation expensive â”‚
â”‚  â€¢ Most state is shareable      â€¢ Objects are temporary     â”‚
â”‚  â€¢ State is immutable           â€¢ Limited concurrent use    â”‚
â”‚                                                             â”‚
â”‚  Example: 10000 characters      Example: 20 DB connections  â”‚
â”‚           sharing 26 glyphs                 being reused    â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Key Takeaways

1. **Flyweight shares common state** - Reduces memory for many similar objects
2. **Intrinsic vs Extrinsic** - Shared immutable vs unique per-instance
3. **Factory manages flyweights** - Creates or returns existing
4. **Context stores extrinsic** - Client maintains unique state
5. **Immutability required** - Shared state must not change
6. **Use for**: Large quantities of similar objects (particles, characters, trees)

> âš ï¸ **Important:** Flyweight adds complexity. Only use when memory is actually a problem and you have many similar objects.

> ğŸ’¡ **Interview Tip:** Explain the difference between Flyweight (sharing) and Prototype (cloning). Flyweight shares one object; Prototype creates copies.
