# ðŸ“˜ Master JavaScript Design Patterns
## Complete Guide: Beginner to Advanced (Interview & Production Ready)

---

# Part I: Foundation

## Chapter 1: Introduction to Design Patterns

### 1.1 What Are Design Patterns?
- Definition and origin (Gang of Four - GoF)
- Why design patterns matter in JavaScript
- Pattern vs Anti-pattern

### 1.2 Benefits of Design Patterns
- Code reusability and maintainability
- Common vocabulary for developers
- Proven solutions to recurring problems
- Scalability in large applications

### 1.3 Categories of Design Patterns
- **Creational** â€“ Object creation mechanisms
- **Structural** â€“ Object composition and relationships
- **Behavioral** â€“ Object communication and responsibility

> âš ï¸ **Important Note:** JavaScript is a prototype-based language, so classical patterns may need adaptation. Understanding prototypal inheritance is crucial before diving deep.

---

## Chapter 2: JavaScript Fundamentals for Design Patterns

### 2.1 Core Concepts (Prerequisites)
- First-class functions
- Closures and lexical scope
- `this` keyword and context binding
- Prototypal inheritance vs Classical inheritance
- ES6+ Classes (syntactic sugar)

### 2.2 Object Creation Techniques
- Object literals
- Constructor functions
- `Object.create()`
- ES6 Classes
- Factory functions

### 2.3 Advanced JavaScript Concepts
- IIFE (Immediately Invoked Function Expressions)
- Higher-order functions
- Currying and partial application
- Memoization
- Proxy and Reflect API
- WeakMap and WeakSet for private data
- Symbols for unique property keys

> ðŸ’¡ **Interview Tip:** Always be ready to explain the difference between `__proto__`, `prototype`, and `Object.getPrototypeOf()`.

---

# Part II: Creational Design Patterns

## Chapter 3: Singleton Pattern

### 3.1 Concept and Use Cases
- Ensuring a single instance
- Global state management
- Configuration objects
- Logger services

### 3.2 Implementation Techniques
- Classic Singleton with closure
- ES6 Module Singleton (preferred)
- Singleton with lazy initialization
- Thread-safe considerations (Node.js workers)

### 3.3 Code Variations
```javascript
// ES6 Module Singleton (Recommended)
class Database {
  constructor() {
    if (Database.instance) return Database.instance;
    Database.instance = this;
    this.connection = null;
  }
}
```

### 3.4 Production Considerations
- Testing challenges (mocking singletons)
- Dependency injection alternative
- Memory leaks in long-running applications

> âš ï¸ **Anti-pattern Warning:** Overusing Singleton can lead to hidden dependencies and make unit testing difficult. Prefer dependency injection in modern applications.

---

## Chapter 4: Factory Pattern

### 4.1 Simple Factory
- Centralized object creation
- Encapsulating `new` keyword
- Use case: UI component creation

### 4.2 Factory Method Pattern
- Defining interface for object creation
- Subclasses decide which class to instantiate
- Use case: Cross-platform UI elements

### 4.3 Abstract Factory Pattern
- Creating families of related objects
- Platform-independent code
- Use case: Theme systems, database adapters

### 4.4 Implementation Examples
```javascript
// Factory Method
class PaymentProcessorFactory {
  createProcessor(type) {
    switch(type) {
      case 'stripe': return new StripeProcessor();
      case 'paypal': return new PayPalProcessor();
      default: throw new Error('Unknown processor');
    }
  }
}
```

> ðŸ’¡ **Interview Tip:** Be ready to explain when to use Factory vs Constructor. Factory is preferred when creation logic is complex or needs to return different types.

---

## Chapter 5: Builder Pattern

### 5.1 Concept and Motivation
- Step-by-step object construction
- Separating construction from representation
- Fluent interface / Method chaining

### 5.2 Implementation Approaches
- Classic Builder with Director
- Fluent Builder (common in JS)
- Builder with validation

### 5.3 Use Cases
- Complex configuration objects
- Query builders (ORM)
- HTTP request builders
- Test data builders

### 5.4 Code Example
```javascript
class QueryBuilder {
  constructor() { this.query = {}; }
  select(fields) { this.query.select = fields; return this; }
  from(table) { this.query.from = table; return this; }
  where(condition) { this.query.where = condition; return this; }
  build() { return this.query; }
}

// Usage: new QueryBuilder().select('*').from('users').where({active: true}).build();
```

> ðŸ­ **Production Note:** Builder pattern is extensively used in libraries like Knex.js, Axios request configs, and test frameworks like Jest.

---

## Chapter 6: Prototype Pattern

### 6.1 JavaScript's Native Pattern
- Prototypal inheritance fundamentals
- `Object.create()` deep dive
- Prototype chain

### 6.2 Cloning Strategies
- Shallow copy vs Deep copy
- `Object.assign()` limitations
- `structuredClone()` (modern)
- JSON parse/stringify pitfalls
- Custom clone with recursion

### 6.3 Use Cases
- Object pool pattern
- Expensive object initialization
- Configuration templates

> âš ï¸ **Important:** `structuredClone()` cannot clone functions, DOM nodes, or objects with circular references containing non-clonable values.

---

## Chapter 7: Constructor Pattern

### 7.1 Traditional Constructor Functions
- `new` keyword mechanics
- Return value behavior
- Forgetting `new` problem

### 7.2 ES6 Classes
- Class syntax and semantics
- Static methods and properties
- Private fields (`#privateField`)
- Getters and setters

### 7.3 Best Practices
- Validation in constructors
- Default parameter values
- Immutable object creation with `Object.freeze()`

---

# Part III: Structural Design Patterns

## Chapter 8: Module Pattern

### 8.1 Classic Module Pattern (IIFE)
- Encapsulation with closures
- Public and private members
- Revealing Module Pattern

### 8.2 ES6 Modules
- `import` / `export` syntax
- Named vs Default exports
- Dynamic imports (`import()`)
- Tree shaking benefits

### 8.3 CommonJS vs ES Modules
- Node.js module system
- Interoperability challenges
- `.mjs` vs `.cjs` extensions

### 8.4 Production Module Architecture
- Barrel exports (`index.js`)
- Circular dependency handling
- Code splitting strategies

> ðŸ’¡ **Interview Tip:** Understand the difference between `module.exports` and `exports`, and why ES modules are statically analyzable.

---

## Chapter 9: Decorator Pattern

### 9.1 Concept and Motivation
- Adding responsibilities dynamically
- Alternative to subclassing
- Open/Closed principle adherence

### 9.2 Implementation Techniques
- Function decorators (wrapping)
- Class decorators (TC39 proposal)
- Method decorators
- Property decorators

### 9.3 Practical Examples
```javascript
// Function decorator
function withLogging(fn) {
  return function(...args) {
    console.log(`Calling ${fn.name} with`, args);
    const result = fn.apply(this, args);
    console.log(`Result:`, result);
    return result;
  };
}
```

### 9.4 Use Cases in Production
- Logging and analytics
- Authentication/Authorization
- Caching (memoization)
- Input validation
- Rate limiting

> ðŸ”¥ **Framework Usage:** Decorators are heavily used in Angular, NestJS, TypeORM, and MobX.

---

## Chapter 10: Adapter Pattern

### 10.1 Concept
- Converting interface to another
- Making incompatible classes work together
- Wrapper pattern

### 10.2 Implementation Types
- Object Adapter (composition)
- Class Adapter (inheritance - less common in JS)

### 10.3 Real-World Use Cases
- Third-party API integration
- Legacy code integration
- Data format transformation (XML to JSON)
- Database driver abstraction

### 10.4 Code Example
```javascript
// Adapting old API to new interface
class OldPaymentAPI {
  makePayment(amount) { /* old implementation */ }
}

class PaymentAdapter {
  constructor(oldAPI) { this.oldAPI = oldAPI; }
  pay(amount, currency) {
    const converted = this.convert(amount, currency);
    return this.oldAPI.makePayment(converted);
  }
}
```

---

## Chapter 11: Facade Pattern

### 11.1 Concept
- Simplified interface to complex subsystem
- Hiding complexity
- Entry point to library/framework

### 11.2 Implementation
- Combining multiple APIs
- Providing sensible defaults
- Error handling aggregation

### 11.3 Use Cases
- Library initialization (jQuery, Lodash)
- Complex DOM operations
- Multi-step processes (checkout flow)
- Microservices aggregation (BFF pattern)

> ðŸ—ï¸ **Architecture Note:** Backend-for-Frontend (BFF) is essentially a Facade at the API level.

---

## Chapter 12: Proxy Pattern

### 12.1 Concept and Types
- Controlling access to objects
- Virtual Proxy (lazy loading)
- Protection Proxy (access control)
- Caching Proxy
- Logging Proxy

### 12.2 ES6 Proxy API
- Handler traps (`get`, `set`, `apply`, etc.)
- Revocable proxies
- Reflect API integration

### 12.3 Advanced Use Cases
```javascript
const validator = {
  set(obj, prop, value) {
    if (prop === 'age' && typeof value !== 'number') {
      throw new TypeError('Age must be a number');
    }
    obj[prop] = value;
    return true;
  }
};
const person = new Proxy({}, validator);
```

### 12.4 Production Applications
- Vue.js 3 reactivity system
- Object validation
- Auto-saving forms
- API rate limiting
- Change detection

> âš ï¸ **Performance Note:** Proxies have a performance overhead. Avoid using them in hot paths or with high-frequency operations.

---

## Chapter 13: Composite Pattern

### 13.1 Concept
- Tree structures
- Part-whole hierarchies
- Uniform treatment of individual and composite objects

### 13.2 Implementation
- Component interface
- Leaf nodes
- Composite nodes with children

### 13.3 Use Cases
- File system representation
- DOM manipulation
- Menu/navigation structures
- Organization hierarchies
- React component trees

---

## Chapter 14: Flyweight Pattern

### 14.1 Concept
- Sharing common state
- Intrinsic vs Extrinsic state
- Memory optimization

### 14.2 Implementation
- Flyweight factory
- Object pool
- Caching shared instances

### 14.3 Use Cases
- Large lists rendering
- Game development (particles, sprites)
- Text editors (character rendering)
- Virtual scrolling optimization

> ðŸ’¡ **Interview Tip:** Flyweight is about sharing; Prototype is about cloning. Know the difference!

---

## Chapter 15: Bridge Pattern

### 15.1 Concept
- Decoupling abstraction from implementation
- Platform independence
- Multiple inheritance alternative

### 15.2 Use Cases
- Cross-platform rendering
- Database abstraction layers
- Device drivers
- Remote API implementations

---

# Part IV: Behavioral Design Patterns

## Chapter 16: Observer Pattern

### 16.1 Concept
- Subject and observers relationship
- Push vs Pull notification
- Loose coupling

### 16.2 Implementation
```javascript
class EventEmitter {
  constructor() { this.events = {}; }
  on(event, listener) {
    (this.events[event] ||= []).push(listener);
    return () => this.off(event, listener);
  }
  off(event, listener) {
    this.events[event] = this.events[event]?.filter(l => l !== listener);
  }
  emit(event, ...args) {
    this.events[event]?.forEach(listener => listener(...args));
  }
}
```

### 16.3 Built-in Implementations
- DOM Events (`addEventListener`)
- Node.js `EventEmitter`
- RxJS Observables
- Custom event buses

### 16.4 Production Considerations
- Memory leaks (forgotten subscriptions)
- Unsubscription patterns
- Event ordering
- Error handling in observers

> âš ï¸ **Critical:** Always unsubscribe observers to prevent memory leaks, especially in SPAs.

---

## Chapter 17: Publish-Subscribe Pattern

### 17.1 Difference from Observer
- Decoupled via message broker/channel
- Publishers don't know subscribers
- Event channels/topics

### 17.2 Implementation
- Event bus / Message broker
- Topic-based subscriptions
- Wildcard subscriptions

### 17.3 Use Cases
- Microservices communication
- Real-time features
- Cross-component communication (Vue/React)
- Logging systems

---

## Chapter 18: Mediator Pattern

### 18.1 Concept
- Centralized communication
- Reducing direct dependencies
- Colleague objects

### 18.2 Implementation
- Chat room example
- Form validation coordination
- Air traffic controller analogy

### 18.3 Mediator vs Observer
| Aspect | Mediator | Observer |
|--------|----------|----------|
| Communication | Bidirectional | Unidirectional |
| Coupling | Through mediator | Direct (loose) |
| Complexity | Mediator can grow | Distributed |

---

## Chapter 19: Command Pattern

### 19.1 Concept
- Encapsulating requests as objects
- Parameterizing operations
- Queuing and logging

### 19.2 Components
- Command interface
- Concrete commands
- Invoker
- Receiver

### 19.3 Advanced Features
- Undo/Redo functionality
- Command history
- Macro commands (composites)
- Transaction support

### 19.4 Use Cases
- Text editors (undo/redo)
- UI actions
- Job queues
- Transaction systems
- Remote procedure calls

```javascript
class CommandManager {
  constructor() { this.history = []; this.position = -1; }
  execute(command) {
    command.execute();
    this.history = this.history.slice(0, this.position + 1);
    this.history.push(command);
    this.position++;
  }
  undo() {
    if (this.position >= 0) this.history[this.position--].undo();
  }
  redo() {
    if (this.position < this.history.length - 1) this.history[++this.position].execute();
  }
}
```

---

## Chapter 20: Strategy Pattern

### 20.1 Concept
- Family of interchangeable algorithms
- Selecting algorithm at runtime
- Eliminating conditional statements

### 20.2 Implementation
```javascript
const strategies = {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b,
  multiply: (a, b) => a * b,
};

class Calculator {
  setStrategy(strategy) { this.strategy = strategy; }
  calculate(a, b) { return this.strategy(a, b); }
}
```

### 20.3 Use Cases
- Payment processing
- Authentication strategies (Passport.js)
- Sorting algorithms
- Validation rules
- Compression algorithms
- Pricing strategies

> ðŸ’¡ **Framework Example:** Passport.js uses Strategy pattern for different authentication methods (Local, OAuth, JWT).

---

## Chapter 21: State Pattern

### 21.1 Concept
- Object behavior changes with internal state
- State-specific behavior encapsulation
- Finite state machines

### 21.2 Implementation Approaches
- State classes
- State transition table
- Switch-based (simple cases)

### 21.3 State vs Strategy
| Aspect | State | Strategy |
|--------|-------|----------|
| Context awareness | States know about each other | Strategies are independent |
| Transition | State changes itself | External changes strategy |
| Purpose | Behavior based on state | Algorithm selection |

### 21.4 Use Cases
- Order status (pending â†’ paid â†’ shipped)
- Media player (playing/paused/stopped)
- Traffic lights
- Game character states
- UI component states

---

## Chapter 22: Chain of Responsibility Pattern

### 22.1 Concept
- Passing requests along handler chain
- Decoupling sender from receivers
- Dynamic chain construction

### 22.2 Implementation
```javascript
class Handler {
  setNext(handler) { this.next = handler; return handler; }
  handle(request) {
    if (this.next) return this.next.handle(request);
    return null;
  }
}
```

### 22.3 Use Cases
- Express.js middleware
- Event bubbling in DOM
- Logging levels
- Approval workflows
- Input validation chains

> ðŸ”¥ **Production Example:** Express.js middleware is the quintessential Chain of Responsibility implementation.

---

## Chapter 23: Iterator Pattern

### 23.1 Concept
- Sequential access without exposing structure
- Uniform traversal interface

### 23.2 JavaScript Built-in Support
- `Symbol.iterator`
- `for...of` loop
- Spread operator
- Array.from()

### 23.3 Custom Iterators
```javascript
const range = {
  from: 1,
  to: 5,
  [Symbol.iterator]() {
    return {
      current: this.from,
      last: this.to,
      next() {
        return this.current <= this.last
          ? { done: false, value: this.current++ }
          : { done: true };
      }
    };
  }
};
```

### 23.4 Generators
- `function*` syntax
- `yield` keyword
- Lazy evaluation
- Infinite sequences
- Async iterators (`for await...of`)

---

## Chapter 24: Template Method Pattern

### 24.1 Concept
- Algorithm skeleton in base class
- Subclasses override specific steps
- "Hollywood Principle" - Don't call us, we'll call you

### 24.2 Implementation
- Abstract base class
- Hook methods
- Required vs optional steps

### 24.3 Use Cases
- Framework extension points
- Data processing pipelines
- Build processes
- Test fixtures (setup/teardown)

---

## Chapter 25: Visitor Pattern

### 25.1 Concept
- Adding operations without modifying classes
- Double dispatch technique
- Separating algorithm from object structure

### 25.2 Use Cases
- AST traversal (Babel, ESLint)
- Document export (PDF, HTML, XML)
- Report generation
- Serialization

---

## Chapter 26: Memento Pattern

### 26.1 Concept
- Capturing and restoring object state
- Undo mechanism
- Snapshot functionality

### 26.2 Implementation Components
- Originator (object being saved)
- Memento (stored state)
- Caretaker (manages mementos)

### 26.3 Use Cases
- Editor history
- Form state management
- Game save/load
- Transaction rollback

---

# Part V: Modern JavaScript Patterns

## Chapter 27: Async Patterns

### 27.1 Callback Pattern
- Error-first callbacks (Node.js convention)
- Callback hell problem
- Error handling

### 27.2 Promise Patterns
- Promise chaining
- `Promise.all()` - parallel execution
- `Promise.race()` - first settled
- `Promise.allSettled()` - all results
- `Promise.any()` - first fulfilled
- Error handling with `.catch()`

### 27.3 Async/Await Patterns
- Sequential vs parallel execution
- Error handling with try/catch
- Top-level await
- Async iterators

### 27.4 Advanced Async Patterns
```javascript
// Retry pattern with exponential backoff
async function retry(fn, retries = 3, delay = 1000) {
  for (let i = 0; i < retries; i++) {
    try { return await fn(); }
    catch (err) {
      if (i === retries - 1) throw err;
      await new Promise(r => setTimeout(r, delay * Math.pow(2, i)));
    }
  }
}
```

- Debounce and Throttle
- Request queuing
- Circuit breaker
- Bulkhead pattern

> ðŸ’¡ **Interview Tip:** Be able to implement `Promise.all` and `Promise.race` from scratch.

---

## Chapter 28: Reactive Patterns

### 28.1 Observable Pattern
- RxJS fundamentals
- Subjects (Subject, BehaviorSubject, ReplaySubject)
- Operators (map, filter, switchMap, etc.)

### 28.2 Signal Pattern (Modern)
- Fine-grained reactivity
- Solid.js signals
- Angular signals
- Preact signals

### 28.3 Store Patterns
- Flux architecture
- Redux pattern
- MobX observables
- Zustand/Jotai patterns

---

## Chapter 29: Dependency Injection Pattern

### 29.1 Concept
- Inversion of Control (IoC)
- Loose coupling
- Testability improvement

### 29.2 Implementation Types
- Constructor injection
- Property injection
- Method injection
- IoC containers

### 29.3 DI in JavaScript
```javascript
// Simple DI container
class Container {
  constructor() { this.services = new Map(); }
  register(name, factory) { this.services.set(name, factory); }
  resolve(name) {
    const factory = this.services.get(name);
    if (!factory) throw new Error(`Service ${name} not found`);
    return factory(this);
  }
}
```

### 29.4 Framework Examples
- NestJS dependency injection
- Angular DI system
- InversifyJS

---

## Chapter 30: Middleware Pattern

### 30.1 Concept
- Request/response pipeline
- Cross-cutting concerns
- Composable functions

### 30.2 Implementation
```javascript
function compose(...middlewares) {
  return function(context, next) {
    let index = -1;
    function dispatch(i) {
      if (i <= index) return Promise.reject(new Error('next() called multiple times'));
      index = i;
      let fn = middlewares[i];
      if (i === middlewares.length) fn = next;
      if (!fn) return Promise.resolve();
      return Promise.resolve(fn(context, () => dispatch(i + 1)));
    }
    return dispatch(0);
  };
}
```

### 30.3 Use Cases
- Express.js/Koa.js
- Redux middleware
- API request interceptors
- Logging and monitoring

---

## Chapter 31: Repository Pattern

### 31.1 Concept
- Abstracting data access
- Collection-like interface
- Decoupling business logic from data layer

### 31.2 Implementation
```javascript
class UserRepository {
  constructor(dataSource) { this.dataSource = dataSource; }
  async findById(id) { return this.dataSource.query('users', { id }); }
  async findAll() { return this.dataSource.query('users'); }
  async save(user) { return this.dataSource.insert('users', user); }
  async delete(id) { return this.dataSource.delete('users', { id }); }
}
```

### 31.3 Benefits
- Testability (mock data sources)
- Switching databases
- Query abstraction

---

## Chapter 32: Unit of Work Pattern

### 32.1 Concept
- Tracking changes to objects
- Batch persistence
- Transaction management

### 32.2 Use Cases
- ORM implementations
- Complex transactions
- Optimistic concurrency

---

# Part VI: Architectural Patterns

## Chapter 33: MVC, MVP, MVVM

### 33.1 MVC (Model-View-Controller)
- Traditional web applications
- Server-side rendering
- Backbone.js example

### 33.2 MVP (Model-View-Presenter)
- Passive view
- Testable presentation logic

### 33.3 MVVM (Model-View-ViewModel)
- Two-way data binding
- Vue.js, Angular, Knockout.js

### 33.4 Comparison Table
| Pattern | View-Model Relationship | Testing | Framework Examples |
|---------|-------------------------|---------|-------------------|
| MVC | Controller mediates | Medium | Express, Backbone |
| MVP | Presenter drives view | High | - |
| MVVM | Two-way binding | High | Vue, Angular, Knockout |

---

## Chapter 34: Component Pattern

### 34.1 Modern UI Architecture
- Self-contained units
- Props and state
- Composition over inheritance

### 34.2 Component Types
- Presentational (dumb) components
- Container (smart) components
- Higher-Order Components (HOC)
- Render props
- Custom hooks

### 34.3 Component Design Principles
- Single responsibility
- Controlled vs Uncontrolled
- Lifting state up
- Prop drilling solutions

---

## Chapter 35: Micro-Frontend Pattern

### 35.1 Concept
- Independent deployment
- Team autonomy
- Technology diversity

### 35.2 Implementation Approaches
- Module Federation (Webpack 5)
- Single-SPA
- iframes
- Web Components

---

# Part VII: Production-Grade Patterns

## Chapter 36: Error Handling Patterns

### 36.1 Error Types
- Operational vs Programmer errors
- Custom error classes
- Error codes and categorization

### 36.2 Implementation
```javascript
class AppError extends Error {
  constructor(message, code, statusCode = 500, isOperational = true) {
    super(message);
    this.code = code;
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    Error.captureStackTrace(this, this.constructor);
  }
}
```

### 36.3 Patterns
- Global error handler
- Error boundary (React)
- Circuit breaker
- Graceful degradation
- Retry with backoff

---

## Chapter 37: Caching Patterns

### 37.1 Strategies
- Cache-aside (Lazy loading)
- Read-through
- Write-through
- Write-behind (Write-back)

### 37.2 Implementation
- In-memory cache (Map, WeakMap)
- LRU cache implementation
- Time-based expiration
- Cache invalidation

### 37.3 Use Cases
- API response caching
- Memoization
- Service Worker cache
- State normalization

---

## Chapter 38: Concurrency Patterns

### 38.1 Web Workers
- Offloading heavy computation
- Communication via postMessage
- Transferable objects

### 38.2 SharedArrayBuffer
- Shared memory
- Atomics operations
- Lock-free programming

### 38.3 Patterns
- Producer-Consumer
- Object pool
- Semaphore
- Mutex implementation

---

## Chapter 39: Security Patterns

### 39.1 Input Validation
- Sanitization
- Schema validation (Joi, Zod)
- Type coercion handling

### 39.2 Authentication Patterns
- Token-based (JWT)
- Session-based
- OAuth 2.0 flows
- Refresh token rotation

### 39.3 Authorization Patterns
- Role-Based Access Control (RBAC)
- Attribute-Based Access Control (ABAC)
- Policy pattern

---

## Chapter 40: Testing Patterns

### 40.1 Unit Testing Patterns
- Arrange-Act-Assert (AAA)
- Test doubles (Mock, Stub, Spy, Fake)
- Dependency injection for testing

### 40.2 Mocking Patterns
```javascript
// Simple mock factory
function createMock(methods) {
  const calls = {};
  return new Proxy({}, {
    get(target, prop) {
      if (prop === '_calls') return calls;
      calls[prop] = calls[prop] || [];
      return (...args) => {
        calls[prop].push(args);
        return methods[prop]?.(...args);
      };
    }
  });
}
```

### 40.3 Integration Testing
- Test containers
- API mocking (MSW)
- Snapshot testing

---

# Part VIII: Anti-Patterns to Avoid

## Chapter 41: Common Anti-Patterns

### 41.1 Creational Anti-Patterns
- **God Object** - Object that knows too much
- **Singleton abuse** - Global state everywhere
- **New in constructor** - Hard to test

### 41.2 Structural Anti-Patterns
- **Spaghetti code** - No clear structure
- **Big Ball of Mud** - Lack of architecture
- **Circular dependencies**

### 41.3 Behavioral Anti-Patterns
- **Callback hell** - Deeply nested callbacks
- **Premature optimization**
- **Magic numbers/strings**

### 41.4 JavaScript-Specific
- **Mutating function arguments**
- **Implicit globals**
- **Type coercion bugs**
- **Prototype pollution**

> âš ï¸ **Critical:** Always validate and sanitize user input to prevent prototype pollution attacks.

---

# Part IX: Interview Preparation

## Chapter 42: Interview Focus Areas

### 42.1 Frequently Asked Patterns
1. Singleton (implement and discuss drawbacks)
2. Observer/Pub-Sub (implement EventEmitter)
3. Factory (when to use)
4. Strategy (runtime algorithm selection)
5. Decorator (function wrappers)
6. Proxy (ES6 Proxy use cases)
7. Module (ES6 modules vs CommonJS)

### 42.2 Common Interview Questions
- Implement Promise from scratch
- Implement debounce/throttle
- Implement EventEmitter
- Implement dependency injection container
- Implement LRU cache
- Deep clone an object
- Implement pub/sub system

### 42.3 System Design with Patterns
- Design a notification system
- Design a state management library
- Design a form validation system
- Design a plugin architecture

### 42.4 Code Review Questions
- Identify patterns in given code
- Refactor code using patterns
- Explain trade-offs

---

## Chapter 43: Quick Reference Card

### 43.1 Pattern Selection Guide

| Problem | Pattern to Consider |
|---------|-------------------|
| Complex object creation | Builder, Factory |
| Single instance needed | Singleton, Module |
| Adding behavior dynamically | Decorator |
| Incompatible interfaces | Adapter |
| Complex subsystem | Facade |
| Access control | Proxy |
| State-dependent behavior | State |
| Algorithm selection | Strategy |
| Event handling | Observer, Pub/Sub |
| Undo functionality | Command, Memento |
| Sequential access | Iterator |
| Request handling chain | Chain of Responsibility |

### 43.2 SOLID Principles Mapping
- **S**ingle Responsibility â†’ Module, Strategy
- **O**pen/Closed â†’ Decorator, Strategy
- **L**iskov Substitution â†’ Factory Method
- **I**nterface Segregation â†’ Adapter, Facade
- **D**ependency Inversion â†’ DI, Factory

---

## Appendix A: Resources

### Books
- "JavaScript Patterns" - Stoyan Stefanov
- "Learning JavaScript Design Patterns" - Addy Osmani
- "Design Patterns: Elements of Reusable OO Software" - GoF
- "Head First Design Patterns"

### Online Resources
- Refactoring.guru
- patterns.dev
- JavaScript.info
- MDN Web Docs

### Practice Platforms
- LeetCode (System Design)
- Frontend Masters
- Exercism

---

> ðŸ“Œ **Final Note:** Design patterns are tools, not rules. Use them when they solve real problems, not to show off. The best code is often the simplest code that works.
