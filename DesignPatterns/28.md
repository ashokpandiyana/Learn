# Chapter 28: Reactive Patterns - In Depth Guide

## ğŸ“š Overview

Reactive programming is a declarative programming paradigm concerned with data streams and the propagation of change. When one value changes, all dependent values automatically update.

## ğŸŒŠ Core Concepts

### Reactive Principles
1. **Responsive**: System responds in a timely manner
2. **Resilient**: System stays responsive in the face of failure
3. **Elastic**: System stays responsive under varying workload
4. **Message Driven**: Relies on asynchronous message-passing

## 1ï¸âƒ£ Observable Pattern (RxJS)

### Basic Observable

```javascript
// Simple Observable implementation
class Observable {
  constructor(subscribe) {
    this._subscribe = subscribe;
  }

  subscribe(observer) {
    return this._subscribe(observer);
  }

  // Operator: map
  map(transformFn) {
    return new Observable(observer => {
      return this.subscribe({
        next: value => observer.next(transformFn(value)),
        error: err => observer.error(err),
        complete: () => observer.complete()
      });
    });
  }

  // Operator: filter
  filter(predicateFn) {
    return new Observable(observer => {
      return this.subscribe({
        next: value => {
          if (predicateFn(value)) {
            observer.next(value);
          }
        },
        error: err => observer.error(err),
        complete: () => observer.complete()
      });
    });
  }

  // Static creator: of
  static of(...values) {
    return new Observable(observer => {
      values.forEach(value => observer.next(value));
      observer.complete();
      return { unsubscribe: () => {} };
    });
  }

  // Static creator: from event
  static fromEvent(element, eventName) {
    return new Observable(observer => {
      const handler = event => observer.next(event);
      element.addEventListener(eventName, handler);
      
      return {
        unsubscribe: () => element.removeEventListener(eventName, handler)
      };
    });
  }

  // Static creator: interval
  static interval(period) {
    return new Observable(observer => {
      let count = 0;
      const id = setInterval(() => {
        observer.next(count++);
      }, period);
      
      return {
        unsubscribe: () => clearInterval(id)
      };
    });
  }
}

// Usage Examples
const numbers$ = Observable.of(1, 2, 3, 4, 5);

const doubled$ = numbers$
  .map(x => x * 2)
  .filter(x => x > 5);

doubled$.subscribe({
  next: value => console.log('Value:', value),
  error: err => console.error('Error:', err),
  complete: () => console.log('Complete!')
});

// Event stream
const clicks$ = Observable.fromEvent(document, 'click');
const clickPositions$ = clicks$.map(e => ({ x: e.clientX, y: e.clientY }));

const subscription = clickPositions$.subscribe({
  next: pos => console.log('Click at:', pos)
});

// Unsubscribe after 5 seconds
setTimeout(() => subscription.unsubscribe(), 5000);
```

### Advanced RxJS Operators

```javascript
// Using real RxJS (install: npm install rxjs)
import { 
  fromEvent, interval, of, merge, combineLatest, 
  Subject, BehaviorSubject, ReplaySubject 
} from 'rxjs';
import { 
  map, filter, debounceTime, throttleTime, 
  switchMap, mergeMap, catchError, retry,
  take, takeUntil, distinctUntilChanged
} from 'rxjs/operators';

// Example 1: Search with debounce
const searchInput = document.getElementById('search');
const search$ = fromEvent(searchInput, 'input').pipe(
  map(e => e.target.value),
  debounceTime(300),
  distinctUntilChanged(),
  switchMap(query => 
    fetch(`/api/search?q=${query}`)
      .then(r => r.json())
      .catch(err => of([]))
  )
);

search$.subscribe(results => {
  console.log('Search results:', results);
});

// Example 2: Auto-save with debounce
const editor = document.getElementById('editor');
const autoSave$ = fromEvent(editor, 'input').pipe(
  debounceTime(1000),
  map(e => e.target.value),
  switchMap(content =>
    fetch('/api/save', {
      method: 'POST',
      body: JSON.stringify({ content })
    }).then(() => content)
  )
);

autoSave$.subscribe(
  content => console.log('Saved:', content),
  error => console.error('Save failed:', error)
);

// Example 3: Infinite scroll
const scrollEvents$ = fromEvent(window, 'scroll');
const nearBottom$ = scrollEvents$.pipe(
  throttleTime(200),
  map(() => {
    const scrollY = window.scrollY;
    const visible = document.documentElement.clientHeight;
    const pageHeight = document.documentElement.scrollHeight;
    const bottomOfPage = visible + scrollY >= pageHeight - 100;
    return bottomOfPage;
  }),
  filter(atBottom => atBottom),
  distinctUntilChanged()
);

nearBottom$.subscribe(() => {
  console.log('Loading more items...');
  // Load more items
});

// Example 4: Combining multiple streams
const mouseMove$ = fromEvent(document, 'mousemove');
const mouseDown$ = fromEvent(document, 'mousedown');
const mouseUp$ = fromEvent(document, 'mouseup');

const drag$ = mouseDown$.pipe(
  switchMap(() => 
    mouseMove$.pipe(
      map(e => ({ x: e.clientX, y: e.clientY })),
      takeUntil(mouseUp$)
    )
  )
);

drag$.subscribe(pos => {
  console.log('Dragging to:', pos);
});
```

### Subjects in RxJS

```javascript
import { Subject, BehaviorSubject, ReplaySubject } from 'rxjs';

// 1. Subject - Basic multicast
const subject = new Subject();

subject.subscribe(v => console.log('Observer 1:', v));
subject.subscribe(v => console.log('Observer 2:', v));

subject.next(1); // Both observers receive 1
subject.next(2); // Both observers receive 2

// 2. BehaviorSubject - Stores last value
const behaviorSubject = new BehaviorSubject(0); // Initial value

behaviorSubject.subscribe(v => console.log('Early subscriber:', v)); // Gets 0
behaviorSubject.next(1);
behaviorSubject.next(2);

behaviorSubject.subscribe(v => console.log('Late subscriber:', v)); // Gets 2

// 3. ReplaySubject - Replays last N values
const replaySubject = new ReplaySubject(2); // Buffer size of 2

replaySubject.next(1);
replaySubject.next(2);
replaySubject.next(3);

replaySubject.subscribe(v => console.log('Replay subscriber:', v)); 
// Gets 2 and 3

// Practical: Event bus
class EventBus {
  constructor() {
    this.subject = new Subject();
  }

  emit(event) {
    this.subject.next(event);
  }

  on(eventType) {
    return this.subject.pipe(
      filter(event => event.type === eventType),
      map(event => event.payload)
    );
  }
}

const bus = new EventBus();

bus.on('user:login').subscribe(user => {
  console.log('User logged in:', user);
});

bus.emit({ type: 'user:login', payload: { id: 1, name: 'John' } });
```

## 2ï¸âƒ£ Signal Pattern (Modern Fine-grained Reactivity)

### Basic Signal Implementation

```javascript
// Simple Signal implementation (similar to Solid.js)
class Signal {
  constructor(value) {
    this._value = value;
    this._subscribers = new Set();
  }

  get value() {
    // Track dependency if there's an active effect
    if (currentEffect) {
      this._subscribers.add(currentEffect);
    }
    return this._value;
  }

  set value(newValue) {
    if (this._value !== newValue) {
      this._value = newValue;
      this._notify();
    }
  }

  _notify() {
    this._subscribers.forEach(effect => effect.execute());
  }
}

class Effect {
  constructor(fn) {
    this.fn = fn;
    this.execute();
  }

  execute() {
    currentEffect = this;
    this.fn();
    currentEffect = null;
  }
}

let currentEffect = null;

function createSignal(initialValue) {
  const signal = new Signal(initialValue);
  return [
    () => signal.value,
    (newValue) => { signal.value = newValue; }
  ];
}

function createEffect(fn) {
  new Effect(fn);
}

// Usage
const [count, setCount] = createSignal(0);
const [name, setName] = createSignal('John');

createEffect(() => {
  console.log(`Count is: ${count()}`);
});

createEffect(() => {
  console.log(`Name is: ${name()}`);
});

setCount(1); // Logs: "Count is: 1"
setCount(2); // Logs: "Count is: 2"
setName('Jane'); // Logs: "Name is: Jane"
```

### Computed Signals (Derived State)

```javascript
function createMemo(fn) {
  const signal = new Signal(undefined);
  
  createEffect(() => {
    signal.value = fn();
  });
  
  return () => signal.value;
}

// Usage
const [firstName, setFirstName] = createSignal('John');
const [lastName, setLastName] = createSignal('Doe');

const fullName = createMemo(() => {
  return `${firstName()} ${lastName()}`;
});

createEffect(() => {
  console.log(`Full name: ${fullName()}`);
});

setFirstName('Jane'); // Logs: "Full name: Jane Doe"
setLastName('Smith'); // Logs: "Full name: Jane Smith"
```

### Practical Signals Example: Counter App

```javascript
// Complete counter with signals
class SignalStore {
  constructor() {
    const [count, setCount] = createSignal(0);
    const [multiplier, setMultiplier] = createSignal(2);
    
    const doubled = createMemo(() => count() * multiplier());
    const isEven = createMemo(() => count() % 2 === 0);
    
    this.count = count;
    this.setCount = setCount;
    this.multiplier = multiplier;
    this.setMultiplier = setMultiplier;
    this.doubled = doubled;
    this.isEven = isEven;
    
    this.increment = () => setCount(count() + 1);
    this.decrement = () => setCount(count() - 1);
    this.reset = () => setCount(0);
  }
}

const store = new SignalStore();

// UI updates automatically
createEffect(() => {
  document.getElementById('count').textContent = store.count();
});

createEffect(() => {
  document.getElementById('doubled').textContent = store.doubled();
});

createEffect(() => {
  document.getElementById('parity').textContent = 
    store.isEven() ? 'Even' : 'Odd';
});

// Event handlers
document.getElementById('increment').onclick = store.increment;
document.getElementById('decrement').onclick = store.decrement;
document.getElementById('reset').onclick = store.reset;
```

## 3ï¸âƒ£ Store Patterns

### Redux Pattern

```javascript
// Redux-style store
class Store {
  constructor(reducer, initialState) {
    this.reducer = reducer;
    this.state = initialState;
    this.listeners = [];
  }

  getState() {
    return this.state;
  }

  dispatch(action) {
    this.state = this.reducer(this.state, action);
    this.listeners.forEach(listener => listener(this.state));
  }

  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
}

// Reducer
function counterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    case 'SET':
      return { ...state, count: action.payload };
    default:
      return state;
  }
}

// Usage
const store = new Store(counterReducer, { count: 0 });

store.subscribe(state => {
  console.log('State changed:', state);
});

store.dispatch({ type: 'INCREMENT' }); // State: { count: 1 }
store.dispatch({ type: 'INCREMENT' }); // State: { count: 2 }
store.dispatch({ type: 'SET', payload: 10 }); // State: { count: 10 }

// Middleware support
class StoreWithMiddleware extends Store {
  constructor(reducer, initialState, middlewares = []) {
    super(reducer, initialState);
    this.middlewares = middlewares;
  }

  dispatch(action) {
    const chain = this.middlewares.map(middleware =>
      middleware(this)
    );

    const composedDispatch = chain.reduce(
      (next, middleware) => middleware(next),
      (action) => super.dispatch(action)
    );

    return composedDispatch(action);
  }
}

// Logger middleware
const logger = store => next => action => {
  console.log('Dispatching:', action);
  const result = next(action);
  console.log('Next state:', store.getState());
  return result;
};

// Async middleware
const thunk = store => next => action => {
  if (typeof action === 'function') {
    return action(store.dispatch, store.getState);
  }
  return next(action);
};

const storeWithMiddleware = new StoreWithMiddleware(
  counterReducer,
  { count: 0 },
  [logger, thunk]
);
```

### MobX-style Observable Store

```javascript
// Simple observable store (MobX-like)
class Observable {
  constructor(target) {
    this.observers = new Set();
    this.proxy = new Proxy(target, {
      set: (obj, prop, value) => {
        obj[prop] = value;
        this.notify();
        return true;
      }
    });
  }

  observe(fn) {
    this.observers.add(fn);
    return () => this.observers.delete(fn);
  }

  notify() {
    this.observers.forEach(fn => fn());
  }

  get value() {
    return this.proxy;
  }
}

// Usage
const observableState = new Observable({
  count: 0,
  name: 'John'
});

observableState.observe(() => {
  console.log('State changed:', observableState.value);
});

observableState.value.count++; // Triggers observer
observableState.value.name = 'Jane'; // Triggers observer

// Computed values with observables
class ComputedObservable {
  constructor(fn, dependencies) {
    this.fn = fn;
    this.dependencies = dependencies;
    this.cached = null;
    this.dirty = true;

    dependencies.forEach(dep => {
      dep.observe(() => {
        this.dirty = true;
      });
    });
  }

  get value() {
    if (this.dirty) {
      this.cached = this.fn();
      this.dirty = false;
    }
    return this.cached;
  }
}
```

### Zustand-style Store (Modern, Simple)

```javascript
// Zustand-inspired simple store
function create(createState) {
  let state;
  const listeners = new Set();

  const setState = (partial) => {
    const nextState = typeof partial === 'function' 
      ? partial(state) 
      : partial;
    
    if (nextState !== state) {
      state = { ...state, ...nextState };
      listeners.forEach(listener => listener(state));
    }
  };

  const getState = () => state;

  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };

  const api = { setState, getState, subscribe };
  state = createState(setState, getState, api);

  return api;
}

// Usage
const useStore = create((set, get) => ({
  count: 0,
  increment: () => set(state => ({ count: state.count + 1 })),
  decrement: () => set(state => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 }),
  
  // Async actions
  incrementAsync: async () => {
    await new Promise(resolve => setTimeout(resolve, 1000));
    set(state => ({ count: state.count + 1 }));
  }
}));

// Subscribe to changes
useStore.subscribe(state => {
  console.log('Count changed:', state.count);
});

// Use the store
useStore.getState().increment();
useStore.getState().incrementAsync();
```

## 4ï¸âƒ£ Reactive UI Patterns

### Virtual DOM with Reactive Updates

```javascript
// Simple reactive virtual DOM
class ReactiveComponent {
  constructor(container) {
    this.container = container;
    this.state = new Observable({});
    this.state.observe(() => this.render());
  }

  setState(partial) {
    Object.assign(this.state.value, partial);
  }

  render() {
    const vdom = this.template();
    this.container.innerHTML = '';
    this.container.appendChild(this.createElement(vdom));
  }

  createElement(vnode) {
    if (typeof vnode === 'string') {
      return document.createTextNode(vnode);
    }

    const element = document.createElement(vnode.tag);

    // Add props
    if (vnode.props) {
      Object.entries(vnode.props).forEach(([key, value]) => {
        if (key.startsWith('on')) {
          const event = key.substring(2).toLowerCase();
          element.addEventListener(event, value);
        } else {
          element.setAttribute(key, value);
        }
      });
    }

    // Add children
    if (vnode.children) {
      vnode.children.forEach(child => {
        element.appendChild(this.createElement(child));
      });
    }

    return element;
  }

  template() {
    // Override in subclass
    return { tag: 'div', children: [] };
  }
}

// Usage
class Counter extends ReactiveComponent {
  constructor(container) {
    super(container);
    this.setState({ count: 0 });
  }

  template() {
    return {
      tag: 'div',
      children: [
        {
          tag: 'h1',
          children: [`Count: ${this.state.value.count}`]
        },
        {
          tag: 'button',
          props: {
            onclick: () => this.setState({ 
              count: this.state.value.count + 1 
            })
          },
          children: ['Increment']
        }
      ]
    };
  }
}

const counter = new Counter(document.getElementById('app'));
```

### Data Binding (Two-way)

```javascript
// Two-way data binding
class DataBinding {
  constructor(data) {
    this.data = new Proxy(data, {
      set: (target, property, value) => {
        target[property] = value;
        this.updateView(property, value);
        return true;
      }
    });
    this.bindings = new Map();
  }

  bind(property, element, attribute = 'value') {
    if (!this.bindings.has(property)) {
      this.bindings.set(property, []);
    }
    
    this.bindings.get(property).push({ element, attribute });

    // Setup two-way binding for inputs
    if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
      element.addEventListener('input', (e) => {
        this.data[property] = e.target.value;
      });
    }

    // Initial update
    this.updateView(property, this.data[property]);
  }

  updateView(property, value) {
    const bindings = this.bindings.get(property);
    if (bindings) {
      bindings.forEach(({ element, attribute }) => {
        if (attribute === 'textContent') {
          element.textContent = value;
        } else if (attribute === 'value') {
          element.value = value;
        } else {
          element.setAttribute(attribute, value);
        }
      });
    }
  }
}

// Usage
const binding = new DataBinding({
  username: '',
  email: ''
});

binding.bind('username', document.getElementById('input-username'), 'value');
binding.bind('username', document.getElementById('display-username'), 'textContent');
binding.bind('email', document.getElementById('input-email'), 'value');
```

## ğŸ¯ When to Use Each Pattern

| Pattern | Use Case | Framework Examples |
|---------|----------|-------------------|
| **Observable** | Complex async event streams | RxJS, Most.js |
| **Signal** | Fine-grained reactivity | Solid.js, Preact Signals |
| **Redux** | Centralized state management | Redux, Vuex |
| **MobX** | Automatic dependency tracking | MobX |
| **Zustand** | Simple global state | Zustand, Jotai |

## ğŸš€ Best Practices

1. **Unsubscribe**: Always clean up subscriptions
2. **Immutability**: Keep state immutable in Redux-style stores
3. **Granularity**: Use signals for fine-grained updates
4. **Debouncing**: Debounce frequent updates
5. **Memoization**: Cache computed values
6. **Error Handling**: Handle stream errors properly
7. **Memory**: Watch for memory leaks in subscriptions

## ğŸ“ Summary

Reactive patterns enable building responsive, dynamic applications. Choose Observables for complex async streams, Signals for fine-grained reactivity, and store patterns for state management. Each pattern has its place in modern JavaScript development.