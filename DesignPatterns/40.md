# Chapter 40: Testing Patterns

## Introduction

Testing is crucial for maintaining code quality and preventing regressions. This chapter covers essential testing patterns, from unit tests to integration tests, with practical JavaScript examples.

---

## 40.1 Testing Fundamentals

### Arrange-Act-Assert (AAA) Pattern

The fundamental structure for writing clear tests:

```javascript
describe('Calculator', () => {
  test('should add two numbers correctly', () => {
    // Arrange - Set up test data and conditions
    const calculator = new Calculator();
    const a = 5;
    const b = 3;
    
    // Act - Execute the code being tested
    const result = calculator.add(a, b);
    
    // Assert - Verify the results
    expect(result).toBe(8);
  });
});
```

### Given-When-Then (BDD Style)

Behavior-driven development pattern:

```javascript
describe('User Authentication', () => {
  it('should allow login with valid credentials', () => {
    // Given - I am a registered user
    const user = {
      email: 'test@example.com',
      password: 'SecurePass123!'
    };
    
    // When - I submit valid credentials
    const result = authService.login(user.email, user.password);
    
    // Then - I should be authenticated
    expect(result.success).toBe(true);
    expect(result.token).toBeDefined();
  });
});
```

---

## 40.2 Test Doubles (Mocks, Stubs, Spies, Fakes)

### Stub Pattern

Provides predetermined responses:

```javascript
class DatabaseStub {
  findById(id) {
    // Return fake data
    return {
      id,
      name: 'Test User',
      email: 'test@example.com'
    };
  }
  
  save(data) {
    // Do nothing, return success
    return { ...data, id: 123 };
  }
}

// Usage in test
describe('UserService', () => {
  test('should retrieve user by id', async () => {
    const dbStub = new DatabaseStub();
    const userService = new UserService(dbStub);
    
    const user = await userService.getUser(1);
    
    expect(user.name).toBe('Test User');
  });
});
```

### Mock Pattern

Verifies interactions:

```javascript
class EmailServiceMock {
  constructor() {
    this.sentEmails = [];
    this.sendCalls = 0;
  }
  
  send(to, subject, body) {
    this.sendCalls++;
    this.sentEmails.push({ to, subject, body });
    return Promise.resolve({ success: true });
  }
  
  // Verification methods
  wasCalled() {
    return this.sendCalls > 0;
  }
  
  wasCalledWith(to, subject) {
    return this.sentEmails.some(email => 
      email.to === to && email.subject === subject
    );
  }
  
  wasCalledTimes(count) {
    return this.sendCalls === count;
  }
}

// Usage
describe('NotificationService', () => {
  test('should send welcome email on user registration', async () => {
    // Arrange
    const emailMock = new EmailServiceMock();
    const notificationService = new NotificationService(emailMock);
    const user = { email: 'new@example.com', name: 'John' };
    
    // Act
    await notificationService.sendWelcomeEmail(user);
    
    // Assert
    expect(emailMock.wasCalled()).toBe(true);
    expect(emailMock.wasCalledWith(user.email, 'Welcome!')).toBe(true);
    expect(emailMock.wasCalledTimes(1)).toBe(true);
  });
});
```

### Spy Pattern

Wraps real objects to record interactions:

```javascript
function createSpy(obj, methodName) {
  const originalMethod = obj[methodName];
  const calls = [];
  
  obj[methodName] = function(...args) {
    calls.push({ args, timestamp: Date.now() });
    return originalMethod.apply(this, args);
  };
  
  obj[methodName].calls = calls;
  obj[methodName].restore = function() {
    obj[methodName] = originalMethod;
  };
  
  return obj[methodName];
}

// Usage
describe('Logger', () => {
  test('should call console.log with correct message', () => {
    const spy = createSpy(console, 'log');
    const logger = new Logger();
    
    logger.info('Test message');
    
    expect(spy.calls.length).toBe(1);
    expect(spy.calls[0].args[0]).toContain('Test message');
    
    spy.restore();
  });
});

// Using Jest spies
describe('Logger with Jest', () => {
  test('should call console.log', () => {
    const spy = jest.spyOn(console, 'log').mockImplementation();
    const logger = new Logger();
    
    logger.info('Test message');
    
    expect(spy).toHaveBeenCalledWith(expect.stringContaining('Test message'));
    expect(spy).toHaveBeenCalledTimes(1);
    
    spy.mockRestore();
  });
});
```

### Fake Pattern

Working implementation with shortcuts:

```javascript
class FakeDatabase {
  constructor() {
    this.data = new Map();
    this.idCounter = 1;
  }
  
  async insert(table, record) {
    const id = this.idCounter++;
    const key = `${table}:${id}`;
    this.data.set(key, { ...record, id });
    return { ...record, id };
  }
  
  async findById(table, id) {
    return this.data.get(`${table}:${id}`) || null;
  }
  
  async findAll(table) {
    const results = [];
    for (const [key, value] of this.data.entries()) {
      if (key.startsWith(`${table}:`)) {
        results.push(value);
      }
    }
    return results;
  }
  
  async update(table, id, updates) {
    const key = `${table}:${id}`;
    const existing = this.data.get(key);
    if (!existing) throw new Error('Not found');
    
    const updated = { ...existing, ...updates };
    this.data.set(key, updated);
    return updated;
  }
  
  async delete(table, id) {
    return this.data.delete(`${table}:${id}`);
  }
  
  clear() {
    this.data.clear();
    this.idCounter = 1;
  }
}

// Usage
describe('UserRepository', () => {
  let fakeDb;
  let userRepo;
  
  beforeEach(() => {
    fakeDb = new FakeDatabase();
    userRepo = new UserRepository(fakeDb);
  });
  
  test('should create and retrieve user', async () => {
    const user = await userRepo.create({ name: 'John', email: 'john@example.com' });
    const retrieved = await userRepo.findById(user.id);
    
    expect(retrieved).toEqual(user);
  });
  
  test('should list all users', async () => {
    await userRepo.create({ name: 'John', email: 'john@example.com' });
    await userRepo.create({ name: 'Jane', email: 'jane@example.com' });
    
    const users = await userRepo.findAll();
    expect(users).toHaveLength(2);
  });
});
```

---

## 40.3 Dependency Injection for Testing

Make code testable by injecting dependencies:

```javascript
// Bad - Hard to test
class OrderService {
  processOrder(order) {
    const paymentGateway = new StripePaymentGateway();
    const emailService = new SendGridEmailService();
    
    const result = paymentGateway.charge(order.total);
    emailService.sendConfirmation(order.email);
    
    return result;
  }
}

// Good - Testable with DI
class OrderService {
  constructor(paymentGateway, emailService) {
    this.paymentGateway = paymentGateway;
    this.emailService = emailService;
  }
  
  async processOrder(order) {
    const result = await this.paymentGateway.charge(order.total);
    await this.emailService.sendConfirmation(order.email);
    return result;
  }
}

// Test with mocks
describe('OrderService', () => {
  test('should process order successfully', async () => {
    // Arrange - inject mocks
    const paymentMock = {
      charge: jest.fn().mockResolvedValue({ success: true, id: 'pay_123' })
    };
    const emailMock = {
      sendConfirmation: jest.fn().mockResolvedValue(true)
    };
    
    const orderService = new OrderService(paymentMock, emailMock);
    const order = { total: 100, email: 'customer@example.com' };
    
    // Act
    const result = await orderService.processOrder(order);
    
    // Assert
    expect(result.success).toBe(true);
    expect(paymentMock.charge).toHaveBeenCalledWith(100);
    expect(emailMock.sendConfirmation).toHaveBeenCalledWith(order.email);
  });
});
```

---

## 40.4 Test Fixture Patterns

### Test Data Builder Pattern

Create complex test objects easily:

```javascript
class UserBuilder {
  constructor() {
    this.user = {
      id: 1,
      name: 'Test User',
      email: 'test@example.com',
      role: 'user',
      active: true,
      createdAt: new Date()
    };
  }
  
  withName(name) {
    this.user.name = name;
    return this;
  }
  
  withEmail(email) {
    this.user.email = email;
    return this;
  }
  
  withRole(role) {
    this.user.role = role;
    return this;
  }
  
  inactive() {
    this.user.active = false;
    return this;
  }
  
  asAdmin() {
    this.user.role = 'admin';
    return this;
  }
  
  build() {
    return { ...this.user };
  }
}

// Usage
describe('UserService', () => {
  test('should not allow inactive users to login', () => {
    const user = new UserBuilder()
      .withEmail('inactive@example.com')
      .inactive()
      .build();
    
    const result = authService.canLogin(user);
    expect(result).toBe(false);
  });
  
  test('admin users should have all permissions', () => {
    const admin = new UserBuilder()
      .asAdmin()
      .build();
    
    expect(authService.hasPermission(admin, 'users:delete')).toBe(true);
  });
});
```

### Object Mother Pattern

Centralized test data creation:

```javascript
class TestDataFactory {
  static createUser(overrides = {}) {
    return {
      id: Math.floor(Math.random() * 1000),
      name: 'Test User',
      email: 'test@example.com',
      role: 'user',
      active: true,
      ...overrides
    };
  }
  
  static createAdmin(overrides = {}) {
    return this.createUser({
      role: 'admin',
      permissions: ['all'],
      ...overrides
    });
  }
  
  static createInactiveUser(overrides = {}) {
    return this.createUser({
      active: false,
      ...overrides
    });
  }
  
  static createOrder(overrides = {}) {
    return {
      id: Math.floor(Math.random() * 1000),
      userId: 1,
      items: [{ id: 1, quantity: 1, price: 10 }],
      total: 10,
      status: 'pending',
      createdAt: new Date(),
      ...overrides
    };
  }
}

// Usage
describe('Order Processing', () => {
  test('should calculate total correctly', () => {
    const order = TestDataFactory.createOrder({
      items: [
        { id: 1, quantity: 2, price: 10 },
        { id: 2, quantity: 1, price: 25 }
      ]
    });
    
    const total = orderService.calculateTotal(order);
    expect(total).toBe(45);
  });
});
```

---

## 40.5 Async Testing Patterns

### Testing Promises

```javascript
describe('API Service', () => {
  test('should fetch user data', async () => {
    const userId = 123;
    const expectedUser = { id: userId, name: 'John' };
    
    // Mock fetch
    global.fetch = jest.fn().mockResolvedValue({
      ok: true,
      json: async () => expectedUser
    });
    
    const user = await apiService.getUser(userId);
    
    expect(user).toEqual(expectedUser);
    expect(fetch).toHaveBeenCalledWith(`/api/users/${userId}`);
  });
  
  test('should handle API errors', async () => {
    global.fetch = jest.fn().mockRejectedValue(new Error('Network error'));
    
    await expect(apiService.getUser(123)).rejects.toThrow('Network error');
  });
});
```

### Testing Callbacks

```javascript
describe('Event Emitter', () => {
  test('should call callback when event is emitted', (done) => {
    const emitter = new EventEmitter();
    const testData = { message: 'test' };
    
    emitter.on('test-event', (data) => {
      try {
        expect(data).toEqual(testData);
        done();
      } catch (error) {
        done(error);
      }
    });
    
    emitter.emit('test-event', testData);
  });
  
  // Better with promises
  test('should call callback - promise version', () => {
    return new Promise((resolve) => {
      const emitter = new EventEmitter();
      const testData = { message: 'test' };
      
      emitter.on('test-event', (data) => {
        expect(data).toEqual(testData);
        resolve();
      });
      
      emitter.emit('test-event', testData);
    });
  });
});
```

### Testing Timers

```javascript
describe('Debounce', () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });
  
  afterEach(() => {
    jest.useRealTimers();
  });
  
  test('should debounce function calls', () => {
    const mockFn = jest.fn();
    const debouncedFn = debounce(mockFn, 1000);
    
    // Call multiple times
    debouncedFn();
    debouncedFn();
    debouncedFn();
    
    // Should not be called yet
    expect(mockFn).not.toHaveBeenCalled();
    
    // Fast-forward time
    jest.advanceTimersByTime(1000);
    
    // Should be called once
    expect(mockFn).toHaveBeenCalledTimes(1);
  });
});
```

---

## 40.6 Integration Testing Patterns

### API Testing

```javascript
const request = require('supertest');
const app = require('../app');

describe('User API', () => {
  let authToken;
  
  beforeAll(async () => {
    // Setup test database
    await setupTestDatabase();
    
    // Get auth token
    const response = await request(app)
      .post('/api/login')
      .send({ email: 'test@example.com', password: 'password' });
    
    authToken = response.body.token;
  });
  
  afterAll(async () => {
    await cleanupTestDatabase();
  });
  
  describe('GET /api/users/:id', () => {
    test('should return user data', async () => {
      const response = await request(app)
        .get('/api/users/1')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);
      
      expect(response.body).toHaveProperty('id', 1);
      expect(response.body).toHaveProperty('email');
    });
    
    test('should return 404 for non-existent user', async () => {
      await request(app)
        .get('/api/users/99999')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(404);
    });
    
    test('should require authentication', async () => {
      await request(app)
        .get('/api/users/1')
        .expect(401);
    });
  });
  
  describe('POST /api/users', () => {
    test('should create new user', async () => {
      const newUser = {
        name: 'New User',
        email: 'new@example.com',
        password: 'SecurePass123!'
      };
      
      const response = await request(app)
        .post('/api/users')
        .send(newUser)
        .expect(201);
      
      expect(response.body).toHaveProperty('id');
      expect(response.body.email).toBe(newUser.email);
      expect(response.body).not.toHaveProperty('password');
    });
    
    test('should validate required fields', async () => {
      const response = await request(app)
        .post('/api/users')
        .send({ name: 'Incomplete' })
        .expect(400);
      
      expect(response.body.errors).toContainEqual(
        expect.objectContaining({ field: 'email' })
      );
    });
  });
});
```

### Database Testing Pattern

```javascript
describe('UserRepository', () => {
  let db;
  let userRepo;
  
  beforeAll(async () => {
    // Connect to test database
    db = await connectToTestDatabase();
  });
  
  beforeEach(async () => {
    // Clean database before each test
    await db.query('TRUNCATE TABLE users');
    userRepo = new UserRepository(db);
  });
  
  afterAll(async () => {
    await db.close();
  });
  
  test('should create user with hashed password', async () => {
    const userData = {
      email: 'test@example.com',
      password: 'plaintext'
    };
    
    const user = await userRepo.create(userData);
    
    expect(user.password).not.toBe('plaintext');
    expect(user.password).toMatch(/^\$2[aby]\$/); // bcrypt hash
  });
  
  test('should find user by email', async () => {
    const userData = {
      email: 'find@example.com',
      password: 'password'
    };
    
    await userRepo.create(userData);
    const found = await userRepo.findByEmail(userData.email);
    
    expect(found).toBeTruthy();
    expect(found.email).toBe(userData.email);
  });
  
  test('should handle duplicate email gracefully', async () => {
    const userData = {
      email: 'duplicate@example.com',
      password: 'password'
    };
    
    await userRepo.create(userData);
    
    await expect(userRepo.create(userData))
      .rejects
      .toThrow(/duplicate|unique/i);
  });
});
```

---

## 40.7 Snapshot Testing

Useful for UI components and data structures:

```javascript
describe('UserProfile Component', () => {
  test('should render correctly', () => {
    const user = {
      name: 'John Doe',
      email: 'john@example.com',
      avatar: 'avatar.jpg'
    };
    
    const component = render(<UserProfile user={user} />);
    
    expect(component).toMatchSnapshot();
  });
  
  test('should render loading state', () => {
    const component = render(<UserProfile loading={true} />);
    expect(component).toMatchSnapshot();
  });
});

// Testing data transformations
describe('Data Formatter', () => {
  test('should format user data correctly', () => {
    const rawData = {
      first_name: 'John',
      last_name: 'Doe',
      email_address: 'john@example.com'
    };
    
    const formatted = formatter.formatUser(rawData);
    
    expect(formatted).toMatchSnapshot();
  });
});
```

---

## 40.8 Test Organization Patterns

### Setup and Teardown

```javascript
describe('Shopping Cart', () => {
  let cart;
  let products;
  
  // Runs once before all tests
  beforeAll(() => {
    products = loadProductCatalog();
  });
  
  // Runs before each test
  beforeEach(() => {
    cart = new ShoppingCart();
  });
  
  // Runs after each test
  afterEach(() => {
    cart.clear();
  });
  
  // Runs once after all tests
  afterAll(() => {
    products = null;
  });
  
  describe('adding items', () => {
    test('should add item to cart', () => {
      const product = products[0];
      cart.addItem(product);
      
      expect(cart.items).toHaveLength(1);
      expect(cart.items[0]).toEqual(product);
    });
    
    test('should increase quantity for duplicate items', () => {
      const product = products[0];
      
      cart.addItem(product);
      cart.addItem(product);
      
      expect(cart.items).toHaveLength(1);
      expect(cart.items[0].quantity).toBe(2);
    });
  });
  
  describe('calculating total', () => {
    test('should calculate total price', () => {
      cart.addItem({ id: 1, price: 10, quantity: 2 });
      cart.addItem({ id: 2, price: 15, quantity: 1 });
      
      expect(cart.getTotal()).toBe(35);
    });
    
    test('should apply discount code', () => {
      cart.addItem({ id: 1, price: 100 });
      cart.applyDiscount('SAVE20');
      
      expect(cart.getTotal()).toBe(80);
    });
  });
});
```

### Parameterized Tests

```javascript
describe('Validation', () => {
  describe.each([
    ['test@example.com', true],
    ['invalid.email', false],
    ['@example.com', false],
    ['test@', false],
    ['test@example', true], // Some consider this valid
  ])('email validation: %s', (email, expected) => {
    test(`should return ${expected} for ${email}`, () => {
      expect(validator.isEmail(email)).toBe(expected);
    });
  });
  
  // Or using test.each
  test.each([
    [2, 3, 5],
    [5, 5, 10],
    [-2, 3, 1],
    [0, 0, 0],
  ])('should add %i + %i to equal %i', (a, b, expected) => {
    expect(calculator.add(a, b)).toBe(expected);
  });
});
```

---

## 40.9 Test Coverage and Best Practices

### Measuring Coverage

```javascript
// package.json
{
  "scripts": {
    "test": "jest",
    "test:coverage": "jest --coverage"
  },
  "jest": {
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    }
  }
}
```

### Best Practices

1. **Test Behavior, Not Implementation**
```javascript
// Bad - tests implementation
test('should call database.query', () => {
  const spy = jest.spyOn(database, 'query');
  userService.getUser(1);
  expect(spy).toHaveBeenCalled();
});

// Good - tests behavior
test('should return user data', async () => {
  const user = await userService.getUser(1);
  expect(user).toHaveProperty('id', 1);
});
```

2. **Write Descriptive Test Names**
```javascript
// Bad
test('user test', () => { });

// Good
test('should throw error when email is already registered', () => { });
```

3. **One Assertion Per Test** (guideline, not rule)
```javascript
// Prefer focused tests
test('should set user name', () => {
  user.setName('John');
  expect(user.name).toBe('John');
});

test('should emit name-changed event', () => {
  const handler = jest.fn();
  user.on('name-changed', handler);
  user.setName('John');
  expect(handler).toHaveBeenCalled();
});
```

4. **Test Edge Cases**
```javascript
describe('divide', () => {
  test('should divide positive numbers', () => {
    expect(divide(10, 2)).toBe(5);
  });
  
  test('should handle division by zero', () => {
    expect(() => divide(10, 0)).toThrow('Division by zero');
  });
  
  test('should handle negative numbers', () => {
    expect(divide(-10, 2)).toBe(-5);
  });
  
  test('should handle decimal results', () => {
    expect(divide(10, 3)).toBeCloseTo(3.333, 2);
  });
});
```

---

## Summary

Key testing patterns:
- **AAA/Given-When-Then** for test structure
- **Test Doubles** (mocks, stubs, spies, fakes) for isolation
- **Dependency Injection** for testability
- **Test Builders** for complex test data
- **Async patterns** for promises and callbacks
- **Integration tests** for real-world scenarios
- **Snapshot tests** for UI and data structures
- **Proper setup/teardown** for test independence

Remember: Good tests are **Fast**, **Independent**, **Repeatable**, **Self-validating**, and **Timely** (FIRST principles).