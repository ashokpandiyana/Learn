# Chapter 36: Error Handling Patterns

## Introduction

Error handling is crucial for building robust, production-ready applications. Proper error handling patterns help you gracefully manage failures, debug issues faster, and provide better user experiences.

---

## 36.1 Error Types

### Operational vs Programmer Errors

**Operational Errors** are runtime problems experienced by correctly-written programs:
- Failed database connections
- Network timeouts
- User input validation failures
- File not found
- External service unavailable

**Programmer Errors** are bugs in the code:
- Calling a function with wrong arguments
- Reading property of `undefined`
- Logic errors
- Memory leaks

**Key Principle:** Operational errors should be handled; programmer errors should be fixed.

### Custom Error Classes

Creating custom error classes helps categorize and handle errors appropriately:

```javascript
// Base application error
class AppError extends Error {
  constructor(message, code, statusCode = 500, isOperational = true) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.timestamp = new Date().toISOString();
    
    // Maintains proper stack trace
    Error.captureStackTrace(this, this.constructor);
  }
}

// Specific error types
class ValidationError extends AppError {
  constructor(message, fields = []) {
    super(message, 'VALIDATION_ERROR', 400);
    this.fields = fields;
  }
}

class NotFoundError extends AppError {
  constructor(resource) {
    super(`${resource} not found`, 'NOT_FOUND', 404);
    this.resource = resource;
  }
}

class DatabaseError extends AppError {
  constructor(message, originalError) {
    super(message, 'DATABASE_ERROR', 500);
    this.originalError = originalError;
  }
}

class AuthenticationError extends AppError {
  constructor(message = 'Authentication failed') {
    super(message, 'AUTH_ERROR', 401);
  }
}

class AuthorizationError extends AppError {
  constructor(message = 'Insufficient permissions') {
    super(message, 'FORBIDDEN', 403);
  }
}

// Usage
throw new ValidationError('Invalid email format', ['email']);
throw new NotFoundError('User');
```

---

## 36.2 Error Handling Patterns

### 1. Try-Catch Pattern

Basic error handling for synchronous and async code:

```javascript
// Synchronous
function parseJSON(jsonString) {
  try {
    return JSON.parse(jsonString);
  } catch (error) {
    console.error('JSON parsing failed:', error.message);
    return null; // or throw new ValidationError(...)
  }
}

// Async/Await
async function fetchUserData(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`);
    
    if (!response.ok) {
      throw new NotFoundError('User');
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    if (error instanceof NotFoundError) {
      // Handle specific error
      console.log('User not found, using default');
      return getDefaultUser();
    }
    // Re-throw unexpected errors
    throw error;
  }
}
```

### 2. Global Error Handler Pattern

Centralized error handling for consistency:

```javascript
// Express.js global error handler
class ErrorHandler {
  static handle(err, req, res, next) {
    const error = this.normalizeError(err);
    
    // Log error
    this.logError(error);
    
    // Don't leak sensitive info in production
    const response = process.env.NODE_ENV === 'production'
      ? this.getPublicError(error)
      : this.getDetailedError(error);
    
    res.status(error.statusCode || 500).json(response);
  }
  
  static normalizeError(err) {
    if (err instanceof AppError) {
      return err;
    }
    
    // Convert unknown errors to AppError
    return new AppError(
      err.message || 'Internal server error',
      'INTERNAL_ERROR',
      500,
      false // Not operational
    );
  }
  
  static logError(error) {
    if (!error.isOperational) {
      // Critical error - alert development team
      console.error('CRITICAL ERROR:', {
        message: error.message,
        stack: error.stack,
        timestamp: error.timestamp
      });
    } else {
      console.warn('Operational error:', error.message);
    }
  }
  
  static getPublicError(error) {
    return {
      status: 'error',
      code: error.code,
      message: error.isOperational 
        ? error.message 
        : 'An unexpected error occurred',
      timestamp: error.timestamp
    };
  }
  
  static getDetailedError(error) {
    return {
      status: 'error',
      code: error.code,
      message: error.message,
      stack: error.stack,
      timestamp: error.timestamp,
      isOperational: error.isOperational
    };
  }
}

// Usage in Express
app.use(ErrorHandler.handle.bind(ErrorHandler));
```

### 3. Error Boundary Pattern (React)

Catch errors in component trees:

```javascript
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { 
      hasError: false, 
      error: null, 
      errorInfo: null 
    };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    // Log to error reporting service
    console.error('Error caught by boundary:', error, errorInfo);
    
    this.setState({
      error: error,
      errorInfo: errorInfo
    });
    
    // Send to monitoring service
    if (process.env.NODE_ENV === 'production') {
      logErrorToService(error, errorInfo);
    }
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Something went wrong</h2>
          <details>
            <summary>Error details</summary>
            <p>{this.state.error?.toString()}</p>
            <pre>{this.state.errorInfo?.componentStack}</pre>
          </details>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage
<ErrorBoundary>
  <App />
</ErrorBoundary>
```

### 4. Circuit Breaker Pattern

Prevent cascading failures by stopping requests to failing services:

```javascript
class CircuitBreaker {
  constructor(service, options = {}) {
    this.service = service;
    this.failureThreshold = options.failureThreshold || 5;
    this.timeout = options.timeout || 60000; // 1 minute
    this.resetTimeout = options.resetTimeout || 30000; // 30 seconds
    
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.failureCount = 0;
    this.nextAttempt = Date.now();
    this.successCount = 0;
  }
  
  async execute(...args) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      // Try to recover
      this.state = 'HALF_OPEN';
      this.successCount = 0;
    }
    
    try {
      const result = await Promise.race([
        this.service(...args),
        this.timeoutPromise()
      ]);
      
      return this.onSuccess(result);
    } catch (error) {
      return this.onFailure(error);
    }
  }
  
  timeoutPromise() {
    return new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Request timeout')), this.timeout);
    });
  }
  
  onSuccess(result) {
    if (this.state === 'HALF_OPEN') {
      this.successCount++;
      if (this.successCount >= 3) {
        this.state = 'CLOSED';
        this.failureCount = 0;
        console.log('Circuit breaker recovered: CLOSED');
      }
    }
    this.failureCount = 0;
    return result;
  }
  
  onFailure(error) {
    this.failureCount++;
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.resetTimeout;
      console.error('Circuit breaker opened due to failures');
    }
    
    throw error;
  }
  
  getState() {
    return {
      state: this.state,
      failureCount: this.failureCount,
      nextAttempt: new Date(this.nextAttempt)
    };
  }
}

// Usage
const externalAPI = async (data) => {
  const response = await fetch('https://api.example.com/data', {
    method: 'POST',
    body: JSON.stringify(data)
  });
  return response.json();
};

const protectedAPI = new CircuitBreaker(externalAPI, {
  failureThreshold: 3,
  timeout: 5000,
  resetTimeout: 20000
});

// Use protected API
try {
  const result = await protectedAPI.execute({ userId: 123 });
  console.log('Success:', result);
} catch (error) {
  console.error('Failed:', error.message);
  // Fallback logic here
}
```

### 5. Retry Pattern with Exponential Backoff

Automatically retry failed operations with increasing delays:

```javascript
class RetryHandler {
  static async retry(fn, options = {}) {
    const {
      retries = 3,
      initialDelay = 1000,
      maxDelay = 30000,
      factor = 2,
      onRetry = null
    } = options;
    
    let lastError;
    
    for (let attempt = 0; attempt <= retries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error;
        
        // Don't retry on certain errors
        if (this.isNonRetryableError(error)) {
          throw error;
        }
        
        if (attempt < retries) {
          const delay = Math.min(
            initialDelay * Math.pow(factor, attempt),
            maxDelay
          );
          
          console.log(`Retry attempt ${attempt + 1}/${retries} after ${delay}ms`);
          
          if (onRetry) {
            onRetry(attempt + 1, delay, error);
          }
          
          await this.sleep(delay);
        }
      }
    }
    
    throw new Error(`Failed after ${retries} retries: ${lastError.message}`);
  }
  
  static isNonRetryableError(error) {
    // Don't retry client errors (4xx) except 408, 429
    if (error.statusCode) {
      return error.statusCode >= 400 && 
             error.statusCode < 500 && 
             error.statusCode !== 408 && 
             error.statusCode !== 429;
    }
    return false;
  }
  
  static sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Usage
async function fetchData(url) {
  const response = await fetch(url);
  if (!response.ok) {
    const error = new Error('Fetch failed');
    error.statusCode = response.status;
    throw error;
  }
  return response.json();
}

const data = await RetryHandler.retry(
  () => fetchData('https://api.example.com/data'),
  {
    retries: 5,
    initialDelay: 1000,
    factor: 2,
    onRetry: (attempt, delay, error) => {
      console.log(`Retrying... Attempt ${attempt}, waiting ${delay}ms`);
    }
  }
);
```

### 6. Graceful Degradation Pattern

Provide fallback functionality when primary features fail:

```javascript
class FeatureManager {
  constructor() {
    this.features = new Map();
    this.fallbacks = new Map();
  }
  
  register(name, implementation, fallback) {
    this.features.set(name, implementation);
    this.fallbacks.set(name, fallback);
  }
  
  async execute(featureName, ...args) {
    const feature = this.features.get(featureName);
    const fallback = this.fallbacks.get(featureName);
    
    if (!feature) {
      throw new Error(`Feature ${featureName} not registered`);
    }
    
    try {
      return await feature(...args);
    } catch (error) {
      console.warn(`Feature ${featureName} failed, using fallback`, error);
      
      if (!fallback) {
        throw error;
      }
      
      return await fallback(...args);
    }
  }
}

// Usage
const featureManager = new FeatureManager();

// Register AI-powered search with fallback to basic search
featureManager.register(
  'search',
  async (query) => {
    const response = await fetch('/api/ai-search', {
      method: 'POST',
      body: JSON.stringify({ query })
    });
    return response.json();
  },
  async (query) => {
    // Simple fallback search
    return { results: [], message: 'Using basic search' };
  }
);

const results = await featureManager.execute('search', 'javascript patterns');
```

---

## 36.3 Best Practices

### 1. Always Include Context

```javascript
// Bad
throw new Error('Failed');

// Good
throw new ValidationError('Email validation failed', ['email']);

// Better
throw new ValidationError('Email validation failed', ['email'], {
  providedValue: userInput.email,
  expectedFormat: 'valid@email.com',
  userId: user.id
});
```

### 2. Don't Swallow Errors

```javascript
// Bad - Silent failure
try {
  await dangerousOperation();
} catch (error) {
  // Do nothing
}

// Good - Log and handle
try {
  await dangerousOperation();
} catch (error) {
  console.error('Operation failed:', error);
  // Notify user or use fallback
  showErrorMessage('Operation failed, please try again');
}
```

### 3. Use Error Codes

```javascript
const ERROR_CODES = {
  VALIDATION_ERROR: 'E1001',
  NOT_FOUND: 'E1002',
  UNAUTHORIZED: 'E1003',
  DATABASE_ERROR: 'E2001',
  EXTERNAL_API_ERROR: 'E3001'
};

class AppError extends Error {
  constructor(message, errorCode, statusCode = 500) {
    super(message);
    this.errorCode = errorCode;
    this.statusCode = statusCode;
  }
}

throw new AppError('User not found', ERROR_CODES.NOT_FOUND, 404);
```

### 4. Async Error Handling in Express

```javascript
// Wrapper to catch async errors
const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};

// Usage
app.get('/users/:id', asyncHandler(async (req, res) => {
  const user = await User.findById(req.params.id);
  if (!user) {
    throw new NotFoundError('User');
  }
  res.json(user);
}));
```

---

## Summary

Key takeaways for error handling:
1. Distinguish between operational and programmer errors
2. Use custom error classes for clarity
3. Implement centralized error handling
4. Use circuit breakers for external dependencies
5. Retry with exponential backoff for transient failures
6. Always provide graceful degradation
7. Log errors appropriately (with context)
8. Never expose sensitive information in error messages
9. Test error scenarios thoroughly