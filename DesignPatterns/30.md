# Chapter 30: Middleware Pattern - In Depth Guide

## üìö Overview

The Middleware Pattern is a design pattern for building a pipeline of processing steps where each piece of middleware can inspect, modify, or terminate a request before passing it to the next middleware in the chain. It's the backbone of frameworks like Express.js, Koa.js, and Redux.

## üéØ Core Concept

Middleware functions are executed sequentially, forming a chain where each middleware can:
1. Execute code before passing control
2. Modify the request/response
3. End the request-response cycle
4. Call the next middleware in the stack

## üèóÔ∏è Basic Implementation

### Simple Middleware Pattern

```javascript
class Middleware {
  constructor() {
    this.middlewares = [];
  }

  use(fn) {
    this.middlewares.push(fn);
    return this; // For chaining
  }

  execute(context) {
    let index = 0;

    const next = () => {
      if (index >= this.middlewares.length) {
        return;
      }

      const middleware = this.middlewares[index++];
      middleware(context, next);
    };

    next();
  }
}

// Usage
const middleware = new Middleware();

middleware.use((context, next) => {
  console.log('Middleware 1: Before');
  context.data = 'Hello';
  next();
  console.log('Middleware 1: After');
});

middleware.use((context, next) => {
  console.log('Middleware 2: Before');
  context.data += ' World';
  next();
  console.log('Middleware 2: After');
});

middleware.use((context, next) => {
  console.log('Middleware 3: Processing');
  console.log('Final data:', context.data);
  // No next() call - terminates the chain
});

middleware.execute({ data: '' });

// Output:
// Middleware 1: Before
// Middleware 2: Before
// Middleware 3: Processing
// Final data: Hello World
// Middleware 2: After
// Middleware 1: After
```

### Async Middleware

```javascript
class AsyncMiddleware {
  constructor() {
    this.middlewares = [];
  }

  use(fn) {
    this.middlewares.push(fn);
    return this;
  }

  async execute(context) {
    let index = 0;

    const next = async () => {
      if (index >= this.middlewares.length) {
        return;
      }

      const middleware = this.middlewares[index++];
      await middleware(context, next);
    };

    await next();
  }
}

// Usage with async operations
const asyncMiddleware = new AsyncMiddleware();

asyncMiddleware.use(async (context, next) => {
  console.log('Fetching user data...');
  context.user = await fetchUser(context.userId);
  await next();
});

asyncMiddleware.use(async (context, next) => {
  console.log('Checking permissions...');
  const hasAccess = await checkPermissions(context.user);
  if (!hasAccess) {
    throw new Error('Access denied');
  }
  await next();
});

asyncMiddleware.use(async (context, next) => {
  console.log('Processing request...');
  context.result = await processData(context.data);
});

// Execute
await asyncMiddleware.execute({
  userId: 123,
  data: { foo: 'bar' }
});
```

## üåê Express.js Style Middleware

### Express-like Implementation

```javascript
class App {
  constructor() {
    this.middlewares = [];
  }

  use(path, ...handlers) {
    // If path is a function, it's a global middleware
    if (typeof path === 'function') {
      handlers = [path, ...handlers];
      path = '*';
    }

    handlers.forEach(handler => {
      this.middlewares.push({ path, handler });
    });

    return this;
  }

  async handle(req, res) {
    let index = 0;

    const next = async (err) => {
      // Error handling
      if (err) {
        return this.handleError(err, req, res);
      }

      // Find next matching middleware
      while (index < this.middlewares.length) {
        const { path, handler } = this.middlewares[index++];
        
        // Check if path matches
        if (path === '*' || req.url.startsWith(path)) {
          try {
            await handler(req, res, next);
            return;
          } catch (error) {
            return next(error);
          }
        }
      }
    };

    await next();
  }

  handleError(err, req, res) {
    console.error('Error:', err);
    res.statusCode = 500;
    res.end('Internal Server Error');
  }
}

// Create request/response objects (simplified)
class Request {
  constructor(url, method = 'GET', body = null) {
    this.url = url;
    this.method = method;
    this.body = body;
    this.headers = {};
  }
}

class Response {
  constructor() {
    this.statusCode = 200;
    this.headers = {};
    this.body = null;
  }

  status(code) {
    this.statusCode = code;
    return this;
  }

  json(data) {
    this.headers['Content-Type'] = 'application/json';
    this.body = JSON.stringify(data);
    this.end();
  }

  send(data) {
    this.body = data;
    this.end();
  }

  end(data) {
    if (data) this.body = data;
    console.log(`Response ${this.statusCode}:`, this.body);
  }
}

// Usage
const app = new App();

// Logger middleware
app.use((req, res, next) => {
  console.log(`${req.method} ${req.url}`);
  req.startTime = Date.now();
  next();
});

// Authentication middleware
app.use((req, res, next) => {
  const token = req.headers.authorization;
  if (!token) {
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }
  req.user = { id: 1, name: 'John' }; // Simplified
  next();
});

// Route-specific middleware
app.use('/api', (req, res, next) => {
  console.log('API route accessed');
  next();
});

// Request handler
app.use('/api/users', (req, res) => {
  res.json({ users: [req.user] });
});

// Error handling middleware
app.use((req, res, next) => {
  const duration = Date.now() - req.startTime;
  console.log(`Request completed in ${duration}ms`);
});

// Test
const req = new Request('/api/users', 'GET');
req.headers.authorization = 'Bearer token123';
const res = new Response();

await app.handle(req, res);
```

## üîÑ Koa.js Style Composition

### Koa-like Middleware (Onion Model)

```javascript
function compose(middlewares) {
  return function (context, next) {
    let index = -1;

    function dispatch(i) {
      if (i <= index) {
        return Promise.reject(new Error('next() called multiple times'));
      }

      index = i;

      let fn = middlewares[i];

      if (i === middlewares.length) {
        fn = next;
      }

      if (!fn) {
        return Promise.resolve();
      }

      try {
        return Promise.resolve(fn(context, () => dispatch(i + 1)));
      } catch (err) {
        return Promise.reject(err);
      }
    }

    return dispatch(0);
  };
}

// Usage
const middleware1 = async (ctx, next) => {
  console.log('‚Üí 1');
  ctx.data = 'Start';
  await next();
  console.log('‚Üê 1');
  ctx.data += ' End';
};

const middleware2 = async (ctx, next) => {
  console.log('‚Üí 2');
  ctx.data += ' ‚Üí Middle';
  await next();
  console.log('‚Üê 2');
};

const middleware3 = async (ctx, next) => {
  console.log('‚Üí 3');
  ctx.data += ' ‚Üí Core';
  console.log('‚Üê 3');
};

const composed = compose([middleware1, middleware2, middleware3]);

const context = { data: '' };
await composed(context);
console.log('Final:', context.data);

// Output:
// ‚Üí 1
// ‚Üí 2
// ‚Üí 3
// ‚Üê 3
// ‚Üê 2
// ‚Üê 1
// Final: Start ‚Üí Middle ‚Üí Core End
```

## üéÆ Redux Middleware Pattern

### Redux-style Middleware

```javascript
// Redux middleware signature:
// store => next => action => { ... }

function createStore(reducer, initialState, middlewares = []) {
  let state = initialState;
  const listeners = [];

  const getState = () => state;

  const dispatch = (action) => {
    state = reducer(state, action);
    listeners.forEach(listener => listener(state));
    return action;
  };

  const subscribe = (listener) => {
    listeners.push(listener);
    return () => {
      const index = listeners.indexOf(listener);
      listeners.splice(index, 1);
    };
  };

  // Apply middlewares
  const middlewareAPI = {
    getState,
    dispatch: (action) => dispatch(action)
  };

  const chain = middlewares.map(middleware => middleware(middlewareAPI));
  const enhancedDispatch = chain.reduceRight(
    (next, middleware) => middleware(next),
    dispatch
  );

  return {
    getState,
    dispatch: enhancedDispatch,
    subscribe
  };
}

// Logger middleware
const logger = store => next => action => {
  console.log('Dispatching:', action);
  const result = next(action);
  console.log('Next state:', store.getState());
  return result;
};

// Thunk middleware (for async actions)
const thunk = store => next => action => {
  if (typeof action === 'function') {
    return action(store.dispatch, store.getState);
  }
  return next(action);
};

// Error handling middleware
const crashReporter = store => next => action => {
  try {
    return next(action);
  } catch (err) {
    console.error('Caught an exception!', err);
    throw err;
  }
};

// Usage
const reducer = (state = { count: 0 }, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
};

const store = createStore(
  reducer,
  { count: 0 },
  [logger, thunk, crashReporter]
);

// Dispatch actions
store.dispatch({ type: 'INCREMENT' });

// Async action (thunk)
store.dispatch((dispatch, getState) => {
  setTimeout(() => {
    dispatch({ type: 'INCREMENT' });
  }, 1000);
});
```

## üõ°Ô∏è Common Middleware Examples

### 1. Authentication Middleware

```javascript
function createAuthMiddleware(options = {}) {
  return async (req, res, next) => {
    try {
      const token = req.headers.authorization?.split(' ')[1];
      
      if (!token) {
        throw new Error('No token provided');
      }

      // Verify token
      const decoded = await verifyToken(token);
      req.user = decoded;
      
      next();
    } catch (error) {
      res.status(401).json({ error: 'Unauthorized' });
    }
  };
}

// Usage
app.use('/api/protected', createAuthMiddleware());
```

### 2. Rate Limiting Middleware

```javascript
class RateLimiter {
  constructor(maxRequests, windowMs) {
    this.maxRequests = maxRequests;
    this.windowMs = windowMs;
    this.requests = new Map();
  }

  middleware() {
    return (req, res, next) => {
      const key = req.ip || 'unknown';
      const now = Date.now();
      
      // Get request history
      let userRequests = this.requests.get(key) || [];
      
      // Remove old requests outside the window
      userRequests = userRequests.filter(
        timestamp => now - timestamp < this.windowMs
      );

      // Check if limit exceeded
      if (userRequests.length >= this.maxRequests) {
        res.status(429).json({
          error: 'Too many requests',
          retryAfter: this.windowMs
        });
        return;
      }

      // Add current request
      userRequests.push(now);
      this.requests.set(key, userRequests);

      next();
    };
  }

  clear() {
    this.requests.clear();
  }
}

// Usage
const limiter = new RateLimiter(100, 60000); // 100 requests per minute
app.use(limiter.middleware());
```

### 3. CORS Middleware

```javascript
function cors(options = {}) {
  const defaults = {
    origin: '*',
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: false,
    maxAge: 86400
  };

  const config = { ...defaults, ...options };

  return (req, res, next) => {
    // Set CORS headers
    res.headers['Access-Control-Allow-Origin'] = config.origin;
    res.headers['Access-Control-Allow-Methods'] = config.methods;
    res.headers['Access-Control-Max-Age'] = config.maxAge;

    if (config.credentials) {
      res.headers['Access-Control-Allow-Credentials'] = 'true';
    }

    // Handle preflight
    if (req.method === 'OPTIONS') {
      res.status(204).end();
      return;
    }

    next();
  };
}

// Usage
app.use(cors({
  origin: 'https://example.com',
  credentials: true
}));
```

### 4. Body Parser Middleware

```javascript
function bodyParser(options = {}) {
  return async (req, res, next) => {
    if (req.method !== 'POST' && req.method !== 'PUT') {
      return next();
    }

    const contentType = req.headers['content-type'];

    try {
      if (contentType === 'application/json') {
        // Parse JSON
        const body = await readBody(req);
        req.body = JSON.parse(body);
      } else if (contentType === 'application/x-www-form-urlencoded') {
        // Parse form data
        const body = await readBody(req);
        req.body = parseFormData(body);
      }

      next();
    } catch (error) {
      res.status(400).json({ error: 'Invalid request body' });
    }
  };
}

async function readBody(req) {
  return new Promise((resolve, reject) => {
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', () => resolve(body));
    req.on('error', reject);
  });
}

function parseFormData(body) {
  return body.split('&').reduce((acc, pair) => {
    const [key, value] = pair.split('=');
    acc[decodeURIComponent(key)] = decodeURIComponent(value);
    return acc;
  }, {});
}
```

### 5. Error Handling Middleware

```javascript
function errorHandler(options = {}) {
  return (err, req, res, next) => {
    console.error('Error:', err);

    // Operational errors
    if (err.isOperational) {
      res.status(err.statusCode || 500).json({
        error: err.message,
        code: err.code
      });
      return;
    }

    // Programming errors
    if (options.showStack && process.env.NODE_ENV !== 'production') {
      res.status(500).json({
        error: err.message,
        stack: err.stack
      });
    } else {
      res.status(500).json({
        error: 'Internal server error'
      });
    }
  };
}

// Usage - must be last middleware
app.use(errorHandler({ showStack: true }));
```

### 6. Caching Middleware

```javascript
class CacheMiddleware {
  constructor(options = {}) {
    this.cache = new Map();
    this.ttl = options.ttl || 60000; // 1 minute default
  }

  middleware() {
    return async (req, res, next) => {
      // Only cache GET requests
      if (req.method !== 'GET') {
        return next();
      }

      const key = req.url;
      const cached = this.cache.get(key);

      if (cached && Date.now() - cached.timestamp < this.ttl) {
        console.log('Cache hit:', key);
        res.headers['X-Cache'] = 'HIT';
        res.json(cached.data);
        return;
      }

      // Store original json method
      const originalJson = res.json.bind(res);

      // Override json method to cache response
      res.json = (data) => {
        this.cache.set(key, {
          data,
          timestamp: Date.now()
        });
        res.headers['X-Cache'] = 'MISS';
        originalJson(data);
      };

      next();
    };
  }

  clear(key) {
    if (key) {
      this.cache.delete(key);
    } else {
      this.cache.clear();
    }
  }
}

// Usage
const cache = new CacheMiddleware({ ttl: 300000 }); // 5 minutes
app.use('/api', cache.middleware());
```

## üîß Advanced Patterns

### Conditional Middleware

```javascript
function conditional(predicate, middleware) {
  return (req, res, next) => {
    if (predicate(req)) {
      return middleware(req, res, next);
    }
    next();
  };
}

// Usage
app.use(conditional(
  req => req.url.startsWith('/api'),
  authMiddleware
));
```

### Parallel Middleware Execution

```javascript
function parallel(...middlewares) {
  return async (req, res, next) => {
    try {
      await Promise.all(
        middlewares.map(middleware =>
          new Promise((resolve, reject) => {
            middleware(req, res, (err) => {
              if (err) reject(err);
              else resolve();
            });
          })
        )
      );
      next();
    } catch (error) {
      next(error);
    }
  };
}

// Usage - run multiple checks in parallel
app.use(parallel(
  checkUserPermissions,
  validateRequestData,
  checkRateLimit
));
```

### Branching Middleware

```javascript
function branch(condition, trueBranch, falseBranch) {
  return (req, res, next) => {
    if (condition(req)) {
      trueBranch(req, res, next);
    } else if (falseBranch) {
      falseBranch(req, res, next);
    } else {
      next();
    }
  };
}

// Usage
app.use(branch(
  req => req.headers['content-type'] === 'application/json',
  jsonParser,
  formParser
));
```

## üéØ Best Practices

1. **Keep middleware focused**: Each middleware should have a single responsibility
2. **Always call next()**: Unless intentionally ending the request
3. **Error handling**: Use try-catch and pass errors to next(error)
4. **Order matters**: Place middlewares in logical order
5. **Performance**: Keep middleware lightweight
6. **Async/Await**: Use async middleware for async operations
7. **Reusability**: Create configurable, reusable middleware
8. **Documentation**: Document middleware behavior and options

## üö´ Common Mistakes

1. **Forgetting to call next()**: Hangs the request
2. **Calling next() multiple times**: Causes errors
3. **Not handling errors**: Crashes the application
4. **Blocking operations**: Slows down the entire pipeline
5. **Modifying shared state**: Race conditions
6. **Not validating input**: Security vulnerabilities

## üìä Performance Considerations

```javascript
// Measure middleware performance
function performanceMonitor(name) {
  return async (req, res, next) => {
    const start = process.hrtime.bigint();
    
    await next();
    
    const end = process.hrtime.bigint();
    const duration = Number(end - start) / 1000000; // Convert to ms
    
    console.log(`${name}: ${duration.toFixed(2)}ms`);
  };
}

app.use(performanceMonitor('Total'));
app.use(performanceMonitor('Auth'), authMiddleware);
app.use(performanceMonitor('Route'), routeHandler);
```

## üìù Summary

The Middleware Pattern is essential for building modular, maintainable request processing pipelines. It enables separation of concerns, promotes code reuse, and provides a clean way to handle cross-cutting concerns like authentication, logging, and error handling. Master this pattern for building robust web applications and understanding frameworks like Express, Koa, and Redux.