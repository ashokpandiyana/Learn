# Chapter 33: MVC, MVP, MVVM - Complete Guide

## üìö Overview: Architectural Patterns for UI

These patterns separate concerns in user interface architecture, making code more maintainable, testable, and scalable. They all share the same goal: **separate presentation logic from business logic**.

### The Evolution
```
Traditional UI (All in one) 
     ‚Üì
MVC (1979 - Smalltalk)
     ‚Üì
MVP (1990s - Microsoft)
     ‚Üì
MVVM (2005 - Microsoft WPF)
```

---

## üéØ MVC: Model-View-Controller

### Core Concept
MVC divides an application into three interconnected components, each with distinct responsibilities.

### Components

**1. Model** 
- Data and business logic
- Database operations
- No knowledge of View or Controller

**2. View**
- User interface
- Displays data from Model
- Sends user input to Controller

**3. Controller**
- Handles user input
- Updates Model
- Selects View to display

### Data Flow
```
User ‚Üí View ‚Üí Controller ‚Üí Model
                ‚Üì           ‚Üì
              View ‚Üê ‚Üê ‚Üê ‚Üê Model (notifies)
```

### Classic MVC Implementation (Server-Side)

```javascript
// Model
class TodoModel {
  constructor() {
    this.todos = [];
    this.observers = [];
  }

  addTodo(text) {
    const todo = {
      id: Date.now(),
      text,
      completed: false
    };
    this.todos.push(todo);
    this.notifyObservers();
    return todo;
  }

  getTodos() {
    return this.todos;
  }

  toggleTodo(id) {
    const todo = this.todos.find(t => t.id === id);
    if (todo) {
      todo.completed = !todo.completed;
      this.notifyObservers();
    }
  }

  deleteTodo(id) {
    this.todos = this.todos.filter(t => t.id !== id);
    this.notifyObservers();
  }

  subscribe(observer) {
    this.observers.push(observer);
  }

  notifyObservers() {
    this.observers.forEach(observer => observer.update(this));
  }
}

// View
class TodoView {
  constructor(model, controller) {
    this.model = model;
    this.controller = controller;
    this.container = document.getElementById('todo-app');
    
    // Subscribe to model changes
    this.model.subscribe(this);
  }

  update(model) {
    this.render(model.getTodos());
  }

  render(todos) {
    this.container.innerHTML = `
      <div class="todo-app">
        <input type="text" id="todo-input" placeholder="Add a todo..." />
        <button id="add-btn">Add</button>
        <ul id="todo-list">
          ${todos.map(todo => `
            <li class="${todo.completed ? 'completed' : ''}">
              <input 
                type="checkbox" 
                ${todo.completed ? 'checked' : ''}
                data-id="${todo.id}"
                class="toggle-todo"
              />
              <span>${todo.text}</span>
              <button class="delete-todo" data-id="${todo.id}">Delete</button>
            </li>
          `).join('')}
        </ul>
      </div>
    `;

    this.bindEvents();
  }

  bindEvents() {
    document.getElementById('add-btn')?.addEventListener('click', () => {
      const input = document.getElementById('todo-input');
      if (input.value.trim()) {
        this.controller.addTodo(input.value);
        input.value = '';
      }
    });

    document.querySelectorAll('.toggle-todo').forEach(checkbox => {
      checkbox.addEventListener('change', (e) => {
        this.controller.toggleTodo(Number(e.target.dataset.id));
      });
    });

    document.querySelectorAll('.delete-todo').forEach(btn => {
      btn.addEventListener('click', (e) => {
        this.controller.deleteTodo(Number(e.target.dataset.id));
      });
    });
  }
}

// Controller
class TodoController {
  constructor(model) {
    this.model = model;
  }

  addTodo(text) {
    if (text.trim()) {
      this.model.addTodo(text);
    }
  }

  toggleTodo(id) {
    this.model.toggleTodo(id);
  }

  deleteTodo(id) {
    this.model.deleteTodo(id);
  }

  getTodos() {
    return this.model.getTodos();
  }
}

// Application initialization
const model = new TodoModel();
const controller = new TodoController(model);
const view = new TodoView(model, controller);

// Initial render
view.update(model);
```

### MVC in Express.js (Server-Side)

```javascript
// Model (using Mongoose)
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  name: String,
  email: { type: String, unique: true },
  password: String
});

const User = mongoose.model('User', userSchema);

// Controller
class UserController {
  async getAllUsers(req, res) {
    try {
      const users = await User.find().select('-password');
      res.json(users);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  async createUser(req, res) {
    try {
      const user = new User(req.body);
      await user.save();
      res.status(201).json(user);
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }

  async getUserById(req, res) {
    try {
      const user = await User.findById(req.params.id).select('-password');
      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }
      res.json(user);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
}

// Routes (part of Controller layer)
const express = require('express');
const router = express.Router();
const userController = new UserController();

router.get('/users', userController.getAllUsers);
router.post('/users', userController.createUser);
router.get('/users/:id', userController.getUserById);

module.exports = router;

// View (Template engine - EJS, Pug, etc.)
// users.ejs
/*
<html>
  <body>
    <h1>Users</h1>
    <ul>
      <% users.forEach(user => { %>
        <li><%= user.name %> - <%= user.email %></li>
      <% }); %>
    </ul>
  </body>
</html>
*/
```

### MVC Characteristics

‚úÖ **Advantages:**
- Clear separation of concerns
- Model can be tested independently
- Multiple views can use the same model
- Well-understood and documented

‚ùå **Disadvantages:**
- View has dependency on Model
- Testing View is challenging
- Can become complex with many controllers
- Tight coupling between components

---

## üé≠ MVP: Model-View-Presenter

### Core Concept
MVP improves testability by making the View completely passive. The Presenter contains all presentation logic and communicates with the View through an interface.

### Key Difference from MVC
- View does **NOT** communicate directly with Model
- Presenter acts as the "middle-man" for everything
- View is completely passive (dumb)

### Data Flow
```
User ‚Üí View ‚Üí Presenter ‚Üí Model
        ‚Üë         ‚Üì
        ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê 
```

### MVP Implementation

```javascript
// Model (same as MVC)
class TodoModel {
  constructor() {
    this.todos = [];
  }

  addTodo(text) {
    const todo = {
      id: Date.now(),
      text,
      completed: false
    };
    this.todos.push(todo);
    return todo;
  }

  getTodos() {
    return [...this.todos]; // Return copy
  }

  toggleTodo(id) {
    const todo = this.todos.find(t => t.id === id);
    if (todo) {
      todo.completed = !todo.completed;
    }
    return todo;
  }

  deleteTodo(id) {
    const index = this.todos.findIndex(t => t.id === id);
    if (index !== -1) {
      this.todos.splice(index, 1);
      return true;
    }
    return false;
  }
}

// View Interface (contract)
class ITodoView {
  displayTodos(todos) {}
  getTodoInput() {}
  clearTodoInput() {}
  showError(message) {}
  showSuccess(message) {}
}

// View Implementation (Passive)
class TodoView extends ITodoView {
  constructor(presenter) {
    super();
    this.presenter = presenter;
    this.container = document.getElementById('todo-app');
    this.init();
  }

  init() {
    this.container.innerHTML = `
      <div class="todo-app">
        <input type="text" id="todo-input" placeholder="Add a todo..." />
        <button id="add-btn">Add</button>
        <div id="message"></div>
        <ul id="todo-list"></ul>
      </div>
    `;

    this.bindEvents();
  }

  bindEvents() {
    // View only forwards events to Presenter
    document.getElementById('add-btn').addEventListener('click', () => {
      this.presenter.onAddTodo();
    });

    document.getElementById('todo-input').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        this.presenter.onAddTodo();
      }
    });
  }

  displayTodos(todos) {
    const list = document.getElementById('todo-list');
    list.innerHTML = todos.map(todo => `
      <li class="${todo.completed ? 'completed' : ''}" data-id="${todo.id}">
        <input 
          type="checkbox" 
          ${todo.completed ? 'checked' : ''}
          onchange="window.todoPresenter.onToggleTodo(${todo.id})"
        />
        <span>${todo.text}</span>
        <button onclick="window.todoPresenter.onDeleteTodo(${todo.id})">
          Delete
        </button>
      </li>
    `).join('');
  }

  getTodoInput() {
    return document.getElementById('todo-input').value;
  }

  clearTodoInput() {
    document.getElementById('todo-input').value = '';
  }

  showError(message) {
    document.getElementById('message').innerHTML = 
      `<div class="error">${message}</div>`;
  }

  showSuccess(message) {
    document.getElementById('message').innerHTML = 
      `<div class="success">${message}</div>`;
    setTimeout(() => {
      document.getElementById('message').innerHTML = '';
    }, 3000);
  }
}

// Presenter (Contains all presentation logic)
class TodoPresenter {
  constructor(view, model) {
    this.view = view;
    this.model = model;
    this.updateView();
  }

  onAddTodo() {
    const text = this.view.getTodoInput();
    
    if (!text.trim()) {
      this.view.showError('Please enter a todo');
      return;
    }

    try {
      this.model.addTodo(text);
      this.view.clearTodoInput();
      this.view.showSuccess('Todo added successfully');
      this.updateView();
    } catch (error) {
      this.view.showError('Failed to add todo');
    }
  }

  onToggleTodo(id) {
    try {
      this.model.toggleTodo(id);
      this.updateView();
    } catch (error) {
      this.view.showError('Failed to toggle todo');
    }
  }

  onDeleteTodo(id) {
    try {
      this.model.deleteTodo(id);
      this.view.showSuccess('Todo deleted');
      this.updateView();
    } catch (error) {
      this.view.showError('Failed to delete todo');
    }
  }

  updateView() {
    const todos = this.model.getTodos();
    this.view.displayTodos(todos);
  }
}

// Application initialization
const model = new TodoModel();
const presenter = new TodoPresenter(null, model);
const view = new TodoView(presenter);
presenter.view = view;

// Make presenter available globally for inline event handlers
window.todoPresenter = presenter;
```

### MVP Testing Example

```javascript
// Mock View for testing
class MockTodoView extends ITodoView {
  constructor() {
    super();
    this.displayedTodos = null;
    this.inputValue = '';
    this.errorMessage = null;
    this.successMessage = null;
  }

  displayTodos(todos) {
    this.displayedTodos = todos;
  }

  getTodoInput() {
    return this.inputValue;
  }

  clearTodoInput() {
    this.inputValue = '';
  }

  showError(message) {
    this.errorMessage = message;
  }

  showSuccess(message) {
    this.successMessage = message;
  }
}

// Unit test
function testPresenter() {
  const model = new TodoModel();
  const mockView = new MockTodoView();
  const presenter = new TodoPresenter(mockView, model);

  // Test adding a todo
  mockView.inputValue = 'Test todo';
  presenter.onAddTodo();
  
  console.assert(mockView.displayedTodos.length === 1, 'Todo should be added');
  console.assert(mockView.inputValue === '', 'Input should be cleared');
  console.assert(mockView.successMessage !== null, 'Success message should be shown');

  // Test empty input
  mockView.inputValue = '';
  presenter.onAddTodo();
  
  console.assert(mockView.errorMessage !== null, 'Error should be shown for empty input');
  
  console.log('All tests passed!');
}
```

### MVP Characteristics

‚úÖ **Advantages:**
- View is completely testable (through interface)
- Presenter is easily unit tested
- No direct View-Model coupling
- Better separation than MVC

‚ùå **Disadvantages:**
- More code (view interface)
- Presenter can become bloated
- One-to-one Presenter-View relationship

---

## ‚ö° MVVM: Model-View-ViewModel

### Core Concept
MVVM introduces **two-way data binding** between View and ViewModel. The ViewModel exposes data and commands that the View binds to, eliminating manual DOM manipulation.

### Components

**1. Model** - Business logic and data (same as MVC/MVP)

**2. View** - UI markup with data bindings

**3. ViewModel**
- Exposes data for binding
- Contains presentation logic
- No reference to View
- Commands for user actions

### Data Flow
```
View ‚Üî ViewModel ‚Üî Model
     (two-way)    (one-way)
```

### MVVM Implementation (Vanilla JS with Proxy)

```javascript
// Simple Observable for two-way binding
class Observable {
  constructor(data) {
    this.listeners = new Map();
    this.data = new Proxy(data, {
      set: (target, property, value) => {
        target[property] = value;
        this.notify(property, value);
        return true;
      }
    });
  }

  subscribe(property, callback) {
    if (!this.listeners.has(property)) {
      this.listeners.set(property, []);
    }
    this.listeners.get(property).push(callback);
  }

  notify(property, value) {
    if (this.listeners.has(property)) {
      this.listeners.get(property).forEach(callback => callback(value));
    }
  }
}

// Model
class TodoModel {
  constructor() {
    this.todos = [];
  }

  async addTodo(text) {
    return new Promise(resolve => {
      setTimeout(() => {
        const todo = {
          id: Date.now(),
          text,
          completed: false
        };
        this.todos.push(todo);
        resolve(todo);
      }, 100); // Simulate API call
    });
  }

  async getTodos() {
    return [...this.todos];
  }

  async toggleTodo(id) {
    const todo = this.todos.find(t => t.id === id);
    if (todo) {
      todo.completed = !todo.completed;
    }
    return todo;
  }

  async deleteTodo(id) {
    this.todos = this.todos.filter(t => t.id !== id);
  }
}

// ViewModel
class TodoViewModel {
  constructor(model) {
    this.model = model;
    
    // Observable properties
    this.state = new Observable({
      todos: [],
      inputValue: '',
      filter: 'all', // all, active, completed
      isLoading: false,
      error: null
    });

    this.init();
  }

  async init() {
    await this.loadTodos();
  }

  async loadTodos() {
    this.state.data.isLoading = true;
    try {
      const todos = await this.model.getTodos();
      this.state.data.todos = todos;
      this.state.data.error = null;
    } catch (error) {
      this.state.data.error = 'Failed to load todos';
    } finally {
      this.state.data.isLoading = false;
    }
  }

  // Commands (actions user can trigger)
  async addTodo() {
    const text = this.state.data.inputValue.trim();
    if (!text) {
      this.state.data.error = 'Please enter a todo';
      return;
    }

    this.state.data.isLoading = true;
    try {
      await this.model.addTodo(text);
      this.state.data.inputValue = '';
      this.state.data.error = null;
      await this.loadTodos();
    } catch (error) {
      this.state.data.error = 'Failed to add todo';
    } finally {
      this.state.data.isLoading = false;
    }
  }

  async toggleTodo(id) {
    try {
      await this.model.toggleTodo(id);
      await this.loadTodos();
    } catch (error) {
      this.state.data.error = 'Failed to toggle todo';
    }
  }

  async deleteTodo(id) {
    try {
      await this.model.deleteTodo(id);
      await this.loadTodos();
    } catch (error) {
      this.state.data.error = 'Failed to delete todo';
    }
  }

  setFilter(filter) {
    this.state.data.filter = filter;
  }

  // Computed property
  get filteredTodos() {
    const { todos, filter } = this.state.data;
    switch (filter) {
      case 'active':
        return todos.filter(t => !t.completed);
      case 'completed':
        return todos.filter(t => t.completed);
      default:
        return todos;
    }
  }

  get activeTodoCount() {
    return this.state.data.todos.filter(t => !t.completed).length;
  }
}

// View (binds to ViewModel)
class TodoView {
  constructor(viewModel) {
    this.viewModel = viewModel;
    this.container = document.getElementById('todo-app');
    this.bindViewModel();
    this.render();
  }

  bindViewModel() {
    // Subscribe to all state changes
    this.viewModel.state.subscribe('todos', () => this.render());
    this.viewModel.state.subscribe('inputValue', () => this.renderInput());
    this.viewModel.state.subscribe('filter', () => this.render());
    this.viewModel.state.subscribe('isLoading', () => this.renderLoading());
    this.viewModel.state.subscribe('error', () => this.renderError());
  }

  render() {
    const todos = this.viewModel.filteredTodos;
    
    this.container.innerHTML = `
      <div class="todo-app">
        <input 
          type="text" 
          id="todo-input" 
          placeholder="Add a todo..."
          value="${this.viewModel.state.data.inputValue}"
        />
        <button id="add-btn">Add</button>
        
        <div id="loading"></div>
        <div id="error"></div>
        
        <div class="filters">
          <button class="filter-btn ${this.viewModel.state.data.filter === 'all' ? 'active' : ''}" 
                  data-filter="all">All</button>
          <button class="filter-btn ${this.viewModel.state.data.filter === 'active' ? 'active' : ''}" 
                  data-filter="active">Active</button>
          <button class="filter-btn ${this.viewModel.state.data.filter === 'completed' ? 'active' : ''}" 
                  data-filter="completed">Completed</button>
        </div>
        
        <ul id="todo-list">
          ${todos.map(todo => `
            <li class="${todo.completed ? 'completed' : ''}">
              <input 
                type="checkbox" 
                ${todo.completed ? 'checked' : ''}
                data-id="${todo.id}"
              />
              <span>${todo.text}</span>
              <button class="delete-btn" data-id="${todo.id}">Delete</button>
            </li>
          `).join('')}
        </ul>
        
        <div class="footer">
          ${this.viewModel.activeTodoCount} items left
        </div>
      </div>
    `;

    this.attachEvents();
    this.renderLoading();
    this.renderError();
  }

  attachEvents() {
    // Two-way binding for input
    const input = document.getElementById('todo-input');
    input.addEventListener('input', (e) => {
      this.viewModel.state.data.inputValue = e.target.value;
    });

    document.getElementById('add-btn').addEventListener('click', () => {
      this.viewModel.addTodo();
    });

    document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
      checkbox.addEventListener('change', (e) => {
        this.viewModel.toggleTodo(Number(e.target.dataset.id));
      });
    });

    document.querySelectorAll('.delete-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        this.viewModel.deleteTodo(Number(e.target.dataset.id));
      });
    });

    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        this.viewModel.setFilter(e.target.dataset.filter);
      });
    });
  }

  renderInput() {
    const input = document.getElementById('todo-input');
    if (input) {
      input.value = this.viewModel.state.data.inputValue;
    }
  }

  renderLoading() {
    const loadingEl = document.getElementById('loading');
    if (loadingEl) {
      loadingEl.innerHTML = this.viewModel.state.data.isLoading 
        ? '<div class="spinner">Loading...</div>' 
        : '';
    }
  }

  renderError() {
    const errorEl = document.getElementById('error');
    if (errorEl) {
      errorEl.innerHTML = this.viewModel.state.data.error 
        ? `<div class="error">${this.viewModel.state.data.error}</div>` 
        : '';
    }
  }
}

// Application initialization
const model = new TodoModel();
const viewModel = new TodoViewModel(model);
const view = new TodoView(viewModel);
```

### MVVM in Vue.js

```javascript
// Vue.js is inherently MVVM
const app = Vue.createApp({
  // This is the ViewModel
  data() {
    return {
      todos: [],
      inputValue: '',
      filter: 'all'
    };
  },
  
  computed: {
    filteredTodos() {
      switch (this.filter) {
        case 'active':
          return this.todos.filter(t => !t.completed);
        case 'completed':
          return this.todos.filter(t => t.completed);
        default:
          return this.todos;
      }
    },
    
    activeTodoCount() {
      return this.todos.filter(t => !t.completed).length;
    }
  },
  
  methods: {
    async addTodo() {
      if (!this.inputValue.trim()) return;
      
      const todo = {
        id: Date.now(),
        text: this.inputValue,
        completed: false
      };
      
      this.todos.push(todo);
      this.inputValue = '';
    },
    
    toggleTodo(id) {
      const todo = this.todos.find(t => t.id === id);
      if (todo) todo.completed = !todo.completed;
    },
    
    deleteTodo(id) {
      this.todos = this.todos.filter(t => t.id !== id);
    }
  }
});

app.mount('#app');
```

```html
<!-- Vue Template (View with declarative bindings) -->
<div id="app">
  <input v-model="inputValue" @keyup.enter="addTodo" placeholder="Add a todo" />
  <button @click="addTodo">Add</button>
  
  <div class="filters">
    <button @click="filter = 'all'" :class="{ active: filter === 'all' }">All</button>
    <button @click="filter = 'active'" :class="{ active: filter === 'active' }">Active</button>
    <button @click="filter = 'completed'" :class="{ active: filter === 'completed' }">Completed</button>
  </div>
  
  <ul>
    <li v-for="todo in filteredTodos" :key="todo.id" :class="{ completed: todo.completed }">
      <input type="checkbox" v-model="todo.completed" />
      <span>{{ todo.text }}</span>
      <button @click="deleteTodo(todo.id)">Delete</button>
    </li>
  </ul>
  
  <div class="footer">{{ activeTodoCount }} items left</div>
</div>
```

### MVVM Characteristics

‚úÖ **Advantages:**
- Two-way data binding reduces boilerplate
- ViewModel is highly testable
- Declarative View (easier to understand)
- Great for complex UIs
- Framework support (Vue, Angular, Knockout)

‚ùå **Disadvantages:**
- Learning curve for binding syntax
- Debugging data binding can be tricky
- Performance overhead with many bindings
- May be overkill for simple apps

---

## üìä Comparison Table

| Aspect | MVC | MVP | MVVM |
|--------|-----|-----|------|
| **View Intelligence** | Smart (knows Model) | Dumb (passive) | Declarative (bindings) |
| **Testability** | Medium | High | High |
| **View-Model Coupling** | Direct | Via Presenter | Via bindings |
| **Code in View** | Some logic | Minimal | Declarative only |
| **Best For** | Server-side, traditional web | Complex UI logic | Rich interactive UIs |
| **Framework Examples** | Express, Django, Rails | Android (old), WinForms | Vue, Angular, Knockout |
| **Learning Curve** | Low | Medium | Medium-High |
| **Boilerplate** | Low | Medium | Low (with framework) |
| **Two-way Binding** | No | No | Yes |

## üéØ When to Use Each

### Use MVC When:
- Building server-rendered applications
- Traditional multi-page websites
- RESTful APIs with views
- Simple applications

### Use MVP When:
- Need maximum testability
- Complex UI logic
- Multiple platforms (reuse Presenter)
- View technology might change

### Use MVVM When:
- Building SPAs (Single Page Apps)
- Rich, interactive UIs
- Using frameworks like Vue/Angular
- Want declarative data binding
- Rapid development with less boilerplate

## üîë Key Takeaways

1. **All three separate UI from logic** - the main goal
2. **MVC**: Traditional, View knows Model
3. **MVP**: Passive View, everything through Presenter
4. **MVVM**: Two-way binding, ViewModel exposes data
5. **Choose based on**: Framework, team expertise, application complexity

Modern frameworks have made these patterns easier to implement, with Vue.js being MVVM, React being more like a View in MVC/MVP, and Angular supporting MVVM with RxJS!