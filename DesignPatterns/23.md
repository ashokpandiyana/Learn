# Chapter 23: Iterator Pattern - In-Depth Guide

## ğŸ¯ Core Concept

The **Iterator Pattern** provides a way to access elements of a collection sequentially without exposing its underlying representation. It separates the traversal logic from the collection itself, allowing uniform access across different data structures.

### Visual Representation

```
Collection               Iterator
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [1,2,3,4]  â”‚â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  current: 0  â”‚
â”‚             â”‚         â”‚  next()      â”‚
â”‚  add()      â”‚         â”‚  hasNext()   â”‚
â”‚  remove()   â”‚         â”‚  current()   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”‘ Key Components

1. **Iterator Interface**: Defines methods for traversing (next, hasNext, current)
2. **Concrete Iterator**: Implements the iteration logic for a specific collection
3. **Aggregate/Collection**: Defines method to create an iterator
4. **Concrete Aggregate**: Returns an instance of concrete iterator

## ğŸ’» JavaScript Built-in Iterator Support

### Symbol.iterator Protocol

JavaScript has first-class support for iterators through `Symbol.iterator`:

```javascript
// Arrays are iterable by default
const array = [1, 2, 3, 4, 5];

// Get the iterator
const iterator = array[Symbol.iterator]();

console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: 4, done: false }
console.log(iterator.next()); // { value: 5, done: false }
console.log(iterator.next()); // { value: undefined, done: true }

// Using for...of (consumes iterator automatically)
for (const value of array) {
  console.log(value); // 1, 2, 3, 4, 5
}

// Spread operator uses iterator
const copy = [...array]; // [1, 2, 3, 4, 5]

// Array.from uses iterator
const copy2 = Array.from(array);
```

### Built-in Iterables

```javascript
// String
const str = 'Hello';
for (const char of str) {
  console.log(char); // H, e, l, l, o
}

// Map
const map = new Map([['a', 1], ['b', 2]]);
for (const [key, value] of map) {
  console.log(key, value);
}

// Set
const set = new Set([1, 2, 3]);
for (const value of set) {
  console.log(value);
}

// NodeList (DOM)
// document.querySelectorAll('div').forEach(...)
```

## ğŸ› ï¸ Custom Iterator Implementation

### Basic Custom Iterator

```javascript
class NumberRange {
  constructor(start, end, step = 1) {
    this.start = start;
    this.end = end;
    this.step = step;
  }
  
  // Make the object iterable
  [Symbol.iterator]() {
    let current = this.start;
    const end = this.end;
    const step = this.step;
    
    return {
      next() {
        if (current <= end) {
          const value = current;
          current += step;
          return { value, done: false };
        }
        return { value: undefined, done: true };
      }
    };
  }
}

// Usage
const range = new NumberRange(1, 10, 2);

for (const num of range) {
  console.log(num); // 1, 3, 5, 7, 9
}

// Can be spread
const numbers = [...new NumberRange(1, 5)]; // [1, 2, 3, 4, 5]
```

### Iterator with Additional Methods

```javascript
class ArrayIterator {
  constructor(array) {
    this.array = array;
    this.index = 0;
  }
  
  next() {
    if (this.hasNext()) {
      return {
        value: this.array[this.index++],
        done: false
      };
    }
    return { value: undefined, done: true };
  }
  
  hasNext() {
    return this.index < this.array.length;
  }
  
  current() {
    return this.array[this.index];
  }
  
  reset() {
    this.index = 0;
  }
  
  skip(count = 1) {
    this.index = Math.min(this.index + count, this.array.length);
  }
  
  rewind(count = 1) {
    this.index = Math.max(this.index - count, 0);
  }
}

// Usage
const iterator = new ArrayIterator([10, 20, 30, 40, 50]);

console.log(iterator.next()); // { value: 10, done: false }
console.log(iterator.next()); // { value: 20, done: false }
iterator.skip(2); // Skip 30, 40
console.log(iterator.next()); // { value: 50, done: false }
iterator.reset();
console.log(iterator.next()); // { value: 10, done: false }
```

## ğŸŒŸ Generator Functions (Simplified Iterators)

Generators provide a more elegant way to create iterators:

```javascript
// Generator function
function* numberRange(start, end, step = 1) {
  for (let i = start; i <= end; i += step) {
    yield i;
  }
}

// Usage
const range = numberRange(1, 5);

console.log(range.next()); // { value: 1, done: false }
console.log(range.next()); // { value: 2, done: false }

// Or use for...of
for (const num of numberRange(1, 5)) {
  console.log(num); // 1, 2, 3, 4, 5
}

// Infinite sequence generator
function* fibonacci() {
  let [a, b] = [0, 1];
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

// Get first 10 Fibonacci numbers
const fib = fibonacci();
const first10 = [];
for (let i = 0; i < 10; i++) {
  first10.push(fib.next().value);
}
console.log(first10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

## ğŸŒ² Tree Traversal Iterators

### Binary Tree with Different Traversal Strategies

```javascript
class TreeNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinaryTree {
  constructor(root = null) {
    this.root = root;
  }
  
  // In-order traversal (Left, Root, Right)
  *inOrder(node = this.root) {
    if (node) {
      yield* this.inOrder(node.left);
      yield node.value;
      yield* this.inOrder(node.right);
    }
  }
  
  // Pre-order traversal (Root, Left, Right)
  *preOrder(node = this.root) {
    if (node) {
      yield node.value;
      yield* this.preOrder(node.left);
      yield* this.preOrder(node.right);
    }
  }
  
  // Post-order traversal (Left, Right, Root)
  *postOrder(node = this.root) {
    if (node) {
      yield* this.postOrder(node.left);
      yield* this.postOrder(node.right);
      yield node.value;
    }
  }
  
  // Level-order traversal (Breadth-first)
  *levelOrder() {
    if (!this.root) return;
    
    const queue = [this.root];
    
    while (queue.length > 0) {
      const node = queue.shift();
      yield node.value;
      
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
  }
  
  // Default iterator (in-order)
  [Symbol.iterator]() {
    return this.inOrder();
  }
}

// Build tree:
//       4
//      / \
//     2   6
//    / \ / \
//   1  3 5  7

const tree = new BinaryTree(new TreeNode(4));
tree.root.left = new TreeNode(2);
tree.root.right = new TreeNode(6);
tree.root.left.left = new TreeNode(1);
tree.root.left.right = new TreeNode(3);
tree.root.right.left = new TreeNode(5);
tree.root.right.right = new TreeNode(7);

console.log('In-order:', [...tree.inOrder()]);    // [1,2,3,4,5,6,7]
console.log('Pre-order:', [...tree.preOrder()]);  // [4,2,1,3,6,5,7]
console.log('Post-order:', [...tree.postOrder()]); // [1,3,2,5,7,6,4]
console.log('Level-order:', [...tree.levelOrder()]); // [4,2,6,1,3,5,7]
console.log('Default:', [...tree]); // [1,2,3,4,5,6,7] (in-order)
```

## ğŸ“š Custom Collection with Multiple Iterators

```javascript
class BookCollection {
  constructor() {
    this.books = [];
  }
  
  addBook(title, author, year, genre) {
    this.books.push({ title, author, year, genre });
  }
  
  // Default iterator - all books
  [Symbol.iterator]() {
    return this.books[Symbol.iterator]();
  }
  
  // Iterator for books by genre
  *byGenre(genre) {
    for (const book of this.books) {
      if (book.genre === genre) {
        yield book;
      }
    }
  }
  
  // Iterator for books by author
  *byAuthor(author) {
    for (const book of this.books) {
      if (book.author === author) {
        yield book;
      }
    }
  }
  
  // Iterator for books in year range
  *byYearRange(startYear, endYear) {
    for (const book of this.books) {
      if (book.year >= startYear && book.year <= endYear) {
        yield book;
      }
    }
  }
  
  // Reverse iterator
  *reverse() {
    for (let i = this.books.length - 1; i >= 0; i--) {
      yield this.books[i];
    }
  }
  
  // Paginated iterator
  *paginate(pageSize = 5) {
    for (let i = 0; i < this.books.length; i += pageSize) {
      yield this.books.slice(i, i + pageSize);
    }
  }
}

// Usage
const library = new BookCollection();
library.addBook('1984', 'George Orwell', 1949, 'Fiction');
library.addBook('Animal Farm', 'George Orwell', 1945, 'Fiction');
library.addBook('Sapiens', 'Yuval Harari', 2011, 'Non-Fiction');
library.addBook('Brief History of Time', 'Stephen Hawking', 1988, 'Science');
library.addBook('The Selfish Gene', 'Richard Dawkins', 1976, 'Science');

console.log('\n=== All Books ===');
for (const book of library) {
  console.log(book.title);
}

console.log('\n=== Fiction Books ===');
for (const book of library.byGenre('Fiction')) {
  console.log(book.title);
}

console.log('\n=== Books by Orwell ===');
for (const book of library.byAuthor('George Orwell')) {
  console.log(book.title);
}

console.log('\n=== Books from 1940-1990 ===');
for (const book of library.byYearRange(1940, 1990)) {
  console.log(`${book.title} (${book.year})`);
}

console.log('\n=== Paginated (2 per page) ===');
let pageNum = 1;
for (const page of library.paginate(2)) {
  console.log(`Page ${pageNum++}:`, page.map(b => b.title));
}
```

## ğŸ”„ Bidirectional Iterator

```javascript
class BiDirectionalIterator {
  constructor(array) {
    this.array = array;
    this.index = 0;
  }
  
  next() {
    if (this.hasNext()) {
      return {
        value: this.array[this.index++],
        done: false
      };
    }
    return { value: undefined, done: true };
  }
  
  previous() {
    if (this.hasPrevious()) {
      return {
        value: this.array[--this.index],
        done: false
      };
    }
    return { value: undefined, done: true };
  }
  
  hasNext() {
    return this.index < this.array.length;
  }
  
  hasPrevious() {
    return this.index > 0;
  }
  
  first() {
    this.index = 0;
    return this.array[0];
  }
  
  last() {
    this.index = this.array.length - 1;
    return this.array[this.index];
  }
  
  current() {
    return this.array[this.index];
  }
}

// Usage
const iter = new BiDirectionalIterator(['A', 'B', 'C', 'D', 'E']);

console.log(iter.next());     // { value: 'A', done: false }
console.log(iter.next());     // { value: 'B', done: false }
console.log(iter.next());     // { value: 'C', done: false }
console.log(iter.previous()); // { value: 'B', done: false }
console.log(iter.previous()); // { value: 'A', done: false }
console.log(iter.last());     // 'E'
console.log(iter.first());    // 'A'
```

## ğŸ® Lazy Evaluation with Iterators

```javascript
class LazyRange {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }
  
  *[Symbol.iterator]() {
    console.log('Iterator started');
    for (let i = this.start; i <= this.end; i++) {
      console.log(`Generating ${i}`);
      yield i;
    }
    console.log('Iterator finished');
  }
  
  map(fn) {
    const parent = this;
    return {
      *[Symbol.iterator]() {
        for (const value of parent) {
          yield fn(value);
        }
      }
    };
  }
  
  filter(predicate) {
    const parent = this;
    return {
      *[Symbol.iterator]() {
        for (const value of parent) {
          if (predicate(value)) {
            yield value;
          }
        }
      }
    };
  }
  
  take(count) {
    const parent = this;
    return {
      *[Symbol.iterator]() {
        let taken = 0;
        for (const value of parent) {
          if (taken >= count) break;
          yield value;
          taken++;
        }
      }
    };
  }
}

// Usage - operations are lazy, nothing executes yet
const range = new LazyRange(1, 1000000); // Million numbers

const result = range
  .filter(x => x % 2 === 0)    // Even numbers only
  .map(x => x * x)             // Square them
  .take(5);                    // Take first 5

console.log('\nStarting iteration (lazy execution):');
for (const value of result) {
  console.log(`Result: ${value}`);
}
// Only generates numbers until we have 5 results!
```

## ğŸŒ Async Iterators

```javascript
// Async Iterator for fetching paginated data
class PaginatedAPI {
  constructor(baseUrl, pageSize = 10) {
    this.baseUrl = baseUrl;
    this.pageSize = pageSize;
  }
  
  async *[Symbol.asyncIterator]() {
    let page = 1;
    let hasMore = true;
    
    while (hasMore) {
      console.log(`Fetching page ${page}...`);
      
      // Simulate API call
      const data = await this.fetchPage(page);
      
      for (const item of data.items) {
        yield item;
      }
      
      hasMore = data.hasMore;
      page++;
    }
  }
  
  async fetchPage(page) {
    // Simulate API delay
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Simulate data
    const start = (page - 1) * this.pageSize;
    const items = Array.from(
      { length: this.pageSize },
      (_, i) => ({ id: start + i + 1, name: `Item ${start + i + 1}` })
    );
    
    return {
      items,
      hasMore: page < 3 // Only 3 pages total
    };
  }
}

// Usage with for await...of
async function processData() {
  const api = new PaginatedAPI('/api/items', 10);
  
  let count = 0;
  for await (const item of api) {
    console.log(item);
    count++;
    if (count >= 25) break; // Get first 25 items
  }
}

// processData();

// Async generator for reading large files
async function* readLargeFile(filename) {
  const chunkSize = 1024;
  let offset = 0;
  
  while (true) {
    // Simulate reading chunk
    const chunk = await readChunk(filename, offset, chunkSize);
    
    if (chunk.length === 0) break;
    
    yield chunk;
    offset += chunk.length;
  }
}

async function readChunk(filename, offset, size) {
  // Simulate async file reading
  await new Promise(resolve => setTimeout(resolve, 10));
  
  // Return simulated data (empty after 5 chunks)
  if (offset >= 5000) return '';
  
  return `Chunk at offset ${offset}`;
}

// Usage
async function processFile() {
  for await (const chunk of readLargeFile('large.txt')) {
    console.log('Processing:', chunk);
  }
}

// processFile();
```

## ğŸ”§ Practical Example: Custom Data Structure

```javascript
class CircularBuffer {
  constructor(capacity) {
    this.capacity = capacity;
    this.buffer = new Array(capacity);
    this.head = 0;
    this.tail = 0;
    this.size = 0;
  }
  
  push(item) {
    this.buffer[this.tail] = item;
    this.tail = (this.tail + 1) % this.capacity;
    
    if (this.size < this.capacity) {
      this.size++;
    } else {
      // Overwrite, move head forward
      this.head = (this.head + 1) % this.capacity;
    }
  }
  
  *[Symbol.iterator]() {
    for (let i = 0; i < this.size; i++) {
      const index = (this.head + i) % this.capacity;
      yield this.buffer[index];
    }
  }
  
  *reverse() {
    for (let i = this.size - 1; i >= 0; i--) {
      const index = (this.head + i) % this.capacity;
      yield this.buffer[index];
    }
  }
}

// Usage
const buffer = new CircularBuffer(5);

// Add items
[1, 2, 3, 4, 5, 6, 7].forEach(n => buffer.push(n));

console.log('Forward:', [...buffer]);  // [3, 4, 5, 6, 7] (first two overwritten)
console.log('Reverse:', [...buffer.reverse()]); // [7, 6, 5, 4, 3]
```

## âœ… When to Use Iterator Pattern

**Use Iterator Pattern when:**
- You need uniform access across different data structures
- You want to traverse a collection without exposing its internal structure
- You need multiple simultaneous traversals
- You want to provide different traversal strategies for the same collection

**Don't use when:**
- Simple array access is sufficient
- Collection is very small and simple
- Performance is critical and iterator overhead matters

## ğŸ¯ Benefits & Trade-offs

### Benefits
- **Encapsulation**: Internal structure hidden
- **Uniform access**: Same interface for different collections
- **Multiple traversals**: Can have many iterators on same collection
- **Simplified collection interface**: Traversal logic separated
- **Lazy evaluation**: Generate values on-demand

### Trade-offs
- **Memory overhead**: Each iterator maintains state
- **Modification issues**: Iterating while modifying can cause problems
- **Performance**: Slight overhead compared to direct access
- **Complexity**: Overkill for simple cases

## ğŸ’¡ Pro Tips

1. **Use generators** for simpler iterator implementation
2. **Consider lazy evaluation** for large datasets
3. **Handle concurrent modifications** gracefully
4. **Implement `Symbol.iterator`** for native JavaScript features
5. **Use async iterators** for I/O operations
6. **Cache results** when appropriate (but watch memory)
7. **Document iterator behavior** (order, state, thread-safety)
8. **Provide multiple iterators** for different use cases
9. **Use built-in iterators** when possible (Array, Map, Set)
10. **Test edge cases**: empty collections, single items, concurrent access