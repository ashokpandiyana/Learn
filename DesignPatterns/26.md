# Chapter 26: Memento Pattern - In Depth Guide

## üìö Overview

The Memento Pattern is a behavioral design pattern that allows you to capture and externalize an object's internal state without violating encapsulation, so that the object can be restored to this state later. Think of it as a "save game" feature for your objects.

## üéØ Core Concept

The Memento Pattern involves three key players:

1. **Originator**: The object whose state needs to be saved
2. **Memento**: The stored state snapshot (immutable)
3. **Caretaker**: Manages and stores mementos without examining their contents

### The Key Principle
The originator has full access to the memento, but the caretaker only stores it - this maintains encapsulation.

## üîß Basic Implementation

### Simple Text Editor Example

```javascript
// Memento - stores the state
class EditorMemento {
  constructor(content, cursorPosition) {
    this._content = content;
    this._cursorPosition = cursorPosition;
    this._timestamp = new Date();
  }

  getContent() {
    return this._content;
  }

  getCursorPosition() {
    return this._cursorPosition;
  }

  getTimestamp() {
    return this._timestamp;
  }
}

// Originator - the object we want to save/restore
class TextEditor {
  constructor() {
    this.content = '';
    this.cursorPosition = 0;
  }

  type(text) {
    this.content = this.content.slice(0, this.cursorPosition) 
                  + text 
                  + this.content.slice(this.cursorPosition);
    this.cursorPosition += text.length;
  }

  delete() {
    if (this.cursorPosition > 0) {
      this.content = this.content.slice(0, this.cursorPosition - 1) 
                    + this.content.slice(this.cursorPosition);
      this.cursorPosition--;
    }
  }

  moveCursor(position) {
    this.cursorPosition = Math.max(0, Math.min(position, this.content.length));
  }

  // Create memento
  save() {
    return new EditorMemento(this.content, this.cursorPosition);
  }

  // Restore from memento
  restore(memento) {
    this.content = memento.getContent();
    this.cursorPosition = memento.getCursorPosition();
  }

  getContent() {
    return this.content;
  }
}

// Caretaker - manages the history
class EditorHistory {
  constructor() {
    this.history = [];
    this.currentIndex = -1;
  }

  save(memento) {
    // Remove any future states when saving a new one
    this.history = this.history.slice(0, this.currentIndex + 1);
    this.history.push(memento);
    this.currentIndex++;
  }

  undo() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      return this.history[this.currentIndex];
    }
    return null;
  }

  redo() {
    if (this.currentIndex < this.history.length - 1) {
      this.currentIndex++;
      return this.history[this.currentIndex];
    }
    return null;
  }

  canUndo() {
    return this.currentIndex > 0;
  }

  canRedo() {
    return this.currentIndex < this.history.length - 1;
  }

  getHistorySize() {
    return this.history.length;
  }
}

// Usage
const editor = new TextEditor();
const history = new EditorHistory();

// Save initial state
history.save(editor.save());

editor.type('Hello');
history.save(editor.save());

editor.type(' World');
history.save(editor.save());

editor.type('!');
history.save(editor.save());

console.log(editor.getContent()); // "Hello World!"

// Undo operations
if (history.canUndo()) {
  editor.restore(history.undo());
  console.log(editor.getContent()); // "Hello World"
}

if (history.canUndo()) {
  editor.restore(history.undo());
  console.log(editor.getContent()); // "Hello"
}

// Redo operations
if (history.canRedo()) {
  editor.restore(history.redo());
  console.log(editor.getContent()); // "Hello World"
}
```

## üé® Advanced Implementation: Canvas Drawing App

```javascript
// Memento for canvas state
class CanvasMemento {
  constructor(imageData, operations) {
    this._imageData = imageData;
    this._operations = [...operations];
    this._timestamp = Date.now();
  }

  getImageData() {
    return this._imageData;
  }

  getOperations() {
    return this._operations;
  }

  getTimestamp() {
    return this._timestamp;
  }
}

// Originator - Canvas Drawing Application
class DrawingCanvas {
  constructor(canvasElement) {
    this.canvas = canvasElement;
    this.ctx = canvasElement.getContext('2d');
    this.operations = []; // Store operations for replay
  }

  drawLine(startX, startY, endX, endY, color = 'black', width = 2) {
    this.ctx.beginPath();
    this.ctx.strokeStyle = color;
    this.ctx.lineWidth = width;
    this.ctx.moveTo(startX, startY);
    this.ctx.lineTo(endX, endY);
    this.ctx.stroke();

    this.operations.push({
      type: 'line',
      startX, startY, endX, endY, color, width
    });
  }

  drawCircle(x, y, radius, color = 'black', fill = false) {
    this.ctx.beginPath();
    this.ctx.arc(x, y, radius, 0, 2 * Math.PI);
    
    if (fill) {
      this.ctx.fillStyle = color;
      this.ctx.fill();
    } else {
      this.ctx.strokeStyle = color;
      this.ctx.stroke();
    }

    this.operations.push({
      type: 'circle',
      x, y, radius, color, fill
    });
  }

  clear() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.operations = [];
  }

  // Save current state
  save() {
    const imageData = this.ctx.getImageData(
      0, 0, 
      this.canvas.width, 
      this.canvas.height
    );
    return new CanvasMemento(imageData, this.operations);
  }

  // Restore from memento
  restore(memento) {
    this.ctx.putImageData(memento.getImageData(), 0, 0);
    this.operations = [...memento.getOperations()];
  }

  // Replay operations (alternative restoration method)
  replayOperations(operations) {
    this.clear();
    operations.forEach(op => {
      if (op.type === 'line') {
        this.ctx.beginPath();
        this.ctx.strokeStyle = op.color;
        this.ctx.lineWidth = op.width;
        this.ctx.moveTo(op.startX, op.startY);
        this.ctx.lineTo(op.endX, op.endY);
        this.ctx.stroke();
      } else if (op.type === 'circle') {
        this.ctx.beginPath();
        this.ctx.arc(op.x, op.y, op.radius, 0, 2 * Math.PI);
        if (op.fill) {
          this.ctx.fillStyle = op.color;
          this.ctx.fill();
        } else {
          this.ctx.strokeStyle = op.color;
          this.ctx.stroke();
        }
      }
    });
    this.operations = [...operations];
  }
}

// Caretaker with advanced features
class CanvasHistory {
  constructor(maxStates = 50) {
    this.states = [];
    this.currentIndex = -1;
    this.maxStates = maxStates;
  }

  save(memento) {
    // Remove future states
    this.states = this.states.slice(0, this.currentIndex + 1);
    
    // Add new state
    this.states.push(memento);
    
    // Limit history size
    if (this.states.length > this.maxStates) {
      this.states.shift();
    } else {
      this.currentIndex++;
    }
  }

  undo() {
    if (this.canUndo()) {
      this.currentIndex--;
      return this.states[this.currentIndex];
    }
    return null;
  }

  redo() {
    if (this.canRedo()) {
      this.currentIndex++;
      return this.states[this.currentIndex];
    }
    return null;
  }

  canUndo() {
    return this.currentIndex > 0;
  }

  canRedo() {
    return this.currentIndex < this.states.length - 1;
  }

  jumpToState(index) {
    if (index >= 0 && index < this.states.length) {
      this.currentIndex = index;
      return this.states[index];
    }
    return null;
  }

  getStateInfo() {
    return this.states.map((state, index) => ({
      index,
      timestamp: new Date(state.getTimestamp()).toLocaleTimeString(),
      isCurrent: index === this.currentIndex
    }));
  }
}
```

## üéÆ Real-World Example: Game Save System

```javascript
// Memento for game state
class GameStateMemento {
  constructor(gameState) {
    // Deep clone the state to prevent mutations
    this._state = JSON.parse(JSON.stringify(gameState));
    this._timestamp = Date.now();
    this._saveId = this._generateId();
  }

  getState() {
    return JSON.parse(JSON.stringify(this._state));
  }

  getTimestamp() {
    return this._timestamp;
  }

  getSaveId() {
    return this._saveId;
  }

  _generateId() {
    return `save_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

// Originator - Game
class Game {
  constructor() {
    this.player = {
      name: '',
      health: 100,
      level: 1,
      position: { x: 0, y: 0 },
      inventory: [],
      gold: 0
    };
    this.world = {
      currentLevel: 'level_1',
      completedQuests: [],
      discoveredLocations: []
    };
    this.gameTime = 0;
  }

  // Game actions
  movePlayer(x, y) {
    this.player.position = { x, y };
  }

  collectItem(item) {
    this.player.inventory.push(item);
  }

  takeDamage(amount) {
    this.player.health = Math.max(0, this.player.health - amount);
  }

  heal(amount) {
    this.player.health = Math.min(100, this.player.health + amount);
  }

  levelUp() {
    this.player.level++;
    this.player.health = 100; // Full health on level up
  }

  completeQuest(questId) {
    this.world.completedQuests.push(questId);
  }

  // Save game
  createSave() {
    return new GameStateMemento({
      player: this.player,
      world: this.world,
      gameTime: this.gameTime
    });
  }

  // Load game
  loadSave(memento) {
    const state = memento.getState();
    this.player = state.player;
    this.world = state.world;
    this.gameTime = state.gameTime;
  }

  getPlayerInfo() {
    return `${this.player.name} - Level ${this.player.level} - HP: ${this.player.health}`;
  }
}

// Caretaker - Save Manager
class SaveManager {
  constructor() {
    this.saves = new Map();
    this.quickSave = null;
  }

  // Create a named save
  createSave(name, memento) {
    this.saves.set(name, {
      memento,
      name,
      timestamp: memento.getTimestamp(),
      id: memento.getSaveId()
    });
    this._persistToStorage();
  }

  // Quick save (single slot)
  quickSave(memento) {
    this.quickSave = memento;
    this._persistToStorage();
  }

  // Load a named save
  loadSave(name) {
    const save = this.saves.get(name);
    return save ? save.memento : null;
  }

  // Load quick save
  loadQuickSave() {
    return this.quickSave;
  }

  // Delete a save
  deleteSave(name) {
    this.saves.delete(name);
    this._persistToStorage();
  }

  // Get all saves info
  getAllSaves() {
    return Array.from(this.saves.values()).map(save => ({
      name: save.name,
      timestamp: new Date(save.timestamp).toLocaleString(),
      id: save.id
    }));
  }

  // Autosave functionality
  autoSave(memento, interval = 5 * 60 * 1000) { // Default: 5 minutes
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
    }

    this.autoSaveInterval = setInterval(() => {
      this.createSave('autosave', memento);
      console.log('Auto-saved at', new Date().toLocaleTimeString());
    }, interval);
  }

  stopAutoSave() {
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
    }
  }

  // Persist to localStorage (browser) or file system (Node.js)
  _persistToStorage() {
    if (typeof localStorage !== 'undefined') {
      const savesData = {
        saves: Array.from(this.saves.entries()),
        quickSave: this.quickSave
      };
      localStorage.setItem('gameSaves', JSON.stringify(savesData));
    }
  }

  // Load from storage
  loadFromStorage() {
    if (typeof localStorage !== 'undefined') {
      const data = localStorage.getItem('gameSaves');
      if (data) {
        const { saves, quickSave } = JSON.parse(data);
        this.saves = new Map(saves);
        this.quickSave = quickSave;
      }
    }
  }
}

// Usage Example
const game = new Game();
const saveManager = new SaveManager();

// Initialize game
game.player.name = 'Hero';
game.movePlayer(10, 20);
game.collectItem('sword');
game.collectItem('shield');

// Create initial save
saveManager.createSave('start', game.createSave());

// Play the game
game.movePlayer(50, 75);
game.takeDamage(30);
game.completeQuest('quest_1');

// Quick save
saveManager.quickSave(game.createSave());

// Continue playing
game.levelUp();
game.collectItem('potion');

// Create another save
saveManager.createSave('level_2_start', game.createSave());

// Player dies, load quick save
const quickSaveState = saveManager.loadQuickSave();
if (quickSaveState) {
  game.loadSave(quickSaveState);
  console.log('Game loaded from quick save');
  console.log(game.getPlayerInfo());
}

// List all saves
console.log('Available saves:', saveManager.getAllSaves());
```

## üíæ Optimized Implementation with Compression

For large states, consider compression:

```javascript
class OptimizedMemento {
  constructor(state) {
    this._compressedState = this._compress(state);
    this._timestamp = Date.now();
  }

  getState() {
    return this._decompress(this._compressedState);
  }

  _compress(state) {
    // Simple compression using JSON + base64
    // In production, use libraries like pako or lz-string
    const json = JSON.stringify(state);
    if (typeof btoa !== 'undefined') {
      return btoa(json);
    }
    return json;
  }

  _decompress(compressed) {
    if (typeof atob !== 'undefined') {
      return JSON.parse(atob(compressed));
    }
    return JSON.parse(compressed);
  }

  getSize() {
    return this._compressedState.length;
  }
}

// Caretaker with memory management
class SmartHistory {
  constructor(maxMemory = 10 * 1024 * 1024) { // 10MB default
    this.states = [];
    this.currentIndex = -1;
    this.maxMemory = maxMemory;
  }

  save(memento) {
    // Remove future states
    this.states = this.states.slice(0, this.currentIndex + 1);
    
    // Add new state
    this.states.push(memento);
    this.currentIndex++;
    
    // Check memory usage
    this._manageMemory();
  }

  _manageMemory() {
    let totalSize = this.states.reduce((sum, state) => 
      sum + (state.getSize ? state.getSize() : 0), 0
    );

    // Remove oldest states if over memory limit
    while (totalSize > this.maxMemory && this.states.length > 1) {
      this.states.shift();
      this.currentIndex--;
      totalSize = this.states.reduce((sum, state) => 
        sum + (state.getSize ? state.getSize() : 0), 0
      );
    }
  }

  getMemoryUsage() {
    const totalSize = this.states.reduce((sum, state) => 
      sum + (state.getSize ? state.getSize() : 0), 0
    );
    return {
      used: totalSize,
      max: this.maxMemory,
      percentage: (totalSize / this.maxMemory * 100).toFixed(2)
    };
  }
}
```

## ‚ö° Performance Considerations

### 1. Differential State Saving
Instead of saving the entire state, save only changes:

```javascript
class DifferentialMemento {
  constructor(changes, previousMemento = null) {
    this._changes = changes;
    this._previousMemento = previousMemento;
    this._timestamp = Date.now();
  }

  getFullState() {
    if (!this._previousMemento) {
      return this._changes; // This is the full initial state
    }

    // Merge changes with previous state
    const previousState = this._previousMemento.getFullState();
    return { ...previousState, ...this._changes };
  }

  getChanges() {
    return this._changes;
  }
}

class StateTracker {
  constructor(initialState) {
    this.currentState = initialState;
    this.previousState = { ...initialState };
  }

  update(newState) {
    this.previousState = { ...this.currentState };
    this.currentState = newState;
  }

  getChanges() {
    const changes = {};
    for (const key in this.currentState) {
      if (this.currentState[key] !== this.previousState[key]) {
        changes[key] = this.currentState[key];
      }
    }
    return changes;
  }

  createMemento(previousMemento = null) {
    const changes = this.getChanges();
    return new DifferentialMemento(changes, previousMemento);
  }
}
```

## üéØ When to Use Memento Pattern

### ‚úÖ Use When:
- You need undo/redo functionality
- You need to save snapshots of object state
- You want to restore objects to previous states
- You need transaction rollback capability
- State history is important (audit trails)

### ‚ùå Avoid When:
- State changes are trivial and don't need history
- Memory constraints are tight (large states)
- State is too large and changes frequently
- Simple setters/getters would suffice

## üÜö Memento vs Other Patterns

| Pattern | Purpose | State Management |
|---------|---------|------------------|
| **Memento** | Save and restore state | External storage |
| **Command** | Encapsulate actions | Can store state for undo |
| **Prototype** | Clone objects | New independent copy |
| **State** | Change behavior | Current state only |

## üöÄ Best Practices

1. **Immutability**: Make mementos immutable
2. **Encapsulation**: Caretaker shouldn't access memento internals
3. **Memory Management**: Implement limits on history size
4. **Serialization**: Use efficient serialization for persistence
5. **Validation**: Validate state before restoration
6. **Metadata**: Include timestamps and identifiers
7. **Compression**: Consider compression for large states

## üîí Common Pitfalls

1. **Memory Leaks**: Unlimited history growth
2. **Performance**: Saving large states frequently
3. **Mutation**: Modifying memento contents
4. **Deep Cloning**: Forgetting to deep clone nested objects
5. **Circular References**: Can't serialize with JSON.stringify

## üìù Summary

The Memento Pattern is essential for implementing undo/redo functionality and state management in applications. It maintains encapsulation while allowing state snapshots, making it perfect for editors, games, and transactional systems. Remember to manage memory carefully and consider optimization techniques for production use.