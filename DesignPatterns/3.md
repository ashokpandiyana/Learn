# Chapter 3: Singleton Pattern

## 3.1 Concept and Use Cases

### What is the Singleton Pattern?

The **Singleton Pattern** ensures that a class has only **one instance** and provides a **global point of access** to that instance.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SINGLETON PATTERN                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚    â”‚   Client A    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚                           â”‚  â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚                           â”‚  â”‚
â”‚                              â”‚      SINGLE INSTANCE      â”‚  â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚                           â”‚  â”‚
â”‚    â”‚   Client B    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚    DatabaseConnection    â”‚  â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚                           â”‚  â”‚
â”‚                              â”‚                           â”‚  â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚                           â”‚  â”‚
â”‚    â”‚   Client C    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚                           â”‚  â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                             â”‚
â”‚    All clients receive the SAME instance                    â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Core Characteristics

1. **Single Instance**: Only one instance of the class exists
2. **Global Access**: Instance is accessible from anywhere
3. **Lazy Initialization**: Instance is created only when needed (optional)
4. **Instance Control**: The class itself controls instantiation

### When to Use Singleton

| Use Case | Example | Why Singleton? |
|----------|---------|----------------|
| **Configuration** | App settings, environment variables | Single source of truth |
| **Logging** | Application logger | Consistent log destination |
| **Database Connection** | Connection pool | Expensive to create, share connection |
| **Caching** | In-memory cache | Shared cache across modules |
| **State Management** | Redux store | Single state tree |
| **Hardware Access** | Printer spooler | Control access to shared resource |

### Real-World Analogy

Think of a **government** in a country:
- There's only ONE government at a time
- Everyone in the country accesses the SAME government
- You can't just create a new government (it's controlled)
- It's globally accessible to all citizens

---

## 3.2 Implementation Techniques

### Implementation 1: Classic Singleton with Closure (ES5)

```javascript
const Singleton = (function() {
  // Private instance variable
  let instance;
  
  // Private constructor function
  function createInstance() {
    return {
      id: Math.random().toString(36).substr(2, 9),
      createdAt: new Date(),
      
      // Instance methods
      getId() {
        return this.id;
      },
      
      getUptime() {
        return Date.now() - this.createdAt.getTime();
      }
    };
  }
  
  // Public API
  return {
    getInstance() {
      if (!instance) {
        console.log('Creating new instance...');
        instance = createInstance();
      } else {
        console.log('Returning existing instance...');
      }
      return instance;
    }
  };
})();

// Usage
const instance1 = Singleton.getInstance(); // "Creating new instance..."
const instance2 = Singleton.getInstance(); // "Returning existing instance..."

console.log(instance1 === instance2); // true
console.log(instance1.getId() === instance2.getId()); // true
```

### Implementation 2: ES6 Class Singleton

```javascript
class DatabaseConnection {
  constructor() {
    // Check if instance already exists
    if (DatabaseConnection.instance) {
      return DatabaseConnection.instance;
    }
    
    // Initialize the singleton instance
    this.connection = null;
    this.connectionString = '';
    
    // Store instance
    DatabaseConnection.instance = this;
    
    // Freeze to prevent modification (optional)
    // Object.freeze(this);
  }
  
  connect(connectionString) {
    if (this.connection) {
      console.log('Already connected');
      return this.connection;
    }
    
    console.log(`Connecting to: ${connectionString}`);
    this.connectionString = connectionString;
    this.connection = { /* mock connection object */ };
    return this.connection;
  }
  
  disconnect() {
    console.log('Disconnecting...');
    this.connection = null;
  }
  
  query(sql) {
    if (!this.connection) {
      throw new Error('Not connected to database');
    }
    console.log(`Executing: ${sql}`);
    return []; // Mock result
  }
  
  // Static method to get instance (alternative access)
  static getInstance() {
    if (!DatabaseConnection.instance) {
      DatabaseConnection.instance = new DatabaseConnection();
    }
    return DatabaseConnection.instance;
  }
}

// Usage
const db1 = new DatabaseConnection();
const db2 = new DatabaseConnection();
const db3 = DatabaseConnection.getInstance();

console.log(db1 === db2); // true
console.log(db2 === db3); // true

db1.connect('mongodb://localhost/mydb');
db2.query('SELECT * FROM users'); // Works because db2 is same instance
```

### Implementation 3: ES6 Module Singleton (Recommended)

This is the **cleanest and most recommended** approach in modern JavaScript.

```javascript
// database.js
class Database {
  constructor() {
    this.connection = null;
  }
  
  connect(uri) {
    console.log(`Connecting to ${uri}`);
    this.connection = { uri, connected: true };
  }
  
  query(sql) {
    console.log(`Query: ${sql}`);
    return [];
  }
}

// Create and export single instance
const database = new Database();

// Freeze to prevent reassignment (optional)
Object.freeze(database);

export default database;

// -------------------------------------------
// userService.js
import database from './database.js';

database.connect('mongodb://localhost');
database.query('SELECT * FROM users');

// -------------------------------------------
// productService.js
import database from './database.js';

// Same instance! Already connected
database.query('SELECT * FROM products');
```

**Why this works:**
- ES6 modules are **evaluated only once**
- All imports receive the **same instance**
- No explicit singleton code needed
- The module system handles it naturally

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ES6 MODULE SINGLETON MECHANISM                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   database.js        First import          Subsequent imports
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
â”‚   â”‚ database â”‚                                              â”‚
â”‚   â”‚ instance â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                              â”‚
â”‚       â–²                                                     â”‚
â”‚       â”‚  Created ONCE                                       â”‚
â”‚       â”‚  Cached by module system                            â”‚
â”‚       â”‚  All imports get same reference                     â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Implementation 4: Singleton with Lazy Initialization

```javascript
class ExpensiveResource {
  static #instance = null;
  
  constructor() {
    if (ExpensiveResource.#instance) {
      throw new Error('Use ExpensiveResource.getInstance() instead');
    }
    
    // Expensive initialization
    console.log('Performing expensive initialization...');
    this.data = this.#loadData();
  }
  
  #loadData() {
    // Simulate expensive operation
    return { loaded: true, timestamp: Date.now() };
  }
  
  static getInstance() {
    if (!ExpensiveResource.#instance) {
      ExpensiveResource.#instance = new ExpensiveResource();
    }
    return ExpensiveResource.#instance;
  }
  
  getData() {
    return this.data;
  }
}

// Resource is NOT created until first getInstance() call
console.log('Application started');

// ... later when actually needed
const resource = ExpensiveResource.getInstance(); // NOW it's created
console.log(resource.getData());

// This will throw an error
// const bad = new ExpensiveResource(); // Error!
```

---

## 3.3 Practical Production Examples

### Example 1: Configuration Manager

```javascript
// config.js
class ConfigManager {
  static #instance = null;
  #config = {};
  #frozen = false;
  
  constructor() {
    if (ConfigManager.#instance) {
      return ConfigManager.#instance;
    }
    ConfigManager.#instance = this;
  }
  
  load(config) {
    if (this.#frozen) {
      throw new Error('Configuration is frozen');
    }
    
    this.#config = {
      ...this.#config,
      ...config
    };
    
    return this;
  }
  
  get(key) {
    const keys = key.split('.');
    let value = this.#config;
    
    for (const k of keys) {
      if (value === undefined) return undefined;
      value = value[k];
    }
    
    return value;
  }
  
  freeze() {
    this.#frozen = true;
    console.log('Configuration frozen');
  }
  
  getAll() {
    return { ...this.#config }; // Return copy
  }
  
  static getInstance() {
    if (!ConfigManager.#instance) {
      ConfigManager.#instance = new ConfigManager();
    }
    return ConfigManager.#instance;
  }
}

// Usage
const config = ConfigManager.getInstance();

config.load({
  database: {
    host: 'localhost',
    port: 5432,
    name: 'myapp'
  },
  api: {
    timeout: 5000,
    retries: 3
  }
});

config.freeze(); // No more changes allowed

console.log(config.get('database.host')); // 'localhost'
console.log(config.get('api.timeout'));   // 5000

// From anywhere else in the app
const sameConfig = ConfigManager.getInstance();
console.log(sameConfig.get('database.port')); // 5432
```

### Example 2: Logger Service

```javascript
// logger.js
class Logger {
  static #instance = null;
  
  #levels = {
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3
  };
  
  #currentLevel = 1; // INFO by default
  #outputs = [];
  
  constructor() {
    if (Logger.#instance) {
      return Logger.#instance;
    }
    
    // Default output
    this.#outputs.push(console.log);
    Logger.#instance = this;
  }
  
  setLevel(level) {
    if (this.#levels[level] !== undefined) {
      this.#currentLevel = this.#levels[level];
    }
  }
  
  addOutput(fn) {
    this.#outputs.push(fn);
  }
  
  #log(level, message, ...args) {
    if (this.#levels[level] < this.#currentLevel) return;
    
    const timestamp = new Date().toISOString();
    const formattedMessage = `[${timestamp}] [${level}] ${message}`;
    
    this.#outputs.forEach(output => {
      output(formattedMessage, ...args);
    });
  }
  
  debug(message, ...args) { this.#log('DEBUG', message, ...args); }
  info(message, ...args)  { this.#log('INFO', message, ...args); }
  warn(message, ...args)  { this.#log('WARN', message, ...args); }
  error(message, ...args) { this.#log('ERROR', message, ...args); }
  
  static getInstance() {
    if (!Logger.#instance) {
      Logger.#instance = new Logger();
    }
    return Logger.#instance;
  }
}

// Export singleton instance
export const logger = Logger.getInstance();

// Usage
import { logger } from './logger.js';

logger.setLevel('DEBUG');
logger.debug('Debugging application');
logger.info('User logged in', { userId: 123 });
logger.error('Failed to connect', new Error('Connection refused'));
```

### Example 3: State Store (Redux-like)

```javascript
// store.js
class Store {
  static #instance = null;
  
  #state = {};
  #listeners = [];
  #reducer;
  
  constructor(reducer, initialState = {}) {
    if (Store.#instance) {
      return Store.#instance;
    }
    
    this.#reducer = reducer;
    this.#state = initialState;
    Store.#instance = this;
  }
  
  getState() {
    return { ...this.#state }; // Return copy
  }
  
  dispatch(action) {
    console.log('Dispatching:', action.type);
    
    const prevState = this.#state;
    this.#state = this.#reducer(this.#state, action);
    
    // Notify listeners only if state changed
    if (prevState !== this.#state) {
      this.#listeners.forEach(listener => listener(this.#state));
    }
    
    return action;
  }
  
  subscribe(listener) {
    this.#listeners.push(listener);
    
    // Return unsubscribe function
    return () => {
      this.#listeners = this.#listeners.filter(l => l !== listener);
    };
  }
  
  static getInstance() {
    return Store.#instance;
  }
}

// Usage
const reducer = (state = { count: 0 }, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    default:
      return state;
  }
};

const store = new Store(reducer, { count: 0 });

// Subscribe to changes
const unsubscribe = store.subscribe(state => {
  console.log('State changed:', state);
});

store.dispatch({ type: 'INCREMENT' }); // State changed: { count: 1 }
store.dispatch({ type: 'INCREMENT' }); // State changed: { count: 2 }

unsubscribe(); // Stop listening
store.dispatch({ type: 'DECREMENT' }); // No log, but state still changes
```

---

## 3.4 Production Considerations

### Testing Challenges

Singletons are **hard to test** because:
1. State persists between tests
2. Can't easily mock dependencies
3. Tests become order-dependent

```javascript
// âŒ PROBLEM: Tests interfere with each other
describe('UserService', () => {
  test('test 1', () => {
    const db = Database.getInstance();
    db.insert({ name: 'Test User 1' });
    // State persists to next test!
  });
  
  test('test 2', () => {
    const db = Database.getInstance();
    // Still has data from test 1!
    expect(db.count()).toBe(0); // FAILS!
  });
});

// âœ… SOLUTION 1: Add reset method
class Database {
  static #instance = null;
  
  static getInstance() { /* ... */ }
  
  // For testing only
  static resetInstance() {
    Database.#instance = null;
  }
}

describe('UserService', () => {
  beforeEach(() => {
    Database.resetInstance();
  });
  
  // Tests are now isolated
});

// âœ… SOLUTION 2: Dependency Injection
class UserService {
  constructor(database) {
    this.database = database; // Inject dependency
  }
  
  getUsers() {
    return this.database.query('SELECT * FROM users');
  }
}

// In production
const userService = new UserService(Database.getInstance());

// In tests
const mockDatabase = { query: jest.fn() };
const userService = new UserService(mockDatabase);
```

### Memory Leaks

Singletons persist for the lifetime of the application. Be careful with:

```javascript
// âŒ PROBLEM: Event listeners not cleaned up
class NotificationService {
  constructor() {
    window.addEventListener('online', this.handleOnline);
    window.addEventListener('offline', this.handleOffline);
  }
  // Listeners never removed!
}

// âœ… SOLUTION: Provide cleanup method
class NotificationService {
  #boundHandlers = {};
  
  constructor() {
    this.#boundHandlers.online = this.handleOnline.bind(this);
    this.#boundHandlers.offline = this.handleOffline.bind(this);
    
    window.addEventListener('online', this.#boundHandlers.online);
    window.addEventListener('offline', this.#boundHandlers.offline);
  }
  
  destroy() {
    window.removeEventListener('online', this.#boundHandlers.online);
    window.removeEventListener('offline', this.#boundHandlers.offline);
  }
}
```

### Thread Safety (Node.js Workers)

In multi-threaded environments, you need synchronization:

```javascript
// Note: In standard Node.js, this isn't usually an issue
// because Node.js is single-threaded for JS execution.
// But with Worker threads, each thread has its own instance.

// main.js
const { Worker } = require('worker_threads');

const worker1 = new Worker('./worker.js');
const worker2 = new Worker('./worker.js');

// Each worker has its OWN singleton instance!
// They don't share memory by default.

// For shared state, use:
// - SharedArrayBuffer
// - External store (Redis)
// - Message passing
```

---

## 3.5 When NOT to Use Singleton

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               SINGLETON ANTI-PATTERN WARNING                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  âŒ DON'T USE SINGLETON WHEN:                               â”‚
â”‚                                                             â”‚
â”‚  â€¢ You need multiple instances (User, Product, Order)       â”‚
â”‚  â€¢ Unit testing is important                                â”‚
â”‚  â€¢ You want to avoid global state                           â”‚
â”‚  â€¢ Dependency injection is preferred                        â”‚
â”‚  â€¢ The "singleton" might need to become "multiton"          â”‚
â”‚                                                             â”‚
â”‚  âœ… USE SINGLETON WHEN:                                     â”‚
â”‚                                                             â”‚
â”‚  â€¢ Resource is expensive to create                          â”‚
â”‚  â€¢ Exactly one instance must exist (Logger, Config)         â”‚
â”‚  â€¢ Coordinated access to shared resource is needed          â”‚
â”‚  â€¢ You understand the testing implications                  â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Better Alternative: Dependency Injection

```javascript
// Instead of Singleton
class UserController {
  constructor() {
    this.db = Database.getInstance(); // Hidden dependency
    this.logger = Logger.getInstance(); // Hidden dependency
  }
}

// Use Dependency Injection
class UserController {
  constructor(db, logger) {
    this.db = db;     // Explicit dependency
    this.logger = logger; // Explicit dependency
  }
}

// Wire up at application root (composition root)
const db = new Database();
const logger = new Logger();
const userController = new UserController(db, logger);

// Tests become easy
const mockDb = { query: jest.fn() };
const mockLogger = { info: jest.fn() };
const testController = new UserController(mockDb, mockLogger);
```

---

## Key Takeaways

1. **Singleton ensures one instance** with global access
2. **ES6 Module export** is the cleanest implementation in modern JS
3. **Use for**: Configuration, Logging, Connection pools, State stores
4. **Avoid for**: Domain objects, when testing is priority
5. **Consider DI** as an alternative for better testability
6. **Add reset methods** for testing singleton behavior
7. **Watch for memory leaks** with event listeners and subscriptions

> âš ï¸ **Anti-pattern Warning:** Overusing Singleton leads to hidden dependencies, difficult testing, and tightly coupled code. Use sparingly and consider dependency injection as the preferred alternative in production applications.

> ğŸ’¡ **Interview Tip:** Be prepared to discuss singleton drawbacks and alternatives. Showing you understand WHEN NOT to use a pattern is as valuable as knowing how to implement it.
