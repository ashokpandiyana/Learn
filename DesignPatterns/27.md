# Chapter 27: Async Patterns - In Depth Guide

## üìö Overview

Asynchronous patterns are fundamental to JavaScript development. Understanding these patterns is crucial for building responsive, efficient applications that handle I/O operations, network requests, and concurrent operations effectively.

## üîÑ Evolution of Async JavaScript

```
Callbacks ‚Üí Promises ‚Üí Async/Await ‚Üí Async Iterators
```

## 1Ô∏è‚É£ Callback Pattern

### Basic Callback Pattern

```javascript
// Error-first callback (Node.js convention)
function readFile(path, callback) {
  setTimeout(() => {
    if (!path) {
      callback(new Error('Path is required'), null);
    } else {
      callback(null, `Content of ${path}`);
    }
  }, 1000);
}

// Usage
readFile('data.txt', (err, data) => {
  if (err) {
    console.error('Error:', err.message);
    return;
  }
  console.log('Success:', data);
});
```

### Callback Hell Problem

```javascript
// ‚ùå Callback Hell (Pyramid of Doom)
getUserData(userId, (err, user) => {
  if (err) return handleError(err);
  
  getOrderHistory(user.id, (err, orders) => {
    if (err) return handleError(err);
    
    getOrderDetails(orders[0].id, (err, details) => {
      if (err) return handleError(err);
      
      processPayment(details.total, (err, payment) => {
        if (err) return handleError(err);
        
        sendConfirmation(user.email, payment, (err, result) => {
          if (err) return handleError(err);
          console.log('Done!');
        });
      });
    });
  });
});
```

### Solution: Named Functions

```javascript
// ‚úÖ Better: Named functions
function processUser(userId) {
  getUserData(userId, handleUserData);
}

function handleUserData(err, user) {
  if (err) return handleError(err);
  getOrderHistory(user.id, handleOrders);
}

function handleOrders(err, orders) {
  if (err) return handleError(err);
  getOrderDetails(orders[0].id, handleDetails);
}

// ... and so on
```

## 2Ô∏è‚É£ Promise Patterns

### Basic Promise Creation

```javascript
// Creating a promise
function fetchData(url) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (!url) {
        reject(new Error('URL is required'));
      } else {
        resolve({ data: 'Sample data', status: 200 });
      }
    }, 1000);
  });
}

// Usage
fetchData('https://api.example.com/data')
  .then(response => console.log(response))
  .catch(error => console.error(error));
```

### Promise Chaining

```javascript
// ‚úÖ Clean promise chain
getUserData(userId)
  .then(user => getOrderHistory(user.id))
  .then(orders => getOrderDetails(orders[0].id))
  .then(details => processPayment(details.total))
  .then(payment => sendConfirmation(user.email, payment))
  .then(result => console.log('Done!'))
  .catch(error => handleError(error));
```

### Promise Combinators

```javascript
// Promise.all() - Wait for all promises (parallel)
async function fetchAllUserData(userId) {
  try {
    const [user, orders, preferences] = await Promise.all([
      getUserData(userId),
      getOrderHistory(userId),
      getUserPreferences(userId)
    ]);
    
    return { user, orders, preferences };
  } catch (error) {
    console.error('One or more requests failed:', error);
    throw error;
  }
}

// Promise.allSettled() - Get all results regardless of success/failure
async function fetchWithAllSettled(urls) {
  const promises = urls.map(url => fetch(url));
  const results = await Promise.allSettled(promises);
  
  results.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      console.log(`Request ${index} succeeded:`, result.value);
    } else {
      console.log(`Request ${index} failed:`, result.reason);
    }
  });
  
  return results;
}

// Promise.race() - First settled (fulfilled or rejected)
async function fetchWithTimeout(url, timeout = 5000) {
  const fetchPromise = fetch(url);
  const timeoutPromise = new Promise((_, reject) =>
    setTimeout(() => reject(new Error('Request timeout')), timeout)
  );
  
  return Promise.race([fetchPromise, timeoutPromise]);
}

// Promise.any() - First fulfilled (ignores rejections)
async function fetchFromMirrors(urls) {
  try {
    // Returns the first successful response
    const response = await Promise.any(urls.map(url => fetch(url)));
    return response;
  } catch (error) {
    // All requests failed
    console.error('All mirrors failed:', error);
    throw error;
  }
}

// Usage examples
(async () => {
  // All must succeed
  const allData = await Promise.all([
    fetch('/api/users'),
    fetch('/api/posts'),
    fetch('/api/comments')
  ]);

  // Get results of all, even failures
  const allResults = await Promise.allSettled([
    fetch('/api/users'),
    fetch('/api/posts-that-might-fail'),
    fetch('/api/comments')
  ]);

  // First to respond wins
  const fastest = await Promise.race([
    fetch('https://api1.example.com'),
    fetch('https://api2.example.com'),
    fetch('https://api3.example.com')
  ]);

  // First successful response
  const firstSuccess = await Promise.any([
    fetch('https://mirror1.example.com'),
    fetch('https://mirror2.example.com'),
    fetch('https://mirror3.example.com')
  ]);
})();
```

### Implementing Promise from Scratch

```javascript
class MyPromise {
  constructor(executor) {
    this.state = 'pending'; // pending, fulfilled, rejected
    this.value = undefined;
    this.reason = undefined;
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];

    const resolve = (value) => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
        this.onFulfilledCallbacks.forEach(fn => fn(value));
      }
    };

    const reject = (reason) => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn => fn(reason));
      }
    };

    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }

  then(onFulfilled, onRejected) {
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
    onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason; };

    const promise2 = new MyPromise((resolve, reject) => {
      if (this.state === 'fulfilled') {
        setTimeout(() => {
          try {
            const x = onFulfilled(this.value);
            this.resolvePromise(promise2, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        }, 0);
      } else if (this.state === 'rejected') {
        setTimeout(() => {
          try {
            const x = onRejected(this.reason);
            this.resolvePromise(promise2, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        }, 0);
      } else {
        this.onFulfilledCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onFulfilled(this.value);
              this.resolvePromise(promise2, x, resolve, reject);
            } catch (error) {
              reject(error);
            }
          }, 0);
        });

        this.onRejectedCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onRejected(this.reason);
              this.resolvePromise(promise2, x, resolve, reject);
            } catch (error) {
              reject(error);
            }
          }, 0);
        });
      }
    });

    return promise2;
  }

  catch(onRejected) {
    return this.then(null, onRejected);
  }

  resolvePromise(promise2, x, resolve, reject) {
    if (promise2 === x) {
      return reject(new TypeError('Chaining cycle detected'));
    }

    if (x instanceof MyPromise) {
      x.then(resolve, reject);
    } else {
      resolve(x);
    }
  }
}

// Usage
const promise = new MyPromise((resolve, reject) => {
  setTimeout(() => resolve('Success!'), 1000);
});

promise
  .then(value => {
    console.log(value);
    return value + ' Again';
  })
  .then(value => console.log(value))
  .catch(error => console.error(error));
```

## 3Ô∏è‚É£ Async/Await Patterns

### Basic Async/Await

```javascript
// Converting promise chain to async/await
async function processUserOrder(userId, orderId) {
  try {
    const user = await getUserData(userId);
    const order = await getOrderDetails(orderId);
    const payment = await processPayment(order.total);
    const confirmation = await sendConfirmation(user.email, payment);
    
    return confirmation;
  } catch (error) {
    console.error('Error processing order:', error);
    throw error;
  }
}
```

### Sequential vs Parallel Execution

```javascript
// ‚ùå Sequential (slow) - 3 seconds total
async function fetchSequential() {
  const user = await fetch('/api/user');      // 1 second
  const posts = await fetch('/api/posts');    // 1 second
  const comments = await fetch('/api/comments'); // 1 second
  
  return { user, posts, comments };
}

// ‚úÖ Parallel (fast) - 1 second total
async function fetchParallel() {
  const [user, posts, comments] = await Promise.all([
    fetch('/api/user'),
    fetch('/api/posts'),
    fetch('/api/comments')
  ]);
  
  return { user, posts, comments };
}

// ‚ö° Hybrid approach - some sequential, some parallel
async function fetchHybrid(userId) {
  // First get the user (must be sequential)
  const user = await fetch(`/api/users/${userId}`);
  const userData = await user.json();
  
  // Then fetch related data in parallel
  const [posts, comments, friends] = await Promise.all([
    fetch(`/api/users/${userId}/posts`),
    fetch(`/api/users/${userId}/comments`),
    fetch(`/api/users/${userId}/friends`)
  ]);
  
  return {
    user: userData,
    posts: await posts.json(),
    comments: await comments.json(),
    friends: await friends.json()
  };
}
```

## 4Ô∏è‚É£ Advanced Async Patterns

### Retry Pattern with Exponential Backoff

```javascript
async function retry(
  fn,
  options = {
    retries: 3,
    delay: 1000,
    backoff: 2,
    onRetry: null
  }
) {
  const { retries, delay, backoff, onRetry } = options;
  
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === retries) {
        throw error;
      }
      
      const waitTime = delay * Math.pow(backoff, attempt);
      
      if (onRetry) {
        onRetry(attempt + 1, retries, waitTime, error);
      }
      
      console.log(`Attempt ${attempt + 1} failed. Retrying in ${waitTime}ms...`);
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
  }
}

// Usage
async function fetchWithRetry(url) {
  return retry(
    () => fetch(url).then(res => {
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }),
    {
      retries: 3,
      delay: 1000,
      backoff: 2,
      onRetry: (attempt, max, wait, error) => {
        console.log(`Retry ${attempt}/${max} after ${wait}ms due to:`, error.message);
      }
    }
  );
}
```

### Timeout Pattern

```javascript
function withTimeout(promise, timeoutMs) {
  return Promise.race([
    promise,
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error(`Timeout after ${timeoutMs}ms`)), timeoutMs)
    )
  ]);
}

// Usage
async function fetchWithTimeout(url, timeout = 5000) {
  try {
    const response = await withTimeout(fetch(url), timeout);
    return await response.json();
  } catch (error) {
    if (error.message.includes('Timeout')) {
      console.error('Request timed out');
    }
    throw error;
  }
}

// Advanced timeout with abort
async function fetchWithAbort(url, timeout = 5000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  try {
    const response = await fetch(url, { signal: controller.signal });
    clearTimeout(timeoutId);
    return await response.json();
  } catch (error) {
    clearTimeout(timeoutId);
    if (error.name === 'AbortError') {
      throw new Error(`Request timeout after ${timeout}ms`);
    }
    throw error;
  }
}
```

### Debounce and Throttle (Async versions)

```javascript
// Debounce - Wait for silence
function debounce(func, wait) {
  let timeout;
  
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// Async debounce with promise
function asyncDebounce(func, wait) {
  let timeout;
  let resolveList = [];
  
  return function(...args) {
    return new Promise((resolve, reject) => {
      clearTimeout(timeout);
      resolveList.push({ resolve, reject });
      
      timeout = setTimeout(async () => {
        const currentResolveList = resolveList;
        resolveList = [];
        
        try {
          const result = await func(...args);
          currentResolveList.forEach(({ resolve }) => resolve(result));
        } catch (error) {
          currentResolveList.forEach(({ reject }) => reject(error));
        }
      }, wait);
    });
  };
}

// Throttle - Execute at most once per interval
function throttle(func, limit) {
  let inThrottle;
  let lastResult;
  
  return function(...args) {
    if (!inThrottle) {
      lastResult = func(...args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
    return lastResult;
  };
}

// Usage examples
const debouncedSearch = asyncDebounce(async (query) => {
  const response = await fetch(`/api/search?q=${query}`);
  return response.json();
}, 300);

const throttledScroll = throttle((event) => {
  console.log('Scroll position:', window.scrollY);
}, 100);

// In a search input handler
inputElement.addEventListener('input', async (e) => {
  try {
    const results = await debouncedSearch(e.target.value);
    displayResults(results);
  } catch (error) {
    console.error('Search failed:', error);
  }
});
```

### Queue Pattern

```javascript
class AsyncQueue {
  constructor(concurrency = 1) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }

  async add(fn) {
    return new Promise((resolve, reject) => {
      this.queue.push({ fn, resolve, reject });
      this.process();
    });
  }

  async process() {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }

    this.running++;
    const { fn, resolve, reject } = this.queue.shift();

    try {
      const result = await fn();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.process();
    }
  }

  async drain() {
    return new Promise(resolve => {
      const check = () => {
        if (this.running === 0 && this.queue.length === 0) {
          resolve();
        } else {
          setTimeout(check, 10);
        }
      };
      check();
    });
  }

  size() {
    return this.queue.length;
  }
}

// Usage
const queue = new AsyncQueue(3); // Max 3 concurrent operations

// Add tasks to queue
const tasks = Array.from({ length: 10 }, (_, i) => 
  () => fetch(`/api/data/${i}`).then(r => r.json())
);

tasks.forEach(task => {
  queue.add(task)
    .then(result => console.log('Task completed:', result))
    .catch(error => console.error('Task failed:', error));
});

// Wait for all tasks to complete
await queue.drain();
console.log('All tasks completed');
```

### Circuit Breaker Pattern

```javascript
class CircuitBreaker {
  constructor(request, options = {}) {
    this.request = request;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.failureCount = 0;
    this.successCount = 0;
    this.nextAttempt = Date.now();
    
    this.failureThreshold = options.failureThreshold || 5;
    this.successThreshold = options.successThreshold || 2;
    this.timeout = options.timeout || 60000; // 1 minute
  }

  async call(...args) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      this.state = 'HALF_OPEN';
    }

    try {
      const result = await this.request(...args);
      return this.onSuccess(result);
    } catch (error) {
      return this.onFailure(error);
    }
  }

  onSuccess(result) {
    this.failureCount = 0;

    if (this.state === 'HALF_OPEN') {
      this.successCount++;
      if (this.successCount >= this.successThreshold) {
        this.state = 'CLOSED';
        this.successCount = 0;
      }
    }

    return result;
  }

  onFailure(error) {
    this.failureCount++;
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.timeout;
    }

    throw error;
  }

  getState() {
    return this.state;
  }
}

// Usage
const apiCall = async (id) => {
  const response = await fetch(`/api/data/${id}`);
  if (!response.ok) throw new Error(`HTTP ${response.status}`);
  return response.json();
};

const breaker = new CircuitBreaker(apiCall, {
  failureThreshold: 3,
  successThreshold: 2,
  timeout: 5000
});

// Use the circuit breaker
for (let i = 0; i < 10; i++) {
  try {
    const result = await breaker.call(i);
    console.log('Success:', result);
  } catch (error) {
    console.error(`Failed (Circuit: ${breaker.getState()}):`, error.message);
  }
}
```

### Bulkhead Pattern

```javascript
class Bulkhead {
  constructor(maxConcurrent) {
    this.maxConcurrent = maxConcurrent;
    this.currentlyRunning = 0;
    this.queue = [];
  }

  async execute(fn) {
    if (this.currentlyRunning < this.maxConcurrent) {
      return this.run(fn);
    }

    // Wait in queue
    return new Promise((resolve, reject) => {
      this.queue.push({ fn, resolve, reject });
    });
  }

  async run(fn) {
    this.currentlyRunning++;
    
    try {
      const result = await fn();
      return result;
    } finally {
      this.currentlyRunning--;
      this.processQueue();
    }
  }

  processQueue() {
    if (this.queue.length > 0 && this.currentlyRunning < this.maxConcurrent) {
      const { fn, resolve, reject } = this.queue.shift();
      this.run(fn).then(resolve).catch(reject);
    }
  }

  getStats() {
    return {
      running: this.currentlyRunning,
      queued: this.queue.length,
      available: this.maxConcurrent - this.currentlyRunning
    };
  }
}

// Usage - Separate bulkheads for different resources
const dbBulkhead = new Bulkhead(5);
const apiBulkhead = new Bulkhead(3);

// Database operations
async function dbQuery(query) {
  return dbBulkhead.execute(async () => {
    // Simulate DB query
    await new Promise(resolve => setTimeout(resolve, 100));
    return { query, result: 'data' };
  });
}

// API calls
async function apiCall(endpoint) {
  return apiBulkhead.execute(async () => {
    // Simulate API call
    await new Promise(resolve => setTimeout(resolve, 200));
    return { endpoint, data: 'response' };
  });
}
```

## 5Ô∏è‚É£ Async Iterators and Generators

### Basic Async Generator

```javascript
async function* fetchPages(url, maxPages) {
  let page = 1;
  
  while (page <= maxPages) {
    const response = await fetch(`${url}?page=${page}`);
    const data = await response.json();
    yield data;
    page++;
  }
}

// Usage
(async () => {
  for await (const page of fetchPages('/api/data', 5)) {
    console.log('Page data:', page);
  }
})();
```

### Stream Processing with Async Iterators

```javascript
// Async iterator for streaming data
class DataStream {
  constructor(source) {
    this.source = source;
  }

  async *[Symbol.asyncIterator]() {
    for (let i = 0; i < this.source.length; i++) {
      // Simulate async fetch
      await new Promise(resolve => setTimeout(resolve, 100));
      yield this.source[i];
    }
  }

  // Transform stream
  map(fn) {
    const self = this;
    return {
      async *[Symbol.asyncIterator]() {
        for await (const item of self) {
          yield fn(item);
        }
      }
    };
  }

  // Filter stream
  filter(predicate) {
    const self = this;
    return {
      async *[Symbol.asyncIterator]() {
        for await (const item of self) {
          if (predicate(item)) {
            yield item;
          }
        }
      }
    };
  }

  // Take first n items
  take(n) {
    const self = this;
    return {
      async *[Symbol.asyncIterator]() {
        let count = 0;
        for await (const item of self) {
          if (count++ >= n) break;
          yield item;
        }
      }
    };
  }
}

// Usage
const stream = new DataStream([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

const processed = stream
  .filter(n => n % 2 === 0)
  .map(n => n * 2)
  .take(3);

for await (const value of processed) {
  console.log(value); // 4, 8, 12
}
```

## üìä Performance Comparison

```javascript
// Benchmark different async patterns
async function benchmark() {
  const urls = Array.from({ length: 10 }, (_, i) => `/api/data/${i}`);

  // Sequential
  console.time('Sequential');
  for (const url of urls) {
    await fetch(url);
  }
  console.timeEnd('Sequential'); // ~10 seconds

  // Parallel (Promise.all)
  console.time('Parallel');
  await Promise.all(urls.map(url => fetch(url)));
  console.timeEnd('Parallel'); // ~1 second

  // Concurrent with limit
  console.time('Concurrent');
  const queue = new AsyncQueue(3);
  await Promise.all(urls.map(url => queue.add(() => fetch(url))));
  console.timeEnd('Concurrent'); // ~3-4 seconds
}
```

## üéØ Best Practices

1. **Always handle errors** with try/catch or .catch()
2. **Use Promise.all()** for parallel operations
3. **Avoid unnecessary await** - don't await if you don't need the result immediately
4. **Use async/await** over raw promises for readability
5. **Implement timeouts** for network requests
6. **Add retry logic** for transient failures
7. **Use circuit breakers** for external services
8. **Consider backpressure** when processing streams
9. **Clean up resources** (AbortController, timeouts)
10. **Test async code** thoroughly with proper mocking

## üö´ Common Mistakes

1. **Forgetting to await** async functions
2. **Sequential when parallel** is possible
3. **Not handling promise rejections**
4. **Mixing callbacks and promises**
5. **Creating promises in loops** unnecessarily
6. **Swallowing errors** silently
7. **Not setting timeouts** for network requests
8. **Memory leaks** from abandoned promises

## üìù Summary

Async patterns are essential for modern JavaScript development. Master callbacks, promises, and async/await, then progress to advanced patterns like retry logic, circuit breakers, and async iterators. Always prioritize error handling, consider performance implications, and choose the right pattern for your use case.