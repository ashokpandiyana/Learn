# Chapter 19: Command Pattern

## 19.1 Concept

### What is the Command Pattern?

The Command Pattern **encapsulates a request as an object**, allowing you to parameterize clients with different requests, queue or log requests, and support undoable operations.

Think of it like ordering at a restaurant: your order (command) is written down, passed to the kitchen (receiver), and can be tracked, modified, or cancelled.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COMMAND PATTERN                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚   â”‚  Client  â”‚â”€â”€â”€â”€â–ºâ”‚  Invoker â”‚â”€â”€â”€â”€â–ºâ”‚ Command  â”‚            â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                          â”‚                  â”‚
â”‚   Creates          Calls                 â”‚ execute()        â”‚
â”‚   commands         execute()             â”‚ undo()           â”‚
â”‚                                          â–¼                  â”‚
â”‚                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚                                    â”‚ Receiver â”‚             â”‚
â”‚                                    â”‚ (actual  â”‚             â”‚
â”‚                                    â”‚  work)   â”‚             â”‚
â”‚                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                             â”‚
â”‚   COMMAND = request as object                               â”‚
â”‚   â€¢ Can be queued                                           â”‚
â”‚   â€¢ Can be logged                                           â”‚
â”‚   â€¢ Can be undone                                           â”‚
â”‚   â€¢ Can be composed (macros)                                â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Components

| Component | Role | Example |
|-----------|------|---------|
| **Command** | Declares execution interface | `execute()`, `undo()` |
| **Concrete Command** | Implements specific action | `CopyCommand`, `PasteCommand` |
| **Invoker** | Asks command to execute | Button, MenuItem, Shortcut |
| **Receiver** | Knows how to perform action | Document, Editor, Service |
| **Client** | Creates commands and sets receivers | Application |

---

## 19.2 Implementation

### Text Editor with Undo/Redo

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMMAND INTERFACE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Command {
  execute() {
    throw new Error('Must implement execute()');
  }
  
  undo() {
    throw new Error('Must implement undo()');
  }
  
  // Optional: description for history display
  getDescription() {
    return 'Unknown command';
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RECEIVER: Text Editor
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class TextEditor {
  constructor() {
    this.content = '';
    this.clipboard = '';
    this.selectionStart = 0;
    this.selectionEnd = 0;
    this.cursorPosition = 0;
  }
  
  // Basic operations
  insertText(text, position = this.cursorPosition) {
    this.content = 
      this.content.slice(0, position) + 
      text + 
      this.content.slice(position);
    this.cursorPosition = position + text.length;
    console.log(`[Editor] Inserted "${text}" at position ${position}`);
  }
  
  deleteText(start, length) {
    const deleted = this.content.slice(start, start + length);
    this.content = 
      this.content.slice(0, start) + 
      this.content.slice(start + length);
    this.cursorPosition = start;
    console.log(`[Editor] Deleted "${deleted}"`);
    return deleted;
  }
  
  replaceText(start, length, newText) {
    const deleted = this.deleteText(start, length);
    this.insertText(newText, start);
    return deleted;
  }
  
  // Selection operations
  setSelection(start, end) {
    this.selectionStart = start;
    this.selectionEnd = end;
    console.log(`[Editor] Selection: ${start}-${end}`);
  }
  
  getSelectedText() {
    return this.content.slice(this.selectionStart, this.selectionEnd);
  }
  
  hasSelection() {
    return this.selectionStart !== this.selectionEnd;
  }
  
  // Clipboard operations
  copyToClipboard(text) {
    this.clipboard = text;
    console.log(`[Editor] Copied to clipboard: "${text}"`);
  }
  
  getClipboard() {
    return this.clipboard;
  }
  
  // Display
  display() {
    console.log(`\n[Editor Content]: "${this.content}"`);
    console.log(`[Cursor Position]: ${this.cursorPosition}`);
    if (this.hasSelection()) {
      console.log(`[Selection]: "${this.getSelectedText()}"`);
    }
    console.log('');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONCRETE COMMANDS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class InsertTextCommand extends Command {
  constructor(editor, text, position) {
    super();
    this.editor = editor;
    this.text = text;
    this.position = position ?? editor.cursorPosition;
  }
  
  execute() {
    this.editor.insertText(this.text, this.position);
  }
  
  undo() {
    this.editor.deleteText(this.position, this.text.length);
  }
  
  getDescription() {
    return `Insert "${this.text.slice(0, 20)}${this.text.length > 20 ? '...' : ''}"`;
  }
}

class DeleteTextCommand extends Command {
  constructor(editor, start, length) {
    super();
    this.editor = editor;
    this.start = start;
    this.length = length;
    this.deletedText = '';
  }
  
  execute() {
    this.deletedText = this.editor.deleteText(this.start, this.length);
  }
  
  undo() {
    this.editor.insertText(this.deletedText, this.start);
  }
  
  getDescription() {
    return `Delete "${this.deletedText.slice(0, 20)}${this.deletedText.length > 20 ? '...' : ''}"`;
  }
}

class ReplaceTextCommand extends Command {
  constructor(editor, start, length, newText) {
    super();
    this.editor = editor;
    this.start = start;
    this.length = length;
    this.newText = newText;
    this.oldText = '';
  }
  
  execute() {
    this.oldText = this.editor.replaceText(this.start, this.length, this.newText);
  }
  
  undo() {
    this.editor.replaceText(this.start, this.newText.length, this.oldText);
  }
  
  getDescription() {
    return `Replace "${this.oldText}" with "${this.newText}"`;
  }
}

class CutCommand extends Command {
  constructor(editor) {
    super();
    this.editor = editor;
    this.cutText = '';
    this.cutPosition = 0;
  }
  
  execute() {
    if (this.editor.hasSelection()) {
      this.cutPosition = this.editor.selectionStart;
      this.cutText = this.editor.getSelectedText();
      this.editor.copyToClipboard(this.cutText);
      this.editor.deleteText(
        this.editor.selectionStart,
        this.editor.selectionEnd - this.editor.selectionStart
      );
    }
  }
  
  undo() {
    this.editor.insertText(this.cutText, this.cutPosition);
    this.editor.setSelection(this.cutPosition, this.cutPosition + this.cutText.length);
  }
  
  getDescription() {
    return `Cut "${this.cutText.slice(0, 20)}..."`;
  }
}

class CopyCommand extends Command {
  constructor(editor) {
    super();
    this.editor = editor;
    this.previousClipboard = '';
  }
  
  execute() {
    this.previousClipboard = this.editor.getClipboard();
    if (this.editor.hasSelection()) {
      this.editor.copyToClipboard(this.editor.getSelectedText());
    }
  }
  
  undo() {
    // Restore previous clipboard content
    this.editor.copyToClipboard(this.previousClipboard);
  }
  
  getDescription() {
    return 'Copy';
  }
}

class PasteCommand extends Command {
  constructor(editor) {
    super();
    this.editor = editor;
    this.pastedText = '';
    this.pastePosition = 0;
  }
  
  execute() {
    this.pastePosition = this.editor.cursorPosition;
    this.pastedText = this.editor.getClipboard();
    this.editor.insertText(this.pastedText, this.pastePosition);
  }
  
  undo() {
    this.editor.deleteText(this.pastePosition, this.pastedText.length);
  }
  
  getDescription() {
    return `Paste "${this.pastedText.slice(0, 20)}..."`;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INVOKER: Command Manager with History
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class CommandManager {
  constructor() {
    this.history = [];
    this.redoStack = [];
    this.maxHistory = 100;
  }
  
  execute(command) {
    command.execute();
    this.history.push(command);
    this.redoStack = []; // Clear redo stack on new action
    
    // Limit history size
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    }
    
    console.log(`[CommandManager] Executed: ${command.getDescription()}`);
  }
  
  undo() {
    if (this.history.length === 0) {
      console.log('[CommandManager] Nothing to undo');
      return false;
    }
    
    const command = this.history.pop();
    command.undo();
    this.redoStack.push(command);
    
    console.log(`[CommandManager] Undid: ${command.getDescription()}`);
    return true;
  }
  
  redo() {
    if (this.redoStack.length === 0) {
      console.log('[CommandManager] Nothing to redo');
      return false;
    }
    
    const command = this.redoStack.pop();
    command.execute();
    this.history.push(command);
    
    console.log(`[CommandManager] Redid: ${command.getDescription()}`);
    return true;
  }
  
  canUndo() {
    return this.history.length > 0;
  }
  
  canRedo() {
    return this.redoStack.length > 0;
  }
  
  getHistory() {
    return this.history.map(cmd => cmd.getDescription());
  }
  
  clear() {
    this.history = [];
    this.redoStack = [];
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USAGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const editor = new TextEditor();
const commandManager = new CommandManager();

console.log('=== Text Editor Demo ===\n');

// Type some text
commandManager.execute(new InsertTextCommand(editor, 'Hello World!'));
editor.display();

// Insert more text
commandManager.execute(new InsertTextCommand(editor, ' This is a test.'));
editor.display();

// Select and copy
editor.setSelection(0, 5);
commandManager.execute(new CopyCommand(editor));

// Paste at end
editor.cursorPosition = editor.content.length;
commandManager.execute(new PasteCommand(editor));
editor.display();

// Replace text
commandManager.execute(new ReplaceTextCommand(editor, 6, 5, 'JavaScript'));
editor.display();

// Show history
console.log('=== Command History ===');
console.log(commandManager.getHistory());

// Undo multiple times
console.log('\n=== Undoing ===');
commandManager.undo();
editor.display();

commandManager.undo();
editor.display();

// Redo
console.log('=== Redoing ===');
commandManager.redo();
editor.display();
```

### Macro Commands (Composite)

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MACRO COMMAND: Executes multiple commands as one
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class MacroCommand extends Command {
  constructor(name) {
    super();
    this.name = name;
    this.commands = [];
  }
  
  add(command) {
    this.commands.push(command);
    return this; // Allow chaining
  }
  
  execute() {
    console.log(`[Macro] Executing "${this.name}" (${this.commands.length} commands)`);
    this.commands.forEach(command => command.execute());
  }
  
  undo() {
    console.log(`[Macro] Undoing "${this.name}"`);
    // Undo in reverse order
    [...this.commands].reverse().forEach(command => command.undo());
  }
  
  getDescription() {
    return `Macro: ${this.name}`;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USAGE: Recording and Playing Macros
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MacroRecorder {
  constructor(commandManager) {
    this.commandManager = commandManager;
    this.recording = null;
    this.isRecording = false;
  }
  
  startRecording(name) {
    this.recording = new MacroCommand(name);
    this.isRecording = true;
    console.log(`[MacroRecorder] Started recording: ${name}`);
  }
  
  stopRecording() {
    this.isRecording = false;
    const macro = this.recording;
    this.recording = null;
    console.log(`[MacroRecorder] Stopped recording: ${macro.name}`);
    return macro;
  }
  
  recordCommand(command) {
    if (this.isRecording) {
      this.recording.add(command);
    }
    this.commandManager.execute(command);
  }
}

// Demo with macros
const editor2 = new TextEditor();
const commandManager2 = new CommandManager();
const macroRecorder = new MacroRecorder(commandManager2);

console.log('\n=== Macro Recording Demo ===\n');

// Start recording
macroRecorder.startRecording('WrapInParentheses');

// Record actions
macroRecorder.recordCommand(new InsertTextCommand(editor2, '(', 0));
macroRecorder.recordCommand(new InsertTextCommand(editor2, ')'));

// Stop recording
const wrapMacro = macroRecorder.stopRecording();

// Reset editor
editor2.content = 'hello world';
editor2.cursorPosition = editor2.content.length;

console.log('\nBefore macro:');
editor2.display();

// Execute macro (wraps content in parentheses)
commandManager2.execute(wrapMacro);

console.log('After macro:');
editor2.display();

// Undo entire macro with single undo
commandManager2.undo();
console.log('After undo:');
editor2.display();
```

---

## 19.3 Job Queue Implementation

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMMAND-BASED JOB QUEUE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Job extends Command {
  constructor(name, payload) {
    super();
    this.id = 'job_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
    this.name = name;
    this.payload = payload;
    this.status = 'pending';
    this.result = null;
    this.error = null;
    this.attempts = 0;
    this.maxAttempts = 3;
    this.createdAt = new Date();
    this.startedAt = null;
    this.completedAt = null;
  }
  
  async execute() {
    this.status = 'running';
    this.startedAt = new Date();
    this.attempts++;
    
    try {
      console.log(`[Job ${this.id}] Executing "${this.name}" (attempt ${this.attempts})`);
      this.result = await this.run(this.payload);
      this.status = 'completed';
      this.completedAt = new Date();
      console.log(`[Job ${this.id}] Completed successfully`);
      return this.result;
    } catch (error) {
      this.error = error;
      if (this.attempts < this.maxAttempts) {
        this.status = 'pending'; // Will be retried
        console.log(`[Job ${this.id}] Failed, will retry`);
      } else {
        this.status = 'failed';
        console.log(`[Job ${this.id}] Failed permanently`);
      }
      throw error;
    }
  }
  
  // Override in subclasses
  async run(payload) {
    throw new Error('Must implement run()');
  }
  
  undo() {
    // Jobs typically don't support undo
    console.log(`[Job ${this.id}] Undo not supported`);
  }
  
  getDescription() {
    return `${this.name} (${this.status})`;
  }
  
  toJSON() {
    return {
      id: this.id,
      name: this.name,
      status: this.status,
      attempts: this.attempts,
      createdAt: this.createdAt,
      completedAt: this.completedAt
    };
  }
}

// Concrete Jobs
class SendEmailJob extends Job {
  constructor(payload) {
    super('SendEmail', payload);
  }
  
  async run({ to, subject, body }) {
    // Simulate email sending
    await new Promise(r => setTimeout(r, 500));
    
    // Simulate occasional failures
    if (Math.random() < 0.2) {
      throw new Error('Email server unavailable');
    }
    
    console.log(`  ğŸ“§ Email sent to ${to}: "${subject}"`);
    return { delivered: true, to };
  }
}

class ProcessImageJob extends Job {
  constructor(payload) {
    super('ProcessImage', payload);
  }
  
  async run({ imageUrl, operations }) {
    console.log(`  ğŸ–¼ï¸ Processing image: ${imageUrl}`);
    
    for (const op of operations) {
      await new Promise(r => setTimeout(r, 200));
      console.log(`    Applied: ${op}`);
    }
    
    return { processed: true, url: `processed_${imageUrl}` };
  }
}

class GenerateReportJob extends Job {
  constructor(payload) {
    super('GenerateReport', payload);
    this.maxAttempts = 1; // Reports shouldn't retry
  }
  
  async run({ reportType, dateRange }) {
    console.log(`  ğŸ“Š Generating ${reportType} report for ${dateRange}`);
    await new Promise(r => setTimeout(r, 1000));
    return { 
      reportType,
      generatedAt: new Date(),
      downloadUrl: `/reports/${reportType}_${Date.now()}.pdf`
    };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JOB QUEUE MANAGER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class JobQueue {
  constructor(options = {}) {
    this.queue = [];
    this.running = [];
    this.completed = [];
    this.failed = [];
    this.concurrency = options.concurrency || 2;
    this.processing = false;
    this.paused = false;
  }
  
  enqueue(job) {
    this.queue.push(job);
    console.log(`[Queue] Job ${job.id} enqueued. Queue size: ${this.queue.length}`);
    this.#process();
    return job.id;
  }
  
  async #process() {
    if (this.processing || this.paused) return;
    this.processing = true;
    
    while (this.queue.length > 0 && this.running.length < this.concurrency) {
      const job = this.queue.shift();
      this.running.push(job);
      
      this.#executeJob(job).finally(() => {
        this.running = this.running.filter(j => j !== job);
        this.#process();
      });
    }
    
    this.processing = false;
  }
  
  async #executeJob(job) {
    try {
      await job.execute();
      this.completed.push(job);
    } catch (error) {
      if (job.status === 'pending') {
        // Retry
        this.queue.unshift(job);
      } else {
        this.failed.push(job);
      }
    }
  }
  
  pause() {
    this.paused = true;
    console.log('[Queue] Paused');
  }
  
  resume() {
    this.paused = false;
    console.log('[Queue] Resumed');
    this.#process();
  }
  
  getStatus() {
    return {
      queued: this.queue.length,
      running: this.running.length,
      completed: this.completed.length,
      failed: this.failed.length
    };
  }
  
  getJob(jobId) {
    const all = [...this.queue, ...this.running, ...this.completed, ...this.failed];
    return all.find(j => j.id === jobId);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USAGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const jobQueue = new JobQueue({ concurrency: 2 });

console.log('\n=== Job Queue Demo ===\n');

// Enqueue various jobs
jobQueue.enqueue(new SendEmailJob({
  to: 'user1@example.com',
  subject: 'Welcome!',
  body: 'Welcome to our service!'
}));

jobQueue.enqueue(new SendEmailJob({
  to: 'user2@example.com',
  subject: 'Order Confirmation',
  body: 'Your order has been confirmed.'
}));

jobQueue.enqueue(new ProcessImageJob({
  imageUrl: 'photo.jpg',
  operations: ['resize', 'compress', 'watermark']
}));

jobQueue.enqueue(new GenerateReportJob({
  reportType: 'sales',
  dateRange: '2024-Q1'
}));

// Check status periodically
setTimeout(() => {
  console.log('\n=== Queue Status ===');
  console.log(jobQueue.getStatus());
}, 3000);
```

---

## 19.4 Transaction Pattern

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRANSACTIONAL COMMAND MANAGER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Transaction {
  constructor() {
    this.commands = [];
    this.executedCommands = [];
    this.status = 'pending'; // pending, committed, rolledback
  }
  
  add(command) {
    if (this.status !== 'pending') {
      throw new Error('Cannot add commands to a completed transaction');
    }
    this.commands.push(command);
    return this;
  }
  
  async commit() {
    console.log(`[Transaction] Committing ${this.commands.length} commands...`);
    
    try {
      for (const command of this.commands) {
        await command.execute();
        this.executedCommands.push(command);
      }
      this.status = 'committed';
      console.log('[Transaction] Committed successfully');
      return true;
    } catch (error) {
      console.error('[Transaction] Error during commit:', error.message);
      await this.rollback();
      return false;
    }
  }
  
  async rollback() {
    console.log(`[Transaction] Rolling back ${this.executedCommands.length} commands...`);
    
    // Undo in reverse order
    for (let i = this.executedCommands.length - 1; i >= 0; i--) {
      try {
        await this.executedCommands[i].undo();
      } catch (error) {
        console.error(`[Transaction] Error during rollback:`, error.message);
      }
    }
    
    this.status = 'rolledback';
    console.log('[Transaction] Rolled back');
  }
}

// Example: Bank Transfer Transaction
class BankAccount {
  constructor(id, balance) {
    this.id = id;
    this.balance = balance;
  }
  
  withdraw(amount) {
    if (amount > this.balance) {
      throw new Error(`Insufficient funds in account ${this.id}`);
    }
    this.balance -= amount;
    console.log(`  Account ${this.id}: Withdrew $${amount}, Balance: $${this.balance}`);
  }
  
  deposit(amount) {
    this.balance += amount;
    console.log(`  Account ${this.id}: Deposited $${amount}, Balance: $${this.balance}`);
  }
}

class WithdrawCommand extends Command {
  constructor(account, amount) {
    super();
    this.account = account;
    this.amount = amount;
  }
  
  execute() {
    this.account.withdraw(this.amount);
  }
  
  undo() {
    this.account.deposit(this.amount);
  }
}

class DepositCommand extends Command {
  constructor(account, amount) {
    super();
    this.account = account;
    this.amount = amount;
  }
  
  execute() {
    this.account.deposit(this.amount);
  }
  
  undo() {
    this.account.withdraw(this.amount);
  }
}

// Usage: Transfer money between accounts
async function transferMoney(from, to, amount) {
  console.log(`\nTransferring $${amount} from Account ${from.id} to Account ${to.id}`);
  
  const transaction = new Transaction();
  transaction
    .add(new WithdrawCommand(from, amount))
    .add(new DepositCommand(to, amount));
  
  return transaction.commit();
}

// Demo
const account1 = new BankAccount('A001', 1000);
const account2 = new BankAccount('A002', 500);

console.log('\n=== Bank Transfer Demo ===');
console.log(`Initial - Account A001: $${account1.balance}, Account A002: $${account2.balance}`);

// Successful transfer
await transferMoney(account1, account2, 200);
console.log(`After transfer - Account A001: $${account1.balance}, Account A002: $${account2.balance}`);

// Failed transfer (insufficient funds)
await transferMoney(account1, account2, 5000);
console.log(`After failed transfer - Account A001: $${account1.balance}, Account A002: $${account2.balance}`);
```

---

## Key Takeaways

1. **Command = Request as Object** - Encapsulates all info for an action
2. **Undo/Redo** - Store inverse operation in command
3. **Queuing** - Commands can be queued for later execution
4. **Logging** - Easy to log all operations
5. **Macros** - Compose multiple commands into one
6. **Transactions** - Execute all or rollback on failure

> ğŸ’¡ **Interview Tip:** Be able to implement undo/redo from scratch. Show how Command pattern enables queuing and logging.

> ğŸ­ **Production Note:** Command pattern is used in Redux (actions), task queues, and any system needing undo functionality.
