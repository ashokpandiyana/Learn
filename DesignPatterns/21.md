# Chapter 21: State Pattern - In-Depth Guide

## ðŸŽ¯ Core Concept

The **State Pattern** allows an object to alter its behavior when its internal state changes. The object will appear to change its class. This pattern encapsulates state-specific behavior and delegates behavior to the current state object.

### Visual Representation

```
Context (OrderContext)
    â”‚
    â”œâ”€â”€â”€ currentState: State
    â”‚
    â””â”€â”€â”€ Methods delegate to state
             â”‚
             â”œâ”€â”€> PendingState
             â”œâ”€â”€> PaidState
             â”œâ”€â”€> ShippedState
             â””â”€â”€> DeliveredState
```

## ðŸ”‘ Key Components

1. **Context**: Maintains an instance of a State subclass that defines the current state
2. **State Interface**: Defines interface for encapsulating behavior associated with a particular state
3. **Concrete States**: Each implements behavior associated with a state of the Context

## ðŸ“Š State vs Strategy Pattern

| Aspect | State Pattern | Strategy Pattern |
|--------|---------------|------------------|
| **Context Awareness** | States know about other states | Strategies are independent |
| **Transition Logic** | State changes itself | Client changes strategy |
| **Purpose** | Behavior based on internal state | Algorithm selection |
| **Coupling** | States may be tightly coupled | Strategies are loosely coupled |
| **Number of Classes** | Often many state classes | Usually fewer strategy classes |

## ðŸ’» Implementation Approaches

### 1. Classic State Pattern with Classes

```javascript
// State Interface (implicit in JavaScript)
class OrderState {
  cancel(order) { throw new Error('Method must be implemented'); }
  ship(order) { throw new Error('Method must be implemented'); }
  deliver(order) { throw new Error('Method must be implemented'); }
  getStatus() { throw new Error('Method must be implemented'); }
}

// Concrete States
class PendingState extends OrderState {
  cancel(order) {
    console.log('Order cancelled');
    order.setState(new CancelledState());
    return true;
  }
  
  ship(order) {
    console.log('Cannot ship: Payment not received');
    return false;
  }
  
  deliver(order) {
    console.log('Cannot deliver: Order not paid');
    return false;
  }
  
  getStatus() {
    return 'Pending Payment';
  }
}

class PaidState extends OrderState {
  cancel(order) {
    console.log('Refunding payment...');
    order.setState(new CancelledState());
    return true;
  }
  
  ship(order) {
    console.log('Order shipped!');
    order.setState(new ShippedState());
    return true;
  }
  
  deliver(order) {
    console.log('Cannot deliver: Order not shipped yet');
    return false;
  }
  
  getStatus() {
    return 'Paid - Ready to Ship';
  }
}

class ShippedState extends OrderState {
  cancel(order) {
    console.log('Cannot cancel: Order already shipped');
    return false;
  }
  
  ship(order) {
    console.log('Already shipped');
    return false;
  }
  
  deliver(order) {
    console.log('Order delivered successfully!');
    order.setState(new DeliveredState());
    return true;
  }
  
  getStatus() {
    return 'Shipped - In Transit';
  }
}

class DeliveredState extends OrderState {
  cancel(order) {
    console.log('Cannot cancel: Order already delivered');
    return false;
  }
  
  ship(order) {
    console.log('Already delivered');
    return false;
  }
  
  deliver(order) {
    console.log('Already delivered');
    return false;
  }
  
  getStatus() {
    return 'Delivered';
  }
}

class CancelledState extends OrderState {
  cancel(order) {
    console.log('Already cancelled');
    return false;
  }
  
  ship(order) {
    console.log('Cannot ship: Order cancelled');
    return false;
  }
  
  deliver(order) {
    console.log('Cannot deliver: Order cancelled');
    return false;
  }
  
  getStatus() {
    return 'Cancelled';
  }
}

// Context
class Order {
  constructor(orderId) {
    this.orderId = orderId;
    this.state = new PendingState();
    this.history = [{ state: 'Pending', timestamp: new Date() }];
  }
  
  setState(state) {
    this.state = state;
    this.history.push({ 
      state: state.getStatus(), 
      timestamp: new Date() 
    });
  }
  
  cancel() {
    return this.state.cancel(this);
  }
  
  ship() {
    return this.state.ship(this);
  }
  
  deliver() {
    return this.state.deliver(this);
  }
  
  getStatus() {
    return this.state.getStatus();
  }
  
  getHistory() {
    return this.history;
  }
}

// Usage
const order = new Order('ORD-12345');
console.log(order.getStatus()); // "Pending Payment"

order.ship(); // "Cannot ship: Payment not received"
order.setState(new PaidState()); // Simulate payment
order.ship(); // "Order shipped!"
order.deliver(); // "Order delivered successfully!"

console.log(order.getHistory());
/*
[
  { state: 'Pending', timestamp: ... },
  { state: 'Paid - Ready to Ship', timestamp: ... },
  { state: 'Shipped - In Transit', timestamp: ... },
  { state: 'Delivered', timestamp: ... }
]
*/
```

### 2. State Pattern with State Machine Object

```javascript
class StateMachine {
  constructor(initialState, states) {
    this.currentState = initialState;
    this.states = states;
  }
  
  transition(action) {
    const state = this.states[this.currentState];
    if (!state) {
      throw new Error(`Unknown state: ${this.currentState}`);
    }
    
    const nextState = state.transitions[action];
    if (!nextState) {
      console.log(`Cannot perform '${action}' from '${this.currentState}'`);
      return false;
    }
    
    // Execute exit action of current state
    if (state.onExit) {
      state.onExit();
    }
    
    // Execute the transition action
    if (state.actions && state.actions[action]) {
      state.actions[action]();
    }
    
    this.currentState = nextState;
    
    // Execute entry action of new state
    const newState = this.states[nextState];
    if (newState.onEnter) {
      newState.onEnter();
    }
    
    return true;
  }
  
  can(action) {
    const state = this.states[this.currentState];
    return state && action in state.transitions;
  }
  
  getState() {
    return this.currentState;
  }
}

// Traffic Light Example
const trafficLight = new StateMachine('red', {
  red: {
    transitions: { 
      next: 'green' 
    },
    onEnter: () => console.log('ðŸ”´ STOP'),
    onExit: () => console.log('Red light ending...'),
    actions: {
      next: () => console.log('Switching to green...')
    }
  },
  green: {
    transitions: { 
      next: 'yellow' 
    },
    onEnter: () => console.log('ðŸŸ¢ GO'),
    actions: {
      next: () => console.log('Switching to yellow...')
    }
  },
  yellow: {
    transitions: { 
      next: 'red' 
    },
    onEnter: () => console.log('ðŸŸ¡ CAUTION'),
    actions: {
      next: () => console.log('Switching to red...')
    }
  }
});

// Usage
console.log(trafficLight.getState()); // "red"
trafficLight.transition('next'); // Red -> Green
trafficLight.transition('next'); // Green -> Yellow
trafficLight.transition('next'); // Yellow -> Red
```

### 3. State Pattern with Functional Approach

```javascript
// Functional State Pattern
const createMediaPlayer = () => {
  let currentState = 'stopped';
  let currentTrack = null;
  
  const states = {
    stopped: {
      play: (track) => {
        currentTrack = track;
        currentState = 'playing';
        console.log(`â–¶ï¸ Playing: ${track}`);
        return true;
      },
      pause: () => {
        console.log('Cannot pause: Player is stopped');
        return false;
      },
      stop: () => {
        console.log('Already stopped');
        return false;
      }
    },
    
    playing: {
      play: (track) => {
        if (track !== currentTrack) {
          currentTrack = track;
          console.log(`â–¶ï¸ Now playing: ${track}`);
        } else {
          console.log('Already playing this track');
        }
        return true;
      },
      pause: () => {
        currentState = 'paused';
        console.log(`â¸ï¸ Paused: ${currentTrack}`);
        return true;
      },
      stop: () => {
        currentState = 'stopped';
        console.log(`â¹ï¸ Stopped`);
        currentTrack = null;
        return true;
      }
    },
    
    paused: {
      play: () => {
        currentState = 'playing';
        console.log(`â–¶ï¸ Resumed: ${currentTrack}`);
        return true;
      },
      pause: () => {
        console.log('Already paused');
        return false;
      },
      stop: () => {
        currentState = 'stopped';
        console.log(`â¹ï¸ Stopped`);
        currentTrack = null;
        return true;
      }
    }
  };
  
  return {
    play: (track) => states[currentState].play(track),
    pause: () => states[currentState].pause(),
    stop: () => states[currentState].stop(),
    getState: () => currentState,
    getCurrentTrack: () => currentTrack
  };
};

// Usage
const player = createMediaPlayer();
player.play('Song 1'); // â–¶ï¸ Playing: Song 1
player.pause();        // â¸ï¸ Paused: Song 1
player.play();         // â–¶ï¸ Resumed: Song 1
player.stop();         // â¹ï¸ Stopped
```

## ðŸŽ® Real-World Use Case: Game Character States

```javascript
class Character {
  constructor(name, health = 100, stamina = 100) {
    this.name = name;
    this.health = health;
    this.stamina = stamina;
    this.state = new IdleState();
  }
  
  setState(state) {
    console.log(`${this.name}: ${this.state.constructor.name} -> ${state.constructor.name}`);
    this.state = state;
  }
  
  attack() { return this.state.attack(this); }
  defend() { return this.state.defend(this); }
  run() { return this.state.run(this); }
  rest() { return this.state.rest(this); }
  
  takeDamage(amount) {
    this.health -= amount;
    if (this.health <= 0) {
      this.health = 0;
      this.setState(new DeadState());
    }
  }
  
  consumeStamina(amount) {
    this.stamina -= amount;
    if (this.stamina < 0) this.stamina = 0;
    if (this.stamina === 0) {
      this.setState(new ExhaustedState());
    }
  }
  
  recoverStamina(amount) {
    this.stamina = Math.min(100, this.stamina + amount);
  }
  
  getStatus() {
    return {
      name: this.name,
      health: this.health,
      stamina: this.stamina,
      state: this.state.constructor.name
    };
  }
}

class CharacterState {
  attack(character) { return false; }
  defend(character) { return false; }
  run(character) { return false; }
  rest(character) { return false; }
}

class IdleState extends CharacterState {
  attack(character) {
    if (character.stamina < 10) {
      console.log('Not enough stamina to attack!');
      return false;
    }
    console.log(`${character.name} attacks!`);
    character.consumeStamina(10);
    character.setState(new AttackingState());
    return true;
  }
  
  defend(character) {
    console.log(`${character.name} takes defensive stance`);
    character.setState(new DefendingState());
    return true;
  }
  
  run(character) {
    if (character.stamina < 15) {
      console.log('Too tired to run!');
      return false;
    }
    console.log(`${character.name} starts running!`);
    character.consumeStamina(15);
    character.setState(new RunningState());
    return true;
  }
  
  rest(character) {
    console.log(`${character.name} is resting...`);
    character.setState(new RestingState());
    return true;
  }
}

class AttackingState extends CharacterState {
  constructor() {
    super();
    // Auto-return to idle after attack animation
    setTimeout(() => {
      console.log('Attack complete');
    }, 500);
  }
  
  attack(character) {
    console.log('Already attacking!');
    return false;
  }
  
  defend(character) {
    console.log('Cannot defend while attacking!');
    return false;
  }
}

class DefendingState extends CharacterState {
  attack(character) {
    console.log(`${character.name} drops defense and attacks!`);
    character.consumeStamina(10);
    character.setState(new AttackingState());
    return true;
  }
  
  defend(character) {
    console.log('Already defending');
    return false;
  }
  
  rest(character) {
    console.log(`${character.name} stops defending and rests`);
    character.setState(new RestingState());
    return true;
  }
}

class RunningState extends CharacterState {
  attack(character) {
    console.log(`${character.name} stops and attacks!`);
    character.consumeStamina(10);
    character.setState(new AttackingState());
    return true;
  }
  
  run(character) {
    console.log('Already running!');
    return false;
  }
  
  rest(character) {
    console.log(`${character.name} stops running and rests`);
    character.setState(new RestingState());
    return true;
  }
}

class RestingState extends CharacterState {
  rest(character) {
    console.log(`${character.name} continues resting...`);
    character.recoverStamina(20);
    console.log(`Stamina: ${character.stamina}/100`);
    if (character.stamina === 100) {
      console.log('Fully recovered!');
      character.setState(new IdleState());
    }
    return true;
  }
  
  attack(character) {
    console.log(`${character.name} stops resting and attacks!`);
    character.consumeStamina(10);
    character.setState(new AttackingState());
    return true;
  }
}

class ExhaustedState extends CharacterState {
  attack(character) {
    console.log('Too exhausted to attack!');
    return false;
  }
  
  defend(character) {
    console.log('Too exhausted to defend properly!');
    return false;
  }
  
  run(character) {
    console.log('Too exhausted to run!');
    return false;
  }
  
  rest(character) {
    console.log(`${character.name} must rest...`);
    character.setState(new RestingState());
    character.recoverStamina(5);
    return true;
  }
}

class DeadState extends CharacterState {
  attack() { console.log('Cannot attack: Dead'); return false; }
  defend() { console.log('Cannot defend: Dead'); return false; }
  run() { console.log('Cannot run: Dead'); return false; }
  rest() { console.log('Cannot rest: Dead'); return false; }
}

// Usage Example
const hero = new Character('Warrior');
console.log(hero.getStatus());

hero.attack();
hero.attack();
hero.run();
hero.rest();
console.log(hero.getStatus());
```

## ðŸ“± UI Component State Example

```javascript
class FormField {
  constructor(value = '') {
    this.value = value;
    this.state = new PristineState();
    this.validationErrors = [];
  }
  
  setState(state) {
    this.state = state;
    this.render();
  }
  
  setValue(value) {
    this.value = value;
    this.state.onChange(this);
  }
  
  focus() { this.state.onFocus(this); }
  blur() { this.state.onBlur(this); }
  submit() { return this.state.onSubmit(this); }
  
  validate() {
    this.validationErrors = [];
    if (!this.value) {
      this.validationErrors.push('Field is required');
    }
    return this.validationErrors.length === 0;
  }
  
  render() {
    console.log(`Field State: ${this.state.constructor.name}`);
    console.log(`Value: "${this.value}"`);
    console.log(`Errors: ${this.validationErrors.join(', ') || 'None'}`);
    console.log('---');
  }
}

class FieldState {
  onChange(field) {}
  onFocus(field) {}
  onBlur(field) {}
  onSubmit(field) { return false; }
}

class PristineState extends FieldState {
  onChange(field) {
    field.setState(new DirtyState());
  }
  
  onFocus(field) {
    field.setState(new FocusedState());
  }
}

class FocusedState extends FieldState {
  onChange(field) {
    field.setState(new DirtyState());
  }
  
  onBlur(field) {
    if (field.value) {
      field.setState(new DirtyState());
    } else {
      field.setState(new PristineState());
    }
  }
}

class DirtyState extends FieldState {
  onChange(field) {
    // Stay dirty
  }
  
  onFocus(field) {
    field.setState(new FocusedState());
  }
  
  onBlur(field) {
    if (field.validate()) {
      field.setState(new ValidState());
    } else {
      field.setState(new InvalidState());
    }
  }
  
  onSubmit(field) {
    return field.validate();
  }
}

class ValidState extends FieldState {
  onChange(field) {
    field.setState(new DirtyState());
  }
  
  onSubmit(field) {
    return true;
  }
}

class InvalidState extends FieldState {
  onChange(field) {
    field.setState(new DirtyState());
  }
  
  onFocus(field) {
    field.setState(new FocusedState());
  }
  
  onSubmit(field) {
    return false;
  }
}

// Usage
const emailField = new FormField();
emailField.focus();
emailField.setValue('user@example.com');
emailField.blur();
console.log(emailField.submit() ? 'Valid!' : 'Invalid!');
```

## âœ… When to Use State Pattern

**Use State Pattern when:**
- Object behavior depends on its state and must change at runtime
- You have large conditional statements that depend on object state
- State-specific behavior is scattered across methods
- State transitions are complex and need to be explicitly defined

**Don't use when:**
- You only have a few simple states (use simple conditionals)
- States don't have distinct behaviors
- State transitions are trivial

## ðŸŽ¯ Benefits & Trade-offs

### Benefits
- Eliminates complex conditionals
- Makes state transitions explicit
- Encapsulates state-specific behavior
- Makes adding new states easier
- Follows Single Responsibility Principle

### Trade-offs
- Increases number of classes
- Can be overkill for simple state logic
- States may become tightly coupled if not careful
- More upfront design required

## ðŸ’¡ Pro Tips

1. **Use TypeScript** for better type safety with states
2. **Log state transitions** for debugging
3. **Consider using a state machine library** (XState) for complex scenarios
4. **Keep state classes focused** on single responsibility
5. **Document valid state transitions** clearly
6. **Use enums or constants** for state names to avoid typos