# Chapter 25: Visitor Pattern - In-Depth Guide

## üéØ Core Concept

The **Visitor Pattern** lets you add new operations to existing object structures without modifying them. It separates algorithms from the objects they operate on by moving the operational logic into separate visitor classes. This pattern is particularly useful when you have a stable class hierarchy but need to add new operations frequently.

### Visual Representation

```
         Visitor                    Element
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ visitA()     ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ Element A    ‚îÇ
    ‚îÇ visitB()     ‚îÇ           ‚îÇ accept(v)    ‚îÇ
    ‚îÇ visitC()     ‚îÇ           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îÇ
         ‚ñ≥                           ‚îÇ
         ‚îÇ                           ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ
    ‚îÇ         ‚îÇ        ‚îÇ            ‚îÇ
ConcreteV1 ConcreteV2 ConcreteV3   ‚îÇ
    ‚îÇ         ‚îÇ        ‚îÇ            ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           Double Dispatch
```

## üîë Key Concepts

1. **Double Dispatch**: The operation depends on both the visitor type AND element type
2. **Separation of Concerns**: Operations separated from data structures
3. **Open/Closed Principle**: Add operations without modifying existing classes
4. **Element Stability**: Works best when element classes are stable

## üíª Classic Implementation

```javascript
// Element interface
class FileSystemElement {
  accept(visitor) {
    throw new Error('accept() must be implemented');
  }
}

// Concrete Elements
class File extends FileSystemElement {
  constructor(name, size) {
    super();
    this.name = name;
    this.size = size;
  }
  
  accept(visitor) {
    return visitor.visitFile(this);
  }
}

class Directory extends FileSystemElement {
  constructor(name) {
    super();
    this.name = name;
    this.children = [];
  }
  
  add(element) {
    this.children.push(element);
  }
  
  accept(visitor) {
    return visitor.visitDirectory(this);
  }
}

class Symlink extends FileSystemElement {
  constructor(name, target) {
    super();
    this.name = name;
    this.target = target;
  }
  
  accept(visitor) {
    return visitor.visitSymlink(this);
  }
}

// Visitor interface
class FileSystemVisitor {
  visitFile(file) {
    throw new Error('visitFile() must be implemented');
  }
  
  visitDirectory(directory) {
    throw new Error('visitDirectory() must be implemented');
  }
  
  visitSymlink(symlink) {
    throw new Error('visitSymlink() must be implemented');
  }
}

// Concrete Visitor 1: Size Calculator
class SizeCalculator extends FileSystemVisitor {
  constructor() {
    super();
    this.totalSize = 0;
  }
  
  visitFile(file) {
    console.log(`  File: ${file.name} (${file.size} bytes)`);
    this.totalSize += file.size;
  }
  
  visitDirectory(directory) {
    console.log(`  Directory: ${directory.name}/`);
    directory.children.forEach(child => child.accept(this));
  }
  
  visitSymlink(symlink) {
    console.log(`  Symlink: ${symlink.name} -> ${symlink.target}`);
    // Symlinks don't add to size
  }
  
  getTotal() {
    return this.totalSize;
  }
}

// Concrete Visitor 2: File Counter
class FileCounter extends FileSystemVisitor {
  constructor() {
    super();
    this.fileCount = 0;
    this.dirCount = 0;
    this.symlinkCount = 0;
  }
  
  visitFile(file) {
    this.fileCount++;
  }
  
  visitDirectory(directory) {
    this.dirCount++;
    directory.children.forEach(child => child.accept(this));
  }
  
  visitSymlink(symlink) {
    this.symlinkCount++;
  }
  
  getReport() {
    return {
      files: this.fileCount,
      directories: this.dirCount,
      symlinks: this.symlinkCount,
      total: this.fileCount + this.dirCount + this.symlinkCount
    };
  }
}

// Concrete Visitor 3: Tree Printer
class TreePrinter extends FileSystemVisitor {
  constructor() {
    super();
    this.output = [];
    this.indentLevel = 0;
  }
  
  getIndent() {
    return '  '.repeat(this.indentLevel);
  }
  
  visitFile(file) {
    this.output.push(`${this.getIndent()}üìÑ ${file.name} (${file.size}b)`);
  }
  
  visitDirectory(directory) {
    this.output.push(`${this.getIndent()}üìÅ ${directory.name}/`);
    this.indentLevel++;
    directory.children.forEach(child => child.accept(this));
    this.indentLevel--;
  }
  
  visitSymlink(symlink) {
    this.output.push(`${this.getIndent()}üîó ${symlink.name} ‚Üí ${symlink.target}`);
  }
  
  getTree() {
    return this.output.join('\n');
  }
}

// Build file system structure
const root = new Directory('root');
const docs = new Directory('documents');
const pics = new Directory('pictures');

docs.add(new File('report.pdf', 2500));
docs.add(new File('notes.txt', 150));
docs.add(new Symlink('shortcuts', '/usr/local/bin'));

pics.add(new File('photo1.jpg', 4500));
pics.add(new File('photo2.jpg', 3800));

root.add(docs);
root.add(pics);
root.add(new File('readme.md', 100));

// Apply different visitors
console.log('=== Size Calculator ===');
const sizeCalc = new SizeCalculator();
root.accept(sizeCalc);
console.log(`\nTotal size: ${sizeCalc.getTotal()} bytes\n`);

console.log('=== File Counter ===');
const counter = new FileCounter();
root.accept(counter);
console.log(counter.getReport());

console.log('\n=== Tree Structure ===');
const printer = new TreePrinter();
root.accept(printer);
console.log(printer.getTree());
```

## üé® AST (Abstract Syntax Tree) Visitor

This is one of the most common real-world uses of the Visitor pattern:

```javascript
// AST Nodes (Elements)
class ASTNode {
  accept(visitor) {
    throw new Error('accept() must be implemented');
  }
}

class NumberLiteral extends ASTNode {
  constructor(value) {
    super();
    this.value = value;
  }
  
  accept(visitor) {
    return visitor.visitNumberLiteral(this);
  }
}

class BinaryOperation extends ASTNode {
  constructor(operator, left, right) {
    super();
    this.operator = operator;
    this.left = left;
    this.right = right;
  }
  
  accept(visitor) {
    return visitor.visitBinaryOperation(this);
  }
}

class Variable extends ASTNode {
  constructor(name) {
    super();
    this.name = name;
  }
  
  accept(visitor) {
    return visitor.visitVariable(this);
  }
}

class FunctionCall extends ASTNode {
  constructor(name, args) {
    super();
    this.name = name;
    this.args = args;
  }
  
  accept(visitor) {
    return visitor.visitFunctionCall(this);
  }
}

// Visitor: Evaluator
class Evaluator {
  constructor(context = {}) {
    this.context = context;
  }
  
  visitNumberLiteral(node) {
    return node.value;
  }
  
  visitVariable(node) {
    if (!(node.name in this.context)) {
      throw new Error(`Undefined variable: ${node.name}`);
    }
    return this.context[node.name];
  }
  
  visitBinaryOperation(node) {
    const left = node.left.accept(this);
    const right = node.right.accept(this);
    
    switch (node.operator) {
      case '+': return left + right;
      case '-': return left - right;
      case '*': return left * right;
      case '/': return left / right;
      case '%': return left % right;
      case '**': return left ** right;
      default: throw new Error(`Unknown operator: ${node.operator}`);
    }
  }
  
  visitFunctionCall(node) {
    const args = node.args.map(arg => arg.accept(this));
    
    const functions = {
      sqrt: (x) => Math.sqrt(x),
      abs: (x) => Math.abs(x),
      max: (...args) => Math.max(...args),
      min: (...args) => Math.min(...args)
    };
    
    if (!(node.name in functions)) {
      throw new Error(`Unknown function: ${node.name}`);
    }
    
    return functions[node.name](...args);
  }
}

// Visitor: Code Generator
class CodeGenerator {
  visitNumberLiteral(node) {
    return node.value.toString();
  }
  
  visitVariable(node) {
    return node.name;
  }
  
  visitBinaryOperation(node) {
    const left = node.left.accept(this);
    const right = node.right.accept(this);
    return `(${left} ${node.operator} ${right})`;
  }
  
  visitFunctionCall(node) {
    const args = node.args.map(arg => arg.accept(this)).join(', ');
    return `${node.name}(${args})`;
  }
}

// Visitor: Pretty Printer
class PrettyPrinter {
  constructor() {
    this.indentLevel = 0;
  }
  
  indent() {
    return '  '.repeat(this.indentLevel);
  }
  
  visitNumberLiteral(node) {
    return `${this.indent()}Number: ${node.value}`;
  }
  
  visitVariable(node) {
    return `${this.indent()}Variable: ${node.name}`;
  }
  
  visitBinaryOperation(node) {
    const result = [`${this.indent()}BinaryOp: ${node.operator}`];
    this.indentLevel++;
    result.push(node.left.accept(this));
    result.push(node.right.accept(this));
    this.indentLevel--;
    return result.join('\n');
  }
  
  visitFunctionCall(node) {
    const result = [`${this.indent()}Function: ${node.name}`];
    this.indentLevel++;
    node.args.forEach(arg => {
      result.push(arg.accept(this));
    });
    this.indentLevel--;
    return result.join('\n');
  }
}

// Build AST: (x + 5) * sqrt(16)
const ast = new BinaryOperation(
  '*',
  new BinaryOperation('+', new Variable('x'), new NumberLiteral(5)),
  new FunctionCall('sqrt', [new NumberLiteral(16)])
);

// Evaluate
console.log('=== Evaluation ===');
const evaluator = new Evaluator({ x: 10 });
console.log('Result:', ast.accept(evaluator)); // (10 + 5) * 4 = 60

// Generate code
console.log('\n=== Code Generation ===');
const codeGen = new CodeGenerator();
console.log('Code:', ast.accept(codeGen));

// Pretty print
console.log('\n=== AST Structure ===');
const printer = new PrettyPrinter();
console.log(ast.accept(printer));
```

## üìä Data Export Visitor

```javascript
// Shape elements
class Shape {
  accept(visitor) {
    throw new Error('accept() must be implemented');
  }
}

class Circle extends Shape {
  constructor(x, y, radius) {
    super();
    this.x = x;
    this.y = y;
    this.radius = radius;
  }
  
  accept(visitor) {
    return visitor.visitCircle(this);
  }
}

class Rectangle extends Shape {
  constructor(x, y, width, height) {
    super();
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  
  accept(visitor) {
    return visitor.visitRectangle(this);
  }
}

class Triangle extends Shape {
  constructor(x1, y1, x2, y2, x3, y3) {
    super();
    this.points = [
      { x: x1, y: y1 },
      { x: x2, y: y2 },
      { x: x3, y: y3 }
    ];
  }
  
  accept(visitor) {
    return visitor.visitTriangle(this);
  }
}

// Visitor: JSON Exporter
class JSONExporter {
  visitCircle(circle) {
    return {
      type: 'circle',
      center: { x: circle.x, y: circle.y },
      radius: circle.radius
    };
  }
  
  visitRectangle(rect) {
    return {
      type: 'rectangle',
      position: { x: rect.x, y: rect.y },
      dimensions: { width: rect.width, height: rect.height }
    };
  }
  
  visitTriangle(triangle) {
    return {
      type: 'triangle',
      points: triangle.points
    };
  }
}

// Visitor: SVG Exporter
class SVGExporter {
  visitCircle(circle) {
    return `<circle cx="${circle.x}" cy="${circle.y}" r="${circle.radius}" />`;
  }
  
  visitRectangle(rect) {
    return `<rect x="${rect.x}" y="${rect.y}" width="${rect.width}" height="${rect.height}" />`;
  }
  
  visitTriangle(triangle) {
    const points = triangle.points
      .map(p => `${p.x},${p.y}`)
      .join(' ');
    return `<polygon points="${points}" />`;
  }
}

// Visitor: Canvas Renderer
class CanvasRenderer {
  constructor(ctx) {
    this.ctx = ctx;
  }
  
  visitCircle(circle) {
    this.ctx.beginPath();
    this.ctx.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);
    this.ctx.stroke();
    console.log(`Drawing circle at (${circle.x}, ${circle.y})`);
  }
  
  visitRectangle(rect) {
    this.ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
    console.log(`Drawing rectangle at (${rect.x}, ${rect.y})`);
  }
  
  visitTriangle(triangle) {
    this.ctx.beginPath();
    this.ctx.moveTo(triangle.points[0].x, triangle.points[0].y);
    triangle.points.slice(1).forEach(p => {
      this.ctx.lineTo(p.x, p.y);
    });
    this.ctx.closePath();
    this.ctx.stroke();
    console.log(`Drawing triangle`);
  }
}

// Visitor: Area Calculator
class AreaCalculator {
  visitCircle(circle) {
    return Math.PI * circle.radius ** 2;
  }
  
  visitRectangle(rect) {
    return rect.width * rect.height;
  }
  
  visitTriangle(triangle) {
    // Using Shoelace formula
    const [p1, p2, p3] = triangle.points;
    return Math.abs(
      (p1.x * (p2.y - p3.y) +
       p2.x * (p3.y - p1.y) +
       p3.x * (p1.y - p2.y)) / 2
    );
  }
}

// Create shapes
const shapes = [
  new Circle(100, 100, 50),
  new Rectangle(200, 200, 100, 60),
  new Triangle(300, 300, 350, 350, 250, 350)
];

// Export to JSON
console.log('=== JSON Export ===');
const jsonExporter = new JSONExporter();
const jsonData = shapes.map(s => s.accept(jsonExporter));
console.log(JSON.stringify(jsonData, null, 2));

// Export to SVG
console.log('\n=== SVG Export ===');
const svgExporter = new SVGExporter();
const svgData = shapes.map(s => s.accept(svgExporter));
console.log('<svg>');
svgData.forEach(svg => console.log('  ' + svg));
console.log('</svg>');

// Calculate areas
console.log('\n=== Area Calculation ===');
const areaCalc = new AreaCalculator();
shapes.forEach((shape, index) => {
  const area = shape.accept(areaCalc);
  console.log(`Shape ${index + 1}: ${area.toFixed(2)} square units`);
});

// Render (mock canvas context)
console.log('\n=== Canvas Rendering ===');
const mockCtx = {
  beginPath: () => {},
  arc: () => {},
  stroke: () => {},
  strokeRect: () => {},
  moveTo: () => {},
  lineTo: () => {},
  closePath: () => {}
};
const renderer = new CanvasRenderer(mockCtx);
shapes.forEach(s => s.accept(renderer));
```

## üîç Type Checking Visitor

```javascript
// Type System Nodes
class TypeNode {
  accept(visitor) {
    throw new Error('accept() must be implemented');
  }
}

class PrimitiveType extends TypeNode {
  constructor(name) {
    super();
    this.name = name; // 'number', 'string', 'boolean'
  }
  
  accept(visitor) {
    return visitor.visitPrimitiveType(this);
  }
}

class ArrayType extends TypeNode {
  constructor(elementType) {
    super();
    this.elementType = elementType;
  }
  
  accept(visitor) {
    return visitor.visitArrayType(this);
  }
}

class ObjectType extends TypeNode {
  constructor(properties) {
    super();
    this.properties = properties; // Map<string, TypeNode>
  }
  
  accept(visitor) {
    return visitor.visitObjectType(this);
  }
}

class UnionType extends TypeNode {
  constructor(types) {
    super();
    this.types = types; // Array<TypeNode>
  }
  
  accept(visitor) {
    return visitor.visitUnionType(this);
  }
}

// Visitor: Type Validator
class TypeValidator {
  visitPrimitiveType(type, value) {
    const typeChecks = {
      number: v => typeof v === 'number',
      string: v => typeof v === 'string',
      boolean: v => typeof v === 'boolean'
    };
    
    return typeChecks[type.name]?.(value) ?? false;
  }
  
  visitArrayType(type, value) {
    if (!Array.isArray(value)) return false;
    
    return value.every(item => 
      type.elementType.accept(this, item)
    );
  }
  
  visitObjectType(type, value) {
    if (typeof value !== 'object' || value === null) return false;
    
    for (const [key, propType] of Object.entries(type.properties)) {
      if (!(key in value)) return false;
      if (!propType.accept(this, value[key])) return false;
    }
    
    return true;
  }
  
  visitUnionType(type, value) {
    return type.types.some(t => t.accept(this, value));
  }
}

// Visitor: Type Stringifier
class TypeStringifier {
  visitPrimitiveType(type) {
    return type.name;
  }
  
  visitArrayType(type) {
    return `Array<${type.elementType.accept(this)}>`;
  }
  
  visitObjectType(type) {
    const props = Object.entries(type.properties)
      .map(([key, propType]) => `${key}: ${propType.accept(this)}`)
      .join(', ');
    return `{ ${props} }`;
  }
  
  visitUnionType(type) {
    return type.types.map(t => t.accept(this)).join(' | ');
  }
}

// Create complex type: Array<{ id: number, name: string | boolean }>
const complexType = new ArrayType(
  new ObjectType({
    id: new PrimitiveType('number'),
    name: new UnionType([
      new PrimitiveType('string'),
      new PrimitiveType('boolean')
    ])
  })
);

// Stringify type
console.log('=== Type Definition ===');
const stringifier = new TypeStringifier();
console.log(complexType.accept(stringifier));

// Validate values
console.log('\n=== Type Validation ===');
const validator = new TypeValidator();

const validValue = [
  { id: 1, name: 'Alice' },
  { id: 2, name: true }
];

const invalidValue = [
  { id: 1, name: 'Alice' },
  { id: 'wrong', name: 'Bob' } // id should be number
];

console.log('Valid:', validator.visitArrayType(complexType, validValue));
console.log('Invalid:', validator.visitArrayType(complexType, invalidValue));
```

## ‚úÖ When to Use Visitor Pattern

**Use Visitor Pattern when:**
- You need to perform operations across a complex object structure
- The object structure rarely changes but operations on it change frequently
- You want to avoid polluting classes with many unrelated operations
- You need to accumulate state while traversing a structure
- Operations are not related to the primary responsibility of elements

**Don't use when:**
- The object structure changes frequently (requires updating all visitors)
- Operations are simple and few
- Elements are too coupled to visitors
- Performance overhead of double dispatch is unacceptable

## üéØ Benefits & Trade-offs

### Benefits
- **Separation of Concerns**: Operations separated from data structure
- **Open/Closed Principle**: Easy to add new operations (new visitors)
- **Single Responsibility**: Each visitor does one thing
- **Accumulation**: Visitor can maintain state across elements
- **Related operations together**: Grouping logic in one visitor class

### Trade-offs
- **Breaking encapsulation**: Visitors need access to element internals
- **Adding elements is hard**: New element requires changing all visitors
- **Tight coupling**: Elements must expose accept method
- **Complexity**: Double dispatch can be confusing
- **Circular dependencies**: Visitors and elements know about each other

## üí° Pro Tips

1. **Use for stable hierarchies**: Element classes shouldn't change often
2. **Document visitor interface**: Make it clear what each visit method does
3. **Consider default implementations**: Base visitor with no-op methods
4. **Think about traversal order**: Who controls it - visitor or element?
5. **Handle null cases**: Check for null/undefined elements
6. **Consider performance**: Double dispatch has overhead
7. **Use for cross-cutting concerns**: Logging, serialization, validation
8. **Alternative: Function-based**: In JS, you can use function objects
9. **Consider Interpreter pattern**: For simpler operation execution
10. **Babel/ESLint use this**: AST transformation is prime visitor territory

## üîÑ Visitor vs Other Patterns

| Aspect | Visitor | Strategy | Command |
|--------|---------|----------|---------|
| Purpose | Operations on structure | Algorithm selection | Encapsulate requests |
| Structure | Complex object tree | Single object | Single command |
| Extensibility | Easy to add operations | Easy to add strategies | Easy to add commands |
| Elements | Must support accept() | No special requirement | No special requirement |

## üöÄ Real-World Usage

**Babel**: AST transformation using visitors
**ESLint**: Linting rules are visitors on AST
**Webpack**: Plugin system uses visitor-like pattern
**TypeScript**: Type checker uses visitors
**XML/DOM processing**: SAX parsers use visitor pattern
**Compiler design**: Code generation, optimization passes