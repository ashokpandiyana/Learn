# Chapter 11: Facade Pattern

## 11.1 Concept

### What is the Facade Pattern?

The Facade Pattern provides a **simplified, unified interface** to a complex subsystem of classes, libraries, or frameworks. It hides the complexity of the subsystem and exposes only what's necessary for clients.

Think of it like a hotel concierge: instead of dealing with housekeeping, room service, transportation, and reservations separately, you talk to one person who handles everything for you.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     FACADE PATTERN                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   WITHOUT FACADE:                                           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                              â”‚
â”‚   â”‚  Client  â”‚â”€â”€â”¬â”€â”€â–º SubsystemA.methodA1()                  â”‚
â”‚   â”‚          â”‚  â”œâ”€â”€â–º SubsystemA.methodA2()                  â”‚
â”‚   â”‚  ğŸ˜°      â”‚  â”œâ”€â”€â–º SubsystemB.methodB1()                  â”‚
â”‚   â”‚ Complex! â”‚  â”œâ”€â”€â–º SubsystemC.methodC1()                  â”‚
â”‚   â”‚          â”‚  â”œâ”€â”€â–º SubsystemC.methodC2()                  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â–º SubsystemD.methodD1()                  â”‚
â”‚                                                             â”‚
â”‚   WITH FACADE:                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚  Client  â”‚â”€â”€â”€â”€â–ºâ”‚  FACADE  â”‚â”€â”€â”€â”€â–ºâ”‚    Subsystem     â”‚    â”‚
â”‚   â”‚          â”‚     â”‚          â”‚     â”‚                  â”‚    â”‚
â”‚   â”‚  ğŸ˜Š      â”‚     â”‚ doTask() â”‚     â”‚  A, B, C, D...   â”‚    â”‚
â”‚   â”‚ Simple!  â”‚     â”‚          â”‚     â”‚                  â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                             â”‚
â”‚   Client only knows about simple Facade interface           â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Characteristics

| Aspect | Description |
|--------|-------------|
| **Purpose** | Simplify complex subsystem interaction |
| **Direction** | One-way: Facade calls subsystem, not reverse |
| **Access** | Doesn't prevent direct subsystem access |
| **Knowledge** | Knows about subsystems; they don't know about Facade |
| **Coupling** | Reduces client-subsystem coupling |

### When to Use Facade

1. **Complex subsystem** - Many interconnected classes
2. **Library initialization** - Complex setup procedures
3. **Legacy system** - Wrap old code with clean interface
4. **Layer separation** - Create clear boundaries
5. **Entry point** - Provide main access point to system

---

## 11.2 Implementation

### Basic Facade Example

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPLEX SUBSYSTEM: Multiple classes with complex interactions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CPU {
  freeze() {
    console.log('CPU: Freezing processor...');
  }
  
  jump(position) {
    console.log(`CPU: Jumping to position ${position}`);
  }
  
  execute() {
    console.log('CPU: Executing instructions...');
  }
}

class Memory {
  load(position, data) {
    console.log(`Memory: Loading data "${data}" at position ${position}`);
  }
  
  read(position) {
    console.log(`Memory: Reading from position ${position}`);
    return 'data';
  }
  
  clear() {
    console.log('Memory: Clearing all memory...');
  }
}

class HardDrive {
  read(sector, size) {
    console.log(`HardDrive: Reading ${size} bytes from sector ${sector}`);
    return 'boot_data';
  }
  
  write(sector, data) {
    console.log(`HardDrive: Writing to sector ${sector}`);
  }
}

class Display {
  init() {
    console.log('Display: Initializing display...');
  }
  
  showBootScreen() {
    console.log('Display: Showing boot screen...');
  }
  
  showDesktop() {
    console.log('Display: Showing desktop...');
  }
}

class PowerSupply {
  turnOn() {
    console.log('PowerSupply: Providing power...');
  }
  
  turnOff() {
    console.log('PowerSupply: Cutting power...');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FACADE: Simple interface to the complex subsystem
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ComputerFacade {
  constructor() {
    this.cpu = new CPU();
    this.memory = new Memory();
    this.hardDrive = new HardDrive();
    this.display = new Display();
    this.power = new PowerSupply();
  }
  
  // Simple method that orchestrates complex operations
  start() {
    console.log('\n=== Starting Computer ===\n');
    
    // Power up
    this.power.turnOn();
    
    // Initialize display
    this.display.init();
    this.display.showBootScreen();
    
    // CPU boot sequence
    this.cpu.freeze();
    
    // Load boot sector
    const bootData = this.hardDrive.read(0, 1024);
    this.memory.load(0, bootData);
    
    // Execute boot
    this.cpu.jump(0);
    this.cpu.execute();
    
    // Show desktop
    this.display.showDesktop();
    
    console.log('\n=== Computer Started Successfully ===\n');
  }
  
  shutdown() {
    console.log('\n=== Shutting Down Computer ===\n');
    
    this.memory.clear();
    this.cpu.freeze();
    this.display.init(); // Show shutdown screen
    this.power.turnOff();
    
    console.log('\n=== Computer Shut Down ===\n');
  }
  
  restart() {
    this.shutdown();
    this.start();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLIENT: Uses simple interface
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const computer = new ComputerFacade();

// Client doesn't need to know about CPU, Memory, HardDrive, etc.
computer.start();
// ... use computer ...
computer.shutdown();
```

### E-Commerce Facade Example

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPLEX SUBSYSTEM: Multiple services for e-commerce
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class InventoryService {
  checkStock(productId) {
    console.log(`Inventory: Checking stock for product ${productId}`);
    return { available: true, quantity: 10 };
  }
  
  reserveStock(productId, quantity) {
    console.log(`Inventory: Reserving ${quantity} units of product ${productId}`);
    return { reserved: true, reservationId: 'RES-' + Date.now() };
  }
  
  releaseReservation(reservationId) {
    console.log(`Inventory: Releasing reservation ${reservationId}`);
  }
}

class PaymentService {
  validateCard(cardDetails) {
    console.log('Payment: Validating card...');
    return { valid: true };
  }
  
  processPayment(amount, cardDetails) {
    console.log(`Payment: Processing $${amount}...`);
    return { 
      success: true, 
      transactionId: 'TXN-' + Date.now(),
      amount 
    };
  }
  
  refund(transactionId, amount) {
    console.log(`Payment: Refunding $${amount} for transaction ${transactionId}`);
    return { success: true };
  }
}

class ShippingService {
  calculateShipping(address, items) {
    console.log('Shipping: Calculating shipping cost...');
    return { cost: 9.99, estimatedDays: 3 };
  }
  
  createShipment(orderId, address, items) {
    console.log(`Shipping: Creating shipment for order ${orderId}`);
    return { 
      trackingNumber: 'TRACK-' + Date.now(),
      carrier: 'FastShip',
      estimatedDelivery: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000)
    };
  }
  
  getTrackingInfo(trackingNumber) {
    console.log(`Shipping: Getting tracking info for ${trackingNumber}`);
    return { status: 'In Transit', location: 'Distribution Center' };
  }
}

class NotificationService {
  sendEmail(to, subject, body) {
    console.log(`Notification: Sending email to ${to}`);
    console.log(`  Subject: ${subject}`);
  }
  
  sendSMS(phone, message) {
    console.log(`Notification: Sending SMS to ${phone}`);
  }
  
  sendPushNotification(userId, title, message) {
    console.log(`Notification: Sending push to user ${userId}`);
  }
}

class TaxService {
  calculateTax(subtotal, address) {
    console.log('Tax: Calculating tax...');
    const taxRate = 0.08; // 8%
    return { tax: subtotal * taxRate, rate: taxRate };
  }
}

class DiscountService {
  applyPromoCode(code, subtotal) {
    console.log(`Discount: Applying promo code ${code}`);
    if (code === 'SAVE10') {
      return { valid: true, discount: subtotal * 0.1, code };
    }
    return { valid: false, discount: 0 };
  }
  
  getLoyaltyDiscount(customerId) {
    console.log(`Discount: Checking loyalty for customer ${customerId}`);
    return { discount: 5, reason: 'Loyalty member' };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FACADE: Simplified order processing interface
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class OrderFacade {
  constructor() {
    this.inventory = new InventoryService();
    this.payment = new PaymentService();
    this.shipping = new ShippingService();
    this.notification = new NotificationService();
    this.tax = new TaxService();
    this.discount = new DiscountService();
  }
  
  // Single method to handle entire checkout process
  async checkout(order) {
    const {
      customerId,
      customerEmail,
      customerPhone,
      items,
      shippingAddress,
      cardDetails,
      promoCode
    } = order;
    
    console.log('\n========== CHECKOUT PROCESS ==========\n');
    
    try {
      // Step 1: Check inventory for all items
      console.log('Step 1: Checking Inventory');
      const reservations = [];
      for (const item of items) {
        const stock = this.inventory.checkStock(item.productId);
        if (!stock.available || stock.quantity < item.quantity) {
          throw new Error(`Product ${item.productId} is out of stock`);
        }
        const reservation = this.inventory.reserveStock(item.productId, item.quantity);
        reservations.push(reservation);
      }
      
      // Step 2: Calculate totals
      console.log('\nStep 2: Calculating Totals');
      let subtotal = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
      
      // Apply promo code
      const promoResult = promoCode 
        ? this.discount.applyPromoCode(promoCode, subtotal) 
        : { discount: 0 };
      
      // Apply loyalty discount
      const loyaltyResult = this.discount.getLoyaltyDiscount(customerId);
      
      const totalDiscount = promoResult.discount + loyaltyResult.discount;
      subtotal -= totalDiscount;
      
      // Calculate shipping
      const shippingResult = this.shipping.calculateShipping(shippingAddress, items);
      
      // Calculate tax
      const taxResult = this.tax.calculateTax(subtotal, shippingAddress);
      
      const total = subtotal + shippingResult.cost + taxResult.tax;
      
      console.log(`  Subtotal: $${subtotal.toFixed(2)}`);
      console.log(`  Discount: -$${totalDiscount.toFixed(2)}`);
      console.log(`  Shipping: $${shippingResult.cost.toFixed(2)}`);
      console.log(`  Tax: $${taxResult.tax.toFixed(2)}`);
      console.log(`  Total: $${total.toFixed(2)}`);
      
      // Step 3: Process payment
      console.log('\nStep 3: Processing Payment');
      const cardValidation = this.payment.validateCard(cardDetails);
      if (!cardValidation.valid) {
        throw new Error('Invalid card details');
      }
      
      const paymentResult = this.payment.processPayment(total, cardDetails);
      if (!paymentResult.success) {
        throw new Error('Payment failed');
      }
      
      // Step 4: Create shipment
      console.log('\nStep 4: Creating Shipment');
      const orderId = 'ORD-' + Date.now();
      const shipmentResult = this.shipping.createShipment(orderId, shippingAddress, items);
      
      // Step 5: Send notifications
      console.log('\nStep 5: Sending Notifications');
      this.notification.sendEmail(
        customerEmail,
        'Order Confirmation',
        `Your order ${orderId} has been placed!`
      );
      this.notification.sendSMS(
        customerPhone,
        `Order ${orderId} confirmed! Track at: ${shipmentResult.trackingNumber}`
      );
      
      console.log('\n========== CHECKOUT COMPLETE ==========\n');
      
      return {
        success: true,
        orderId,
        transactionId: paymentResult.transactionId,
        trackingNumber: shipmentResult.trackingNumber,
        total,
        estimatedDelivery: shipmentResult.estimatedDelivery
      };
      
    } catch (error) {
      // Rollback: Release all reservations
      console.log('\nError occurred, rolling back...');
      // In real app: release reservations, refund if needed
      
      return {
        success: false,
        error: error.message
      };
    }
  }
  
  // Simplified method to track an order
  trackOrder(trackingNumber) {
    return this.shipping.getTrackingInfo(trackingNumber);
  }
  
  // Simplified method to cancel an order
  async cancelOrder(orderId, transactionId, amount) {
    console.log(`\nCancelling order ${orderId}...`);
    
    // Refund payment
    const refundResult = this.payment.refund(transactionId, amount);
    
    // Send notification
    this.notification.sendEmail(
      'customer@example.com',
      'Order Cancelled',
      `Your order ${orderId} has been cancelled and refunded.`
    );
    
    return refundResult;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLIENT: Simple usage
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const orderFacade = new OrderFacade();

// Client only needs to call one method!
const result = await orderFacade.checkout({
  customerId: 'CUST-123',
  customerEmail: 'john@example.com',
  customerPhone: '+1234567890',
  items: [
    { productId: 'PROD-1', name: 'Widget', price: 29.99, quantity: 2 },
    { productId: 'PROD-2', name: 'Gadget', price: 49.99, quantity: 1 }
  ],
  shippingAddress: {
    street: '123 Main St',
    city: 'New York',
    zip: '10001'
  },
  cardDetails: {
    number: '4111111111111111',
    expiry: '12/25',
    cvv: '123'
  },
  promoCode: 'SAVE10'
});

console.log('Order Result:', result);
```

---

## 11.3 Facade in JavaScript Libraries

### jQuery as Facade

```javascript
// jQuery is a classic Facade example
// It simplifies complex DOM operations

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WITHOUT jQuery (Complex native APIs)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Select elements
const elements = document.querySelectorAll('.my-class');

// Add event listener to each
elements.forEach(el => {
  el.addEventListener('click', function(e) {
    // Handle click
  });
});

// AJAX request
const xhr = new XMLHttpRequest();
xhr.open('GET', '/api/data');
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    const data = JSON.parse(xhr.responseText);
    // Handle data
  }
};
xhr.send();

// Animate element
let opacity = 0;
const fadeIn = setInterval(() => {
  opacity += 0.1;
  element.style.opacity = opacity;
  if (opacity >= 1) clearInterval(fadeIn);
}, 50);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WITH jQuery (Simple Facade)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Select and attach events
$('.my-class').click(function() {
  // Handle click
});

// AJAX request
$.get('/api/data', function(data) {
  // Handle data
});

// Animate
$element.fadeIn();
```

### Creating Your Own Facade

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Browser Storage Facade
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class StorageFacade {
  constructor(storageType = 'local') {
    this.storage = storageType === 'local' 
      ? localStorage 
      : sessionStorage;
    this.prefix = 'app_';
  }
  
  // Simple set with automatic serialization
  set(key, value, ttl = null) {
    const item = {
      value,
      timestamp: Date.now(),
      ttl
    };
    
    try {
      this.storage.setItem(
        this.prefix + key, 
        JSON.stringify(item)
      );
      return true;
    } catch (e) {
      console.error('Storage error:', e);
      return false;
    }
  }
  
  // Simple get with automatic deserialization and TTL check
  get(key, defaultValue = null) {
    try {
      const itemStr = this.storage.getItem(this.prefix + key);
      
      if (!itemStr) return defaultValue;
      
      const item = JSON.parse(itemStr);
      
      // Check TTL
      if (item.ttl && Date.now() - item.timestamp > item.ttl) {
        this.remove(key);
        return defaultValue;
      }
      
      return item.value;
    } catch (e) {
      return defaultValue;
    }
  }
  
  // Remove item
  remove(key) {
    this.storage.removeItem(this.prefix + key);
  }
  
  // Clear all app items
  clear() {
    const keys = Object.keys(this.storage);
    keys.forEach(key => {
      if (key.startsWith(this.prefix)) {
        this.storage.removeItem(key);
      }
    });
  }
  
  // Check if key exists
  has(key) {
    return this.get(key) !== null;
  }
  
  // Get all keys
  keys() {
    return Object.keys(this.storage)
      .filter(key => key.startsWith(this.prefix))
      .map(key => key.slice(this.prefix.length));
  }
}

// Usage - Much simpler than raw localStorage
const storage = new StorageFacade();

// Store objects directly (no manual JSON.stringify)
storage.set('user', { name: 'John', role: 'admin' });
storage.set('token', 'abc123', 3600000); // 1 hour TTL

// Get objects directly (no manual JSON.parse)
const user = storage.get('user');
const token = storage.get('token', 'no-token'); // With default

// Other operations
storage.has('user');  // true
storage.keys();       // ['user', 'token']
storage.remove('token');
storage.clear();
```

---

## 11.4 Facade vs Other Patterns

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              FACADE vs SIMILAR PATTERNS                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  FACADE vs ADAPTER:                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚  Facade:   Simplifies (many classes â†’ one interface)        â”‚
â”‚  Adapter:  Converts (one interface â†’ another interface)     â”‚
â”‚                                                             â”‚
â”‚  FACADE vs MEDIATOR:                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚  Facade:   One-way (facade â†’ subsystems)                    â”‚
â”‚  Mediator: Two-way (components â†” mediator â†” components)     â”‚
â”‚                                                             â”‚
â”‚  FACADE vs PROXY:                                           â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                            â”‚
â”‚  Facade:   Different, simplified interface                  â”‚
â”‚  Proxy:    Same interface, controls access                  â”‚
â”‚                                                             â”‚
â”‚  FACADE vs ABSTRACT FACTORY:                                â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                 â”‚
â”‚  Facade:   Hides how subsystems work                        â”‚
â”‚  Abstract Factory: Hides how objects are created            â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Key Takeaways

1. **Facade simplifies complex subsystems** - One interface to rule them all
2. **Doesn't hide subsystems** - Direct access still possible if needed
3. **Reduces coupling** - Clients depend on facade, not subsystems
4. **Common in libraries** - jQuery, Lodash, SDK wrappers
5. **Entry point pattern** - Good for library/module public APIs
6. **Layer separation** - Creates clear architectural boundaries

> ğŸ’¡ **Interview Tip:** Explain Facade with the "hotel concierge" analogy - you don't call housekeeping, room service, and transportation separately; the concierge handles it all.

> ğŸ­ **Production Note:** Facade is perfect for wrapping third-party libraries. If you need to switch providers (e.g., analytics, payments), only the facade needs to change.
