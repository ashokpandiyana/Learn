# Chapter 34: Component Pattern - Complete Guide

## üìö What is the Component Pattern?

The Component Pattern is a fundamental building block of modern UI development where the interface is broken down into **self-contained, reusable, and composable units** called components. Each component encapsulates its own structure (HTML), styling (CSS), and behavior (JavaScript).

### Core Philosophy
```
"Everything is a component"
```

Instead of building one large application, you build many small, focused components that work together.

## üéØ Core Principles

### 1. Encapsulation
Each component contains everything it needs to function:
- Structure (markup)
- Style (CSS)
- Behavior (logic)
- State (data)

### 2. Reusability
Write once, use anywhere with different props/configurations.

### 3. Composition
Build complex UIs by combining simple components.

### 4. Single Responsibility
Each component does one thing well.

## üèóÔ∏è Component Anatomy

```javascript
// A typical component structure
Component {
  Props (input)      // Data passed from parent
  State (internal)   // Component's own data
  Lifecycle          // Creation, update, destruction
  Render (output)    // Visual representation
  Events (output)    // Communication to parent
}
```

## üíª Vanilla JavaScript Implementation

### 1. Basic Component Class

```javascript
class Component {
  constructor(props = {}) {
    this.props = props;
    this.state = {};
    this.element = null;
  }

  // Lifecycle methods
  componentWillMount() {}
  componentDidMount() {}
  componentWillUpdate(nextProps, nextState) {}
  componentDidUpdate(prevProps, prevState) {}
  componentWillUnmount() {}

  setState(newState) {
    const prevState = { ...this.state };
    this.state = { ...this.state, ...newState };
    
    this.componentWillUpdate(this.props, this.state);
    this.update();
    this.componentDidUpdate(this.props, prevState);
  }

  // Abstract method - must be implemented
  render() {
    throw new Error('Component must implement render method');
  }

  // Mount component to DOM
  mount(container) {
    this.componentWillMount();
    this.element = this.render();
    container.appendChild(this.element);
    this.componentDidMount();
  }

  // Update the component
  update() {
    if (this.element && this.element.parentNode) {
      const newElement = this.render();
      this.element.parentNode.replaceChild(newElement, this.element);
      this.element = newElement;
    }
  }

  // Remove component from DOM
  unmount() {
    this.componentWillUnmount();
    if (this.element && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
  }
}
```

### 2. Practical Example: Button Component

```javascript
class Button extends Component {
  constructor(props) {
    super(props);
    this.state = {
      isClicked: false
    };
  }

  componentDidMount() {
    console.log('Button mounted');
  }

  handleClick = () => {
    this.setState({ isClicked: true });
    
    // Call prop callback if provided
    if (this.props.onClick) {
      this.props.onClick(this.props.label);
    }

    // Reset after animation
    setTimeout(() => {
      this.setState({ isClicked: false });
    }, 200);
  }

  render() {
    const button = document.createElement('button');
    button.className = `btn ${this.props.variant || 'primary'} ${
      this.state.isClicked ? 'clicked' : ''
    }`;
    button.textContent = this.props.label || 'Click me';
    button.disabled = this.props.disabled || false;
    button.addEventListener('click', this.handleClick);
    
    return button;
  }
}

// Usage
const container = document.getElementById('app');
const button = new Button({
  label: 'Submit',
  variant: 'success',
  onClick: (label) => console.log(`${label} clicked!`)
});
button.mount(container);
```

### 3. Complex Component: Todo List

```javascript
class TodoList extends Component {
  constructor(props) {
    super(props);
    this.state = {
      todos: props.todos || [],
      filter: 'all'
    };
  }

  addTodo(text) {
    const newTodo = {
      id: Date.now(),
      text,
      completed: false
    };
    this.setState({
      todos: [...this.state.todos, newTodo]
    });
  }

  toggleTodo(id) {
    const todos = this.state.todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    );
    this.setState({ todos });
  }

  deleteTodo(id) {
    const todos = this.state.todos.filter(todo => todo.id !== id);
    this.setState({ todos });
  }

  setFilter(filter) {
    this.setState({ filter });
  }

  getFilteredTodos() {
    const { todos, filter } = this.state;
    switch (filter) {
      case 'active':
        return todos.filter(t => !t.completed);
      case 'completed':
        return todos.filter(t => t.completed);
      default:
        return todos;
    }
  }

  render() {
    const container = document.createElement('div');
    container.className = 'todo-list';

    // Input section
    const inputSection = document.createElement('div');
    inputSection.className = 'input-section';
    
    const input = document.createElement('input');
    input.type = 'text';
    input.placeholder = 'Add a todo...';
    input.className = 'todo-input';
    
    const addButton = document.createElement('button');
    addButton.textContent = 'Add';
    addButton.className = 'btn-add';
    addButton.addEventListener('click', () => {
      if (input.value.trim()) {
        this.addTodo(input.value);
        input.value = '';
      }
    });

    inputSection.appendChild(input);
    inputSection.appendChild(addButton);

    // Filter buttons
    const filters = document.createElement('div');
    filters.className = 'filters';
    
    ['all', 'active', 'completed'].forEach(filter => {
      const btn = document.createElement('button');
      btn.textContent = filter.charAt(0).toUpperCase() + filter.slice(1);
      btn.className = `filter-btn ${this.state.filter === filter ? 'active' : ''}`;
      btn.addEventListener('click', () => this.setFilter(filter));
      filters.appendChild(btn);
    });

    // Todo items
    const list = document.createElement('ul');
    list.className = 'todos';
    
    this.getFilteredTodos().forEach(todo => {
      const item = document.createElement('li');
      item.className = todo.completed ? 'completed' : '';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = todo.completed;
      checkbox.addEventListener('change', () => this.toggleTodo(todo.id));

      const text = document.createElement('span');
      text.textContent = todo.text;

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'Delete';
      deleteBtn.className = 'btn-delete';
      deleteBtn.addEventListener('click', () => this.deleteTodo(todo.id));

      item.appendChild(checkbox);
      item.appendChild(text);
      item.appendChild(deleteBtn);
      list.appendChild(item);
    });

    // Statistics
    const stats = document.createElement('div');
    stats.className = 'stats';
    const activeCount = this.state.todos.filter(t => !t.completed).length;
    stats.textContent = `${activeCount} item${activeCount !== 1 ? 's' : ''} left`;

    container.appendChild(inputSection);
    container.appendChild(filters);
    container.appendChild(list);
    container.appendChild(stats);

    return container;
  }
}

// Usage
const app = document.getElementById('app');
const todoList = new TodoList({
  todos: [
    { id: 1, text: 'Learn components', completed: false },
    { id: 2, text: 'Build an app', completed: false }
  ]
});
todoList.mount(app);
```

## ‚öõÔ∏è Component Types

### 1. Presentational Components (Dumb/Pure)

Components that only display data and don't manage state.

```javascript
// Presentational: User Card
class UserCard extends Component {
  render() {
    const { name, email, avatar } = this.props;
    
    const card = document.createElement('div');
    card.className = 'user-card';
    card.innerHTML = `
      <img src="${avatar}" alt="${name}" class="avatar" />
      <h3>${name}</h3>
      <p>${email}</p>
    `;
    
    return card;
  }
}

// Usage with data
const user = { name: 'John Doe', email: 'john@example.com', avatar: 'avatar.jpg' };
new UserCard(user).mount(container);
```

### 2. Container Components (Smart)

Components that manage state and logic, passing data to presentational components.

```javascript
class UserList extends Component {
  constructor(props) {
    super(props);
    this.state = {
      users: [],
      loading: true,
      error: null
    };
  }

  async componentDidMount() {
    try {
      const response = await fetch('/api/users');
      const users = await response.json();
      this.setState({ users, loading: false });
    } catch (error) {
      this.setState({ error: error.message, loading: false });
    }
  }

  render() {
    const container = document.createElement('div');
    container.className = 'user-list';

    if (this.state.loading) {
      container.innerHTML = '<div class="loading">Loading...</div>';
      return container;
    }

    if (this.state.error) {
      container.innerHTML = `<div class="error">${this.state.error}</div>`;
      return container;
    }

    this.state.users.forEach(user => {
      const userCard = new UserCard(user);
      container.appendChild(userCard.render());
    });

    return container;
  }
}
```

### 3. Higher-Order Components (HOC)

Functions that take a component and return an enhanced component.

```javascript
// HOC: Add loading functionality
function withLoading(Component) {
  return class extends Component {
    constructor(props) {
      super(props);
      this.state = {
        ...this.state,
        isLoading: false
      };
    }

    setLoading(isLoading) {
      this.setState({ isLoading });
    }

    render() {
      if (this.state.isLoading) {
        const loader = document.createElement('div');
        loader.className = 'loading-overlay';
        loader.innerHTML = '<div class="spinner">Loading...</div>';
        return loader;
      }
      return super.render();
    }
  };
}

// HOC: Add error handling
function withErrorBoundary(Component) {
  return class extends Component {
    constructor(props) {
      super(props);
      this.state = {
        ...this.state,
        hasError: false,
        error: null
      };
    }

    componentDidCatch(error) {
      this.setState({
        hasError: true,
        error: error.message
      });
    }

    render() {
      if (this.state.hasError) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-boundary';
        errorDiv.innerHTML = `
          <h3>Something went wrong</h3>
          <p>${this.state.error}</p>
        `;
        return errorDiv;
      }
      
      try {
        return super.render();
      } catch (error) {
        this.componentDidCatch(error);
        return this.render();
      }
    }
  };
}

// Usage
const EnhancedUserList = withErrorBoundary(withLoading(UserList));
const list = new EnhancedUserList();
list.mount(container);
```

## üé® Component Composition

Building complex UIs by combining simple components.

```javascript
// Atomic components
class Icon extends Component {
  render() {
    const icon = document.createElement('i');
    icon.className = `icon icon-${this.props.name}`;
    return icon;
  }
}

class Text extends Component {
  render() {
    const span = document.createElement('span');
    span.textContent = this.props.children;
    span.className = this.props.className || '';
    return span;
  }
}

// Molecule: Composed of atoms
class IconButton extends Component {
  render() {
    const button = document.createElement('button');
    button.className = `icon-button ${this.props.className || ''}`;
    
    if (this.props.icon) {
      const icon = new Icon({ name: this.props.icon });
      button.appendChild(icon.render());
    }
    
    if (this.props.label) {
      const text = new Text({ children: this.props.label });
      button.appendChild(text.render());
    }
    
    button.addEventListener('click', this.props.onClick || (() => {}));
    
    return button;
  }
}

// Organism: Composed of molecules
class Card extends Component {
  render() {
    const card = document.createElement('div');
    card.className = 'card';
    
    // Header
    const header = document.createElement('div');
    header.className = 'card-header';
    
    const title = new Text({ 
      children: this.props.title, 
      className: 'card-title' 
    });
    header.appendChild(title.render());
    
    if (this.props.onClose) {
      const closeBtn = new IconButton({
        icon: 'close',
        className: 'card-close',
        onClick: this.props.onClose
      });
      header.appendChild(closeBtn.render());
    }
    
    // Body
    const body = document.createElement('div');
    body.className = 'card-body';
    body.innerHTML = this.props.content || '';
    
    // Footer
    if (this.props.actions) {
      const footer = document.createElement('div');
      footer.className = 'card-footer';
      
      this.props.actions.forEach(action => {
        const btn = new IconButton(action);
        footer.appendChild(btn.render());
      });
      
      card.appendChild(footer);
    }
    
    card.appendChild(header);
    card.appendChild(body);
    
    return card;
  }
}

// Usage: Complex composition
const card = new Card({
  title: 'Welcome',
  content: '<p>This is a composed component!</p>',
  onClose: () => console.log('Closed'),
  actions: [
    { icon: 'save', label: 'Save', onClick: () => console.log('Saved') },
    { icon: 'delete', label: 'Delete', onClick: () => console.log('Deleted') }
  ]
});
card.mount(container);
```

## üîÑ Component Communication

### 1. Props Down (Parent to Child)

```javascript
class Parent extends Component {
  constructor(props) {
    super(props);
    this.state = { message: 'Hello from parent' };
  }

  render() {
    const container = document.createElement('div');
    
    // Pass data to child via props
    const child = new Child({ message: this.state.message });
    container.appendChild(child.render());
    
    return container;
  }
}

class Child extends Component {
  render() {
    const div = document.createElement('div');
    div.textContent = this.props.message; // Receive from parent
    return div;
  }
}
```

### 2. Events Up (Child to Parent)

```javascript
class Parent extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  handleIncrement = () => {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    const container = document.createElement('div');
    
    const display = document.createElement('div');
    display.textContent = `Count: ${this.state.count}`;
    
    // Pass callback to child
    const child = new Child({ onIncrement: this.handleIncrement });
    
    container.appendChild(display);
    container.appendChild(child.render());
    
    return container;
  }
}

class Child extends Component {
  render() {
    const button = document.createElement('button');
    button.textContent = 'Increment';
    // Call parent's callback
    button.addEventListener('click', () => this.props.onIncrement());
    return button;
  }
}
```

### 3. Event Bus (Sibling Communication)

```javascript
class EventBus {
  constructor() {
    this.events = {};
  }

  on(event, callback) {
    (this.events[event] ||= []).push(callback);
  }

  emit(event, data) {
    (this.events[event] || []).forEach(callback => callback(data));
  }

  off(event, callback) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
  }
}

const eventBus = new EventBus();

class ComponentA extends Component {
  sendMessage() {
    eventBus.emit('message', 'Hello from A');
  }

  render() {
    const button = document.createElement('button');
    button.textContent = 'Send Message';
    button.addEventListener('click', () => this.sendMessage());
    return button;
  }
}

class ComponentB extends Component {
  constructor(props) {
    super(props);
    this.state = { message: '' };
  }

  componentDidMount() {
    this.messageHandler = (message) => {
      this.setState({ message });
    };
    eventBus.on('message', this.messageHandler);
  }

  componentWillUnmount() {
    eventBus.off('message', this.messageHandler);
  }

  render() {
    const div = document.createElement('div');
    div.textContent = `Received: ${this.state.message}`;
    return div;
  }
}
```

## ‚ö° React Component Patterns

### 1. Functional Components with Hooks

```javascript
// Modern React component
function TodoList() {
  const [todos, setTodos] = React.useState([]);
  const [input, setInput] = React.useState('');

  const addTodo = () => {
    if (input.trim()) {
      setTodos([...todos, { id: Date.now(), text: input, completed: false }]);
      setInput('');
    }
  };

  const toggleTodo = (id) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  return (
    <div className="todo-list">
      <input 
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Add a todo..."
      />
      <button onClick={addTodo}>Add</button>
      <ul>
        {todos.map(todo => (
          <li key={todo.id} className={todo.completed ? 'completed' : ''}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            />
            <span>{todo.text}</span>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### 2. Custom Hooks

```javascript
// Reusable logic in custom hooks
function useTodos() {
  const [todos, setTodos] = React.useState([]);

  const addTodo = (text) => {
    setTodos([...todos, { id: Date.now(), text, completed: false }]);
  };

  const toggleTodo = (id) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const deleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  return { todos, addTodo, toggleTodo, deleteTodo };
}

// Usage
function TodoApp() {
  const { todos, addTodo, toggleTodo, deleteTodo } = useTodos();
  const [input, setInput] = React.useState('');

  return (
    <div>
      <input value={input} onChange={(e) => setInput(e.target.value)} />
      <button onClick={() => { addTodo(input); setInput(''); }}>Add</button>
      <TodoList todos={todos} onToggle={toggleTodo} onDelete={deleteTodo} />
    </div>
  );
}
```

### 3. Render Props Pattern

```javascript
// Component with render prop
class DataFetcher extends React.Component {
  state = { data: null, loading: true, error: null };

  async componentDidMount() {
    try {
      const response = await fetch(this.props.url);
      const data = await response.json();
      this.setState({ data, loading: false });
    } catch (error) {
      this.setState({ error: error.message, loading: false });
    }
  }

  render() {
    return this.props.render(this.state);
  }
}

// Usage
function App() {
  return (
    <DataFetcher
      url="/api/users"
      render={({ data, loading, error }) => {
        if (loading) return <div>Loading...</div>;
        if (error) return <div>Error: {error}</div>;
        return <UserList users={data} />;
      }}
    />
  );
}
```

## üéØ Component Design Best Practices

### ‚úÖ DO:
- Keep components small and focused
- Use composition over inheritance
- Separate presentational and container components
- Props should be immutable
- Lift state up when needed
- Use meaningful component names
- Implement proper error boundaries

### ‚ùå DON'T:
- Create components with too many responsibilities
- Mutate props directly
- Have deep prop drilling (use context/state management)
- Mix business logic with presentation
- Create premature abstractions
- Forget to clean up in unmount

## üîë Key Takeaways

1. **Encapsulation**: Components contain their own logic, styling, and structure
2. **Reusability**: Write once, use everywhere
3. **Composition**: Build complex UIs from simple components
4. **Unidirectional Data Flow**: Props down, events up
5. **Types**: Presentational (dumb) vs Container (smart)
6. **Communication**: Props, events, context, or event bus
7. **Modern Patterns**: Hooks, HOCs, render props

The Component Pattern is the foundation of modern frameworks like React, Vue, and Angular, enabling scalable and maintainable UI development!