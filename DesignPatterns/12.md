# Chapter 12: Proxy Pattern

## 12.1 Concept and Types

### What is the Proxy Pattern?

The Proxy Pattern provides a **surrogate or placeholder** for another object to control access to it. The proxy has the same interface as the real object, so clients can use it interchangeably.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     PROXY PATTERN                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚   â”‚  Client  â”‚â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   Proxy  â”‚â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Real    â”‚      â”‚
â”‚   â”‚          â”‚        â”‚          â”‚        â”‚  Subject â”‚      â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                             â”‚                               â”‚
â”‚                             â”‚ Controls:                     â”‚
â”‚                             â”‚ â€¢ Access                      â”‚
â”‚                             â”‚ â€¢ Caching                     â”‚
â”‚                             â”‚ â€¢ Logging                     â”‚
â”‚                             â”‚ â€¢ Lazy loading                â”‚
â”‚                             â”‚ â€¢ Validation                  â”‚
â”‚                                                             â”‚
â”‚   Both Proxy and Real Subject implement SAME interface      â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Types of Proxies

| Type | Purpose | Example |
|------|---------|---------|
| **Virtual Proxy** | Lazy initialization, deferred loading | Load image on demand |
| **Protection Proxy** | Access control, permissions | Role-based access |
| **Caching Proxy** | Store results for repeated requests | API response cache |
| **Logging Proxy** | Track operations | Audit logs |
| **Remote Proxy** | Represent remote objects locally | RPC, API clients |
| **Smart Reference** | Additional actions on access | Reference counting |

---

## 12.2 ES6 Proxy API

JavaScript has a **built-in Proxy object** that enables powerful metaprogramming.

### Proxy Fundamentals

```javascript
// Syntax: new Proxy(target, handler)
// target: The object to wrap
// handler: Object with "traps" (interceptor methods)

const target = {
  name: 'John',
  age: 30
};

const handler = {
  // Trap for property access
  get(target, property, receiver) {
    console.log(`Getting property: ${property}`);
    return Reflect.get(target, property, receiver);
  },
  
  // Trap for property assignment
  set(target, property, value, receiver) {
    console.log(`Setting property: ${property} = ${value}`);
    return Reflect.set(target, property, value, receiver);
  }
};

const proxy = new Proxy(target, handler);

proxy.name;       // "Getting property: name" â†’ "John"
proxy.age = 31;   // "Setting property: age = 31"
```

### Available Handler Traps

```javascript
const allTrapsHandler = {
  // Property access
  get(target, prop, receiver) {},
  set(target, prop, value, receiver) {},
  has(target, prop) {},                    // 'prop' in proxy
  deleteProperty(target, prop) {},         // delete proxy.prop
  
  // Function calls
  apply(target, thisArg, argumentsList) {}, // proxy()
  construct(target, args, newTarget) {},    // new proxy()
  
  // Object operations
  getOwnPropertyDescriptor(target, prop) {},
  defineProperty(target, prop, descriptor) {},
  getPrototypeOf(target) {},
  setPrototypeOf(target, proto) {},
  isExtensible(target) {},
  preventExtensions(target) {},
  ownKeys(target) {}                       // Object.keys(), for...in
};
```

### Reflect API

Always use `Reflect` methods inside handlers to perform the default operation:

```javascript
const handler = {
  get(target, prop, receiver) {
    // Do custom logic
    console.log(`Accessing: ${prop}`);
    
    // Use Reflect for default behavior
    return Reflect.get(target, prop, receiver);
  },
  
  set(target, prop, value, receiver) {
    // Validation
    if (prop === 'age' && value < 0) {
      throw new Error('Age cannot be negative');
    }
    
    // Use Reflect to actually set the property
    return Reflect.set(target, prop, value, receiver);
  }
};
```

---

## 12.3 Proxy Implementations

### Virtual Proxy (Lazy Loading)

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Heavy object that's expensive to create
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class HeavyImage {
  constructor(filename) {
    this.filename = filename;
    this.loadImage(); // Expensive operation
  }
  
  loadImage() {
    console.log(`Loading heavy image: ${this.filename}`);
    // Simulate loading large image
    this.data = new Array(1000000).fill('pixel');
  }
  
  display() {
    console.log(`Displaying: ${this.filename}`);
  }
  
  getInfo() {
    return {
      filename: this.filename,
      size: this.data.length
    };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Virtual Proxy - Defers creation until needed
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class ImageProxy {
  constructor(filename) {
    this.filename = filename;
    this.realImage = null; // Not created yet
  }
  
  // Lazy initialization
  #getRealImage() {
    if (!this.realImage) {
      console.log('Creating real image (first access)...');
      this.realImage = new HeavyImage(this.filename);
    }
    return this.realImage;
  }
  
  display() {
    // Now we need the real image
    this.#getRealImage().display();
  }
  
  getInfo() {
    // Can provide basic info without loading
    if (!this.realImage) {
      return { filename: this.filename, size: 'unknown (not loaded)' };
    }
    return this.realImage.getInfo();
  }
}

// Usage
const images = [
  new ImageProxy('photo1.jpg'),
  new ImageProxy('photo2.jpg'),
  new ImageProxy('photo3.jpg')
];

// Images NOT loaded yet
console.log(images[0].getInfo()); // { filename: 'photo1.jpg', size: 'unknown' }

// Only loads when display() is called
images[0].display(); // NOW it loads
console.log(images[0].getInfo()); // { filename: 'photo1.jpg', size: 1000000 }
```

### Protection Proxy (Access Control)

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Resource that needs access control
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class BankAccount {
  constructor(owner, balance) {
    this.owner = owner;
    this.balance = balance;
    this.transactions = [];
  }
  
  deposit(amount) {
    this.balance += amount;
    this.transactions.push({ type: 'deposit', amount, date: new Date() });
    return this.balance;
  }
  
  withdraw(amount) {
    if (amount > this.balance) {
      throw new Error('Insufficient funds');
    }
    this.balance -= amount;
    this.transactions.push({ type: 'withdraw', amount, date: new Date() });
    return amount;
  }
  
  getBalance() {
    return this.balance;
  }
  
  getTransactions() {
    return [...this.transactions];
  }
  
  transfer(toAccount, amount) {
    this.withdraw(amount);
    toAccount.deposit(amount);
    return true;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Protection Proxy - Role-based access control
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function createBankAccountProxy(account, currentUser) {
  const permissions = {
    owner: ['deposit', 'withdraw', 'getBalance', 'getTransactions', 'transfer'],
    manager: ['deposit', 'withdraw', 'getBalance', 'getTransactions'],
    teller: ['deposit', 'getBalance'],
    auditor: ['getBalance', 'getTransactions']
  };
  
  return new Proxy(account, {
    get(target, property, receiver) {
      // Allow non-function properties
      if (typeof target[property] !== 'function') {
        return Reflect.get(target, property, receiver);
      }
      
      // Check permissions for methods
      const userRole = currentUser.role;
      const allowedMethods = permissions[userRole] || [];
      
      if (!allowedMethods.includes(property)) {
        return () => {
          throw new Error(
            `Access denied: ${currentUser.name} (${userRole}) cannot perform ${property}`
          );
        };
      }
      
      // Log access
      console.log(`[AUDIT] ${currentUser.name} accessed ${property}`);
      
      // Return bound method
      return target[property].bind(target);
    },
    
    set(target, property, value) {
      // Prevent direct property modification
      throw new Error('Cannot modify account properties directly');
    }
  });
}

// Usage
const realAccount = new BankAccount('John Doe', 10000);

// Different users get different access
const ownerProxy = createBankAccountProxy(realAccount, { name: 'John', role: 'owner' });
const tellerProxy = createBankAccountProxy(realAccount, { name: 'Jane', role: 'teller' });
const auditorProxy = createBankAccountProxy(realAccount, { name: 'Bob', role: 'auditor' });

// Owner can do everything
ownerProxy.deposit(500);     // âœ… Works
ownerProxy.withdraw(200);    // âœ… Works
ownerProxy.getTransactions(); // âœ… Works

// Teller has limited access
tellerProxy.deposit(100);    // âœ… Works
tellerProxy.withdraw(50);    // âŒ Error: Access denied

// Auditor can only view
auditorProxy.getBalance();   // âœ… Works
auditorProxy.getTransactions(); // âœ… Works
auditorProxy.deposit(100);   // âŒ Error: Access denied
```

### Caching Proxy

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// API Service (expensive calls)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class UserAPIService {
  async getUser(userId) {
    console.log(`API: Fetching user ${userId} from server...`);
    // Simulate API call
    await new Promise(r => setTimeout(r, 1000));
    return {
      id: userId,
      name: `User ${userId}`,
      email: `user${userId}@example.com`,
      fetchedAt: new Date().toISOString()
    };
  }
  
  async getUsers() {
    console.log('API: Fetching all users from server...');
    await new Promise(r => setTimeout(r, 2000));
    return [
      { id: 1, name: 'Alice' },
      { id: 2, name: 'Bob' },
      { id: 3, name: 'Charlie' }
    ];
  }
  
  async updateUser(userId, data) {
    console.log(`API: Updating user ${userId}...`);
    await new Promise(r => setTimeout(r, 500));
    return { ...data, id: userId, updatedAt: new Date().toISOString() };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Caching Proxy with TTL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function createCachingProxy(apiService, ttl = 60000) {
  const cache = new Map();
  
  function getCacheKey(method, args) {
    return `${method}:${JSON.stringify(args)}`;
  }
  
  function isExpired(cacheEntry) {
    return Date.now() - cacheEntry.timestamp > ttl;
  }
  
  // Methods that should invalidate cache
  const writeMethods = ['updateUser', 'deleteUser', 'createUser'];
  
  return new Proxy(apiService, {
    get(target, property) {
      const original = target[property];
      
      if (typeof original !== 'function') {
        return original;
      }
      
      return async function(...args) {
        // Write methods: invalidate cache and execute
        if (writeMethods.includes(property)) {
          console.log('Cache: Invalidating due to write operation');
          cache.clear();
          return original.apply(target, args);
        }
        
        // Read methods: check cache first
        const key = getCacheKey(property, args);
        const cached = cache.get(key);
        
        if (cached && !isExpired(cached)) {
          console.log(`Cache: HIT for ${key}`);
          return cached.value;
        }
        
        console.log(`Cache: MISS for ${key}`);
        const result = await original.apply(target, args);
        
        cache.set(key, {
          value: result,
          timestamp: Date.now()
        });
        
        return result;
      };
    }
  });
}

// Usage
const api = new UserAPIService();
const cachedAPI = createCachingProxy(api, 30000); // 30 second TTL

// First call - cache miss, hits server
await cachedAPI.getUser(1);  // Takes 1 second

// Second call - cache hit, instant
await cachedAPI.getUser(1);  // Instant!

// Different user - cache miss
await cachedAPI.getUser(2);  // Takes 1 second

// Update invalidates cache
await cachedAPI.updateUser(1, { name: 'Updated' });

// Cache was cleared, hits server again
await cachedAPI.getUser(1);  // Takes 1 second
```

### Validation Proxy

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Create validated objects with schema
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function createValidatedObject(target, schema) {
  return new Proxy(target, {
    set(obj, prop, value) {
      const validator = schema[prop];
      
      if (!validator) {
        // No validation for this property
        return Reflect.set(obj, prop, value);
      }
      
      const { type, required, min, max, pattern, custom } = validator;
      
      // Required check
      if (required && (value === null || value === undefined)) {
        throw new Error(`${prop} is required`);
      }
      
      // Type check
      if (type && typeof value !== type) {
        throw new TypeError(`${prop} must be of type ${type}, got ${typeof value}`);
      }
      
      // Min/Max for numbers
      if (typeof value === 'number') {
        if (min !== undefined && value < min) {
          throw new RangeError(`${prop} must be at least ${min}`);
        }
        if (max !== undefined && value > max) {
          throw new RangeError(`${prop} must be at most ${max}`);
        }
      }
      
      // Min/Max for strings (length)
      if (typeof value === 'string') {
        if (min !== undefined && value.length < min) {
          throw new RangeError(`${prop} must be at least ${min} characters`);
        }
        if (max !== undefined && value.length > max) {
          throw new RangeError(`${prop} must be at most ${max} characters`);
        }
      }
      
      // Pattern for strings
      if (pattern && typeof value === 'string' && !pattern.test(value)) {
        throw new Error(`${prop} does not match required pattern`);
      }
      
      // Custom validator
      if (custom) {
        const result = custom(value);
        if (result !== true) {
          throw new Error(result || `${prop} failed custom validation`);
        }
      }
      
      return Reflect.set(obj, prop, value);
    },
    
    deleteProperty(obj, prop) {
      const validator = schema[prop];
      if (validator?.required) {
        throw new Error(`Cannot delete required property: ${prop}`);
      }
      return Reflect.deleteProperty(obj, prop);
    }
  });
}

// Define schema
const userSchema = {
  name: {
    type: 'string',
    required: true,
    min: 2,
    max: 50
  },
  email: {
    type: 'string',
    required: true,
    pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  },
  age: {
    type: 'number',
    min: 0,
    max: 150
  },
  password: {
    type: 'string',
    required: true,
    min: 8,
    custom: (value) => {
      if (!/[A-Z]/.test(value)) return 'Password must contain uppercase letter';
      if (!/[0-9]/.test(value)) return 'Password must contain number';
      return true;
    }
  }
};

// Usage
const user = createValidatedObject({}, userSchema);

user.name = 'John Doe';           // âœ… Valid
user.email = 'john@example.com';  // âœ… Valid
user.age = 30;                    // âœ… Valid
user.password = 'SecurePass123';  // âœ… Valid

// These will throw errors:
// user.name = 'J';               // âŒ RangeError: name must be at least 2 characters
// user.email = 'invalid';        // âŒ Error: email does not match required pattern
// user.age = -5;                 // âŒ RangeError: age must be at least 0
// user.password = 'weak';        // âŒ Error: Password must contain uppercase letter
// delete user.name;              // âŒ Error: Cannot delete required property: name
```

### Logging/Monitoring Proxy

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Create proxy that logs all operations
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function createMonitoringProxy(target, options = {}) {
  const {
    name = 'Object',
    logGets = true,
    logSets = true,
    logCalls = true,
    onAccess = null
  } = options;
  
  const stats = {
    gets: {},
    sets: {},
    calls: {}
  };
  
  return new Proxy(target, {
    get(obj, prop, receiver) {
      const value = Reflect.get(obj, prop, receiver);
      
      // Track statistics
      stats.gets[prop] = (stats.gets[prop] || 0) + 1;
      
      if (logGets && typeof value !== 'function') {
        console.log(`[${name}] GET ${String(prop)} â†’ ${JSON.stringify(value)}`);
      }
      
      if (onAccess) {
        onAccess({ type: 'get', property: prop, value });
      }
      
      // Wrap functions to monitor calls
      if (typeof value === 'function') {
        return function(...args) {
          stats.calls[prop] = (stats.calls[prop] || 0) + 1;
          
          if (logCalls) {
            console.log(`[${name}] CALL ${String(prop)}(${args.map(a => JSON.stringify(a)).join(', ')})`);
          }
          
          const startTime = performance.now();
          const result = value.apply(this === receiver ? obj : this, args);
          const duration = performance.now() - startTime;
          
          if (logCalls) {
            console.log(`[${name}] RETURN ${String(prop)} â†’ ${JSON.stringify(result)} (${duration.toFixed(2)}ms)`);
          }
          
          return result;
        };
      }
      
      return value;
    },
    
    set(obj, prop, value, receiver) {
      const oldValue = obj[prop];
      stats.sets[prop] = (stats.sets[prop] || 0) + 1;
      
      if (logSets) {
        console.log(`[${name}] SET ${String(prop)}: ${JSON.stringify(oldValue)} â†’ ${JSON.stringify(value)}`);
      }
      
      if (onAccess) {
        onAccess({ type: 'set', property: prop, oldValue, newValue: value });
      }
      
      return Reflect.set(obj, prop, value, receiver);
    }
  });
  
  // Attach stats getter
  Object.defineProperty(target, '__stats__', {
    get: () => ({ ...stats }),
    enumerable: false
  });
  
  return new Proxy(target, handler);
}

// Usage
const calculator = createMonitoringProxy({
  value: 0,
  add(n) {
    this.value += n;
    return this.value;
  },
  multiply(n) {
    this.value *= n;
    return this.value;
  }
}, { name: 'Calculator' });

calculator.add(5);
// [Calculator] CALL add(5)
// [Calculator] GET value â†’ 0
// [Calculator] SET value: 0 â†’ 5
// [Calculator] RETURN add â†’ 5 (0.15ms)

calculator.multiply(3);
// [Calculator] CALL multiply(3)
// [Calculator] GET value â†’ 5
// [Calculator] SET value: 5 â†’ 15
// [Calculator] RETURN multiply â†’ 15 (0.12ms)

console.log(calculator.value);
// [Calculator] GET value â†’ 15
```

---

## 12.4 Revocable Proxies

```javascript
// Proxy.revocable creates a proxy that can be disabled
const target = { secret: 'classified data' };

const { proxy, revoke } = Proxy.revocable(target, {
  get(obj, prop) {
    console.log(`Accessing: ${prop}`);
    return obj[prop];
  }
});

console.log(proxy.secret); // "Accessing: secret" â†’ "classified data"

// Later, revoke access
revoke();

// Now any operation throws TypeError
try {
  console.log(proxy.secret);
} catch (e) {
  console.log('Access revoked:', e.message);
  // "Cannot perform 'get' on a proxy that has been revoked"
}

// Use case: Temporary access tokens
function createTemporaryAccess(resource, durationMs) {
  const { proxy, revoke } = Proxy.revocable(resource, {});
  
  // Auto-revoke after duration
  setTimeout(() => {
    console.log('Access expired');
    revoke();
  }, durationMs);
  
  return proxy;
}

const tempAccess = createTemporaryAccess({ data: 'sensitive' }, 5000);
console.log(tempAccess.data); // Works for 5 seconds
// After 5 seconds: TypeError
```

---

## 12.5 Vue.js Reactivity (Real-World Example)

```javascript
// Simplified version of Vue 3's reactivity system
function reactive(target) {
  const handlers = {
    get(obj, prop, receiver) {
      const value = Reflect.get(obj, prop, receiver);
      
      // Track dependency
      track(obj, prop);
      
      // Make nested objects reactive too
      if (typeof value === 'object' && value !== null) {
        return reactive(value);
      }
      
      return value;
    },
    
    set(obj, prop, value, receiver) {
      const oldValue = obj[prop];
      const result = Reflect.set(obj, prop, value, receiver);
      
      // Trigger updates if value changed
      if (oldValue !== value) {
        trigger(obj, prop);
      }
      
      return result;
    }
  };
  
  return new Proxy(target, handlers);
}

// Dependency tracking (simplified)
let activeEffect = null;
const targetMap = new WeakMap();

function track(target, prop) {
  if (!activeEffect) return;
  
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }
  
  let dep = depsMap.get(prop);
  if (!dep) {
    depsMap.set(prop, (dep = new Set()));
  }
  
  dep.add(activeEffect);
}

function trigger(target, prop) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;
  
  const dep = depsMap.get(prop);
  if (dep) {
    dep.forEach(effect => effect());
  }
}

function watchEffect(fn) {
  activeEffect = fn;
  fn(); // Run once to collect dependencies
  activeEffect = null;
}

// Usage (like Vue 3)
const state = reactive({
  count: 0,
  user: { name: 'John' }
});

watchEffect(() => {
  console.log(`Count is: ${state.count}`);
});

state.count++; // Automatically logs: "Count is: 1"
state.count++; // Automatically logs: "Count is: 2"
```

---

## Key Takeaways

1. **Proxy controls access** - Same interface, different behavior
2. **ES6 Proxy is powerful** - Built-in metaprogramming
3. **Use Reflect** - For default operations in handlers
4. **Types**: Virtual, Protection, Caching, Logging, Remote
5. **Revocable proxies** - For temporary access
6. **Real-world uses**: Vue reactivity, validation, ORM

> âš ï¸ **Performance Note:** Proxies have overhead. Avoid in hot paths or high-frequency operations. Profile before using extensively.

> ğŸ’¡ **Interview Tip:** Be ready to implement a caching proxy or validation proxy. Explain how Vue 3 uses Proxy for reactivity.
