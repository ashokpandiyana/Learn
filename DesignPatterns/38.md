# Chapter 38: Concurrency Patterns

## Introduction

JavaScript is single-threaded, but modern web applications need to handle concurrent operations efficiently. This chapter covers patterns for managing parallelism, asynchronous operations, and multi-threaded execution using Web Workers.

---

## 38.1 Web Workers

### What are Web Workers?

Web Workers run JavaScript in background threads, enabling true parallelism without blocking the main thread.

**Types:**
- **Dedicated Workers**: Single-use workers
- **Shared Workers**: Shared across multiple contexts
- **Service Workers**: Handle network requests and caching

### Basic Web Worker Pattern

```javascript
// main.js (Main Thread)
class WorkerPool {
  constructor(workerScript, poolSize = 4) {
    this.workers = [];
    this.taskQueue = [];
    this.workerScript = workerScript;
    
    // Initialize worker pool
    for (let i = 0; i < poolSize; i++) {
      this.addWorker();
    }
  }
  
  addWorker() {
    const worker = new Worker(this.workerScript);
    worker.busy = false;
    
    worker.onmessage = (e) => {
      const { id, result, error } = e.data;
      
      // Resolve the pending task
      const task = this.taskQueue.find(t => t.id === id);
      if (task) {
        if (error) {
          task.reject(new Error(error));
        } else {
          task.resolve(result);
        }
        this.taskQueue = this.taskQueue.filter(t => t.id !== id);
      }
      
      // Worker is now available
      worker.busy = false;
      this.processQueue();
    };
    
    worker.onerror = (error) => {
      console.error('Worker error:', error);
      worker.busy = false;
      this.processQueue();
    };
    
    this.workers.push(worker);
  }
  
  execute(data) {
    return new Promise((resolve, reject) => {
      const id = Math.random().toString(36).substr(2, 9);
      
      this.taskQueue.push({
        id,
        data,
        resolve,
        reject
      });
      
      this.processQueue();
    });
  }
  
  processQueue() {
    // Find available worker
    const availableWorker = this.workers.find(w => !w.busy);
    if (!availableWorker) return;
    
    // Find pending task
    const task = this.taskQueue.find(t => !t.processing);
    if (!task) return;
    
    // Assign task to worker
    task.processing = true;
    availableWorker.busy = true;
    
    availableWorker.postMessage({
      id: task.id,
      data: task.data
    });
  }
  
  terminate() {
    this.workers.forEach(worker => worker.terminate());
    this.workers = [];
  }
}

// Usage
const pool = new WorkerPool('heavy-computation.worker.js', 4);

async function processLargeDataset(data) {
  try {
    const result = await pool.execute(data);
    console.log('Result:', result);
  } catch (error) {
    console.error('Processing failed:', error);
  }
}

// heavy-computation.worker.js (Worker Thread)
self.onmessage = function(e) {
  const { id, data } = e.data;
  
  try {
    // Perform heavy computation
    const result = heavyComputation(data);
    
    self.postMessage({ id, result });
  } catch (error) {
    self.postMessage({ id, error: error.message });
  }
};

function heavyComputation(data) {
  // CPU-intensive task
  let result = 0;
  for (let i = 0; i < 1000000; i++) {
    result += Math.sqrt(i) * data;
  }
  return result;
}
```

### Transferable Objects

For large data, use transferable objects to avoid copying:

```javascript
// main.js
const arrayBuffer = new ArrayBuffer(1024 * 1024); // 1MB
const uint8Array = new Uint8Array(arrayBuffer);

// Transfer ownership to worker (zero-copy)
worker.postMessage(
  { buffer: arrayBuffer },
  [arrayBuffer] // Transferable list
);

// arrayBuffer is now unusable in main thread
console.log(arrayBuffer.byteLength); // 0

// worker.js
self.onmessage = function(e) {
  const { buffer } = e.data;
  const array = new Uint8Array(buffer);
  
  // Process data
  for (let i = 0; i < array.length; i++) {
    array[i] = i % 256;
  }
  
  // Transfer back
  self.postMessage({ buffer }, [buffer]);
};
```

---

## 38.2 SharedArrayBuffer and Atomics

For sharing memory between threads (requires special headers for security).

### SharedArrayBuffer Pattern

```javascript
// main.js
const sharedBuffer = new SharedArrayBuffer(1024);
const sharedArray = new Int32Array(sharedBuffer);

// Create workers sharing the same memory
const workers = Array.from({ length: 4 }, () => {
  const worker = new Worker('shared-worker.js');
  worker.postMessage({ sharedBuffer });
  return worker;
});

// Wait for workers to complete using Atomics
const statusIndex = 0;
Atomics.store(sharedArray, statusIndex, workers.length); // Count of active workers

workers.forEach(worker => {
  worker.onmessage = () => {
    const remaining = Atomics.sub(sharedArray, statusIndex, 1);
    if (remaining === 1) {
      console.log('All workers completed!');
      console.log('Final array:', Array.from(sharedArray));
    }
  };
});

// shared-worker.js
self.onmessage = function(e) {
  const { sharedBuffer } = e.data;
  const sharedArray = new Int32Array(sharedBuffer);
  
  // Atomic operations to prevent race conditions
  const index = 1 + Math.floor(Math.random() * 10);
  
  // Atomically increment value
  Atomics.add(sharedArray, index, 1);
  
  self.postMessage('done');
};
```

### Lock Pattern with Atomics

```javascript
class SpinLock {
  constructor(sharedBuffer, lockIndex = 0) {
    this.sharedArray = new Int32Array(sharedBuffer);
    this.lockIndex = lockIndex;
  }
  
  lock() {
    while (true) {
      // Try to acquire lock
      const oldValue = Atomics.compareExchange(
        this.sharedArray,
        this.lockIndex,
        0, // Expected value (unlocked)
        1  // New value (locked)
      );
      
      if (oldValue === 0) {
        // Successfully acquired lock
        return;
      }
      
      // Wait before retrying (reduce CPU usage)
      Atomics.wait(this.sharedArray, this.lockIndex, 1, 10);
    }
  }
  
  unlock() {
    Atomics.store(this.sharedArray, this.lockIndex, 0);
    Atomics.notify(this.sharedArray, this.lockIndex, 1);
  }
}

// Usage in worker
const lock = new SpinLock(sharedBuffer, 0);

function criticalSection() {
  lock.lock();
  try {
    // Protected code
    sharedArray[1]++;
  } finally {
    lock.unlock();
  }
}
```

---

## 38.3 Producer-Consumer Pattern

Classic concurrency pattern for work distribution:

```javascript
class AsyncQueue {
  constructor() {
    this.queue = [];
    this.resolvers = [];
  }
  
  enqueue(item) {
    if (this.resolvers.length > 0) {
      // Consumer is waiting
      const resolve = this.resolvers.shift();
      resolve(item);
    } else {
      // Add to queue
      this.queue.push(item);
    }
  }
  
  dequeue() {
    if (this.queue.length > 0) {
      // Item available
      return Promise.resolve(this.queue.shift());
    } else {
      // Wait for producer
      return new Promise(resolve => {
        this.resolvers.push(resolve);
      });
    }
  }
  
  size() {
    return this.queue.length;
  }
}

// Producer
async function producer(queue, taskCount) {
  for (let i = 0; i < taskCount; i++) {
    const task = { id: i, data: `Task ${i}` };
    queue.enqueue(task);
    console.log('Produced:', task.id);
    await new Promise(r => setTimeout(r, 100)); // Simulate work
  }
  
  // Signal completion
  queue.enqueue(null);
}

// Consumer
async function consumer(id, queue) {
  while (true) {
    const task = await queue.dequeue();
    
    if (task === null) {
      console.log(`Consumer ${id} finished`);
      queue.enqueue(null); // Pass signal to next consumer
      break;
    }
    
    console.log(`Consumer ${id} processing:`, task.id);
    await new Promise(r => setTimeout(r, 200)); // Simulate processing
  }
}

// Usage
const queue = new AsyncQueue();

producer(queue, 10);
consumer(1, queue);
consumer(2, queue);
consumer(3, queue);
```

---

## 38.4 Object Pool Pattern

Reuse expensive objects instead of creating new ones:

```javascript
class ObjectPool {
  constructor(factory, resetFn, initialSize = 10, maxSize = 50) {
    this.factory = factory;
    this.resetFn = resetFn;
    this.maxSize = maxSize;
    this.available = [];
    this.inUse = new Set();
    
    // Pre-create objects
    for (let i = 0; i < initialSize; i++) {
      this.available.push(this.factory());
    }
  }
  
  acquire() {
    let obj;
    
    if (this.available.length > 0) {
      // Reuse existing object
      obj = this.available.pop();
    } else if (this.inUse.size < this.maxSize) {
      // Create new object
      obj = this.factory();
    } else {
      // Pool exhausted
      throw new Error('Object pool exhausted');
    }
    
    this.inUse.add(obj);
    return obj;
  }
  
  release(obj) {
    if (!this.inUse.has(obj)) {
      throw new Error('Object not from this pool');
    }
    
    this.inUse.delete(obj);
    
    // Reset and return to pool
    this.resetFn(obj);
    this.available.push(obj);
  }
  
  stats() {
    return {
      available: this.available.length,
      inUse: this.inUse.size,
      total: this.available.length + this.inUse.size
    };
  }
}

// Example: Database connection pool
class DatabaseConnection {
  constructor(id) {
    this.id = id;
    this.isConnected = true;
  }
  
  query(sql) {
    return `Executing: ${sql} on connection ${this.id}`;
  }
}

const connectionPool = new ObjectPool(
  // Factory function
  () => {
    const id = Math.random().toString(36).substr(2, 9);
    return new DatabaseConnection(id);
  },
  // Reset function
  (conn) => {
    conn.isConnected = true;
  },
  5,  // Initial size
  20  // Max size
);

// Usage
async function performDatabaseOperations() {
  const conn = connectionPool.acquire();
  
  try {
    const result = conn.query('SELECT * FROM users');
    console.log(result);
  } finally {
    // Always release back to pool
    connectionPool.release(conn);
  }
  
  console.log('Pool stats:', connectionPool.stats());
}
```

---

## 38.5 Semaphore Pattern

Limit concurrent access to a resource:

```javascript
class Semaphore {
  constructor(maxConcurrency) {
    this.maxConcurrency = maxConcurrency;
    this.currentConcurrency = 0;
    this.queue = [];
  }
  
  async acquire() {
    if (this.currentConcurrency < this.maxConcurrency) {
      this.currentConcurrency++;
      return;
    }
    
    // Wait in queue
    await new Promise(resolve => {
      this.queue.push(resolve);
    });
  }
  
  release() {
    if (this.queue.length > 0) {
      // Wake up next waiting task
      const resolve = this.queue.shift();
      resolve();
    } else {
      this.currentConcurrency--;
    }
  }
  
  async execute(fn) {
    await this.acquire();
    try {
      return await fn();
    } finally {
      this.release();
    }
  }
}

// Usage: Limit concurrent API requests
const apiSemaphore = new Semaphore(3); // Max 3 concurrent requests

async function fetchData(url) {
  return apiSemaphore.execute(async () => {
    console.log(`Fetching: ${url}`);
    const response = await fetch(url);
    return response.json();
  });
}

// Fire 10 requests, but only 3 will run concurrently
const urls = Array.from({ length: 10 }, (_, i) => 
  `https://api.example.com/data/${i}`
);

const results = await Promise.all(
  urls.map(url => fetchData(url))
);
```

---

## 38.6 Async Iteration Patterns

### Parallel Iteration with Limits

```javascript
async function parallelMap(array, asyncFn, concurrency = 5) {
  const semaphore = new Semaphore(concurrency);
  
  return Promise.all(
    array.map(item => 
      semaphore.execute(() => asyncFn(item))
    )
  );
}

// Usage
const userIds = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const users = await parallelMap(
  userIds,
  async (id) => {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
  },
  3 // Max 3 concurrent requests
);
```

### Batching Pattern

Process items in batches:

```javascript
async function processBatch(items, batchSize, processor) {
  const results = [];
  
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize);
    console.log(`Processing batch ${i / batchSize + 1}`);
    
    const batchResults = await Promise.all(
      batch.map(item => processor(item))
    );
    
    results.push(...batchResults);
    
    // Optional: delay between batches
    if (i + batchSize < items.length) {
      await new Promise(r => setTimeout(r, 1000));
    }
  }
  
  return results;
}

// Usage
const results = await processBatch(
  largeArray,
  50, // Process 50 items at a time
  async (item) => processItem(item)
);
```

---

## 38.7 Race Conditions and Solutions

### Problem: Race Condition

```javascript
// INCORRECT - Race condition!
let balance = 1000;

async function withdraw(amount) {
  const currentBalance = balance;
  await new Promise(r => setTimeout(r, 10)); // Simulate async operation
  balance = currentBalance - amount;
}

// Both withdrawals might succeed even if total > balance
Promise.all([
  withdraw(600),
  withdraw(600)
]);
```

### Solution 1: Mutex Lock

```javascript
class Mutex {
  constructor() {
    this.locked = false;
    this.queue = [];
  }
  
  async lock() {
    if (!this.locked) {
      this.locked = true;
      return;
    }
    
    await new Promise(resolve => {
      this.queue.push(resolve);
    });
  }
  
  unlock() {
    if (this.queue.length > 0) {
      const resolve = this.queue.shift();
      resolve();
    } else {
      this.locked = false;
    }
  }
  
  async runExclusive(fn) {
    await this.lock();
    try {
      return await fn();
    } finally {
      this.unlock();
    }
  }
}

// Usage
const mutex = new Mutex();
let balance = 1000;

async function withdraw(amount) {
  return mutex.runExclusive(async () => {
    if (balance >= amount) {
      const currentBalance = balance;
      await new Promise(r => setTimeout(r, 10));
      balance = currentBalance - amount;
      return true;
    }
    return false;
  });
}

// Now safe
await Promise.all([
  withdraw(600),
  withdraw(600)
]);
console.log('Balance:', balance); // 400
```

### Solution 2: Atomic Operations (if using SharedArrayBuffer)

```javascript
const sharedBuffer = new SharedArrayBuffer(4);
const balanceArray = new Int32Array(sharedBuffer);
Atomics.store(balanceArray, 0, 1000);

function atomicWithdraw(amount) {
  while (true) {
    const currentBalance = Atomics.load(balanceArray, 0);
    
    if (currentBalance < amount) {
      return false;
    }
    
    const newBalance = currentBalance - amount;
    const exchanged = Atomics.compareExchange(
      balanceArray,
      0,
      currentBalance,
      newBalance
    );
    
    if (exchanged === currentBalance) {
      return true; // Success
    }
    // Retry if another thread modified the value
  }
}
```

---

## 38.8 Best Practices

1. **Use Workers for CPU-Intensive Tasks**
   - Image processing
   - Data parsing
   - Encryption/decryption
   - Complex calculations

2. **Avoid Overusing Workers**
   - Worker creation has overhead
   - Use worker pools for repeated tasks

3. **Implement Proper Cleanup**
   ```javascript
   window.addEventListener('beforeunload', () => {
     workerPool.terminate();
   });
   ```

4. **Handle Worker Errors**
   ```javascript
   worker.onerror = (error) => {
     console.error('Worker error:', error);
     // Restart worker or notify user
   };
   ```

5. **Use Transferable Objects for Large Data**

6. **Limit Concurrency**
   - Use semaphores or queues
   - Prevent resource exhaustion

7. **Test Concurrent Code Thoroughly**
   - Race conditions are hard to reproduce
   - Use stress tests

8. **Consider Browser Support**
   - SharedArrayBuffer requires specific headers
   - Provide fallbacks for older browsers

---

## Summary

Concurrency patterns in JavaScript enable:
- **True parallelism** with Web Workers
- **Resource management** with object pools and semaphores
- **Safe concurrent access** with mutexes and atomic operations
- **Efficient task distribution** with producer-consumer patterns
- **Controlled execution** with batch processing and rate limiting

These patterns are essential for building high-performance applications that handle intensive computations without blocking the user interface.