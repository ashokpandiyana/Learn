# Chapter 7: Constructor Pattern

## 7.1 Traditional Constructor Functions

### What is the Constructor Pattern?

The Constructor Pattern uses **constructor functions** (or classes) to create new objects. When called with the `new` keyword, a constructor creates a new instance with its own properties and access to shared methods via the prototype.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  CONSTRUCTOR PATTERN                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   function Person(name) {        new Person('John')         â”‚
â”‚     this.name = name;                  â”‚                    â”‚
â”‚   }                                    â–¼                    â”‚
â”‚                                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚   Person.prototype.greet =      â”‚   Object    â”‚             â”‚
â”‚     function() {...}            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤             â”‚
â”‚                                 â”‚ name: 'John'â”‚             â”‚
â”‚                                 â”‚ [[Proto]] â”€â”€â”¼â”€â”€â–º Person.prototype
â”‚                                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚      â”‚
â”‚                                                      â–¼      â”‚
â”‚                                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚                                              â”‚ greet()   â”‚  â”‚
â”‚                                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### The `new` Keyword Mechanics

When you call a function with `new`, JavaScript performs these steps:

```javascript
function User(name, email) {
  // 1. Create a new empty object
  // 2. Set the object's [[Prototype]] to User.prototype
  // 3. Bind 'this' to the new object
  // 4. Execute the constructor code
  this.name = name;
  this.email = email;
  this.createdAt = new Date();
  // 5. Return 'this' (unless explicit return of object)
}

// What happens behind the scenes:
function simulateNew(Constructor, ...args) {
  // Step 1 & 2: Create object with correct prototype
  const obj = Object.create(Constructor.prototype);
  
  // Step 3 & 4: Execute constructor with 'this' bound to new object
  const result = Constructor.apply(obj, args);
  
  // Step 5: Return object (or explicit return value if it's an object)
  return (typeof result === 'object' && result !== null) ? result : obj;
}

// These are equivalent:
const user1 = new User('John', 'john@example.com');
const user2 = simulateNew(User, 'John', 'john@example.com');
```

### Constructor vs Prototype Properties

```javascript
function Car(make, model, year) {
  // Instance properties - unique to each instance
  this.make = make;
  this.model = model;
  this.year = year;
  this.mileage = 0;
  
  // âŒ BAD: Method on instance (duplicated in memory)
  // this.drive = function(miles) {
  //   this.mileage += miles;
  // };
}

// âœ… GOOD: Method on prototype (shared by all instances)
Car.prototype.drive = function(miles) {
  this.mileage += miles;
  console.log(`${this.make} ${this.model} drove ${miles} miles. Total: ${this.mileage}`);
};

Car.prototype.getInfo = function() {
  return `${this.year} ${this.make} ${this.model} (${this.mileage} miles)`;
};

// Static method (on constructor, not instances)
Car.compare = function(car1, car2) {
  return car1.mileage - car2.mileage;
};

// Usage
const car1 = new Car('Toyota', 'Camry', 2020);
const car2 = new Car('Honda', 'Civic', 2021);

car1.drive(100);
car2.drive(50);

// Both share the same method
console.log(car1.drive === car2.drive); // true

// Static method called on constructor
console.log(Car.compare(car1, car2)); // 50 (car1 has more mileage)
```

### Memory Comparison

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           METHODS ON INSTANCE vs PROTOTYPE                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  âŒ METHODS ON INSTANCE (Wasteful):                         â”‚
â”‚                                                             â”‚
â”‚  car1                    car2                    car3       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚ make: Toyota â”‚       â”‚ make: Honda  â”‚       â”‚ make: Ford   â”‚
â”‚  â”‚ drive: fn â”€â”€â”€â”¼â”€â”€â”    â”‚ drive: fn â”€â”€â”€â”¼â”€â”€â”    â”‚ drive: fn â”€â”€â”€â”¼â”€â”€â”
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                    â–¼                      â–¼                      â–¼
â”‚               [Function]            [Function]            [Function]
â”‚               (copy 1)              (copy 2)              (copy 3)
â”‚                                                             â”‚
â”‚  âœ… METHODS ON PROTOTYPE (Efficient):                       â”‚
â”‚                                                             â”‚
â”‚  car1              car2              car3                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ make: Toyota â”‚ â”‚ make: Honda  â”‚ â”‚ make: Ford   â”‚         â”‚
â”‚  â”‚ [[Proto]] â”€â”€â”€â”¼â”€â”¼â”€â”€[[Proto]] â”€â”€â”¼â”€â”¼â”€â”€[[Proto]] â”€â”€â”¼â”€â”€â”      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚      â”‚
â”‚                                                      â–¼      â”‚
â”‚                                              Car.prototype  â”‚
â”‚                                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚                                              â”‚ drive: fn  â”‚ â”‚
â”‚                                              â”‚ getInfo: fnâ”‚ â”‚
â”‚                                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                              (single copy)  â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### The "Forgetting new" Problem

```javascript
function User(name) {
  this.name = name;
}

// Correct usage
const user1 = new User('John'); // âœ… Works correctly
console.log(user1.name); // 'John'

// Forgetting 'new'
const user2 = User('Jane'); // âŒ 'this' is global/undefined
console.log(user2); // undefined
console.log(globalThis.name); // 'Jane' (polluted global!)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SOLUTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Solution 1: Check instanceof
function SafeUser(name) {
  if (!(this instanceof SafeUser)) {
    return new SafeUser(name);
  }
  this.name = name;
}

const user3 = SafeUser('Bob'); // Works even without 'new'
console.log(user3.name); // 'Bob'

// Solution 2: Use new.target (ES6)
function ModernUser(name) {
  if (!new.target) {
    throw new Error('ModernUser must be called with new');
  }
  this.name = name;
}

// Solution 3: Use ES6 Classes (enforced by default)
class ClassUser {
  constructor(name) {
    this.name = name;
  }
}

// const user4 = ClassUser('Test'); // TypeError: Class constructor cannot be invoked without 'new'
```

### Constructor Return Value Behavior

```javascript
function ReturnsObject(name) {
  this.name = name;
  // Returning an object overrides the new instance
  return { customProperty: 'This replaces the instance' };
}

function ReturnsPrimitive(name) {
  this.name = name;
  // Returning a primitive is ignored
  return 'This is ignored';
}

function ReturnsNothing(name) {
  this.name = name;
  // Implicit return of 'this'
}

const obj1 = new ReturnsObject('Test');
console.log(obj1.name); // undefined
console.log(obj1.customProperty); // 'This replaces the instance'

const obj2 = new ReturnsPrimitive('Test');
console.log(obj2.name); // 'Test' (primitive return ignored)

const obj3 = new ReturnsNothing('Test');
console.log(obj3.name); // 'Test'
```

---

## 7.2 ES6 Classes

### Class Syntax and Semantics

ES6 classes are **syntactic sugar** over constructor functions, but with cleaner syntax and some enforced rules.

```javascript
class Animal {
  // Constructor
  constructor(name, species) {
    this.name = name;
    this.species = species;
    this.energy = 100;
  }
  
  // Instance methods (on prototype)
  eat(food) {
    console.log(`${this.name} eats ${food}`);
    this.energy += 10;
    return this;
  }
  
  sleep(hours) {
    console.log(`${this.name} sleeps for ${hours} hours`);
    this.energy += hours * 5;
    return this;
  }
  
  play() {
    if (this.energy < 20) {
      console.log(`${this.name} is too tired to play`);
      return this;
    }
    console.log(`${this.name} plays happily`);
    this.energy -= 20;
    return this;
  }
  
  // Getter
  get status() {
    if (this.energy > 80) return 'Energetic';
    if (this.energy > 50) return 'Normal';
    if (this.energy > 20) return 'Tired';
    return 'Exhausted';
  }
  
  // Setter
  set nickname(value) {
    if (value.length < 2) {
      throw new Error('Nickname must be at least 2 characters');
    }
    this._nickname = value;
  }
  
  get nickname() {
    return this._nickname || this.name;
  }
  
  // Static method
  static isAnimal(obj) {
    return obj instanceof Animal;
  }
  
  // Static property
  static kingdom = 'Animalia';
}

// Usage
const dog = new Animal('Buddy', 'Dog');
dog.eat('kibble').play().sleep(2);
console.log(dog.status); // 'Normal'
console.log(Animal.kingdom); // 'Animalia'
console.log(Animal.isAnimal(dog)); // true
```

### Inheritance with Classes

```javascript
class Animal {
  constructor(name) {
    this.name = name;
    this.energy = 100;
  }
  
  eat(food) {
    console.log(`${this.name} eats ${food}`);
    this.energy += 10;
  }
  
  sleep(hours) {
    console.log(`${this.name} sleeps for ${hours} hours`);
    this.energy += hours * 5;
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    // MUST call super() before using 'this'
    super(name);
    this.breed = breed;
  }
  
  bark() {
    console.log(`${this.name} barks: Woof!`);
    this.energy -= 5;
  }
  
  // Override parent method
  eat(food) {
    // Call parent method
    super.eat(food);
    // Add dog-specific behavior
    if (food === 'treat') {
      console.log(`${this.name} wags tail excitedly!`);
      this.energy += 5; // Extra energy from treats
    }
  }
  
  // Dog-specific getter
  get info() {
    return `${this.name} is a ${this.breed}`;
  }
}

class Cat extends Animal {
  constructor(name, indoor = true) {
    super(name);
    this.indoor = indoor;
  }
  
  meow() {
    console.log(`${this.name} meows softly`);
    this.energy -= 3;
  }
  
  scratch() {
    console.log(`${this.name} scratches the furniture`);
  }
}

// Usage
const buddy = new Dog('Buddy', 'Golden Retriever');
buddy.eat('treat'); // 'Buddy eats treat' then 'Buddy wags tail excitedly!'
buddy.bark();        // 'Buddy barks: Woof!'
console.log(buddy.info); // 'Buddy is a Golden Retriever'

const whiskers = new Cat('Whiskers', true);
whiskers.sleep(3);   // 'Whiskers sleeps for 3 hours'
whiskers.meow();     // 'Whiskers meows softly'

// Inheritance check
console.log(buddy instanceof Dog);    // true
console.log(buddy instanceof Animal); // true
console.log(whiskers instanceof Dog); // false
```

### Private Fields (#privateField)

```javascript
class BankAccount {
  // Private fields (ES2022)
  #balance = 0;
  #transactions = [];
  #pin;
  
  // Static private field
  static #totalAccounts = 0;
  
  constructor(owner, initialDeposit, pin) {
    this.owner = owner;  // Public
    this.#pin = pin;     // Private
    this.#balance = initialDeposit;
    this.#transactions.push({
      type: 'deposit',
      amount: initialDeposit,
      date: new Date()
    });
    BankAccount.#totalAccounts++;
    
    // Generate account number
    this.accountNumber = this.#generateAccountNumber();
  }
  
  // Private method
  #generateAccountNumber() {
    return 'ACC' + Date.now().toString(36).toUpperCase();
  }
  
  #validatePin(pin) {
    return pin === this.#pin;
  }
  
  #recordTransaction(type, amount) {
    this.#transactions.push({
      type,
      amount,
      date: new Date(),
      balance: this.#balance
    });
  }
  
  // Public methods
  deposit(amount) {
    if (amount <= 0) {
      throw new Error('Deposit amount must be positive');
    }
    this.#balance += amount;
    this.#recordTransaction('deposit', amount);
    return this.#balance;
  }
  
  withdraw(amount, pin) {
    if (!this.#validatePin(pin)) {
      throw new Error('Invalid PIN');
    }
    if (amount > this.#balance) {
      throw new Error('Insufficient funds');
    }
    this.#balance -= amount;
    this.#recordTransaction('withdrawal', amount);
    return amount;
  }
  
  getBalance(pin) {
    if (!this.#validatePin(pin)) {
      throw new Error('Invalid PIN');
    }
    return this.#balance;
  }
  
  getStatement(pin) {
    if (!this.#validatePin(pin)) {
      throw new Error('Invalid PIN');
    }
    return [...this.#transactions]; // Return copy
  }
  
  // Static method with private field
  static getTotalAccounts() {
    return BankAccount.#totalAccounts;
  }
}

// Usage
const account = new BankAccount('John Doe', 1000, '1234');

account.deposit(500);
console.log(account.getBalance('1234')); // 1500

account.withdraw(200, '1234');
console.log(account.getBalance('1234')); // 1300

// Private fields are truly private
console.log(account.#balance); // SyntaxError: Private field
console.log(account.#pin);     // SyntaxError: Private field

console.log(BankAccount.getTotalAccounts()); // 1
```

---

## 7.3 Best Practices

### Validation in Constructors

```javascript
class Email {
  static #emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  
  constructor(address) {
    // Validate before assignment
    if (!address || typeof address !== 'string') {
      throw new TypeError('Email address must be a non-empty string');
    }
    
    const normalized = address.toLowerCase().trim();
    
    if (!Email.#emailRegex.test(normalized)) {
      throw new Error(`Invalid email format: ${address}`);
    }
    
    // Use Object.defineProperty for immutability
    Object.defineProperty(this, 'address', {
      value: normalized,
      writable: false,
      enumerable: true,
      configurable: false
    });
    
    // Parse email parts
    const [localPart, domain] = normalized.split('@');
    Object.defineProperty(this, 'localPart', { value: localPart, writable: false });
    Object.defineProperty(this, 'domain', { value: domain, writable: false });
  }
  
  toString() {
    return this.address;
  }
  
  equals(other) {
    if (!(other instanceof Email)) return false;
    return this.address === other.address;
  }
}

// Usage
const email = new Email('John.Doe@Example.COM');
console.log(email.address);   // 'john.doe@example.com'
console.log(email.domain);    // 'example.com'

email.address = 'hacked@evil.com'; // Fails silently (or throws in strict mode)
console.log(email.address);   // Still 'john.doe@example.com'

// new Email('invalid'); // Error: Invalid email format
```

### Default Parameter Values

```javascript
class HttpClient {
  constructor({
    baseURL = '',
    timeout = 30000,
    headers = {},
    retries = 3,
    retryDelay = 1000,
    validateStatus = (status) => status >= 200 && status < 300
  } = {}) {
    this.baseURL = baseURL;
    this.timeout = timeout;
    this.headers = {
      'Content-Type': 'application/json',
      ...headers
    };
    this.retries = retries;
    this.retryDelay = retryDelay;
    this.validateStatus = validateStatus;
  }
  
  async request(url, options = {}) {
    const fullURL = this.baseURL + url;
    const config = {
      ...options,
      headers: { ...this.headers, ...options.headers }
    };
    
    let lastError;
    
    for (let attempt = 0; attempt <= this.retries; attempt++) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);
        
        const response = await fetch(fullURL, {
          ...config,
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!this.validateStatus(response.status)) {
          throw new Error(`HTTP ${response.status}`);
        }
        
        return response;
      } catch (error) {
        lastError = error;
        if (attempt < this.retries) {
          await new Promise(r => setTimeout(r, this.retryDelay * (attempt + 1)));
        }
      }
    }
    
    throw lastError;
  }
}

// Usage with defaults
const client1 = new HttpClient();

// Usage with custom config
const client2 = new HttpClient({
  baseURL: 'https://api.example.com',
  timeout: 5000,
  headers: { 'Authorization': 'Bearer token123' },
  retries: 5
});
```

### Immutable Object Creation

```javascript
class Point {
  constructor(x, y) {
    // Validate
    if (typeof x !== 'number' || typeof y !== 'number') {
      throw new TypeError('Coordinates must be numbers');
    }
    
    // Freeze the instance
    this.x = x;
    this.y = y;
    Object.freeze(this);
  }
  
  // All operations return new instances
  add(other) {
    return new Point(this.x + other.x, this.y + other.y);
  }
  
  subtract(other) {
    return new Point(this.x - other.x, this.y - other.y);
  }
  
  scale(factor) {
    return new Point(this.x * factor, this.y * factor);
  }
  
  distanceTo(other) {
    const dx = this.x - other.x;
    const dy = this.y - other.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  
  equals(other) {
    return other instanceof Point && 
           this.x === other.x && 
           this.y === other.y;
  }
  
  toString() {
    return `Point(${this.x}, ${this.y})`;
  }
  
  // Factory methods
  static origin() {
    return new Point(0, 0);
  }
  
  static fromPolar(radius, angle) {
    return new Point(
      radius * Math.cos(angle),
      radius * Math.sin(angle)
    );
  }
}

// Usage
const p1 = new Point(3, 4);
const p2 = new Point(1, 1);

p1.x = 100; // Fails silently (frozen)
console.log(p1.x); // Still 3

const p3 = p1.add(p2);
console.log(p3.toString()); // Point(4, 5)
console.log(p1.distanceTo(Point.origin())); // 5
```

### Composition Over Inheritance

```javascript
// Instead of deep inheritance hierarchies, compose behaviors

// Behavior mixins
const canFly = {
  fly() {
    console.log(`${this.name} is flying at ${this.flySpeed} mph`);
  },
  land() {
    console.log(`${this.name} has landed`);
  }
};

const canSwim = {
  swim() {
    console.log(`${this.name} is swimming at ${this.swimSpeed} mph`);
  },
  dive(depth) {
    console.log(`${this.name} dives to ${depth} feet`);
  }
};

const canWalk = {
  walk() {
    console.log(`${this.name} is walking at ${this.walkSpeed} mph`);
  },
  run() {
    console.log(`${this.name} is running at ${this.runSpeed} mph`);
  }
};

// Compose animals with different abilities
class Duck {
  constructor(name) {
    this.name = name;
    this.flySpeed = 50;
    this.swimSpeed = 5;
    this.walkSpeed = 2;
    
    // Compose behaviors
    Object.assign(this, canFly, canSwim, canWalk);
  }
}

class Penguin {
  constructor(name) {
    this.name = name;
    this.swimSpeed = 15;
    this.walkSpeed = 1;
    
    // Penguins can swim and walk, but not fly
    Object.assign(this, canSwim, canWalk);
  }
}

class Eagle {
  constructor(name) {
    this.name = name;
    this.flySpeed = 100;
    this.walkSpeed = 3;
    
    // Eagles can fly and walk, but not swim
    Object.assign(this, canFly, canWalk);
  }
}

// Usage
const donald = new Duck('Donald');
donald.fly();   // Donald is flying at 50 mph
donald.swim();  // Donald is swimming at 5 mph
donald.walk();  // Donald is walking at 2 mph

const pingu = new Penguin('Pingu');
pingu.swim();   // Pingu is swimming at 15 mph
// pingu.fly(); // TypeError: pingu.fly is not a function
```

---

## Key Takeaways

1. **Understand `new`**: Know the 5 steps JavaScript performs
2. **Prototype methods**: Put shared methods on prototype, not instance
3. **ES6 Classes**: Cleaner syntax, enforced `new`, easier inheritance
4. **Private fields (#)**: True encapsulation in modern JavaScript
5. **Validate early**: Check inputs in constructor before assignment
6. **Consider immutability**: Use Object.freeze() for value objects
7. **Composition > Inheritance**: Mix behaviors instead of deep hierarchies

> ğŸ’¡ **Interview Tip:** Be ready to explain what happens when you forget `new`, demonstrate the prototype chain, and show how ES6 classes are syntactic sugar over constructor functions.

> âš ï¸ **Important:** Private fields (#) are not the same as TypeScript's `private` keyword. They provide runtime privacy in JavaScript!
