# Chapter 24: Template Method Pattern - In-Depth Guide

## üéØ Core Concept

The **Template Method Pattern** defines the skeleton of an algorithm in a base class, letting subclasses override specific steps without changing the algorithm's structure. It's about defining the "what" in the base class and letting subclasses define the "how."

### Visual Representation

```
AbstractClass
‚îú‚îÄ‚îÄ templateMethod() [final]
‚îÇ   ‚îú‚îÄ‚îÄ step1()        [implemented]
‚îÇ   ‚îú‚îÄ‚îÄ step2()        [abstract]
‚îÇ   ‚îî‚îÄ‚îÄ step3()        [hook]
‚îÇ
ConcreteClassA extends AbstractClass
‚îî‚îÄ‚îÄ step2()            [implemented]
    step3()            [optionally overridden]

ConcreteClassB extends AbstractClass
‚îî‚îÄ‚îÄ step2()            [implemented]
    step3()            [optionally overridden]
```

## üîë Key Components

1. **Abstract Class**: Defines the template method and declares abstract/hook methods
2. **Template Method**: Defines the algorithm skeleton (usually final/not overridable)
3. **Primitive Operations**: Abstract methods that must be implemented by subclasses
4. **Hook Methods**: Optional methods with default implementations that can be overridden

## üé¨ The Hollywood Principle

> **"Don't call us, we'll call you"**

The parent class controls the flow and calls methods on subclasses, not the other way around. This inverts control compared to typical inheritance.

## üíª Classic Implementation

```javascript
// Abstract Base Class
class DataProcessor {
  // Template Method - defines the algorithm structure
  process(data) {
    console.log('Starting data processing pipeline...\n');
    
    const validated = this.validate(data);
    if (!validated.isValid) {
      console.error('Validation failed:', validated.errors);
      return null;
    }
    
    const transformed = this.transform(validated.data);
    const enriched = this.enrich(transformed);
    const result = this.save(enriched);
    
    this.postProcess(result);
    
    console.log('\nProcessing complete!');
    return result;
  }
  
  // Hook method - optional override
  validate(data) {
    console.log('Default validation (override for custom validation)');
    return { isValid: true, data };
  }
  
  // Abstract method - must be implemented
  transform(data) {
    throw new Error('transform() must be implemented');
  }
  
  // Hook method with default implementation
  enrich(data) {
    console.log('Default enrichment: adding timestamp');
    return { ...data, processedAt: new Date() };
  }
  
  // Abstract method - must be implemented
  save(data) {
    throw new Error('save() must be implemented');
  }
  
  // Hook method - optional override
  postProcess(result) {
    console.log('Default post-processing complete');
  }
}

// Concrete Implementation 1: CSV Processor
class CSVDataProcessor extends DataProcessor {
  validate(data) {
    console.log('Validating CSV format...');
    
    if (!data || typeof data !== 'string') {
      return { isValid: false, errors: ['Invalid CSV format'] };
    }
    
    return { isValid: true, data };
  }
  
  transform(data) {
    console.log('Transforming CSV to objects...');
    
    const lines = data.trim().split('\n');
    const headers = lines[0].split(',');
    
    return lines.slice(1).map(line => {
      const values = line.split(',');
      return headers.reduce((obj, header, index) => {
        obj[header.trim()] = values[index]?.trim();
        return obj;
      }, {});
    });
  }
  
  save(data) {
    console.log('Saving to CSV database...');
    // Simulate database save
    return { id: 'csv_' + Date.now(), records: data };
  }
  
  postProcess(result) {
    console.log(`Post-processing: Indexed ${result.records.length} CSV records`);
  }
}

// Concrete Implementation 2: JSON Processor
class JSONDataProcessor extends DataProcessor {
  validate(data) {
    console.log('Validating JSON format...');
    
    try {
      const parsed = typeof data === 'string' ? JSON.parse(data) : data;
      return { isValid: true, data: parsed };
    } catch (error) {
      return { isValid: false, errors: [error.message] };
    }
  }
  
  transform(data) {
    console.log('Transforming JSON data...');
    
    // Flatten nested structures
    return Array.isArray(data) ? data : [data];
  }
  
  enrich(data) {
    console.log('Enriching JSON with metadata...');
    return data.map(item => ({
      ...item,
      processedAt: new Date(),
      source: 'json-processor',
      version: '1.0'
    }));
  }
  
  save(data) {
    console.log('Saving to JSON database...');
    return { id: 'json_' + Date.now(), records: data };
  }
}

// Usage
console.log('=== Processing CSV Data ===');
const csvProcessor = new CSVDataProcessor();
const csvData = 'name,age,city\nJohn,30,NYC\nJane,25,LA';
csvProcessor.process(csvData);

console.log('\n\n=== Processing JSON Data ===');
const jsonProcessor = new JSONDataProcessor();
const jsonData = [{ name: 'Bob', age: 35 }, { name: 'Alice', age: 28 }];
jsonProcessor.process(jsonData);
```

## üç≥ Real-World Example: Recipe System

```javascript
class Recipe {
  // Template method
  cook() {
    console.log(`\nüç≥ Starting to prepare ${this.getName()}...\n`);
    
    this.prepareIngredients();
    this.cookIngredients();
    
    if (this.shouldAddSeasoning()) {
      this.addSeasoning();
    }
    
    this.serve();
    
    console.log(`\n‚úÖ ${this.getName()} is ready!\n`);
  }
  
  // Abstract methods
  getName() {
    throw new Error('getName() must be implemented');
  }
  
  prepareIngredients() {
    throw new Error('prepareIngredients() must be implemented');
  }
  
  cookIngredients() {
    throw new Error('cookIngredients() must be implemented');
  }
  
  // Hook methods with defaults
  shouldAddSeasoning() {
    return true;
  }
  
  addSeasoning() {
    console.log('Adding salt and pepper');
  }
  
  serve() {
    console.log('Serving on a plate');
  }
}

class Pasta extends Recipe {
  getName() {
    return 'Spaghetti Carbonara';
  }
  
  prepareIngredients() {
    console.log('Step 1: Boiling water');
    console.log('Step 2: Preparing bacon');
    console.log('Step 3: Beating eggs');
    console.log('Step 4: Grating parmesan');
  }
  
  cookIngredients() {
    console.log('Step 1: Cooking spaghetti for 10 minutes');
    console.log('Step 2: Frying bacon until crispy');
    console.log('Step 3: Mixing pasta with egg mixture');
  }
  
  addSeasoning() {
    console.log('Adding black pepper and extra parmesan');
  }
  
  serve() {
    console.log('Serving in a warm bowl with parsley garnish');
  }
}

class Steak extends Recipe {
  getName() {
    return 'Grilled Ribeye Steak';
  }
  
  prepareIngredients() {
    console.log('Step 1: Taking steak out of fridge (30 min before)');
    console.log('Step 2: Patting dry with paper towel');
    console.log('Step 3: Seasoning generously with salt');
  }
  
  cookIngredients() {
    console.log('Step 1: Heating grill to high heat');
    console.log('Step 2: Searing 4 minutes per side');
    console.log('Step 3: Resting for 5 minutes');
  }
  
  shouldAddSeasoning() {
    return false; // Already seasoned in preparation
  }
  
  serve() {
    console.log('Slicing against the grain');
    console.log('Serving with herb butter on top');
  }
}

class Salad extends Recipe {
  getName() {
    return 'Caesar Salad';
  }
  
  prepareIngredients() {
    console.log('Step 1: Washing and drying lettuce');
    console.log('Step 2: Making croutons');
    console.log('Step 3: Preparing Caesar dressing');
  }
  
  cookIngredients() {
    console.log('Step 1: Tossing lettuce with dressing');
    console.log('Step 2: Adding croutons');
    console.log('Step 3: Adding parmesan shavings');
  }
  
  shouldAddSeasoning() {
    return false; // Dressing already has seasoning
  }
}

// Cook different dishes
const pasta = new Pasta();
pasta.cook();

const steak = new Steak();
steak.cook();

const salad = new Salad();
salad.cook();
```

## üß™ Test Framework Example

```javascript
class TestCase {
  // Template method
  async run() {
    console.log(`\nüß™ Running test: ${this.getTestName()}`);
    
    try {
      await this.setUp();
      
      const startTime = performance.now();
      await this.test();
      const duration = performance.now() - startTime;
      
      await this.tearDown();
      
      console.log(`‚úÖ PASSED (${duration.toFixed(2)}ms)`);
      return { passed: true, duration };
    } catch (error) {
      await this.tearDown();
      console.log(`‚ùå FAILED: ${error.message}`);
      return { passed: false, error: error.message };
    }
  }
  
  // Abstract methods
  getTestName() {
    throw new Error('getTestName() must be implemented');
  }
  
  async test() {
    throw new Error('test() must be implemented');
  }
  
  // Hook methods
  async setUp() {
    console.log('  Setting up test...');
  }
  
  async tearDown() {
    console.log('  Cleaning up...');
  }
}

// Concrete test cases
class DatabaseConnectionTest extends TestCase {
  getTestName() {
    return 'Database Connection Test';
  }
  
  async setUp() {
    console.log('  Connecting to test database...');
    this.connection = { connected: true };
    // Simulate connection delay
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  
  async test() {
    console.log('  Testing connection...');
    if (!this.connection.connected) {
      throw new Error('Connection failed');
    }
    
    console.log('  Executing test query...');
    await new Promise(resolve => setTimeout(resolve, 50));
  }
  
  async tearDown() {
    console.log('  Closing database connection...');
    this.connection = null;
  }
}

class APIEndpointTest extends TestCase {
  getTestName() {
    return 'API Endpoint Test';
  }
  
  async setUp() {
    console.log('  Starting test server...');
    this.server = { running: true, port: 3000 };
  }
  
  async test() {
    console.log('  Sending GET request to /api/users...');
    await new Promise(resolve => setTimeout(resolve, 80));
    
    const response = { status: 200, data: [] };
    
    if (response.status !== 200) {
      throw new Error('Expected status 200');
    }
    
    console.log('  Response validated successfully');
  }
  
  async tearDown() {
    console.log('  Stopping test server...');
    this.server = null;
  }
}

class FailingTest extends TestCase {
  getTestName() {
    return 'Intentionally Failing Test';
  }
  
  async test() {
    console.log('  Executing test that will fail...');
    throw new Error('This test always fails');
  }
}

// Run test suite
async function runTestSuite() {
  const tests = [
    new DatabaseConnectionTest(),
    new APIEndpointTest(),
    new FailingTest()
  ];
  
  console.log('üöÄ Test Suite Starting...');
  
  const results = [];
  for (const test of tests) {
    const result = await test.run();
    results.push(result);
  }
  
  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;
  
  console.log(`\nüìä Test Summary: ${passed} passed, ${failed} failed`);
}

runTestSuite();
```

## üèóÔ∏è Build Process Example

```javascript
class BuildProcess {
  // Template method
  build(config) {
    console.log(`\nüî® Starting build process: ${config.name}\n`);
    
    const validationResult = this.validateConfiguration(config);
    if (!validationResult.valid) {
      console.error('‚ùå Configuration invalid:', validationResult.errors);
      return { success: false };
    }
    
    const cleaned = this.clean();
    const compiled = this.compile(config);
    const tested = this.runTests();
    
    if (!tested.passed) {
      console.error('‚ùå Tests failed, aborting build');
      return { success: false };
    }
    
    const bundled = this.bundle(compiled);
    const optimized = this.optimize(bundled);
    const deployed = this.deploy(optimized, config);
    
    this.notifySuccess(deployed);
    
    console.log('\n‚úÖ Build completed successfully!\n');
    return { success: true, output: deployed };
  }
  
  // Hook with default implementation
  validateConfiguration(config) {
    console.log('Validating configuration...');
    return { valid: true };
  }
  
  // Hook with default implementation
  clean() {
    console.log('Cleaning build directory...');
    return { cleaned: true };
  }
  
  // Abstract method
  compile(config) {
    throw new Error('compile() must be implemented');
  }
  
  // Hook with default implementation
  runTests() {
    console.log('Running tests...');
    return { passed: true, count: 0 };
  }
  
  // Abstract method
  bundle(compiled) {
    throw new Error('bundle() must be implemented');
  }
  
  // Hook with default implementation
  optimize(bundled) {
    console.log('Optimizing build...');
    return bundled;
  }
  
  // Abstract method
  deploy(output, config) {
    throw new Error('deploy() must be implemented');
  }
  
  // Hook
  notifySuccess(result) {
    console.log('Sending success notification...');
  }
}

class ReactBuildProcess extends BuildProcess {
  compile(config) {
    console.log('Compiling React components with Babel...');
    console.log('  - Transforming JSX');
    console.log('  - Transpiling ES6+ to ES5');
    return { 
      compiled: true, 
      files: ['app.js', 'vendor.js'] 
    };
  }
  
  bundle(compiled) {
    console.log('Bundling with Webpack...');
    console.log('  - Creating bundle.js');
    console.log('  - Code splitting');
    return { 
      bundled: true, 
      output: 'dist/bundle.js',
      size: '250KB'
    };
  }
  
  optimize(bundled) {
    console.log('Optimizing React build...');
    console.log('  - Minifying JavaScript');
    console.log('  - Tree shaking unused code');
    console.log('  - Compressing assets');
    return { 
      ...bundled, 
      size: '180KB',
      optimized: true 
    };
  }
  
  deploy(output, config) {
    console.log(`Deploying to ${config.target}...`);
    console.log('  - Uploading files to CDN');
    console.log('  - Invalidating cache');
    return { 
      deployed: true, 
      url: `https://${config.target}/app` 
    };
  }
  
  notifySuccess(result) {
    console.log(`üéâ Deployment successful: ${result.url}`);
    console.log('Sending Slack notification...');
  }
}

class NodeBuildProcess extends BuildProcess {
  validateConfiguration(config) {
    console.log('Validating Node.js configuration...');
    
    if (!config.entryPoint) {
      return { 
        valid: false, 
        errors: ['Entry point required'] 
      };
    }
    
    return { valid: true };
  }
  
  compile(config) {
    console.log('Compiling TypeScript to JavaScript...');
    console.log('  - Type checking');
    console.log('  - Generating .js files');
    return { 
      compiled: true, 
      files: ['index.js', 'utils.js'] 
    };
  }
  
  runTests() {
    console.log('Running Jest tests...');
    console.log('  - Unit tests: 45/45 passed');
    console.log('  - Integration tests: 12/12 passed');
    return { passed: true, count: 57 };
  }
  
  bundle(compiled) {
    console.log('Bundling Node.js application...');
    console.log('  - Copying dependencies');
    console.log('  - Creating package');
    return { 
      bundled: true, 
      output: 'dist/'
    };
  }
  
  deploy(output, config) {
    console.log(`Deploying to ${config.target}...`);
    console.log('  - Pushing to Docker registry');
    console.log('  - Updating Kubernetes deployment');
    return { 
      deployed: true, 
      target: config.target 
    };
  }
}

// Usage
const reactConfig = {
  name: 'My React App',
  target: 'production.example.com'
};

const nodeConfig = {
  name: 'My API Server',
  target: 'k8s-cluster',
  entryPoint: 'src/index.ts'
};

const reactBuild = new ReactBuildProcess();
reactBuild.build(reactConfig);

const nodeBuild = new NodeBuildProcess();
nodeBuild.build(nodeConfig);
```

## üéÆ Game AI Behavior Example

```javascript
class AIBehavior {
  // Template method
  execute(gameState) {
    console.log(`\nü§ñ AI Turn: ${this.getName()}`);
    
    this.perceive(gameState);
    
    if (this.shouldRetreat(gameState)) {
      console.log('  Retreating!');
      return this.retreat(gameState);
    }
    
    const decision = this.decide(gameState);
    const action = this.act(decision);
    
    this.learn(gameState, action);
    
    return action;
  }
  
  // Abstract methods
  getName() {
    throw new Error('getName() must be implemented');
  }
  
  perceive(gameState) {
    throw new Error('perceive() must be implemented');
  }
  
  decide(gameState) {
    throw new Error('decide() must be implemented');
  }
  
  act(decision) {
    throw new Error('act() must be implemented');
  }
  
  // Hook methods
  shouldRetreat(gameState) {
    return false;
  }
  
  retreat(gameState) {
    console.log('  Moving to safe position');
    return { action: 'retreat' };
  }
  
  learn(gameState, action) {
    // Optional learning step
  }
}

class AggressiveAI extends AIBehavior {
  getName() {
    return 'Aggressive Bot';
  }
  
  perceive(gameState) {
    console.log('  Scanning for enemies...');
    this.nearestEnemy = gameState.enemies[0];
  }
  
  decide(gameState) {
    console.log('  Choosing aggressive strategy');
    return {
      strategy: 'attack',
      target: this.nearestEnemy
    };
  }
  
  act(decision) {
    console.log(`  Attacking ${decision.target}!`);
    return {
      action: 'attack',
      target: decision.target,
      damage: 20
    };
  }
}

class DefensiveAI extends AIBehavior {
  getName() {
    return 'Defensive Bot';
  }
  
  perceive(gameState) {
    console.log('  Assessing threats...');
    this.health = gameState.self.health;
    this.enemyCount = gameState.enemies.length;
  }
  
  shouldRetreat(gameState) {
    return this.health < 30 || this.enemyCount > 2;
  }
  
  decide(gameState) {
    console.log('  Choosing defensive strategy');
    return {
      strategy: 'defend',
      position: gameState.safestLocation
    };
  }
  
  act(decision) {
    console.log('  Taking defensive position');
    return {
      action: 'defend',
      position: decision.position,
      defenseBonus: 10
    };
  }
  
  learn(gameState, action) {
    console.log('  Updating defensive tactics based on outcome');
  }
}

// Usage
const gameState = {
  self: { health: 50, position: { x: 10, y: 10 } },
  enemies: ['Enemy1', 'Enemy2'],
  safestLocation: { x: 5, y: 5 }
};

const aggressiveBot = new AggressiveAI();
aggressiveBot.execute(gameState);

const defensiveBot = new DefensiveAI();
defensiveBot.execute(gameState);
```

## ‚úÖ When to Use Template Method Pattern

**Use Template Method when:**
- Multiple classes have similar algorithms with minor variations
- You want to avoid code duplication across similar classes
- You want to control extension points in an algorithm
- The algorithm structure should remain fixed but steps can vary

**Don't use when:**
- Algorithm steps vary drastically between implementations
- You need runtime algorithm changes (use Strategy pattern)
- Inheritance creates tight coupling you want to avoid
- The algorithm is simple and doesn't benefit from structuring

## üéØ Benefits & Trade-offs

### Benefits
- **Code reuse**: Common logic is centralized
- **Control**: Parent controls algorithm flow
- **Extension points**: Clear where subclasses can customize
- **Reduced duplication**: Shared code in one place
- **Open/Closed Principle**: Open for extension, closed for modification

### Trade-offs
- **Tight coupling**: Subclasses depend on parent class
- **Limited flexibility**: Algorithm structure is fixed
- **Can be confusing**: Flow is inverted (parent calls child methods)
- **Inheritance**: Can't use with classes that already inherit
- **Rigid structure**: Adding new steps affects all subclasses

## üí° Pro Tips

1. **Mark template method as final** (if language supports it) to prevent overriding
2. **Use descriptive names** for hooks vs required methods
3. **Document expected behavior** of each overridable method
4. **Keep template method focused** - not too many steps
5. **Consider Strategy pattern** if you need runtime algorithm changes
6. **Use abstract classes** to enforce method implementation
7. **Provide sensible defaults** for hook methods
8. **Don't make everything a hook** - some steps should be fixed
9. **Consider composition over inheritance** for complex scenarios
10. **Use TypeScript/JSDoc** for better documentation and type safety