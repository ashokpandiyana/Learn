# Chapter 17: Publish-Subscribe Pattern

## 17.1 Concept

### What is Publish-Subscribe?

The Publish-Subscribe (Pub/Sub) pattern is a messaging pattern where **publishers** send messages to a **message broker/channel**, and **subscribers** receive messages from channels they're interested in. Publishers and subscribers are **completely decoupled**.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 PUBLISH-SUBSCRIBE PATTERN                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                             ‚îÇ
‚îÇ   OBSERVER:                      PUB/SUB:                   ‚îÇ
‚îÇ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                      ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                   ‚îÇ
‚îÇ   Subject knows observers        Publishers don't know      ‚îÇ
‚îÇ   Direct communication           subscribers                ‚îÇ
‚îÇ                                  Channel/Broker in between  ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ   ‚îÇ Subject  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫       ‚îÇPublisher ‚îÇ                ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îÇ        ‚îÇ                 ‚îÇ           ‚îÇ                      ‚îÇ
‚îÇ        ‚îÇ direct          ‚îÇ           ‚îÇ publish              ‚îÇ
‚îÇ        ‚ñº                 ‚îÇ           ‚ñº                      ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               ‚îÇ
‚îÇ   ‚îÇ Observer ‚îÇ           ‚îÇ    ‚îÇ   CHANNEL   ‚îÇ               ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ    ‚îÇ   /BROKER   ‚îÇ               ‚îÇ
‚îÇ                          ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îÇ
‚îÇ                          ‚îÇ           ‚îÇ distribute           ‚îÇ
‚îÇ                          ‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ                          ‚îÇ     ‚ñº           ‚ñº                ‚îÇ
‚îÇ                          ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ
‚îÇ                          ‚îÇ ‚îÇ Sub A  ‚îÇ ‚îÇ Sub B  ‚îÇ            ‚îÇ
‚îÇ                          ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
‚îÇ                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Observer vs Pub/Sub

| Aspect | Observer | Pub/Sub |
|--------|----------|---------|
| **Coupling** | Subject knows observers | Complete decoupling |
| **Communication** | Direct | Through broker/channel |
| **Topic/Channel** | Usually single | Multiple channels |
| **Filtering** | All observers get all events | Subscribers filter by topic |
| **Use Case** | Component state | Distributed systems |

---

## 17.2 Implementation

### Event Bus / Message Broker

```javascript
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PUB/SUB EVENT BUS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
class EventBus {
  constructor() {
    this.channels = new Map();
    this.history = [];
    this.maxHistory = 100;
  }
  
  // Subscribe to a channel
  subscribe(channel, callback, options = {}) {
    if (!this.channels.has(channel)) {
      this.channels.set(channel, new Set());
    }
    
    const subscriber = {
      callback,
      once: options.once || false,
      priority: options.priority || 0,
      filter: options.filter || null
    };
    
    this.channels.get(channel).add(subscriber);
    
    console.log(`[EventBus] Subscribed to "${channel}"`);
    
    // Return unsubscribe function
    return () => {
      this.channels.get(channel).delete(subscriber);
      console.log(`[EventBus] Unsubscribed from "${channel}"`);
    };
  }
  
  // Subscribe once
  once(channel, callback) {
    return this.subscribe(channel, callback, { once: true });
  }
  
  // Publish to a channel
  publish(channel, data, options = {}) {
    const message = {
      channel,
      data,
      timestamp: Date.now(),
      id: this.#generateId(),
      source: options.source || 'anonymous'
    };
    
    // Store in history
    this.history.push(message);
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    }
    
    console.log(`[EventBus] Publishing to "${channel}":`, data);
    
    if (!this.channels.has(channel)) {
      console.log(`[EventBus] No subscribers for "${channel}"`);
      return;
    }
    
    const subscribers = [...this.channels.get(channel)]
      .sort((a, b) => b.priority - a.priority);
    
    subscribers.forEach(subscriber => {
      // Apply filter if exists
      if (subscriber.filter && !subscriber.filter(data)) {
        return;
      }
      
      try {
        subscriber.callback(message);
      } catch (error) {
        console.error(`[EventBus] Error in subscriber:`, error);
      }
      
      // Remove if once
      if (subscriber.once) {
        this.channels.get(channel).delete(subscriber);
      }
    });
  }
  
  // Publish to multiple channels (broadcast)
  broadcast(channels, data, options = {}) {
    channels.forEach(channel => this.publish(channel, data, options));
  }
  
  // Get channels
  getChannels() {
    return [...this.channels.keys()];
  }
  
  // Get subscriber count for a channel
  getSubscriberCount(channel) {
    return this.channels.has(channel) ? this.channels.get(channel).size : 0;
  }
  
  // Get message history
  getHistory(channel = null) {
    if (channel) {
      return this.history.filter(m => m.channel === channel);
    }
    return [...this.history];
  }
  
  // Clear all subscriptions
  clear() {
    this.channels.clear();
    console.log('[EventBus] All subscriptions cleared');
  }
  
  #generateId() {
    return 'msg_' + Math.random().toString(36).substr(2, 9);
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// USAGE: E-commerce Application
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const eventBus = new EventBus();

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// SUBSCRIBERS (Different modules/services)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Analytics Module
eventBus.subscribe('order:created', (message) => {
  console.log('[Analytics] Tracking order:', message.data.orderId);
});

eventBus.subscribe('user:registered', (message) => {
  console.log('[Analytics] New user registered:', message.data.email);
});

// Notification Module
eventBus.subscribe('order:created', (message) => {
  console.log('[Notifications] Sending order confirmation email');
});

eventBus.subscribe('order:shipped', (message) => {
  console.log('[Notifications] Sending shipment notification');
});

// Inventory Module
eventBus.subscribe('order:created', (message) => {
  console.log('[Inventory] Updating stock for order:', message.data.orderId);
  message.data.items.forEach(item => {
    console.log(`  - Reducing stock for ${item.name} by ${item.quantity}`);
  });
});

// Loyalty Module - Only for orders over $100
eventBus.subscribe('order:created', (message) => {
  console.log(`[Loyalty] Adding ${Math.floor(message.data.total)} points`);
}, {
  filter: (data) => data.total > 100
});

// Fraud Detection - High priority
eventBus.subscribe('order:created', (message) => {
  console.log('[Fraud Detection] Checking order...');
  // If suspicious, could publish to 'order:flagged' channel
}, { priority: 10 });

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PUBLISHERS (Different parts of the application)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Order Service publishes
console.log('\n=== Creating Order ===\n');
eventBus.publish('order:created', {
  orderId: 'ORD-001',
  userId: 'USR-123',
  items: [
    { name: 'Laptop', quantity: 1, price: 999 },
    { name: 'Mouse', quantity: 2, price: 25 }
  ],
  total: 1049
}, { source: 'OrderService' });

// Shipping Service publishes
console.log('\n=== Shipping Order ===\n');
eventBus.publish('order:shipped', {
  orderId: 'ORD-001',
  trackingNumber: 'TRACK-12345',
  carrier: 'FedEx'
}, { source: 'ShippingService' });

// Auth Service publishes
console.log('\n=== New User Registration ===\n');
eventBus.publish('user:registered', {
  userId: 'USR-456',
  email: 'newuser@example.com'
}, { source: 'AuthService' });

// Check statistics
console.log('\n=== Event Bus Statistics ===');
console.log('Channels:', eventBus.getChannels());
console.log('order:created subscribers:', eventBus.getSubscriberCount('order:created'));
console.log('Message history:', eventBus.getHistory().length, 'messages');
```

### Topic-Based Pub/Sub with Wildcards

```javascript
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ADVANCED PUB/SUB WITH WILDCARD MATCHING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
class TopicPubSub {
  constructor() {
    this.subscriptions = new Map();
  }
  
  // Topic format: "namespace.category.event"
  // Wildcards: * (single level), # (multiple levels)
  subscribe(pattern, callback) {
    if (!this.subscriptions.has(pattern)) {
      this.subscriptions.set(pattern, new Set());
    }
    this.subscriptions.get(pattern).add(callback);
    
    return () => {
      this.subscriptions.get(pattern).delete(callback);
      if (this.subscriptions.get(pattern).size === 0) {
        this.subscriptions.delete(pattern);
      }
    };
  }
  
  publish(topic, data) {
    const message = { topic, data, timestamp: Date.now() };
    let delivered = 0;
    
    this.subscriptions.forEach((callbacks, pattern) => {
      if (this.#matchTopic(pattern, topic)) {
        callbacks.forEach(callback => {
          try {
            callback(message);
            delivered++;
          } catch (error) {
            console.error(`Error in subscriber for ${pattern}:`, error);
          }
        });
      }
    });
    
    console.log(`[TopicPubSub] "${topic}" ‚Üí ${delivered} subscribers`);
    return delivered;
  }
  
  #matchTopic(pattern, topic) {
    const patternParts = pattern.split('.');
    const topicParts = topic.split('.');
    
    let patternIndex = 0;
    let topicIndex = 0;
    
    while (patternIndex < patternParts.length && topicIndex < topicParts.length) {
      const patternPart = patternParts[patternIndex];
      
      if (patternPart === '#') {
        // # matches everything after
        return true;
      } else if (patternPart === '*') {
        // * matches exactly one level
        patternIndex++;
        topicIndex++;
      } else if (patternPart === topicParts[topicIndex]) {
        // Exact match
        patternIndex++;
        topicIndex++;
      } else {
        return false;
      }
    }
    
    // Both should be exhausted for a match (unless pattern ends with #)
    return patternIndex === patternParts.length && 
           topicIndex === topicParts.length;
  }
  
  getSubscriptions() {
    const result = {};
    this.subscriptions.forEach((callbacks, pattern) => {
      result[pattern] = callbacks.size;
    });
    return result;
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// USAGE: IoT Device Management
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const pubsub = new TopicPubSub();

// Subscribe to specific device
pubsub.subscribe('devices.sensor.temperature.living-room', (msg) => {
  console.log('[Living Room Thermostat]', msg.data);
});

// Subscribe to all temperature sensors (single wildcard)
pubsub.subscribe('devices.sensor.temperature.*', (msg) => {
  console.log('[Temperature Dashboard]', msg.topic, ':', msg.data.value + '¬∞C');
});

// Subscribe to all sensors of any type (multi-level wildcard)
pubsub.subscribe('devices.sensor.#', (msg) => {
  console.log('[Sensor Log]', msg.topic);
});

// Subscribe to all device events
pubsub.subscribe('devices.#', (msg) => {
  console.log('[Device Monitor] Event:', msg.topic);
});

// Subscribe to all motion sensors
pubsub.subscribe('devices.sensor.motion.*', (msg) => {
  if (msg.data.detected) {
    console.log('[Security] Motion detected:', msg.topic);
  }
});

// Publish sensor data
console.log('\n=== Publishing Sensor Data ===\n');

pubsub.publish('devices.sensor.temperature.living-room', {
  value: 22.5,
  unit: 'celsius'
});

pubsub.publish('devices.sensor.temperature.bedroom', {
  value: 20.0,
  unit: 'celsius'
});

pubsub.publish('devices.sensor.humidity.bathroom', {
  value: 65,
  unit: 'percent'
});

pubsub.publish('devices.sensor.motion.front-door', {
  detected: true,
  timestamp: Date.now()
});

pubsub.publish('devices.actuator.light.kitchen', {
  state: 'on',
  brightness: 80
});

console.log('\n=== Subscriptions ===');
console.log(pubsub.getSubscriptions());
```

---

## 17.3 Cross-Component Communication

```javascript
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SINGLETON EVENT BUS FOR APPLICATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// eventBus.js
class ApplicationEventBus {
  static #instance = null;
  
  constructor() {
    if (ApplicationEventBus.#instance) {
      return ApplicationEventBus.#instance;
    }
    
    this.channels = new Map();
    this.middlewares = [];
    ApplicationEventBus.#instance = this;
  }
  
  // Add middleware (for logging, validation, etc.)
  use(middleware) {
    this.middlewares.push(middleware);
  }
  
  subscribe(channel, callback) {
    if (!this.channels.has(channel)) {
      this.channels.set(channel, new Set());
    }
    this.channels.get(channel).add(callback);
    
    return () => this.channels.get(channel).delete(callback);
  }
  
  async publish(channel, data) {
    let message = { channel, data, timestamp: Date.now() };
    
    // Run through middlewares
    for (const middleware of this.middlewares) {
      message = await middleware(message);
      if (!message) return; // Middleware can cancel message
    }
    
    if (this.channels.has(channel)) {
      this.channels.get(channel).forEach(callback => callback(message));
    }
  }
  
  static getInstance() {
    if (!ApplicationEventBus.#instance) {
      ApplicationEventBus.#instance = new ApplicationEventBus();
    }
    return ApplicationEventBus.#instance;
  }
}

// Export singleton
const eventBus = ApplicationEventBus.getInstance();

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// COMPONENT EXAMPLES (React-like)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Header Component
class HeaderComponent {
  constructor() {
    this.cartCount = 0;
    this.subscriptions = [];
  }
  
  mount() {
    // Listen for cart updates
    this.subscriptions.push(
      eventBus.subscribe('cart:updated', (msg) => {
        this.cartCount = msg.data.itemCount;
        this.render();
      })
    );
    
    // Listen for user login/logout
    this.subscriptions.push(
      eventBus.subscribe('user:loggedIn', (msg) => {
        this.userName = msg.data.name;
        this.render();
      })
    );
  }
  
  unmount() {
    this.subscriptions.forEach(unsub => unsub());
  }
  
  render() {
    console.log(`[Header] Cart: ${this.cartCount} items | User: ${this.userName || 'Guest'}`);
  }
}

// Cart Component
class CartComponent {
  constructor() {
    this.items = [];
  }
  
  addItem(item) {
    this.items.push(item);
    // Publish cart update
    eventBus.publish('cart:updated', {
      items: this.items,
      itemCount: this.items.length,
      total: this.items.reduce((sum, i) => sum + i.price, 0)
    });
  }
  
  removeItem(itemId) {
    this.items = this.items.filter(i => i.id !== itemId);
    eventBus.publish('cart:updated', {
      items: this.items,
      itemCount: this.items.length,
      total: this.items.reduce((sum, i) => sum + i.price, 0)
    });
  }
}

// Auth Component
class AuthComponent {
  login(user) {
    // Perform login...
    eventBus.publish('user:loggedIn', {
      id: user.id,
      name: user.name,
      email: user.email
    });
  }
  
  logout() {
    eventBus.publish('user:loggedOut', {});
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MIDDLEWARE EXAMPLES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Logging middleware
eventBus.use(async (message) => {
  console.log(`[Middleware:Log] ${message.channel}`, message.data);
  return message;
});

// Validation middleware
eventBus.use(async (message) => {
  // Could validate message structure here
  if (!message.data) {
    console.warn('[Middleware:Validate] Empty data, canceling');
    return null; // Cancel message
  }
  return message;
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// USAGE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const header = new HeaderComponent();
const cart = new CartComponent();
const auth = new AuthComponent();

header.mount();

// Simulate user interactions
auth.login({ id: 1, name: 'John', email: 'john@example.com' });
cart.addItem({ id: 1, name: 'Widget', price: 19.99 });
cart.addItem({ id: 2, name: 'Gadget', price: 29.99 });
cart.removeItem(1);

// Cleanup
header.unmount();
```

---

## 17.4 Async Message Queue

```javascript
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MESSAGE QUEUE WITH RETRY AND DEAD LETTER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
class MessageQueue {
  constructor(options = {}) {
    this.queues = new Map();
    this.deadLetterQueue = [];
    this.maxRetries = options.maxRetries || 3;
    this.retryDelay = options.retryDelay || 1000;
  }
  
  // Create a queue
  createQueue(name, handler, options = {}) {
    this.queues.set(name, {
      handler,
      messages: [],
      processing: false,
      options: {
        concurrency: options.concurrency || 1,
        ...options
      }
    });
    console.log(`[Queue] Created queue: ${name}`);
  }
  
  // Add message to queue
  async enqueue(queueName, data, options = {}) {
    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Queue "${queueName}" doesn't exist`);
    }
    
    const message = {
      id: 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5),
      data,
      attempts: 0,
      createdAt: Date.now(),
      priority: options.priority || 0,
      delay: options.delay || 0
    };
    
    queue.messages.push(message);
    queue.messages.sort((a, b) => b.priority - a.priority);
    
    console.log(`[Queue] Enqueued message ${message.id} to "${queueName}"`);
    
    // Start processing if not already
    this.#processQueue(queueName);
    
    return message.id;
  }
  
  async #processQueue(queueName) {
    const queue = this.queues.get(queueName);
    
    if (queue.processing || queue.messages.length === 0) {
      return;
    }
    
    queue.processing = true;
    
    while (queue.messages.length > 0) {
      const message = queue.messages.shift();
      
      // Handle delay
      if (message.delay > 0) {
        const elapsed = Date.now() - message.createdAt;
        if (elapsed < message.delay) {
          await new Promise(r => setTimeout(r, message.delay - elapsed));
        }
      }
      
      message.attempts++;
      
      try {
        console.log(`[Queue] Processing message ${message.id} (attempt ${message.attempts})`);
        await queue.handler(message.data, message);
        console.log(`[Queue] Message ${message.id} processed successfully`);
      } catch (error) {
        console.error(`[Queue] Error processing ${message.id}:`, error.message);
        
        if (message.attempts < this.maxRetries) {
          // Retry with exponential backoff
          const delay = this.retryDelay * Math.pow(2, message.attempts - 1);
          message.delay = delay;
          message.createdAt = Date.now();
          queue.messages.push(message);
          console.log(`[Queue] Retrying ${message.id} in ${delay}ms`);
        } else {
          // Move to dead letter queue
          this.deadLetterQueue.push({
            ...message,
            error: error.message,
            failedAt: Date.now()
          });
          console.log(`[Queue] Message ${message.id} moved to dead letter queue`);
        }
      }
    }
    
    queue.processing = false;
  }
  
  getDeadLetters() {
    return [...this.deadLetterQueue];
  }
  
  retryDeadLetters(queueName) {
    const toRetry = this.deadLetterQueue.splice(0, this.deadLetterQueue.length);
    toRetry.forEach(msg => {
      msg.attempts = 0;
      this.enqueue(queueName, msg.data);
    });
    return toRetry.length;
  }
  
  getStats() {
    const stats = {};
    this.queues.forEach((queue, name) => {
      stats[name] = {
        pending: queue.messages.length,
        processing: queue.processing
      };
    });
    stats.deadLetters = this.deadLetterQueue.length;
    return stats;
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// USAGE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const mq = new MessageQueue({ maxRetries: 3, retryDelay: 500 });

// Create email queue
mq.createQueue('emails', async (data, message) => {
  console.log(`  Sending email to: ${data.to}`);
  
  // Simulate random failures
  if (Math.random() < 0.3) {
    throw new Error('Email server temporarily unavailable');
  }
  
  // Simulate send delay
  await new Promise(r => setTimeout(r, 100));
  console.log(`  Email sent: "${data.subject}"`);
});

// Create notifications queue
mq.createQueue('notifications', async (data) => {
  console.log(`  Push notification to ${data.userId}: ${data.message}`);
  await new Promise(r => setTimeout(r, 50));
});

// Enqueue messages
console.log('\n=== Enqueueing Messages ===\n');

mq.enqueue('emails', { to: 'user1@example.com', subject: 'Welcome!' });
mq.enqueue('emails', { to: 'user2@example.com', subject: 'Order Confirmation' });
mq.enqueue('emails', { to: 'user3@example.com', subject: 'Password Reset' }, { priority: 10 });

mq.enqueue('notifications', { userId: 'user1', message: 'New follower!' });
mq.enqueue('notifications', { userId: 'user2', message: 'Your order shipped' });

// Check stats after a delay
setTimeout(() => {
  console.log('\n=== Queue Stats ===');
  console.log(mq.getStats());
  
  console.log('\n=== Dead Letters ===');
  console.log(mq.getDeadLetters());
}, 5000);
```

---

## Key Takeaways

1. **Pub/Sub = Complete Decoupling** - Publishers don't know subscribers
2. **Event Bus/Broker** - Central message distribution point
3. **Topic-based filtering** - Subscribe to specific channels/topics
4. **Wildcard patterns** - `*` and `#` for flexible subscriptions
5. **Async message queues** - Handle failures with retry/dead letter
6. **Use for**: Microservices, event-driven architecture, IoT

> üí° **Interview Tip:** Explain the key difference from Observer: In Pub/Sub, the publisher has no knowledge of subscribers. The broker handles all distribution.

> üè≠ **Production Note:** Real-world systems use message brokers like RabbitMQ, Apache Kafka, or Redis Pub/Sub for distributed pub/sub.
