# Chapter 32: Unit of Work Pattern - Complete Guide

## ðŸ“š What is the Unit of Work Pattern?

The Unit of Work Pattern **tracks all changes** to objects during a business transaction and **coordinates the writing** of these changes to the database in a single batch operation. It maintains a list of affected objects and ensures database consistency.

### The Problem It Solves

Imagine you're processing an order:
1. Create an order record
2. Update product inventory
3. Create payment record
4. Update user's purchase history

What if step 3 fails? You'd have inconsistent data! Unit of Work ensures **all or nothing** - either all changes succeed or all are rolled back.

## ðŸŽ¯ Core Concepts

### Key Responsibilities:
1. **Track Changes** - Monitor all modifications to entities
2. **Maintain Identity Map** - Prevent duplicate object instances
3. **Batch Operations** - Group database operations together
4. **Transaction Management** - Commit or rollback as a unit

### Change Tracking States:
- **New** - Entity to be inserted
- **Modified** - Entity to be updated
- **Deleted** - Entity to be removed
- **Clean** - No changes

## ðŸ—ï¸ Architecture

```
Business Logic
       â†“
  Unit of Work (tracks all changes)
       â†“
  [New] [Modified] [Deleted] registries
       â†“
  commit() â†’ Database Transaction
```

## ðŸ’» Basic Implementation

### 1. Simple Unit of Work

```javascript
class UnitOfWork {
  constructor(dataSource) {
    this.dataSource = dataSource;
    this.newEntities = new Set();
    this.dirtyEntities = new Set();
    this.deletedEntities = new Set();
    this.identityMap = new Map(); // entity type -> Map(id -> entity)
  }

  // Register a new entity for insertion
  registerNew(entity, entityType) {
    if (this.deletedEntities.has(entity)) {
      throw new Error('Cannot register deleted entity as new');
    }
    if (this.dirtyEntities.has(entity)) {
      throw new Error('Entity already registered as modified');
    }
    
    this.newEntities.add({ entity, entityType });
  }

  // Register an entity for update
  registerDirty(entity, entityType) {
    if (this.deletedEntities.has(entity)) {
      throw new Error('Cannot modify deleted entity');
    }
    if (!this.newEntities.has(entity)) {
      this.dirtyEntities.add({ entity, entityType });
    }
  }

  // Register an entity for deletion
  registerDeleted(entity, entityType) {
    if (this.newEntities.has(entity)) {
      this.newEntities.delete(entity);
      return;
    }
    
    this.dirtyEntities.delete(entity);
    this.deletedEntities.add({ entity, entityType });
  }

  // Commit all changes
  async commit() {
    const transaction = await this.dataSource.beginTransaction();
    
    try {
      // Insert new entities
      for (const { entity, entityType } of this.newEntities) {
        const result = await transaction.insert(entityType, entity);
        entity.id = result.insertedId;
      }

      // Update modified entities
      for (const { entity, entityType } of this.dirtyEntities) {
        await transaction.update(entityType, entity.id, entity);
      }

      // Delete entities
      for (const { entity, entityType } of this.deletedEntities) {
        await transaction.delete(entityType, entity.id);
      }

      await transaction.commit();
      this.clear();
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }

  // Clear all tracked changes
  clear() {
    this.newEntities.clear();
    this.dirtyEntities.clear();
    this.deletedEntities.clear();
  }

  // Rollback without committing
  rollback() {
    this.clear();
  }
}
```

### 2. Unit of Work with Identity Map

```javascript
class UnitOfWorkWithIdentityMap {
  constructor(dataSource) {
    this.dataSource = dataSource;
    this.newEntities = new Map(); // entityType -> Set(entities)
    this.dirtyEntities = new Map();
    this.deletedEntities = new Map();
    this.identityMap = new Map(); // entityType -> Map(id -> entity)
  }

  // Get or create entity type registry
  getRegistry(entityType) {
    if (!this.newEntities.has(entityType)) {
      this.newEntities.set(entityType, new Set());
      this.dirtyEntities.set(entityType, new Set());
      this.deletedEntities.set(entityType, new Set());
      this.identityMap.set(entityType, new Map());
    }
    return {
      new: this.newEntities.get(entityType),
      dirty: this.dirtyEntities.get(entityType),
      deleted: this.deletedEntities.get(entityType),
      identityMap: this.identityMap.get(entityType)
    };
  }

  // Get entity from identity map
  getFromIdentityMap(entityType, id) {
    const registry = this.getRegistry(entityType);
    return registry.identityMap.get(id);
  }

  // Register entity in identity map
  addToIdentityMap(entityType, entity) {
    const registry = this.getRegistry(entityType);
    if (entity.id) {
      registry.identityMap.set(entity.id, entity);
    }
  }

  // Register operations
  registerNew(entity, entityType) {
    const registry = this.getRegistry(entityType);
    
    if (registry.deleted.has(entity)) {
      throw new Error('Cannot register deleted entity as new');
    }
    
    registry.new.add(entity);
    if (entity.id) {
      this.addToIdentityMap(entityType, entity);
    }
  }

  registerDirty(entity, entityType) {
    const registry = this.getRegistry(entityType);
    
    if (registry.deleted.has(entity)) {
      throw new Error('Cannot modify deleted entity');
    }
    if (!registry.new.has(entity)) {
      registry.dirty.add(entity);
    }
  }

  registerDeleted(entity, entityType) {
    const registry = this.getRegistry(entityType);
    
    if (registry.new.has(entity)) {
      registry.new.delete(entity);
    } else {
      registry.dirty.delete(entity);
      registry.deleted.add(entity);
    }
    
    if (entity.id) {
      registry.identityMap.delete(entity.id);
    }
  }

  async commit() {
    const transaction = await this.dataSource.beginTransaction();
    
    try {
      // Process each entity type
      for (const [entityType, newSet] of this.newEntities) {
        const registry = this.getRegistry(entityType);

        // Insert new entities
        for (const entity of newSet) {
          const result = await transaction.insert(entityType, entity);
          entity.id = result.insertedId;
          this.addToIdentityMap(entityType, entity);
        }

        // Update dirty entities
        for (const entity of registry.dirty) {
          await transaction.update(entityType, entity.id, entity);
        }

        // Delete entities
        for (const entity of registry.deleted) {
          await transaction.delete(entityType, entity.id);
        }
      }

      await transaction.commit();
      this.clear();
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }

  clear() {
    this.newEntities.clear();
    this.dirtyEntities.clear();
    this.deletedEntities.clear();
    // Keep identity map for subsequent operations
  }

  clearAll() {
    this.clear();
    this.identityMap.clear();
  }
}
```

## ðŸ”„ Repository Integration

```javascript
class RepositoryWithUnitOfWork {
  constructor(unitOfWork, entityType, EntityClass) {
    this.unitOfWork = unitOfWork;
    this.entityType = entityType;
    this.EntityClass = EntityClass;
  }

  async findById(id) {
    // Check identity map first
    const cached = this.unitOfWork.getFromIdentityMap(this.entityType, id);
    if (cached) return cached;

    // Fetch from database
    const data = await this.unitOfWork.dataSource.findOne(this.entityType, { id });
    if (!data) return null;

    const entity = new this.EntityClass(data);
    this.unitOfWork.addToIdentityMap(this.entityType, entity);
    return entity;
  }

  async findAll() {
    const items = await this.unitOfWork.dataSource.find(this.entityType);
    return items.map(data => {
      const cached = this.unitOfWork.getFromIdentityMap(this.entityType, data.id);
      if (cached) return cached;

      const entity = new this.EntityClass(data);
      this.unitOfWork.addToIdentityMap(this.entityType, entity);
      return entity;
    });
  }

  insert(entity) {
    this.unitOfWork.registerNew(entity, this.entityType);
    return entity;
  }

  update(entity) {
    this.unitOfWork.registerDirty(entity, this.entityType);
    return entity;
  }

  delete(entity) {
    this.unitOfWork.registerDeleted(entity, this.entityType);
  }
}
```

## ðŸŽ­ Advanced: Change Tracking

```javascript
class EntityState {
  static NEW = 'NEW';
  static MODIFIED = 'MODIFIED';
  static DELETED = 'DELETED';
  static UNCHANGED = 'UNCHANGED';
}

class TrackedEntity {
  constructor(entity, entityType, state = EntityState.UNCHANGED) {
    this.entity = entity;
    this.entityType = entityType;
    this.state = state;
    this.originalValues = state === EntityState.UNCHANGED ? 
      JSON.parse(JSON.stringify(entity)) : null;
  }

  hasChanges() {
    if (this.state !== EntityState.UNCHANGED) return true;
    return JSON.stringify(this.entity) !== JSON.stringify(this.originalValues);
  }

  getChanges() {
    if (!this.originalValues) return null;
    
    const changes = {};
    for (const key in this.entity) {
      if (this.entity[key] !== this.originalValues[key]) {
        changes[key] = {
          old: this.originalValues[key],
          new: this.entity[key]
        };
      }
    }
    return Object.keys(changes).length > 0 ? changes : null;
  }

  acceptChanges() {
    this.originalValues = JSON.parse(JSON.stringify(this.entity));
    this.state = EntityState.UNCHANGED;
  }

  rejectChanges() {
    if (this.originalValues) {
      Object.assign(this.entity, this.originalValues);
      this.state = EntityState.UNCHANGED;
    }
  }
}

class ChangeTrackingUnitOfWork {
  constructor(dataSource) {
    this.dataSource = dataSource;
    this.trackedEntities = new Map(); // entity -> TrackedEntity
  }

  attach(entity, entityType, state = EntityState.UNCHANGED) {
    if (!this.trackedEntities.has(entity)) {
      this.trackedEntities.set(entity, new TrackedEntity(entity, entityType, state));
    }
  }

  detach(entity) {
    this.trackedEntities.delete(entity);
  }

  markAsNew(entity, entityType) {
    const tracked = new TrackedEntity(entity, entityType, EntityState.NEW);
    this.trackedEntities.set(entity, tracked);
  }

  markAsModified(entity) {
    const tracked = this.trackedEntities.get(entity);
    if (tracked && tracked.state === EntityState.UNCHANGED) {
      tracked.state = EntityState.MODIFIED;
    }
  }

  markAsDeleted(entity) {
    const tracked = this.trackedEntities.get(entity);
    if (tracked) {
      if (tracked.state === EntityState.NEW) {
        this.trackedEntities.delete(entity);
      } else {
        tracked.state = EntityState.DELETED;
      }
    }
  }

  getChanges() {
    const changes = {
      new: [],
      modified: [],
      deleted: []
    };

    for (const [entity, tracked] of this.trackedEntities) {
      switch (tracked.state) {
        case EntityState.NEW:
          changes.new.push({ entity, type: tracked.entityType });
          break;
        case EntityState.MODIFIED:
          if (tracked.hasChanges()) {
            changes.modified.push({
              entity,
              type: tracked.entityType,
              changes: tracked.getChanges()
            });
          }
          break;
        case EntityState.DELETED:
          changes.deleted.push({ entity, type: tracked.entityType });
          break;
      }
    }

    return changes;
  }

  async commit() {
    const changes = this.getChanges();
    const transaction = await this.dataSource.beginTransaction();

    try {
      // Insert new entities
      for (const { entity, type } of changes.new) {
        const result = await transaction.insert(type, entity);
        entity.id = result.insertedId;
      }

      // Update modified entities
      for (const { entity, type } of changes.modified) {
        await transaction.update(type, entity.id, entity);
      }

      // Delete entities
      for (const { entity, type } of changes.deleted) {
        await transaction.delete(type, entity.id);
      }

      await transaction.commit();

      // Accept all changes
      for (const tracked of this.trackedEntities.values()) {
        if (tracked.state === EntityState.DELETED) {
          this.trackedEntities.delete(tracked.entity);
        } else {
          tracked.acceptChanges();
        }
      }
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }

  rollback() {
    // Reject all changes
    for (const tracked of this.trackedEntities.values()) {
      if (tracked.state === EntityState.NEW) {
        this.trackedEntities.delete(tracked.entity);
      } else {
        tracked.rejectChanges();
      }
    }
  }
}
```

## ðŸ§ª Complete Example: E-commerce Order Processing

```javascript
// Domain entities
class Order {
  constructor(data) {
    this.id = data.id || null;
    this.userId = data.userId;
    this.items = data.items || [];
    this.total = data.total || 0;
    this.status = data.status || 'pending';
    this.createdAt = data.createdAt || new Date();
  }

  addItem(productId, quantity, price) {
    this.items.push({ productId, quantity, price });
    this.calculateTotal();
  }

  calculateTotal() {
    this.total = this.items.reduce((sum, item) => 
      sum + (item.price * item.quantity), 0);
  }
}

class Product {
  constructor(data) {
    this.id = data.id;
    this.name = data.name;
    this.price = data.price;
    this.stock = data.stock;
  }

  reduceStock(quantity) {
    if (this.stock < quantity) {
      throw new Error(`Insufficient stock for ${this.name}`);
    }
    this.stock -= quantity;
  }
}

class Payment {
  constructor(data) {
    this.id = data.id || null;
    this.orderId = data.orderId;
    this.amount = data.amount;
    this.status = data.status || 'pending';
    this.createdAt = data.createdAt || new Date();
  }
}

// Service using Unit of Work
class OrderService {
  constructor(unitOfWork, orderRepo, productRepo, paymentRepo) {
    this.unitOfWork = unitOfWork;
    this.orderRepo = orderRepo;
    this.productRepo = productRepo;
    this.paymentRepo = paymentRepo;
  }

  async createOrder(userId, items) {
    try {
      // Create order
      const order = new Order({ userId });

      // Process each item
      for (const item of items) {
        const product = await this.productRepo.findById(item.productId);
        if (!product) {
          throw new Error(`Product ${item.productId} not found`);
        }

        // Check and reduce stock
        product.reduceStock(item.quantity);
        this.productRepo.update(product);

        // Add item to order
        order.addItem(item.productId, item.quantity, product.price);
      }

      // Register order
      this.orderRepo.insert(order);

      // Create payment
      const payment = new Payment({
        orderId: order.id,
        amount: order.total
      });
      this.paymentRepo.insert(payment);

      // Commit all changes as one transaction
      await this.unitOfWork.commit();

      return { order, payment };
    } catch (error) {
      // Rollback all changes
      this.unitOfWork.rollback();
      throw error;
    }
  }

  async cancelOrder(orderId) {
    try {
      const order = await this.orderRepo.findById(orderId);
      if (!order) {
        throw new Error('Order not found');
      }

      // Restore product stock
      for (const item of order.items) {
        const product = await this.productRepo.findById(item.productId);
        product.stock += item.quantity;
        this.productRepo.update(product);
      }

      // Mark order as cancelled
      order.status = 'cancelled';
      this.orderRepo.update(order);

      // Cancel payment
      const payment = await this.paymentRepo.findByOrderId(orderId);
      if (payment) {
        payment.status = 'cancelled';
        this.paymentRepo.update(payment);
      }

      await this.unitOfWork.commit();
      return order;
    } catch (error) {
      this.unitOfWork.rollback();
      throw error;
    }
  }
}

// Usage
async function processOrder() {
  const dataSource = new MockDataSource();
  const unitOfWork = new UnitOfWorkWithIdentityMap(dataSource);

  const orderRepo = new RepositoryWithUnitOfWork(unitOfWork, 'orders', Order);
  const productRepo = new RepositoryWithUnitOfWork(unitOfWork, 'products', Product);
  const paymentRepo = new RepositoryWithUnitOfWork(unitOfWork, 'payments', Payment);

  const orderService = new OrderService(
    unitOfWork,
    orderRepo,
    productRepo,
    paymentRepo
  );

  try {
    const result = await orderService.createOrder(1, [
      { productId: 1, quantity: 2 },
      { productId: 2, quantity: 1 }
    ]);

    console.log('Order created:', result.order);
    console.log('Payment created:', result.payment);
  } catch (error) {
    console.error('Order failed:', error.message);
  }
}
```

## ðŸŽ¯ Unit of Work vs Transaction

| Aspect | Unit of Work | Transaction |
|--------|--------------|-------------|
| Scope | Application-level | Database-level |
| Tracks Changes | Yes | No |
| Batch Operations | Yes | Sequential |
| Identity Map | Often included | No |
| Object State | Manages | Doesn't care |

## ðŸ’¡ Best Practices

### âœ… DO:
- Keep Unit of Work lifetime short (per request/operation)
- Clear the Unit of Work after commit
- Use identity map to prevent duplicate instances
- Track entity state changes
- Implement proper rollback mechanisms

### âŒ DON'T:
- Share Unit of Work across requests
- Commit partial changes
- Forget to handle rollback on errors
- Track too many entities (memory issues)
- Use for simple CRUD operations (overkill)

## ðŸ”‘ Key Takeaways

1. **Transactional Consistency**: All changes succeed or fail together
2. **Performance**: Batch operations reduce database round trips
3. **Identity Map**: Ensures one instance per database row
4. **Change Tracking**: Monitors entity modifications
5. **Complex Operations**: Essential for multi-step business transactions

## ðŸŒŸ When to Use

âœ… **Use When:**
- Multiple entities must be saved atomically
- Complex business transactions
- Need to maintain object identity
- Working with ORM frameworks

âŒ **Don't Use When:**
- Simple CRUD operations
- Single entity updates
- Stateless API endpoints
- Real-time systems (holds locks too long)

The Unit of Work pattern is the backbone of most ORM frameworks like TypeORM, Prisma, and Entity Framework!