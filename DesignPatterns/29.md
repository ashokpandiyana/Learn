# Chapter 29: Dependency Injection Pattern - In Depth Guide

## ğŸ“š Overview

Dependency Injection (DI) is a design pattern that implements Inversion of Control (IoC) for resolving dependencies. Instead of a class creating its dependencies, they are "injected" from the outside, making code more modular, testable, and maintainable.

## ğŸ¯ Core Concepts

### The Problem: Tight Coupling

```javascript
// âŒ Bad: Tight coupling
class UserService {
  constructor() {
    this.database = new MySQLDatabase(); // Hard dependency
    this.emailService = new GmailService(); // Hard dependency
    this.logger = new ConsoleLogger(); // Hard dependency
  }

  async createUser(userData) {
    this.logger.log('Creating user...');
    const user = await this.database.save(userData);
    await this.emailService.send(user.email, 'Welcome!');
    return user;
  }
}

// Problems:
// 1. Can't easily swap implementations
// 2. Hard to test (can't mock dependencies)
// 3. Creates new instances every time
// 4. Violates Single Responsibility Principle
```

### The Solution: Dependency Injection

```javascript
// âœ… Good: Dependencies injected
class UserService {
  constructor(database, emailService, logger) {
    this.database = database;
    this.emailService = emailService;
    this.logger = logger;
  }

  async createUser(userData) {
    this.logger.log('Creating user...');
    const user = await this.database.save(userData);
    await this.emailService.send(user.email, 'Welcome!');
    return user;
  }
}

// Usage
const database = new MySQLDatabase();
const emailService = new GmailService();
const logger = new ConsoleLogger();

const userService = new UserService(database, emailService, logger);
```

## ğŸ”§ Types of Dependency Injection

### 1. Constructor Injection (Recommended)

```javascript
class OrderService {
  constructor(paymentProcessor, inventoryService, notificationService) {
    this.paymentProcessor = paymentProcessor;
    this.inventoryService = inventoryService;
    this.notificationService = notificationService;
  }

  async processOrder(order) {
    await this.inventoryService.reserve(order.items);
    const payment = await this.paymentProcessor.charge(order.total);
    await this.notificationService.sendConfirmation(order);
    return { order, payment };
  }
}

// Benefits:
// - Dependencies are explicit and required
// - Object is fully initialized after construction
// - Immutable after creation
```

### 2. Setter Injection

```javascript
class ReportGenerator {
  constructor() {
    this.database = null;
    this.formatter = null;
  }

  setDatabase(database) {
    this.database = database;
  }

  setFormatter(formatter) {
    this.formatter = formatter;
  }

  async generateReport() {
    if (!this.database || !this.formatter) {
      throw new Error('Dependencies not set');
    }
    
    const data = await this.database.query('SELECT * FROM reports');
    return this.formatter.format(data);
  }
}

// Usage
const generator = new ReportGenerator();
generator.setDatabase(new PostgresDB());
generator.setFormatter(new PDFFormatter());

// Use case: Optional dependencies or configuration after creation
```

### 3. Method Injection

```javascript
class DataProcessor {
  process(data, validator, transformer) {
    const validated = validator.validate(data);
    return transformer.transform(validated);
  }
}

// Usage
const processor = new DataProcessor();
const result = processor.process(
  data,
  new SchemaValidator(),
  new JSONTransformer()
);

// Use case: Different dependencies per method call
```

## ğŸ—ï¸ Building a DI Container

### Simple DI Container

```javascript
class DIContainer {
  constructor() {
    this.services = new Map();
    this.singletons = new Map();
  }

  // Register a service
  register(name, definition, options = {}) {
    this.services.set(name, {
      definition,
      dependencies: options.dependencies || [],
      singleton: options.singleton || false
    });
  }

  // Resolve a service
  resolve(name) {
    const service = this.services.get(name);
    
    if (!service) {
      throw new Error(`Service "${name}" not found`);
    }

    // Return singleton if already created
    if (service.singleton && this.singletons.has(name)) {
      return this.singletons.get(name);
    }

    // Resolve dependencies recursively
    const dependencies = service.dependencies.map(dep => this.resolve(dep));

    // Create instance
    const instance = typeof service.definition === 'function'
      ? new service.definition(...dependencies)
      : service.definition(...dependencies);

    // Store singleton
    if (service.singleton) {
      this.singletons.set(name, instance);
    }

    return instance;
  }

  // Check if service exists
  has(name) {
    return this.services.has(name);
  }
}

// Usage
const container = new DIContainer();

// Register services
container.register('logger', ConsoleLogger, { singleton: true });
container.register('database', MySQLDatabase, {
  dependencies: ['logger'],
  singleton: true
});
container.register('emailService', EmailService, {
  dependencies: ['logger']
});
container.register('userService', UserService, {
  dependencies: ['database', 'emailService', 'logger']
});

// Resolve services
const userService = container.resolve('userService');
```

### Advanced DI Container with Auto-wiring

```javascript
class AdvancedDIContainer {
  constructor() {
    this.services = new Map();
    this.singletons = new Map();
    this.factories = new Map();
  }

  // Register with class
  registerClass(name, Class, options = {}) {
    this.services.set(name, {
      type: 'class',
      Class,
      dependencies: options.dependencies || this.extractDependencies(Class),
      singleton: options.singleton !== false, // Default to singleton
      lazy: options.lazy || false
    });
  }

  // Register with factory function
  registerFactory(name, factory, options = {}) {
    this.services.set(name, {
      type: 'factory',
      factory,
      dependencies: options.dependencies || [],
      singleton: options.singleton !== false
    });
  }

  // Register instance directly
  registerInstance(name, instance) {
    this.singletons.set(name, instance);
    this.services.set(name, { type: 'instance' });
  }

  // Extract dependencies from constructor
  extractDependencies(Class) {
    const constructorString = Class.toString();
    const match = constructorString.match(/constructor\s*\(([^)]*)\)/);
    
    if (!match || !match[1].trim()) {
      return [];
    }

    return match[1]
      .split(',')
      .map(param => param.trim())
      .filter(param => param);
  }

  // Resolve service
  resolve(name) {
    // Check for direct instance
    if (this.singletons.has(name)) {
      return this.singletons.get(name);
    }

    const service = this.services.get(name);
    
    if (!service) {
      throw new Error(`Service "${name}" not registered`);
    }

    if (service.type === 'instance') {
      return this.singletons.get(name);
    }

    // Resolve dependencies
    const dependencies = service.dependencies.map(dep => this.resolve(dep));

    // Create instance
    let instance;
    if (service.type === 'class') {
      instance = new service.Class(...dependencies);
    } else if (service.type === 'factory') {
      instance = service.factory(...dependencies);
    }

    // Store singleton
    if (service.singleton) {
      this.singletons.set(name, instance);
    }

    return instance;
  }

  // Resolve all dependencies for a function
  call(fn, additionalDeps = []) {
    const deps = this.extractDependencies(fn);
    const resolved = deps.map(dep => this.resolve(dep));
    return fn(...resolved, ...additionalDeps);
  }

  // Clear singletons (useful for testing)
  clearSingletons() {
    this.singletons.clear();
  }

  // Get all registered service names
  getServiceNames() {
    return Array.from(this.services.keys());
  }
}

// Example usage
class Logger {
  log(message) {
    console.log(`[LOG] ${message}`);
  }
}

class Database {
  constructor(logger) {
    this.logger = logger;
  }

  async query(sql) {
    this.logger.log(`Executing: ${sql}`);
    return [];
  }
}

class EmailService {
  constructor(logger) {
    this.logger = logger;
  }

  async send(to, subject, body) {
    this.logger.log(`Sending email to ${to}`);
  }
}

class UserService {
  constructor(database, emailService, logger) {
    this.database = database;
    this.emailService = emailService;
    this.logger = logger;
  }

  async createUser(userData) {
    this.logger.log('Creating user');
    const user = await this.database.query('INSERT INTO users...');
    await this.emailService.send(userData.email, 'Welcome!', 'Body');
    return user;
  }
}

// Setup container
const container = new AdvancedDIContainer();

container.registerClass('logger', Logger);
container.registerClass('database', Database);
container.registerClass('emailService', EmailService);
container.registerClass('userService', UserService);

// Resolve and use
const userService = container.resolve('userService');
await userService.createUser({ email: 'test@example.com' });
```

## ğŸ¨ Decorator-based DI (TypeScript Style)

```javascript
// Decorator functions (requires decorator proposal or TypeScript)
const Injectable = () => {
  return (target) => {
    target.injectable = true;
    return target;
  };
};

const Inject = (token) => {
  return (target, propertyKey, parameterIndex) => {
    if (!target.dependencies) {
      target.dependencies = [];
    }
    target.dependencies[parameterIndex] = token;
  };
};

// Usage with decorators
@Injectable()
class ProductService {
  constructor(
    @Inject('Database') database,
    @Inject('Logger') logger
  ) {
    this.database = database;
    this.logger = logger;
  }
}

// Manual implementation without decorators
class ProductService {
  static dependencies = ['database', 'logger'];

  constructor(database, logger) {
    this.database = database;
    this.logger = logger;
  }
}
```

## ğŸ­ Factory Pattern with DI

```javascript
class ServiceFactory {
  constructor(container) {
    this.container = container;
  }

  create(ServiceClass, ...additionalArgs) {
    const dependencies = ServiceClass.dependencies || [];
    const resolved = dependencies.map(dep => this.container.resolve(dep));
    return new ServiceClass(...resolved, ...additionalArgs);
  }

  createMany(ServiceClass, count) {
    return Array.from({ length: count }, () => this.create(ServiceClass));
  }
}

// Usage
class WorkerService {
  static dependencies = ['logger', 'queue'];

  constructor(logger, queue, workerId) {
    this.logger = logger;
    this.queue = queue;
    this.workerId = workerId;
  }

  start() {
    this.logger.log(`Worker ${this.workerId} started`);
  }
}

const factory = new ServiceFactory(container);
const workers = Array.from({ length: 5 }, (_, i) =>
  factory.create(WorkerService, i)
);
```

## ğŸ§ª DI for Testing

### Mock Injection

```javascript
// Production code
class UserService {
  constructor(database, emailService) {
    this.database = database;
    this.emailService = emailService;
  }

  async createUser(userData) {
    const user = await this.database.save(userData);
    await this.emailService.send(user.email, 'Welcome!');
    return user;
  }
}

// Test code
class MockDatabase {
  async save(data) {
    return { id: 1, ...data };
  }
}

class MockEmailService {
  async send(to, subject) {
    this.lastEmail = { to, subject };
  }
}

// Test
describe('UserService', () => {
  let userService, mockDb, mockEmail;

  beforeEach(() => {
    mockDb = new MockDatabase();
    mockEmail = new MockEmailService();
    userService = new UserService(mockDb, mockEmail);
  });

  test('creates user and sends email', async () => {
    const user = await userService.createUser({
      email: 'test@example.com',
      name: 'Test User'
    });

    expect(user.id).toBe(1);
    expect(mockEmail.lastEmail.to).toBe('test@example.com');
  });
});
```

### Test Container

```javascript
class TestContainer extends DIContainer {
  constructor() {
    super();
    this.mocks = new Map();
  }

  mock(name, mockInstance) {
    this.mocks.set(name, mockInstance);
  }

  resolve(name) {
    // Return mock if exists
    if (this.mocks.has(name)) {
      return this.mocks.get(name);
    }
    return super.resolve(name);
  }

  clearMocks() {
    this.mocks.clear();
  }
}

// Usage in tests
describe('OrderService', () => {
  let container, orderService;

  beforeEach(() => {
    container = new TestContainer();
    
    // Register real services
    container.register('logger', Logger, { singleton: true });
    container.register('orderService', OrderService, {
      dependencies: ['paymentProcessor', 'inventoryService', 'logger']
    });

    // Mock dependencies
    container.mock('paymentProcessor', {
      charge: jest.fn().mockResolvedValue({ id: '123' })
    });
    container.mock('inventoryService', {
      reserve: jest.fn().mockResolvedValue(true)
    });

    orderService = container.resolve('orderService');
  });

  test('processes order correctly', async () => {
    const order = { total: 100, items: ['item1'] };
    await orderService.processOrder(order);
    
    expect(container.mocks.get('paymentProcessor').charge)
      .toHaveBeenCalledWith(100);
  });
});
```

## ğŸŒ Real-World Example: Express.js Application

```javascript
// Services
class DatabaseService {
  constructor(config) {
    this.config = config;
  }

  async connect() {
    console.log('Database connected');
  }

  async query(sql, params) {
    return []; // Simplified
  }
}

class LoggerService {
  log(level, message) {
    console.log(`[${level}] ${message}`);
  }
}

class UserRepository {
  constructor(database, logger) {
    this.db = database;
    this.logger = logger;
  }

  async findById(id) {
    this.logger.log('INFO', `Finding user ${id}`);
    return this.db.query('SELECT * FROM users WHERE id = ?', [id]);
  }

  async create(userData) {
    this.logger.log('INFO', 'Creating user');
    return this.db.query('INSERT INTO users...', [userData]);
  }
}

class AuthService {
  constructor(userRepository, logger) {
    this.userRepo = userRepository;
    this.logger = logger;
  }

  async login(username, password) {
    this.logger.log('INFO', `Login attempt for ${username}`);
    // Login logic
  }
}

class UserController {
  constructor(userRepository, authService, logger) {
    this.userRepo = userRepository;
    this.authService = authService;
    this.logger = logger;
  }

  async getUser(req, res) {
    try {
      const user = await this.userRepo.findById(req.params.id);
      res.json(user);
    } catch (error) {
      this.logger.log('ERROR', error.message);
      res.status(500).json({ error: 'Internal error' });
    }
  }

  async createUser(req, res) {
    try {
      const user = await this.userRepo.create(req.body);
      res.json(user);
    } catch (error) {
      this.logger.log('ERROR', error.message);
      res.status(500).json({ error: 'Internal error' });
    }
  }
}

// Setup container
const container = new AdvancedDIContainer();

// Register configuration
container.registerInstance('config', {
  database: {
    host: 'localhost',
    port: 5432
  }
});

// Register services
container.registerClass('logger', LoggerService);
container.registerClass('database', DatabaseService, {
  dependencies: ['config']
});
container.registerClass('userRepository', UserRepository, {
  dependencies: ['database', 'logger']
});
container.registerClass('authService', AuthService, {
  dependencies: ['userRepository', 'logger']
});
container.registerClass('userController', UserController, {
  dependencies: ['userRepository', 'authService', 'logger']
});

// Create Express app
const express = require('express');
const app = express();

// Middleware to inject container
app.use((req, res, next) => {
  req.container = container;
  next();
});

// Routes
app.get('/users/:id', (req, res) => {
  const controller = req.container.resolve('userController');
  controller.getUser(req, res);
});

app.post('/users', (req, res) => {
  const controller = req.container.resolve('userController');
  controller.createUser(req, res);
});

// Startup
(async () => {
  const db = container.resolve('database');
  await db.connect();
  app.listen(3000, () => console.log('Server running'));
})();
```

## ğŸ”„ Lifecycle Management

```javascript
class ManagedContainer extends AdvancedDIContainer {
  constructor() {
    super();
    this.scopes = new Map();
    this.currentScope = 'default';
  }

  // Create a scoped container
  createScope(name) {
    this.scopes.set(name, new Map());
  }

  // Switch to a scope
  useScope(name) {
    this.currentScope = name;
  }

  // Register with lifecycle
  registerWithLifecycle(name, Class, lifecycle = 'singleton') {
    this.services.set(name, {
      type: 'class',
      Class,
      lifecycle, // 'singleton', 'transient', 'scoped'
      dependencies: this.extractDependencies(Class)
    });
  }

  resolve(name) {
    const service = this.services.get(name);
    
    if (!service) {
      throw new Error(`Service "${name}" not registered`);
    }

    // Singleton: one instance for application lifetime
    if (service.lifecycle === 'singleton') {
      if (this.singletons.has(name)) {
        return this.singletons.get(name);
      }
      const instance = this.createInstance(service);
      this.singletons.set(name, instance);
      return instance;
    }

    // Scoped: one instance per scope
    if (service.lifecycle === 'scoped') {
      const scope = this.scopes.get(this.currentScope);
      if (scope && scope.has(name)) {
        return scope.get(name);
      }
      const instance = this.createInstance(service);
      if (scope) {
        scope.set(name, instance);
      }
      return instance;
    }

    // Transient: new instance every time
    return this.createInstance(service);
  }

  createInstance(service) {
    const dependencies = service.dependencies.map(dep => this.resolve(dep));
    return new service.Class(...dependencies);
  }

  // Clear scope
  clearScope(name) {
    this.scopes.delete(name);
  }
}

// Usage
const container = new ManagedContainer();

container.registerWithLifecycle('logger', Logger, 'singleton');
container.registerWithLifecycle('request', Request, 'scoped');
container.registerWithLifecycle('helper', Helper, 'transient');

// Per-request scope
app.use((req, res, next) => {
  const scopeName = `request-${Date.now()}`;
  container.createScope(scopeName);
  container.useScope(scopeName);
  
  res.on('finish', () => {
    container.clearScope(scopeName);
  });
  
  next();
});
```

## âš¡ Performance Considerations

```javascript
class OptimizedContainer extends DIContainer {
  constructor() {
    super();
    this.resolveCache = new Map();
  }

  // Lazy resolution with caching
  resolveLazy(name) {
    if (this.resolveCache.has(name)) {
      return this.resolveCache.get(name);
    }

    const resolver = () => this.resolve(name);
    this.resolveCache.set(name, resolver);
    return resolver;
  }

  // Batch resolution
  resolveMany(...names) {
    return names.map(name => this.resolve(name));
  }

  // Pre-compile dependency graph
  compile() {
    // Build dependency graph
    // Detect circular dependencies
    // Optimize resolution order
  }
}
```

## ğŸ¯ Best Practices

1. **Prefer Constructor Injection**: Makes dependencies explicit
2. **Use Interfaces**: Define contracts for dependencies
3. **Avoid Service Locator**: Don't pass container everywhere
4. **Lifecycle Management**: Choose appropriate lifetimes
5. **Testing**: Always design for testability
6. **Documentation**: Document dependencies clearly
7. **Avoid Circular Dependencies**: Indicates design issues
8. **Keep It Simple**: Don't over-engineer

## ğŸš« Common Pitfalls

1. **Over-injection**: Too many dependencies = design smell
2. **Hidden Dependencies**: Static calls, global state
3. **Container Coupling**: Services depending on the container itself
4. **Circular Dependencies**: A depends on B, B depends on A
5. **Memory Leaks**: Not cleaning up singletons in tests

## ğŸ“ Summary

Dependency Injection is fundamental for building maintainable, testable applications. It promotes loose coupling, makes testing easier, and provides flexibility in swapping implementations. Use DI containers for managing complex dependency graphs, but keep the pattern simple for smaller applications.