# Chapter 15: Bridge Pattern

## 15.1 Concept

### What is the Bridge Pattern?

The Bridge Pattern **decouples an abstraction from its implementation** so that the two can vary independently. It separates a big class or closely related classes into two separate hierarchiesâ€”abstraction and implementation.

Think of it like a TV and remote control: the remote (abstraction) can work with any TV brand (implementation). You can develop remotes and TVs independently.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     BRIDGE PATTERN                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   WITHOUT BRIDGE (Class Explosion):                         â”‚
â”‚                                                             â”‚
â”‚                        Shape                                â”‚
â”‚                          â”‚                                  â”‚
â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚        â”‚                 â”‚                 â”‚                â”‚
â”‚   CircleRed       CircleBlue       SquareRed ...            â”‚
â”‚   SquareBlue      TriangleRed      TriangleBlue             â”‚
â”‚                                                             â”‚
â”‚   Adding new color = new class for EVERY shape              â”‚
â”‚   Adding new shape = new class for EVERY color              â”‚
â”‚                                                             â”‚
â”‚   WITH BRIDGE (Separate hierarchies):                       â”‚
â”‚                                                             â”‚
â”‚   Abstraction                    Implementation             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚   â”‚  Shape   â”‚â”€â”€â”€â”€â”€ bridge â”€â”€â”€â”€â”€â–ºâ”‚  Color   â”‚               â”‚
â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜               â”‚
â”‚        â”‚                              â”‚                     â”‚
â”‚    â”Œâ”€â”€â”€â”´â”€â”€â”€â”                      â”Œâ”€â”€â”€â”´â”€â”€â”€â”                 â”‚
â”‚    â”‚       â”‚                      â”‚       â”‚                 â”‚
â”‚ Circle  Square                  Red    Blue                 â”‚
â”‚                                                             â”‚
â”‚   Adding new color = ONE new class                          â”‚
â”‚   Adding new shape = ONE new class                          â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Components

| Component | Description | Example |
|-----------|-------------|---------|
| **Abstraction** | High-level control layer | Remote control |
| **Refined Abstraction** | Extended abstraction | Advanced remote |
| **Implementation** | Low-level operations interface | Device interface |
| **Concrete Implementation** | Specific implementation | TV, Radio |

### Bridge vs Other Patterns

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              BRIDGE vs SIMILAR PATTERNS                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  BRIDGE vs ADAPTER:                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚  Bridge:   Designed upfront, both sides can vary            â”‚
â”‚  Adapter:  Applied after, makes incompatible work together  â”‚
â”‚                                                             â”‚
â”‚  BRIDGE vs STRATEGY:                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚  Bridge:   Structural, separates interface from impl        â”‚
â”‚  Strategy: Behavioral, swaps algorithms                     â”‚
â”‚                                                             â”‚
â”‚  BRIDGE vs ABSTRACT FACTORY:                                â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                 â”‚
â”‚  Bridge:   Focuses on structure/hierarchy                   â”‚
â”‚  Abstract Factory: Focuses on object creation               â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 15.2 Implementation

### Device Remote Control Example

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// IMPLEMENTATION INTERFACE: Device
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Device {
  isEnabled() { throw new Error('Must implement'); }
  enable() { throw new Error('Must implement'); }
  disable() { throw new Error('Must implement'); }
  getVolume() { throw new Error('Must implement'); }
  setVolume(volume) { throw new Error('Must implement'); }
  getChannel() { throw new Error('Must implement'); }
  setChannel(channel) { throw new Error('Must implement'); }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONCRETE IMPLEMENTATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class TV extends Device {
  constructor() {
    super();
    this.on = false;
    this.volume = 30;
    this.channel = 1;
  }
  
  isEnabled() { return this.on; }
  
  enable() {
    this.on = true;
    console.log('TV: Turning ON');
  }
  
  disable() {
    this.on = false;
    console.log('TV: Turning OFF');
  }
  
  getVolume() { return this.volume; }
  
  setVolume(volume) {
    this.volume = Math.max(0, Math.min(100, volume));
    console.log(`TV: Volume set to ${this.volume}`);
  }
  
  getChannel() { return this.channel; }
  
  setChannel(channel) {
    this.channel = channel;
    console.log(`TV: Channel set to ${this.channel}`);
  }
  
  // TV-specific features
  setBrightness(level) {
    console.log(`TV: Brightness set to ${level}`);
  }
}

class Radio extends Device {
  constructor() {
    super();
    this.on = false;
    this.volume = 20;
    this.frequency = 87.5;
  }
  
  isEnabled() { return this.on; }
  
  enable() {
    this.on = true;
    console.log('Radio: Turning ON');
  }
  
  disable() {
    this.on = false;
    console.log('Radio: Turning OFF');
  }
  
  getVolume() { return this.volume; }
  
  setVolume(volume) {
    this.volume = Math.max(0, Math.min(100, volume));
    console.log(`Radio: Volume set to ${this.volume}`);
  }
  
  getChannel() { return this.frequency; }
  
  setChannel(frequency) {
    this.frequency = Math.max(87.5, Math.min(108.0, frequency));
    console.log(`Radio: Frequency set to ${this.frequency} FM`);
  }
}

class SmartSpeaker extends Device {
  constructor() {
    super();
    this.on = false;
    this.volume = 50;
    this.station = 'Spotify';
  }
  
  isEnabled() { return this.on; }
  
  enable() {
    this.on = true;
    console.log('Smart Speaker: Waking up... "Hey, I\'m listening!"');
  }
  
  disable() {
    this.on = false;
    console.log('Smart Speaker: Going to sleep...');
  }
  
  getVolume() { return this.volume; }
  
  setVolume(volume) {
    this.volume = Math.max(0, Math.min(100, volume));
    console.log(`Smart Speaker: Volume set to ${this.volume}`);
  }
  
  getChannel() { return this.station; }
  
  setChannel(station) {
    this.station = station;
    console.log(`Smart Speaker: Playing ${this.station}`);
  }
  
  // Smart speaker-specific
  voiceCommand(command) {
    console.log(`Smart Speaker: Processing "${command}"...`);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ABSTRACTION: Remote Control
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class RemoteControl {
  constructor(device) {
    this.device = device; // Bridge to implementation
  }
  
  togglePower() {
    console.log('\n[Remote] Toggle Power');
    if (this.device.isEnabled()) {
      this.device.disable();
    } else {
      this.device.enable();
    }
  }
  
  volumeUp() {
    console.log('\n[Remote] Volume Up');
    this.device.setVolume(this.device.getVolume() + 10);
  }
  
  volumeDown() {
    console.log('\n[Remote] Volume Down');
    this.device.setVolume(this.device.getVolume() - 10);
  }
  
  channelUp() {
    console.log('\n[Remote] Channel Up');
    this.device.setChannel(this.device.getChannel() + 1);
  }
  
  channelDown() {
    console.log('\n[Remote] Channel Down');
    this.device.setChannel(this.device.getChannel() - 1);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REFINED ABSTRACTION: Advanced Remote
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class AdvancedRemoteControl extends RemoteControl {
  constructor(device) {
    super(device);
    this.savedVolume = null;
  }
  
  mute() {
    console.log('\n[Advanced Remote] Mute');
    this.savedVolume = this.device.getVolume();
    this.device.setVolume(0);
  }
  
  unmute() {
    if (this.savedVolume !== null) {
      console.log('\n[Advanced Remote] Unmute');
      this.device.setVolume(this.savedVolume);
      this.savedVolume = null;
    }
  }
  
  setChannel(channel) {
    console.log(`\n[Advanced Remote] Set Channel to ${channel}`);
    this.device.setChannel(channel);
  }
  
  showInfo() {
    console.log('\n[Advanced Remote] Device Info:');
    console.log(`  Power: ${this.device.isEnabled() ? 'ON' : 'OFF'}`);
    console.log(`  Volume: ${this.device.getVolume()}`);
    console.log(`  Channel: ${this.device.getChannel()}`);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Voice Remote (another refined abstraction)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class VoiceRemoteControl extends AdvancedRemoteControl {
  processVoiceCommand(command) {
    console.log(`\n[Voice Remote] Processing: "${command}"`);
    
    const cmd = command.toLowerCase();
    
    if (cmd.includes('turn on') || cmd.includes('power on')) {
      if (!this.device.isEnabled()) this.device.enable();
    } else if (cmd.includes('turn off') || cmd.includes('power off')) {
      if (this.device.isEnabled()) this.device.disable();
    } else if (cmd.includes('volume up') || cmd.includes('louder')) {
      this.volumeUp();
    } else if (cmd.includes('volume down') || cmd.includes('quieter')) {
      this.volumeDown();
    } else if (cmd.includes('mute')) {
      this.mute();
    } else if (cmd.includes('channel')) {
      const match = cmd.match(/channel (\d+)/);
      if (match) {
        this.setChannel(parseInt(match[1]));
      }
    } else {
      console.log('  Command not recognized');
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USAGE: Any remote works with any device
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

console.log('========== TV with Basic Remote ==========');
const tv = new TV();
const tvRemote = new RemoteControl(tv);

tvRemote.togglePower();
tvRemote.volumeUp();
tvRemote.channelUp();

console.log('\n========== Radio with Advanced Remote ==========');
const radio = new Radio();
const radioRemote = new AdvancedRemoteControl(radio);

radioRemote.togglePower();
radioRemote.setChannel(95.5);
radioRemote.volumeUp();
radioRemote.showInfo();
radioRemote.mute();

console.log('\n========== Smart Speaker with Voice Remote ==========');
const speaker = new SmartSpeaker();
const voiceRemote = new VoiceRemoteControl(speaker);

voiceRemote.processVoiceCommand('Turn on');
voiceRemote.processVoiceCommand('Volume up');
voiceRemote.processVoiceCommand('Channel Spotify Daily Mix');
voiceRemote.showInfo();

// The beauty: We can easily add new devices or new remotes!
// New Device (e.g., Projector) = ONE new class implementing Device
// New Remote (e.g., AppRemote) = ONE new class extending RemoteControl
```

### Cross-Platform UI Example

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// IMPLEMENTATION: Renderer Interface
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Renderer {
  renderButton(x, y, width, height, label) { throw new Error('Must implement'); }
  renderTextInput(x, y, width, height, placeholder) { throw new Error('Must implement'); }
  renderCheckbox(x, y, label, checked) { throw new Error('Must implement'); }
  renderDropdown(x, y, width, options, selected) { throw new Error('Must implement'); }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONCRETE IMPLEMENTATIONS: Platform Renderers
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class WebRenderer extends Renderer {
  renderButton(x, y, width, height, label) {
    return `<button style="position:absolute;left:${x}px;top:${y}px;width:${width}px;height:${height}px">${label}</button>`;
  }
  
  renderTextInput(x, y, width, height, placeholder) {
    return `<input type="text" placeholder="${placeholder}" style="position:absolute;left:${x}px;top:${y}px;width:${width}px;height:${height}px" />`;
  }
  
  renderCheckbox(x, y, label, checked) {
    return `<label style="position:absolute;left:${x}px;top:${y}px"><input type="checkbox" ${checked ? 'checked' : ''} />${label}</label>`;
  }
  
  renderDropdown(x, y, width, options, selected) {
    const optionsHTML = options.map(o => 
      `<option ${o === selected ? 'selected' : ''}>${o}</option>`
    ).join('');
    return `<select style="position:absolute;left:${x}px;top:${y}px;width:${width}px">${optionsHTML}</select>`;
  }
}

class CanvasRenderer extends Renderer {
  constructor(ctx) {
    super();
    this.ctx = ctx;
  }
  
  renderButton(x, y, width, height, label) {
    console.log(`Canvas: Draw button at (${x},${y}) "${label}"`);
    return { type: 'button', x, y, width, height, label };
  }
  
  renderTextInput(x, y, width, height, placeholder) {
    console.log(`Canvas: Draw input at (${x},${y}) placeholder="${placeholder}"`);
    return { type: 'input', x, y, width, height, placeholder };
  }
  
  renderCheckbox(x, y, label, checked) {
    console.log(`Canvas: Draw checkbox at (${x},${y}) "${label}" checked=${checked}`);
    return { type: 'checkbox', x, y, label, checked };
  }
  
  renderDropdown(x, y, width, options, selected) {
    console.log(`Canvas: Draw dropdown at (${x},${y}) with ${options.length} options`);
    return { type: 'dropdown', x, y, width, options, selected };
  }
}

class ConsoleRenderer extends Renderer {
  renderButton(x, y, width, height, label) {
    return `[ ${label} ]`;
  }
  
  renderTextInput(x, y, width, height, placeholder) {
    return `[_${placeholder}_______]`;
  }
  
  renderCheckbox(x, y, label, checked) {
    return `[${checked ? 'x' : ' '}] ${label}`;
  }
  
  renderDropdown(x, y, width, options, selected) {
    return `[${selected} â–¼]`;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ABSTRACTION: UI Components
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class UIComponent {
  constructor(renderer) {
    this.renderer = renderer; // Bridge
    this.x = 0;
    this.y = 0;
  }
  
  setPosition(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  
  render() {
    throw new Error('Must implement');
  }
}

class Button extends UIComponent {
  constructor(renderer, label, onClick) {
    super(renderer);
    this.label = label;
    this.width = 100;
    this.height = 30;
    this.onClick = onClick;
  }
  
  setSize(width, height) {
    this.width = width;
    this.height = height;
    return this;
  }
  
  render() {
    return this.renderer.renderButton(
      this.x, this.y, this.width, this.height, this.label
    );
  }
}

class TextInput extends UIComponent {
  constructor(renderer, placeholder = '') {
    super(renderer);
    this.placeholder = placeholder;
    this.width = 200;
    this.height = 30;
    this.value = '';
  }
  
  render() {
    return this.renderer.renderTextInput(
      this.x, this.y, this.width, this.height, this.placeholder
    );
  }
}

class Checkbox extends UIComponent {
  constructor(renderer, label, checked = false) {
    super(renderer);
    this.label = label;
    this.checked = checked;
  }
  
  toggle() {
    this.checked = !this.checked;
    return this;
  }
  
  render() {
    return this.renderer.renderCheckbox(
      this.x, this.y, this.label, this.checked
    );
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REFINED ABSTRACTION: Complex Components
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Form extends UIComponent {
  constructor(renderer) {
    super(renderer);
    this.components = [];
    this.currentY = 0;
  }
  
  addComponent(component) {
    component.setPosition(this.x + 10, this.y + this.currentY);
    this.components.push(component);
    this.currentY += 40;
    return this;
  }
  
  render() {
    console.log('\n=== Rendering Form ===\n');
    return this.components.map(c => c.render());
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USAGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Web platform
console.log('========== Web Rendering ==========');
const webRenderer = new WebRenderer();
const webForm = new Form(webRenderer);
webForm
  .addComponent(new TextInput(webRenderer, 'Username'))
  .addComponent(new TextInput(webRenderer, 'Password'))
  .addComponent(new Checkbox(webRenderer, 'Remember me'))
  .addComponent(new Button(webRenderer, 'Login'));

const webOutput = webForm.render();
console.log(webOutput.join('\n'));

// Console platform
console.log('\n========== Console Rendering ==========');
const consoleRenderer = new ConsoleRenderer();
const consoleForm = new Form(consoleRenderer);
consoleForm
  .addComponent(new TextInput(consoleRenderer, 'Username'))
  .addComponent(new TextInput(consoleRenderer, 'Password'))
  .addComponent(new Checkbox(consoleRenderer, 'Remember me'))
  .addComponent(new Button(consoleRenderer, 'Login'));

const consoleOutput = consoleForm.render();
console.log(consoleOutput.join('\n'));

// Same Form class, different Renderers!
// Adding new platform = ONE new Renderer class
// Adding new component = ONE new UIComponent class
```

---

## 15.3 Database Abstraction Example

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Implementation: Database Driver Interface
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class DatabaseDriver {
  connect(config) { throw new Error('Must implement'); }
  disconnect() { throw new Error('Must implement'); }
  execute(query, params) { throw new Error('Must implement'); }
  beginTransaction() { throw new Error('Must implement'); }
  commit() { throw new Error('Must implement'); }
  rollback() { throw new Error('Must implement'); }
}

class MySQLDriver extends DatabaseDriver {
  connect(config) {
    console.log(`MySQL: Connecting to ${config.host}:${config.port}`);
    return this;
  }
  
  disconnect() {
    console.log('MySQL: Disconnected');
  }
  
  execute(query, params = []) {
    console.log(`MySQL: Executing "${query}" with params:`, params);
    return []; // Simulated result
  }
  
  beginTransaction() {
    console.log('MySQL: START TRANSACTION');
  }
  
  commit() {
    console.log('MySQL: COMMIT');
  }
  
  rollback() {
    console.log('MySQL: ROLLBACK');
  }
}

class PostgreSQLDriver extends DatabaseDriver {
  connect(config) {
    console.log(`PostgreSQL: Connecting to ${config.host}:${config.port}`);
    return this;
  }
  
  disconnect() {
    console.log('PostgreSQL: Disconnected');
  }
  
  execute(query, params = []) {
    console.log(`PostgreSQL: Executing "${query}" with params:`, params);
    return [];
  }
  
  beginTransaction() {
    console.log('PostgreSQL: BEGIN');
  }
  
  commit() {
    console.log('PostgreSQL: COMMIT');
  }
  
  rollback() {
    console.log('PostgreSQL: ROLLBACK');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Abstraction: Repository Base
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Repository {
  constructor(driver, tableName) {
    this.driver = driver; // Bridge to implementation
    this.tableName = tableName;
  }
  
  findAll() {
    return this.driver.execute(`SELECT * FROM ${this.tableName}`);
  }
  
  findById(id) {
    return this.driver.execute(
      `SELECT * FROM ${this.tableName} WHERE id = ?`,
      [id]
    );
  }
  
  create(data) {
    const columns = Object.keys(data).join(', ');
    const placeholders = Object.keys(data).map(() => '?').join(', ');
    return this.driver.execute(
      `INSERT INTO ${this.tableName} (${columns}) VALUES (${placeholders})`,
      Object.values(data)
    );
  }
  
  update(id, data) {
    const setClause = Object.keys(data).map(k => `${k} = ?`).join(', ');
    return this.driver.execute(
      `UPDATE ${this.tableName} SET ${setClause} WHERE id = ?`,
      [...Object.values(data), id]
    );
  }
  
  delete(id) {
    return this.driver.execute(
      `DELETE FROM ${this.tableName} WHERE id = ?`,
      [id]
    );
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Refined Abstraction: Specialized Repositories
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class UserRepository extends Repository {
  constructor(driver) {
    super(driver, 'users');
  }
  
  findByEmail(email) {
    return this.driver.execute(
      'SELECT * FROM users WHERE email = ?',
      [email]
    );
  }
  
  findActive() {
    return this.driver.execute(
      'SELECT * FROM users WHERE active = ?',
      [true]
    );
  }
}

class OrderRepository extends Repository {
  constructor(driver) {
    super(driver, 'orders');
  }
  
  findByUser(userId) {
    return this.driver.execute(
      'SELECT * FROM orders WHERE user_id = ?',
      [userId]
    );
  }
  
  findPending() {
    return this.driver.execute(
      "SELECT * FROM orders WHERE status = ?",
      ['pending']
    );
  }
  
  createWithItems(orderData, items) {
    this.driver.beginTransaction();
    try {
      this.create(orderData);
      items.forEach(item => {
        this.driver.execute(
          'INSERT INTO order_items (order_id, product_id, quantity) VALUES (?, ?, ?)',
          [orderData.id, item.productId, item.quantity]
        );
      });
      this.driver.commit();
    } catch (error) {
      this.driver.rollback();
      throw error;
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Usage: Same repositories work with any database
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

console.log('========== Using MySQL ==========\n');
const mysqlDriver = new MySQLDriver();
mysqlDriver.connect({ host: 'localhost', port: 3306 });

const mysqlUserRepo = new UserRepository(mysqlDriver);
mysqlUserRepo.findAll();
mysqlUserRepo.findByEmail('john@example.com');
mysqlUserRepo.create({ name: 'John', email: 'john@example.com' });

console.log('\n========== Using PostgreSQL ==========\n');
const pgDriver = new PostgreSQLDriver();
pgDriver.connect({ host: 'localhost', port: 5432 });

const pgUserRepo = new UserRepository(pgDriver);
pgUserRepo.findAll();
pgUserRepo.findByEmail('jane@example.com');

const pgOrderRepo = new OrderRepository(pgDriver);
pgOrderRepo.createWithItems(
  { id: 1, userId: 1, total: 100 },
  [{ productId: 1, quantity: 2 }, { productId: 2, quantity: 1 }]
);

// Switching databases only requires changing the driver!
// All repository logic remains the same
```

---

## 15.4 When to Use Bridge

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                WHEN TO USE BRIDGE                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  âœ… USE WHEN:                                               â”‚
â”‚  â€¢ Abstraction and implementation should vary independently â”‚
â”‚  â€¢ Avoiding permanent binding between abstraction & impl    â”‚
â”‚  â€¢ Both abstraction and implementation need extension       â”‚
â”‚  â€¢ Changes in implementation shouldn't affect client code   â”‚
â”‚  â€¢ You want to share implementation among multiple objects  â”‚
â”‚  â€¢ You need to switch implementations at runtime            â”‚
â”‚                                                             â”‚
â”‚  âŒ AVOID WHEN:                                             â”‚
â”‚  â€¢ Only one implementation exists                           â”‚
â”‚  â€¢ Implementation won't change                              â”‚
â”‚  â€¢ Abstraction hierarchy is simple                          â”‚
â”‚                                                             â”‚
â”‚  COMMON USE CASES:                                          â”‚
â”‚  â€¢ Cross-platform applications (UI, graphics)               â”‚
â”‚  â€¢ Database abstraction layers                              â”‚
â”‚  â€¢ Device drivers                                           â”‚
â”‚  â€¢ Remote interfaces (API clients)                          â”‚
â”‚  â€¢ Graphics/rendering engines                               â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Key Takeaways

1. **Bridge separates abstraction from implementation** - Both can vary independently
2. **Prevents class explosion** - N + M classes instead of N Ã— M
3. **Composition over inheritance** - Uses "has-a" relationship
4. **Planned upfront** - Unlike Adapter (applied after)
5. **Runtime flexibility** - Can switch implementations dynamically
6. **Use for**: Cross-platform code, database drivers, renderers

> ğŸ’¡ **Interview Tip:** Explain Bridge with the remote control and device example. The remote (abstraction) works with any device (implementation) through a common interface.

> ğŸ­ **Production Note:** ORMs like Sequelize and TypeORM use Bridge pattern - same repository interface, different database drivers.
