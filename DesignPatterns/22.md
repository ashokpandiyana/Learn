# Chapter 22: Chain of Responsibility Pattern - In-Depth Guide

## üéØ Core Concept

The **Chain of Responsibility Pattern** passes requests along a chain of handlers. Each handler decides either to process the request or to pass it to the next handler in the chain. This decouples senders from receivers and allows multiple objects a chance to handle the request.

### Visual Representation

```
Request ‚Üí Handler1 ‚Üí Handler2 ‚Üí Handler3 ‚Üí Handler4
           ‚Üì          ‚Üì          ‚Üì          ‚Üì
         Process    Process    Process    Process
           or         or         or         or
          Pass       Pass       Pass       Pass
```

## üîë Key Components

1. **Handler**: Defines interface for handling requests and optional reference to successor
2. **Concrete Handlers**: Handle requests they're responsible for; forward others to successor
3. **Client**: Initiates request to a handler in the chain

## üíª Classic Implementation

```javascript
// Abstract Handler
class Handler {
  constructor() {
    this.nextHandler = null;
  }
  
  setNext(handler) {
    this.nextHandler = handler;
    return handler; // Allows chaining: h1.setNext(h2).setNext(h3)
  }
  
  handle(request) {
    if (this.nextHandler) {
      return this.nextHandler.handle(request);
    }
    return null;
  }
}

// Concrete Handler 1: Level 1 Support
class Level1Support extends Handler {
  handle(request) {
    if (request.complexity === 'basic') {
      return `Level 1: Resolved - ${request.issue}`;
    }
    console.log('Level 1: Escalating...');
    return super.handle(request);
  }
}

// Concrete Handler 2: Level 2 Support
class Level2Support extends Handler {
  handle(request) {
    if (request.complexity === 'moderate') {
      return `Level 2: Resolved - ${request.issue}`;
    }
    console.log('Level 2: Escalating...');
    return super.handle(request);
  }
}

// Concrete Handler 3: Level 3 Support
class Level3Support extends Handler {
  handle(request) {
    if (request.complexity === 'complex') {
      return `Level 3: Resolved - ${request.issue}`;
    }
    console.log('Level 3: Escalating to management...');
    return super.handle(request);
  }
}

// Concrete Handler 4: Management
class Management extends Handler {
  handle(request) {
    return `Management: Taking ownership - ${request.issue}`;
  }
}

// Setup the chain
const level1 = new Level1Support();
const level2 = new Level2Support();
const level3 = new Level3Support();
const management = new Management();

level1.setNext(level2).setNext(level3).setNext(management);

// Usage
const requests = [
  { issue: 'Password reset', complexity: 'basic' },
  { issue: 'Software configuration', complexity: 'moderate' },
  { issue: 'Server architecture', complexity: 'complex' },
  { issue: 'Major outage', complexity: 'critical' }
];

requests.forEach(request => {
  console.log(`\nProcessing: ${request.issue}`);
  const result = level1.handle(request);
  console.log(`Result: ${result}\n`);
});
```

## üöÄ Modern Express.js Style Middleware

```javascript
// Middleware pattern (Chain of Responsibility in practice)
class MiddlewareChain {
  constructor() {
    this.middlewares = [];
  }
  
  use(middleware) {
    this.middlewares.push(middleware);
    return this;
  }
  
  async execute(context) {
    let index = 0;
    
    const next = async () => {
      if (index >= this.middlewares.length) {
        return;
      }
      
      const middleware = this.middlewares[index++];
      await middleware(context, next);
    };
    
    await next();
  }
}

// Example: HTTP Request Processing
const app = new MiddlewareChain();

// Logger middleware
app.use(async (ctx, next) => {
  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.url}`);
  ctx.startTime = Date.now();
  await next();
  const duration = Date.now() - ctx.startTime;
  console.log(`Request completed in ${duration}ms`);
});

// Authentication middleware
app.use(async (ctx, next) => {
  const token = ctx.headers?.authorization;
  if (!token) {
    ctx.status = 401;
    ctx.body = { error: 'Unauthorized' };
    return; // Stop the chain
  }
  
  // Verify token (simplified)
  ctx.user = { id: 1, name: 'John Doe' };
  console.log(`Authenticated user: ${ctx.user.name}`);
  await next();
});

// Rate limiting middleware
app.use(async (ctx, next) => {
  const userRequests = rateLimit.get(ctx.user.id) || 0;
  
  if (userRequests >= 100) {
    ctx.status = 429;
    ctx.body = { error: 'Too many requests' };
    return;
  }
  
  rateLimit.set(ctx.user.id, userRequests + 1);
  await next();
});

// Request validation middleware
app.use(async (ctx, next) => {
  if (ctx.method === 'POST' && !ctx.body) {
    ctx.status = 400;
    ctx.body = { error: 'Request body required' };
    return;
  }
  await next();
});

// Main handler
app.use(async (ctx, next) => {
  ctx.status = 200;
  ctx.body = { message: 'Success', data: ctx.body };
  await next();
});

// Usage
const rateLimit = new Map();

const request1 = {
  method: 'GET',
  url: '/api/users',
  headers: { authorization: 'Bearer token123' }
};

app.execute(request1);
```

## üîê Advanced: Authentication Chain

```javascript
class AuthHandler {
  constructor() {
    this.next = null;
  }
  
  setNext(handler) {
    this.next = handler;
    return handler;
  }
  
  async authenticate(credentials) {
    throw new Error('authenticate() must be implemented');
  }
  
  async handle(credentials) {
    const result = await this.authenticate(credentials);
    if (result.success) {
      return result;
    }
    
    if (this.next) {
      console.log(`${this.constructor.name} failed, trying next...`);
      return this.next.handle(credentials);
    }
    
    return { success: false, message: 'All authentication methods failed' };
  }
}

class LocalAuthHandler extends AuthHandler {
  constructor(users) {
    super();
    this.users = users;
  }
  
  async authenticate(credentials) {
    console.log('Trying local authentication...');
    
    if (credentials.username && credentials.password) {
      const user = this.users.find(
        u => u.username === credentials.username && 
             u.password === credentials.password
      );
      
      if (user) {
        return {
          success: true,
          method: 'local',
          user: { id: user.id, username: user.username }
        };
      }
    }
    
    return { success: false };
  }
}

class TokenAuthHandler extends AuthHandler {
  constructor(validTokens) {
    super();
    this.validTokens = validTokens;
  }
  
  async authenticate(credentials) {
    console.log('Trying token authentication...');
    
    if (credentials.token) {
      const tokenData = this.validTokens.get(credentials.token);
      
      if (tokenData && tokenData.expiresAt > Date.now()) {
        return {
          success: true,
          method: 'token',
          user: tokenData.user
        };
      }
    }
    
    return { success: false };
  }
}

class OAuthHandler extends AuthHandler {
  constructor(oauthProviders) {
    super();
    this.providers = oauthProviders;
  }
  
  async authenticate(credentials) {
    console.log('Trying OAuth authentication...');
    
    if (credentials.provider && credentials.accessToken) {
      const provider = this.providers[credentials.provider];
      
      if (provider) {
        // Simulate OAuth verification
        const isValid = credentials.accessToken.startsWith('oauth_');
        
        if (isValid) {
          return {
            success: true,
            method: 'oauth',
            provider: credentials.provider,
            user: { id: 'oauth_user', username: 'OAuth User' }
          };
        }
      }
    }
    
    return { success: false };
  }
}

class BiometricAuthHandler extends AuthHandler {
  async authenticate(credentials) {
    console.log('Trying biometric authentication...');
    
    if (credentials.biometric) {
      // Simulate biometric verification
      const isValid = credentials.biometric === 'fingerprint_match';
      
      if (isValid) {
        return {
          success: true,
          method: 'biometric',
          user: { id: 'bio_user', username: 'Biometric User' }
        };
      }
    }
    
    return { success: false };
  }
}

// Setup authentication chain
const users = [
  { id: 1, username: 'admin', password: 'admin123' },
  { id: 2, username: 'user', password: 'user123' }
];

const tokens = new Map([
  ['token_abc123', { user: { id: 3, username: 'Token User' }, expiresAt: Date.now() + 3600000 }]
]);

const oauthProviders = {
  google: true,
  github: true
};

const localAuth = new LocalAuthHandler(users);
const tokenAuth = new TokenAuthHandler(tokens);
const oauthAuth = new OAuthHandler(oauthProviders);
const biometricAuth = new BiometricAuthHandler();

// Chain them together
localAuth.setNext(tokenAuth).setNext(oauthAuth).setNext(biometricAuth);

// Test different authentication methods
async function testAuth() {
  // Test 1: Local auth
  console.log('\n=== Test 1: Local Authentication ===');
  let result = await localAuth.handle({ 
    username: 'admin', 
    password: 'admin123' 
  });
  console.log('Result:', result);
  
  // Test 2: Token auth
  console.log('\n=== Test 2: Token Authentication ===');
  result = await localAuth.handle({ 
    token: 'token_abc123' 
  });
  console.log('Result:', result);
  
  // Test 3: OAuth
  console.log('\n=== Test 3: OAuth Authentication ===');
  result = await localAuth.handle({ 
    provider: 'google', 
    accessToken: 'oauth_xyz789' 
  });
  console.log('Result:', result);
  
  // Test 4: Failed auth
  console.log('\n=== Test 4: Failed Authentication ===');
  result = await localAuth.handle({ 
    username: 'wrong', 
    password: 'wrong' 
  });
  console.log('Result:', result);
}

testAuth();
```

## üìã Validation Chain Example

```javascript
class Validator {
  constructor() {
    this.next = null;
  }
  
  setNext(validator) {
    this.next = validator;
    return validator;
  }
  
  validate(data) {
    throw new Error('validate() must be implemented');
  }
  
  check(data) {
    const errors = this.validate(data);
    
    if (errors.length > 0) {
      return errors;
    }
    
    if (this.next) {
      return this.next.check(data);
    }
    
    return [];
  }
}

class RequiredFieldsValidator extends Validator {
  constructor(fields) {
    super();
    this.requiredFields = fields;
  }
  
  validate(data) {
    const errors = [];
    
    this.requiredFields.forEach(field => {
      if (!data[field]) {
        errors.push(`${field} is required`);
      }
    });
    
    return errors;
  }
}

class EmailValidator extends Validator {
  validate(data) {
    const errors = [];
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    
    if (data.email && !emailRegex.test(data.email)) {
      errors.push('Invalid email format');
    }
    
    return errors;
  }
}

class PasswordStrengthValidator extends Validator {
  validate(data) {
    const errors = [];
    
    if (data.password) {
      if (data.password.length < 8) {
        errors.push('Password must be at least 8 characters');
      }
      if (!/[A-Z]/.test(data.password)) {
        errors.push('Password must contain uppercase letter');
      }
      if (!/[0-9]/.test(data.password)) {
        errors.push('Password must contain a number');
      }
      if (!/[!@#$%^&*]/.test(data.password)) {
        errors.push('Password must contain special character');
      }
    }
    
    return errors;
  }
}

class AgeValidator extends Validator {
  constructor(minAge = 18) {
    super();
    this.minAge = minAge;
  }
  
  validate(data) {
    const errors = [];
    
    if (data.age !== undefined) {
      if (data.age < this.minAge) {
        errors.push(`Must be at least ${this.minAge} years old`);
      }
      if (data.age > 150) {
        errors.push('Invalid age');
      }
    }
    
    return errors;
  }
}

// Setup validation chain
const requiredValidator = new RequiredFieldsValidator(['username', 'email', 'password']);
const emailValidator = new EmailValidator();
const passwordValidator = new PasswordStrengthValidator();
const ageValidator = new AgeValidator(18);

requiredValidator
  .setNext(emailValidator)
  .setNext(passwordValidator)
  .setNext(ageValidator);

// Test cases
const testData = [
  {
    username: 'john_doe',
    email: 'john@example.com',
    password: 'SecurePass123!',
    age: 25
  },
  {
    username: '',
    email: 'invalid-email',
    password: 'weak',
    age: 15
  },
  {
    username: 'jane_doe',
    email: 'jane@example.com',
    password: 'NoSpecialChar123',
    age: 30
  }
];

testData.forEach((data, index) => {
  console.log(`\n=== Test Case ${index + 1} ===`);
  console.log('Data:', data);
  const errors = requiredValidator.check(data);
  
  if (errors.length === 0) {
    console.log('‚úÖ Validation passed!');
  } else {
    console.log('‚ùå Validation failed:');
    errors.forEach(error => console.log(`  - ${error}`));
  }
});
```

## üí≥ Payment Processing Chain

```javascript
class PaymentHandler {
  constructor(name) {
    this.name = name;
    this.next = null;
  }
  
  setNext(handler) {
    this.next = handler;
    return handler;
  }
  
  canProcess(amount) {
    return false;
  }
  
  processPayment(amount) {
    throw new Error('processPayment() must be implemented');
  }
  
  handle(amount) {
    if (this.canProcess(amount)) {
      return this.processPayment(amount);
    }
    
    if (this.next) {
      console.log(`${this.name} cannot process $${amount}, forwarding...`);
      return this.next.handle(amount);
    }
    
    return { success: false, message: 'No payment method can handle this amount' };
  }
}

class CashPayment extends PaymentHandler {
  constructor(availableCash) {
    super('Cash');
    this.availableCash = availableCash;
  }
  
  canProcess(amount) {
    return amount <= this.availableCash;
  }
  
  processPayment(amount) {
    this.availableCash -= amount;
    return {
      success: true,
      method: 'Cash',
      amount,
      remaining: this.availableCash
    };
  }
}

class DebitCardPayment extends PaymentHandler {
  constructor(balance) {
    super('Debit Card');
    this.balance = balance;
  }
  
  canProcess(amount) {
    return amount <= this.balance;
  }
  
  processPayment(amount) {
    this.balance -= amount;
    return {
      success: true,
      method: 'Debit Card',
      amount,
      remaining: this.balance
    };
  }
}

class CreditCardPayment extends PaymentHandler {
  constructor(creditLimit, currentDebt = 0) {
    super('Credit Card');
    this.creditLimit = creditLimit;
    this.currentDebt = currentDebt;
  }
  
  canProcess(amount) {
    return (this.currentDebt + amount) <= this.creditLimit;
  }
  
  processPayment(amount) {
    this.currentDebt += amount;
    return {
      success: true,
      method: 'Credit Card',
      amount,
      creditUsed: this.currentDebt,
      creditAvailable: this.creditLimit - this.currentDebt
    };
  }
}

class BankLoanPayment extends PaymentHandler {
  constructor() {
    super('Bank Loan');
  }
  
  canProcess(amount) {
    return amount >= 1000; // Only for large amounts
  }
  
  processPayment(amount) {
    return {
      success: true,
      method: 'Bank Loan',
      amount,
      message: 'Loan approved with 5% interest'
    };
  }
}

// Setup payment chain
const cash = new CashPayment(100);
const debitCard = new DebitCardPayment(500);
const creditCard = new CreditCardPayment(2000, 200);
const bankLoan = new BankLoanPayment();

cash.setNext(debitCard).setNext(creditCard).setNext(bankLoan);

// Process payments
const purchases = [50, 150, 1000, 5000];

purchases.forEach(amount => {
  console.log(`\n=== Processing payment of $${amount} ===`);
  const result = cash.handle(amount);
  console.log('Result:', result);
});
```

## üåê Real-World: DOM Event Bubbling

```javascript
// DOM Event Bubbling is Chain of Responsibility in action!

class DOMElement {
  constructor(tag, id) {
    this.tag = tag;
    this.id = id;
    this.parent = null;
    this.eventListeners = new Map();
  }
  
  setParent(parent) {
    this.parent = parent;
    return this;
  }
  
  addEventListener(eventType, handler, stopPropagation = false) {
    if (!this.eventListeners.has(eventType)) {
      this.eventListeners.set(eventType, []);
    }
    this.eventListeners.get(eventType).push({ handler, stopPropagation });
  }
  
  dispatchEvent(event) {
    console.log(`Event '${event.type}' reached <${this.tag}#${this.id}>`);
    
    const listeners = this.eventListeners.get(event.type) || [];
    
    for (const { handler, stopPropagation } of listeners) {
      handler(event);
      
      if (stopPropagation || event.propagationStopped) {
        console.log(`Propagation stopped at <${this.tag}#${this.id}>`);
        return;
      }
    }
    
    // Bubble up to parent
    if (this.parent && !event.propagationStopped) {
      console.log(`Bubbling up to parent...`);
      this.parent.dispatchEvent(event);
    }
  }
}

class Event {
  constructor(type, target) {
    this.type = type;
    this.target = target;
    this.propagationStopped = false;
  }
  
  stopPropagation() {
    this.propagationStopped = true;
  }
}

// Create DOM-like structure: document > body > div > button
const document = new DOMElement('document', 'root');
const body = new DOMElement('body', 'body').setParent(document);
const div = new DOMElement('div', 'container').setParent(body);
const button = new DOMElement('button', 'submit-btn').setParent(div);

// Add event listeners at different levels
document.addEventListener('click', (e) => {
  console.log('  ‚Üí Document handler executed');
});

body.addEventListener('click', (e) => {
  console.log('  ‚Üí Body handler executed');
});

div.addEventListener('click', (e) => {
  console.log('  ‚Üí Div handler executed');
  // e.stopPropagation(); // Uncomment to stop bubbling
});

button.addEventListener('click', (e) => {
  console.log('  ‚Üí Button handler executed');
});

// Dispatch click event from button
console.log('=== Clicking button ===\n');
const clickEvent = new Event('click', button);
button.dispatchEvent(clickEvent);
```

## ‚úÖ When to Use Chain of Responsibility

**Use this pattern when:**
- Multiple objects can handle a request, and the handler isn't known a priori
- You want to issue a request to one of several objects without specifying the receiver explicitly
- The set of objects that can handle a request should be specified dynamically
- You want to decouple senders from receivers

**Don't use when:**
- Every request must be handled (no option to pass along)
- The chain is too long (performance concerns)
- Handlers are simple and few (just use if-else or switch)

## üéØ Benefits & Trade-offs

### Benefits
- **Decoupling**: Sender doesn't need to know the receiver
- **Flexibility**: Add/remove handlers dynamically
- **Responsibility distribution**: Each handler focuses on one responsibility
- **Open/Closed Principle**: Easy to add new handlers

### Trade-offs
- **No guarantee of handling**: Request might not be handled
- **Debugging difficulty**: Hard to trace execution flow
- **Performance**: Each request traverses the chain
- **Complex setup**: Requires careful chain configuration

## üí° Pro Tips

1. **Document the chain order** clearly
2. **Add logging** for debugging
3. **Consider performance** with long chains
4. **Implement timeout** for async chains
5. **Handle the "no handler" case** explicitly
6. **Make handlers independent** when possible
7. **Use middleware libraries** (Express, Koa) instead of reinventing
8. **Consider alternatives**: If every request needs handling, use Strategy or Command pattern instead