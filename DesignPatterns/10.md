# Chapter 10: Adapter Pattern

## 10.1 Concept

### What is the Adapter Pattern?

The Adapter Pattern **converts the interface of a class into another interface** that clients expect. It allows classes with incompatible interfaces to work together.

Think of it like a power adapter: your laptop has a US plug, but you're in Europe. The adapter doesn't change your laptop or the European outletâ€”it just makes them compatible.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ADAPTER PATTERN                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   Without Adapter:                                          â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          âœ—          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚   â”‚   Client   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚   Adaptee  â”‚         â”‚
â”‚   â”‚            â”‚    Incompatible!    â”‚            â”‚         â”‚
â”‚   â”‚ expects    â”‚                     â”‚ has        â”‚         â”‚
â”‚   â”‚ methodA()  â”‚                     â”‚ methodX()  â”‚         â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                             â”‚
â”‚   With Adapter:                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚   â”‚   Client   â”‚â”€â”€â”€â”‚  Adapter  â”‚â”€â”€â”€â”€â”‚  Adaptee   â”‚         â”‚
â”‚   â”‚            â”‚   â”‚           â”‚    â”‚            â”‚         â”‚
â”‚   â”‚ calls      â”‚   â”‚ methodA() â”‚    â”‚ has        â”‚         â”‚
â”‚   â”‚ methodA()  â”‚   â”‚ calls     â”‚    â”‚ methodX()  â”‚         â”‚
â”‚   â”‚            â”‚   â”‚ methodX() â”‚    â”‚            â”‚         â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                             â”‚
â”‚   Adapter translates between interfaces                     â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### When to Use Adapter

| Scenario | Example |
|----------|---------|
| **Legacy Integration** | Old payment system â†’ New interface |
| **Third-party Libraries** | Different analytics APIs â†’ Unified interface |
| **API Version Differences** | Old API format â†’ New format |
| **Data Format Conversion** | XML system â†’ JSON interface |
| **Testing/Mocking** | Real service â†’ Mock adapter |

---

## 10.2 Implementation Types

### Object Adapter (Composition) - Recommended

Uses composition: the adapter holds an instance of the adaptee.

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TARGET: Interface that the client expects
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class ModernPaymentProcessor {
  processPayment(amount, currency, cardDetails) {
    throw new Error('Method must be implemented');
  }
  
  refund(transactionId, amount) {
    throw new Error('Method must be implemented');
  }
  
  getTransactionStatus(transactionId) {
    throw new Error('Method must be implemented');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ADAPTEE: Existing class with incompatible interface
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class LegacyPaymentSystem {
  constructor() {
    this.transactions = new Map();
  }
  
  // Old method signatures
  makePayment(cardNumber, expiryDate, cvv, amountInCents) {
    const txId = 'TXN_' + Date.now();
    this.transactions.set(txId, {
      amount: amountInCents,
      status: 'completed',
      card: cardNumber.slice(-4)
    });
    console.log(`Legacy: Processed ${amountInCents} cents`);
    return { transactionId: txId, success: true };
  }
  
  cancelPayment(txId, amountInCents) {
    const tx = this.transactions.get(txId);
    if (tx) {
      tx.status = 'refunded';
      console.log(`Legacy: Refunded ${amountInCents} cents`);
      return { success: true };
    }
    return { success: false, error: 'Transaction not found' };
  }
  
  checkPaymentStatus(txId) {
    const tx = this.transactions.get(txId);
    return tx ? tx.status : 'unknown';
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ADAPTER: Converts legacy interface to modern interface
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class LegacyPaymentAdapter extends ModernPaymentProcessor {
  constructor(legacySystem) {
    super();
    this.legacySystem = legacySystem;
    this.currencyRates = { USD: 1, EUR: 0.85, GBP: 0.73 };
  }
  
  // Convert modern interface to legacy calls
  processPayment(amount, currency, cardDetails) {
    // Convert amount to cents (legacy expects cents)
    const amountInCents = Math.round(amount * 100);
    
    // Extract card details
    const { number, expiry, cvv } = cardDetails;
    
    // Call legacy system
    const result = this.legacySystem.makePayment(
      number,
      expiry,
      cvv,
      amountInCents
    );
    
    // Convert response to modern format
    return {
      success: result.success,
      transactionId: result.transactionId,
      amount,
      currency,
      timestamp: new Date().toISOString()
    };
  }
  
  refund(transactionId, amount) {
    const amountInCents = Math.round(amount * 100);
    const result = this.legacySystem.cancelPayment(transactionId, amountInCents);
    
    return {
      success: result.success,
      transactionId,
      refundedAmount: amount,
      error: result.error || null
    };
  }
  
  getTransactionStatus(transactionId) {
    const legacyStatus = this.legacySystem.checkPaymentStatus(transactionId);
    
    // Map legacy status to modern status
    const statusMap = {
      'completed': 'SUCCESS',
      'refunded': 'REFUNDED',
      'pending': 'PENDING',
      'unknown': 'NOT_FOUND'
    };
    
    return {
      transactionId,
      status: statusMap[legacyStatus] || 'UNKNOWN',
      rawStatus: legacyStatus
    };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLIENT CODE: Works with modern interface
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function checkout(paymentProcessor, orderTotal, cardInfo) {
  // Client doesn't know or care if it's legacy or modern
  const result = paymentProcessor.processPayment(
    orderTotal,
    'USD',
    cardInfo
  );
  
  if (result.success) {
    console.log(`Payment successful: ${result.transactionId}`);
    return result;
  }
  
  throw new Error('Payment failed');
}

// Usage
const legacySystem = new LegacyPaymentSystem();
const paymentProcessor = new LegacyPaymentAdapter(legacySystem);

const result = checkout(paymentProcessor, 99.99, {
  number: '4111111111111111',
  expiry: '12/25',
  cvv: '123'
});

console.log(paymentProcessor.getTransactionStatus(result.transactionId));
// { transactionId: 'TXN_...', status: 'SUCCESS', rawStatus: 'completed' }
```

### Class Adapter (Inheritance)

Uses inheritance: the adapter extends both the target and adaptee. Less common in JavaScript due to single inheritance.

```javascript
// In JavaScript, we can simulate this with mixins
// Note: This is less flexible than object adapter

class OldCalculator {
  operations(num1, num2, operation) {
    switch(operation) {
      case 'add': return num1 + num2;
      case 'sub': return num1 - num2;
      default: return NaN;
    }
  }
}

// New interface the client expects
class NewCalculatorInterface {
  add(a, b) {}
  subtract(a, b) {}
  multiply(a, b) {}
  divide(a, b) {}
}

// Class adapter - extends OldCalculator
class CalculatorAdapter extends OldCalculator {
  add(a, b) {
    return this.operations(a, b, 'add');
  }
  
  subtract(a, b) {
    return this.operations(a, b, 'sub');
  }
  
  multiply(a, b) {
    // OldCalculator doesn't have this, implement directly
    return a * b;
  }
  
  divide(a, b) {
    if (b === 0) throw new Error('Division by zero');
    return a / b;
  }
}

// Usage
const calc = new CalculatorAdapter();
console.log(calc.add(5, 3));      // 8 (via adapter)
console.log(calc.subtract(5, 3)); // 2 (via adapter)
console.log(calc.multiply(5, 3)); // 15 (new implementation)
```

---

## 10.3 Real-World Use Cases

### Use Case 1: Third-Party API Integration

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Your app's unified analytics interface
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class AnalyticsService {
  trackEvent(eventName, properties) {
    throw new Error('Must implement trackEvent');
  }
  
  trackPageView(pageName, properties) {
    throw new Error('Must implement trackPageView');
  }
  
  identifyUser(userId, traits) {
    throw new Error('Must implement identifyUser');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Google Analytics (different API)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class GoogleAnalytics {
  sendEvent(category, action, label, value) {
    console.log(`GA: Event - ${category}/${action}/${label}:${value}`);
  }
  
  sendPageview(pagePath) {
    console.log(`GA: Pageview - ${pagePath}`);
  }
  
  setUserId(userId) {
    console.log(`GA: Set user ID - ${userId}`);
  }
}

class GoogleAnalyticsAdapter extends AnalyticsService {
  constructor(ga) {
    super();
    this.ga = ga;
  }
  
  trackEvent(eventName, properties = {}) {
    this.ga.sendEvent(
      properties.category || 'general',
      eventName,
      properties.label || '',
      properties.value || 0
    );
  }
  
  trackPageView(pageName, properties = {}) {
    this.ga.sendPageview(properties.path || `/${pageName}`);
  }
  
  identifyUser(userId, traits = {}) {
    this.ga.setUserId(userId);
    // GA doesn't support traits, we ignore them
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Mixpanel (different API)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Mixpanel {
  track(event, props) {
    console.log(`Mixpanel: Track "${event}"`, props);
  }
  
  people = {
    set(props) {
      console.log('Mixpanel: People set', props);
    }
  };
  
  identify(distinctId) {
    console.log(`Mixpanel: Identify ${distinctId}`);
  }
}

class MixpanelAdapter extends AnalyticsService {
  constructor(mixpanel) {
    super();
    this.mixpanel = mixpanel;
  }
  
  trackEvent(eventName, properties = {}) {
    this.mixpanel.track(eventName, properties);
  }
  
  trackPageView(pageName, properties = {}) {
    this.mixpanel.track('Page View', { page: pageName, ...properties });
  }
  
  identifyUser(userId, traits = {}) {
    this.mixpanel.identify(userId);
    this.mixpanel.people.set(traits);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Unified Analytics Manager
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class AnalyticsManager {
  constructor() {
    this.services = [];
  }
  
  addService(service) {
    if (!(service instanceof AnalyticsService)) {
      throw new Error('Service must implement AnalyticsService');
    }
    this.services.push(service);
  }
  
  trackEvent(eventName, properties) {
    this.services.forEach(service => {
      service.trackEvent(eventName, properties);
    });
  }
  
  trackPageView(pageName, properties) {
    this.services.forEach(service => {
      service.trackPageView(pageName, properties);
    });
  }
  
  identifyUser(userId, traits) {
    this.services.forEach(service => {
      service.identifyUser(userId, traits);
    });
  }
}

// Usage - Same interface for all analytics providers
const analytics = new AnalyticsManager();

// Add different providers through adapters
analytics.addService(new GoogleAnalyticsAdapter(new GoogleAnalytics()));
analytics.addService(new MixpanelAdapter(new Mixpanel()));

// Use unified interface
analytics.identifyUser('user-123', { name: 'John', plan: 'premium' });
analytics.trackPageView('Dashboard', { path: '/dashboard' });
analytics.trackEvent('Button Click', { category: 'UI', label: 'Submit' });
```

### Use Case 2: Data Format Adapter

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Your application expects JSON format
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class DataProcessor {
  processUsers(users) {
    // Expects: [{ id, name, email, createdAt }]
    return users.map(user => ({
      ...user,
      displayName: user.name.toUpperCase(),
      createdAtDate: new Date(user.createdAt)
    }));
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Legacy API returns XML
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class LegacyUserAPI {
  fetchUsersXML() {
    // Simulated XML response
    return `
      <users>
        <user>
          <user_id>1</user_id>
          <full_name>John Doe</full_name>
          <email_address>john@example.com</email_address>
          <created_timestamp>1609459200000</created_timestamp>
        </user>
        <user>
          <user_id>2</user_id>
          <full_name>Jane Smith</full_name>
          <email_address>jane@example.com</email_address>
          <created_timestamp>1612137600000</created_timestamp>
        </user>
      </users>
    `;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Adapter: XML to JSON conversion
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class XMLUserAPIAdapter {
  constructor(legacyAPI) {
    this.legacyAPI = legacyAPI;
  }
  
  fetchUsers() {
    const xml = this.legacyAPI.fetchUsersXML();
    return this.parseXMLToJSON(xml);
  }
  
  parseXMLToJSON(xml) {
    // Simple XML parsing (in production, use proper XML parser)
    const users = [];
    const userMatches = xml.match(/<user>[\s\S]*?<\/user>/g) || [];
    
    for (const userXml of userMatches) {
      users.push({
        id: parseInt(this.extractValue(userXml, 'user_id')),
        name: this.extractValue(userXml, 'full_name'),
        email: this.extractValue(userXml, 'email_address'),
        createdAt: parseInt(this.extractValue(userXml, 'created_timestamp'))
      });
    }
    
    return users;
  }
  
  extractValue(xml, tagName) {
    const match = xml.match(new RegExp(`<${tagName}>([\\s\\S]*?)</${tagName}>`));
    return match ? match[1].trim() : '';
  }
}

// Usage
const legacyAPI = new LegacyUserAPI();
const userAPI = new XMLUserAPIAdapter(legacyAPI);
const processor = new DataProcessor();

const users = userAPI.fetchUsers();
console.log(users);
// [{ id: 1, name: 'John Doe', email: 'john@example.com', createdAt: 1609459200000 }, ...]

const processedUsers = processor.processUsers(users);
console.log(processedUsers);
// Works seamlessly with JSON format
```

### Use Case 3: Database Driver Adapter

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Unified Database Interface
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class DatabaseDriver {
  async connect(config) {
    throw new Error('Must implement');
  }
  
  async query(sql, params) {
    throw new Error('Must implement');
  }
  
  async insert(table, data) {
    throw new Error('Must implement');
  }
  
  async update(table, data, where) {
    throw new Error('Must implement');
  }
  
  async delete(table, where) {
    throw new Error('Must implement');
  }
  
  async disconnect() {
    throw new Error('Must implement');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MySQL Driver (different API)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class MySQLClient {
  createConnection(config) {
    console.log('MySQL: Creating connection');
    return this;
  }
  
  executeQuery(queryString, values, callback) {
    console.log(`MySQL: Executing "${queryString}" with`, values);
    // Simulate async
    setTimeout(() => callback(null, [{ id: 1, name: 'Test' }]), 10);
  }
  
  close() {
    console.log('MySQL: Connection closed');
  }
}

class MySQLAdapter extends DatabaseDriver {
  constructor() {
    super();
    this.client = new MySQLClient();
    this.connection = null;
  }
  
  async connect(config) {
    this.connection = this.client.createConnection(config);
    return this;
  }
  
  async query(sql, params = []) {
    return new Promise((resolve, reject) => {
      this.client.executeQuery(sql, params, (err, results) => {
        if (err) reject(err);
        else resolve(results);
      });
    });
  }
  
  async insert(table, data) {
    const columns = Object.keys(data).join(', ');
    const placeholders = Object.keys(data).map(() => '?').join(', ');
    const values = Object.values(data);
    
    const sql = `INSERT INTO ${table} (${columns}) VALUES (${placeholders})`;
    return this.query(sql, values);
  }
  
  async update(table, data, where) {
    const setClause = Object.keys(data).map(k => `${k} = ?`).join(', ');
    const whereClause = Object.keys(where).map(k => `${k} = ?`).join(' AND ');
    const values = [...Object.values(data), ...Object.values(where)];
    
    const sql = `UPDATE ${table} SET ${setClause} WHERE ${whereClause}`;
    return this.query(sql, values);
  }
  
  async delete(table, where) {
    const whereClause = Object.keys(where).map(k => `${k} = ?`).join(' AND ');
    const values = Object.values(where);
    
    const sql = `DELETE FROM ${table} WHERE ${whereClause}`;
    return this.query(sql, values);
  }
  
  async disconnect() {
    this.client.close();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MongoDB (completely different API)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class MongoDBClient {
  connect(url) {
    console.log('MongoDB: Connecting to', url);
    return this;
  }
  
  db(dbName) {
    return {
      collection: (name) => ({
        find: (query) => ({
          toArray: async () => {
            console.log(`MongoDB: Find in ${name}`, query);
            return [{ _id: '1', name: 'Test' }];
          }
        }),
        insertOne: async (doc) => {
          console.log(`MongoDB: Insert into ${name}`, doc);
          return { insertedId: '123' };
        },
        updateMany: async (filter, update) => {
          console.log(`MongoDB: Update in ${name}`, filter, update);
          return { modifiedCount: 1 };
        },
        deleteMany: async (filter) => {
          console.log(`MongoDB: Delete from ${name}`, filter);
          return { deletedCount: 1 };
        }
      })
    };
  }
  
  close() {
    console.log('MongoDB: Connection closed');
  }
}

class MongoDBAdapter extends DatabaseDriver {
  constructor() {
    super();
    this.client = new MongoDBClient();
    this.database = null;
  }
  
  async connect(config) {
    await this.client.connect(config.url);
    this.database = this.client.db(config.database);
    return this;
  }
  
  async query(collectionName, filter = {}) {
    const collection = this.database.collection(collectionName);
    const results = await collection.find(filter).toArray();
    
    // Transform _id to id for consistency
    return results.map(doc => {
      const { _id, ...rest } = doc;
      return { id: _id, ...rest };
    });
  }
  
  async insert(collection, data) {
    const coll = this.database.collection(collection);
    const result = await coll.insertOne(data);
    return { id: result.insertedId, ...data };
  }
  
  async update(collection, data, where) {
    const coll = this.database.collection(collection);
    const result = await coll.updateMany(where, { $set: data });
    return { modifiedCount: result.modifiedCount };
  }
  
  async delete(collection, where) {
    const coll = this.database.collection(collection);
    const result = await coll.deleteMany(where);
    return { deletedCount: result.deletedCount };
  }
  
  async disconnect() {
    this.client.close();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Application uses unified interface
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class UserRepository {
  constructor(db) {
    this.db = db; // Any DatabaseDriver
  }
  
  async findAll() {
    return this.db.query('users', {});
  }
  
  async create(userData) {
    return this.db.insert('users', userData);
  }
  
  async update(id, userData) {
    return this.db.update('users', userData, { id });
  }
  
  async delete(id) {
    return this.db.delete('users', { id });
  }
}

// Usage - Same UserRepository works with both databases!
const mysqlDb = new MySQLAdapter();
await mysqlDb.connect({ host: 'localhost', database: 'myapp' });
const mysqlRepo = new UserRepository(mysqlDb);

const mongoDb = new MongoDBAdapter();
await mongoDb.connect({ url: 'mongodb://localhost', database: 'myapp' });
const mongoRepo = new UserRepository(mongoDb);

// Both use the same interface
await mysqlRepo.create({ name: 'John', email: 'john@example.com' });
await mongoRepo.create({ name: 'John', email: 'john@example.com' });
```

---

## 10.4 Adapter vs Other Patterns

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          ADAPTER vs SIMILAR PATTERNS                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  ADAPTER vs DECORATOR:                                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚  Adapter:    Changes the interface                          â”‚
â”‚  Decorator:  Adds behavior, same interface                  â”‚
â”‚                                                             â”‚
â”‚  ADAPTER vs FACADE:                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚  Adapter:    One-to-one class conversion                    â”‚
â”‚  Facade:     Simplifies complex subsystem                   â”‚
â”‚                                                             â”‚
â”‚  ADAPTER vs BRIDGE:                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚  Adapter:    Makes things work after design                 â”‚
â”‚  Bridge:     Planned separation upfront                     â”‚
â”‚                                                             â”‚
â”‚  ADAPTER vs PROXY:                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                           â”‚
â”‚  Adapter:    Different interface                            â”‚
â”‚  Proxy:      Same interface, control access                 â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Key Takeaways

1. **Adapter converts interfaces** - Makes incompatible classes work together
2. **Object Adapter (composition)** - More flexible, preferred approach
3. **Class Adapter (inheritance)** - Less common in JavaScript
4. **Use for**: Legacy integration, third-party libraries, API differences
5. **Client remains unchanged** - Works with expected interface
6. **Single Responsibility** - Adapter only translates, no business logic
7. **Testability** - Easy to mock adapters for testing

> ğŸ’¡ **Interview Tip:** Be ready to explain the difference between Adapter and Facade (Adapter is one-to-one conversion, Facade simplifies a complex subsystem) and when to use each.

> ğŸ­ **Production Note:** Adapters are essential when integrating with third-party services. Always create adapters for external dependencies to make them easier to swap or mock.
