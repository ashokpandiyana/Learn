# Chapter 31: Repository Pattern - Complete Guide

## ðŸ“š What is the Repository Pattern?

The Repository Pattern is a **data access abstraction layer** that sits between your business logic and data storage. It provides a collection-like interface for accessing domain objects, making your data access code cleaner, more maintainable, and testable.

### Core Concept
Think of a repository as a **librarian** - you don't need to know where books are stored or how the filing system works. You just ask the librarian for a book, and they handle all the details of finding and retrieving it.

## ðŸŽ¯ Key Benefits

1. **Separation of Concerns** - Business logic doesn't know about database details
2. **Testability** - Easy to mock data sources for unit tests
3. **Maintainability** - Changes to data access logic are isolated
4. **Flexibility** - Switch databases without changing business logic
5. **Query Abstraction** - Complex queries are encapsulated

## ðŸ—ï¸ Architecture

```
Business Logic Layer
        â†“
Repository Interface (abstraction)
        â†“
Concrete Repository Implementation
        â†“
Data Source (Database, API, File System, etc.)
```

## ðŸ’» Basic Implementation

### 1. Simple Repository

```javascript
// User entity
class User {
  constructor(id, name, email, age) {
    this.id = id;
    this.name = name;
    this.email = email;
    this.age = age;
  }
}

// Basic User Repository
class UserRepository {
  constructor(dataSource) {
    this.dataSource = dataSource;
  }

  async findById(id) {
    const data = await this.dataSource.query('users', { id });
    if (!data) return null;
    return new User(data.id, data.name, data.email, data.age);
  }

  async findAll() {
    const users = await this.dataSource.query('users');
    return users.map(u => new User(u.id, u.name, u.email, u.age));
  }

  async findByEmail(email) {
    const data = await this.dataSource.query('users', { email });
    if (!data) return null;
    return new User(data.id, data.name, data.email, data.age);
  }

  async save(user) {
    if (user.id) {
      // Update existing
      return this.dataSource.update('users', user.id, user);
    } else {
      // Create new
      const result = await this.dataSource.insert('users', user);
      user.id = result.insertedId;
      return user;
    }
  }

  async delete(id) {
    return this.dataSource.delete('users', { id });
  }
}
```

### 2. Generic Repository Base Class

```javascript
// Generic Repository that can be extended
class BaseRepository {
  constructor(dataSource, entityName, EntityClass) {
    this.dataSource = dataSource;
    this.entityName = entityName;
    this.EntityClass = EntityClass;
  }

  async findById(id) {
    const data = await this.dataSource.findOne(this.entityName, { id });
    return data ? new this.EntityClass(data) : null;
  }

  async findAll(filter = {}) {
    const items = await this.dataSource.find(this.entityName, filter);
    return items.map(item => new this.EntityClass(item));
  }

  async findOne(filter) {
    const data = await this.dataSource.findOne(this.entityName, filter);
    return data ? new this.EntityClass(data) : null;
  }

  async save(entity) {
    const data = entity.toJSON ? entity.toJSON() : entity;
    
    if (entity.id) {
      await this.dataSource.update(this.entityName, entity.id, data);
      return entity;
    } else {
      const result = await this.dataSource.insert(this.entityName, data);
      entity.id = result.insertedId;
      return entity;
    }
  }

  async delete(id) {
    return this.dataSource.delete(this.entityName, { id });
  }

  async count(filter = {}) {
    return this.dataSource.count(this.entityName, filter);
  }

  async exists(filter) {
    return (await this.count(filter)) > 0;
  }
}

// Specific repository extending base
class ProductRepository extends BaseRepository {
  constructor(dataSource) {
    super(dataSource, 'products', Product);
  }

  // Add product-specific methods
  async findByCategory(category) {
    return this.findAll({ category });
  }

  async findInPriceRange(minPrice, maxPrice) {
    const products = await this.dataSource.find(this.entityName, {
      price: { $gte: minPrice, $lte: maxPrice }
    });
    return products.map(p => new this.EntityClass(p));
  }

  async findPopular(limit = 10) {
    const products = await this.dataSource.find(
      this.entityName, 
      {}, 
      { sort: { popularity: -1 }, limit }
    );
    return products.map(p => new this.EntityClass(p));
  }
}
```

## ðŸ”§ Advanced Implementation with Multiple Data Sources

```javascript
// Data source interface
class IDataSource {
  async findOne(collection, filter) { throw new Error('Not implemented'); }
  async find(collection, filter, options) { throw new Error('Not implemented'); }
  async insert(collection, data) { throw new Error('Not implemented'); }
  async update(collection, id, data) { throw new Error('Not implemented'); }
  async delete(collection, filter) { throw new Error('Not implemented'); }
}

// MongoDB implementation
class MongoDataSource extends IDataSource {
  constructor(db) {
    super();
    this.db = db;
  }

  async findOne(collection, filter) {
    return this.db.collection(collection).findOne(filter);
  }

  async find(collection, filter, options = {}) {
    return this.db.collection(collection)
      .find(filter)
      .sort(options.sort || {})
      .limit(options.limit || 0)
      .toArray();
  }

  async insert(collection, data) {
    const result = await this.db.collection(collection).insertOne(data);
    return { insertedId: result.insertedId };
  }

  async update(collection, id, data) {
    return this.db.collection(collection).updateOne(
      { _id: id },
      { $set: data }
    );
  }

  async delete(collection, filter) {
    return this.db.collection(collection).deleteOne(filter);
  }
}

// REST API implementation
class RestApiDataSource extends IDataSource {
  constructor(baseUrl, apiKey) {
    super();
    this.baseUrl = baseUrl;
    this.apiKey = apiKey;
  }

  async findOne(collection, filter) {
    const params = new URLSearchParams(filter);
    const response = await fetch(
      `${this.baseUrl}/${collection}?${params}`,
      { headers: { 'Authorization': `Bearer ${this.apiKey}` } }
    );
    const items = await response.json();
    return items[0] || null;
  }

  async find(collection, filter, options = {}) {
    const params = new URLSearchParams(filter);
    const response = await fetch(
      `${this.baseUrl}/${collection}?${params}`,
      { headers: { 'Authorization': `Bearer ${this.apiKey}` } }
    );
    return response.json();
  }

  async insert(collection, data) {
    const response = await fetch(`${this.baseUrl}/${collection}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.apiKey}`
      },
      body: JSON.stringify(data)
    });
    const result = await response.json();
    return { insertedId: result.id };
  }

  async update(collection, id, data) {
    return fetch(`${this.baseUrl}/${collection}/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.apiKey}`
      },
      body: JSON.stringify(data)
    });
  }

  async delete(collection, filter) {
    return fetch(`${this.baseUrl}/${collection}/${filter.id}`, {
      method: 'DELETE',
      headers: { 'Authorization': `Bearer ${this.apiKey}` }
    });
  }
}

// In-Memory implementation (for testing)
class InMemoryDataSource extends IDataSource {
  constructor() {
    super();
    this.collections = new Map();
  }

  async findOne(collection, filter) {
    const items = this.collections.get(collection) || [];
    return items.find(item => 
      Object.entries(filter).every(([key, value]) => item[key] === value)
    );
  }

  async find(collection, filter, options = {}) {
    let items = this.collections.get(collection) || [];
    
    // Apply filter
    if (Object.keys(filter).length > 0) {
      items = items.filter(item =>
        Object.entries(filter).every(([key, value]) => item[key] === value)
      );
    }

    // Apply limit
    if (options.limit) {
      items = items.slice(0, options.limit);
    }

    return items;
  }

  async insert(collection, data) {
    if (!this.collections.has(collection)) {
      this.collections.set(collection, []);
    }
    const items = this.collections.get(collection);
    const id = Date.now() + Math.random();
    const newItem = { ...data, id };
    items.push(newItem);
    return { insertedId: id };
  }

  async update(collection, id, data) {
    const items = this.collections.get(collection) || [];
    const index = items.findIndex(item => item.id === id);
    if (index !== -1) {
      items[index] = { ...items[index], ...data };
    }
  }

  async delete(collection, filter) {
    const items = this.collections.get(collection) || [];
    const newItems = items.filter(item =>
      !Object.entries(filter).every(([key, value]) => item[key] === value)
    );
    this.collections.set(collection, newItems);
  }
}
```

## ðŸŽ­ Repository with Caching

```javascript
class CachedRepository {
  constructor(repository, cacheProvider, ttl = 300000) { // 5 min default
    this.repository = repository;
    this.cache = cacheProvider;
    this.ttl = ttl;
  }

  async findById(id) {
    const cacheKey = `user:${id}`;
    
    // Try cache first
    const cached = await this.cache.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }

    // Fetch from repository
    const user = await this.repository.findById(id);
    
    // Store in cache
    if (user) {
      await this.cache.set(cacheKey, JSON.stringify(user), this.ttl);
    }

    return user;
  }

  async save(entity) {
    const result = await this.repository.save(entity);
    
    // Invalidate cache
    await this.cache.delete(`user:${entity.id}`);
    
    return result;
  }

  async delete(id) {
    const result = await this.repository.delete(id);
    
    // Invalidate cache
    await this.cache.delete(`user:${id}`);
    
    return result;
  }
}

// Simple cache provider
class MemoryCache {
  constructor() {
    this.cache = new Map();
  }

  async get(key) {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() > item.expiry) {
      this.cache.delete(key);
      return null;
    }
    
    return item.value;
  }

  async set(key, value, ttl) {
    this.cache.set(key, {
      value,
      expiry: Date.now() + ttl
    });
  }

  async delete(key) {
    this.cache.delete(key);
  }
}
```

## ðŸ“Š Specification Pattern with Repository

```javascript
// Specification pattern for complex queries
class Specification {
  isSatisfiedBy(entity) {
    throw new Error('Must implement isSatisfiedBy');
  }

  toFilter() {
    throw new Error('Must implement toFilter');
  }

  and(other) {
    return new AndSpecification(this, other);
  }

  or(other) {
    return new OrSpecification(this, other);
  }
}

class ActiveUserSpecification extends Specification {
  isSatisfiedBy(user) {
    return user.isActive === true;
  }

  toFilter() {
    return { isActive: true };
  }
}

class AgeRangeSpecification extends Specification {
  constructor(minAge, maxAge) {
    super();
    this.minAge = minAge;
    this.maxAge = maxAge;
  }

  isSatisfiedBy(user) {
    return user.age >= this.minAge && user.age <= this.maxAge;
  }

  toFilter() {
    return { age: { $gte: this.minAge, $lte: this.maxAge } };
  }
}

class AndSpecification extends Specification {
  constructor(spec1, spec2) {
    super();
    this.spec1 = spec1;
    this.spec2 = spec2;
  }

  isSatisfiedBy(entity) {
    return this.spec1.isSatisfiedBy(entity) && 
           this.spec2.isSatisfiedBy(entity);
  }

  toFilter() {
    return { $and: [this.spec1.toFilter(), this.spec2.toFilter()] };
  }
}

// Repository with specification support
class SpecificationRepository extends BaseRepository {
  async findBySpecification(specification) {
    const filter = specification.toFilter();
    return this.findAll(filter);
  }
}

// Usage
const repo = new SpecificationRepository(dataSource, 'users', User);
const activeAdults = new ActiveUserSpecification()
  .and(new AgeRangeSpecification(18, 65));

const users = await repo.findBySpecification(activeAdults);
```

## ðŸ§ª Complete Example with Testing

```javascript
// Domain entity
class Product {
  constructor(data) {
    this.id = data.id || null;
    this.name = data.name;
    this.price = data.price;
    this.category = data.category;
    this.stock = data.stock || 0;
  }

  isInStock() {
    return this.stock > 0;
  }

  toJSON() {
    return {
      id: this.id,
      name: this.name,
      price: this.price,
      category: this.category,
      stock: this.stock
    };
  }
}

// Product Repository
class ProductRepository extends BaseRepository {
  constructor(dataSource) {
    super(dataSource, 'products', Product);
  }

  async findLowStock(threshold = 10) {
    const products = await this.dataSource.find(
      this.entityName,
      { stock: { $lt: threshold } }
    );
    return products.map(p => new Product(p));
  }

  async updateStock(productId, quantity) {
    const product = await this.findById(productId);
    if (!product) throw new Error('Product not found');
    
    product.stock += quantity;
    return this.save(product);
  }
}

// Usage in service layer
class ProductService {
  constructor(productRepository) {
    this.productRepo = productRepository;
  }

  async purchaseProduct(productId, quantity) {
    const product = await this.productRepo.findById(productId);
    
    if (!product) {
      throw new Error('Product not found');
    }

    if (product.stock < quantity) {
      throw new Error('Insufficient stock');
    }

    await this.productRepo.updateStock(productId, -quantity);
    return { success: true, product };
  }

  async getLowStockProducts() {
    return this.productRepo.findLowStock(10);
  }
}

// Testing
class MockDataSource extends IDataSource {
  constructor() {
    super();
    this.products = new Map([
      [1, { id: 1, name: 'Laptop', price: 999, category: 'Electronics', stock: 5 }],
      [2, { id: 2, name: 'Mouse', price: 29, category: 'Electronics', stock: 50 }]
    ]);
  }

  async findOne(collection, filter) {
    if (filter.id) {
      return this.products.get(filter.id) || null;
    }
    return null;
  }

  async find(collection, filter) {
    return Array.from(this.products.values());
  }

  async update(collection, id, data) {
    const product = this.products.get(id);
    if (product) {
      this.products.set(id, { ...product, ...data });
    }
  }
}

// Test
async function testRepository() {
  const mockDataSource = new MockDataSource();
  const productRepo = new ProductRepository(mockDataSource);
  const productService = new ProductService(productRepo);

  // Test purchase
  const result = await productService.purchaseProduct(1, 2);
  console.log('Purchase result:', result);

  // Test low stock
  const lowStock = await productService.getLowStockProducts();
  console.log('Low stock products:', lowStock);
}
```

## ðŸŽ¯ Best Practices

### âœ… DO:
- Keep repositories focused on data access only
- Return domain entities, not raw database objects
- Use dependency injection for data sources
- Create mock repositories for testing
- Keep query logic in the repository

### âŒ DON'T:
- Put business logic in repositories
- Expose database-specific details to consumers
- Create generic repositories for everything (be specific when needed)
- Return database cursors or connections
- Mix multiple data sources in one repository

## ðŸ”‘ Key Takeaways

1. **Abstraction Layer**: Repository abstracts data storage details
2. **Testability**: Easy to mock for unit tests
3. **Flexibility**: Switch data sources without changing business logic
4. **Collection Interface**: Treat data access like in-memory collections
5. **Domain Entities**: Always return domain objects, not raw data

The Repository Pattern is essential for clean architecture and is widely used in enterprise applications, ORMs (TypeORM, Prisma), and modern frameworks.