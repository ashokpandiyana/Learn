# Chapter 39: Security Patterns

## Introduction

Security is not optional in modern applications. This chapter covers essential security patterns to protect against common vulnerabilities and attacks.

---

## 39.1 Input Validation and Sanitization

### Validation Pattern

Always validate input on both client and server:

```javascript
class Validator {
  static isEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }
  
  static isStrongPassword(password) {
    // At least 8 chars, 1 uppercase, 1 lowercase, 1 number, 1 special
    const regex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
    return regex.test(password);
  }
  
  static isSafeString(str, maxLength = 1000) {
    if (typeof str !== 'string') return false;
    if (str.length > maxLength) return false;
    
    // Check for suspicious patterns
    const dangerousPatterns = [
      /<script/i,
      /javascript:/i,
      /on\w+\s*=/i,  // Event handlers
      /data:text\/html/i
    ];
    
    return !dangerousPatterns.some(pattern => pattern.test(str));
  }
  
  static isValidURL(url) {
    try {
      const parsed = new URL(url);
      // Only allow http and https
      return ['http:', 'https:'].includes(parsed.protocol);
    } catch {
      return false;
    }
  }
  
  static sanitizeInteger(value, min = 0, max = Number.MAX_SAFE_INTEGER) {
    const num = parseInt(value, 10);
    if (isNaN(num)) return null;
    return Math.max(min, Math.min(max, num));
  }
}

// Usage with schema validation
class UserValidator {
  static validate(data) {
    const errors = [];
    
    if (!data.email || !Validator.isEmail(data.email)) {
      errors.push({ field: 'email', message: 'Invalid email format' });
    }
    
    if (!data.password || !Validator.isStrongPassword(data.password)) {
      errors.push({ 
        field: 'password', 
        message: 'Password must be at least 8 characters with uppercase, lowercase, number, and special character' 
      });
    }
    
    if (!data.username || !Validator.isSafeString(data.username, 50)) {
      errors.push({ field: 'username', message: 'Invalid username' });
    }
    
    if (data.age !== undefined) {
      data.age = Validator.sanitizeInteger(data.age, 0, 150);
      if (data.age === null) {
        errors.push({ field: 'age', message: 'Invalid age' });
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      sanitized: data
    };
  }
}

// Express middleware
function validateRequest(schema) {
  return (req, res, next) => {
    const result = schema.validate(req.body);
    
    if (!result.isValid) {
      return res.status(400).json({
        status: 'error',
        errors: result.errors
      });
    }
    
    req.body = result.sanitized;
    next();
  };
}

// Usage
app.post('/api/users', 
  validateRequest(UserValidator),
  async (req, res) => {
    // req.body is now validated and sanitized
    const user = await createUser(req.body);
    res.json(user);
  }
);
```

### HTML Sanitization

Prevent XSS attacks:

```javascript
class HTMLSanitizer {
  static escape(html) {
    const div = document.createElement('div');
    div.textContent = html;
    return div.innerHTML;
  }
  
  static stripTags(html) {
    const div = document.createElement('div');
    div.innerHTML = html;
    return div.textContent || div.innerText || '';
  }
  
  static allowedTags(html, allowedTags = ['b', 'i', 'em', 'strong', 'a']) {
    const div = document.createElement('div');
    div.innerHTML = html;
    
    const walk = (node) => {
      const nodesToRemove = [];
      
      for (const child of node.childNodes) {
        if (child.nodeType === Node.ELEMENT_NODE) {
          const tagName = child.tagName.toLowerCase();
          
          if (!allowedTags.includes(tagName)) {
            nodesToRemove.push(child);
          } else {
            // Remove dangerous attributes
            this.sanitizeAttributes(child);
            walk(child);
          }
        }
      }
      
      nodesToRemove.forEach(node => node.remove());
    };
    
    walk(div);
    return div.innerHTML;
  }
  
  static sanitizeAttributes(element) {
    const dangerousAttrs = ['onclick', 'onerror', 'onload', 'onmouseover'];
    const allowedAttrs = ['href', 'title', 'class', 'id'];
    
    const attrs = Array.from(element.attributes);
    attrs.forEach(attr => {
      if (dangerousAttrs.includes(attr.name.toLowerCase()) || 
          !allowedAttrs.includes(attr.name.toLowerCase())) {
        element.removeAttribute(attr.name);
      }
      
      // Check href for javascript:
      if (attr.name === 'href' && attr.value.toLowerCase().includes('javascript:')) {
        element.removeAttribute('href');
      }
    });
  }
}

// Usage
const userInput = '<script>alert("XSS")</script><b>Bold text</b>';
const safe = HTMLSanitizer.escape(userInput);
console.log(safe); // &lt;script&gt;alert("XSS")&lt;/script&gt;&lt;b&gt;Bold text&lt;/b&gt;
```

---

## 39.2 Authentication Patterns

### JWT Authentication Pattern

```javascript
const crypto = require('crypto');

class JWTAuth {
  constructor(secret) {
    this.secret = secret;
  }
  
  // Generate JWT token
  generateToken(payload, expiresIn = '24h') {
    const header = {
      alg: 'HS256',
      typ: 'JWT'
    };
    
    const now = Math.floor(Date.now() / 1000);
    const expiresInSeconds = this.parseExpiry(expiresIn);
    
    const claims = {
      ...payload,
      iat: now,
      exp: now + expiresInSeconds
    };
    
    const encodedHeader = this.base64URLEncode(JSON.stringify(header));
    const encodedPayload = this.base64URLEncode(JSON.stringify(claims));
    
    const signature = this.sign(`${encodedHeader}.${encodedPayload}`);
    
    return `${encodedHeader}.${encodedPayload}.${signature}`;
  }
  
  // Verify JWT token
  verifyToken(token) {
    try {
      const [encodedHeader, encodedPayload, signature] = token.split('.');
      
      // Verify signature
      const expectedSignature = this.sign(`${encodedHeader}.${encodedPayload}`);
      if (signature !== expectedSignature) {
        throw new Error('Invalid signature');
      }
      
      // Decode payload
      const payload = JSON.parse(this.base64URLDecode(encodedPayload));
      
      // Check expiration
      const now = Math.floor(Date.now() / 1000);
      if (payload.exp && payload.exp < now) {
        throw new Error('Token expired');
      }
      
      return { valid: true, payload };
    } catch (error) {
      return { valid: false, error: error.message };
    }
  }
  
  sign(data) {
    return crypto
      .createHmac('sha256', this.secret)
      .update(data)
      .digest('base64url');
  }
  
  base64URLEncode(str) {
    return Buffer.from(str)
      .toString('base64url');
  }
  
  base64URLDecode(str) {
    return Buffer.from(str, 'base64url')
      .toString('utf8');
  }
  
  parseExpiry(expiresIn) {
    const match = expiresIn.match(/^(\d+)([smhd])$/);
    if (!match) return 3600; // Default 1 hour
    
    const value = parseInt(match[1]);
    const unit = match[2];
    
    const multipliers = { s: 1, m: 60, h: 3600, d: 86400 };
    return value * multipliers[unit];
  }
}

// Refresh Token Pattern
class TokenManager {
  constructor(jwtAuth) {
    this.jwtAuth = jwtAuth;
    this.refreshTokens = new Map(); // In production, use Redis
  }
  
  generateTokenPair(userId) {
    const accessToken = this.jwtAuth.generateToken(
      { userId, type: 'access' },
      '15m'
    );
    
    const refreshToken = crypto.randomBytes(32).toString('hex');
    
    // Store refresh token
    this.refreshTokens.set(refreshToken, {
      userId,
      createdAt: Date.now(),
      expiresAt: Date.now() + (7 * 24 * 60 * 60 * 1000) // 7 days
    });
    
    return { accessToken, refreshToken };
  }
  
  refreshAccessToken(refreshToken) {
    const tokenData = this.refreshTokens.get(refreshToken);
    
    if (!tokenData) {
      throw new Error('Invalid refresh token');
    }
    
    if (Date.now() > tokenData.expiresAt) {
      this.refreshTokens.delete(refreshToken);
      throw new Error('Refresh token expired');
    }
    
    // Generate new access token
    const accessToken = this.jwtAuth.generateToken(
      { userId: tokenData.userId, type: 'access' },
      '15m'
    );
    
    return accessToken;
  }
  
  revokeRefreshToken(refreshToken) {
    this.refreshTokens.delete(refreshToken);
  }
}

// Middleware
function authMiddleware(jwtAuth) {
  return (req, res, next) => {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'No token provided' });
    }
    
    const token = authHeader.substring(7);
    const result = jwtAuth.verifyToken(token);
    
    if (!result.valid) {
      return res.status(401).json({ error: result.error });
    }
    
    req.user = result.payload;
    next();
  };
}

// Usage
const jwtAuth = new JWTAuth(process.env.JWT_SECRET);
const tokenManager = new TokenManager(jwtAuth);

app.post('/api/login', async (req, res) => {
  const { email, password } = req.body;
  
  // Verify credentials (pseudo code)
  const user = await verifyCredentials(email, password);
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  const tokens = tokenManager.generateTokenPair(user.id);
  res.json(tokens);
});

app.post('/api/refresh', (req, res) => {
  const { refreshToken } = req.body;
  
  try {
    const accessToken = tokenManager.refreshAccessToken(refreshToken);
    res.json({ accessToken });
  } catch (error) {
    res.status(401).json({ error: error.message });
  }
});

app.get('/api/protected', authMiddleware(jwtAuth), (req, res) => {
  res.json({ message: 'Protected resource', user: req.user });
});
```

---

## 39.3 Authorization Patterns

### Role-Based Access Control (RBAC)

```javascript
class RBAC {
  constructor() {
    this.roles = new Map();
    this.permissions = new Map();
  }
  
  // Define roles and their permissions
  defineRole(roleName, permissions = []) {
    this.roles.set(roleName, new Set(permissions));
  }
  
  // Grant permission to a role
  grantPermission(roleName, permission) {
    const role = this.roles.get(roleName);
    if (role) {
      role.add(permission);
    }
  }
  
  // Check if role has permission
  hasPermission(roleName, permission) {
    const role = this.roles.get(roleName);
    return role ? role.has(permission) : false;
  }
  
  // Check if user has permission (supports multiple roles)
  userHasPermission(userRoles, permission) {
    return userRoles.some(role => this.hasPermission(role, permission));
  }
}

// Setup
const rbac = new RBAC();

rbac.defineRole('admin', [
  'users:read',
  'users:write',
  'users:delete',
  'posts:read',
  'posts:write',
  'posts:delete'
]);

rbac.defineRole('editor', [
  'posts:read',
  'posts:write',
  'users:read'
]);

rbac.defineRole('viewer', [
  'posts:read'
]);

// Middleware
function requirePermission(permission) {
  return (req, res, next) => {
    if (!req.user || !req.user.roles) {
      return res.status(401).json({ error: 'Not authenticated' });
    }
    
    if (!rbac.userHasPermission(req.user.roles, permission)) {
      return res.status(403).json({ 
        error: 'Insufficient permissions',
        required: permission 
      });
    }
    
    next();
  };
}

// Usage
app.delete('/api/users/:id', 
  authMiddleware,
  requirePermission('users:delete'),
  async (req, res) => {
    await deleteUser(req.params.id);
    res.json({ success: true });
  }
);
```

### Attribute-Based Access Control (ABAC)

More flexible than RBAC:

```javascript
class ABAC {
  constructor() {
    this.policies = [];
  }
  
  addPolicy(policy) {
    this.policies.push(policy);
  }
  
  evaluate(subject, resource, action, context = {}) {
    for (const policy of this.policies) {
      const result = policy.evaluate(subject, resource, action, context);
      
      if (result === 'allow') return true;
      if (result === 'deny') return false;
    }
    
    return false; // Default deny
  }
}

class Policy {
  constructor(name, condition) {
    this.name = name;
    this.condition = condition;
  }
  
  evaluate(subject, resource, action, context) {
    return this.condition(subject, resource, action, context);
  }
}

// Setup policies
const abac = new ABAC();

// Policy: Users can edit their own posts
abac.addPolicy(new Policy(
  'own-post-edit',
  (subject, resource, action, context) => {
    if (action === 'edit' && 
        resource.type === 'post' && 
        resource.authorId === subject.id) {
      return 'allow';
    }
    return null;
  }
));

// Policy: Admins can do anything
abac.addPolicy(new Policy(
  'admin-all',
  (subject, resource, action, context) => {
    if (subject.roles.includes('admin')) {
      return 'allow';
    }
    return null;
  }
));

// Policy: Block edits during maintenance
abac.addPolicy(new Policy(
  'maintenance-mode',
  (subject, resource, action, context) => {
    if (context.maintenanceMode && action === 'edit') {
      return 'deny';
    }
    return null;
  }
));

// Usage
function checkAccess(req, res, next) {
  const user = req.user;
  const resource = req.resource; // Set by route handler
  const action = req.params.action;
  
  const allowed = abac.evaluate(user, resource, action, {
    maintenanceMode: process.env.MAINTENANCE_MODE === 'true'
  });
  
  if (!allowed) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  next();
}
```

---

## 39.4 CSRF Protection Pattern

```javascript
const crypto = require('crypto');

class CSRFProtection {
  constructor() {
    this.tokens = new Map();
  }
  
  generateToken(sessionId) {
    const token = crypto.randomBytes(32).toString('hex');
    
    this.tokens.set(sessionId, {
      token,
      createdAt: Date.now(),
      expiresAt: Date.now() + (60 * 60 * 1000) // 1 hour
    });
    
    return token;
  }
  
  validateToken(sessionId, token) {
    const stored = this.tokens.get(sessionId);
    
    if (!stored) return false;
    
    // Check expiration
    if (Date.now() > stored.expiresAt) {
      this.tokens.delete(sessionId);
      return false;
    }
    
    // Constant-time comparison
    return crypto.timingSafeEqual(
      Buffer.from(stored.token),
      Buffer.from(token)
    );
  }
  
  deleteToken(sessionId) {
    this.tokens.delete(sessionId);
  }
}

const csrfProtection = new CSRFProtection();

// Middleware to attach CSRF token
app.use((req, res, next) => {
  if (!req.session.csrfToken) {
    req.session.csrfToken = csrfProtection.generateToken(req.sessionID);
  }
  res.locals.csrfToken = req.session.csrfToken;
  next();
});

// Middleware to verify CSRF token
function verifyCsrfToken(req, res, next) {
  if (['GET', 'HEAD', 'OPTIONS'].includes(req.method)) {
    return next();
  }
  
  const token = req.headers['x-csrf-token'] || req.body._csrf;
  
  if (!token || !csrfProtection.validateToken(req.sessionID, token)) {
    return res.status(403).json({ error: 'Invalid CSRF token' });
  }
  
  next();
}

// Usage
app.post('/api/transfer', verifyCsrfToken, (req, res) => {
  // Process transfer
  res.json({ success: true });
});
```

---

## 39.5 Rate Limiting Pattern

Prevent abuse and DDoS:

```javascript
class RateLimiter {
  constructor(maxRequests, windowMs) {
    this.maxRequests = maxRequests;
    this.windowMs = windowMs;
    this.requests = new Map();
  }
  
  isAllowed(key) {
    const now = Date.now();
    const userRequests = this.requests.get(key) || [];
    
    // Remove expired requests
    const validRequests = userRequests.filter(
      time => now - time < this.windowMs
    );
    
    if (validRequests.length >= this.maxRequests) {
      return {
        allowed: false,
        retryAfter: Math.ceil((validRequests[0] + this.windowMs - now) / 1000)
      };
    }
    
    // Add new request
    validRequests.push(now);
    this.requests.set(key, validRequests);
    
    return {
      allowed: true,
      remaining: this.maxRequests - validRequests.length
    };
  }
  
  reset(key) {
    this.requests.delete(key);
  }
}

// Token bucket algorithm for more sophisticated rate limiting
class TokenBucket {
  constructor(capacity, refillRate) {
    this.capacity = capacity;
    this.tokens = capacity;
    this.refillRate = refillRate; // tokens per second
    this.lastRefill = Date.now();
  }
  
  consume(tokens = 1) {
    this.refill();
    
    if (this.tokens >= tokens) {
      this.tokens -= tokens;
      return true;
    }
    
    return false;
  }
  
  refill() {
    const now = Date.now();
    const elapsed = (now - this.lastRefill) / 1000;
    const tokensToAdd = elapsed * this.refillRate;
    
    this.tokens = Math.min(this.capacity, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }
}

// Middleware
function rateLimitMiddleware(limiter) {
  return (req, res, next) => {
    const key = req.ip || req.user?.id || 'anonymous';
    const result = limiter.isAllowed(key);
    
    if (!result.allowed) {
      res.set('Retry-After', result.retryAfter);
      return res.status(429).json({
        error: 'Too many requests',
        retryAfter: result.retryAfter
      });
    }
    
    res.set('X-RateLimit-Remaining', result.remaining);
    next();
  };
}

// Usage
const apiLimiter = new RateLimiter(100, 60 * 1000); // 100 requests per minute

app.use('/api/', rateLimitMiddleware(apiLimiter));
```

---

## 39.6 SQL Injection Prevention

```javascript
// ALWAYS use parameterized queries
class DatabaseSafe {
  // BAD - Vulnerable to SQL injection
  static async getUserBad(email) {
    const query = `SELECT * FROM users WHERE email = '${email}'`;
    return db.query(query);
  }
  
  // GOOD - Using parameterized query
  static async getUserGood(email) {
    const query = 'SELECT * FROM users WHERE email = ?';
    return db.query(query, [email]);
  }
  
  // ORM example (safe)
  static async getUserORM(email) {
    return User.findOne({ where: { email } });
  }
}

// Input validation for identifiers (table/column names)
class QueryBuilder {
  static allowedTables = ['users', 'posts', 'comments'];
  static allowedColumns = ['id', 'email', 'name', 'created_at'];
  
  static buildQuery(table, columns) {
    // Validate table name
    if (!this.allowedTables.includes(table)) {
      throw new Error('Invalid table name');
    }
    
    // Validate column names
    columns.forEach(col => {
      if (!this.allowedColumns.includes(col)) {
        throw new Error(`Invalid column name: ${col}`);
      }
    });
    
    return `SELECT ${columns.join(', ')} FROM ${table}`;
  }
}
```

---

## 39.7 Best Practices Summary

1. **Never Trust User Input** - Validate and sanitize everything
2. **Use HTTPS Everywhere** - Encrypt data in transit
3. **Implement CSP** - Content Security Policy headers
4. **Use HttpOnly Cookies** - Prevent XSS attacks on cookies
5. **Implement Rate Limiting** - Prevent abuse
6. **Use Prepared Statements** - Prevent SQL injection
7. **Hash Passwords Properly** - Use bcrypt or Argon2
8. **Implement CSRF Protection** - For state-changing operations
9. **Set Security Headers** - X-Frame-Options, X-Content-Type-Options
10. **Keep Dependencies Updated** - Regular security audits
11. **Principle of Least Privilege** - Minimum necessary permissions
12. **Log Security Events** - Monitor for attacks

```javascript
// Security headers middleware
function securityHeaders(req, res, next) {
  res.set({
    'X-Frame-Options': 'DENY',
    'X-Content-Type-Options': 'nosniff',
    'X-XSS-Protection': '1; mode=block',
    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
    'Content-Security-Policy': "default-src 'self'",
    'Referrer-Policy': 'no-referrer'
  });
  next();
}

app.use(securityHeaders);
```