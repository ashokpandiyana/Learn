# Chapter 6: Prototype Pattern

## 6.1 JavaScript's Native Pattern

### What is the Prototype Pattern?

The Prototype Pattern creates new objects by **cloning existing objects** (prototypes) rather than creating new instances from scratch. This is particularly useful when object creation is expensive or complex.

> ðŸ’¡ **Key Insight:** Unlike other languages where Prototype is just a design pattern, in JavaScript it's a **fundamental language feature**. JavaScript IS a prototype-based language!

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   PROTOTYPE PATTERN                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   Traditional OOP:          Prototype-Based:                â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”‚
â”‚                                                             â”‚
â”‚   Class (Blueprint)         Prototype Object                â”‚
â”‚        â”‚                         â”‚                          â”‚
â”‚        â–¼                         â–¼                          â”‚
â”‚   new Instance()            Clone/Delegate                  â”‚
â”‚                                  â”‚                          â”‚
â”‚                                  â–¼                          â”‚
â”‚                             New Object                      â”‚
â”‚                                                             â”‚
â”‚   "Classes define           "Objects inherit directly       â”‚
â”‚    what objects are"         from other objects"            â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Prototypal Inheritance Fundamentals

Every JavaScript object has an internal link to another object called its **prototype**. This chain continues until an object with `null` prototype is reached.

```javascript
// Understanding the prototype chain
const animal = {
  alive: true,
  breathe() {
    console.log('Breathing...');
  },
  eat(food) {
    console.log(`Eating ${food}`);
  }
};

// Create new object with 'animal' as prototype
const dog = Object.create(animal);
dog.breed = 'Labrador';
dog.bark = function() {
  console.log('Woof!');
};

// Create another object inheriting from dog
const myDog = Object.create(dog);
myDog.name = 'Rex';

// The prototype chain:
console.log(myDog.name);      // 'Rex' (own property)
console.log(myDog.breed);     // 'Labrador' (from dog)
console.log(myDog.alive);     // true (from animal)
myDog.breathe();              // 'Breathing...' (from animal)
myDog.bark();                 // 'Woof!' (from dog)

// Verify the chain
console.log(Object.getPrototypeOf(myDog) === dog);      // true
console.log(Object.getPrototypeOf(dog) === animal);     // true
console.log(Object.getPrototypeOf(animal) === Object.prototype); // true
console.log(Object.getPrototypeOf(Object.prototype));   // null (end of chain)
```

### Visualizing the Prototype Chain

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PROTOTYPE CHAIN                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   myDog                                                     â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                    â”‚
â”‚   â”‚ name: 'Rex'        â”‚                                    â”‚
â”‚   â”‚ [[Prototype]] â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”                             â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚                             â”‚
â”‚                               â–¼                             â”‚
â”‚                          dog                                â”‚
â”‚                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚                          â”‚ breed: 'Labrador'  â”‚             â”‚
â”‚                          â”‚ bark: function     â”‚             â”‚
â”‚                          â”‚ [[Prototype]] â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚      â”‚
â”‚                                                      â–¼      â”‚
â”‚                                                 animal      â”‚
â”‚                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚                                    â”‚ alive: true        â”‚   â”‚
â”‚                                    â”‚ breathe: function  â”‚   â”‚
â”‚                                    â”‚ eat: function      â”‚   â”‚
â”‚                                    â”‚ [[Prototype]] â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¤
â”‚                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â–¼
â”‚                                               Object.prototype
â”‚                                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                          â”‚ toString()         â”‚
â”‚                                          â”‚ hasOwnProperty()   â”‚
â”‚                                          â”‚ [[Prototype]]: nullâ”‚
â”‚                                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Object.create() Deep Dive

`Object.create()` is the purest way to implement prototypal inheritance.

```javascript
// Syntax: Object.create(proto, propertiesObject)

// Basic usage
const vehiclePrototype = {
  start() {
    console.log(`${this.make} ${this.model} starting...`);
    this.running = true;
  },
  stop() {
    console.log(`${this.make} ${this.model} stopping...`);
    this.running = false;
  },
  getInfo() {
    return `${this.year} ${this.make} ${this.model}`;
  }
};

// Create with property descriptors
const myCar = Object.create(vehiclePrototype, {
  make: {
    value: 'Toyota',
    writable: true,
    enumerable: true,
    configurable: true
  },
  model: {
    value: 'Camry',
    writable: true,
    enumerable: true,
    configurable: true
  },
  year: {
    value: 2024,
    writable: false,  // Cannot be changed
    enumerable: true,
    configurable: false
  },
  running: {
    value: false,
    writable: true,
    enumerable: true,
    configurable: true
  }
});

console.log(myCar.getInfo()); // '2024 Toyota Camry'
myCar.start();                // 'Toyota Camry starting...'
console.log(myCar.running);   // true

// Year is not writable
myCar.year = 2025;            // Silently fails (or throws in strict mode)
console.log(myCar.year);      // Still 2024

// Check property ownership
console.log(myCar.hasOwnProperty('make'));    // true
console.log(myCar.hasOwnProperty('start'));   // false (inherited)
```

### Property Shadowing

When you set a property on an object, it creates/modifies the property on that object, even if a property with the same name exists in the prototype chain.

```javascript
const parent = {
  name: 'Parent',
  greet() {
    return `Hello from ${this.name}`;
  }
};

const child = Object.create(parent);

// Before shadowing
console.log(child.name);        // 'Parent' (from prototype)
console.log(child.greet());     // 'Hello from Parent'

// Shadow the property
child.name = 'Child';

// After shadowing
console.log(child.name);        // 'Child' (own property)
console.log(parent.name);       // 'Parent' (unchanged)
console.log(child.greet());     // 'Hello from Child'

// Check ownership
console.log(child.hasOwnProperty('name'));   // true (now own property)
console.log(parent.hasOwnProperty('name'));  // true

// Delete child's own property to reveal parent's
delete child.name;
console.log(child.name);        // 'Parent' (back to prototype)
```

---

## 6.2 Cloning Strategies

### Shallow Copy vs Deep Copy

Understanding the difference is crucial for the Prototype pattern.

```javascript
const original = {
  name: 'Original',
  numbers: [1, 2, 3],
  nested: {
    value: 'deep',
    array: [4, 5, 6]
  },
  date: new Date('2024-01-01'),
  func: function() { return this.name; }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SHALLOW COPY METHODS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Method 1: Object.assign()
const shallow1 = Object.assign({}, original);

// Method 2: Spread operator
const shallow2 = { ...original };

// Method 3: Object.create() with property copying
const shallow3 = Object.create(
  Object.getPrototypeOf(original),
  Object.getOwnPropertyDescriptors(original)
);

// Problem with shallow copies:
shallow1.name = 'Modified';        // âœ… Doesn't affect original
shallow1.numbers.push(4);          // âŒ AFFECTS original!
shallow1.nested.value = 'changed'; // âŒ AFFECTS original!

console.log(original.numbers);     // [1, 2, 3, 4] - Modified!
console.log(original.nested.value); // 'changed' - Modified!
```

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              SHALLOW vs DEEP COPY                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  SHALLOW COPY:                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚  â”‚  Original   â”‚         â”‚   Copy      â”‚                    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                    â”‚
â”‚  â”‚ name: 'Orig'â”‚         â”‚ name: 'Orig'â”‚  â† Copied value    â”‚
â”‚  â”‚ arr: â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”    â”‚ arr: â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚               â”‚
â”‚                     â”‚                       â”‚               â”‚
â”‚                     â””â”€â”€â”€â”€â”€â”€â”€â–ºâ”Œâ”€â”€â”€â”€â”€â”€â”â—„â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                              â”‚[1,2,3]â”‚  â† SHARED reference! â”‚
â”‚                              â””â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚                                                             â”‚
â”‚  DEEP COPY:                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚  â”‚  Original   â”‚         â”‚   Copy      â”‚                    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                    â”‚
â”‚  â”‚ name: 'Orig'â”‚         â”‚ name: 'Orig'â”‚  â† Copied value    â”‚
â”‚  â”‚ arr: â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”      â”‚ arr: â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                 â”‚
â”‚                   â–¼                       â–¼                 â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”               â”‚
â”‚              â”‚[1,2,3]â”‚               â”‚[1,2,3]â”‚ â† SEPARATE!  â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Deep Copy Methods

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DEEP COPY METHODS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const original = {
  name: 'Original',
  numbers: [1, 2, 3],
  nested: { value: 'deep' },
  date: new Date('2024-01-01'),
  regex: /test/gi,
  func: function() { return this.name; },
  undef: undefined,
  sym: Symbol('test')
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Method 1: JSON.parse/stringify
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const jsonCopy = JSON.parse(JSON.stringify(original));

// âš ï¸ LIMITATIONS:
// - Loses: functions, undefined, Symbols, RegExp
// - Date becomes string
// - Cannot handle circular references
// - Loses prototype chain

console.log(jsonCopy.func);    // undefined (lost!)
console.log(jsonCopy.date);    // "2024-01-01T00:00:00.000Z" (string!)
console.log(jsonCopy.undef);   // undefined (key removed!)
console.log(jsonCopy.regex);   // {} (empty object!)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Method 2: structuredClone() (Modern - Recommended)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const structuredCopy = structuredClone({
  name: 'Original',
  numbers: [1, 2, 3],
  nested: { value: 'deep' },
  date: new Date('2024-01-01'),
  map: new Map([['key', 'value']]),
  set: new Set([1, 2, 3]),
  buffer: new ArrayBuffer(8)
});

// âœ… Handles: Date, Map, Set, ArrayBuffer, circular refs
// âŒ Cannot clone: Functions, DOM nodes, Symbols

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Method 3: Custom Deep Clone (Full Control)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function deepClone(obj, hash = new WeakMap()) {
  // Handle primitives and null
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // Handle circular references
  if (hash.has(obj)) {
    return hash.get(obj);
  }
  
  // Handle Date
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  
  // Handle RegExp
  if (obj instanceof RegExp) {
    return new RegExp(obj.source, obj.flags);
  }
  
  // Handle Map
  if (obj instanceof Map) {
    const clonedMap = new Map();
    hash.set(obj, clonedMap);
    obj.forEach((value, key) => {
      clonedMap.set(deepClone(key, hash), deepClone(value, hash));
    });
    return clonedMap;
  }
  
  // Handle Set
  if (obj instanceof Set) {
    const clonedSet = new Set();
    hash.set(obj, clonedSet);
    obj.forEach(value => {
      clonedSet.add(deepClone(value, hash));
    });
    return clonedSet;
  }
  
  // Handle Array
  if (Array.isArray(obj)) {
    const clonedArr = [];
    hash.set(obj, clonedArr);
    obj.forEach((item, index) => {
      clonedArr[index] = deepClone(item, hash);
    });
    return clonedArr;
  }
  
  // Handle Object
  const clonedObj = Object.create(Object.getPrototypeOf(obj));
  hash.set(obj, clonedObj);
  
  // Copy all properties including symbols
  const allKeys = [
    ...Object.keys(obj),
    ...Object.getOwnPropertySymbols(obj)
  ];
  
  for (const key of allKeys) {
    const descriptor = Object.getOwnPropertyDescriptor(obj, key);
    if (descriptor.value !== undefined) {
      descriptor.value = deepClone(descriptor.value, hash);
    }
    Object.defineProperty(clonedObj, key, descriptor);
  }
  
  return clonedObj;
}

// Test with circular reference
const circular = { name: 'circular' };
circular.self = circular;

const cloned = deepClone(circular);
console.log(cloned.self === cloned); // true (correctly handles circular!)
console.log(cloned !== circular);     // true (different object)
```

### Comparison Table

| Method | Functions | Date | RegExp | Circular | Prototype | Performance |
|--------|-----------|------|--------|----------|-----------|-------------|
| Object.assign() | âœ… | âœ… Ref | âœ… Ref | âŒ | âŒ | Fast |
| Spread {...} | âœ… | âœ… Ref | âœ… Ref | âŒ | âŒ | Fast |
| JSON parse/stringify | âŒ | âŒ String | âŒ | âŒ | âŒ | Medium |
| structuredClone() | âŒ | âœ… | âŒ | âœ… | âŒ | Medium |
| Custom deepClone | âœ… | âœ… | âœ… | âœ… | âœ… | Slower |

---

## 6.3 Prototype Pattern Implementation

### Classic Prototype Pattern

```javascript
// Prototype interface
class Prototype {
  clone() {
    throw new Error('Subclass must implement clone()');
  }
}

// Concrete Prototype: Document
class Document extends Prototype {
  constructor(title, content, author) {
    super();
    this.title = title;
    this.content = content;
    this.author = author;
    this.createdAt = new Date();
    this.modifiedAt = new Date();
    this.version = 1;
    this.metadata = {
      wordCount: content.split(' ').length,
      tags: []
    };
  }
  
  clone() {
    // Create a deep copy
    const cloned = Object.create(Object.getPrototypeOf(this));
    
    cloned.title = this.title + ' (Copy)';
    cloned.content = this.content;
    cloned.author = this.author;
    cloned.createdAt = new Date(); // New creation time
    cloned.modifiedAt = new Date();
    cloned.version = 1; // Reset version
    cloned.metadata = {
      ...this.metadata,
      tags: [...this.metadata.tags] // Deep copy array
    };
    
    return cloned;
  }
  
  addTag(tag) {
    this.metadata.tags.push(tag);
    this.modifiedAt = new Date();
  }
  
  updateContent(content) {
    this.content = content;
    this.metadata.wordCount = content.split(' ').length;
    this.modifiedAt = new Date();
    this.version++;
  }
}

// Usage
const originalDoc = new Document(
  'Design Patterns',
  'A comprehensive guide to design patterns in JavaScript',
  'John Doe'
);
originalDoc.addTag('programming');
originalDoc.addTag('javascript');

console.log('Original:', originalDoc.title);
console.log('Tags:', originalDoc.metadata.tags);

// Clone the document
const clonedDoc = originalDoc.clone();

console.log('Cloned:', clonedDoc.title);  // 'Design Patterns (Copy)'
console.log('Tags:', clonedDoc.metadata.tags); // Same tags, but different array

// Modify clone doesn't affect original
clonedDoc.addTag('tutorial');
console.log('Original tags:', originalDoc.metadata.tags); // ['programming', 'javascript']
console.log('Cloned tags:', clonedDoc.metadata.tags);     // ['programming', 'javascript', 'tutorial']
```

### Prototype Registry (Prototype Manager)

```javascript
class PrototypeRegistry {
  constructor() {
    this.prototypes = new Map();
  }
  
  register(name, prototype) {
    if (typeof prototype.clone !== 'function') {
      throw new Error('Prototype must have a clone() method');
    }
    this.prototypes.set(name, prototype);
  }
  
  unregister(name) {
    this.prototypes.delete(name);
  }
  
  get(name) {
    const prototype = this.prototypes.get(name);
    if (!prototype) {
      throw new Error(`Prototype "${name}" not found`);
    }
    return prototype.clone();
  }
  
  list() {
    return [...this.prototypes.keys()];
  }
}

// Shape prototypes
class Shape {
  constructor() {
    this.x = 0;
    this.y = 0;
    this.color = 'black';
  }
  
  clone() {
    const cloned = Object.create(Object.getPrototypeOf(this));
    Object.assign(cloned, this);
    return cloned;
  }
  
  moveTo(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  
  setColor(color) {
    this.color = color;
    return this;
  }
}

class Circle extends Shape {
  constructor(radius = 10) {
    super();
    this.radius = radius;
  }
  
  getArea() {
    return Math.PI * this.radius ** 2;
  }
  
  draw() {
    console.log(`Drawing ${this.color} circle at (${this.x}, ${this.y}) with radius ${this.radius}`);
  }
}

class Rectangle extends Shape {
  constructor(width = 10, height = 10) {
    super();
    this.width = width;
    this.height = height;
  }
  
  getArea() {
    return this.width * this.height;
  }
  
  draw() {
    console.log(`Drawing ${this.color} rectangle at (${this.x}, ${this.y}) - ${this.width}x${this.height}`);
  }
}

// Usage
const registry = new PrototypeRegistry();

// Register prototypes
const redCircle = new Circle(50);
redCircle.setColor('red');
registry.register('red-circle', redCircle);

const blueRect = new Rectangle(100, 50);
blueRect.setColor('blue');
registry.register('blue-rectangle', blueRect);

const greenCircle = new Circle(25);
greenCircle.setColor('green');
registry.register('small-green-circle', greenCircle);

// Clone from registry
const circle1 = registry.get('red-circle').moveTo(10, 20);
const circle2 = registry.get('red-circle').moveTo(100, 200);
const rect1 = registry.get('blue-rectangle').moveTo(50, 50);

circle1.draw(); // Drawing red circle at (10, 20) with radius 50
circle2.draw(); // Drawing red circle at (100, 200) with radius 50
rect1.draw();   // Drawing blue rectangle at (50, 50) - 100x50

console.log('Available prototypes:', registry.list());
// ['red-circle', 'blue-rectangle', 'small-green-circle']
```

---

## 6.4 Use Cases

### Use Case 1: Object Pool Pattern

```javascript
class ExpensiveObject {
  constructor(id) {
    this.id = id;
    // Simulate expensive initialization
    this.data = new Array(1000000).fill(0).map((_, i) => i * Math.random());
    this.createdAt = Date.now();
    console.log(`Created expensive object ${id}`);
  }
  
  reset() {
    // Reset state for reuse
    this.data.fill(0);
    return this;
  }
  
  clone() {
    const cloned = Object.create(Object.getPrototypeOf(this));
    cloned.id = `${this.id}-clone-${Date.now()}`;
    cloned.data = [...this.data]; // Copy the array
    cloned.createdAt = Date.now();
    return cloned;
  }
}

class ObjectPool {
  constructor(createFn, initialSize = 5, maxSize = 20) {
    this.createFn = createFn;
    this.maxSize = maxSize;
    this.available = [];
    this.inUse = new Set();
    
    // Pre-populate pool
    for (let i = 0; i < initialSize; i++) {
      this.available.push(this.createFn(i));
    }
  }
  
  acquire() {
    let obj;
    
    if (this.available.length > 0) {
      obj = this.available.pop();
      console.log(`Reusing object from pool`);
    } else if (this.inUse.size < this.maxSize) {
      obj = this.createFn(this.inUse.size);
      console.log(`Created new object (pool expanding)`);
    } else {
      throw new Error('Pool exhausted');
    }
    
    this.inUse.add(obj);
    return obj;
  }
  
  release(obj) {
    if (this.inUse.has(obj)) {
      this.inUse.delete(obj);
      obj.reset(); // Reset for reuse
      this.available.push(obj);
      console.log(`Object returned to pool`);
    }
  }
  
  getStats() {
    return {
      available: this.available.length,
      inUse: this.inUse.size,
      total: this.available.length + this.inUse.size
    };
  }
}

// Usage
const pool = new ObjectPool(
  (id) => new ExpensiveObject(id),
  3,  // Initial size
  10  // Max size
);

console.log('Initial stats:', pool.getStats());
// { available: 3, inUse: 0, total: 3 }

const obj1 = pool.acquire(); // Reusing
const obj2 = pool.acquire(); // Reusing
const obj3 = pool.acquire(); // Reusing
const obj4 = pool.acquire(); // Creates new

console.log('After acquiring 4:', pool.getStats());
// { available: 0, inUse: 4, total: 4 }

pool.release(obj1);
pool.release(obj2);

console.log('After releasing 2:', pool.getStats());
// { available: 2, inUse: 2, total: 4 }

const obj5 = pool.acquire(); // Reuses released object
```

### Use Case 2: Configuration Templates

```javascript
class ServerConfig {
  constructor() {
    this.host = 'localhost';
    this.port = 3000;
    this.ssl = false;
    this.timeout = 30000;
    this.maxConnections = 100;
    this.logging = {
      level: 'info',
      format: 'json',
      destination: 'console'
    };
    this.database = {
      host: 'localhost',
      port: 5432,
      poolSize: 10
    };
  }
  
  clone() {
    const cloned = new ServerConfig();
    cloned.host = this.host;
    cloned.port = this.port;
    cloned.ssl = this.ssl;
    cloned.timeout = this.timeout;
    cloned.maxConnections = this.maxConnections;
    cloned.logging = { ...this.logging };
    cloned.database = { ...this.database };
    return cloned;
  }
  
  // Fluent setters for customization
  setHost(host) { this.host = host; return this; }
  setPort(port) { this.port = port; return this; }
  enableSSL() { this.ssl = true; return this; }
  setLogging(config) { this.logging = { ...this.logging, ...config }; return this; }
  setDatabase(config) { this.database = { ...this.database, ...config }; return this; }
}

// Create template configurations
const templates = {
  development: new ServerConfig(),
  
  production: (() => {
    const config = new ServerConfig();
    config.host = '0.0.0.0';
    config.port = 8080;
    config.ssl = true;
    config.maxConnections = 1000;
    config.logging = { level: 'warn', format: 'json', destination: 'file' };
    config.database = { host: 'prod-db.example.com', port: 5432, poolSize: 50 };
    return config;
  })(),
  
  testing: (() => {
    const config = new ServerConfig();
    config.port = 3001;
    config.logging = { level: 'debug', format: 'pretty', destination: 'console' };
    config.database = { host: 'localhost', port: 5432, poolSize: 2 };
    return config;
  })()
};

// Clone and customize for specific needs
const apiServerConfig = templates.production.clone()
  .setPort(8081)
  .setLogging({ level: 'info' });

const workerServerConfig = templates.production.clone()
  .setPort(8082)
  .setDatabase({ poolSize: 20 });

console.log('API Server:', apiServerConfig);
console.log('Worker Server:', workerServerConfig);
```

---

## Key Takeaways

1. **JavaScript is prototype-based** - Understanding prototypes is essential
2. **Object.create()** is the purest prototypal inheritance method
3. **Know your cloning needs**: Shallow vs Deep copy
4. **structuredClone()** is the modern deep copy solution for most cases
5. **Custom clone for special cases**: Functions, RegExp, circular refs
6. **Prototype Registry** - Manage and organize clonable prototypes
7. **Object Pool** - Reuse expensive objects via cloning

> âš ï¸ **Important:** `structuredClone()` cannot clone functions, DOM nodes, or objects with certain property descriptors. Use custom clone for full control.

> ðŸ’¡ **Interview Tip:** Be ready to explain the prototype chain, demonstrate Object.create(), and discuss shallow vs deep copying strategies!
