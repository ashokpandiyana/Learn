# Chapter 16: Observer Pattern

## 16.1 Concept

### What is the Observer Pattern?

The Observer Pattern defines a **one-to-many dependency** between objects. When one object (the **Subject**) changes state, all its dependents (**Observers**) are notified and updated automatically.

Think of it like a newspaper subscription: when a new edition is published, all subscribers receive it automatically without having to check the newsstand.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    OBSERVER PATTERN                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
â”‚                     â”‚    SUBJECT    â”‚                       â”‚
â”‚                     â”‚   (Publisher) â”‚                       â”‚
â”‚                     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                       â”‚
â”‚                     â”‚ observers[]   â”‚                       â”‚
â”‚                     â”‚ attach()      â”‚                       â”‚
â”‚                     â”‚ detach()      â”‚                       â”‚
â”‚                     â”‚ notify()      â”‚                       â”‚
â”‚                     â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚                             â”‚                               â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚              â”‚              â”‚              â”‚                â”‚
â”‚              â–¼              â–¼              â–¼                â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚       â”‚Observer Aâ”‚   â”‚Observer Bâ”‚   â”‚Observer Câ”‚           â”‚
â”‚       â”‚ update() â”‚   â”‚ update() â”‚   â”‚ update() â”‚           â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                             â”‚
â”‚   When Subject changes â†’ All Observers are notified         â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Characteristics

| Concept | Description |
|---------|-------------|
| **Subject** | Maintains list of observers, sends notifications |
| **Observer** | Defines update interface for receiving notifications |
| **Loose Coupling** | Subject knows nothing about observers except interface |
| **Push vs Pull** | Subject can push data or observers can pull it |

### Push vs Pull Model

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   PUSH vs PULL MODEL                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  PUSH MODEL:                                                â”‚
â”‚  Subject sends all data to observers                        â”‚
â”‚  observer.update(data)                                      â”‚
â”‚  + Simple for observers                                     â”‚
â”‚  - May send unnecessary data                                â”‚
â”‚                                                             â”‚
â”‚  PULL MODEL:                                                â”‚
â”‚  Subject notifies, observers request data                   â”‚
â”‚  observer.update(this) â†’ observer calls subject.getData()  â”‚
â”‚  + Observers get only what they need                        â”‚
â”‚  - More complex, tighter coupling                           â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 16.2 Implementation

### Basic Observer Pattern

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SUBJECT: Maintains and notifies observers
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Subject {
  constructor() {
    this.observers = [];
  }
  
  attach(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      console.log('Observer attached');
    }
  }
  
  detach(observer) {
    const index = this.observers.indexOf(observer);
    if (index !== -1) {
      this.observers.splice(index, 1);
      console.log('Observer detached');
    }
  }
  
  notify(data) {
    console.log(`Notifying ${this.observers.length} observers...`);
    this.observers.forEach(observer => {
      observer.update(data);
    });
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OBSERVER INTERFACE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Observer {
  update(data) {
    throw new Error('Observer.update() must be implemented');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONCRETE SUBJECT: Weather Station
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class WeatherStation extends Subject {
  constructor() {
    super();
    this.temperature = 0;
    this.humidity = 0;
    this.pressure = 0;
  }
  
  setMeasurements(temperature, humidity, pressure) {
    console.log('\n--- Weather Station: New measurements ---');
    this.temperature = temperature;
    this.humidity = humidity;
    this.pressure = pressure;
    
    // Notify all observers of the change
    this.notify({
      temperature: this.temperature,
      humidity: this.humidity,
      pressure: this.pressure
    });
  }
  
  getTemperature() { return this.temperature; }
  getHumidity() { return this.humidity; }
  getPressure() { return this.pressure; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONCRETE OBSERVERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class CurrentConditionsDisplay extends Observer {
  constructor(name) {
    super();
    this.name = name;
  }
  
  update(data) {
    console.log(`[${this.name}] Current conditions:`);
    console.log(`  Temperature: ${data.temperature}Â°C`);
    console.log(`  Humidity: ${data.humidity}%`);
  }
}

class StatisticsDisplay extends Observer {
  constructor() {
    super();
    this.temperatures = [];
  }
  
  update(data) {
    this.temperatures.push(data.temperature);
    
    const avg = this.temperatures.reduce((a, b) => a + b, 0) / this.temperatures.length;
    const max = Math.max(...this.temperatures);
    const min = Math.min(...this.temperatures);
    
    console.log('[Statistics Display]');
    console.log(`  Avg: ${avg.toFixed(1)}Â°C, Max: ${max}Â°C, Min: ${min}Â°C`);
  }
}

class ForecastDisplay extends Observer {
  constructor() {
    super();
    this.lastPressure = 0;
  }
  
  update(data) {
    let forecast;
    if (data.pressure > this.lastPressure) {
      forecast = 'Improving weather on the way!';
    } else if (data.pressure < this.lastPressure) {
      forecast = 'Watch out for cooler, rainy weather';
    } else {
      forecast = 'More of the same';
    }
    
    this.lastPressure = data.pressure;
    console.log(`[Forecast Display] ${forecast}`);
  }
}

class AlertSystem extends Observer {
  constructor(thresholds) {
    super();
    this.thresholds = thresholds;
  }
  
  update(data) {
    if (data.temperature > this.thresholds.maxTemp) {
      console.log(`ðŸš¨ [ALERT] High temperature warning: ${data.temperature}Â°C`);
    }
    if (data.temperature < this.thresholds.minTemp) {
      console.log(`ðŸš¨ [ALERT] Low temperature warning: ${data.temperature}Â°C`);
    }
    if (data.humidity > this.thresholds.maxHumidity) {
      console.log(`ðŸš¨ [ALERT] High humidity warning: ${data.humidity}%`);
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USAGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const weatherStation = new WeatherStation();

// Create observers
const phoneDisplay = new CurrentConditionsDisplay('Phone App');
const webDisplay = new CurrentConditionsDisplay('Web Dashboard');
const statsDisplay = new StatisticsDisplay();
const forecastDisplay = new ForecastDisplay();
const alertSystem = new AlertSystem({
  maxTemp: 35,
  minTemp: 0,
  maxHumidity: 90
});

// Attach observers
weatherStation.attach(phoneDisplay);
weatherStation.attach(webDisplay);
weatherStation.attach(statsDisplay);
weatherStation.attach(forecastDisplay);
weatherStation.attach(alertSystem);

// Simulate weather changes
weatherStation.setMeasurements(25, 65, 1013);
weatherStation.setMeasurements(28, 70, 1010);
weatherStation.setMeasurements(38, 92, 1005); // Triggers alerts!

// Detach an observer
weatherStation.detach(webDisplay);
weatherStation.setMeasurements(22, 60, 1015);
```

### Modern JavaScript EventEmitter

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EventEmitter: A more flexible Observer implementation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class EventEmitter {
  constructor() {
    this.events = new Map();
  }
  
  // Subscribe to an event
  on(event, listener) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event).push(listener);
    
    // Return unsubscribe function
    return () => this.off(event, listener);
  }
  
  // Subscribe once
  once(event, listener) {
    const wrapper = (...args) => {
      listener(...args);
      this.off(event, wrapper);
    };
    return this.on(event, wrapper);
  }
  
  // Unsubscribe from an event
  off(event, listener) {
    if (!this.events.has(event)) return;
    
    const listeners = this.events.get(event);
    const index = listeners.indexOf(listener);
    
    if (index !== -1) {
      listeners.splice(index, 1);
    }
    
    if (listeners.length === 0) {
      this.events.delete(event);
    }
  }
  
  // Emit an event
  emit(event, ...args) {
    if (!this.events.has(event)) return false;
    
    const listeners = this.events.get(event);
    listeners.forEach(listener => {
      try {
        listener(...args);
      } catch (error) {
        console.error(`Error in listener for "${event}":`, error);
      }
    });
    
    return true;
  }
  
  // Get listener count
  listenerCount(event) {
    return this.events.has(event) ? this.events.get(event).length : 0;
  }
  
  // Remove all listeners
  removeAllListeners(event) {
    if (event) {
      this.events.delete(event);
    } else {
      this.events.clear();
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USAGE: Shopping Cart with Events
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class ShoppingCart extends EventEmitter {
  constructor() {
    super();
    this.items = [];
  }
  
  addItem(item) {
    this.items.push(item);
    this.emit('itemAdded', item);
    this.emit('cartUpdated', this.items, this.getTotal());
  }
  
  removeItem(itemId) {
    const index = this.items.findIndex(i => i.id === itemId);
    if (index !== -1) {
      const removed = this.items.splice(index, 1)[0];
      this.emit('itemRemoved', removed);
      this.emit('cartUpdated', this.items, this.getTotal());
    }
  }
  
  getTotal() {
    return this.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  }
  
  checkout() {
    if (this.items.length === 0) {
      this.emit('checkoutFailed', 'Cart is empty');
      return;
    }
    
    const order = {
      items: [...this.items],
      total: this.getTotal(),
      timestamp: new Date()
    };
    
    this.items = [];
    this.emit('checkoutComplete', order);
    this.emit('cartUpdated', this.items, 0);
  }
}

// Usage
const cart = new ShoppingCart();

// UI Updates
cart.on('cartUpdated', (items, total) => {
  console.log(`[UI] Cart updated: ${items.length} items, Total: $${total.toFixed(2)}`);
});

// Analytics
cart.on('itemAdded', (item) => {
  console.log(`[Analytics] Item added: ${item.name}`);
});

cart.on('itemRemoved', (item) => {
  console.log(`[Analytics] Item removed: ${item.name}`);
});

// Notifications
cart.on('checkoutComplete', (order) => {
  console.log(`[Email] Order confirmation sent! Total: $${order.total.toFixed(2)}`);
});

// Inventory System (subscribe once for demo)
cart.once('itemAdded', (item) => {
  console.log(`[Inventory] First item added - checking stock for: ${item.name}`);
});

// Test
cart.addItem({ id: 1, name: 'Laptop', price: 999.99, quantity: 1 });
cart.addItem({ id: 2, name: 'Mouse', price: 29.99, quantity: 2 });
cart.removeItem(2);
cart.checkout();
```

---

## 16.3 Advanced Patterns

### Observable with RxJS-like Interface

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Simple Observable Implementation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Observable {
  constructor(subscribe) {
    this._subscribe = subscribe;
  }
  
  subscribe(observer) {
    // Normalize observer
    const normalizedObserver = typeof observer === 'function'
      ? { next: observer, error: () => {}, complete: () => {} }
      : { next: observer.next || (() => {}),
          error: observer.error || (() => {}),
          complete: observer.complete || (() => {}) };
    
    // Execute the subscribe function
    const teardown = this._subscribe(normalizedObserver);
    
    // Return subscription object
    return {
      unsubscribe: () => {
        if (typeof teardown === 'function') {
          teardown();
        }
      }
    };
  }
  
  // Operators
  pipe(...operators) {
    return operators.reduce((source, operator) => operator(source), this);
  }
  
  // Static creators
  static of(...values) {
    return new Observable(observer => {
      values.forEach(value => observer.next(value));
      observer.complete();
    });
  }
  
  static from(iterable) {
    return new Observable(observer => {
      for (const value of iterable) {
        observer.next(value);
      }
      observer.complete();
    });
  }
  
  static interval(ms) {
    return new Observable(observer => {
      let count = 0;
      const id = setInterval(() => {
        observer.next(count++);
      }, ms);
      
      return () => clearInterval(id);
    });
  }
  
  static fromEvent(element, eventName) {
    return new Observable(observer => {
      const handler = (e) => observer.next(e);
      element.addEventListener(eventName, handler);
      return () => element.removeEventListener(eventName, handler);
    });
  }
}

// Operators
function map(transformFn) {
  return (source) => new Observable(observer => {
    return source.subscribe({
      next: value => observer.next(transformFn(value)),
      error: err => observer.error(err),
      complete: () => observer.complete()
    });
  });
}

function filter(predicateFn) {
  return (source) => new Observable(observer => {
    return source.subscribe({
      next: value => {
        if (predicateFn(value)) {
          observer.next(value);
        }
      },
      error: err => observer.error(err),
      complete: () => observer.complete()
    });
  });
}

function take(count) {
  return (source) => new Observable(observer => {
    let taken = 0;
    const subscription = source.subscribe({
      next: value => {
        if (taken < count) {
          observer.next(value);
          taken++;
          if (taken >= count) {
            observer.complete();
            subscription.unsubscribe();
          }
        }
      },
      error: err => observer.error(err),
      complete: () => observer.complete()
    });
    return subscription;
  });
}

function debounceTime(ms) {
  return (source) => new Observable(observer => {
    let timeoutId;
    return source.subscribe({
      next: value => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => observer.next(value), ms);
      },
      error: err => observer.error(err),
      complete: () => observer.complete()
    });
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USAGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Simple observable
const numbers$ = Observable.of(1, 2, 3, 4, 5);

numbers$.pipe(
  filter(n => n % 2 === 0),
  map(n => n * 10)
).subscribe({
  next: value => console.log('Value:', value),
  complete: () => console.log('Complete!')
});
// Value: 20
// Value: 40
// Complete!

// Interval with take
const timer$ = Observable.interval(100);
const subscription = timer$.pipe(
  take(5),
  map(n => `Tick ${n}`)
).subscribe({
  next: value => console.log(value),
  complete: () => console.log('Timer complete')
});

// Cleanup after 1 second
setTimeout(() => subscription.unsubscribe(), 1000);
```

---

## 16.4 Production Considerations

### Memory Leaks Prevention

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROBLEM: Memory leaks from forgotten subscriptions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Component {
  constructor(eventEmitter) {
    this.eventEmitter = eventEmitter;
    this.subscriptions = [];
  }
  
  initialize() {
    // âŒ BAD: Subscription never cleaned up
    // this.eventEmitter.on('data', this.handleData);
    
    // âœ… GOOD: Store unsubscribe function
    const unsubscribe = this.eventEmitter.on('data', (data) => {
      this.handleData(data);
    });
    this.subscriptions.push(unsubscribe);
  }
  
  handleData(data) {
    console.log('Received:', data);
  }
  
  // Always clean up!
  destroy() {
    console.log('Cleaning up subscriptions...');
    this.subscriptions.forEach(unsubscribe => unsubscribe());
    this.subscriptions = [];
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Subscription Manager Pattern
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class SubscriptionManager {
  constructor() {
    this.subscriptions = new Map();
  }
  
  add(key, unsubscribeFn) {
    // Auto-cleanup if key already exists
    if (this.subscriptions.has(key)) {
      this.subscriptions.get(key)();
    }
    this.subscriptions.set(key, unsubscribeFn);
  }
  
  remove(key) {
    if (this.subscriptions.has(key)) {
      this.subscriptions.get(key)();
      this.subscriptions.delete(key);
    }
  }
  
  clear() {
    this.subscriptions.forEach(unsubscribe => unsubscribe());
    this.subscriptions.clear();
  }
}

// Usage
class UserDashboard {
  constructor(userService, notificationService) {
    this.userService = userService;
    this.notificationService = notificationService;
    this.subs = new SubscriptionManager();
  }
  
  mount() {
    this.subs.add('user', 
      this.userService.on('userUpdated', this.updateUser.bind(this))
    );
    
    this.subs.add('notifications',
      this.notificationService.on('newNotification', this.showNotification.bind(this))
    );
  }
  
  unmount() {
    this.subs.clear(); // Clean all subscriptions
  }
  
  updateUser(user) { /* ... */ }
  showNotification(notification) { /* ... */ }
}
```

### Error Handling

```javascript
class SafeEventEmitter extends EventEmitter {
  emit(event, ...args) {
    if (!this.events.has(event)) return false;
    
    const listeners = this.events.get(event);
    let hasError = false;
    
    listeners.forEach(listener => {
      try {
        listener(...args);
      } catch (error) {
        hasError = true;
        // Emit error event if there are listeners
        if (event !== 'error' && this.events.has('error')) {
          this.emit('error', error, event);
        } else {
          console.error(`Error in "${event}" listener:`, error);
        }
      }
    });
    
    return !hasError;
  }
}

// Usage
const emitter = new SafeEventEmitter();

emitter.on('error', (error, event) => {
  console.log(`[Error Handler] Error in "${event}":`, error.message);
  // Log to monitoring service, etc.
});

emitter.on('data', (data) => {
  throw new Error('Something went wrong!');
});

emitter.emit('data', { value: 42 });
// [Error Handler] Error in "data": Something went wrong!
```

---

## Key Takeaways

1. **Observer = One-to-Many** - One subject, many observers
2. **Loose coupling** - Subject doesn't know observer details
3. **Push vs Pull** - Choose based on use case
4. **EventEmitter** - Common JavaScript implementation
5. **Always unsubscribe** - Prevent memory leaks
6. **Error handling** - Don't let one observer break others
7. **Use for**: UI updates, event systems, reactive data

> âš ï¸ **Critical:** Always unsubscribe observers to prevent memory leaks, especially in SPAs and long-running applications.

> ðŸ’¡ **Interview Tip:** Be able to implement a basic EventEmitter from scratch. Explain the difference between Observer and Pub/Sub patterns.
