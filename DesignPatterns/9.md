# Chapter 9: Decorator Pattern

## 9.1 Concept and Motivation

### What is the Decorator Pattern?

The Decorator Pattern allows you to **add new behaviors to objects dynamically** by wrapping them in objects that contain these behaviors. It provides a flexible alternative to subclassing for extending functionality.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   DECORATOR PATTERN                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   WITHOUT DECORATOR (Inheritance explosion):                â”‚
â”‚                                                             â”‚
â”‚                    Coffee                                   â”‚
â”‚                       â”‚                                     â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚       â–¼               â–¼               â–¼                     â”‚
â”‚   CoffeeWithMilk  CoffeeWithSugar  CoffeeWithMilkAndSugar   â”‚
â”‚       â”‚               â”‚               â”‚                     â”‚
â”‚       â–¼               â–¼               â–¼                     â”‚
â”‚   (more subclasses for every combination...)                â”‚
â”‚                                                             â”‚
â”‚   WITH DECORATOR (Composition):                             â”‚
â”‚                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚ Coffee  â”‚ â—„â”€â”€â”‚  Milk   â”‚ â—„â”€â”€â”‚  Sugar  â”‚ â—„â”€â”€â”‚ Vanilla â”‚  â”‚
â”‚   â”‚ (base)  â”‚    â”‚(wrapper)â”‚    â”‚(wrapper)â”‚    â”‚(wrapper)â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                             â”‚
â”‚   Each wrapper adds behavior and delegates to wrapped objectâ”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Why Use Decorators?

| Problem | Solution with Decorator |
|---------|------------------------|
| Class explosion from combinations | Compose behaviors at runtime |
| Modifying existing code | Wrap instead of modify |
| Adding cross-cutting concerns | Layer concerns independently |
| Conditional functionality | Apply decorators conditionally |

### Open/Closed Principle

The Decorator pattern follows the **Open/Closed Principle**: classes should be open for extension but closed for modification. Instead of changing a class, we wrap it.

---

## 9.2 Function Decorators (Most Common in JS)

### Basic Function Wrapper

```javascript
// The simplest decorator: wrap a function
function withLogging(fn) {
  return function(...args) {
    console.log(`Calling ${fn.name} with args:`, args);
    const result = fn.apply(this, args);
    console.log(`${fn.name} returned:`, result);
    return result;
  };
}

function add(a, b) {
  return a + b;
}

const loggedAdd = withLogging(add);
loggedAdd(2, 3);
// Calling add with args: [2, 3]
// add returned: 5
```

### Practical Function Decorators

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 1. TIMING DECORATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function withTiming(fn) {
  return function(...args) {
    const start = performance.now();
    const result = fn.apply(this, args);
    const end = performance.now();
    console.log(`${fn.name} took ${(end - start).toFixed(2)}ms`);
    return result;
  };
}

// Async version
function withTimingAsync(fn) {
  return async function(...args) {
    const start = performance.now();
    const result = await fn.apply(this, args);
    const end = performance.now();
    console.log(`${fn.name} took ${(end - start).toFixed(2)}ms`);
    return result;
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 2. MEMOIZATION DECORATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function withMemoization(fn) {
  const cache = new Map();
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      console.log(`Cache hit for ${fn.name}`);
      return cache.get(key);
    }
    
    console.log(`Cache miss for ${fn.name}`);
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// With TTL (Time To Live)
function withMemoizationTTL(fn, ttl = 60000) {
  const cache = new Map();
  
  return function(...args) {
    const key = JSON.stringify(args);
    const cached = cache.get(key);
    
    if (cached && Date.now() - cached.timestamp < ttl) {
      return cached.value;
    }
    
    const result = fn.apply(this, args);
    cache.set(key, { value: result, timestamp: Date.now() });
    return result;
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 3. RETRY DECORATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function withRetry(fn, maxRetries = 3, delay = 1000) {
  return async function(...args) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await fn.apply(this, args);
      } catch (error) {
        lastError = error;
        console.log(`Attempt ${attempt} failed: ${error.message}`);
        
        if (attempt < maxRetries) {
          await new Promise(r => setTimeout(r, delay * attempt));
        }
      }
    }
    
    throw lastError;
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 4. THROTTLE DECORATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function withThrottle(fn, limit = 1000) {
  let lastCall = 0;
  let lastResult;
  
  return function(...args) {
    const now = Date.now();
    
    if (now - lastCall >= limit) {
      lastCall = now;
      lastResult = fn.apply(this, args);
    }
    
    return lastResult;
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 5. DEBOUNCE DECORATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function withDebounce(fn, delay = 300) {
  let timeoutId;
  
  return function(...args) {
    clearTimeout(timeoutId);
    
    timeoutId = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// With immediate option
function withDebounceImmediate(fn, delay = 300, immediate = false) {
  let timeoutId;
  
  return function(...args) {
    const callNow = immediate && !timeoutId;
    
    clearTimeout(timeoutId);
    
    timeoutId = setTimeout(() => {
      timeoutId = null;
      if (!immediate) fn.apply(this, args);
    }, delay);
    
    if (callNow) fn.apply(this, args);
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 6. VALIDATION DECORATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function withValidation(fn, validators) {
  return function(...args) {
    for (let i = 0; i < validators.length; i++) {
      const validator = validators[i];
      const arg = args[i];
      
      if (validator && !validator(arg)) {
        throw new Error(`Invalid argument at position ${i}: ${arg}`);
      }
    }
    
    return fn.apply(this, args);
  };
}

// Usage
const isPositive = n => typeof n === 'number' && n > 0;
const isString = s => typeof s === 'string';

const createUser = withValidation(
  (age, name) => ({ age, name }),
  [isPositive, isString]
);

createUser(25, 'John');  // âœ… { age: 25, name: 'John' }
createUser(-5, 'John');  // âŒ Error: Invalid argument at position 0
```

### Composing Multiple Decorators

```javascript
// Compose decorators (right to left, like mathematical composition)
function compose(...decorators) {
  return function(fn) {
    return decorators.reduceRight((decorated, decorator) => {
      return decorator(decorated);
    }, fn);
  };
}

// Pipe decorators (left to right)
function pipe(...decorators) {
  return function(fn) {
    return decorators.reduce((decorated, decorator) => {
      return decorator(decorated);
    }, fn);
  };
}

// Usage
async function fetchUserData(userId) {
  const response = await fetch(`/api/users/${userId}`);
  return response.json();
}

// Apply multiple decorators
const enhancedFetch = pipe(
  withTimingAsync,
  withRetry,
  withMemoizationTTL
)(fetchUserData);

// Or using compose (decorators applied right-to-left)
const enhancedFetch2 = compose(
  withTimingAsync,      // 3rd: Add timing
  withRetry,            // 2nd: Add retry
  withMemoizationTTL    // 1st: Add caching
)(fetchUserData);
```

---

## 9.3 Object/Class Decorators

### Classic Object Decorator Pattern

```javascript
// Base component interface
class Coffee {
  getCost() {
    return 5;
  }
  
  getDescription() {
    return 'Simple Coffee';
  }
}

// Base decorator
class CoffeeDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }
  
  getCost() {
    return this.coffee.getCost();
  }
  
  getDescription() {
    return this.coffee.getDescription();
  }
}

// Concrete decorators
class MilkDecorator extends CoffeeDecorator {
  getCost() {
    return this.coffee.getCost() + 1.5;
  }
  
  getDescription() {
    return this.coffee.getDescription() + ', Milk';
  }
}

class SugarDecorator extends CoffeeDecorator {
  getCost() {
    return this.coffee.getCost() + 0.5;
  }
  
  getDescription() {
    return this.coffee.getDescription() + ', Sugar';
  }
}

class VanillaDecorator extends CoffeeDecorator {
  getCost() {
    return this.coffee.getCost() + 2;
  }
  
  getDescription() {
    return this.coffee.getDescription() + ', Vanilla';
  }
}

class WhippedCreamDecorator extends CoffeeDecorator {
  getCost() {
    return this.coffee.getCost() + 1;
  }
  
  getDescription() {
    return this.coffee.getDescription() + ', Whipped Cream';
  }
}

// Usage - compose decorators as needed
let coffee = new Coffee();
console.log(`${coffee.getDescription()}: $${coffee.getCost()}`);
// Simple Coffee: $5

coffee = new MilkDecorator(coffee);
console.log(`${coffee.getDescription()}: $${coffee.getCost()}`);
// Simple Coffee, Milk: $6.5

coffee = new SugarDecorator(coffee);
coffee = new VanillaDecorator(coffee);
console.log(`${coffee.getDescription()}: $${coffee.getCost()}`);
// Simple Coffee, Milk, Sugar, Vanilla: $9

// Different combination
let fancyCoffee = new WhippedCreamDecorator(
  new VanillaDecorator(
    new MilkDecorator(
      new Coffee()
    )
  )
);
console.log(`${fancyCoffee.getDescription()}: $${fancyCoffee.getCost()}`);
// Simple Coffee, Milk, Vanilla, Whipped Cream: $9.5
```

### JavaScript-Style Object Decoration

```javascript
// More idiomatic JavaScript approach
function createLogger(options = {}) {
  return {
    level: options.level || 'info',
    
    log(message) {
      console.log(`[LOG] ${message}`);
    },
    
    info(message) {
      console.log(`[INFO] ${message}`);
    },
    
    error(message) {
      console.error(`[ERROR] ${message}`);
    }
  };
}

// Decorator functions
function withTimestamp(logger) {
  const original = { ...logger };
  
  return {
    ...logger,
    log(message) {
      original.log(`[${new Date().toISOString()}] ${message}`);
    },
    info(message) {
      original.info(`[${new Date().toISOString()}] ${message}`);
    },
    error(message) {
      original.error(`[${new Date().toISOString()}] ${message}`);
    }
  };
}

function withPrefix(logger, prefix) {
  const original = { ...logger };
  
  return {
    ...logger,
    log(message) {
      original.log(`[${prefix}] ${message}`);
    },
    info(message) {
      original.info(`[${prefix}] ${message}`);
    },
    error(message) {
      original.error(`[${prefix}] ${message}`);
    }
  };
}

function withFileOutput(logger, filePath) {
  const original = { ...logger };
  
  return {
    ...logger,
    log(message) {
      original.log(message);
      // fs.appendFileSync(filePath, message + '\n');
      console.log(`(Also written to ${filePath})`);
    }
    // ... other methods
  };
}

// Compose decorators
let logger = createLogger();
logger = withTimestamp(logger);
logger = withPrefix(logger, 'MyApp');

logger.info('Application started');
// [INFO] [MyApp] [2024-01-15T10:30:00.000Z] Application started
```

---

## 9.4 TC39 Decorators (Stage 3)

Modern JavaScript (via TypeScript or Babel) supports decorator syntax. This is heavily used in frameworks like Angular and NestJS.

```javascript
// Note: Requires transpilation (TypeScript/Babel)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLASS DECORATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function sealed(constructor) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}

function singleton(constructor) {
  let instance;
  
  return class extends constructor {
    constructor(...args) {
      if (instance) {
        return instance;
      }
      super(...args);
      instance = this;
    }
  };
}

@sealed
@singleton
class Database {
  constructor() {
    this.connection = null;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// METHOD DECORATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function log(target, propertyKey, descriptor) {
  const original = descriptor.value;
  
  descriptor.value = function(...args) {
    console.log(`Calling ${propertyKey} with:`, args);
    const result = original.apply(this, args);
    console.log(`${propertyKey} returned:`, result);
    return result;
  };
  
  return descriptor;
}

function readonly(target, propertyKey, descriptor) {
  descriptor.writable = false;
  return descriptor;
}

function deprecated(message) {
  return function(target, propertyKey, descriptor) {
    const original = descriptor.value;
    
    descriptor.value = function(...args) {
      console.warn(`DEPRECATED: ${propertyKey}() - ${message}`);
      return original.apply(this, args);
    };
    
    return descriptor;
  };
}

class Calculator {
  @log
  add(a, b) {
    return a + b;
  }
  
  @readonly
  get pi() {
    return 3.14159;
  }
  
  @deprecated('Use multiply() instead')
  times(a, b) {
    return a * b;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROPERTY DECORATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function required(target, propertyKey) {
  let value;
  
  Object.defineProperty(target, propertyKey, {
    get() {
      if (value === undefined) {
        throw new Error(`${propertyKey} is required`);
      }
      return value;
    },
    set(newValue) {
      if (newValue === undefined || newValue === null) {
        throw new Error(`${propertyKey} cannot be null or undefined`);
      }
      value = newValue;
    }
  });
}

function min(minValue) {
  return function(target, propertyKey) {
    let value;
    
    Object.defineProperty(target, propertyKey, {
      get() { return value; },
      set(newValue) {
        if (newValue < minValue) {
          throw new Error(`${propertyKey} must be at least ${minValue}`);
        }
        value = newValue;
      }
    });
  };
}

class User {
  @required
  name;
  
  @min(0)
  age;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PARAMETER DECORATOR (Used with method decorator)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const validatedParams = Symbol('validatedParams');

function validate(validator) {
  return function(target, propertyKey, parameterIndex) {
    const existing = target[validatedParams] || {};
    existing[propertyKey] = existing[propertyKey] || [];
    existing[propertyKey][parameterIndex] = validator;
    target[validatedParams] = existing;
  };
}

function validateParams(target, propertyKey, descriptor) {
  const original = descriptor.value;
  
  descriptor.value = function(...args) {
    const validators = target[validatedParams]?.[propertyKey] || [];
    
    validators.forEach((validator, index) => {
      if (validator && !validator(args[index])) {
        throw new Error(`Invalid parameter at index ${index}`);
      }
    });
    
    return original.apply(this, args);
  };
  
  return descriptor;
}

class UserService {
  @validateParams
  createUser(
    @validate(s => s && s.length >= 2) name,
    @validate(n => n > 0 && n < 150) age
  ) {
    return { name, age };
  }
}
```

---

## 9.5 Real-World Use Cases

### Use Case 1: API Request Decorators

```javascript
// API decorator utilities
const withAuth = (fetchFn) => async (url, options = {}) => {
  const token = localStorage.getItem('authToken');
  return fetchFn(url, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${token}`
    }
  });
};

const withErrorHandling = (fetchFn) => async (url, options) => {
  try {
    const response = await fetchFn(url, options);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    return response;
  } catch (error) {
    console.error('API Error:', error);
    throw error;
  }
};

const withRetry = (fetchFn, maxRetries = 3) => async (url, options) => {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fetchFn(url, options);
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(r => setTimeout(r, 1000 * (i + 1)));
    }
  }
};

const withLogging = (fetchFn) => async (url, options) => {
  console.log(`â†’ ${options?.method || 'GET'} ${url}`);
  const start = Date.now();
  const response = await fetchFn(url, options);
  console.log(`â† ${response.status} (${Date.now() - start}ms)`);
  return response;
};

// Compose into enhanced fetch
const api = pipe(
  withLogging,
  withAuth,
  withRetry,
  withErrorHandling
)(fetch);

// Usage
const userData = await api('/api/users/me').then(r => r.json());
```

### Use Case 2: React Higher-Order Components (HOC)

```javascript
// HOCs are decorators for React components

// withLoading HOC
function withLoading(WrappedComponent) {
  return function WithLoadingComponent({ isLoading, ...props }) {
    if (isLoading) {
      return <div className="loading">Loading...</div>;
    }
    return <WrappedComponent {...props} />;
  };
}

// withAuth HOC
function withAuth(WrappedComponent) {
  return function WithAuthComponent(props) {
    const { user } = useAuth();
    
    if (!user) {
      return <Redirect to="/login" />;
    }
    
    return <WrappedComponent {...props} user={user} />;
  };
}

// withErrorBoundary HOC
function withErrorBoundary(WrappedComponent, FallbackComponent) {
  return class WithErrorBoundary extends React.Component {
    state = { hasError: false };
    
    static getDerivedStateFromError() {
      return { hasError: true };
    }
    
    componentDidCatch(error, info) {
      console.error('Component Error:', error, info);
    }
    
    render() {
      if (this.state.hasError) {
        return <FallbackComponent />;
      }
      return <WrappedComponent {...this.props} />;
    }
  };
}

// Usage
const UserProfile = ({ user }) => <div>{user.name}</div>;

const EnhancedUserProfile = pipe(
  withErrorBoundary,
  withAuth,
  withLoading
)(UserProfile);

// Or with compose
const EnhancedUserProfile = compose(
  withLoading,
  withAuth,
  withErrorBoundary
)(UserProfile);
```

### Use Case 3: Validation Decorators (NestJS Style)

```javascript
// Simulating NestJS-style validation decorators

const validators = Symbol('validators');

function IsString() {
  return (target, propertyKey) => {
    target[validators] = target[validators] || {};
    target[validators][propertyKey] = target[validators][propertyKey] || [];
    target[validators][propertyKey].push({
      type: 'string',
      validate: (v) => typeof v === 'string',
      message: `${propertyKey} must be a string`
    });
  };
}

function IsEmail() {
  return (target, propertyKey) => {
    target[validators] = target[validators] || {};
    target[validators][propertyKey] = target[validators][propertyKey] || [];
    target[validators][propertyKey].push({
      type: 'email',
      validate: (v) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v),
      message: `${propertyKey} must be a valid email`
    });
  };
}

function MinLength(min) {
  return (target, propertyKey) => {
    target[validators] = target[validators] || {};
    target[validators][propertyKey] = target[validators][propertyKey] || [];
    target[validators][propertyKey].push({
      type: 'minLength',
      validate: (v) => v && v.length >= min,
      message: `${propertyKey} must be at least ${min} characters`
    });
  };
}

function validate(instance) {
  const validatorMap = instance[validators] || {};
  const errors = [];
  
  for (const [property, propertyValidators] of Object.entries(validatorMap)) {
    for (const validator of propertyValidators) {
      if (!validator.validate(instance[property])) {
        errors.push(validator.message);
      }
    }
  }
  
  return { valid: errors.length === 0, errors };
}

// Usage
class CreateUserDto {
  @IsString()
  @MinLength(2)
  name;
  
  @IsEmail()
  email;
  
  @IsString()
  @MinLength(8)
  password;
}

const dto = new CreateUserDto();
dto.name = 'J';
dto.email = 'invalid';
dto.password = '123';

const result = validate(dto);
console.log(result);
// { valid: false, errors: ['name must be at least 2 characters', ...] }
```

---

## Key Takeaways

1. **Decorators add behavior without modifying original** - Wrap, don't change
2. **Function decorators are most common in JS** - Simple and flexible
3. **Compose decorators for complex behavior** - Use pipe/compose utilities
4. **Object decorators follow interface** - Decorated objects look the same
5. **TC39 decorators are powerful** - Class/method/property decorators
6. **Use for cross-cutting concerns** - Logging, auth, validation, caching
7. **React HOCs are decorators** - Enhance components without modifying them

> ğŸ”¥ **Framework Usage:** Decorators are heavily used in Angular (@Component, @Injectable), NestJS (@Controller, @Get), TypeORM (@Entity, @Column), and MobX (@observable, @action).

> ğŸ’¡ **Interview Tip:** Be ready to implement debounce/throttle decorators, explain the difference between inheritance and decoration, and discuss cross-cutting concerns.
