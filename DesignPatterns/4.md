# Chapter 4: Factory Pattern

## Introduction

The Factory Pattern is one of the most widely used creational patterns. It provides an interface for creating objects without specifying their exact classes. There are three variations: **Simple Factory**, **Factory Method**, and **Abstract Factory**.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 FACTORY PATTERN FAMILY                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Simple Factory â”€â”€â–º Factory Method â”€â”€â–º Abstract Factory     â”‚
â”‚      (Basic)          (Extensible)        (Complex)         â”‚
â”‚                                                             â”‚
â”‚  Complexity & Flexibility increases â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4.1 Simple Factory

### Concept

The Simple Factory is not technically a "pattern" (it's an idiom), but it's the foundation for understanding factories. It **encapsulates object creation** in a single place.

### The Problem It Solves

```javascript
// âŒ WITHOUT FACTORY: Client is tightly coupled to concrete classes
function processPayment(type, amount) {
  let processor;
  
  if (type === 'credit') {
    processor = new CreditCardProcessor();
  } else if (type === 'paypal') {
    processor = new PayPalProcessor();
  } else if (type === 'crypto') {
    processor = new CryptoProcessor();
  }
  
  return processor.process(amount);
}

// Problems:
// 1. processPayment knows about ALL processor types
// 2. Adding new types requires changing this function
// 3. Duplicate logic if creation happens elsewhere
// 4. Hard to test - can't easily mock processors
```

### The Solution

```javascript
// âœ… WITH SIMPLE FACTORY: Centralized object creation

// Define the products
class CreditCardProcessor {
  constructor() {
    this.type = 'Credit Card';
  }
  
  process(amount) {
    console.log(`Processing $${amount} via Credit Card`);
    return { success: true, type: this.type, amount };
  }
}

class PayPalProcessor {
  constructor() {
    this.type = 'PayPal';
  }
  
  process(amount) {
    console.log(`Processing $${amount} via PayPal`);
    return { success: true, type: this.type, amount };
  }
}

class CryptoProcessor {
  constructor() {
    this.type = 'Cryptocurrency';
  }
  
  process(amount) {
    console.log(`Processing $${amount} via Crypto`);
    return { success: true, type: this.type, amount };
  }
}

// The Simple Factory
class PaymentProcessorFactory {
  static create(type) {
    const processors = {
      credit: CreditCardProcessor,
      paypal: PayPalProcessor,
      crypto: CryptoProcessor
    };
    
    const ProcessorClass = processors[type];
    
    if (!ProcessorClass) {
      throw new Error(`Unknown processor type: ${type}`);
    }
    
    return new ProcessorClass();
  }
}

// Usage - Client only knows about the factory
function processPayment(type, amount) {
  const processor = PaymentProcessorFactory.create(type);
  return processor.process(amount);
}

processPayment('credit', 100);  // Processing $100 via Credit Card
processPayment('paypal', 50);   // Processing $50 via PayPal
processPayment('crypto', 200);  // Processing $200 via Crypto
```

### Diagram: Simple Factory

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     SIMPLE FACTORY                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚    Client                                                   â”‚
â”‚      â”‚                                                      â”‚
â”‚      â”‚ create('credit')                                     â”‚
â”‚      â–¼                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚  â”‚   PaymentProcessorFactory     â”‚                          â”‚
â”‚  â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚                          â”‚
â”‚  â”‚   static create(type)         â”‚                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                  â”‚                                          â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚       â–¼          â–¼          â–¼                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚  â”‚ Credit  â”‚ â”‚ PayPal  â”‚ â”‚ Crypto  â”‚                        â”‚
â”‚  â”‚ Card    â”‚ â”‚Processorâ”‚ â”‚Processorâ”‚                        â”‚
â”‚  â”‚Processorâ”‚ â”‚         â”‚ â”‚         â”‚                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Use Cases for Simple Factory

1. **UI Component Creation**
```javascript
class UIFactory {
  static createButton(type) {
    switch (type) {
      case 'primary': return new PrimaryButton();
      case 'secondary': return new SecondaryButton();
      case 'danger': return new DangerButton();
      default: return new DefaultButton();
    }
  }
  
  static createInput(type) {
    switch (type) {
      case 'text': return new TextInput();
      case 'password': return new PasswordInput();
      case 'email': return new EmailInput();
      default: return new TextInput();
    }
  }
}
```

2. **Notification Services**
```javascript
class NotificationFactory {
  static create(channel, message) {
    const notifiers = {
      email: () => new EmailNotifier(message),
      sms: () => new SMSNotifier(message),
      push: () => new PushNotifier(message),
      slack: () => new SlackNotifier(message)
    };
    
    return notifiers[channel]?.() ?? new EmailNotifier(message);
  }
}
```

---

## 4.2 Factory Method Pattern

### Concept

The Factory Method defines an **interface for creating objects**, but lets **subclasses decide** which class to instantiate. It's more flexible than Simple Factory.

### Key Difference from Simple Factory

| Aspect | Simple Factory | Factory Method |
|--------|---------------|----------------|
| Extension | Modify factory code | Create new subclass |
| Open/Closed | Violates (modify to extend) | Follows (extend without modify) |
| Complexity | Lower | Higher |
| Use when | Few product types | Many/dynamic product types |

### Implementation

```javascript
// Abstract Product
class Document {
  constructor(name) {
    this.name = name;
  }
  
  open() { throw new Error('Must implement open()'); }
  save() { throw new Error('Must implement save()'); }
  close() { throw new Error('Must implement close()'); }
}

// Concrete Products
class PDFDocument extends Document {
  open() {
    console.log(`Opening PDF: ${this.name}`);
    return this;
  }
  
  save() {
    console.log(`Saving PDF: ${this.name}`);
    return this;
  }
  
  close() {
    console.log(`Closing PDF: ${this.name}`);
    return this;
  }
  
  addPage() {
    console.log('Adding new PDF page');
    return this;
  }
}

class WordDocument extends Document {
  open() {
    console.log(`Opening Word Doc: ${this.name}`);
    return this;
  }
  
  save() {
    console.log(`Saving Word Doc: ${this.name}`);
    return this;
  }
  
  close() {
    console.log(`Closing Word Doc: ${this.name}`);
    return this;
  }
  
  checkSpelling() {
    console.log('Running spell check');
    return this;
  }
}

class SpreadsheetDocument extends Document {
  open() {
    console.log(`Opening Spreadsheet: ${this.name}`);
    return this;
  }
  
  save() {
    console.log(`Saving Spreadsheet: ${this.name}`);
    return this;
  }
  
  close() {
    console.log(`Closing Spreadsheet: ${this.name}`);
    return this;
  }
  
  calculateFormulas() {
    console.log('Calculating formulas');
    return this;
  }
}

// Abstract Creator (Factory)
class Application {
  constructor() {
    this.documents = [];
  }
  
  // Factory Method - subclasses override this
  createDocument(name) {
    throw new Error('Subclass must implement createDocument()');
  }
  
  // Template method using the factory
  newDocument(name) {
    const doc = this.createDocument(name);
    this.documents.push(doc);
    doc.open();
    return doc;
  }
  
  openDocument(name) {
    const doc = this.createDocument(name);
    doc.open();
    return doc;
  }
}

// Concrete Creators
class PDFApplication extends Application {
  createDocument(name) {
    return new PDFDocument(name);
  }
}

class WordApplication extends Application {
  createDocument(name) {
    return new WordDocument(name);
  }
}

class SpreadsheetApplication extends Application {
  createDocument(name) {
    return new SpreadsheetDocument(name);
  }
}

// Usage
const pdfApp = new PDFApplication();
const doc1 = pdfApp.newDocument('report.pdf');
doc1.addPage().save().close();

const wordApp = new WordApplication();
const doc2 = wordApp.newDocument('letter.docx');
doc2.checkSpelling().save().close();

const excelApp = new SpreadsheetApplication();
const doc3 = excelApp.newDocument('budget.xlsx');
doc3.calculateFormulas().save().close();
```

### Diagram: Factory Method

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FACTORY METHOD                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚   Application       â”‚         â”‚     Document        â”‚    â”‚
â”‚  â”‚   (Abstract Creator)â”‚         â”‚  (Abstract Product) â”‚    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚  â”‚ createDocument()    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ open()              â”‚    â”‚
â”‚  â”‚ newDocument()       â”‚ creates â”‚ save()              â”‚    â”‚
â”‚  â”‚ openDocument()      â”‚         â”‚ close()             â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚             â”‚                               â”‚               â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”         â”‚
â”‚       â–¼           â–¼                   â–¼           â–¼         â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚PDFApp     â”‚ â”‚WordApp    â”‚    â”‚PDFDocumentâ”‚ â”‚WordDocumentâ”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚ â”‚createDoc()â”‚ â”‚createDoc()â”‚    â”‚open()     â”‚ â”‚open()     â”‚  â”‚
â”‚ â”‚returns PDFâ”‚ â”‚returns Word    â”‚save()     â”‚ â”‚save()     â”‚  â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚addPage()  â”‚ â”‚spellCheck()â”‚ â”‚
â”‚                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Real-World Example: Cross-Platform UI

```javascript
// Abstract UI Elements
class Button {
  render() { throw new Error('Must implement'); }
  onClick(handler) { throw new Error('Must implement'); }
}

class TextInput {
  render() { throw new Error('Must implement'); }
  getValue() { throw new Error('Must implement'); }
}

// iOS Implementations
class IOSButton extends Button {
  render() {
    return '<UIButton style="ios-native">Click</UIButton>';
  }
  onClick(handler) {
    console.log('iOS button tap handler attached');
  }
}

class IOSTextInput extends TextInput {
  render() {
    return '<UITextField style="ios-native" />';
  }
  getValue() {
    return 'iOS input value';
  }
}

// Android Implementations
class AndroidButton extends Button {
  render() {
    return '<Button android:style="material">Click</Button>';
  }
  onClick(handler) {
    console.log('Android button click handler attached');
  }
}

class AndroidTextInput extends TextInput {
  render() {
    return '<EditText android:style="material" />';
  }
  getValue() {
    return 'Android input value';
  }
}

// Factory Method Implementation
class UIFactory {
  createButton() { throw new Error('Must implement'); }
  createTextInput() { throw new Error('Must implement'); }
  
  // Template method for creating login form
  createLoginForm() {
    const button = this.createButton();
    const usernameInput = this.createTextInput();
    const passwordInput = this.createTextInput();
    
    return {
      render() {
        return `
          <form>
            ${usernameInput.render()}
            ${passwordInput.render()}
            ${button.render()}
          </form>
        `;
      }
    };
  }
}

class IOSUIFactory extends UIFactory {
  createButton() { return new IOSButton(); }
  createTextInput() { return new IOSTextInput(); }
}

class AndroidUIFactory extends UIFactory {
  createButton() { return new AndroidButton(); }
  createTextInput() { return new AndroidTextInput(); }
}

// Usage based on platform
function getUIFactory(platform) {
  const factories = {
    ios: IOSUIFactory,
    android: AndroidUIFactory
  };
  
  const Factory = factories[platform];
  if (!Factory) throw new Error(`Unsupported platform: ${platform}`);
  return new Factory();
}

const platform = 'ios'; // Could be detected at runtime
const factory = getUIFactory(platform);
const loginForm = factory.createLoginForm();
console.log(loginForm.render());
```

---

## 4.3 Abstract Factory Pattern

### Concept

The Abstract Factory provides an interface for creating **families of related objects** without specifying their concrete classes.

### When to Use

- Creating **related/dependent objects** together
- Supporting **multiple themes/platforms**
- Ensuring **consistency** across object families

### Implementation

```javascript
// Abstract Products
class Chair {
  sitOn() { throw new Error('Must implement'); }
  getStyle() { throw new Error('Must implement'); }
}

class Sofa {
  lieOn() { throw new Error('Must implement'); }
  getStyle() { throw new Error('Must implement'); }
}

class CoffeeTable {
  placeItems() { throw new Error('Must implement'); }
  getStyle() { throw new Error('Must implement'); }
}

// Victorian Furniture Family
class VictorianChair extends Chair {
  sitOn() { return 'Sitting on ornate Victorian chair'; }
  getStyle() { return 'Victorian'; }
}

class VictorianSofa extends Sofa {
  lieOn() { return 'Lying on elegant Victorian sofa'; }
  getStyle() { return 'Victorian'; }
}

class VictorianCoffeeTable extends CoffeeTable {
  placeItems() { return 'Placing items on carved Victorian table'; }
  getStyle() { return 'Victorian'; }
}

// Modern Furniture Family
class ModernChair extends Chair {
  sitOn() { return 'Sitting on minimalist modern chair'; }
  getStyle() { return 'Modern'; }
}

class ModernSofa extends Sofa {
  lieOn() { return 'Lying on sleek modern sofa'; }
  getStyle() { return 'Modern'; }
}

class ModernCoffeeTable extends CoffeeTable {
  placeItems() { return 'Placing items on glass modern table'; }
  getStyle() { return 'Modern'; }
}

// Industrial Furniture Family
class IndustrialChair extends Chair {
  sitOn() { return 'Sitting on metal industrial chair'; }
  getStyle() { return 'Industrial'; }
}

class IndustrialSofa extends Sofa {
  lieOn() { return 'Lying on leather industrial sofa'; }
  getStyle() { return 'Industrial'; }
}

class IndustrialCoffeeTable extends CoffeeTable {
  placeItems() { return 'Placing items on reclaimed wood table'; }
  getStyle() { return 'Industrial'; }
}

// Abstract Factory
class FurnitureFactory {
  createChair() { throw new Error('Must implement'); }
  createSofa() { throw new Error('Must implement'); }
  createCoffeeTable() { throw new Error('Must implement'); }
  
  // Convenience method to create a set
  createLivingRoomSet() {
    return {
      chair: this.createChair(),
      sofa: this.createSofa(),
      table: this.createCoffeeTable()
    };
  }
}

// Concrete Factories
class VictorianFurnitureFactory extends FurnitureFactory {
  createChair() { return new VictorianChair(); }
  createSofa() { return new VictorianSofa(); }
  createCoffeeTable() { return new VictorianCoffeeTable(); }
}

class ModernFurnitureFactory extends FurnitureFactory {
  createChair() { return new ModernChair(); }
  createSofa() { return new ModernSofa(); }
  createCoffeeTable() { return new ModernCoffeeTable(); }
}

class IndustrialFurnitureFactory extends FurnitureFactory {
  createChair() { return new IndustrialChair(); }
  createSofa() { return new IndustrialSofa(); }
  createCoffeeTable() { return new IndustrialCoffeeTable(); }
}

// Factory Provider
function getFurnitureFactory(style) {
  const factories = {
    victorian: VictorianFurnitureFactory,
    modern: ModernFurnitureFactory,
    industrial: IndustrialFurnitureFactory
  };
  
  const Factory = factories[style.toLowerCase()];
  if (!Factory) throw new Error(`Unknown style: ${style}`);
  return new Factory();
}

// Client code - completely decoupled from concrete classes
function furnishRoom(style) {
  const factory = getFurnitureFactory(style);
  const { chair, sofa, table } = factory.createLivingRoomSet();
  
  console.log(`\n=== ${style.toUpperCase()} Living Room ===`);
  console.log(chair.sitOn());
  console.log(sofa.lieOn());
  console.log(table.placeItems());
  console.log(`All items are: ${chair.getStyle()} style`);
}

// Usage
furnishRoom('victorian');
furnishRoom('modern');
furnishRoom('industrial');
```

### Diagram: Abstract Factory

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ABSTRACT FACTORY                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                   FurnitureFactory                        â”‚  â”‚
â”‚  â”‚               (Abstract Factory)                          â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚  + createChair(): Chair                                   â”‚  â”‚
â”‚  â”‚  + createSofa(): Sofa                                     â”‚  â”‚
â”‚  â”‚  + createCoffeeTable(): CoffeeTable                       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                             â”‚                                   â”‚
â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚          â–¼                  â–¼                  â–¼                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ Victorian     â”‚  â”‚ Modern        â”‚  â”‚ Industrial    â”‚        â”‚
â”‚  â”‚ Factory       â”‚  â”‚ Factory       â”‚  â”‚ Factory       â”‚        â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤        â”‚
â”‚  â”‚Creates:       â”‚  â”‚Creates:       â”‚  â”‚Creates:       â”‚        â”‚
â”‚  â”‚â€¢ VictChair    â”‚  â”‚â€¢ ModernChair  â”‚  â”‚â€¢ IndusChair   â”‚        â”‚
â”‚  â”‚â€¢ VictSofa     â”‚  â”‚â€¢ ModernSofa   â”‚  â”‚â€¢ IndusSofa    â”‚        â”‚
â”‚  â”‚â€¢ VictTable    â”‚  â”‚â€¢ ModernTable  â”‚  â”‚â€¢ IndusTable   â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                                 â”‚
â”‚  PRODUCT FAMILIES:                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Victorian  â”‚  VictorianChair  VictorianSofa  VictorianTableâ”‚  â”‚
â”‚  â”‚ Modern     â”‚  ModernChair     ModernSofa     ModernTable   â”‚  â”‚
â”‚  â”‚ Industrial â”‚  IndustrialChair IndustrialSofa IndustrialTableâ”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4.4 JavaScript-Specific Factory Patterns

### Functional Factory (No Classes)

```javascript
// Pure functional approach - very JavaScript-ish
const createUser = (name, role) => {
  // Private data via closure
  let loginCount = 0;
  
  return {
    name,
    role,
    login() {
      loginCount++;
      console.log(`${name} logged in (${loginCount} times)`);
    },
    getLoginCount() {
      return loginCount;
    }
  };
};

const admin = createUser('Alice', 'admin');
const user = createUser('Bob', 'user');

admin.login(); // Alice logged in (1 times)
admin.login(); // Alice logged in (2 times)
console.log(admin.getLoginCount()); // 2
console.log(admin.loginCount); // undefined - private!
```

### Factory with Registration

```javascript
class ShapeFactory {
  static #shapes = new Map();
  
  static register(name, creator) {
    this.#shapes.set(name, creator);
  }
  
  static create(name, ...args) {
    const creator = this.#shapes.get(name);
    if (!creator) {
      throw new Error(`Unknown shape: ${name}`);
    }
    return creator(...args);
  }
  
  static getRegisteredShapes() {
    return [...this.#shapes.keys()];
  }
}

// Register shapes - can be done dynamically
ShapeFactory.register('circle', (radius) => ({
  type: 'circle',
  radius,
  area: () => Math.PI * radius ** 2
}));

ShapeFactory.register('rectangle', (width, height) => ({
  type: 'rectangle',
  width,
  height,
  area: () => width * height
}));

ShapeFactory.register('triangle', (base, height) => ({
  type: 'triangle',
  base,
  height,
  area: () => 0.5 * base * height
}));

// Usage
const circle = ShapeFactory.create('circle', 5);
const rect = ShapeFactory.create('rectangle', 4, 6);

console.log(circle.area()); // 78.54...
console.log(rect.area());   // 24

console.log(ShapeFactory.getRegisteredShapes()); // ['circle', 'rectangle', 'triangle']
```

### Async Factory

```javascript
class AsyncResourceFactory {
  static async create(type, config) {
    console.log(`Creating ${type} resource...`);
    
    // Simulate async initialization
    await new Promise(resolve => setTimeout(resolve, 100));
    
    switch (type) {
      case 'database':
        return this.#createDatabase(config);
      case 'cache':
        return this.#createCache(config);
      case 'queue':
        return this.#createQueue(config);
      default:
        throw new Error(`Unknown resource: ${type}`);
    }
  }
  
  static async #createDatabase(config) {
    // Simulate connection
    await new Promise(resolve => setTimeout(resolve, 200));
    return {
      type: 'database',
      connected: true,
      query: async (sql) => console.log(`Executing: ${sql}`)
    };
  }
  
  static async #createCache(config) {
    return {
      type: 'cache',
      data: new Map(),
      get: (key) => this.data.get(key),
      set: (key, value) => this.data.set(key, value)
    };
  }
  
  static async #createQueue(config) {
    return {
      type: 'queue',
      items: [],
      push: (item) => this.items.push(item),
      pop: () => this.items.shift()
    };
  }
}

// Usage with async/await
async function initializeApp() {
  const db = await AsyncResourceFactory.create('database', { host: 'localhost' });
  const cache = await AsyncResourceFactory.create('cache', { size: 100 });
  
  await db.query('SELECT * FROM users');
  cache.set('key', 'value');
  
  return { db, cache };
}

initializeApp().then(console.log);
```

---

## 4.5 Factory vs Constructor: When to Use What

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              FACTORY vs CONSTRUCTOR DECISION                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  USE CONSTRUCTOR WHEN:            USE FACTORY WHEN:         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”‚
â”‚  â€¢ Simple object creation         â€¢ Complex creation logic  â”‚
â”‚  â€¢ Always same type               â€¢ Different types/variantsâ”‚
â”‚  â€¢ No pre/post processing         â€¢ Need validation/caching â”‚
â”‚  â€¢ Instance needed immediately    â€¢ Async initialization    â”‚
â”‚  â€¢ Clear, single responsibility   â€¢ Creation logic may changeâ”‚
â”‚                                                             â”‚
â”‚  class User {                     function createUser(data) â”‚
â”‚    constructor(name) {              // Validate             â”‚
â”‚      this.name = name;              // Transform            â”‚
â”‚    }                                // Decide type          â”‚
â”‚  }                                  // Return instance      â”‚
â”‚                                   }                         â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Key Takeaways

1. **Simple Factory**: Centralizes creation logic, good for simple cases
2. **Factory Method**: Lets subclasses decide what to create, extensible
3. **Abstract Factory**: Creates families of related objects, ensures consistency
4. **In JavaScript**: Functional factories often simpler than class-based
5. **Use factories** when creation logic is complex or may return different types
6. **Consider async factories** for resources requiring initialization

> ğŸ’¡ **Interview Tip:** Be ready to explain:
> - The difference between Simple Factory, Factory Method, and Abstract Factory
> - When to use Factory vs Constructor
> - How JavaScript's dynamic nature affects factory implementation
