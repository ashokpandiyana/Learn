# Chapter 35: Micro-Frontend Pattern - Complete Guide

## ğŸ“š What are Micro-Frontends?

Micro-Frontends extend the microservices concept to the frontend. Instead of building one monolithic frontend application, you **split it into smaller, independently deployable pieces**, each owned by different teams.

### The Big Idea
```
Monolithic Frontend â†’ Multiple Mini-Frontends
(One giant app)       (Many small apps working together)
```

Think of it like building with LEGO blocks instead of carving from a single piece of stone.

## ğŸ¯ Core Principles

### 1. **Technology Agnostic**
Teams can choose different frameworks (React, Vue, Angular, Svelte) for their micro-frontend.

### 2. **Team Autonomy**
Each team owns a complete vertical slice: UI, API, database.

### 3. **Independent Deployment**
Deploy one micro-frontend without touching others.

### 4. **Isolated State**
Each micro-frontend manages its own state.

### 5. **Native Communication**
Micro-frontends communicate via events or custom APIs.

## ğŸ—ï¸ Architecture Patterns

### The Three Main Approaches

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Browser/Container               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚  Header  â”‚  â”‚  Content â”‚  â”‚Sidebar â”‚â”‚
â”‚  â”‚ (Team A) â”‚  â”‚ (Team B) â”‚  â”‚(Team C)â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» Implementation Approaches

### 1. Build-Time Integration (Simple but Limited)

Components are combined during the build process using npm packages.

```javascript
// package.json
{
  "dependencies": {
    "@company/header": "^1.0.0",
    "@company/footer": "^1.0.0",
    "@company/product-list": "^2.3.0"
  }
}

// main.js
import Header from '@company/header';
import Footer from '@company/footer';
import ProductList from '@company/product-list';

function App() {
  return (
    <div>
      <Header />
      <ProductList />
      <Footer />
    </div>
  );
}
```

**Pros:**
- Simple to implement
- Type safety
- Easy local development

**Cons:**
- Not truly independent (must redeploy all)
- Version conflicts
- Large bundle sizes

---

### 2. Run-Time Integration via JavaScript

Load micro-frontends dynamically at runtime.

#### A. Single-SPA Framework

```javascript
// root-config.js
import { registerApplication, start } from 'single-spa';

// Register micro-frontends
registerApplication({
  name: '@company/header',
  app: () => System.import('@company/header'),
  activeWhen: '/' // Always active
});

registerApplication({
  name: '@company/products',
  app: () => System.import('@company/products'),
  activeWhen: '/products'
});

registerApplication({
  name: '@company/checkout',
  app: () => System.import('@company/checkout'),
  activeWhen: '/checkout'
});

start();
```

```javascript
// Product micro-frontend (React)
import React from 'react';
import ReactDOM from 'react-dom';
import singleSpaReact from 'single-spa-react';
import ProductApp from './ProductApp';

const lifecycles = singleSpaReact({
  React,
  ReactDOM,
  rootComponent: ProductApp,
  errorBoundary(err, info, props) {
    return <div>Error loading products</div>;
  }
});

export const { bootstrap, mount, unmount } = lifecycles;
```

```javascript
// Checkout micro-frontend (Vue)
import Vue from 'vue';
import singleSpaVue from 'single-spa-vue';
import CheckoutApp from './CheckoutApp.vue';

const vueLifecycles = singleSpaVue({
  Vue,
  appOptions: {
    render: h => h(CheckoutApp)
  }
});

export const { bootstrap, mount, unmount } = vueLifecycles;
```

#### B. Module Federation (Webpack 5)

The game-changer for micro-frontends!

```javascript
// Header micro-frontend (webpack.config.js)
const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'header',
      filename: 'remoteEntry.js',
      exposes: {
        './Header': './src/Header'
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true }
      }
    })
  ]
};

// Products micro-frontend (webpack.config.js)
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'products',
      filename: 'remoteEntry.js',
      exposes: {
        './ProductList': './src/ProductList',
        './ProductDetail': './src/ProductDetail'
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true }
      }
    })
  ]
};

// Container app (webpack.config.js)
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'container',
      remotes: {
        header: 'header@http://localhost:3001/remoteEntry.js',
        products: 'products@http://localhost:3002/remoteEntry.js'
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true }
      }
    })
  ]
};

// Container app usage
import React, { lazy, Suspense } from 'react';

const Header = lazy(() => import('header/Header'));
const ProductList = lazy(() => import('products/ProductList'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <Header />
        <ProductList />
      </Suspense>
    </div>
  );
}
```

---

### 3. Server-Side Composition (SSR)

Compose micro-frontends on the server before sending to client.

```javascript
// Using Server-Side Includes (SSI)
// nginx.conf
server {
  location /products {
    ssi on;
    proxy_pass http://products-service;
  }
}

// products.html
<!DOCTYPE html>
<html>
  <body>
    <!--#include virtual="/header" -->
    <div id="product-content">
      <!-- Product content here -->
    </div>
    <!--#include virtual="/footer" -->
  </body>
</html>
```

```javascript
// Using Podium (Node.js framework)
const Podium = require('@podium/podium');
const podlet = new Podium.Podlet({
  name: 'products',
  version: '1.0.0',
  pathname: '/'
});

app.get(podlet.content(), (req, res) => {
  res.podiumSend(`
    <div id="products">
      <h2>Products</h2>
      <!-- Products HTML -->
    </div>
  `);
});

// Layout (container)
const layout = new Podium.Layout({
  name: 'main',
  pathname: '/'
});

const headerClient = layout.client.register({
  name: 'header',
  uri: 'http://header-service/manifest.json'
});

const productsClient = layout.client.register({
  name: 'products',
  uri: 'http://products-service/manifest.json'
});

app.get('/', async (req, res) => {
  const [header, products] = await Promise.all([
    headerClient.fetch(res.locals.podium),
    productsClient.fetch(res.locals.podium)
  ]);

  res.send(`
    <!DOCTYPE html>
    <html>
      <head>${header.css}</head>
      <body>
        ${header.content}
        ${products.content}
        ${header.js}
        ${products.js}
      </body>
    </html>
  `);
});
```

---

### 4. Web Components (Framework Agnostic)

Use native Web Components for true framework independence.

```javascript
// Header micro-frontend (Custom Element)
class HeaderElement extends HTMLElement {
  connectedCallback() {
    this.innerHTML = `
      <header>
        <nav>
          <a href="/">Home</a>
          <a href="/products">Products</a>
          <a href="/cart">Cart (<span id="cart-count">0</span>)</a>
        </nav>
      </header>
    `;

    // Listen for cart updates
    window.addEventListener('cart-updated', (e) => {
      document.getElementById('cart-count').textContent = e.detail.count;
    });
  }
}

customElements.define('app-header', HeaderElement);

// Products micro-frontend (React + Web Component wrapper)
import React from 'react';
import ReactDOM from 'react-dom';
import ProductApp from './ProductApp';

class ProductsElement extends HTMLElement {
  connectedCallback() {
    const mountPoint = document.createElement('div');
    this.appendChild(mountPoint);
    ReactDOM.render(<ProductApp />, mountPoint);
  }

  disconnectedCallback() {
    ReactDOM.unmountComponentAtNode(this);
  }
}

customElements.define('app-products', ProductsElement);

// Cart micro-frontend (Vue + Web Component)
import Vue from 'vue';
import CartApp from './CartApp.vue';
import wrap from '@vue/web-component-wrapper';

const CartElement = wrap(Vue, CartApp);
customElements.define('app-cart', CartElement);

// Container HTML
<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.header.com/header.js"></script>
    <script src="https://cdn.products.com/products.js"></script>
    <script src="https://cdn.cart.com/cart.js"></script>
  </head>
  <body>
    <app-header></app-header>
    <app-products></app-products>
    <app-cart></app-cart>
  </body>
</html>
```

---

### 5. IFrame Integration (Old but Gold)

The simplest approach, but with limitations.

```html
<!-- Container -->
<!DOCTYPE html>
<html>
  <head>
    <style>
      iframe {
        width: 100%;
        border: none;
      }
      #header-frame { height: 80px; }
      #products-frame { height: 600px; }
      #footer-frame { height: 100px; }
    </style>
  </head>
  <body>
    <iframe id="header-frame" src="https://header.company.com"></iframe>
    <iframe id="products-frame" src="https://products.company.com"></iframe>
    <iframe id="footer-frame" src="https://footer.company.com"></iframe>

    <script>
      // Communication via postMessage
      window.addEventListener('message', (event) => {
        if (event.origin !== 'https://products.company.com') return;
        
        if (event.data.type === 'ADD_TO_CART') {
          // Notify other iframes
          document.getElementById('header-frame')
            .contentWindow.postMessage({
              type: 'CART_UPDATED',
              count: event.data.count
            }, '*');
        }
      });
    </script>
  </body>
</html>
```

**Pros:**
- Complete isolation
- No dependency conflicts
- Works with any framework

**Cons:**
- Poor performance (many HTTP requests)
- Difficult styling across boundaries
- Complex communication
- Bad for SEO

---

## ğŸ”„ Communication Between Micro-Frontends

### 1. Custom Events (Recommended)

```javascript
// Event bus
class MicroFrontendEventBus {
  static dispatch(eventName, detail) {
    window.dispatchEvent(new CustomEvent(eventName, { detail }));
  }

  static listen(eventName, callback) {
    window.addEventListener(eventName, (e) => callback(e.detail));
  }

  static unlisten(eventName, callback) {
    window.removeEventListener(eventName, callback);
  }
}

// Products micro-frontend (publishes)
function addToCart(product) {
  cart.add(product);
  MicroFrontendEventBus.dispatch('product:added-to-cart', {
    product,
    cartCount: cart.count
  });
}

// Header micro-frontend (subscribes)
MicroFrontendEventBus.listen('product:added-to-cart', (data) => {
  updateCartBadge(data.cartCount);
});

// Cart micro-frontend (subscribes)
MicroFrontendEventBus.listen('product:added-to-cart', (data) => {
  refreshCartItems();
});
```

### 2. Shared State Store

```javascript
// Shared store (published as separate package)
class SharedStore {
  constructor() {
    this.state = {};
    this.subscribers = new Map();
  }

  getState(key) {
    return this.state[key];
  }

  setState(key, value) {
    this.state[key] = value;
    this.notify(key, value);
  }

  subscribe(key, callback) {
    if (!this.subscribers.has(key)) {
      this.subscribers.set(key, []);
    }
    this.subscribers.get(key).push(callback);

    // Return unsubscribe function
    return () => {
      const callbacks = this.subscribers.get(key);
      const index = callbacks.indexOf(callback);
      if (index > -1) callbacks.splice(index, 1);
    };
  }

  notify(key, value) {
    const callbacks = this.subscribers.get(key) || [];
    callbacks.forEach(callback => callback(value));
  }
}

// Create singleton instance
window.__SHARED_STORE__ = window.__SHARED_STORE__ || new SharedStore();

// Usage in Products micro-frontend
const store = window.__SHARED_STORE__;

function addToCart(product) {
  const cart = store.getState('cart') || [];
  cart.push(product);
  store.setState('cart', cart);
}

// Usage in Header micro-frontend
const store = window.__SHARED_STORE__;

store.subscribe('cart', (cart) => {
  updateCartCount(cart.length);
});
```

### 3. Props and Callbacks (for nested micro-frontends)

```javascript
// Container passes props to micro-frontends
function Container() {
  const [user, setUser] = useState(null);

  return (
    <div>
      <Header user={user} onLogout={() => setUser(null)} />
      <Products userId={user?.id} />
    </div>
  );
}
```

---

## ğŸ¨ Styling Strategies

### 1. CSS Modules / Scoped CSS

```javascript
// Each micro-frontend uses unique prefixes
// Header
.header__nav { /* styles */ }
.header__logo { /* styles */ }

// Products
.products__grid { /* styles */ }
.products__item { /* styles */ }
```

### 2. Shadow DOM (with Web Components)

```javascript
class IsolatedComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <style>
        /* Styles are completely isolated! */
        .button { color: red; }
      </style>
      <button class="button">Click Me</button>
    `;
  }
}
```

### 3. CSS-in-JS with Unique Namespaces

```javascript
// Use styled-components with prefixes
import styled from 'styled-components';

const Button = styled.button`
  /* Generates unique class names automatically */
  color: blue;
`;
```

---

## ğŸ§ª Complete Example: E-Commerce Platform

### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Container App                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Header (Team A - React)               â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Navigation  â”‚  â”‚  Product Catalog     â”‚ â”‚
â”‚  â”‚  (Team A)    â”‚  â”‚  (Team B - Vue)      â”‚ â”‚
â”‚  â”‚  React       â”‚  â”‚                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Shopping Cart (Team C - Svelte)       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Footer (Team A - React)               â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Implementation

```javascript
// Container (Module Federation)
import React, { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

const Header = lazy(() => import('header/Header'));
const Navigation = lazy(() => import('header/Navigation'));
const ProductCatalog = lazy(() => import('products/Catalog'));
const ProductDetail = lazy(() => import('products/Detail'));
const Cart = lazy(() => import('cart/Cart'));
const Checkout = lazy(() => import('cart/Checkout'));
const Footer = lazy(() => import('header/Footer'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<div>Loading...</div>}>
        <Header />
        <Navigation />
        
        <Routes>
          <Route path="/" element={<ProductCatalog />} />
          <Route path="/products/:id" element={<ProductDetail />} />
          <Route path="/cart" element={<Cart />} />
          <Route path="/checkout" element={<Checkout />} />
        </Routes>

        <Footer />
      </Suspense>
    </BrowserRouter>
  );
}
```

---

## ğŸ“Š Comparison of Approaches

| Approach | Independence | Performance | Complexity | Team Autonomy |
|----------|--------------|-------------|------------|---------------|
| Build-time | â­ | â­â­â­â­â­ | â­â­ | â­â­ |
| Single-SPA | â­â­â­â­ | â­â­â­â­ | â­â­â­ | â­â­â­â­ |
| Module Federation | â­â­â­â­â­ | â­â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |
| SSR | â­â­â­â­ | â­â­â­ | â­â­â­â­ | â­â­â­â­ |
| Web Components | â­â­â­â­â­ | â­â­â­ | â­â­â­ | â­â­â­â­â­ |
| IFrames | â­â­â­â­â­ | â­ | â­â­ | â­â­â­â­â­ |

---

## ğŸ¯ Best Practices

### âœ… DO:
- Define clear boundaries between micro-frontends
- Use shared design system for consistency
- Implement robust error boundaries
- Version your micro-frontends
- Monitor performance across boundaries
- Use feature flags for gradual rollouts
- Implement proper authentication/authorization
- Cache shared dependencies

### âŒ DON'T:
- Share state excessively (prefer events)
- Create too many micro-frontends (overhead)
- Ignore performance implications
- Skip integration testing
- Forget about accessibility
- Over-engineer for small teams
- Ignore backward compatibility

---

## ğŸš€ When to Use Micro-Frontends

### âœ… **Use When:**
- Large teams working on same product
- Different teams own different features
- Need independent deployment
- Mix of old and new tech stacks
- Scaling development across teams

### âŒ **Don't Use When:**
- Small team (< 10 developers)
- Simple application
- Tight coupling between features
- Performance is critical (every millisecond counts)
- Limited ops/DevOps capacity

---

## ğŸ”‘ Key Takeaways

1. **Multiple Approaches**: Build-time, runtime, SSR, Web Components, iframes
2. **Module Federation**: The most modern and flexible approach
3. **Independence**: Each micro-frontend can be developed and deployed separately
4. **Communication**: Use custom events or shared stores
5. **Styling**: Scope styles or use Shadow DOM
6. **Team Autonomy**: Different teams can use different tech stacks
7. **Complexity Trade-off**: More flexibility comes with more complexity

Micro-frontends are powerful but not a silver bullet. Use them when the benefits (team autonomy, independent deployment) outweigh the costs (complexity, performance overhead)!