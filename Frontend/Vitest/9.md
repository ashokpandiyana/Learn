# Chapter 9: Performance & Optimization - Complete Guide

## 9.1 Test Execution Speed

### Understanding Test Performance

```
Test Suite Performance Goals:
┌────────────────────────────────────────┐
│ Test Type    │ Target Time │ Actual    │
├────────────────────────────────────────┤
│ Unit         │ < 10ms      │ ⚡ 5ms    │
│ Integration  │ < 500ms     │ ⚡ 200ms  │
│ E2E          │ < 30s       │ ⚠️  45s    │
├────────────────────────────────────────┤
│ Total Suite  │ < 5 min     │ ⚠️  8min   │
└────────────────────────────────────────┘

Goal: Keep fast feedback loop
Unit tests should be nearly instant
```

### Measuring Test Performance

```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    // Use verbose reporter to see timing
    reporters: ['verbose'],
    
    // Set slow test threshold
    slowTestThreshold: 1000, // 1 second
    
    // Log heap usage
    logHeapUsage: true
  }
})
```

```bash
# Run with timing information
vitest --reporter=verbose

# Output:
# ✓ src/utils/math.test.ts (4) 12ms
#   ✓ add function (2ms)
#   ✓ subtract function (1ms)
#   ✓ multiply function (8ms) ⚠️ SLOW
#   ✓ divide function (1ms)
```

### Identifying Slow Tests

```typescript
// test/performance-monitor.ts
import { beforeEach, afterEach } from 'vitest'

let testStartTime: number

beforeEach(() => {
  testStartTime = performance.now()
})

afterEach((context) => {
  const duration = performance.now() - testStartTime
  
  if (duration > 100) {
    console.warn(
      `⚠️ Slow test: "${context.task.name}" took ${duration.toFixed(2)}ms`
    )
  }
})
```

### Common Performance Issues

```typescript
// ❌ SLOW - Creating expensive objects in loop
describe('Data processing', () => {
  it('should process items', () => {
    for (let i = 0; i < 1000; i++) {
      const processor = new ExpensiveProcessor() // Created 1000 times!
      processor.process(data[i])
    }
  })
})

// ✅ FAST - Reuse object
describe('Data processing', () => {
  it('should process items', () => {
    const processor = new ExpensiveProcessor() // Created once
    
    for (let i = 0; i < 1000; i++) {
      processor.process(data[i])
    }
  })
})

// ❌ SLOW - Unnecessary async/await
describe('Sync operations', () => {
  it('should calculate total', async () => {
    const result = await calculateTotal([1, 2, 3]) // Unnecessary await
    expect(result).toBe(6)
  })
})

// ✅ FAST - Remove unnecessary async
describe('Sync operations', () => {
  it('should calculate total', () => {
    const result = calculateTotal([1, 2, 3])
    expect(result).toBe(6)
  })
})

// ❌ SLOW - Reading files in each test
describe('Config tests', () => {
  it('should parse config', () => {
    const config = fs.readFileSync('config.json') // Slow I/O
    // test config
  })
  
  it('should validate config', () => {
    const config = fs.readFileSync('config.json') // Slow I/O again
    // test validation
  })
})

// ✅ FAST - Read once in beforeAll
describe('Config tests', () => {
  let config: Config
  
  beforeAll(() => {
    config = fs.readFileSync('config.json') // Read once
  })
  
  it('should parse config', () => {
    // Use cached config
  })
  
  it('should validate config', () => {
    // Use cached config
  })
})
```

---

## 9.2 Parallel Execution

### Understanding Thread Pools

```
Sequential Execution:
Test 1 ──────► Test 2 ──────► Test 3 ──────► Test 4
(100ms)        (100ms)        (100ms)        (100ms)
Total: 400ms

Parallel Execution (4 threads):
Test 1 ──────►
Test 2 ──────►  } Running simultaneously
Test 3 ──────►
Test 4 ──────►
Total: ~100ms
```

### Configuring Parallel Execution

```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    // ═══════════════════════════════════════
    // THREAD CONFIGURATION
    // ═══════════════════════════════════════
    
    // Enable threading (default: true)
    threads: true,
    
    // Maximum concurrent threads
    maxThreads: 8,
    
    // Minimum threads (always active)
    minThreads: 1,
    
    // Maximum concurrent test files
    maxConcurrency: 5,
    
    // ═══════════════════════════════════════
    // POOL OPTIONS
    // ═══════════════════════════════════════
    
    // Pool type: 'threads' | 'forks' | 'vmThreads'
    pool: 'threads',
    
    poolOptions: {
      threads: {
        // Run in single thread (for debugging)
        singleThread: false,
        
        // Isolate each test file
        isolate: true,
        
        // Use worker threads
        useAtomics: true
      }
    }
  }
})
```

### When to Use Different Pools

```typescript
// THREADS (default) - Best for most cases
export default defineConfig({
  test: {
    pool: 'threads',
    // ✓ Fast
    // ✓ Good isolation
    // ✓ Low overhead
  }
})

// FORKS - For tests that need full isolation
export default defineConfig({
  test: {
    pool: 'forks',
    // ✓ Complete isolation (separate processes)
    // ✓ No shared state possible
    // ✗ Slower startup
    // ✗ Higher memory usage
  }
})

// VM THREADS - For experimental features
export default defineConfig({
  test: {
    pool: 'vmThreads',
    // ✓ Very fast
    // ⚠️ Experimental
    // ⚠️ Some limitations
  }
})
```

### Parallel-Safe Tests

```typescript
// ✅ SAFE for parallel execution
describe('Pure functions', () => {
  it('should add numbers', () => {
    expect(add(2, 3)).toBe(5)
  })
  
  it('should multiply numbers', () => {
    expect(multiply(2, 3)).toBe(6)
  })
})

// ✅ SAFE - Each test has own data
describe('User operations', () => {
  it('should create user A', async () => {
    const user = await createUser({ email: 'a@test.com' })
    expect(user).toBeDefined()
  })
  
  it('should create user B', async () => {
    const user = await createUser({ email: 'b@test.com' })
    expect(user).toBeDefined()
  })
})

// ❌ UNSAFE - Shared global state
let counter = 0

describe('Counter tests', () => {
  it('should increment', () => {
    counter++
    expect(counter).toBe(1) // Race condition!
  })
  
  it('should increment again', () => {
    counter++
    expect(counter).toBe(2) // Race condition!
  })
})

// ✅ SAFE - Use beforeEach for isolation
describe('Counter tests', () => {
  let counter: number
  
  beforeEach(() => {
    counter = 0 // Fresh counter for each test
  })
  
  it('should increment', () => {
    counter++
    expect(counter).toBe(1)
  })
  
  it('should increment again', () => {
    counter++
    expect(counter).toBe(1) // Independent!
  })
})
```

### File-Level Sequencing

```typescript
// Some tests MUST run sequentially
// @vitest-environment node
// @vitest-pool forks
// @vitest-sequence 1

describe('Database migrations', () => {
  it('should run migration 1', async () => {
    await runMigration('001_initial')
  })
  
  it('should run migration 2', async () => {
    await runMigration('002_add_users')
  })
})
```

---

## 9.3 Workspace & Monorepo Support

### Understanding Workspaces

```
monorepo/
├── packages/
│   ├── ui/
│   │   ├── src/
│   │   ├── vitest.config.ts
│   │   └── package.json
│   ├── api/
│   │   ├── src/
│   │   ├── vitest.config.ts
│   │   └── package.json
│   └── shared/
│       ├── src/
│       ├── vitest.config.ts
│       └── package.json
├── vitest.workspace.ts  ← Workspace config
└── package.json
```

### Basic Workspace Configuration

```typescript
// vitest.workspace.ts
import { defineWorkspace } from 'vitest/config'

export default defineWorkspace([
  // Packages configuration
  'packages/*',
  
  // Or specific configs
  {
    test: {
      name: 'ui',
      root: './packages/ui',
      environment: 'happy-dom'
    }
  },
  {
    test: {
      name: 'api',
      root: './packages/api',
      environment: 'node'
    }
  }
])
```

### Advanced Workspace Setup

```typescript
// vitest.workspace.ts
import { defineWorkspace } from 'vitest/config'

export default defineWorkspace([
  // Unit tests across all packages
  {
    test: {
      name: 'unit',
      include: ['packages/*/src/**/*.test.ts'],
      environment: 'node',
      exclude: ['**/*.integration.test.ts']
    }
  },
  
  // Integration tests
  {
    test: {
      name: 'integration',
      include: ['packages/*/src/**/*.integration.test.ts'],
      environment: 'node',
      setupFiles: ['./test/integration-setup.ts']
    }
  },
  
  // UI component tests
  {
    test: {
      name: 'ui-components',
      include: ['packages/ui/**/*.test.tsx'],
      environment: 'happy-dom',
      setupFiles: ['./test/ui-setup.ts']
    }
  },
  
  // E2E tests
  {
    test: {
      name: 'e2e',
      include: ['e2e/**/*.test.ts'],
      environment: 'node',
      testTimeout: 30000
    }
  }
])
```

### Running Workspace Tests

```bash
# Run all workspaces
vitest

# Run specific workspace
vitest --project=ui

# Run multiple workspaces
vitest --project=ui --project=api

# List all projects
vitest --list-projects
```

### Shared Configuration

```typescript
// vitest.shared.ts
import { defineConfig } from 'vitest/config'

export const sharedConfig = defineConfig({
  test: {
    globals: true,
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html']
    }
  }
})
```

```typescript
// packages/ui/vitest.config.ts
import { defineConfig, mergeConfig } from 'vitest/config'
import { sharedConfig } from '../../vitest.shared'

export default mergeConfig(
  sharedConfig,
  defineConfig({
    test: {
      environment: 'happy-dom',
      include: ['src/**/*.test.tsx']
    }
  })
)
```

### Workspace-Specific Features

```typescript
// vitest.workspace.ts
export default defineWorkspace([
  {
    test: {
      name: 'unit-fast',
      include: ['src/**/*.test.ts'],
      exclude: ['src/**/*.slow.test.ts'],
      // Fast tests - run in parallel
      threads: true,
      maxThreads: 8
    }
  },
  {
    test: {
      name: 'integration-slow',
      include: ['src/**/*.integration.test.ts'],
      // Slow tests - limit concurrency
      threads: true,
      maxThreads: 2,
      testTimeout: 30000
    }
  }
])
```

---

## 9.4 Browser Mode

### When to Use Browser Mode

```
Browser Mode is for:
✓ Testing browser-specific APIs
✓ Real DOM behavior testing
✓ Visual regression testing
✓ Cross-browser compatibility

Use happy-dom/jsdom for:
✓ Unit tests
✓ Fast component tests
✓ CI/CD pipelines
```

### Setting Up Browser Mode

```bash
# Install browser provider
npm install -D @vitest/browser playwright
# or
npm install -D @vitest/browser webdriverio
```

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    browser: {
      enabled: true,
      
      // Browser name
      name: 'chromium', // 'firefox' | 'webkit' | 'chrome' | 'edge'
      
      // Provider
      provider: 'playwright', // or 'webdriverio'
      
      // Headless mode
      headless: true,
      
      // Viewport
      viewport: {
        width: 1280,
        height: 720
      },
      
      // Screenshots on failure
      screenshotFailures: true
    }
  }
})
```

### Browser-Specific Tests

```typescript
// component.browser.test.ts
import { expect, test } from '@vitest/browser'
import { render } from '@testing-library/react'

test('should interact with real DOM', async () => {
  const { getByRole } = render(<Button>Click me</Button>)
  
  const button = getByRole('button')
  
  // Real browser click
  await button.click()
  
  // Real browser APIs
  expect(document.activeElement).toBe(button)
  expect(window.getComputedStyle(button).color).toBe('rgb(0, 0, 0)')
})

test('should use canvas API', () => {
  const canvas = document.createElement('canvas')
  const ctx = canvas.getContext('2d')
  
  // Real canvas API (not available in jsdom)
  ctx?.fillRect(0, 0, 100, 100)
  
  expect(canvas.toDataURL()).toContain('data:image/png')
})
```

### Performance Considerations

```typescript
// Browser mode is slower - use strategically
export default defineConfig({
  test: {
    // Regular tests - fast
    include: ['src/**/*.test.ts'],
    environment: 'happy-dom',
    
    // Browser tests - slower but more accurate
    browser: {
      enabled: true,
      include: ['src/**/*.browser.test.ts']
    }
  }
})
```

---

## 9.5 Benchmarking

### What is Benchmarking?

Benchmarking measures and compares performance of different implementations.

```typescript
import { bench, describe } from 'vitest'

describe('String concatenation', () => {
  const iterations = 1000
  
  bench('string concatenation with +', () => {
    let str = ''
    for (let i = 0; i < iterations; i++) {
      str += 'test'
    }
  })
  
  bench('string concatenation with array join', () => {
    const arr: string[] = []
    for (let i = 0; i < iterations; i++) {
      arr.push('test')
    }
    arr.join('')
  })
  
  bench('string concatenation with template literals', () => {
    let str = ''
    for (let i = 0; i < iterations; i++) {
      str = `${str}test`
    }
  })
})

// Output:
// ✓ string concatenation with + (5.2ms) - 192.3 ops/ms
// ✓ array join (2.1ms) - 476.2 ops/ms ← Winner!
// ✓ template literals (6.8ms) - 147.1 ops/ms
```

### Benchmark Configuration

```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    benchmark: {
      include: ['**/*.bench.ts'],
      exclude: ['node_modules'],
      
      // Benchmark options
      outputFile: './benchmark-results.json',
      
      // Reporter
      reporters: ['default', 'json']
    }
  }
})
```

### Real-World Benchmarks

```typescript
// sorting.bench.ts
import { bench, describe } from 'vitest'

describe('Array sorting algorithms', () => {
  const unsorted = Array.from({ length: 1000 }, () => 
    Math.floor(Math.random() * 1000)
  )
  
  bench('native sort', () => {
    [...unsorted].sort((a, b) => a - b)
  })
  
  bench('bubble sort', () => {
    bubbleSort([...unsorted])
  })
  
  bench('quick sort', () => {
    quickSort([...unsorted])
  })
})

// Output:
// ✓ native sort (0.5ms) - 2000 ops/ms ← Fastest
// ✓ quick sort (2.3ms) - 434.8 ops/ms
// ✓ bubble sort (45.2ms) - 22.1 ops/ms
```

```typescript
// data-structures.bench.ts
describe('Map vs Object lookup', () => {
  const size = 10000
  
  // Setup data
  const map = new Map()
  const obj: Record<string, number> = {}
  
  for (let i = 0; i < size; i++) {
    const key = `key_${i}`
    map.set(key, i)
    obj[key] = i
  }
  
  bench('Map lookup', () => {
    map.get('key_5000')
  })
  
  bench('Object lookup', () => {
    obj['key_5000']
  })
  
  bench('Map iteration', () => {
    for (const [key, value] of map) {
      // iterate
    }
  })
  
  bench('Object iteration', () => {
    for (const key in obj) {
      const value = obj[key]
    }
  })
})
```

### Comparing Implementations

```typescript
// cache.bench.ts
describe('Cache implementations', () => {
  interface Cache {
    get(key: string): any
    set(key: string, value: any): void
  }
  
  class MapCache implements Cache {
    private cache = new Map()
    get(key: string) { return this.cache.get(key) }
    set(key: string, value: any) { this.cache.set(key, value) }
  }
  
  class ObjectCache implements Cache {
    private cache: Record<string, any> = {}
    get(key: string) { return this.cache[key] }
    set(key: string, value: any) { this.cache[key] = value }
  }
  
  const testData = Array.from({ length: 1000 }, (_, i) => [`key_${i}`, i])
  
  bench('MapCache', () => {
    const cache = new MapCache()
    testData.forEach(([k, v]) => cache.set(k, v))
    testData.forEach(([k]) => cache.get(k))
  })
  
  bench('ObjectCache', () => {
    const cache = new ObjectCache()
    testData.forEach(([k, v]) => cache.set(k, v))
    testData.forEach(([k]) => cache.get(k))
  })
})
```

---

## 9.6 Optimization Tips

### 1. Minimize Setup/Teardown

```typescript
// ❌ SLOW - Expensive setup in beforeEach
describe('Database tests', () => {
  let db: Database
  
  beforeEach(async () => {
    db = await createDatabase()
    await db.migrate()
    await db.seed() // Slow!
  })
  
  // 10 tests = 10 expensive setups
})

// ✅ FAST - Setup once in beforeAll
describe('Database tests', () => {
  let db: Database
  
  beforeAll(async () => {
    db = await createDatabase()
    await db.migrate()
    await db.seed()
  })
  
  beforeEach(async () => {
    // Only reset data that changed
    await db.resetTestData()
  })
  
  // 10 tests = 1 expensive setup + 10 quick resets
})
```

### 2. Smart Mocking

```typescript
// ❌ SLOW - Mock entire large library
vi.mock('lodash')

// ✅ FAST - Mock only what you use
vi.mock('lodash', () => ({
  debounce: vi.fn((fn) => fn),
  throttle: vi.fn((fn) => fn)
}))

// ✅ FASTER - Don't mock if not needed
import { debounce } from 'lodash'
// Use real implementation
```

### 3. Avoid Unnecessary Async

```typescript
// ❌ SLOW - Unnecessary async
it('should add numbers', async () => {
  const result = await Promise.resolve(add(2, 3))
  expect(result).toBe(5)
})

// ✅ FAST - Synchronous
it('should add numbers', () => {
  const result = add(2, 3)
  expect(result).toBe(5)
})
```

### 4. Batch Similar Tests

```typescript
// ❌ SLOW - Separate tests with repeated setup
it('should validate email', () => {
  const validator = new Validator()
  expect(validator.email('test@example.com')).toBe(true)
})

it('should reject invalid email', () => {
  const validator = new Validator()
  expect(validator.email('invalid')).toBe(false)
})

// ✅ FAST - Test multiple cases together
it('should validate email formats', () => {
  const validator = new Validator()
  
  expect(validator.email('test@example.com')).toBe(true)
  expect(validator.email('invalid')).toBe(false)
  expect(validator.email('')).toBe(false)
})
```

### 5. Use Test Fixtures

```typescript
// fixtures/users.ts
export const testUsers = {
  admin: {
    id: 1,
    name: 'Admin User',
    role: 'admin',
    email: 'admin@test.com'
  },
  regular: {
    id: 2,
    name: 'Regular User',
    role: 'user',
    email: 'user@test.com'
  }
}

// test.ts - No need to recreate data
import { testUsers } from '@test/fixtures/users'

it('should check admin permissions', () => {
  expect(hasPermission(testUsers.admin, 'delete')).toBe(true)
})
```

### 6. Profile and Optimize

```bash
# Find slow tests
vitest --reporter=verbose | grep "ms"

# Profile with Node inspector
vitest --inspect-brk

# Check memory usage
vitest --logHeapUsage
```

---

## Summary: Chapter 9

### Performance Optimization Checklist

**Test Execution:**
- ✅ Keep unit tests under 10ms
- ✅ Use `beforeAll` for expensive setup
- ✅ Avoid unnecessary async/await
- ✅ Profile slow tests regularly

**Parallel Execution:**
- ✅ Enable threads for fast tests
- ✅ Ensure tests are independent
- ✅ Use appropriate pool (threads/forks)
- ✅ Limit concurrent integration tests

**Workspace/Monorepo:**
- ✅ Separate unit/integration/e2e
- ✅ Run relevant tests per package
- ✅ Share common configuration
- ✅ Use project filtering

**Browser Mode:**
- ✅ Use only when necessary
- ✅ Prefer happy-dom for unit tests
- ✅ Real browser for integration
- ✅ Enable headless mode

**Benchmarking:**
- ✅ Compare implementations
- ✅ Test at realistic scale
- ✅ Track performance over time
- ✅ Document findings

### Quick Reference

```typescript
// Fast test configuration
export default defineConfig({
  test: {
    threads: true,
    maxThreads: 8,
    isolate: true,
    pool: 'threads'
  }
})

// Benchmark
import { bench } from 'vitest'

bench('operation', () => {
  // code to benchmark
})
```

**Remember**: Premature optimization is the root of all evil. Profile first, optimize what matters!