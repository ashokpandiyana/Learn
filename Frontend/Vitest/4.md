# Chapter 4: Advanced Testing Patterns - Complete Guide

## 4.1 Snapshot Testing

### What is Snapshot Testing?

Snapshot testing captures the output of a function or component and saves it as a reference file. Future test runs compare new output against this saved snapshot to detect unexpected changes.

```
┌─────────────────────────────────────────┐
│   First Run: Create Snapshot           │
├─────────────────────────────────────────┤
│   Your Code → Output → Save to file    │
│                         (.snap file)    │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│   Subsequent Runs: Compare              │
├─────────────────────────────────────────┤
│   Your Code → Output → Compare with     │
│                         saved snapshot  │
│                         ✓ Match or      │
│                         ✗ Fail          │
└─────────────────────────────────────────┘
```

### Basic Snapshot Testing

```typescript
import { describe, it, expect } from 'vitest'

describe('Snapshot testing basics', () => {
  it('should match snapshot for simple data', () => {
    const user = {
      id: 1,
      name: 'John Doe',
      email: 'john@example.com',
      createdAt: '2024-01-01'
    }
    
    expect(user).toMatchSnapshot()
  })
  
  it('should match snapshot for arrays', () => {
    const users = [
      { id: 1, name: 'John' },
      { id: 2, name: 'Jane' },
      { id: 3, name: 'Bob' }
    ]
    
    expect(users).toMatchSnapshot()
  })
})
```

**First run creates:**
```javascript
// __snapshots__/test.spec.ts.snap

exports['Snapshot testing basics > should match snapshot for simple data 1'] = `
{
  "createdAt": "2024-01-01",
  "email": "john@example.com",
  "id": 1,
  "name": "John Doe",
}
`
```

### Inline Snapshots

```typescript
describe('Inline snapshots', () => {
  it('should create inline snapshot', () => {
    const greeting = (name: string) => `Hello, ${name}!`
    
    // First run: snapshot value is inserted automatically
    expect(greeting('World')).toMatchInlineSnapshot()
    
    // After first run, code becomes:
    // expect(greeting('World')).toMatchInlineSnapshot(`"Hello, World!"`)
  })
  
  it('should update inline snapshot', () => {
    const config = {
      timeout: 5000,
      retries: 3,
      baseUrl: 'https://api.example.com'
    }
    
    expect(config).toMatchInlineSnapshot(`
      {
        "baseUrl": "https://api.example.com",
        "retries": 3,
        "timeout": 5000,
      }
    `)
  })
})
```

### Snapshot Testing with Dynamic Data

```typescript
describe('Handling dynamic data', () => {
  it('should ignore dynamic fields with property matchers', () => {
    const user = {
      id: Math.random(), // Dynamic
      name: 'John',
      createdAt: new Date(), // Dynamic
      profile: {
        bio: 'Software Developer',
        joinedAt: new Date() // Dynamic
      }
    }
    
    expect(user).toMatchSnapshot({
      id: expect.any(Number),
      createdAt: expect.any(Date),
      profile: {
        bio: 'Software Developer',
        joinedAt: expect.any(Date)
      }
    })
  })
  
  it('should use snapshot serializers for consistent output', () => {
    const timestamp = Date.now()
    
    // Without serializer: fails on every run
    // expect(timestamp).toMatchSnapshot()
    
    // With custom handling: consistent
    expect(new Date(timestamp).toISOString())
      .toMatchInlineSnapshot(`"2024-01-01T00:00:00.000Z"`)
  })
})
```

### Real-World Example: Testing API Responses

```typescript
// api.ts
export interface ApiResponse<T> {
  data: T
  metadata: {
    timestamp: string
    requestId: string
    version: string
  }
}

export async function fetchUsers(): Promise<ApiResponse<User[]>> {
  const response = await fetch('/api/users')
  return response.json()
}

// api.test.ts
import { describe, it, expect, vi } from 'vitest'
import { fetchUsers } from './api'

vi.mock('fetch')

describe('API Response Snapshots', () => {
  it('should match response structure', async () => {
    const mockResponse = {
      data: [
        { id: 1, name: 'John', email: 'john@example.com' },
        { id: 2, name: 'Jane', email: 'jane@example.com' }
      ],
      metadata: {
        timestamp: '2024-01-01T00:00:00Z',
        requestId: 'req-12345',
        version: '1.0.0'
      }
    }
    
    vi.mocked(fetch).mockResolvedValue({
      ok: true,
      json: async () => mockResponse
    } as Response)
    
    const result = await fetchUsers()
    
    // Use property matchers for dynamic fields
    expect(result).toMatchSnapshot({
      data: expect.any(Array),
      metadata: {
        timestamp: expect.any(String),
        requestId: expect.stringMatching(/^req-/),
        version: expect.any(String)
      }
    })
  })
})
```

### Snapshot Testing React Components

```typescript
import { render } from '@testing-library/react'
import { describe, it, expect } from 'vitest'

interface ButtonProps {
  label: string
  variant?: 'primary' | 'secondary'
  onClick?: () => void
}

function Button({ label, variant = 'primary', onClick }: ButtonProps) {
  return (
    <button 
      className={`btn btn-${variant}`}
      onClick={onClick}
    >
      {label}
    </button>
  )
}

describe('Button Component Snapshots', () => {
  it('should match snapshot for primary button', () => {
    const { container } = render(<Button label="Click Me" />)
    expect(container.firstChild).toMatchSnapshot()
  })
  
  it('should match snapshot for secondary button', () => {
    const { container } = render(
      <Button label="Cancel" variant="secondary" />
    )
    expect(container.firstChild).toMatchSnapshot()
  })
})
```

### Updating Snapshots

```bash
# Update all snapshots
vitest -u

# Update snapshots interactively
vitest --watch
# Press 'u' to update failing snapshots
```

### Snapshot Best Practices

```typescript
describe('Snapshot best practices', () => {
  // ✅ GOOD - Small, focused snapshots
  it('should snapshot user name formatting', () => {
    const formatted = formatUserName({ first: 'John', last: 'Doe' })
    expect(formatted).toMatchInlineSnapshot(`"John Doe"`)
  })
  
  // ❌ BAD - Large, unwieldy snapshots
  it('should snapshot entire application state', () => {
    const state = {
      users: Array(100).fill({ /* complex object */ }),
      posts: Array(200).fill({ /* complex object */ }),
      comments: Array(500).fill({ /* complex object */ })
    }
    expect(state).toMatchSnapshot() // Too large!
  })
  
  // ✅ GOOD - Snapshot specific parts
  it('should snapshot user summary', () => {
    const state = getApplicationState()
    expect(state.users.slice(0, 3)).toMatchSnapshot()
  })
})
```

### When to Use Snapshots

**✅ Good Use Cases:**
- Testing serialized data structures
- API response shapes
- Component rendering output
- Configuration objects
- Error messages
- Log output

**❌ Avoid Snapshots For:**
- Highly dynamic data
- Very large objects
- Binary data
- Encrypted/hashed values
- Time-sensitive data

### Snapshot Testing Anti-Patterns

```typescript
describe('Snapshot anti-patterns', () => {
  // ❌ BAD - Snapshot includes timestamps
  it('should create user', () => {
    const user = createUser('John')
    expect(user).toMatchSnapshot() // Fails: timestamp always different
  })
  
  // ✅ GOOD - Exclude dynamic fields
  it('should create user', () => {
    const user = createUser('John')
    expect(user).toMatchSnapshot({
      id: expect.any(String),
      createdAt: expect.any(Date)
    })
  })
  
  // ❌ BAD - Blindly updating snapshots
  it('renders component', () => {
    const { container } = render(<ComplexComponent />)
    expect(container).toMatchSnapshot()
    // Developer runs `vitest -u` without reviewing changes!
  })
  
  // ✅ GOOD - Review snapshot changes carefully
  it('renders component', () => {
    const { container } = render(<ComplexComponent />)
    // 1. Review what changed
    // 2. Verify changes are intentional
    // 3. Only then update snapshot
    expect(container).toMatchSnapshot()
  })
})
```

---

## 4.2 Test Context

### Understanding Test Context

Test context allows sharing data between test lifecycle hooks and test functions. It's particularly useful for complex setup logic.

```typescript
import { describe, it, expect, beforeEach } from 'vitest'

describe('Test Context Basics', () => {
  // Define context type
  interface TestContext {
    user: { id: number; name: string }
    token: string
  }
  
  // Setup context in beforeEach
  beforeEach<TestContext>(async (context) => {
    // Create test data
    context.user = { id: 1, name: 'John' }
    context.token = 'test-token-123'
  })
  
  // Use context in tests
  it<TestContext>('should have user in context', ({ user, token }) => {
    expect(user).toEqual({ id: 1, name: 'John' })
    expect(token).toBe('test-token-123')
  })
  
  it<TestContext>('should access context properties', ({ user }) => {
    expect(user.name).toBe('John')
  })
})
```

### Extended Context with TypeScript

```typescript
import { describe, it, beforeEach } from 'vitest'

// Define extended context interface
interface DatabaseContext {
  db: Database
  cleanup: () => Promise<void>
}

interface UserContext {
  adminUser: User
  regularUser: User
}

// Combine contexts
type TestContext = DatabaseContext & UserContext

describe('Extended Context', () => {
  beforeEach<TestContext>(async (context) => {
    // Setup database
    context.db = await createTestDatabase()
    
    // Create test users
    context.adminUser = await context.db.users.create({
      name: 'Admin',
      role: 'admin'
    })
    
    context.regularUser = await context.db.users.create({
      name: 'User',
      role: 'user'
    })
    
    // Setup cleanup function
    context.cleanup = async () => {
      await context.db.users.deleteAll()
      await context.db.close()
    }
  })
  
  afterEach<TestContext>(async ({ cleanup }) => {
    await cleanup()
  })
  
  it<TestContext>('should query users', async ({ db, adminUser }) => {
    const user = await db.users.findById(adminUser.id)
    expect(user).toEqual(adminUser)
  })
  
  it<TestContext>('should check permissions', ({ adminUser, regularUser }) => {
    expect(adminUser.role).toBe('admin')
    expect(regularUser.role).toBe('user')
  })
})
```

### Real-World Example: E2E Testing Context

```typescript
// testContext.ts
import { Page } from 'playwright'

export interface E2EContext {
  page: Page
  baseUrl: string
  login: (email: string, password: string) => Promise<void>
  logout: () => Promise<void>
  screenshot: (name: string) => Promise<void>
}

// test.spec.ts
describe('E2E Tests', () => {
  beforeEach<E2EContext>(async (context) => {
    // Setup page
    context.page = await browser.newPage()
    context.baseUrl = 'http://localhost:3000'
    
    // Helper: Login
    context.login = async (email: string, password: string) => {
      await context.page.goto(`${context.baseUrl}/login`)
      await context.page.fill('[name="email"]', email)
      await context.page.fill('[name="password"]', password)
      await context.page.click('button[type="submit"]')
      await context.page.waitForURL(`${context.baseUrl}/dashboard`)
    }
    
    // Helper: Logout
    context.logout = async () => {
      await context.page.click('[data-testid="logout"]')
      await context.page.waitForURL(`${context.baseUrl}/login`)
    }
    
    // Helper: Screenshot
    context.screenshot = async (name: string) => {
      await context.page.screenshot({ 
        path: `screenshots/${name}.png` 
      })
    }
  })
  
  afterEach<E2EContext>(async ({ page }) => {
    await page.close()
  })
  
  it<E2EContext>('should login successfully', async ({ 
    page, 
    login,
    baseUrl 
  }) => {
    await login('user@example.com', 'password123')
    
    const url = page.url()
    expect(url).toBe(`${baseUrl}/dashboard`)
  })
  
  it<E2EContext>('should navigate after login', async ({
    page,
    login,
    screenshot
  }) => {
    await login('user@example.com', 'password123')
    
    await page.click('[data-testid="profile-link"]')
    await screenshot('profile-page')
    
    const title = await page.textContent('h1')
    expect(title).toBe('User Profile')
  })
})
```

### Context with Fixtures Pattern

```typescript
// fixtures.ts
export interface Fixtures {
  authenticatedUser: User
  testProduct: Product
  testOrder: Order
}

export async function createFixtures(): Promise<Fixtures> {
  const user = await createTestUser({ role: 'customer' })
  const product = await createTestProduct({ price: 99.99 })
  const order = await createTestOrder({ userId: user.id })
  
  return { authenticatedUser: user, testProduct: product, testOrder: order }
}

// test.ts
describe('Order Tests', () => {
  beforeEach<Fixtures>(async (context) => {
    const fixtures = await createFixtures()
    Object.assign(context, fixtures)
  })
  
  it<Fixtures>('should create order for user', async ({
    authenticatedUser,
    testProduct
  }) => {
    const order = await orderService.create({
      userId: authenticatedUser.id,
      productId: testProduct.id,
      quantity: 2
    })
    
    expect(order.userId).toBe(authenticatedUser.id)
    expect(order.total).toBe(testProduct.price * 2)
  })
})
```

---

## 4.3 Concurrent Testing

### Understanding Concurrent Tests

By default, Vitest runs tests in each file sequentially. Concurrent testing allows multiple tests to run in parallel, significantly speeding up test suites.

```
┌─────────────────────────────────────┐
│   SEQUENTIAL (default)              │
├─────────────────────────────────────┤
│   Test 1 → Test 2 → Test 3         │
│   (100ms)  (100ms)  (100ms)         │
│   Total: 300ms                      │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│   CONCURRENT                        │
├─────────────────────────────────────┤
│   Test 1 ┐                          │
│   Test 2 ├→ Run in parallel         │
│   Test 3 ┘                          │
│   Total: ~100ms                     │
└─────────────────────────────────────┘
```

### Basic Concurrent Tests

```typescript
import { describe, it, expect } from 'vitest'

describe('Concurrent tests', () => {
  // Sequential (default)
  it('test 1', async () => {
    await delay(100)
    expect(true).toBe(true)
  })
  
  it('test 2', async () => {
    await delay(100)
    expect(true).toBe(true)
  })
  // Total time: ~200ms
  
  // Concurrent - runs in parallel
  it.concurrent('concurrent test 1', async () => {
    await delay(100)
    expect(true).toBe(true)
  })
  
  it.concurrent('concurrent test 2', async () => {
    await delay(100)
    expect(true).toBe(true)
  })
  // Total time: ~100ms
})
```

### Concurrent Test Suites

```typescript
describe('Concurrent test suites', () => {
  // All tests in this suite run concurrently
  describe.concurrent('API endpoints', () => {
    it('GET /users', async () => {
      const response = await api.get('/users')
      expect(response.status).toBe(200)
    })
    
    it('GET /posts', async () => {
      const response = await api.get('/posts')
      expect(response.status).toBe(200)
    })
    
    it('GET /comments', async () => {
      const response = await api.get('/comments')
      expect(response.status).toBe(200)
    })
    // All three requests run simultaneously
  })
})
```

### When to Use Concurrent Tests

```typescript
describe('Use cases for concurrent tests', () => {
  // ✅ GOOD - Independent API calls
  describe.concurrent('Independent API tests', () => {
    it('fetches user data', async () => {
      const user = await fetchUser(1)
      expect(user.id).toBe(1)
    })
    
    it('fetches product data', async () => {
      const product = await fetchProduct(1)
      expect(product.id).toBe(1)
    })
    // No shared state - safe to run concurrently
  })
  
  // ❌ BAD - Shared state
  describe('Tests with shared state', () => {
    let counter = 0
    
    it.concurrent('increments counter', () => {
      counter++
      expect(counter).toBe(1) // Race condition!
    })
    
    it.concurrent('increments counter again', () => {
      counter++
      expect(counter).toBe(2) // Race condition!
    })
    // These will fail unpredictably
  })
})
```

### Concurrent with Limits

```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    // Limit concurrent tests
    maxConcurrency: 5
  }
})

describe('Rate-limited API tests', () => {
  // Run max 5 tests at once
  describe.concurrent('API stress test', () => {
    for (let i = 0; i < 100; i++) {
      it(`request ${i}`, async () => {
        const response = await api.get(`/data/${i}`)
        expect(response.status).toBe(200)
      })
    }
  })
})
```

### Real-World Example: Testing Multiple Endpoints

```typescript
describe.concurrent('Microservices Health Checks', () => {
  const services = [
    'user-service',
    'order-service',
    'payment-service',
    'notification-service',
    'analytics-service'
  ]
  
  services.forEach(service => {
    it(`${service} should be healthy`, async () => {
      const response = await fetch(`https://${service}/health`)
      const data = await response.json()
      
      expect(response.status).toBe(200)
      expect(data.status).toBe('healthy')
    })
  })
  
  // All 5 health checks run simultaneously
})
```

### Concurrent Testing Best Practices

```typescript
describe('Concurrent best practices', () => {
  // ✅ GOOD - Pure functions, no side effects
  describe.concurrent('Math operations', () => {
    it('adds numbers', () => {
      expect(1 + 1).toBe(2)
    })
    
    it('multiplies numbers', () => {
      expect(2 * 3).toBe(6)
    })
  })
  
  // ✅ GOOD - Each test has its own data
  describe.concurrent('User creation', () => {
    it('creates user 1', async () => {
      const user = await createUser({ email: 'user1@test.com' })
      expect(user).toBeDefined()
    })
    
    it('creates user 2', async () => {
      const user = await createUser({ email: 'user2@test.com' })
      expect(user).toBeDefined()
    })
  })
  
  // ❌ BAD - Global state mutation
  let globalUser: User
  
  describe('Tests with global state', () => {
    it.concurrent('sets user', async () => {
      globalUser = await createUser({ name: 'John' })
    })
    
    it.concurrent('uses user', () => {
      expect(globalUser.name).toBe('John') // Race condition!
    })
  })
})
```

---

## 4.4 Custom Matchers

### Why Custom Matchers?

Custom matchers allow you to create domain-specific assertions that make tests more readable and maintainable.

```typescript
// ❌ WITHOUT custom matcher
expect(temperature).toBeGreaterThanOrEqual(20)
expect(temperature).toBeLessThanOrEqual(30)

// ✅ WITH custom matcher
expect(temperature).toBeWithinRange(20, 30)
```

### Creating Custom Matchers

```typescript
import { expect } from 'vitest'

// Extend expect with custom matchers
expect.extend({
  toBeWithinRange(received: number, floor: number, ceiling: number) {
    const pass = received >= floor && received <= ceiling
    
    if (pass) {
      return {
        message: () =>
          `expected ${received} not to be within range ${floor} - ${ceiling}`,
        pass: true
      }
    } else {
      return {
        message: () =>
          `expected ${received} to be within range ${floor} - ${ceiling}`,
        pass: false
      }
    }
  }
})

// Usage
describe('Custom matcher', () => {
  it('should check if number is in range', () => {
    expect(25).toBeWithinRange(20, 30)
    expect(15).not.toBeWithinRange(20, 30)
  })
})
```

### TypeScript Support for Custom Matchers

```typescript
// Add type definitions
interface CustomMatchers<R = unknown> {
  toBeWithinRange(floor: number, ceiling: number): R
}

declare module 'vitest' {
  interface Assertion<T = any> extends CustomMatchers<T> {}
  interface AsymmetricMatchersContaining extends CustomMatchers {}
}

// Now TypeScript knows about your custom matcher
expect(25).toBeWithinRange(20, 30) // ✅ Type-safe
```

### Real-World Example: Date Matchers

```typescript
import { expect } from 'vitest'

expect.extend({
  toBeToday(received: Date) {
    const today = new Date()
    const isSameDay = 
      received.getDate() === today.getDate() &&
      received.getMonth() === today.getMonth() &&
      received.getFullYear() === today.getFullYear()
    
    return {
      message: () =>
        isSameDay
          ? `expected ${received} not to be today`
          : `expected ${received} to be today`,
      pass: isSameDay
    }
  },
  
  toBeAfter(received: Date, expected: Date) {
    const pass = received.getTime() > expected.getTime()
    
    return {
      message: () =>
        pass
          ? `expected ${received} not to be after ${expected}`
          : `expected ${received} to be after ${expected}`,
      pass
    }
  },
  
  toBeBefore(received: Date, expected: Date) {
    const pass = received.getTime() < expected.getTime()
    
    return {
      message: () =>
        pass
          ? `expected ${received} not to be before ${expected}`
          : `expected ${received} to be before ${expected}`,
      pass
    }
  }
})

// Usage
describe('Date custom matchers', () => {
  it('should validate dates', () => {
    const now = new Date()
    const yesterday = new Date(Date.now() - 86400000)
    const tomorrow = new Date(Date.now() + 86400000)
    
    expect(now).toBeToday()
    expect(tomorrow).toBeAfter(now)
    expect(yesterday).toBeBefore(now)
  })
})
```

### Custom Matcher for API Responses

```typescript
interface ApiResponse {
  status: number
  data: any
  error?: string
}

expect.extend({
  toBeSuccessfulResponse(received: ApiResponse) {
    const isSuccess = received.status >= 200 && received.status < 300
    const hasData = received.data !== null && received.data !== undefined
    const noError = !received.error
    
    const pass = isSuccess && hasData && noError
    
    return {
      message: () => {
        if (!isSuccess) {
          return `expected successful status, got ${received.status}`
        }
        if (!hasData) {
          return 'expected response to have data'
        }
        if (!noError) {
          return `expected no error, got: ${received.error}`
        }
        return 'expected response not to be successful'
      },
      pass
    }
  },
  
  toHaveValidationError(received: ApiResponse, field: string) {
    const hasError = received.status === 400 || received.status === 422
    const errorMessage = received.error?.toLowerCase() || ''
    const mentionsField = errorMessage.includes(field.toLowerCase())
    
    const pass = hasError && mentionsField
    
    return {
      message: () =>
        pass
          ? `expected no validation error for ${field}`
          : `expected validation error for ${field}`,
      pass
    }
  }
})

// Usage
describe('API Response custom matchers', () => {
  it('should validate successful response', async () => {
    const response = await api.get('/users/1')
    expect(response).toBeSuccessfulResponse()
  })
  
  it('should validate error response', async () => {
    const response = await api.post('/users', { email: 'invalid' })
    expect(response).toHaveValidationError('email')
  })
})
```

### Custom Matchers with this.utils

```typescript
expect.extend({
  toBeValidEmail(received: string) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    const pass = emailRegex.test(received)
    
    return {
      message: () => {
        // Use this.utils for formatting
        const hint = this.utils.matcherHint(
          'toBeValidEmail',
          'received',
          '',
          { isNot: this.isNot }
        )
        
        const receivedStr = this.utils.printReceived(received)
        
        return pass
          ? `${hint}\n\nExpected ${receivedStr} not to be a valid email`
          : `${hint}\n\nExpected ${receivedStr} to be a valid email`
      },
      pass
    }
  }
})

describe('Email validation', () => {
  it('should validate email format', () => {
    expect('user@example.com').toBeValidEmail()
    expect('invalid-email').not.toBeValidEmail()
  })
})
```

---

## 4.5 Parameterized Tests

### Understanding Parameterized Tests

Parameterized tests (also called data-driven tests) allow you to run the same test with different inputs, reducing code duplication.

```typescript
// ❌ WITHOUT parameterized tests
it('adds 1 + 1', () => expect(add(1, 1)).toBe(2))
it('adds 2 + 2', () => expect(add(2, 2)).toBe(4))
it('adds 3 + 3', () => expect(add(3, 3)).toBe(6))

// ✅ WITH parameterized tests
it.each([
  [1, 1, 2],
  [2, 2, 4],
  [3, 3, 6]
])('adds %i + %i to equal %i', (a, b, expected) => {
  expect(add(a, b)).toBe(expected)
})
```

### Basic test.each() with Arrays

```typescript
import { describe, it, expect } from 'vitest'

function add(a: number, b: number) {
  return a + b
}

describe('Parameterized tests', () => {
  // Array of arrays
  it.each([
    [1, 1, 2],
    [2, 2, 4],
    [5, 3, 8],
    [10, -5, 5]
  ])('adds %i + %i to equal %i', (a, b, expected) => {
    expect(add(a, b)).toBe(expected)
  })
})

// Output:
// ✓ adds 1 + 1 to equal 2
// ✓ adds 2 + 2 to equal 4
// ✓ adds 5 + 3 to equal 8
// ✓ adds 10 + -5 to equal 5
```

### test.each() with Objects (Table Format)

```typescript
describe('Table format', () => {
  it.each([
    { a: 1, b: 1, expected: 2 },
    { a: 2, b: 2, expected: 4 },
    { a: 5, b: 3, expected: 8 }
  ])('adds $a + $b to equal $expected', ({ a, b, expected }) => {
    expect(add(a, b)).toBe(expected)
  })
})
```

### Template Literal Syntax

```typescript
describe('Template literal syntax', () => {
  it.each`
    a    | b    | expected
    ${1} | ${1} | ${2}
    ${2} | ${2} | ${4}
    ${5} | ${3} | ${8}
  `('adds $a + $b to equal $expected', ({ a, b, expected }) => {
    expect(add(a, b)).toBe(expected)
  })
})
```

### Real-World Example: Input Validation

```typescript
function validatePassword(password: string): {
  valid: boolean
  errors: string[]
} {
  const errors: string[] = []
  
  if (password.length < 8) {
    errors.push('Password must be at least 8 characters')
  }
  
  if (!/[A-Z]/.test(password)) {
    errors.push('Password must contain uppercase letter')
  }
  
  if (!/[0-9]/.test(password)) {
    errors.push('Password must contain number')
  }
  
  return {
    valid: errors.length === 0,
    errors
  }
}

describe('Password validation', () => {
  describe('invalid passwords', () => {
    it.each([
      ['short', ['Password must be at least 8 characters', 'Password must contain uppercase letter', 'Password must contain number']],
      ['lowercase', ['Password must contain uppercase letter', 'Password must contain number']],
      ['NoNumbers', ['Password must contain number']],
      ['12345678', ['Password must contain uppercase letter']]
    ])('rejects "%s"', (password, expectedErrors) => {
      const result = validatePassword(password)
      expect(result.valid).toBe(false)
      expect(result.errors).toEqual(expectedErrors)
    })
  })
  
  describe('valid passwords', () => {
    it.each([
      'Password123',
      'MySecure1Pass',
      'Strong9Password'
    ])('accepts "%s"', (password) => {
      const result = validatePassword(password)
      expect(result.valid).toBe(true)
      expect(result.errors).toHaveLength(0)
    })
  })
})
```

### Testing Edge Cases with Parameterized Tests

```typescript
function divide(a: number, b: number): number {
  if (b === 0) throw new Error('Division by zero')
  return a / b
}

describe('Division edge cases', () => {
  it.each([
    { a: 10, b: 2, expected: 5, description: 'normal division' },
    { a: 0, b: 5, expected: 0, description: 'zero dividend' },
    { a: -10, b: 2, expected: -5, description: 'negative dividend' },
    { a: 10, b: -2, expected: -5, description: 'negative divisor' },
    { a: -10, b: -2, expected: 5, description: 'both negative' }
  ])('$description: $a / $b = $expected', ({ a, b, expected }) => {
    expect(divide(a, b)).toBe(expected)
  })
  
  it('throws error for division by zero', () => {
    expect(() => divide(10, 0)).toThrow('Division by zero')
  })
})
```

### Parameterized Tests with Async Operations

```typescript
async function fetchUser(id: number): Promise<User> {
  const response = await fetch(`/api/users/${id}`)
  if (!response.ok) throw new Error('User not found')
  return response.json()
}

describe('Fetch users', () => {
  it.each([
    { id: 1, name: 'John' },
    { id: 2, name: 'Jane' },
    { id: 3, name: 'Bob' }
  ])('fetches user $id with name $name', async ({ id, name }) => {
    const user = await fetchUser(id)
    expect(user.id).toBe(id)
    expect(user.name).toBe(name)
  })
})
```

### describe.each() for Test Suites

```typescript
describe.each([
  { role: 'admin', canDelete: true, canEdit: true },
  { role: 'editor', canDelete: false, canEdit: true },
  { role: 'viewer', canDelete: false, canEdit: false }
])('User with role: $role', ({ role, canDelete, canEdit }) => {
  it('has correct delete permission', () => {
    const user = createUser({ role })
    expect(user.permissions.canDelete).toBe(canDelete)
  })
  
  it('has correct edit permission', () => {
    const user = createUser({ role })
    expect(user.permissions.canEdit).toBe(canEdit)
  })
})

// Output:
// User with role: admin
//   ✓ has correct delete permission
//   ✓ has correct edit permission
// User with role: editor
//   ✓ has correct delete permission
//   ✓ has correct edit permission
// User with role: viewer
//   ✓ has correct delete permission
//   ✓ has correct edit permission
```

---

## Summary: Chapter 4

### Key Takeaways

1. **Snapshot Testing**: Capture output once, compare on every run
   - Use for serialized data, components, API responses
   - Review changes carefully before updating
   - Avoid for highly dynamic or large data

2. **Test Context**: Share setup between hooks and tests
   - Type-safe with TypeScript interfaces
   - Perfect for complex fixtures
   - Keeps tests DRY (Don't Repeat Yourself)

3. **Concurrent Testing**: Run tests in parallel
   - Significantly speeds up test suites
   - Only for independent tests without shared state
   - Use `maxConcurrency` to control resource usage

4. **Custom Matchers**: Domain-specific assertions
   - Make tests more readable
   - Reduce code duplication
   - Provide better error messages

5. **Parameterized Tests**: Run same test with different data
   - Reduce code duplication
   - Test edge cases systematically
   - Better test coverage with less code

### Quick Reference

```typescript
// Snapshots
expect(data).toMatchSnapshot()
expect(data).toMatchInlineSnapshot()

// Context
beforeEach<MyContext>((ctx) => { ctx.user = ... })
it<MyContext>('test', ({ user }) => { ... })

// Concurrent
it.concurrent('test', async () => { ... })
describe.concurrent('suite', () => { ... })

// Custom matchers
expect.extend({ myMatcher(received) { ... } })

// Parameterized tests
it.each([ [1,2], [3,4] ])('test %i', (a, b) => { ... })
describe.each([...])('suite', () => { ... })
```

**Next Chapter Preview**: Chapter 5 will cover testing specific technologies including React, Vue, Svelte components, API calls with MSW, and DOM manipulation.