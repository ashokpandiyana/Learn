# Chapter 3: Mocking & Spies - Complete Guide

## Understanding Mocking

### What is Mocking?

**Mocking** is the practice of replacing real implementations with controlled test doubles. This allows you to:

1. **Isolate** the code under test from dependencies
2. **Control** behavior of external systems
3. **Verify** interactions between components
4. **Speed up** tests by avoiding slow operations

```
┌─────────────────────────────────────────┐
│        REAL SYSTEM                      │
├─────────────────────────────────────────┤
│  Your Code → Database → API → Email    │
│     ↑         (slow)   (slow)  (slow)  │
│     └── Tests are slow & unpredictable  │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│        WITH MOCKS                       │
├─────────────────────────────────────────┤
│  Your Code → Mock DB → Mock API        │
│     ↑         (fast)    (fast)         │
│     └── Tests are fast & predictable    │
└─────────────────────────────────────────┘
```

### When to Mock

✅ **DO Mock:**
- External APIs and network requests
- Database operations
- File system operations
- Time-dependent functions (Date.now, setTimeout)
- Third-party libraries
- Complex dependencies

❌ **DON'T Mock:**
- Simple utility functions
- Your own business logic
- Data structures (arrays, objects)
- Language features

---

## 3.1 Function Mocks

### Creating Mock Functions with vi.fn()

```typescript
import { describe, it, expect, vi } from 'vitest'

describe('vi.fn() basics', () => {
  it('should create a mock function', () => {
    // Create a mock function
    const mockFn = vi.fn()
    
    // Call it
    mockFn('hello')
    mockFn('world')
    
    // Verify it was called
    expect(mockFn).toHaveBeenCalled()
    expect(mockFn).toHaveBeenCalledTimes(2)
    expect(mockFn).toHaveBeenCalledWith('hello')
    expect(mockFn).toHaveBeenLastCalledWith('world')
  })
})
```

### Mock Return Values

```typescript
describe('mockReturnValue', () => {
  it('should return specified value', () => {
    const mockFn = vi.fn()
    mockFn.mockReturnValue(42)
    
    expect(mockFn()).toBe(42)
    expect(mockFn()).toBe(42)  // Always returns 42
  })
  
  it('should return different values in sequence', () => {
    const mockFn = vi.fn()
    
    // Return different values for each call
    mockFn
      .mockReturnValueOnce(1)
      .mockReturnValueOnce(2)
      .mockReturnValueOnce(3)
      .mockReturnValue(999)  // Default for subsequent calls
    
    expect(mockFn()).toBe(1)
    expect(mockFn()).toBe(2)
    expect(mockFn()).toBe(3)
    expect(mockFn()).toBe(999)
    expect(mockFn()).toBe(999)
  })
})
```

### Mock Implementations

```typescript
describe('mockImplementation', () => {
  it('should use custom implementation', () => {
    const mockFn = vi.fn()
    
    // Provide custom logic
    mockFn.mockImplementation((a, b) => a + b)
    
    expect(mockFn(2, 3)).toBe(5)
    expect(mockFn(10, 5)).toBe(15)
  })
  
  it('should use different implementations', () => {
    const mockFn = vi.fn()
    
    mockFn
      .mockImplementationOnce(() => 'first')
      .mockImplementationOnce(() => 'second')
      .mockImplementation(() => 'default')
    
    expect(mockFn()).toBe('first')
    expect(mockFn()).toBe('second')
    expect(mockFn()).toBe('default')
  })
})
```

### Mock Resolved/Rejected Values (Async)

```typescript
describe('Async mock functions', () => {
  it('should mock resolved promises', async () => {
    const mockFn = vi.fn()
    mockFn.mockResolvedValue({ id: 1, name: 'John' })
    
    const result = await mockFn()
    expect(result).toEqual({ id: 1, name: 'John' })
  })
  
  it('should mock rejected promises', async () => {
    const mockFn = vi.fn()
    mockFn.mockRejectedValue(new Error('Network error'))
    
    await expect(mockFn()).rejects.toThrow('Network error')
  })
  
  it('should handle async sequences', async () => {
    const mockFn = vi.fn()
    
    mockFn
      .mockResolvedValueOnce({ status: 'pending' })
      .mockResolvedValueOnce({ status: 'processing' })
      .mockResolvedValueOnce({ status: 'complete' })
    
    expect(await mockFn()).toEqual({ status: 'pending' })
    expect(await mockFn()).toEqual({ status: 'processing' })
    expect(await mockFn()).toEqual({ status: 'complete' })
  })
})
```

### Real-World Example: Testing Callback Functions

```typescript
// eventEmitter.ts
type EventCallback = (data: any) => void

class EventEmitter {
  private listeners: Map<string, EventCallback[]> = new Map()
  
  on(event: string, callback: EventCallback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, [])
    }
    this.listeners.get(event)!.push(callback)
  }
  
  emit(event: string, data: any) {
    const callbacks = this.listeners.get(event) || []
    callbacks.forEach(cb => cb(data))
  }
}

// eventEmitter.test.ts
describe('EventEmitter', () => {
  let emitter: EventEmitter
  
  beforeEach(() => {
    emitter = new EventEmitter()
  })
  
  it('should call listener when event is emitted', () => {
    const listener = vi.fn()
    
    emitter.on('data', listener)
    emitter.emit('data', { value: 42 })
    
    expect(listener).toHaveBeenCalledTimes(1)
    expect(listener).toHaveBeenCalledWith({ value: 42 })
  })
  
  it('should call multiple listeners', () => {
    const listener1 = vi.fn()
    const listener2 = vi.fn()
    
    emitter.on('data', listener1)
    emitter.on('data', listener2)
    emitter.emit('data', 'test')
    
    expect(listener1).toHaveBeenCalledWith('test')
    expect(listener2).toHaveBeenCalledWith('test')
  })
  
  it('should handle errors in listeners', () => {
    const errorListener = vi.fn().mockImplementation(() => {
      throw new Error('Listener error')
    })
    const successListener = vi.fn()
    
    emitter.on('data', errorListener)
    emitter.on('data', successListener)
    
    expect(() => emitter.emit('data', 'test')).toThrow('Listener error')
    expect(errorListener).toHaveBeenCalled()
  })
})
```

### Mock Function Properties

```typescript
describe('Mock function properties', () => {
  it('should track mock calls', () => {
    const mockFn = vi.fn()
    
    mockFn('arg1', 'arg2')
    mockFn('arg3')
    
    // Access call history
    expect(mockFn.mock.calls).toEqual([
      ['arg1', 'arg2'],
      ['arg3']
    ])
    
    // Access results
    expect(mockFn.mock.results).toHaveLength(2)
  })
  
  it('should track this context', () => {
    const mockFn = vi.fn()
    const obj = { method: mockFn }
    
    obj.method('test')
    
    expect(mockFn.mock.contexts[0]).toBe(obj)
  })
})
```

### Resetting and Restoring Mocks

```typescript
describe('Mock cleanup', () => {
  let mockFn: ReturnType<typeof vi.fn>
  
  beforeEach(() => {
    mockFn = vi.fn()
  })
  
  it('should clear mock call history', () => {
    mockFn('test')
    expect(mockFn).toHaveBeenCalledTimes(1)
    
    // Clear call history but keep implementation
    mockFn.mockClear()
    expect(mockFn).toHaveBeenCalledTimes(0)
  })
  
  it('should reset mock to initial state', () => {
    mockFn.mockReturnValue(42)
    mockFn('test')
    
    // Reset implementation and call history
    mockFn.mockReset()
    
    expect(mockFn()).toBeUndefined()  // No implementation
    expect(mockFn).toHaveBeenCalledTimes(1)  // Fresh call count
  })
  
  it('should restore original implementation', () => {
    const original = (x: number) => x * 2
    const mockFn = vi.fn(original)
    
    mockFn.mockImplementation((x: number) => x * 3)
    expect(mockFn(5)).toBe(15)
    
    // Restore to original
    mockFn.mockRestore()
    expect(mockFn(5)).toBe(10)
  })
})
```

---

## 3.2 Module Mocking

### Understanding Module Mocking

Module mocking replaces entire modules with mocked versions. This is useful for:
- External dependencies (axios, lodash)
- Internal modules with complex logic
- Modules with side effects

### Basic Module Mocking with vi.mock()

```typescript
// api.ts
export async function fetchUser(id: number) {
  const response = await fetch(`/api/users/${id}`)
  return response.json()
}

export function getUserName(id: number) {
  return `User ${id}`
}
```

```typescript
// userService.test.ts
import { describe, it, expect, vi } from 'vitest'
import { fetchUser, getUserName } from './api'

// Mock the entire module
vi.mock('./api', () => ({
  fetchUser: vi.fn(),
  getUserName: vi.fn()
}))

describe('Module mocking', () => {
  it('should use mocked fetchUser', async () => {
    // Configure the mock
    vi.mocked(fetchUser).mockResolvedValue({ id: 1, name: 'John' })
    
    const user = await fetchUser(1)
    
    expect(user).toEqual({ id: 1, name: 'John' })
    expect(fetchUser).toHaveBeenCalledWith(1)
  })
})
```

### Partial Module Mocking

```typescript
// utils.ts
export function add(a: number, b: number) {
  return a + b
}

export function multiply(a: number, b: number) {
  return a * b
}

export function complexCalculation(x: number) {
  // Complex logic we want to mock
  return Math.sqrt(x) * Math.PI
}
```

```typescript
// test.ts
import { describe, it, expect, vi } from 'vitest'

// Mock only specific exports
vi.mock('./utils', async (importOriginal) => {
  const actual = await importOriginal<typeof import('./utils')>()
  
  return {
    ...actual,  // Keep original implementations
    complexCalculation: vi.fn()  // Mock only this
  }
})

import { add, multiply, complexCalculation } from './utils'

describe('Partial mocking', () => {
  it('should use real add function', () => {
    expect(add(2, 3)).toBe(5)  // Real implementation
  })
  
  it('should use real multiply function', () => {
    expect(multiply(2, 3)).toBe(6)  // Real implementation
  })
  
  it('should use mocked complexCalculation', () => {
    vi.mocked(complexCalculation).mockReturnValue(100)
    expect(complexCalculation(10)).toBe(100)  // Mocked
  })
})
```

### Mocking External Dependencies

```typescript
// userService.ts
import axios from 'axios'

export class UserService {
  async getUser(id: number) {
    const response = await axios.get(`/api/users/${id}`)
    return response.data
  }
  
  async createUser(data: any) {
    const response = await axios.post('/api/users', data)
    return response.data
  }
}
```

```typescript
// userService.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import axios from 'axios'
import { UserService } from './userService'

// Mock axios module
vi.mock('axios')

describe('UserService', () => {
  let service: UserService
  
  beforeEach(() => {
    service = new UserService()
    vi.clearAllMocks()
  })
  
  describe('getUser', () => {
    it('should fetch user from API', async () => {
      const mockUser = { id: 1, name: 'John' }
      
      // Configure axios mock
      vi.mocked(axios.get).mockResolvedValue({
        data: mockUser,
        status: 200,
        statusText: 'OK',
        headers: {},
        config: {} as any
      })
      
      const user = await service.getUser(1)
      
      expect(user).toEqual(mockUser)
      expect(axios.get).toHaveBeenCalledWith('/api/users/1')
    })
    
    it('should handle API errors', async () => {
      vi.mocked(axios.get).mockRejectedValue(
        new Error('Network error')
      )
      
      await expect(service.getUser(1))
        .rejects
        .toThrow('Network error')
    })
  })
  
  describe('createUser', () => {
    it('should create user with correct data', async () => {
      const userData = { name: 'Jane', email: 'jane@example.com' }
      const createdUser = { id: 2, ...userData }
      
      vi.mocked(axios.post).mockResolvedValue({
        data: createdUser,
        status: 201,
        statusText: 'Created',
        headers: {},
        config: {} as any
      })
      
      const result = await service.createUser(userData)
      
      expect(result).toEqual(createdUser)
      expect(axios.post).toHaveBeenCalledWith('/api/users', userData)
    })
  })
})
```

### Factory Functions for Dynamic Mocking

```typescript
// config.ts
export const config = {
  apiUrl: 'https://api.production.com',
  timeout: 5000,
  retries: 3
}

// config.test.ts
vi.mock('./config', () => {
  // Factory function - called once when module loads
  const env = process.env.NODE_ENV
  
  return {
    config: {
      apiUrl: env === 'test' ? 'http://localhost:3000' : 'https://api.com',
      timeout: 1000,
      retries: 0
    }
  }
})
```

### Hoisting Behavior

⚠️ **Important**: `vi.mock()` is hoisted to the top of the file!

```typescript
// This code:
import { user } from './user'
vi.mock('./user')
console.log('After mock')

// Actually runs as:
vi.mock('./user')  // ← Hoisted to top!
import { user } from './user'
console.log('After mock')
```

**Why it matters:**
```typescript
// ❌ WRONG - Variable not accessible
const mockData = { name: 'John' }

vi.mock('./api', () => ({
  getUser: vi.fn().mockReturnValue(mockData)  // Error! mockData not in scope
}))

// ✅ CORRECT - Configure in test
vi.mock('./api', () => ({
  getUser: vi.fn()
}))

import { getUser } from './api'

it('test', () => {
  vi.mocked(getUser).mockReturnValue({ name: 'John' })
})
```

---

## 3.3 Spies

### What are Spies?

**Spies** observe existing function behavior without replacing it. They let you:
- Track how a function is called
- Verify arguments passed
- Keep the original implementation

```
┌─────────────────────────────────────┐
│           MOCK                      │
├─────────────────────────────────────┤
│  Original Function → [REPLACED]     │
│  You control behavior completely    │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│            SPY                      │
├─────────────────────────────────────┤
│  Original Function → [OBSERVED]     │
│  Original runs, but you can watch   │
└─────────────────────────────────────┘
```

### Creating Spies with vi.spyOn()

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'

describe('vi.spyOn() basics', () => {
  // Object to spy on
  const calculator = {
    add(a: number, b: number) {
      return a + b
    },
    multiply(a: number, b: number) {
      return a * b
    }
  }
  
  it('should spy on method calls', () => {
    // Create spy
    const addSpy = vi.spyOn(calculator, 'add')
    
    // Call original method
    const result = calculator.add(2, 3)
    
    // Original behavior preserved
    expect(result).toBe(5)
    
    // But we can track the call
    expect(addSpy).toHaveBeenCalledWith(2, 3)
    expect(addSpy).toHaveBeenCalledTimes(1)
  })
  
  it('should spy and override implementation', () => {
    const addSpy = vi.spyOn(calculator, 'add')
    
    // Override implementation
    addSpy.mockImplementation((a, b) => a * b)
    
    // Now it multiplies instead of adds
    expect(calculator.add(2, 3)).toBe(6)
    expect(addSpy).toHaveBeenCalledWith(2, 3)
  })
})
```

### Spy Matchers

```typescript
describe('Spy matchers', () => {
  const logger = {
    log: (message: string) => console.log(message),
    error: (message: string) => console.error(message)
  }
  
  let logSpy: ReturnType<typeof vi.spyOn>
  
  beforeEach(() => {
    logSpy = vi.spyOn(logger, 'log').mockImplementation(() => {})
  })
  
  afterEach(() => {
    logSpy.mockRestore()
  })
  
  it('should verify calls', () => {
    logger.log('Hello')
    logger.log('World')
    
    // Was it called?
    expect(logSpy).toHaveBeenCalled()
    
    // How many times?
    expect(logSpy).toHaveBeenCalledTimes(2)
    
    // With what arguments?
    expect(logSpy).toHaveBeenCalledWith('Hello')
    expect(logSpy).toHaveBeenNthCalledWith(1, 'Hello')
    expect(logSpy).toHaveBeenNthCalledWith(2, 'World')
    
    // What was the last call?
    expect(logSpy).toHaveBeenLastCalledWith('World')
  })
  
  it('should verify arguments with matchers', () => {
    logger.log('User logged in: ID 12345')
    
    // Partial matching
    expect(logSpy).toHaveBeenCalledWith(
      expect.stringContaining('logged in')
    )
    
    // Regex matching
    expect(logSpy).toHaveBeenCalledWith(
      expect.stringMatching(/ID \d+/)
    )
  })
})
```

### Real-World Example: Testing Side Effects

```typescript
// storage.ts
export class LocalStorage {
  set(key: string, value: any): void {
    localStorage.setItem(key, JSON.stringify(value))
  }
  
  get(key: string): any {
    const item = localStorage.getItem(key)
    return item ? JSON.parse(item) : null
  }
  
  remove(key: string): void {
    localStorage.removeItem(key)
  }
}

// userPreferences.ts
import { LocalStorage } from './storage'

export class UserPreferences {
  private storage = new LocalStorage()
  
  saveTheme(theme: 'light' | 'dark') {
    this.storage.set('theme', theme)
  }
  
  getTheme(): 'light' | 'dark' {
    return this.storage.get('theme') || 'light'
  }
}
```

```typescript
// userPreferences.test.ts
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { UserPreferences } from './userPreferences'
import { LocalStorage } from './storage'

describe('UserPreferences', () => {
  let preferences: UserPreferences
  let setSpy: ReturnType<typeof vi.spyOn>
  let getSpy: ReturnType<typeof vi.spyOn>
  
  beforeEach(() => {
    preferences = new UserPreferences()
    
    // Spy on storage methods
    setSpy = vi.spyOn(LocalStorage.prototype, 'set')
    getSpy = vi.spyOn(LocalStorage.prototype, 'get')
  })
  
  afterEach(() => {
    vi.restoreAllMocks()
  })
  
  describe('saveTheme', () => {
    it('should save theme to storage', () => {
      preferences.saveTheme('dark')
      
      expect(setSpy).toHaveBeenCalledWith('theme', 'dark')
      expect(setSpy).toHaveBeenCalledTimes(1)
    })
  })
  
  describe('getTheme', () => {
    it('should retrieve theme from storage', () => {
      getSpy.mockReturnValue('dark')
      
      const theme = preferences.getTheme()
      
      expect(theme).toBe('dark')
      expect(getSpy).toHaveBeenCalledWith('theme')
    })
    
    it('should return default theme when none saved', () => {
      getSpy.mockReturnValue(null)
      
      const theme = preferences.getTheme()
      
      expect(theme).toBe('light')
    })
  })
})
```

### Spying on Global Objects

```typescript
describe('Global object spies', () => {
  it('should spy on console.log', () => {
    const consoleLogSpy = vi.spyOn(console, 'log')
    
    console.log('Test message')
    
    expect(consoleLogSpy).toHaveBeenCalledWith('Test message')
    
    consoleLogSpy.mockRestore()
  })
  
  it('should spy on window methods', () => {
    const alertSpy = vi.spyOn(window, 'alert').mockImplementation(() => {})
    
    window.alert('Warning!')
    
    expect(alertSpy).toHaveBeenCalledWith('Warning!')
    
    alertSpy.mockRestore()
  })
  
  it('should spy on Date', () => {
    const dateSpy = vi.spyOn(Date, 'now').mockReturnValue(1000000)
    
    expect(Date.now()).toBe(1000000)
    
    dateSpy.mockRestore()
  })
})
```

### Restoring Spies

```typescript
describe('Spy restoration', () => {
  const obj = {
    getValue: () => 'original'
  }
  
  it('should restore original implementation', () => {
    const spy = vi.spyOn(obj, 'getValue')
    spy.mockReturnValue('mocked')
    
    expect(obj.getValue()).toBe('mocked')
    
    // Restore original
    spy.mockRestore()
    
    expect(obj.getValue()).toBe('original')
  })
  
  it('should restore all mocks at once', () => {
    vi.spyOn(obj, 'getValue').mockReturnValue('mocked')
    vi.spyOn(console, 'log')
    
    // Restore all at once
    vi.restoreAllMocks()
    
    expect(obj.getValue()).toBe('original')
  })
})
```

---

## 3.4 Timers & Dates

### Why Mock Time?

Real time makes tests:
- **Slow**: Waiting for timeouts
- **Flaky**: Race conditions
- **Unpredictable**: Tests depend on when they run

### Fake Timers

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'

describe('Fake timers', () => {
  beforeEach(() => {
    vi.useFakeTimers()
  })
  
  afterEach(() => {
    vi.restoreAllMocks()
  })
  
  it('should fast-forward setTimeout', () => {
    const callback = vi.fn()
    
    setTimeout(callback, 1000)
    
    // Time hasn't passed yet
    expect(callback).not.toHaveBeenCalled()
    
    // Fast-forward 1000ms
    vi.advanceTimersByTime(1000)
    
    expect(callback).toHaveBeenCalledTimes(1)
  })
  
  it('should handle setInterval', () => {
    const callback = vi.fn()
    
    setInterval(callback, 100)
    
    // Fast-forward 350ms (3 intervals + 50ms)
    vi.advanceTimersByTime(350)
    
    expect(callback).toHaveBeenCalledTimes(3)
  })
  
  it('should run all timers', () => {
    const callback1 = vi.fn()
    const callback2 = vi.fn()
    
    setTimeout(callback1, 1000)
    setTimeout(callback2, 5000)
    
    // Run all pending timers
    vi.runAllTimers()
    
    expect(callback1).toHaveBeenCalled()
    expect(callback2).toHaveBeenCalled()
  })
})
```

### Real-World Example: Debounce Function

```typescript
// debounce.ts
export function debounce<T extends (...args: any[]) => any>(
  fn: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timeoutId: NodeJS.Timeout
  
  return function(...args: Parameters<T>) {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => fn(...args), delay)
  }
}

// debounce.test.ts
describe('Debounce', () => {
  beforeEach(() => {
    vi.useFakeTimers()
  })
  
  afterEach(() => {
    vi.restoreAllMocks()
  })
  
  it('should delay function execution', () => {
    const callback = vi.fn()
    const debounced = debounce(callback, 500)
    
    debounced('test')
    
    // Not called immediately
    expect(callback).not.toHaveBeenCalled()
    
    // Called after delay
    vi.advanceTimersByTime(500)
    expect(callback).toHaveBeenCalledWith('test')
    expect(callback).toHaveBeenCalledTimes(1)
  })
  
  it('should reset timer on multiple calls', () => {
    const callback = vi.fn()
    const debounced = debounce(callback, 500)
    
    debounced('call1')
    vi.advanceTimersByTime(200)  // 200ms passed
    
    debounced('call2')  // Resets timer
    vi.advanceTimersByTime(200)  // 400ms total
    
    // Still not called (timer was reset)
    expect(callback).not.toHaveBeenCalled()
    
    vi.advanceTimersByTime(300)  // 700ms total, 500ms since last call
    
    // Now called with last argument
    expect(callback).toHaveBeenCalledTimes(1)
    expect(callback).toHaveBeenCalledWith('call2')
  })
})
```

### Mocking Dates

```typescript
describe('Date mocking', () => {
  beforeEach(() => {
    vi.useFakeTimers()
  })
  
  afterEach(() => {
    vi.restoreAllMocks()
  })
  
  it('should set system time', () => {
    const mockDate = new Date('2024-01-01T00:00:00.000Z')
    vi.setSystemTime(mockDate)
    
    expect(new Date().toISOString()).toBe('2024-01-01T00:00:00.000Z')
    expect(Date.now()).toBe(mockDate.getTime())
  })
  
  it('should test age calculation', () => {
    vi.setSystemTime(new Date('2024-01-01'))
    
    function getAge(birthDate: Date): number {
      const today = new Date()
      const age = today.getFullYear() - birthDate.getFullYear()
      return age
    }
    
    const birthDate = new Date('1990-06-15')
    expect(getAge(birthDate)).toBe(34)
  })
})
```

### Testing Async Code with Timers

```typescript
describe('Async with timers', () => {
  beforeEach(() => {
    vi.useFakeTimers()
  })
  
  afterEach(() => {
    vi.restoreAllMocks()
  })
  
  it('should handle promises with setTimeout', async () => {
    function delayedResolve(value: string, delay: number) {
      return new Promise(resolve => {
        setTimeout(() => resolve(value), delay)
      })
    }
    
    const promise = delayedResolve('result', 1000)
    
    // Advance time
    vi.advanceTimersByTime(1000)
    
    // Wait for promise
    await expect(promise).resolves.toBe('result')
  })
})
```

---

## 3.5 Mocking Best Practices

### 1. Mock at the Boundary

```typescript
// ❌ BAD - Mocking internal functions
// userService.ts
import { validateEmail } from './validators'

export function registerUser(email: string) {
  if (!validateEmail(email)) throw new Error('Invalid')
  // ...
}

// userService.test.ts
vi.mock('./validators')  // Don't mock internal utils


// ✅ GOOD - Mock external dependencies
// userService.ts
import axios from 'axios'

export async function registerUser(email: string) {
  const response = await axios.post('/users', { email })
  return response.data
}

// userService.test.ts
vi.mock('axios')  // Mock the boundary (API)
```

### 2. Avoid Over-Mocking

```typescript
// ❌ BAD - Too many mocks
describe('ProcessOrder', () => {
  vi.mock('./validators')
  vi.mock('./formatters')
  vi.mock('./calculators')
  vi.mock('./utils')
  // Testing implementation, not behavior
})

// ✅ GOOD - Mock only external dependencies
describe('ProcessOrder', () => {
  vi.mock('./api')
  vi.mock('./database')
  // Test behavior with real internal logic
})
```

### 3. Clean Up Mocks

```typescript
describe('Tests with cleanup', () => {
  beforeEach(() => {
    vi.clearAllMocks()  // Clear call history
  })
  
  afterEach(() => {
    vi.restoreAllMocks()  // Restore implementations
  })
  
  // Tests here...
})
```

### 4. Use Descriptive Mock Data

```typescript
// ❌ BAD - Magic values
mockFn.mockReturnValue({ id: 1, name: 'John' })

// ✅ GOOD - Named constants
const MOCK_USER = {
  id: 1,
  name: 'John Doe',
  email: 'john@example.com',
  role: 'user'
}

mockFn.mockReturnValue(MOCK_USER)
```

### 5. Test Both Success and Failure

```typescript
describe('API calls', () => {
  it('should handle successful response', async () => {
    vi.mocked(api.fetchUser).mockResolvedValue({ id: 1, name: 'John' })
    // test success case
  })
  
  it('should handle network error', async () => {
    vi.mocked(api.fetchUser).mockRejectedValue(new Error('Network error'))
    // test error case
  })
  
  it('should handle 404 error', async () => {
    vi.mocked(api.fetchUser).mockRejectedValue(new Error('Not found'))
    // test 404 case
  })
})
```

---

## Summary: Chapter 3

### Key Concepts

1. **Mocks** (`vi.fn()`): Replace functions with controlled test doubles
2. **Module Mocks** (`vi.mock()`): Replace entire modules
3. **Spies** (`vi.spyOn()`): Observe existing functions
4. **Timers**: Control time in tests (`vi.useFakeTimers()`)

### Mock vs Spy Decision Tree

```
Do you want to keep original implementation?
  ├─ Yes → Use vi.spyOn()
  │   └─ Track calls while maintaining behavior
  │
  └─ No  → Use vi.fn() or vi.mock()
      └─ Replace with controlled test double
```

### Essential Commands

```typescript
// Function mocks
const mock = vi.fn()
mock.mockReturnValue(value)
mock.mockResolvedValue(value)
mock.mockImplementation(fn)

// Module mocks
vi.mock('./module')
vi.mock('./module', () => ({ ... }))

// Spies
const spy = vi.spyOn(obj, 'method')
spy.mockRestore()

// Timers
vi.useFakeTimers()
vi.advanceTimersByTime(ms)
vi.setSystemTime(date)
vi.useRealTimers()

// Cleanup
vi.clearAllMocks()
vi.resetAllMocks()
vi.restoreAllMocks()
```

### Best Practices Checklist

- ✅ Mock at boundaries (APIs, databases)
- ✅ Clean up mocks in afterEach
- ✅ Test both success and failure cases
- ✅ Use descriptive mock data
- ✅ Restore spies after use
- ✅ Always restore timers
- ❌ Don't over-mock internal logic
- ❌ Don't forget to configure mocks before use
- ❌ Don't leave fake timers active

---

**You've completed Chapters 1-3!** You now have a solid foundation in:
- Setting up and running Vitest
- Writing assertions with various matchers
- Testing async code
- Using lifecycle hooks
- Creating mocks, spies, and controlling time

These skills are essential for both production development and technical interviews. Practice by writing tests for real projects to solidify your understanding!