# Chapter 2: Core Testing Concepts - Complete Guide

## 2.1 Assertions & Matchers

### Understanding Assertions

An **assertion** is a statement that verifies whether a condition is true. In testing, assertions check if your code behaves as expected. Vitest uses the `expect()` function to create assertions with **matchers**.

```typescript
// Anatomy of an assertion
expect(actualValue).toBe(expectedValue)
//  ‚Üë       ‚Üë         ‚Üë         ‚Üë
// 1. expect() - Creates expectation object
// 2. actualValue - Value to test
// 3. toBe() - Matcher function
// 4. expectedValue - Expected result
```

---

### Equality Matchers

#### `toBe()` - Reference Equality

Uses `Object.is()` for comparison. Best for **primitives** and **checking object references**.

```typescript
import { describe, it, expect } from 'vitest'

describe('toBe() matcher', () => {
  it('should compare primitive values', () => {
    expect(2 + 2).toBe(4)
    expect('hello').toBe('hello')
    expect(true).toBe(true)
    expect(null).toBe(null)
    expect(undefined).toBe(undefined)
  })
  
  it('should compare object references', () => {
    const obj = { name: 'John' }
    const sameRef = obj
    const differentObj = { name: 'John' }
    
    expect(obj).toBe(sameRef)        // ‚úÖ Same reference
    expect(obj).not.toBe(differentObj) // ‚úÖ Different references
  })
  
  it('demonstrates special cases', () => {
    // Object.is differences from ===
    expect(+0).not.toBe(-0)          // Object.is treats +0 and -0 as different
    expect(NaN).toBe(NaN)            // Object.is treats NaN as equal to itself
  })
})
```

#### `toEqual()` - Deep Equality

Recursively checks all properties. Best for **objects** and **arrays**.

```typescript
describe('toEqual() matcher', () => {
  it('should compare objects deeply', () => {
    const user1 = { name: 'John', age: 30 }
    const user2 = { name: 'John', age: 30 }
    
    expect(user1).toEqual(user2)     // ‚úÖ Same structure and values
    expect(user1).not.toBe(user2)    // ‚úÖ Different references
  })
  
  it('should compare arrays', () => {
    const arr1 = [1, 2, 3]
    const arr2 = [1, 2, 3]
    
    expect(arr1).toEqual(arr2)
    expect(arr1).not.toBe(arr2)
  })
  
  it('should compare nested structures', () => {
    const data = {
      user: { name: 'John', posts: [1, 2, 3] },
      meta: { created: '2024-01-01' }
    }
    
    expect(data).toEqual({
      user: { name: 'John', posts: [1, 2, 3] },
      meta: { created: '2024-01-01' }
    })
  })
})
```

#### `toStrictEqual()` - Strict Deep Equality

Like `toEqual()` but stricter - checks undefined properties and array sparseness.

```typescript
describe('toStrictEqual() matcher', () => {
  it('should detect undefined properties', () => {
    const obj1 = { a: 1, b: undefined }
    const obj2 = { a: 1 }
    
    expect(obj1).toEqual(obj2)           // ‚úÖ toEqual ignores undefined
    expect(obj1).not.toStrictEqual(obj2) // ‚úÖ toStrictEqual catches it
  })
  
  it('should detect sparse arrays', () => {
    const arr1 = [1, , 3] // Sparse array (empty slot)
    const arr2 = [1, undefined, 3]
    
    expect(arr1).toEqual(arr2)           // ‚úÖ toEqual treats them same
    expect(arr1).not.toStrictEqual(arr2) // ‚úÖ toStrictEqual sees difference
  })
  
  it('should check class instances', () => {
    class User { constructor(public name: string) {} }
    
    const user1 = new User('John')
    const user2 = { name: 'John' }
    
    expect(user1).toEqual(user2)           // ‚úÖ Same shape
    expect(user1).not.toStrictEqual(user2) // ‚úÖ Different types
  })
})
```

**Decision Tree:**
```
Need to compare values?
  ‚îú‚îÄ Primitives (numbers, strings, booleans)
  ‚îÇ   ‚îî‚îÄ Use toBe()
  ‚îÇ
  ‚îú‚îÄ Objects/Arrays (structure)
  ‚îÇ   ‚îú‚îÄ Care about undefined properties?
  ‚îÇ   ‚îÇ   ‚îú‚îÄ Yes ‚Üí Use toStrictEqual()
  ‚îÇ   ‚îÇ   ‚îî‚îÄ No  ‚Üí Use toEqual()
  ‚îÇ   ‚îî‚îÄ Checking same reference?
  ‚îÇ       ‚îî‚îÄ Use toBe()
  ‚îî‚îÄ Special cases (NaN, +0/-0)
      ‚îî‚îÄ Use toBe()
```

---

### Truthiness Matchers

```typescript
describe('Truthiness matchers', () => {
  // toBeTruthy() - Checks if value is truthy (!!value === true)
  it('should validate truthy values', () => {
    expect(1).toBeTruthy()
    expect('hello').toBeTruthy()
    expect(true).toBeTruthy()
    expect({}).toBeTruthy()
    expect([]).toBeTruthy()
  })
  
  // toBeFalsy() - Checks if value is falsy (!!value === false)
  it('should validate falsy values', () => {
    expect(0).toBeFalsy()
    expect('').toBeFalsy()
    expect(false).toBeFalsy()
    expect(null).toBeFalsy()
    expect(undefined).toBeFalsy()
    expect(NaN).toBeFalsy()
  })
  
  // Specific null/undefined checks
  it('should check for null', () => {
    const value = null
    expect(value).toBeNull()
    expect(value).not.toBeUndefined()
  })
  
  it('should check for undefined', () => {
    const value = undefined
    expect(value).toBeUndefined()
    expect(value).not.toBeNull()
  })
  
  it('should check for defined values', () => {
    const value = 0  // Falsy but defined!
    expect(value).toBeDefined()
    expect(value).toBeFalsy()
  })
})
```

**Use Cases:**
```typescript
// ‚úÖ Good - Checking explicit values
function getUser(id: string) {
  return id ? { id, name: 'John' } : null
}

it('should return null for empty id', () => {
  expect(getUser('')).toBeNull()  // Specific check
})

// ‚úÖ Good - Checking existence
function hasPermission(user: User | undefined) {
  return !!user?.isAdmin
}

it('should return falsy for undefined user', () => {
  expect(hasPermission(undefined)).toBeFalsy()
})
```

---

### Number Matchers

```typescript
describe('Number matchers', () => {
  it('should compare numbers with greater than', () => {
    const score = 85
    expect(score).toBeGreaterThan(80)
    expect(score).toBeGreaterThanOrEqual(85)
  })
  
  it('should compare numbers with less than', () => {
    const age = 25
    expect(age).toBeLessThan(30)
    expect(age).toBeLessThanOrEqual(25)
  })
  
  // toBeCloseTo() - For floating point comparisons
  it('should handle floating point precision', () => {
    const result = 0.1 + 0.2
    
    // ‚ùå This fails due to floating point precision
    // expect(result).toBe(0.3)  // 0.30000000000000004 !== 0.3
    
    // ‚úÖ Use toBeCloseTo() instead
    expect(result).toBeCloseTo(0.3)        // Default: 2 decimal places
    expect(result).toBeCloseTo(0.3, 5)     // Check 5 decimal places
  })
  
  it('should validate number ranges', () => {
    const temperature = 22.5
    
    expect(temperature).toBeGreaterThan(20)
    expect(temperature).toBeLessThan(25)
    expect(temperature).toBeCloseTo(22.5, 1)
  })
})
```

**Real-World Example:**
```typescript
// Testing a discount calculator
function calculateDiscount(price: number, discountPercent: number): number {
  return price * (1 - discountPercent / 100)
}

describe('Discount Calculator', () => {
  it('should calculate 10% discount correctly', () => {
    const finalPrice = calculateDiscount(100, 10)
    expect(finalPrice).toBeCloseTo(90, 2)
  })
  
  it('should handle floating point discounts', () => {
    const finalPrice = calculateDiscount(99.99, 15.5)
    // 99.99 * 0.845 = 84.49155
    expect(finalPrice).toBeCloseTo(84.49, 2)
  })
})
```

---

### String Matchers

```typescript
describe('String matchers', () => {
  // toMatch() - RegExp or substring matching
  it('should match with regular expressions', () => {
    const email = 'user@example.com'
    
    expect(email).toMatch(/\w+@\w+\.\w+/)
    expect(email).toMatch('@example.com')
  })
  
  // toContain() - Substring check
  it('should check if string contains substring', () => {
    const message = 'Hello, World!'
    
    expect(message).toContain('World')
    expect(message).toContain('Hello')
    expect(message).not.toContain('Goodbye')
  })
  
  // Case sensitivity
  it('should be case sensitive by default', () => {
    const text = 'JavaScript'
    
    expect(text).toContain('Java')
    expect(text).not.toContain('java')  // Case sensitive!
    
    // For case-insensitive, use regex
    expect(text.toLowerCase()).toContain('java')
  })
})
```

**Practical Examples:**
```typescript
// Validating user input
describe('Email Validation', () => {
  const validEmail = 'john.doe@company.com'
  const invalidEmail = 'notanemail'
  
  it('should validate email format', () => {
    expect(validEmail).toMatch(/^[\w.-]+@[\w.-]+\.\w+$/)
    expect(invalidEmail).not.toMatch(/^[\w.-]+@[\w.-]+\.\w+$/)
  })
  
  it('should contain @ symbol', () => {
    expect(validEmail).toContain('@')
    expect(invalidEmail).not.toContain('@')
  })
})

// Testing error messages
describe('Error Messages', () => {
  it('should contain helpful error info', () => {
    const error = new Error('User not found: ID 12345')
    
    expect(error.message).toContain('User not found')
    expect(error.message).toMatch(/ID \d+/)
    expect(error.message).toContain('12345')
  })
})
```

---

### Array and Object Matchers

```typescript
describe('Array matchers', () => {
  const fruits = ['apple', 'banana', 'cherry']
  
  // toContain() - Check if array contains value
  it('should check array contains value', () => {
    expect(fruits).toContain('banana')
    expect(fruits).not.toContain('grape')
  })
  
  // toHaveLength() - Check array length
  it('should check array length', () => {
    expect(fruits).toHaveLength(3)
    expect([]).toHaveLength(0)
  })
  
  // toContainEqual() - Deep equality check for objects
  it('should check if array contains object', () => {
    const users = [
      { id: 1, name: 'John' },
      { id: 2, name: 'Jane' }
    ]
    
    expect(users).toContainEqual({ id: 1, name: 'John' })
  })
})

describe('Object matchers', () => {
  const user = {
    id: 1,
    name: 'John',
    email: 'john@example.com',
    role: 'admin'
  }
  
  // toHaveProperty() - Check if property exists
  it('should check property existence', () => {
    expect(user).toHaveProperty('name')
    expect(user).toHaveProperty('email', 'john@example.com')
    expect(user).not.toHaveProperty('password')
  })
  
  // toMatchObject() - Partial object matching
  it('should match subset of object', () => {
    expect(user).toMatchObject({
      name: 'John',
      role: 'admin'
    })
    // Note: Other properties (id, email) are ignored
  })
  
  // Nested property checking
  it('should check nested properties', () => {
    const config = {
      database: {
        host: 'localhost',
        port: 5432
      }
    }
    
    expect(config).toHaveProperty('database.host', 'localhost')
    expect(config).toHaveProperty('database.port')
  })
})
```

---

### Exception Matchers

```typescript
describe('Exception matchers', () => {
  // Functions that throw
  function divide(a: number, b: number) {
    if (b === 0) throw new Error('Division by zero')
    return a / b
  }
  
  // toThrow() - Check if function throws
  it('should throw error for division by zero', () => {
    // ‚ö†Ô∏è IMPORTANT: Wrap in arrow function!
    expect(() => divide(10, 0)).toThrow()
    
    // ‚ùå WRONG - This executes immediately
    // expect(divide(10, 0)).toThrow()
  })
  
  // toThrow() with specific error message
  it('should throw with specific message', () => {
    expect(() => divide(10, 0)).toThrow('Division by zero')
    expect(() => divide(10, 0)).toThrow(/division/i)
  })
  
  // toThrowError() - Same as toThrow()
  it('should throw specific error type', () => {
    class ValidationError extends Error {}
    
    function validateAge(age: number) {
      if (age < 0) throw new ValidationError('Invalid age')
      return age
    }
    
    expect(() => validateAge(-1)).toThrowError(ValidationError)
    expect(() => validateAge(-1)).toThrowError('Invalid age')
  })
})
```

**Common Mistakes:**
```typescript
describe('Common Exception Testing Mistakes', () => {
  function throwError() {
    throw new Error('Boom!')
  }
  
  it('‚ùå WRONG - Function executes immediately', () => {
    // This will fail the test immediately, not in expect()
    // expect(throwError()).toThrow()
  })
  
  it('‚úÖ CORRECT - Wrap in arrow function', () => {
    expect(() => throwError()).toThrow()
  })
  
  it('‚úÖ CORRECT - For async functions', async () => {
    async function asyncThrow() {
      throw new Error('Async boom!')
    }
    
    await expect(asyncThrow()).rejects.toThrow('Async boom!')
  })
})
```

---

## 2.2 Async Testing

### The Challenge of Async Code

```typescript
// ‚ùå WRONG - Test completes before async operation
it('fetches user data', () => {
  fetchUser(1).then(user => {
    expect(user.name).toBe('John')
  })
})
// Test passes even if assertion fails!
```

### Method 1: Async/Await (Recommended)

```typescript
describe('Async/Await Pattern', () => {
  async function fetchUser(id: number) {
    const response = await fetch(`/api/users/${id}`)
    return response.json()
  }
  
  // ‚úÖ CORRECT - Use async/await
  it('should fetch user data', async () => {
    const user = await fetchUser(1)
    expect(user.name).toBe('John')
    expect(user.id).toBe(1)
  })
  
  // Multiple async operations
  it('should fetch multiple users', async () => {
    const [user1, user2] = await Promise.all([
      fetchUser(1),
      fetchUser(2)
    ])
    
    expect(user1.name).toBe('John')
    expect(user2.name).toBe('Jane')
  })
})
```

### Method 2: Resolves/Rejects Matchers

```typescript
describe('Resolves/Rejects Pattern', () => {
  async function fetchUser(id: number) {
    if (id < 0) throw new Error('Invalid ID')
    return { id, name: 'John' }
  }
  
  // Testing successful promises
  it('should resolve with user data', async () => {
    await expect(fetchUser(1)).resolves.toEqual({
      id: 1,
      name: 'John'
    })
  })
  
  // Testing rejected promises
  it('should reject for invalid ID', async () => {
    await expect(fetchUser(-1)).rejects.toThrow('Invalid ID')
  })
  
  // Chaining matchers
  it('should resolve with correct properties', async () => {
    await expect(fetchUser(1)).resolves.toHaveProperty('name', 'John')
  })
})
```

### Method 3: Return Promise (Legacy)

```typescript
describe('Return Promise Pattern', () => {
  // ‚úÖ CORRECT - Return the promise
  it('should fetch user', () => {
    return fetchUser(1).then(user => {
      expect(user.name).toBe('John')
    })
  })
  
  // ‚ùå WRONG - Not returning promise
  it('will pass incorrectly', () => {
    fetchUser(1).then(user => {
      expect(user.name).toBe('Wrong')
    })
  })
})
```

### Real-World Example: API Testing

```typescript
// api.ts
export class UserAPI {
  async getUser(id: number): Promise<User> {
    const response = await fetch(`/api/users/${id}`)
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`)
    }
    return response.json()
  }
  
  async createUser(data: CreateUserDto): Promise<User> {
    const response = await fetch('/api/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    })
    return response.json()
  }
}

// api.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { UserAPI } from './api'

describe('UserAPI', () => {
  let api: UserAPI
  
  beforeEach(() => {
    api = new UserAPI()
    global.fetch = vi.fn()
  })
  
  describe('getUser', () => {
    it('should fetch user successfully', async () => {
      const mockUser = { id: 1, name: 'John' }
      
      vi.mocked(fetch).mockResolvedValue({
        ok: true,
        json: async () => mockUser
      } as Response)
      
      const user = await api.getUser(1)
      
      expect(user).toEqual(mockUser)
      expect(fetch).toHaveBeenCalledWith('/api/users/1')
    })
    
    it('should throw error for failed request', async () => {
      vi.mocked(fetch).mockResolvedValue({
        ok: false,
        status: 404
      } as Response)
      
      await expect(api.getUser(999))
        .rejects
        .toThrow('HTTP 404')
    })
  })
  
  describe('createUser', () => {
    it('should create user with correct data', async () => {
      const userData = { name: 'Jane', email: 'jane@example.com' }
      const createdUser = { id: 2, ...userData }
      
      vi.mocked(fetch).mockResolvedValue({
        ok: true,
        json: async () => createdUser
      } as Response)
      
      const result = await api.createUser(userData)
      
      expect(result).toEqual(createdUser)
      expect(fetch).toHaveBeenCalledWith(
        '/api/users',
        expect.objectContaining({
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(userData)
        })
      )
    })
  })
})
```

### Async Testing Best Practices

```typescript
// ‚úÖ DO: Always await or return promises
it('correct async test', async () => {
  const result = await asyncOperation()
  expect(result).toBe('expected')
})

// ‚úÖ DO: Use resolves/rejects for cleaner code
it('correct with resolves', async () => {
  await expect(asyncOperation()).resolves.toBe('expected')
})

// ‚ùå DON'T: Forget to await
it('incorrect async test', async () => {
  const result = asyncOperation()  // Missing await!
  expect(result).toBe('expected')   // Testing Promise object
})

// ‚ùå DON'T: Mix patterns unnecessarily
it('confusing test', async () => {
  return asyncOperation().then(result => {
    expect(result).toBe('expected')
  })
})
```

---

## 2.3 Setup and Teardown

### Understanding Test Lifecycle

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       beforeAll()                   ‚îÇ  ‚Üê Runs ONCE before all tests
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ    beforeEach()             ‚îÇ  ‚Üê Runs before EACH test
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ    it('test 1')             ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ    afterEach()              ‚îÇ  ‚Üê Runs after EACH test
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ    beforeEach()             ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ    it('test 2')             ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ    afterEach()              ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       afterAll()                    ‚îÇ  ‚Üê Runs ONCE after all tests
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### beforeEach() and afterEach()

```typescript
describe('Shopping Cart', () => {
  let cart: ShoppingCart
  
  // Setup: Runs before EACH test
  beforeEach(() => {
    cart = new ShoppingCart()
    console.log('üîß Setting up cart')
  })
  
  // Cleanup: Runs after EACH test
  afterEach(() => {
    cart.clear()
    console.log('üßπ Cleaning up cart')
  })
  
  it('should start empty', () => {
    expect(cart.items).toHaveLength(0)
  })
  
  it('should add items', () => {
    cart.addItem({ id: 1, name: 'Book', price: 10 })
    expect(cart.items).toHaveLength(1)
  })
})

// Output:
// üîß Setting up cart
// ‚úì should start empty
// üßπ Cleaning up cart
// üîß Setting up cart
// ‚úì should add items
// üßπ Cleaning up cart
```

### beforeAll() and afterAll()

```typescript
describe('Database Tests', () => {
  let db: Database
  
  // Setup: Runs ONCE before all tests
  beforeAll(async () => {
    db = await Database.connect()
    await db.migrate()
    console.log('üì¶ Database connected')
  })
  
  // Cleanup: Runs ONCE after all tests
  afterAll(async () => {
    await db.close()
    console.log('üì¶ Database disconnected')
  })
  
  // Each test uses the same db connection
  it('should insert user', async () => {
    await db.users.insert({ name: 'John' })
    expect(await db.users.count()).toBe(1)
  })
  
  it('should find user', async () => {
    const user = await db.users.findOne({ name: 'John' })
    expect(user).toBeDefined()
  })
})
```

### Execution Order with Nesting

```typescript
describe('Outer Suite', () => {
  beforeAll(() => console.log('1. Outer beforeAll'))
  afterAll(() => console.log('6. Outer afterAll'))
  beforeEach(() => console.log('2. Outer beforeEach'))
  afterEach(() => console.log('5. Outer afterEach'))
  
  it('outer test', () => {
    console.log('3. Outer test')
  })
  
  describe('Inner Suite', () => {
    beforeAll(() => console.log('  1a. Inner beforeAll'))
    afterAll(() => console.log('  6a. Inner afterAll'))
    beforeEach(() => console.log('  2a. Inner beforeEach'))
    afterEach(() => console.log('  5a. Inner afterEach'))
    
    it('inner test', () => {
      console.log('  3a. Inner test')
    })
  })
})

// Output:
// 1. Outer beforeAll
// 2. Outer beforeEach
// 3. Outer test
// 5. Outer afterEach
//   1a. Inner beforeAll
// 2. Outer beforeEach
//   2a. Inner beforeEach
//   3a. Inner test
//   5a. Inner afterEach
// 5. Outer afterEach
//   6a. Inner afterAll
// 6. Outer afterAll
```

### Real-World Example: E-commerce Testing

```typescript
describe('E-commerce System', () => {
  let database: Database
  let apiClient: APIClient
  let testUser: User
  
  // Connect to database once
  beforeAll(async () => {
    database = await Database.connect(TEST_DB_URL)
    await database.migrate()
  })
  
  // Disconnect once at the end
  afterAll(async () => {
    await database.close()
  })
  
  // Create fresh API client for each test
  beforeEach(async () => {
    apiClient = new APIClient()
    testUser = await database.users.create({
      email: 'test@example.com',
      password: 'password123'
    })
  })
  
  // Clean up test data after each test
  afterEach(async () => {
    await database.users.deleteAll()
    await database.orders.deleteAll()
    apiClient.destroy()
  })
  
  describe('Order Creation', () => {
    let authToken: string
    
    // Login before tests in this suite
    beforeEach(async () => {
      authToken = await apiClient.login(testUser.email, 'password123')
    })
    
    it('should create order with valid items', async () => {
      const order = await apiClient.createOrder({
        items: [{ productId: 1, quantity: 2 }],
        token: authToken
      })
      
      expect(order).toHaveProperty('id')
      expect(order.items).toHaveLength(1)
    })
    
    it('should reject order without authentication', async () => {
      await expect(
        apiClient.createOrder({
          items: [{ productId: 1, quantity: 2 }]
        })
      ).rejects.toThrow('Unauthorized')
    })
  })
})
```

---

## 2.4 Test Filtering

### Using .only() - Run Specific Tests

```typescript
describe('Math Operations', () => {
  it('should add numbers', () => {
    expect(1 + 1).toBe(2)
  })
  
  // Only this test will run
  it.only('should subtract numbers', () => {
    expect(5 - 3).toBe(2)
  })
  
  it('should multiply numbers', () => {
    expect(2 * 3).toBe(6)
  })
})

// Can also use on describe blocks
describe.only('Only This Suite', () => {
  // All tests in this suite run
  it('test 1', () => {})
  it('test 2', () => {})
})
```

‚ö†Ô∏è **Warning**: Never commit `.only()` to version control!

### Using .skip() - Skip Tests

```typescript
describe('Feature Tests', () => {
  it('working test', () => {
    expect(true).toBe(true)
  })
  
  // This test will be skipped
  it.skip('broken test', () => {
    expect(brokenFunction()).toBe('something')
  })
  
  // Skip entire suite
  describe.skip('Broken Feature', () => {
    it('test 1', () => {})
    it('test 2', () => {})
  })
})
```

**Better Alternative**: Use `.todo()` for unimplemented tests

```typescript
describe('Future Features', () => {
  it.todo('should implement user authentication')
  it.todo('should add payment processing')
  
  // This shows in test output as "todo"
})
```

### Conditional Testing

```typescript
import { it, describe } from 'vitest'

describe('Platform-specific tests', () => {
  // Run only on specific platform
  const itLinux = process.platform === 'linux' ? it : it.skip
  const itWindows = process.platform === 'win32' ? it : it.skip
  
  itLinux('should run on Linux', () => {
    // Linux-specific test
  })
  
  itWindows('should run on Windows', () => {
    // Windows-specific test
  })
  
  // Environment-based
  const itProduction = process.env.NODE_ENV === 'production' ? it : it.skip
  
  itProduction('should use production API', () => {
    // Only runs in production
  })
})
```

---

## Summary: Chapter 2 Key Concepts

### Matchers Quick Reference

| Category | Matcher | Use Case |
|----------|---------|----------|
| **Equality** | `toBe()` | Primitives, references |
| | `toEqual()` | Objects, arrays (deep) |
| | `toStrictEqual()` | Strict deep equality |
| **Truthiness** | `toBeTruthy()` | Truthy values |
| | `toBeFalsy()` | Falsy values |
| | `toBeNull()` | Specifically null |
| | `toBeUndefined()` | Specifically undefined |
| **Numbers** | `toBeGreaterThan()` | Numeric comparisons |
| | `toBeLessThan()` | Numeric comparisons |
| | `toBeCloseTo()` | Floating point |
| **Strings** | `toMatch()` | Regex matching |
| | `toContain()` | Substring |
| **Arrays** | `toContain()` | Has value |
| | `toHaveLength()` | Array length |
| | `toContainEqual()` | Has object (deep) |
| **Objects** | `toHaveProperty()` | Has property |
| | `toMatchObject()` | Subset match |
| **Exceptions** | `toThrow()` | Throws error |
| **Async** | `resolves` | Promise resolves |
| | `rejects` | Promise rejects |

### Best Practices Checklist

- ‚úÖ Use `toBe()` for primitives, `toEqual()` for objects
- ‚úÖ Always `await` or return promises in async tests
- ‚úÖ Use `beforeEach()`/`afterEach()` for test isolation
- ‚úÖ Clean up resources in `afterEach()` or `afterAll()`
- ‚úÖ Use `toBeCloseTo()` for floating point numbers
- ‚úÖ Wrap functions in arrow functions when testing throws
- ‚ùå Never commit `.only()` or `.skip()` without good reason
- ‚ùå Don't forget to `await` async expectations

**Next Chapter Preview**: In Chapter 3, we'll master mocking and spies - essential for isolating units of code and controlling test environments.