# Complete Vitest Mastery Guide: Beginner to Advanced

## Chapter 1: Fundamentals & Setup

### 1.1 What is Vitest?
- **Definition**: Fast unit test framework powered by Vite
- **Key Advantages**: Native ESM support, instant hot module reload, Vite config compatibility
- **Comparison with Jest**: API compatibility, faster execution, better ESM support

### 1.2 Installation & Configuration
- Basic installation: `npm install -D vitest`
- Config file setup: `vitest.config.ts`
- Integration with existing Vite projects
- **Important**: Vitest extends Vite config, can use `defineConfig` from `vitest/config`

### 1.3 Basic Test Structure
```typescript
import { describe, it, expect } from 'vitest'
```
- `describe()` - Test suites
- `it()` / `test()` - Individual test cases
- `expect()` - Assertions
- **Note**: All test files should end with `.test.ts` or `.spec.ts`

### 1.4 Running Tests
- `vitest` - Watch mode (default)
- `vitest run` - Run once
- `vitest --ui` - Visual UI mode
- `vitest --coverage` - Coverage reports
- **Important**: Watch mode only reruns affected tests (smart)

---

## Chapter 2: Core Testing Concepts

### 2.1 Assertions & Matchers
- **Equality**: `toBe()`, `toEqual()`, `toStrictEqual()`
- **Truthiness**: `toBeTruthy()`, `toBeFalsy()`, `toBeNull()`, `toBeUndefined()`
- **Numbers**: `toBeGreaterThan()`, `toBeLessThan()`, `toBeCloseTo()`
- **Strings**: `toMatch()`, `toContain()`
- **Arrays/Objects**: `toContain()`, `toHaveLength()`, `toMatchObject()`
- **Exceptions**: `toThrow()`, `toThrowError()`
- **Important**: Use `toEqual()` for deep equality, `toBe()` for reference equality

### 2.2 Async Testing
- Testing Promises: `async/await` pattern
- `resolves` and `rejects` matchers
- **Important**: Always return or await promises
```typescript
await expect(asyncFunction()).resolves.toBe(value)
await expect(asyncFunction()).rejects.toThrow()
```

### 2.3 Setup and Teardown
- `beforeEach()` / `afterEach()` - Runs before/after each test
- `beforeAll()` / `afterAll()` - Runs once before/after all tests
- **Execution Order**: Describe blocks nest, hooks run in order
- **Important**: Cleanup is critical to prevent test pollution

### 2.4 Test Filtering
- `.only()` - Run only specific tests
- `.skip()` - Skip tests
- `.todo()` - Mark tests as TODO
- **Important**: Never commit `.only()` to production code

---

## Chapter 3: Mocking & Spies

### 3.1 Function Mocks
- `vi.fn()` - Create mock functions
- Mock return values: `mockReturnValue()`, `mockReturnValueOnce()`
- Mock implementations: `mockImplementation()`, `mockImplementationOnce()`
- **Important**: Reset mocks between tests with `vi.clearAllMocks()`

### 3.2 Module Mocking
- `vi.mock()` - Mock entire modules
- Partial mocks with `vi.importActual()`
- Factory functions for dynamic mocking
- **Important**: Hoisting behavior - `vi.mock()` is hoisted to top
```typescript
vi.mock('./module', () => ({
  default: vi.fn(),
  namedExport: vi.fn()
}))
```

### 3.3 Spies
- `vi.spyOn(object, 'method')` - Spy on existing methods
- Spy matchers: `toHaveBeenCalled()`, `toHaveBeenCalledWith()`
- `toHaveBeenCalledTimes()`, `toHaveBeenLastCalledWith()`
- **Important**: Restore spies with `vi.restoreAllMocks()`

### 3.4 Timers & Dates
- `vi.useFakeTimers()` - Mock timers
- `vi.advanceTimersByTime()` - Fast-forward time
- `vi.setSystemTime()` - Mock current date
- `vi.useRealTimers()` - Restore real timers
- **Important**: Always restore timers in `afterEach()`

### 3.5 Mocking Best Practices
- Mock at the boundary (API calls, external dependencies)
- Avoid mocking internal implementation details
- Use real implementations when possible
- **Important**: Over-mocking makes tests brittle

---

## Chapter 4: Advanced Testing Patterns

### 4.1 Snapshot Testing
- `toMatchSnapshot()` - Create snapshots
- `toMatchInlineSnapshot()` - Inline snapshots
- Updating snapshots: `vitest -u`
- **Important**: Review snapshot diffs carefully, don't blindly update

### 4.2 Test Context
- Shared context with `beforeEach()` return values
- Extended context typing with TypeScript
```typescript
beforeEach<{ user: User }>(async (context) => {
  context.user = await createUser()
})
```

### 4.3 Concurrent Testing
- `test.concurrent()` - Run tests in parallel
- `describe.concurrent()` - Parallel test suites
- **Important**: Ensure tests are isolated, no shared state
- **Limitation**: Not suitable for tests with side effects

### 4.4 Custom Matchers
- Extend `expect` with custom matchers
- `expect.extend()` API
```typescript
expect.extend({
  toBeWithinRange(received, floor, ceiling) {
    // custom logic
  }
})
```

### 4.5 Parameterized Tests
- `test.each()` - Run same test with different inputs
- Table-driven tests
```typescript
test.each([
  [1, 1, 2],
  [2, 2, 4],
])('adds %i + %i to equal %i', (a, b, expected) => {
  expect(a + b).toBe(expected)
})
```

---

## Chapter 5: Testing Specific Technologies

### 5.1 Testing React Components
- `@testing-library/react` integration
- Render components, query DOM, fire events
- `userEvent` for realistic interactions
- **Important**: Use `screen` queries for better error messages

### 5.2 Testing Vue Components
- `@vue/test-utils` integration
- Component mounting: `mount()`, `shallowMount()`
- Props, slots, emits testing
- **Important**: Use `findComponent()` for async rendering

### 5.3 Testing Svelte Components
- `@testing-library/svelte` integration
- Component compilation and testing
- Store testing patterns

### 5.4 Testing API/HTTP Calls
- `msw` (Mock Service Worker) for API mocking
- Intercept network requests
- **Important**: Mock at network level, not implementation level

### 5.5 Testing DOM Manipulation
- `happy-dom` or `jsdom` environments
- DOM APIs availability
- **Important**: Configure environment in config: `environment: 'happy-dom'`

---

## Chapter 6: Configuration & Optimization

### 6.1 Configuration Deep Dive
```typescript
export default defineConfig({
  test: {
    globals: true,
    environment: 'happy-dom',
    setupFiles: './test/setup.ts',
    include: ['**/*.{test,spec}.{js,ts}'],
    exclude: ['node_modules', 'dist'],
    coverage: { /* ... */ }
  }
})
```

### 6.2 Global Test Setup
- `setupFiles` - Run before each test file
- `globalSetup` - Run once before all tests
- **Difference**: setupFiles runs in test context, globalSetup runs in Node

### 6.3 Environment Configuration
- `happy-dom` - Lightweight, faster
- `jsdom` - More complete, slower
- `node` - No DOM APIs
- `edge-runtime` - Edge environment simulation
- **Important**: Choose based on what you're testing

### 6.4 TypeScript Configuration
- Automatic TypeScript support
- Type checking: `typecheck: true`
- `test-d` for type testing
```typescript
import { expectTypeOf } from 'vitest'
expectTypeOf<string>().toBeString()
```

### 6.5 Path Aliases & Module Resolution
- Use Vite's `resolve.alias`
- Same aliases as your app
- **Important**: Keep test and app resolution consistent

---

## Chapter 7: Code Coverage

### 7.1 Coverage Setup
- Install coverage provider: `@vitest/coverage-v8` or `@vitest/coverage-istanbul`
- Configure thresholds
```typescript
coverage: {
  provider: 'v8',
  reporter: ['text', 'json', 'html'],
  branches: 80,
  functions: 80,
  lines: 80,
  statements: 80
}
```

### 7.2 Coverage Types
- **Lines**: Percentage of executed lines
- **Branches**: If/else, switch cases coverage
- **Functions**: Function execution coverage
- **Statements**: Individual statements coverage

### 7.3 Coverage Best Practices
- Aim for 80%+ coverage, but don't obsess over 100%
- Exclude generated files, config files
- Use `/* istanbul ignore */` sparingly
- **Important**: High coverage ≠ Good tests

### 7.4 Coverage Reports
- Terminal output for quick feedback
- HTML reports for detailed analysis
- CI integration for tracking over time

---

## Chapter 8: Testing Strategies

### 8.1 Test Pyramid
- **Unit Tests** (70%): Individual functions/components
- **Integration Tests** (20%): Module interactions
- **E2E Tests** (10%): Full user flows
- **Important**: Most tests should be unit tests

### 8.2 AAA Pattern
- **Arrange**: Set up test data
- **Act**: Execute the code under test
- **Assert**: Verify the results
```typescript
// Arrange
const user = createUser({ name: 'John' })
// Act
const result = greet(user)
// Assert
expect(result).toBe('Hello, John')
```

### 8.3 Test Naming Conventions
- Describe what, not how
- Format: "should [expected behavior] when [condition]"
- Example: `should return error when user not found`

### 8.4 Test Independence
- Each test should run independently
- No test should depend on another test's state
- **Important**: Use `beforeEach()` to reset state

### 8.5 Testing Edge Cases
- Empty inputs, null values, undefined
- Boundary conditions
- Error scenarios
- **Important**: Edge cases find the most bugs

---

## Chapter 9: Performance & Optimization

### 9.1 Test Execution Speed
- Parallel execution: `--pool=threads` (default)
- Isolate: `--pool=forks` for complete isolation
- `--no-isolate` for faster, less isolated tests
- **Important**: Balance speed vs isolation

### 9.2 Workspace & Monorepo Support
- Configure multiple projects
- Shared configurations
- Project-specific test patterns
```typescript
export default defineConfig({
  test: {
    workspace: [
      './packages/*/vitest.config.ts'
    ]
  }
})
```

### 9.3 Browser Mode
- Test in real browsers
- `@vitest/browser` package
- Playwright or WebdriverIO providers
- **Important**: Slower but more accurate for UI

### 9.4 Benchmarking
- `bench()` for performance testing
- Compare different implementations
```typescript
import { bench, describe } from 'vitest'

describe('sort', () => {
  bench('normal', () => {
    const x = [1, 5, 4, 2, 3]
    x.sort((a, b) => a - b)
  })
})
```

### 9.5 Optimization Tips
- Minimize I/O operations in tests
- Use `vi.mock()` for expensive imports
- Avoid unnecessary `beforeEach()` setup
- **Important**: Profile slow tests with `--reporter=verbose`

---

## Chapter 10: Production-Grade Practices

### 10.1 CI/CD Integration
- Run tests in CI pipeline
- Fail builds on test failures
- Cache dependencies for speed
```yaml
# Example GitHub Actions
- run: npm test -- --run --coverage
```

### 10.2 Test Documentation
- Document complex test scenarios
- Explain why, not just what
- Use descriptive test names
- **Important**: Tests are living documentation

### 10.3 Flaky Test Management
- Identify flaky tests: `--retry=3`
- Fix root causes (race conditions, timing issues)
- Never ignore flaky tests
- **Important**: Flaky tests erode trust

### 10.4 Test Data Management
- Use factories for test data
- Fixtures for complex scenarios
- Avoid hardcoded IDs
```typescript
function createUser(overrides = {}) {
  return {
    id: Math.random(),
    name: 'Test User',
    ...overrides
  }
}
```

### 10.5 Testing Anti-Patterns to Avoid
- ❌ Testing implementation details
- ❌ Over-mocking
- ❌ Large test files (split them)
- ❌ Tests that test the framework
- ❌ Skipping unhappy paths
- ❌ Not cleaning up after tests

### 10.6 Code Review for Tests
- Tests should be reviewed as carefully as production code
- Check for proper assertions
- Verify test independence
- Look for missing edge cases

---

## Chapter 11: Advanced Topics

### 11.1 In-Source Testing
- Write tests next to source code
- `if (import.meta.vitest)` pattern
```typescript
if (import.meta.vitest) {
  const { it, expect } = import.meta.vitest
  it('adds numbers', () => {
    expect(add(1, 2)).toBe(3)
  })
}
```

### 11.2 Custom Test Reporters
- Create custom reporters for CI/CD
- Implement `Reporter` interface
- Format output for specific needs

### 11.3 Extending Vitest
- Custom pool implementations
- Plugin system integration
- Vite plugin compatibility

### 11.4 Debugging Tests
- `--inspect` flag for Node debugger
- VS Code debugging configuration
- `debugger` statements
- **Important**: Use `test.only()` to focus on failing test

### 11.5 Testing Private Methods
- **Best Practice**: Don't test private methods directly
- Test through public API
- If needed, use TypeScript: `(obj as any).privateMethod()`
- **Important**: Indicates possible design issue

---

## Chapter 12: Interview Focus Areas

### 12.1 Common Interview Questions
- **Q**: Difference between `toBe()` and `toEqual()`?
  - **A**: `toBe` uses `Object.is`, `toEqual` deep equality
- **Q**: How to test async code?
  - **A**: `async/await`, `resolves/rejects` matchers
- **Q**: When to use mocks vs spies?
  - **A**: Mocks replace implementations, spies observe existing ones
- **Q**: How to prevent test pollution?
  - **A**: `beforeEach/afterEach`, clear mocks, restore spies

### 12.2 Architectural Questions
- Test pyramid and why it matters
- Integration vs unit vs e2e testing
- Mocking strategies and trade-offs
- Coverage metrics interpretation

### 12.3 Problem-Solving Scenarios
- How to test a race condition?
- How to test code with side effects?
- How to refactor untested legacy code?
- How to handle flaky tests?

### 12.4 Vitest-Specific Knowledge
- Why Vitest over Jest?
- ESM-first approach benefits
- Vite integration advantages
- Performance characteristics

### 12.5 Production Experience Questions
- How do you structure tests in a large codebase?
- CI/CD test strategy
- Handling test failures in production
- Balancing test speed vs thoroughness

---

## Chapter 13: Real-World Examples

### 13.1 Testing a Service Layer
```typescript
describe('UserService', () => {
  let service: UserService
  let mockDb: MockDatabase

  beforeEach(() => {
    mockDb = createMockDatabase()
    service = new UserService(mockDb)
  })

  it('should create user with hashed password', async () => {
    const result = await service.createUser({
      email: 'test@example.com',
      password: 'secret'
    })
    
    expect(result.password).not.toBe('secret')
    expect(mockDb.insert).toHaveBeenCalled()
  })
})
```

### 13.2 Testing Error Handling
```typescript
it('should throw error when user not found', async () => {
  mockDb.findById.mockResolvedValue(null)
  
  await expect(
    service.getUser('invalid-id')
  ).rejects.toThrow('User not found')
})
```

### 13.3 Testing Complex State Management
```typescript
describe('Shopping Cart', () => {
  it('should calculate total with discounts', () => {
    const cart = new ShoppingCart()
    cart.addItem({ price: 100, qty: 2 })
    cart.addItem({ price: 50, qty: 1 })
    cart.applyDiscount(10) // 10% off
    
    expect(cart.getTotal()).toBe(225) // (200 + 50) * 0.9
  })
})
```

---

## Quick Reference: Essential Commands

```bash
# Run tests
vitest                    # Watch mode
vitest run               # Single run
vitest --ui              # UI mode
vitest --coverage        # With coverage

# Filter tests
vitest user.test.ts      # Specific file
vitest -t "user login"   # By name pattern

# Debug
vitest --inspect-brk     # Debug mode
vitest --reporter=verbose # Detailed output

# Update snapshots
vitest -u

# Configuration
vitest --config custom.config.ts
```

---

## Key Takeaways for Mastery

1. **Understand the fundamentals**: Assertions, mocking, async testing
2. **Write maintainable tests**: Independent, readable, focused
3. **Know your tools**: Mocks, spies, timers, snapshots
4. **Optimize performance**: Parallel execution, smart mocking
5. **Production mindset**: CI/CD, flaky tests, test data management
6. **Keep learning**: Vitest ecosystem, new patterns, best practices

**Remember**: Great tests verify behavior, not implementation. They should give confidence, run fast, and fail clearly when something breaks.