# Chapter 10: Production-Grade Practices - Complete Guide

## 10.1 CI/CD Integration

### GitHub Actions - Complete Example

```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  NODE_VERSION: '20'

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 1: Unit & Integration Tests
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  test:
    name: Unit & Integration Tests
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [18, 20]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # For coverage comparison
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      
      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run linter
        run: npm run lint
      
      - name: Run type check
        run: npm run type-check
      
      - name: Run unit tests
        run: npm run test:unit -- --coverage
      
      - name: Run integration tests
        run: npm run test:integration
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info
          flags: unittests
          name: codecov-${{ matrix.node-version }}
          fail_ci_if_error: true
      
      - name: Store coverage report
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report
          path: coverage/
          retention-days: 7
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 2: E2E Tests
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  e2e:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: test
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Install Playwright
        run: npx playwright install --with-deps
      
      - name: Build application
        run: npm run build
      
      - name: Run migrations
        run: npm run db:migrate
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test
      
      - name: Start server
        run: npm run start:test &
        env:
          NODE_ENV: test
          PORT: 3000
      
      - name: Wait for server
        run: npx wait-on http://localhost:3000
      
      - name: Run E2E tests
        run: npm run test:e2e
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: e2e-results
          path: test-results/
          retention-days: 7
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 3: Coverage Check & Report
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  coverage:
    name: Coverage Check
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download coverage
        uses: actions/download-artifact@v3
        with:
          name: coverage-report
          path: coverage/
      
      - name: Check coverage thresholds
        run: node scripts/check-coverage.js
      
      - name: Comment PR with coverage
        uses: romeovs/lcov-reporter-action@v0.3.1
        with:
          lcov-file: ./coverage/lcov.info
          github-token: ${{ secrets.GITHUB_TOKEN }}
          title: Coverage Report
```

### GitLab CI/CD Example

```yaml
# .gitlab-ci.yml
image: node:20

stages:
  - test
  - e2e
  - deploy

variables:
  npm_config_cache: "$CI_PROJECT_DIR/.npm"
  CYPRESS_CACHE_FOLDER: "$CI_PROJECT_DIR/.cypress"

cache:
  paths:
    - .npm
    - .cypress
    - node_modules

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Test Stage
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
test:unit:
  stage: test
  script:
    - npm ci
    - npm run test:unit -- --coverage --reporter=junit
  coverage: '/Lines\s*:\s*(\d+\.?\d*)%/'
  artifacts:
    when: always
    reports:
      junit: junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
    expire_in: 1 week

test:integration:
  stage: test
  services:
    - postgres:15
  variables:
    POSTGRES_DB: test
    POSTGRES_USER: test
    POSTGRES_PASSWORD: test
    DATABASE_URL: postgresql://test:test@postgres:5432/test
  script:
    - npm ci
    - npm run db:migrate
    - npm run test:integration

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# E2E Stage
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
test:e2e:
  stage: e2e
  services:
    - postgres:15
  script:
    - npm ci
    - npm run build
    - npm run start:test &
    - npm run test:e2e
  artifacts:
    when: always
    paths:
      - test-results/
    expire_in: 1 week
```

### Coverage Threshold Script

```javascript
// scripts/check-coverage.js
const fs = require('fs')
const path = require('path')

const THRESHOLDS = {
  lines: 80,
  statements: 80,
  functions: 80,
  branches: 75
}

function checkCoverage() {
  const summaryPath = path.join(__dirname, '../coverage/coverage-summary.json')
  
  if (!fs.existsSync(summaryPath)) {
    console.error('âŒ Coverage summary not found!')
    process.exit(1)
  }
  
  const summary = JSON.parse(fs.readFileSync(summaryPath, 'utf8'))
  const { total } = summary
  
  let failed = false
  const results = []
  
  for (const [metric, threshold] of Object.entries(THRESHOLDS)) {
    const coverage = total[metric].pct
    const passed = coverage >= threshold
    
    results.push({
      metric,
      coverage: coverage.toFixed(2),
      threshold,
      passed
    })
    
    if (!passed) failed = true
  }
  
  // Print table
  console.log('\nğŸ“Š Coverage Report\n')
  console.log('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”')
  console.log('â”‚ Metric      â”‚ Coverage â”‚ Threshold â”‚ Status â”‚')
  console.log('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤')
  
  results.forEach(({ metric, coverage, threshold, passed }) => {
    const status = passed ? 'âœ“ Pass' : 'âœ— Fail'
    const color = passed ? '\x1b[32m' : '\x1b[31m'
    console.log(
      `â”‚ ${metric.padEnd(11)} â”‚ ${coverage.padStart(7)}% â”‚ ${threshold.toString().padStart(8)}% â”‚ ${color}${status}\x1b[0m  â”‚`
    )
  })
  
  console.log('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n')
  
  if (failed) {
    console.error('âŒ Coverage thresholds not met!')
    process.exit(1)
  }
  
  console.log('âœ… All coverage thresholds met!\n')
}

checkCoverage()
```

---

## 10.2 Test Documentation

### Self-Documenting Tests

```typescript
// âŒ BAD - Unclear test name
it('test1', () => {
  const result = calculate(10, 5)
  expect(result).toBe(15)
})

// âœ… GOOD - Self-explanatory
it('should add tax to product price', () => {
  const price = 100
  const taxRate = 0.1
  
  const total = calculateTotal(price, taxRate)
  
  expect(total).toBe(110)
})
```

### Documentation Comments

```typescript
/**
 * User Authentication Tests
 * 
 * This suite tests the authentication flow including:
 * - User login with valid credentials
 * - Login failure handling
 * - Session management
 * - Token refresh
 * 
 * @see AuthService
 * @see SessionManager
 */
describe('Authentication', () => {
  /**
   * Tests successful login flow
   * 
   * Scenario:
   * 1. User submits valid email and password
   * 2. System validates credentials
   * 3. System creates session
   * 4. User receives auth token
   * 
   * Expected: User is logged in with valid token
   */
  it('should authenticate user with valid credentials', async () => {
    const credentials = {
      email: 'user@example.com',
      password: 'SecurePassword123!'
    }
    
    const result = await authService.login(credentials)
    
    expect(result.token).toBeDefined()
    expect(result.user.email).toBe(credentials.email)
    expect(result.expiresIn).toBe(3600)
  })
  
  /**
   * Tests account lockout after failed attempts
   * 
   * Security requirement: Accounts must lock after 5 failed attempts
   * to prevent brute force attacks.
   * 
   * @see SECURITY.md - Account Lockout Policy
   */
  it('should lock account after 5 failed login attempts', async () => {
    const email = 'user@example.com'
    const wrongPassword = 'WrongPassword'
    
    // Attempt login 5 times with wrong password
    for (let i = 0; i < 5; i++) {
      await expect(
        authService.login({ email, password: wrongPassword })
      ).rejects.toThrow('Invalid credentials')
    }
    
    // 6th attempt should indicate locked account
    await expect(
      authService.login({ email, password: wrongPassword })
    ).rejects.toThrow('Account locked')
  })
})
```

### Test README

```markdown
# Test Documentation

## Running Tests

```bash
# Run all tests
npm test

# Run specific suite
npm test -- auth.test.ts

# Run with coverage
npm run test:coverage

# Run in watch mode
npm run test:watch
```

## Test Structure

```
test/
â”œâ”€â”€ unit/           # Unit tests (fast, isolated)
â”œâ”€â”€ integration/    # Integration tests (DB + services)
â”œâ”€â”€ e2e/           # End-to-end tests (full flows)
â”œâ”€â”€ fixtures/      # Test data and helpers
â””â”€â”€ setup.ts       # Global test setup
```

## Test Categories

### Unit Tests
- Pure functions
- Business logic
- Utilities
- **Target**: 80% coverage

### Integration Tests
- API endpoints
- Database operations
- External service integration
- **Target**: 75% coverage

### E2E Tests
- Critical user flows
- Payment processing
- Authentication
- **Target**: Major happy paths

## Writing Tests

### Naming Convention
```typescript
it('should [action] when [condition]', () => {})
```

### AAA Pattern
```typescript
it('test name', () => {
  // Arrange - setup
  // Act - execute
  // Assert - verify
})
```

### Test Independence
Each test should:
- Run in isolation
- Not depend on other tests
- Clean up after itself

## CI/CD

Tests run automatically on:
- Push to main/develop
- Pull requests
- Nightly builds

Required checks:
- âœ… All tests pass
- âœ… Coverage â‰¥ 80%
- âœ… No linting errors
```

---

## 10.3 Flaky Test Management

### What are Flaky Tests?

Flaky tests are tests that intermittently pass or fail without code changes.

```
Normal Test:     Flaky Test:
Run 1: âœ…        Run 1: âœ…
Run 2: âœ…        Run 2: âŒ
Run 3: âœ…        Run 3: âœ…
Run 4: âœ…        Run 4: âŒ
```

### Common Causes

```typescript
// 1. TIMING ISSUES
// âŒ BAD - Race condition
it('should update UI', () => {
  fetchData()
  expect(element.textContent).toBe('Updated') // Too fast!
})

// âœ… GOOD - Wait for update
it('should update UI', async () => {
  await fetchData()
  await waitFor(() => {
    expect(element.textContent).toBe('Updated')
  })
})

// 2. RANDOM DATA
// âŒ BAD - Non-deterministic
it('should sort items', () => {
  const items = generateRandomItems()
  const sorted = sort(items)
  expect(sorted[0]).toBe(items[0]) // Might fail!
})

// âœ… GOOD - Fixed data
it('should sort items', () => {
  const items = [3, 1, 4, 1, 5, 9, 2, 6]
  const sorted = sort(items)
  expect(sorted).toEqual([1, 1, 2, 3, 4, 5, 6, 9])
})

// 3. EXTERNAL DEPENDENCIES
// âŒ BAD - Real API call
it('should fetch users', async () => {
  const users = await api.getUsers() // Might fail!
  expect(users).toBeDefined()
})

// âœ… GOOD - Mocked
it('should fetch users', async () => {
  vi.mocked(api.getUsers).mockResolvedValue([
    { id: 1, name: 'John' }
  ])
  const users = await api.getUsers()
  expect(users).toHaveLength(1)
})

// 4. SHARED STATE
// âŒ BAD - Shared counter
let counter = 0

it('increments', () => {
  counter++
  expect(counter).toBe(1) // Fails in parallel!
})

// âœ… GOOD - Isolated
it('increments', () => {
  let counter = 0
  counter++
  expect(counter).toBe(1)
})

// 5. DATE/TIME DEPENDENT
// âŒ BAD - Real date
it('should show current year', () => {
  expect(getCopyrightYear()).toBe(2024) // Fails next year!
})

// âœ… GOOD - Mocked date
it('should show current year', () => {
  vi.useFakeTimers()
  vi.setSystemTime(new Date('2024-01-01'))
  
  expect(getCopyrightYear()).toBe(2024)
  
  vi.useRealTimers()
})
```

### Detecting Flaky Tests

```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    // Retry failed tests
    retry: 3,
    
    // Report flaky tests
    reporters: [
      'default',
      ['json', { outputFile: 'test-results.json' }]
    ]
  }
})
```

```javascript
// scripts/detect-flaky-tests.js
const fs = require('fs')

// Run tests multiple times
const runs = 10
const results = []

for (let i = 0; i < runs; i++) {
  console.log(`\nRun ${i + 1}/${runs}...`)
  execSync('npm test -- --reporter=json --outputFile=result.json', {
    stdio: 'inherit'
  })
  
  const result = JSON.parse(fs.readFileSync('result.json'))
  results.push(result)
}

// Analyze results
const flakyTests = []

// Compare results to find inconsistencies
// ... analysis logic

if (flakyTests.length > 0) {
  console.error('\nâŒ Flaky tests detected:')
  flakyTests.forEach(test => {
    console.error(`  - ${test.name}`)
    console.error(`    Pass rate: ${test.passRate}%`)
  })
  process.exit(1)
}
```

### Fixing Flaky Tests

```typescript
// Strategy 1: Add proper waits
it('should load data', async () => {
  render(<DataComponent />)
  
  // âŒ Don't assume instant load
  // expect(screen.getByText('Data')).toBeInTheDocument()
  
  // âœ… Wait for async operation
  await waitFor(() => {
    expect(screen.getByText('Data')).toBeInTheDocument()
  }, { timeout: 5000 })
})

// Strategy 2: Increase timeouts for slow operations
it('should process large file', async () => {
  const result = await processFile(largeFile)
  expect(result).toBeDefined()
}, 30000) // 30 second timeout

// Strategy 3: Mock non-deterministic behavior
it('should generate ID', () => {
  vi.spyOn(Math, 'random').mockReturnValue(0.5)
  
  const id = generateId()
  
  expect(id).toBe('expected-id-based-on-0.5')
})

// Strategy 4: Isolate tests
describe('Counter', () => {
  let counter: Counter
  
  beforeEach(() => {
    counter = new Counter() // Fresh instance
  })
  
  it('test 1', () => {
    // Independent test
  })
  
  it('test 2', () => {
    // Independent test
  })
})
```

### Quarantining Flaky Tests

```typescript
// Mark flaky tests
describe('Known flaky tests', () => {
  it.skip('flaky test - investigating', () => {
    // Test code
  })
  
  it.failing('flaky test - expected to fail', () => {
    // Test that's known to fail
    // Won't fail the build
  })
})

// Or use custom matcher
it('potentially flaky operation', () => {
  // Test might be flaky
}).retry(5) // Retry up to 5 times
```

---

## 10.4 Test Data Management

### Test Fixtures

```typescript
// test/fixtures/users.ts
export const testUsers = {
  admin: {
    id: 1,
    email: 'admin@test.com',
    name: 'Admin User',
    role: 'admin',
    permissions: ['read', 'write', 'delete']
  },
  
  user: {
    id: 2,
    email: 'user@test.com',
    name: 'Regular User',
    role: 'user',
    permissions: ['read']
  },
  
  guest: {
    id: 3,
    email: 'guest@test.com',
    name: 'Guest User',
    role: 'guest',
    permissions: []
  }
}

export const testProducts = [
  { id: 1, name: 'Product A', price: 100, stock: 50 },
  { id: 2, name: 'Product B', price: 200, stock: 30 },
  { id: 3, name: 'Product C', price: 150, stock: 0 }
]
```

### Factory Functions

```typescript
// test/factories/user.factory.ts
let userIdCounter = 1

export function createUser(overrides?: Partial<User>): User {
  return {
    id: userIdCounter++,
    email: `user${userIdCounter}@test.com`,
    name: 'Test User',
    role: 'user',
    createdAt: new Date(),
    ...overrides
  }
}

export function createAdmin(overrides?: Partial<User>): User {
  return createUser({
    role: 'admin',
    permissions: ['read', 'write', 'delete'],
    ...overrides
  })
}

// Usage
describe('User service', () => {
  it('should create user', () => {
    const user = createUser({ name: 'John' })
    expect(user.name).toBe('John')
    expect(user.email).toContain('@test.com')
  })
  
  it('should create admin', () => {
    const admin = createAdmin()
    expect(admin.role).toBe('admin')
    expect(admin.permissions).toContain('delete')
  })
})
```

### Builder Pattern

```typescript
// test/builders/order.builder.ts
export class OrderBuilder {
  private order: Partial<Order> = {
    items: [],
    status: 'pending',
    createdAt: new Date()
  }
  
  withId(id: number): this {
    this.order.id = id
    return this
  }
  
  withUser(userId: number): this {
    this.order.userId = userId
    return this
  }
  
  withItems(items: OrderItem[]): this {
    this.order.items = items
    return this
  }
  
  withStatus(status: OrderStatus): this {
    this.order.status = status
    return this
  }
  
  build(): Order {
    return this.order as Order
  }
}

// Usage
describe('Order processing', () => {
  it('should calculate total', () => {
    const order = new OrderBuilder()
      .withId(1)
      .withUser(1)
      .withItems([
        { productId: 1, quantity: 2, price: 10 },
        { productId: 2, quantity: 1, price: 20 }
      ])
      .build()
    
    const total = calculateOrderTotal(order)
    expect(total).toBe(40)
  })
})
```

### Database Seeding

```typescript
// test/seed.ts
export async function seedDatabase(db: Database) {
  // Clear existing data
  await db.users.deleteAll()
  await db.products.deleteAll()
  await db.orders.deleteAll()
  
  // Seed users
  const users = await Promise.all([
    db.users.create(testUsers.admin),
    db.users.create(testUsers.user),
    db.users.create(testUsers.guest)
  ])
  
  // Seed products
  const products = await Promise.all(
    testProducts.map(p => db.products.create(p))
  )
  
  // Seed orders
  await db.orders.create({
    userId: users[1].id,
    items: [
      { productId: products[0].id, quantity: 2 }
    ],
    total: 200
  })
  
  return { users, products }
}

// Usage
describe('Order integration tests', () => {
  let db: Database
  let testData: { users: User[], products: Product[] }
  
  beforeAll(async () => {
    db = await createTestDatabase()
    testData = await seedDatabase(db)
  })
  
  it('should fetch user orders', async () => {
    const orders = await db.orders.findByUserId(testData.users[1].id)
    expect(orders).toHaveLength(1)
  })
})
```

---

## 10.5 Testing Anti-Patterns

### 1. Testing Implementation Details

```typescript
// âŒ BAD - Tests internal implementation
it('should call validateEmail', () => {
  const spy = vi.spyOn(validator, 'validateEmail')
  
  createUser({ email: 'test@example.com' })
  
  expect(spy).toHaveBeenCalled() // Who cares HOW it validates?
})

// âœ… GOOD - Tests behavior
it('should reject invalid email', () => {
  expect(() => 
    createUser({ email: 'invalid' })
  ).toThrow('Invalid email')
})
```

### 2. Too Many Assertions

```typescript
// âŒ BAD - Testing everything in one test
it('user operations', async () => {
  const user = await createUser({ name: 'John' })
  expect(user).toBeDefined()
  expect(user.name).toBe('John')
  
  await updateUser(user.id, { name: 'Jane' })
  expect(user.name).toBe('Jane')
  
  await deleteUser(user.id)
  expect(await getUser(user.id)).toBeNull()
  
  // And 20 more assertions...
})

// âœ… GOOD - Focused tests
describe('User CRUD', () => {
  it('should create user', async () => {
    const user = await createUser({ name: 'John' })
    expect(user.name).toBe('John')
  })
  
  it('should update user', async () => {
    const user = await createUser({ name: 'John' })
    await updateUser(user.id, { name: 'Jane' })
    const updated = await getUser(user.id)
    expect(updated.name).toBe('Jane')
  })
})
```

### 3. Magic Numbers

```typescript
// âŒ BAD - Magic numbers
it('should calculate discount', () => {
  expect(calculateDiscount(100, 0.1)).toBe(90)
  expect(calculateDiscount(200, 0.2)).toBe(160)
})

// âœ… GOOD - Named constants
it('should calculate discount', () => {
  const PRICE = 100
  const DISCOUNT_10_PERCENT = 0.1
  const EXPECTED_PRICE = 90
  
  expect(calculateDiscount(PRICE, DISCOUNT_10_PERCENT))
    .toBe(EXPECTED_PRICE)
})
```

### 4. Not Testing Edge Cases

```typescript
// âŒ BAD - Only happy path
it('should divide numbers', () => {
  expect(divide(10, 2)).toBe(5)
})

// âœ… GOOD - Include edge cases
describe('divide', () => {
  it('should divide positive numbers', () => {
    expect(divide(10, 2)).toBe(5)
  })
  
  it('should handle division by zero', () => {
    expect(() => divide(10, 0)).toThrow('Division by zero')
  })
  
  it('should handle negative numbers', () => {
    expect(divide(-10, 2)).toBe(-5)
  })
})
```

### 5. Ignoring Async Errors

```typescript
// âŒ BAD - Silently catching errors
it('should fetch data', async () => {
  try {
    const data = await fetchData()
    expect(data).toBeDefined()
  } catch (error) {
    // Error silently caught!
  }
})

// âœ… GOOD - Let errors propagate
it('should fetch data', async () => {
  const data = await fetchData()
  expect(data).toBeDefined()
})

it('should handle fetch errors', async () => {
  vi.mocked(fetch).mockRejectedValue(new Error('Network error'))
  
  await expect(fetchData()).rejects.toThrow('Network error')
})
```

---

## 10.6 Code Review for Tests

### Test Code Review Checklist

```markdown
## Test Quality Checklist

### Test Structure
- [ ] Tests follow AAA pattern
- [ ] Test names are descriptive
- [ ] Tests are independent
- [ ] No test depends on execution order

### Coverage
- [ ] Happy paths are tested
- [ ] Edge cases are tested
- [ ] Error cases are tested
- [ ] Coverage meets thresholds (80%+)

### Assertions
- [ ] Assertions are clear and specific
- [ ] No magic numbers or strings
- [ ] Correct matchers used (toBe vs toEqual)
- [ ] Async assertions use await

### Performance
- [ ] Tests run quickly (< 10ms for unit)
- [ ] No unnecessary async/await
- [ ] Expensive setup in beforeAll
- [ ] Mocks are cleaned up

### Maintainability
- [ ] No implementation details tested
- [ ] Tests would survive refactoring
- [ ] Test data is clear and minimal
- [ ] No code duplication

### Best Practices
- [ ] No .only() or .skip() committed
- [ ] Error messages are helpful
- [ ] Tests document expected behavior
- [ ] No flaky tests
```

### Review Comments Examples

```typescript
// Comment 1: Missing edge case
it('should validate email', () => {
  expect(validateEmail('test@example.com')).toBe(true)
})
// ğŸ’¬ Consider testing: empty string, missing @, multiple @

// Comment 2: Too broad
it('should work', () => {
  const result = doSomething()
  expect(result).toBeDefined()
})
// ğŸ’¬ Test name should describe WHAT works and WHY it matters

// Comment 3: Testing implementation
it('should call helper function', () => {
  const spy = vi.spyOn(obj, 'helper')
  obj.method()
  expect(spy).toHaveBeenCalled()
})
// ğŸ’¬ Test behavior, not internal calls. What's the expected outcome?

// Comment 4: Shared state
let user: User

it('test 1', () => {
  user = createUser()
})

it('test 2', () => {
  updateUser(user) // Depends on test 1!
})
// ğŸ’¬ Tests should be independent. Move setup to beforeEach
```

---

## Summary: Chapter 10

### Production-Grade Testing Checklist

**CI/CD:**
- âœ… Automated test runs
- âœ… Coverage reports
- âœ… Failed tests block deploys
- âœ… Multiple Node versions tested
- âœ… E2E tests in staging environment

**Documentation:**
- âœ… README with running instructions
- âœ… Self-documenting test names
- âœ… Comments for complex scenarios
- âœ… Test structure documented

**Flaky Tests:**
- âœ… Retry mechanism configured
- âœ… Regular flaky test detection
- âœ… Root cause analysis
- âœ… Quarantine process for unfixable tests

**Test Data:**
- âœ… Fixtures for common data
- âœ… Factory functions for variation
- âœ… Database seeding scripts
- âœ… No hardcoded IDs or magic values

**Anti-Patterns Avoided:**
- âŒ Testing implementation details
- âŒ Too many assertions per test
- âŒ Magic numbers
- âŒ Ignoring edge cases
- âŒ Catching async errors

**Code Review:**
- âœ… Test quality checklist
- âœ… Coverage requirements
- âœ… Performance monitoring
- âœ… Maintainability focus

### Production Test Suite Metrics

```
Target Metrics:
- Total suite time: < 5 minutes
- Unit test speed: < 10ms average
- Integration test speed: < 500ms average
- Code coverage: > 80%
- Flaky test rate: < 1%
- Build success rate: > 95%
```

**Congratulations!** You've completed all 10 chapters of Vitest mastery. You're now equipped with production-grade testing skills for both interviews and real-world applications!