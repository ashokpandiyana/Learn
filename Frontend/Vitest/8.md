# Chapter 8: Testing Strategies - Complete Guide

## 8.1 The Test Pyramid

### Understanding the Test Pyramid

The test pyramid is a strategy for organizing tests by scope and speed, with the most tests at the bottom (fast, isolated) and fewer at the top (slow, integrated).

```
        â•±â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â•²
       â•±  E2E Tests    â•²         â† 10% of tests
      â•±   (Slow, Full)  â•²           Entire system
     â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²          Days to write
    â•±                    â•²         Minutes to run
   â•±  Integration Tests  â•²     â† 20% of tests
  â•±   (Medium, Partial)   â•²       Multiple units
 â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²      Hours to write
â•±                           â•²     Seconds to run
â•²      Unit Tests           â•±  â† 70% of tests
 â•²   (Fast, Isolated)      â•±      Single unit
  â•²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•±        Minutes to write
   â•²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•±           Milliseconds to run
```

### Distribution Guidelines

```typescript
// Recommended test distribution

Unit Tests:        70%
â”œâ”€ Pure functions
â”œâ”€ Business logic
â”œâ”€ Utilities
â”œâ”€ Single components
â””â”€ Individual classes

Integration Tests: 20%
â”œâ”€ API endpoints
â”œâ”€ Database operations
â”œâ”€ Component interactions
â”œâ”€ Service integration
â””â”€ Module collaboration

E2E Tests:        10%
â”œâ”€ Critical user flows
â”œâ”€ Happy paths
â”œâ”€ Authentication
â””â”€ Core features
```

### Unit Tests - The Foundation

```typescript
// utils/calculator.ts
export function calculateTotal(
  items: Array<{ price: number; quantity: number }>,
  taxRate: number,
  discount: number = 0
): number {
  const subtotal = items.reduce((sum, item) => 
    sum + (item.price * item.quantity), 0
  )
  
  const afterDiscount = subtotal * (1 - discount)
  const total = afterDiscount * (1 + taxRate)
  
  return Math.round(total * 100) / 100
}
```

```typescript
// utils/calculator.test.ts - Unit Test
import { describe, it, expect } from 'vitest'
import { calculateTotal } from './calculator'

describe('calculateTotal', () => {
  // Fast, isolated, deterministic
  
  it('should calculate total without tax or discount', () => {
    const items = [
      { price: 10, quantity: 2 },
      { price: 5, quantity: 3 }
    ]
    
    expect(calculateTotal(items, 0)).toBe(35)
  })
  
  it('should apply tax rate', () => {
    const items = [{ price: 100, quantity: 1 }]
    
    expect(calculateTotal(items, 0.1)).toBe(110)
  })
  
  it('should apply discount', () => {
    const items = [{ price: 100, quantity: 1 }]
    
    expect(calculateTotal(items, 0, 0.2)).toBe(80)
  })
  
  it('should apply both tax and discount', () => {
    const items = [{ price: 100, quantity: 1 }]
    
    expect(calculateTotal(items, 0.1, 0.2)).toBe(88)
  })
  
  it('should handle multiple items', () => {
    const items = [
      { price: 10, quantity: 2 },  // 20
      { price: 15, quantity: 1 },  // 15
      { price: 5, quantity: 4 }    // 20
    ]
    
    expect(calculateTotal(items, 0.1)).toBe(60.5)
  })
  
  it('should round to 2 decimal places', () => {
    const items = [{ price: 10.333, quantity: 3 }]
    
    expect(calculateTotal(items, 0.1)).toBe(34.1)
  })
})

// âš¡ Speed: ~5ms
// ğŸ¯ Scope: Single function
// ğŸ”„ Maintenance: Low
```

### Integration Tests - Testing Interactions

```typescript
// services/orderService.ts
import { Database } from './database'
import { EmailService } from './emailService'
import { PaymentGateway } from './paymentGateway'

export class OrderService {
  constructor(
    private db: Database,
    private email: EmailService,
    private payment: PaymentGateway
  ) {}
  
  async createOrder(userId: number, items: OrderItem[]): Promise<Order> {
    // Multiple systems working together
    
    const user = await this.db.users.findById(userId)
    if (!user) throw new Error('User not found')
    
    const total = this.calculateTotal(items)
    
    const payment = await this.payment.charge(user.paymentMethod, total)
    
    const order = await this.db.orders.create({
      userId,
      items,
      total,
      paymentId: payment.id
    })
    
    await this.email.send(user.email, 'order-confirmation', { order })
    
    return order
  }
}
```

```typescript
// services/orderService.test.ts - Integration Test
import { describe, it, expect, beforeEach } from 'vitest'
import { OrderService } from './orderService'
import { createTestDatabase } from '@test/helpers'

describe('OrderService Integration', () => {
  let db: Database
  let service: OrderService
  
  beforeEach(async () => {
    // Real database (test instance)
    db = await createTestDatabase()
    
    // Mock external services
    const mockEmail = {
      send: vi.fn().mockResolvedValue(true)
    }
    
    const mockPayment = {
      charge: vi.fn().mockResolvedValue({ id: 'pay_123' })
    }
    
    service = new OrderService(db, mockEmail, mockPayment)
  })
  
  afterEach(async () => {
    await db.close()
  })
  
  it('should create order with real database', async () => {
    // Setup test data
    const user = await db.users.create({
      email: 'test@example.com',
      paymentMethod: 'card_123'
    })
    
    const items = [
      { productId: 1, quantity: 2, price: 10 }
    ]
    
    // Execute
    const order = await service.createOrder(user.id, items)
    
    // Verify database state
    expect(order).toHaveProperty('id')
    expect(order.total).toBe(20)
    
    const dbOrder = await db.orders.findById(order.id)
    expect(dbOrder).toEqual(order)
    
    // Verify external service calls
    expect(mockPayment.charge).toHaveBeenCalledWith('card_123', 20)
    expect(mockEmail.send).toHaveBeenCalledWith(
      'test@example.com',
      'order-confirmation',
      expect.objectContaining({ order })
    )
  })
})

// âš¡ Speed: ~100-500ms
// ğŸ¯ Scope: Multiple units + database
// ğŸ”„ Maintenance: Medium
```

### E2E Tests - Full User Flows

```typescript
// e2e/checkout.test.ts - E2E Test
import { test, expect } from '@playwright/test'

test.describe('Checkout Flow', () => {
  test('user can complete purchase', async ({ page }) => {
    // Navigate to site
    await page.goto('http://localhost:3000')
    
    // Browse products
    await page.click('text=Shop')
    await page.click('text=Add to Cart')
    
    // View cart
    await page.click('[data-testid="cart-icon"]')
    await expect(page.locator('.cart-item')).toHaveCount(1)
    
    // Proceed to checkout
    await page.click('text=Checkout')
    
    // Fill shipping info
    await page.fill('[name="name"]', 'John Doe')
    await page.fill('[name="address"]', '123 Main St')
    await page.fill('[name="city"]', 'New York')
    await page.fill('[name="zip"]', '10001')
    
    // Fill payment info
    await page.fill('[name="cardNumber"]', '4242424242424242')
    await page.fill('[name="expiry"]', '12/25')
    await page.fill('[name="cvc"]', '123')
    
    // Submit order
    await page.click('text=Place Order')
    
    // Verify success
    await expect(page.locator('.order-confirmation')).toBeVisible()
    await expect(page.locator('.order-number')).toContainText(/ORD-\d+/)
    
    // Verify email sent (check UI message)
    await expect(page.locator('.email-sent')).toContainText(
      'Confirmation sent to'
    )
  })
})

// âš¡ Speed: ~10-30 seconds
// ğŸ¯ Scope: Entire system
// ğŸ”„ Maintenance: High
```

### When to Use Each Type

| Scenario | Test Type | Why |
|----------|-----------|-----|
| Pure function | Unit | Fast, isolated, deterministic |
| Business logic | Unit | No dependencies, easy to test |
| API endpoint | Integration | Tests routing + logic + DB |
| Database query | Integration | Tests actual DB operations |
| Component | Unit/Integration | Depends on complexity |
| User signup flow | E2E | Critical path, multiple systems |
| Payment processing | E2E | Critical, requires real flow |

---

## 8.2 AAA Pattern (Arrange-Act-Assert)

### The AAA Structure

```typescript
it('should apply discount to order', () => {
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ARRANGE - Set up test preconditions
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const order = {
    items: [
      { name: 'Product A', price: 50, quantity: 2 },
      { name: 'Product B', price: 30, quantity: 1 }
    ],
    discount: 0.1 // 10% discount
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ACT - Execute the code under test
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const result = calculateOrderTotal(order)
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ASSERT - Verify the outcome
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  expect(result).toBe(117) // (50*2 + 30) * 0.9
})
```

### AAA with Comments (for clarity)

```typescript
describe('UserService', () => {
  it('should create user with hashed password', async () => {
    // Arrange
    const userData = {
      email: 'user@example.com',
      password: 'plaintext123'
    }
    const mockHasher = vi.fn().mockReturnValue('hashed_password')
    const service = new UserService(mockHasher)
    
    // Act
    const user = await service.createUser(userData)
    
    // Assert
    expect(user.password).toBe('hashed_password')
    expect(mockHasher).toHaveBeenCalledWith('plaintext123')
  })
})
```

### Complex AAA Example

```typescript
describe('ShoppingCart', () => {
  it('should apply tiered discounts correctly', () => {
    // Arrange - Setup is more complex
    const cart = new ShoppingCart()
    
    // Add items
    cart.addItem({ id: 1, price: 10, quantity: 5 })  // 50
    cart.addItem({ id: 2, price: 20, quantity: 3 })  // 60
    cart.addItem({ id: 3, price: 15, quantity: 2 })  // 30
    
    // Apply coupon
    cart.applyCoupon('SAVE10')
    
    // Set shipping
    cart.setShipping('express', 15)
    
    // Act - Single clear action
    const total = cart.calculateTotal()
    
    // Assert - Multiple related assertions
    expect(total.subtotal).toBe(140)
    expect(total.discount).toBe(14)      // 10% off
    expect(total.shipping).toBe(15)
    expect(total.tax).toBe(14.1)         // 10% tax on discounted amount
    expect(total.grandTotal).toBe(155.1) // 140 - 14 + 15 + 14.1
  })
})
```

### AAA with Async Operations

```typescript
describe('EmailService', () => {
  it('should retry failed sends', async () => {
    // Arrange
    const mockTransport = {
      send: vi.fn()
        .mockRejectedValueOnce(new Error('Network error'))
        .mockRejectedValueOnce(new Error('Network error'))
        .mockResolvedValueOnce({ messageId: '123' })
    }
    
    const service = new EmailService(mockTransport, { 
      maxRetries: 3,
      retryDelay: 100
    })
    
    const email = {
      to: 'user@example.com',
      subject: 'Test',
      body: 'Hello'
    }
    
    // Act
    const result = await service.send(email)
    
    // Assert
    expect(result.messageId).toBe('123')
    expect(mockTransport.send).toHaveBeenCalledTimes(3)
  })
})
```

### AAA Best Practices

```typescript
// âœ… GOOD - Clear separation
it('should calculate shipping cost', () => {
  // Arrange
  const order = createOrder({ weight: 5, distance: 100 })
  
  // Act
  const cost = calculateShipping(order)
  
  // Assert
  expect(cost).toBe(15)
})

// âŒ BAD - Mixed arrange and act
it('should calculate shipping cost', () => {
  const order = createOrder({ weight: 5 })
  const cost1 = calculateShipping(order)
  order.distance = 100
  const cost2 = calculateShipping(order)
  
  expect(cost2).toBeGreaterThan(cost1)
})

// âœ… GOOD - Multiple assertions for single action
it('should update user profile', async () => {
  // Arrange
  const user = await createUser()
  const updates = { name: 'New Name', bio: 'New bio' }
  
  // Act
  await updateProfile(user.id, updates)
  
  // Assert - All related to single action
  const updated = await getUser(user.id)
  expect(updated.name).toBe('New Name')
  expect(updated.bio).toBe('New bio')
  expect(updated.updatedAt).toBeInstanceOf(Date)
})

// âŒ BAD - Multiple unrelated actions
it('user operations', async () => {
  const user = await createUser()
  expect(user).toBeDefined()
  
  await updateProfile(user.id, { name: 'New' })
  expect(user.name).toBe('New')
  
  await deleteUser(user.id)
  expect(await getUser(user.id)).toBeNull()
})
```

---

## 8.3 Test Naming Conventions

### BDD-Style (Behavior-Driven Development)

```typescript
describe('when user is logged in', () => {
  describe('and user is an admin', () => {
    it('should allow access to admin panel', () => {
      // test
    })
    
    it('should allow user deletion', () => {
      // test
    })
  })
  
  describe('and user is a regular user', () => {
    it('should deny access to admin panel', () => {
      // test
    })
    
    it('should allow profile editing', () => {
      // test
    })
  })
})
```

### Should-Style

```typescript
describe('UserValidator', () => {
  it('should accept valid email addresses', () => {})
  it('should reject emails without @ symbol', () => {})
  it('should reject emails with multiple @ symbols', () => {})
  it('should accept emails with subdomains', () => {})
})
```

### Given-When-Then Style

```typescript
describe('Shopping Cart', () => {
  it('given empty cart, when item added, then cart contains 1 item', () => {
    // Arrange (Given)
    const cart = new ShoppingCart()
    
    // Act (When)
    cart.addItem({ id: 1, name: 'Product' })
    
    // Assert (Then)
    expect(cart.itemCount).toBe(1)
  })
  
  it('given cart with item, when item removed, then cart is empty', () => {
    const cart = new ShoppingCart()
    cart.addItem({ id: 1, name: 'Product' })
    
    cart.removeItem(1)
    
    expect(cart.itemCount).toBe(0)
  })
})
```

### Descriptive Scenario Style

```typescript
describe('Authentication', () => {
  it('allows login with valid credentials', () => {})
  
  it('rejects login with incorrect password', () => {})
  
  it('locks account after 5 failed attempts', () => {})
  
  it('sends password reset email when requested', () => {})
  
  it('expires password reset tokens after 1 hour', () => {})
})
```

### Component Testing Names

```typescript
describe('LoginForm component', () => {
  it('renders email and password inputs', () => {})
  
  it('shows validation error for invalid email', () => {})
  
  it('disables submit button while loading', () => {})
  
  it('calls onSubmit with form data when submitted', () => {})
  
  it('displays error message when login fails', () => {})
})
```

### Naming Best Practices

```typescript
// âœ… GOOD - Clear, specific, describes behavior
it('should return null when user not found', () => {})
it('should throw error when amount is negative', () => {})
it('should send confirmation email after successful registration', () => {})

// âŒ BAD - Vague, implementation-focused
it('should work', () => {})
it('test validation', () => {})
it('should return value', () => {})

// âœ… GOOD - Describes the scenario
it('should apply 10% discount for premium members', () => {})
it('should reject orders with more than 100 items', () => {})

// âŒ BAD - Tests implementation details
it('should call validateEmail function', () => {})
it('should set isLoading to false', () => {})
```

---

## 8.4 Test Independence

### The Problem with Dependent Tests

```typescript
// âŒ BAD - Tests depend on execution order
describe('User CRUD', () => {
  let userId: number
  
  it('should create user', async () => {
    const user = await createUser({ name: 'John' })
    userId = user.id  // Shared state!
    expect(user).toBeDefined()
  })
  
  it('should update user', async () => {
    // Depends on previous test
    await updateUser(userId, { name: 'Jane' })
    const user = await getUser(userId)
    expect(user.name).toBe('Jane')
  })
  
  it('should delete user', async () => {
    // Depends on previous tests
    await deleteUser(userId)
    expect(await getUser(userId)).toBeNull()
  })
})

// Problem: If first test fails, all subsequent tests fail
// Problem: Can't run tests in isolation or in parallel
```

### Solution: Independent Tests

```typescript
// âœ… GOOD - Each test is independent
describe('User CRUD', () => {
  describe('create', () => {
    it('should create user with valid data', async () => {
      const user = await createUser({ name: 'John' })
      
      expect(user).toBeDefined()
      expect(user.name).toBe('John')
      
      // Cleanup
      await deleteUser(user.id)
    })
  })
  
  describe('update', () => {
    it('should update user name', async () => {
      // Setup for this test
      const user = await createUser({ name: 'John' })
      
      // Test update
      await updateUser(user.id, { name: 'Jane' })
      const updated = await getUser(user.id)
      
      expect(updated.name).toBe('Jane')
      
      // Cleanup
      await deleteUser(user.id)
    })
  })
  
  describe('delete', () => {
    it('should delete user', async () => {
      // Setup for this test
      const user = await createUser({ name: 'John' })
      
      // Test delete
      await deleteUser(user.id)
      
      expect(await getUser(user.id)).toBeNull()
    })
  })
})
```

### Using beforeEach for Independent Setup

```typescript
describe('ShoppingCart', () => {
  let cart: ShoppingCart
  
  // Fresh cart for each test
  beforeEach(() => {
    cart = new ShoppingCart()
  })
  
  it('should start empty', () => {
    expect(cart.items).toHaveLength(0)
  })
  
  it('should add item', () => {
    cart.addItem({ id: 1, name: 'Product', price: 10 })
    expect(cart.items).toHaveLength(1)
  })
  
  it('should remove item', () => {
    cart.addItem({ id: 1, name: 'Product', price: 10 })
    cart.removeItem(1)
    expect(cart.items).toHaveLength(0)
  })
  
  // Each test runs with a fresh cart
  // Tests can run in any order
  // Tests can run in parallel
})
```

### Database Test Independence

```typescript
describe('Database operations', () => {
  let db: Database
  
  beforeEach(async () => {
    // Fresh database for each test
    db = await createTestDatabase()
    await db.migrate()
  })
  
  afterEach(async () => {
    // Clean up after each test
    await db.destroy()
  })
  
  it('should insert user', async () => {
    const user = await db.users.create({ name: 'John' })
    expect(user.id).toBeDefined()
  })
  
  it('should find user', async () => {
    await db.users.create({ name: 'John' })
    const user = await db.users.findOne({ name: 'John' })
    expect(user).toBeDefined()
  })
})
```

### Test Independence Checklist

```typescript
// âœ… Tests should be independent if:
- They can run in any order
- They can run in parallel
- Skipping one test doesn't break others
- Each test has its own setup
- Each test cleans up after itself

// âŒ Warning signs of dependent tests:
- Tests share mutable state
- Tests rely on previous test results
- Tests must run in specific order
- Test names like "test 1", "test 2"
- Tests fail when run individually
```

---

## 8.5 Testing Edge Cases

### What Are Edge Cases?

Edge cases are inputs or conditions at the extremes of expected behavior.

```typescript
// Function to test
function divide(a: number, b: number): number {
  if (b === 0) throw new Error('Division by zero')
  return a / b
}

describe('divide function', () => {
  // âœ… Normal cases
  it('should divide positive numbers', () => {
    expect(divide(10, 2)).toBe(5)
  })
  
  // âœ… Edge cases
  it('should handle zero dividend', () => {
    expect(divide(0, 5)).toBe(0)
  })
  
  it('should throw on zero divisor', () => {
    expect(() => divide(10, 0)).toThrow('Division by zero')
  })
  
  it('should handle negative numbers', () => {
    expect(divide(-10, 2)).toBe(-5)
    expect(divide(10, -2)).toBe(-5)
    expect(divide(-10, -2)).toBe(5)
  })
  
  it('should handle very small numbers', () => {
    expect(divide(0.0001, 0.0001)).toBe(1)
  })
  
  it('should handle very large numbers', () => {
    expect(divide(1e308, 1e308)).toBe(1)
  })
  
  it('should handle infinity', () => {
    expect(divide(Infinity, 2)).toBe(Infinity)
  })
})
```

### Boundary Value Testing

```typescript
// Age validation: 18-120
function validateAge(age: number): boolean {
  return age >= 18 && age <= 120
}

describe('validateAge', () => {
  // Test boundaries
  it('should accept age 18 (minimum)', () => {
    expect(validateAge(18)).toBe(true)
  })
  
  it('should accept age 120 (maximum)', () => {
    expect(validateAge(120)).toBe(true)
  })
  
  it('should reject age 17 (below minimum)', () => {
    expect(validateAge(17)).toBe(false)
  })
  
  it('should reject age 121 (above maximum)', () => {
    expect(validateAge(121)).toBe(false)
  })
  
  it('should reject negative age', () => {
    expect(validateAge(-1)).toBe(false)
  })
  
  it('should reject zero', () => {
    expect(validateAge(0)).toBe(false)
  })
})
```

### Empty/Null/Undefined Cases

```typescript
function processItems(items: string[]): number {
  return items.filter(item => item.length > 0).length
}

describe('processItems edge cases', () => {
  it('should handle empty array', () => {
    expect(processItems([])).toBe(0)
  })
  
  it('should handle array with empty strings', () => {
    expect(processItems(['', '', ''])).toBe(0)
  })
  
  it('should handle mixed array', () => {
    expect(processItems(['a', '', 'b', ''])).toBe(2)
  })
  
  it('should handle single item', () => {
    expect(processItems(['item'])).toBe(1)
  })
  
  it('should handle very long array', () => {
    const items = Array(10000).fill('item')
    expect(processItems(items)).toBe(10000)
  })
})
```

### String Edge Cases

```typescript
function formatName(name: string): string {
  return name.trim().toLowerCase()
}

describe('formatName edge cases', () => {
  it('should handle empty string', () => {
    expect(formatName('')).toBe('')
  })
  
  it('should handle whitespace only', () => {
    expect(formatName('   ')).toBe('')
  })
  
  it('should handle leading/trailing spaces', () => {
    expect(formatName('  John  ')).toBe('john')
  })
  
  it('should handle single character', () => {
    expect(formatName('A')).toBe('a')
  })
  
  it('should handle special characters', () => {
    expect(formatName('HÃ©llo WÃ¶rld')).toBe('hÃ©llo wÃ¶rld')
  })
  
  it('should handle unicode', () => {
    expect(formatName('ã“ã‚“ã«ã¡ã¯')).toBe('ã“ã‚“ã«ã¡ã¯')
  })
  
  it('should handle very long string', () => {
    const longString = 'a'.repeat(10000)
    expect(formatName(longString)).toHaveLength(10000)
  })
})
```

### Date/Time Edge Cases

```typescript
function isBusinessDay(date: Date): boolean {
  const day = date.getDay()
  return day > 0 && day < 6
}

describe('isBusinessDay edge cases', () => {
  it('should handle Monday (start of week)', () => {
    const monday = new Date('2024-01-01') // Monday
    expect(isBusinessDay(monday)).toBe(true)
  })
  
  it('should handle Friday (end of week)', () => {
    const friday = new Date('2024-01-05') // Friday
    expect(isBusinessDay(friday)).toBe(true)
  })
  
  it('should handle Saturday', () => {
    const saturday = new Date('2024-01-06')
    expect(isBusinessDay(saturday)).toBe(false)
  })
  
  it('should handle Sunday', () => {
    const sunday = new Date('2024-01-07')
    expect(isBusinessDay(sunday)).toBe(false)
  })
  
  it('should handle leap year', () => {
    const leapDay = new Date('2024-02-29')
    expect(isBusinessDay(leapDay)).toBe(true) // Thursday
  })
  
  it('should handle daylight saving change', () => {
    const dstStart = new Date('2024-03-10') // DST starts
    expect(isBusinessDay(dstStart)).toBe(true)
  })
})
```

### Error Handling Edge Cases

```typescript
async function fetchData(url: string): Promise<Data> {
  const response = await fetch(url)
  if (!response.ok) throw new Error(`HTTP ${response.status}`)
  return response.json()
}

describe('fetchData error cases', () => {
  it('should handle 404', async () => {
    global.fetch = vi.fn().mockResolvedValue({
      ok: false,
      status: 404
    })
    
    await expect(fetchData('/api/data')).rejects.toThrow('HTTP 404')
  })
  
  it('should handle 500', async () => {
    global.fetch = vi.fn().mockResolvedValue({
      ok: false,
      status: 500
    })
    
    await expect(fetchData('/api/data')).rejects.toThrow('HTTP 500')
  })
  
  it('should handle network error', async () => {
    global.fetch = vi.fn().mockRejectedValue(
      new Error('Network error')
    )
    
    await expect(fetchData('/api/data')).rejects.toThrow('Network error')
  })
  
  it('should handle timeout', async () => {
    global.fetch = vi.fn().mockImplementation(() => 
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Timeout')), 100)
      )
    )
    
    await expect(fetchData('/api/data')).rejects.toThrow('Timeout')
  })
})
```

### Edge Case Checklist

```typescript
// Numbers
- Zero
- Negative numbers
- Very large numbers
- Very small numbers
- Infinity / -Infinity
- NaN
- Decimals vs integers

// Strings
- Empty string
- Whitespace only
- Single character
- Very long strings
- Special characters
- Unicode characters

// Arrays
- Empty array
- Single item
- Duplicate items
- Very large array
- Mixed types (if applicable)

// Objects
- Empty object
- Missing properties
- Null values
- Undefined values
- Circular references

// Dates
- Leap years
- Month boundaries
- DST transitions
- Timezones
- Past/future dates

// Booleans
- True
- False
- Truthy values
- Falsy values
```

---

## Summary: Chapter 8

### Key Testing Strategies

1. **Test Pyramid**
   - 70% Unit tests (fast, isolated)
   - 20% Integration tests (medium, combined)
   - 10% E2E tests (slow, full system)

2. **AAA Pattern**
   - Arrange: Set up test conditions
   - Act: Execute code under test
   - Assert: Verify outcomes

3. **Test Naming**
   - Clear, descriptive names
   - Describes behavior, not implementation
   - Should/Given-When-Then styles

4. **Test Independence**
   - Each test runs in isolation
   - No shared mutable state
   - Can run in any order

5. **Edge Cases**
   - Test boundaries
   - Test empty/null/undefined
   - Test error conditions
   - Test extremes

### Quick Reference

```typescript
// Test Pyramid Distribution
Unit:        70% - Pure functions, business logic
Integration: 20% - API + DB, service interactions
E2E:        10% - Critical user flows

// AAA Pattern
it('should do something', () => {
  // Arrange - setup
  // Act - execute
  // Assert - verify
})

// Independence
beforeEach(() => {
  // Fresh setup for each test
})

afterEach(() => {
  // Cleanup after each test
})
```

**Testing is about confidence, not coverage.** Focus on testing the right things in the right way, and your tests will provide value for years to come.