# Chapter 5: Testing Specific Technologies - Complete Guide

## 5.1 Testing React Components

### Setup for React Testing

```bash
# Install dependencies
npm install -D @testing-library/react @testing-library/jest-dom @testing-library/user-event
```

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'happy-dom', // or 'jsdom'
    setupFiles: './test/setup.ts'
  }
})
```

```typescript
// test/setup.ts
import { expect, afterEach } from 'vitest'
import { cleanup } from '@testing-library/react'
import * as matchers from '@testing-library/jest-dom/matchers'

expect.extend(matchers)

afterEach(() => {
  cleanup()
})
```

### Basic Component Testing

```typescript
// Button.tsx
import { ReactNode } from 'react'

interface ButtonProps {
  children: ReactNode
  onClick?: () => void
  variant?: 'primary' | 'secondary'
  disabled?: boolean
}

export function Button({ 
  children, 
  onClick, 
  variant = 'primary',
  disabled = false 
}: ButtonProps) {
  return (
    <button
      className={`btn btn-${variant}`}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  )
}
```

```typescript
// Button.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { Button } from './Button'

describe('Button Component', () => {
  it('should render with text', () => {
    render(<Button>Click Me</Button>)
    
    expect(screen.getByText('Click Me')).toBeInTheDocument()
  })
  
  it('should apply variant class', () => {
    render(<Button variant="secondary">Click Me</Button>)
    
    const button = screen.getByRole('button')
    expect(button).toHaveClass('btn-secondary')
  })
  
  it('should call onClick when clicked', async () => {
    const handleClick = vi.fn()
    const user = userEvent.setup()
    
    render(<Button onClick={handleClick}>Click Me</Button>)
    
    await user.click(screen.getByRole('button'))
    
    expect(handleClick).toHaveBeenCalledTimes(1)
  })
  
  it('should not call onClick when disabled', async () => {
    const handleClick = vi.fn()
    const user = userEvent.setup()
    
    render(<Button onClick={handleClick} disabled>Click Me</Button>)
    
    await user.click(screen.getByRole('button'))
    
    expect(handleClick).not.toHaveBeenCalled()
  })
})
```

### Testing Component State

```typescript
// Counter.tsx
import { useState } from 'react'

export function Counter() {
  const [count, setCount] = useState(0)
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  )
}
```

```typescript
// Counter.test.tsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { Counter } from './Counter'

describe('Counter Component', () => {
  it('should start at 0', () => {
    render(<Counter />)
    expect(screen.getByText('Count: 0')).toBeInTheDocument()
  })
  
  it('should increment count', async () => {
    const user = userEvent.setup()
    render(<Counter />)
    
    await user.click(screen.getByText('Increment'))
    
    expect(screen.getByText('Count: 1')).toBeInTheDocument()
  })
  
  it('should decrement count', async () => {
    const user = userEvent.setup()
    render(<Counter />)
    
    await user.click(screen.getByText('Increment'))
    await user.click(screen.getByText('Increment'))
    await user.click(screen.getByText('Decrement'))
    
    expect(screen.getByText('Count: 1')).toBeInTheDocument()
  })
  
  it('should reset count', async () => {
    const user = userEvent.setup()
    render(<Counter />)
    
    await user.click(screen.getByText('Increment'))
    await user.click(screen.getByText('Increment'))
    await user.click(screen.getByText('Reset'))
    
    expect(screen.getByText('Count: 0')).toBeInTheDocument()
  })
})
```

### Testing Forms and Input

```typescript
// LoginForm.tsx
import { useState, FormEvent } from 'react'

interface LoginFormProps {
  onSubmit: (email: string, password: string) => void
}

export function LoginForm({ onSubmit }: LoginFormProps) {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [error, setError] = useState('')
  
  const handleSubmit = (e: FormEvent) => {
    e.preventDefault()
    
    if (!email || !password) {
      setError('All fields are required')
      return
    }
    
    if (!email.includes('@')) {
      setError('Invalid email format')
      return
    }
    
    setError('')
    onSubmit(email, password)
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label htmlFor="email">Email</label>
        <input
          id="email"
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
      </div>
      
      <div>
        <label htmlFor="password">Password</label>
        <input
          id="password"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
      </div>
      
      {error && <div role="alert">{error}</div>}
      
      <button type="submit">Login</button>
    </form>
  )
}
```

```typescript
// LoginForm.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { LoginForm } from './LoginForm'

describe('LoginForm Component', () => {
  it('should render form fields', () => {
    render(<LoginForm onSubmit={vi.fn()} />)
    
    expect(screen.getByLabelText('Email')).toBeInTheDocument()
    expect(screen.getByLabelText('Password')).toBeInTheDocument()
    expect(screen.getByRole('button', { name: 'Login' })).toBeInTheDocument()
  })
  
  it('should submit form with valid data', async () => {
    const handleSubmit = vi.fn()
    const user = userEvent.setup()
    
    render(<LoginForm onSubmit={handleSubmit} />)
    
    await user.type(screen.getByLabelText('Email'), 'user@example.com')
    await user.type(screen.getByLabelText('Password'), 'password123')
    await user.click(screen.getByRole('button', { name: 'Login' }))
    
    expect(handleSubmit).toHaveBeenCalledWith('user@example.com', 'password123')
  })
  
  it('should show error for empty fields', async () => {
    const user = userEvent.setup()
    
    render(<LoginForm onSubmit={vi.fn()} />)
    
    await user.click(screen.getByRole('button', { name: 'Login' }))
    
    expect(screen.getByRole('alert')).toHaveTextContent('All fields are required')
  })
  
  it('should show error for invalid email', async () => {
    const user = userEvent.setup()
    
    render(<LoginForm onSubmit={vi.fn()} />)
    
    await user.type(screen.getByLabelText('Email'), 'invalid-email')
    await user.type(screen.getByLabelText('Password'), 'password123')
    await user.click(screen.getByRole('button', { name: 'Login' }))
    
    expect(screen.getByRole('alert')).toHaveTextContent('Invalid email format')
  })
})
```

### Testing Async Components

```typescript
// UserProfile.tsx
import { useEffect, useState } from 'react'

interface User {
  id: number
  name: string
  email: string
}

interface UserProfileProps {
  userId: number
}

export function UserProfile({ userId }: UserProfileProps) {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => {
        if (!res.ok) throw new Error('Failed to fetch')
        return res.json()
      })
      .then(data => {
        setUser(data)
        setLoading(false)
      })
      .catch(err => {
        setError(err.message)
        setLoading(false)
      })
  }, [userId])
  
  if (loading) return <div>Loading...</div>
  if (error) return <div role="alert">Error: {error}</div>
  if (!user) return null
  
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  )
}
```

```typescript
// UserProfile.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import { UserProfile } from './UserProfile'

describe('UserProfile Component', () => {
  beforeEach(() => {
    global.fetch = vi.fn()
  })
  
  it('should show loading state initially', () => {
    vi.mocked(fetch).mockImplementation(() => 
      new Promise(() => {}) // Never resolves
    )
    
    render(<UserProfile userId={1} />)
    
    expect(screen.getByText('Loading...')).toBeInTheDocument()
  })
  
  it('should display user data after loading', async () => {
    const mockUser = {
      id: 1,
      name: 'John Doe',
      email: 'john@example.com'
    }
    
    vi.mocked(fetch).mockResolvedValue({
      ok: true,
      json: async () => mockUser
    } as Response)
    
    render(<UserProfile userId={1} />)
    
    // Wait for loading to finish
    await waitFor(() => {
      expect(screen.queryByText('Loading...')).not.toBeInTheDocument()
    })
    
    expect(screen.getByText('John Doe')).toBeInTheDocument()
    expect(screen.getByText('john@example.com')).toBeInTheDocument()
  })
  
  it('should display error message on fetch failure', async () => {
    vi.mocked(fetch).mockResolvedValue({
      ok: false
    } as Response)
    
    render(<UserProfile userId={1} />)
    
    await waitFor(() => {
      expect(screen.getByRole('alert')).toBeInTheDocument()
    })
    
    expect(screen.getByText(/Error:/)).toBeInTheDocument()
  })
})
```

### Testing with React Context

```typescript
// ThemeContext.tsx
import { createContext, useContext, useState, ReactNode } from 'react'

type Theme = 'light' | 'dark'

const ThemeContext = createContext<{
  theme: Theme
  toggleTheme: () => void
} | null>(null)

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<Theme>('light')
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light')
  }
  
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  )
}

export function useTheme() {
  const context = useContext(ThemeContext)
  if (!context) throw new Error('useTheme must be used within ThemeProvider')
  return context
}

// ThemedButton.tsx
export function ThemedButton() {
  const { theme, toggleTheme } = useTheme()
  
  return (
    <button 
      onClick={toggleTheme}
      className={`btn-${theme}`}
    >
      Current theme: {theme}
    </button>
  )
}
```

```typescript
// ThemedButton.test.tsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { ThemeProvider } from './ThemeContext'
import { ThemedButton } from './ThemedButton'

describe('ThemedButton with Context', () => {
  it('should display current theme', () => {
    render(
      <ThemeProvider>
        <ThemedButton />
      </ThemeProvider>
    )
    
    expect(screen.getByText(/Current theme: light/)).toBeInTheDocument()
  })
  
  it('should toggle theme on click', async () => {
    const user = userEvent.setup()
    
    render(
      <ThemeProvider>
        <ThemedButton />
      </ThemeProvider>
    )
    
    const button = screen.getByRole('button')
    
    expect(button).toHaveTextContent('Current theme: light')
    
    await user.click(button)
    
    expect(button).toHaveTextContent('Current theme: dark')
    
    await user.click(button)
    
    expect(button).toHaveTextContent('Current theme: light')
  })
})
```

### Query Selectors Best Practices

```typescript
describe('Query priorities', () => {
  // ✅ BEST - Accessible to everyone
  screen.getByRole('button', { name: 'Submit' })
  screen.getByLabelText('Email')
  screen.getByPlaceholderText('Enter email')
  screen.getByText('Welcome')
  
  // ✅ GOOD - Semantic queries
  screen.getByAltText('Profile picture')
  screen.getByTitle('Close')
  
  // ⚠️ USE WITH CAUTION - Test IDs
  screen.getByTestId('submit-button')
  
  // ❌ AVOID - Implementation details
  // screen.getByClassName('btn-primary')
  // container.querySelector('.button')
})
```

---

## 5.2 Testing Vue Components

### Setup for Vue Testing

```bash
# Install dependencies
npm install -D @vue/test-utils @testing-library/vue happy-dom
```

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  test: {
    globals: true,
    environment: 'happy-dom'
  }
})
```

### Basic Vue Component Testing

```vue
<!-- Button.vue -->
<template>
  <button 
    :class="`btn btn-${variant}`"
    :disabled="disabled"
    @click="handleClick"
  >
    <slot></slot>
  </button>
</template>

<script setup lang="ts">
interface Props {
  variant?: 'primary' | 'secondary'
  disabled?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  variant: 'primary',
  disabled: false
})

const emit = defineEmits<{
  click: []
}>()

const handleClick = () => {
  emit('click')
}
</script>
```

```typescript
// Button.test.ts
import { describe, it, expect, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import Button from './Button.vue'

describe('Button Component', () => {
  it('should render slot content', () => {
    const wrapper = mount(Button, {
      slots: {
        default: 'Click Me'
      }
    })
    
    expect(wrapper.text()).toBe('Click Me')
  })
  
  it('should apply variant class', () => {
    const wrapper = mount(Button, {
      props: {
        variant: 'secondary'
      },
      slots: {
        default: 'Click Me'
      }
    })
    
    expect(wrapper.classes()).toContain('btn-secondary')
  })
  
  it('should emit click event', async () => {
    const wrapper = mount(Button, {
      slots: {
        default: 'Click Me'
      }
    })
    
    await wrapper.trigger('click')
    
    expect(wrapper.emitted('click')).toHaveLength(1)
  })
  
  it('should not emit when disabled', async () => {
    const wrapper = mount(Button, {
      props: {
        disabled: true
      },
      slots: {
        default: 'Click Me'
      }
    })
    
    await wrapper.trigger('click')
    
    expect(wrapper.emitted('click')).toBeUndefined()
  })
})
```

### Testing Vue Component with Composition API

```vue
<!-- Counter.vue -->
<template>
  <div>
    <p>Count: {{ count }}</p>
    <button @click="increment">Increment</button>
    <button @click="decrement">Decrement</button>
    <button @click="reset">Reset</button>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'

const count = ref(0)

const increment = () => {
  count.value++
}

const decrement = () => {
  count.value--
}

const reset = () => {
  count.value = 0
}
</script>
```

```typescript
// Counter.test.ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import Counter from './Counter.vue'

describe('Counter Component', () => {
  it('should start at 0', () => {
    const wrapper = mount(Counter)
    
    expect(wrapper.text()).toContain('Count: 0')
  })
  
  it('should increment count', async () => {
    const wrapper = mount(Counter)
    
    await wrapper.find('button').trigger('click')
    
    expect(wrapper.text()).toContain('Count: 1')
  })
  
  it('should handle multiple operations', async () => {
    const wrapper = mount(Counter)
    const buttons = wrapper.findAll('button')
    
    await buttons[0].trigger('click') // Increment
    await buttons[0].trigger('click') // Increment
    expect(wrapper.text()).toContain('Count: 2')
    
    await buttons[1].trigger('click') // Decrement
    expect(wrapper.text()).toContain('Count: 1')
    
    await buttons[2].trigger('click') // Reset
    expect(wrapper.text()).toContain('Count: 0')
  })
})
```

### Testing Vue Component with Props and Emits

```vue
<!-- UserCard.vue -->
<template>
  <div class="user-card">
    <h2>{{ user.name }}</h2>
    <p>{{ user.email }}</p>
    <button @click="handleEdit">Edit</button>
    <button @click="handleDelete">Delete</button>
  </div>
</template>

<script setup lang="ts">
interface User {
  id: number
  name: string
  email: string
}

interface Props {
  user: User
}

const props = defineProps<Props>()

const emit = defineEmits<{
  edit: [user: User]
  delete: [userId: number]
}>()

const handleEdit = () => {
  emit('edit', props.user)
}

const handleDelete = () => {
  emit('delete', props.user.id)
}
</script>
```

```typescript
// UserCard.test.ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import UserCard from './UserCard.vue'

describe('UserCard Component', () => {
  const mockUser = {
    id: 1,
    name: 'John Doe',
    email: 'john@example.com'
  }
  
  it('should display user information', () => {
    const wrapper = mount(UserCard, {
      props: {
        user: mockUser
      }
    })
    
    expect(wrapper.text()).toContain('John Doe')
    expect(wrapper.text()).toContain('john@example.com')
  })
  
  it('should emit edit event with user', async () => {
    const wrapper = mount(UserCard, {
      props: {
        user: mockUser
      }
    })
    
    await wrapper.find('button').trigger('click')
    
    expect(wrapper.emitted('edit')).toHaveLength(1)
    expect(wrapper.emitted('edit')?.[0]).toEqual([mockUser])
  })
  
  it('should emit delete event with user id', async () => {
    const wrapper = mount(UserCard, {
      props: {
        user: mockUser
      }
    })
    
    const buttons = wrapper.findAll('button')
    await buttons[1].trigger('click')
    
    expect(wrapper.emitted('delete')).toHaveLength(1)
    expect(wrapper.emitted('delete')?.[0]).toEqual([mockUser.id])
  })
})
```

### Testing Pinia Stores

```typescript
// stores/counter.ts
import { defineStore } from 'pinia'
import { ref } from 'vue'

export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)
  
  function increment() {
    count.value++
  }
  
  function decrement() {
    count.value--
  }
  
  return { count, increment, decrement }
})
```

```typescript
// stores/counter.test.ts
import { describe, it, expect, beforeEach } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useCounterStore } from './counter'

describe('Counter Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })
  
  it('should initialize with 0', () => {
    const store = useCounterStore()
    expect(store.count).toBe(0)
  })
  
  it('should increment count', () => {
    const store = useCounterStore()
    
    store.increment()
    
    expect(store.count).toBe(1)
  })
  
  it('should decrement count', () => {
    const store = useCounterStore()
    
    store.increment()
    store.increment()
    store.decrement()
    
    expect(store.count).toBe(1)
  })
})
```

---

## 5.3 Testing Svelte Components

### Setup for Svelte Testing

```bash
# Install dependencies
npm install -D @testing-library/svelte @testing-library/jest-dom
```

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import { svelte } from '@sveltejs/vite-plugin-svelte'

export default defineConfig({
  plugins: [svelte()],
  test: {
    globals: true,
    environment: 'happy-dom'
  }
})
```

### Basic Svelte Component Testing

```svelte
<!-- Button.svelte -->
<script lang="ts">
  export let variant: 'primary' | 'secondary' = 'primary'
  export let disabled = false
  
  import { createEventDispatcher } from 'svelte'
  const dispatch = createEventDispatcher()
  
  function handleClick() {
    dispatch('click')
  }
</script>

<button
  class="btn btn-{variant}"
  {disabled}
  on:click={handleClick}
>
  <slot></slot>
</button>
```

```typescript
// Button.test.ts
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/svelte'
import userEvent from '@testing-library/user-event'
import Button from './Button.svelte'

describe('Button Component', () => {
  it('should render with text', () => {
    render(Button, { props: {}, slots: { default: 'Click Me' } })
    
    expect(screen.getByText('Click Me')).toBeInTheDocument()
  })
  
  it('should apply variant class', () => {
    render(Button, { 
      props: { variant: 'secondary' },
      slots: { default: 'Click Me' }
    })
    
    const button = screen.getByRole('button')
    expect(button).toHaveClass('btn-secondary')
  })
  
  it('should dispatch click event', async () => {
    const user = userEvent.setup()
    const { component } = render(Button, {
      slots: { default: 'Click Me' }
    })
    
    const clickHandler = vi.fn()
    component.$on('click', clickHandler)
    
    await user.click(screen.getByRole('button'))
    
    expect(clickHandler).toHaveBeenCalledTimes(1)
  })
})
```

---

## 5.4 Testing API/HTTP Calls with MSW

### What is MSW (Mock Service Worker)?

MSW intercepts network requests at the network level, providing realistic API mocking without changing your application code.

```
┌─────────────────────────────────────┐
│   Traditional Mocking               │
├─────────────────────────────────────┤
│   App → Mock fetch() function       │
│   (Mocks implementation details)    │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│   MSW (Mock Service Worker)         │
├─────────────────────────────────────┤
│   App → Real fetch() → MSW → Mock   │
│   (Mocks at network boundary)       │
└─────────────────────────────────────┘
```

### Setup MSW

```bash
npm install -D msw
```

```typescript
// mocks/handlers.ts
import { http, HttpResponse } from 'msw'

export const handlers = [
  http.get('/api/users/:id', ({ params }) => {
    const { id } = params
    
    return HttpResponse.json({
      id: Number(id),
      name: 'John Doe',
      email: 'john@example.com'
    })
  }),
  
  http.post('/api/users', async ({ request }) => {
    const body = await request.json()
    
    return HttpResponse.json({
      id: 1,
      ...body
    }, { status: 201 })
  }),
  
  http.delete('/api/users/:id', () => {
    return new HttpResponse(null, { status: 204 })
  })
]
```

```typescript
// mocks/server.ts
import { setupServer } from 'msw/node'
import { handlers } from './handlers'

export const server = setupServer(...handlers)
```

```typescript
// test/setup.ts
import { beforeAll, afterEach, afterAll } from 'vitest'
import { server } from '../mocks/server'

beforeAll(() => server.listen())
afterEach(() => server.resetHandlers())
afterAll(() => server.close())
```

### Testing with MSW

```typescript
// api.ts
export async function fetchUser(id: number) {
  const response = await fetch(`/api/users/${id}`)
  if (!response.ok) throw new Error('Failed to fetch user')
  return response.json()
}

export async function createUser(data: { name: string; email: string }) {
  const response = await fetch('/api/users', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  })
  if (!response.ok) throw new Error('Failed to create user')
  return response.json()
}

export async function deleteUser(id: number) {
  const response = await fetch(`/api/users/${id}`, {
    method: 'DELETE'
  })
  if (!response.ok) throw new Error('Failed to delete user')
}
```

```typescript
// api.test.ts
import { describe, it, expect } from 'vitest'
import { http, HttpResponse } from 'msw'
import { server } from '../mocks/server'
import { fetchUser, createUser, deleteUser } from './api'

describe('API Functions', () => {
  describe('fetchUser', () => {
    it('should fetch user successfully', async () => {
      const user = await fetchUser(1)
      
      expect(user).toEqual({
        id: 1,
        name: 'John Doe',
        email: 'john@example.com'
      })
    })
    
    it('should handle 404 error', async () => {
      server.use(
        http.get('/api/users/:id', () => {
          return new HttpResponse(null, { status: 404 })
        })
      )
      
      await expect(fetchUser(999)).rejects.toThrow('Failed to fetch user')
    })
  })
  
  describe('createUser', () => {
    it('should create user successfully', async () => {
      const userData = { name: 'Jane', email: 'jane@example.com' }
      const user = await createUser(userData)
      
      expect(user).toEqual({
        id: 1,
        ...userData
      })
    })
  })
  
  describe('deleteUser', () => {
    it('should delete user successfully', async () => {
      await expect(deleteUser(1)).resolves.toBeUndefined()
    })
  })
})
```

### Testing Different Response Scenarios

```typescript
describe('API Error Scenarios', () => {
  it('should handle network errors', async () => {
    server.use(
      http.get('/api/users/:id', () => {
        return HttpResponse.error()
      })
    )
    
    await expect(fetchUser(1)).rejects.toThrow()
  })
  
  it('should handle timeout', async () => {
    server.use(
      http.get('/api/users/:id', async () => {
        await new Promise(resolve => setTimeout(resolve, 10000))
        return HttpResponse.json({ id: 1 })
      })
    )
    
    // Test with timeout logic
  })
  
  it('should handle validation errors', async () => {
    server.use(
      http.post('/api/users', () => {
        return HttpResponse.json(
          { error: 'Invalid email format' },
          { status: 400 }
        )
      })
    )
    
    await expect(
      createUser({ name: 'John', email: 'invalid' })
    ).rejects.toThrow()
  })
})
```

---

## 5.5 Testing DOM Manipulation

### Setup for DOM Testing

```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    environment: 'happy-dom' // or 'jsdom'
  }
})
```

### Testing Direct DOM Manipulation

```typescript
// dom.ts
export function createButton(text: string): HTMLButtonElement {
  const button = document.createElement('button')
  button.textContent = text
  button.className = 'btn'
  return button
}

export function appendToBody(element: HTMLElement): void {
  document.body.appendChild(element)
}

export function removeFromBody(element: HTMLElement): void {
  document.body.removeChild(element)
}
```

```typescript
// dom.test.ts
import { describe, it, expect, afterEach } from 'vitest'
import { createButton, appendToBody, removeFromBody } from './dom'

describe('DOM Manipulation', () => {
  afterEach(() => {
    document.body.innerHTML = ''
  })
  
  it('should create button with text', () => {
    const button = createButton('Click Me')
    
    expect(button.tagName).toBe('BUTTON')
    expect(button.textContent).toBe('Click Me')
    expect(button.className).toBe('btn')
  })
  
  it('should append element to body', () => {
    const button = createButton('Test')
    
    appendToBody(button)
    
    expect(document.body.contains(button)).toBe(true)
    expect(document.querySelectorAll('button')).toHaveLength(1)
  })
  
  it('should remove element from body', () => {
    const button = createButton('Test')
    appendToBody(button)
    
    removeFromBody(button)
    
    expect(document.body.contains(button)).toBe(false)
    expect(document.querySelectorAll('button')).toHaveLength(0)
  })
})
```

### Testing Event Listeners

```typescript
// eventHandler.ts
export class ClickCounter {
  private count = 0
  private button: HTMLButtonElement
  
  constructor(buttonId: string) {
    this.button = document.getElementById(buttonId) as HTMLButtonElement
    this.button.addEventListener('click', this.handleClick)
  }
  
  private handleClick = () => {
    this.count++
    this.button.textContent = `Clicked ${this.count} times`
  }
  
  getCount(): number {
    return this.count
  }
  
  destroy(): void {
    this.button.removeEventListener('click', this.handleClick)
  }
}
```

```typescript
// eventHandler.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { ClickCounter } from './eventHandler'

describe('ClickCounter', () => {
  let button: HTMLButtonElement
  let counter: ClickCounter
  
  beforeEach(() => {
    button = document.createElement('button')
    button.id = 'test-button'
    button.textContent = 'Click Me'
    document.body.appendChild(button)
    
    counter = new ClickCounter('test-button')
  })
  
  afterEach(() => {
    counter.destroy()
    document.body.innerHTML = ''
  })
  
  it('should increment count on click', () => {
    button.click()
    
    expect(counter.getCount()).toBe(1)
    expect(button.textContent).toBe('Clicked 1 times')
  })
  
  it('should handle multiple clicks', () => {
    button.click()
    button.click()
    button.click()
    
    expect(counter.getCount()).toBe(3)
    expect(button.textContent).toBe('Clicked 3 times')
  })
})
```

### Testing CSS Manipulation

```typescript
// styles.ts
export function toggleClass(
  element: HTMLElement,
  className: string
): void {
  element.classList.toggle(className)
}

export function setStyles(
  element: HTMLElement,
  styles: Partial<CSSStyleDeclaration>
): void {
  Object.assign(element.style, styles)
}
```

```typescript
// styles.test.ts
import { describe, it, expect, beforeEach } from 'vitest'
import { toggleClass, setStyles } from './styles'

describe('Style Manipulation', () => {
  let element: HTMLDivElement
  
  beforeEach(() => {
    element = document.createElement('div')
  })
  
  it('should toggle class', () => {
    toggleClass(element, 'active')
    expect(element.classList.contains('active')).toBe(true)
    
    toggleClass(element, 'active')
    expect(element.classList.contains('active')).toBe(false)
  })
  
  it('should set styles', () => {
    setStyles(element, {
      color: 'red',
      fontSize: '16px',
      display: 'block'
    })
    
    expect(element.style.color).toBe('red')
    expect(element.style.fontSize).toBe('16px')
    expect(element.style.display).toBe('block')
  })
})
```

---

## Summary: Chapter 5

### Key Takeaways

**React Testing:**
- Use `@testing-library/react` for component testing
- Query by role, label, text (accessibility-first)
- Use `userEvent` for realistic interactions
- Test behavior, not implementation

**Vue Testing:**
- Use `@vue/test-utils` for mounting components
- Test props, emits, and slots
- Use Pinia for state management testing
- Mount components in isolation

**Svelte Testing:**
- Use `@testing-library/svelte`
- Test components with event dispatchers
- Focus on user interactions

**MSW for API Testing:**
- Mock at network boundary
- Realistic request/response testing
- Easy to test error scenarios
- No changes to application code

**DOM Testing:**
- Use `happy-dom` or `jsdom`
- Test direct DOM manipulation
- Clean up after each test
- Test event listeners and styles

### Testing Checklist

- ✅ Test user interactions, not implementation
- ✅ Use accessible queries (role, label)
- ✅ Clean up after each test
- ✅ Mock external dependencies (API calls)
- ✅ Test async operations with waitFor
- ✅ Test error states and edge cases
- ✅ Keep tests isolated and independent

**Next Chapter Preview**: Chapter 6 will cover configuration deep-dives, performance optimization, TypeScript integration, and production-grade test setups.