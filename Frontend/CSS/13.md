# Chapter 13: Performance Optimization - In-Depth Explanation

## Introduction to CSS Performance

**CSS Performance** directly impacts page load speed, user experience, and SEO. Poor CSS can block rendering, cause layout shifts, and slow down interactions.

**Why Performance Matters:**
- 1 second delay = 7% reduction in conversions
- Google ranks faster sites higher
- Users abandon slow sites (53% leave if > 3 seconds)
- Performance is a feature, not an afterthought

**Key Metrics:**
- **FCP** (First Contentful Paint): When first content appears
- **LCP** (Largest Contentful Paint): When main content loads
- **CLS** (Cumulative Layout Shift): Visual stability
- **TTI** (Time to Interactive): When page is fully interactive

---

## 13.1 Rendering Performance

### Critical Rendering Path

**The Critical Rendering Path** is the sequence of steps browsers take to render a page.

**Steps:**
1. **DOM Construction**: Parse HTML → DOM tree
2. **CSSOM Construction**: Parse CSS → CSSOM tree
3. **Render Tree**: Combine DOM + CSSOM
4. **Layout**: Calculate positions and sizes
5. **Paint**: Draw pixels on screen
6. **Composite**: Combine layers

```
HTML → DOM ╮
           ├→ Render Tree → Layout → Paint → Composite
CSS → CSSOM ╯
```

**CSS blocks rendering!** Browser must download and parse ALL CSS before rendering.

---

### Render-Blocking CSS

**Problem:** CSS blocks page rendering by default.

```html
<!-- Render-blocking (traditional) -->
<link rel="stylesheet" href="styles.css">
<!-- Browser waits for styles.css before rendering -->
```

**What happens:**
1. Browser downloads HTML
2. Finds `<link>` tag
3. **Stops rendering** to download CSS
4. Parses CSS
5. **Only then** renders page

**Impact:** Delays FCP (First Contentful Paint)

---

### Optimization Strategies

#### 1. Inline Critical CSS

Include essential "above-the-fold" CSS directly in HTML.

```html
<!DOCTYPE html>
<html>
<head>
    <style>
        /* Critical CSS (inline) - renders immediately */
        body {
            font-family: system-ui;
            margin: 0;
        }
        .header {
            background: blue;
            padding: 20px;
        }
        .hero {
            height: 100vh;
            display: flex;
            align-items: center;
        }
    </style>
    
    <!-- Non-critical CSS (async load) -->
    <link rel="preload" href="main.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="main.css"></noscript>
</head>
<body>
    <!-- Above-the-fold content -->
</body>
</html>
```

**Benefits:**
- Faster FCP (no CSS download wait)
- Progressive rendering
- Better perceived performance

**How much critical CSS?**
- Typically 14KB or less (TCP slow start threshold)
- Only above-the-fold styles
- Use tools to extract automatically

**Tools:**
- Critical (npm package)
- Penthouse
- critters-webpack-plugin

---

#### 2. Async Loading Non-Critical CSS

```html
<!-- Method 1: Preload + onload swap -->
<link rel="preload" href="styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="styles.css"></noscript>

<!-- Method 2: Media query swap -->
<link rel="stylesheet" href="styles.css" media="print" onload="this.media='all'">

<!-- Method 3: JavaScript loading -->
<script>
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = 'styles.css';
    document.head.appendChild(link);
</script>
```

---

#### 3. Preload Critical Assets

```html
<!-- Preload fonts -->
<link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin>

<!-- Preload critical CSS -->
<link rel="preload" href="critical.css" as="style">
<link rel="stylesheet" href="critical.css">

<!-- Preconnect to external domains -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
```

**Preload Hierarchy:**
1. Critical CSS
2. Web fonts
3. Hero images
4. Other resources

---

### CSS Containment (contain Property)

**CSS Containment** isolates elements, allowing browser to optimize rendering.

```css
.component {
    contain: none;      /* No containment (default) */
    contain: size;      /* Size doesn't affect outside */
    contain: layout;    /* Layout isolated */
    contain: style;     /* Style counters isolated */
    contain: paint;     /* Paint isolated */
    contain: strict;    /* All containment */
    contain: content;   /* layout + paint + style */
}

/* Common combinations */
.widget {
    contain: layout style paint;
}

.independent-component {
    contain: strict;  /* Maximum isolation */
}
```

**What Each Type Does:**

**size:**
- Element size calculated independently
- Doesn't affect parent size
- **Use carefully**: Can cause overflow issues

**layout:**
- Element's internal layout isolated
- Changes inside don't affect outside layout
- Great for independent components

**paint:**
- Element's painting isolated
- Content can't paint outside bounds
- Enables optimization

**style:**
- Style containment (counters, quotes)
- Rarely used alone

**Example:**
```css
/* Independent card that doesn't affect page layout */
.card {
    contain: layout paint;
    /* Layout and paint changes inside card don't trigger page reflow */
}

/* Feed items that don't affect each other */
.feed-item {
    contain: content;  /* layout + paint + style */
}
```

**When to use:**
- Repeated components (cards, list items)
- Infinite scroll items
- Independent widgets
- Third-party content

---

### content-visibility (Modern!)

**Game-changer for performance!** Skips rendering off-screen content.

```css
.section {
    content-visibility: auto;  /* Render when near viewport */
    contain-intrinsic-size: 0 500px;  /* Estimated size when not rendered */
}

/* Values */
.element {
    content-visibility: visible;  /* Normal (default) */
    content-visibility: hidden;   /* Skip rendering (like display: none but keeps size) */
    content-visibility: auto;     /* Render when near viewport ✓ BEST */
}
```

**How it works:**
- **auto**: Browser skips rendering until element is near viewport
- **Massive performance boost** for long pages
- Must provide `contain-intrinsic-size` (estimated size)

**Example:**
```css
/* Long article with sections */
.article-section {
    content-visibility: auto;
    contain-intrinsic-size: 0 1000px;  /* Estimate: 1000px tall */
}

/* Benefits:
   - Sections off-screen not rendered
   - Scroll to them → render
   - Reduces initial render time by 50-90%!
*/
```

**Best Practices:**
```css
/* Use on repeated, similar-sized elements */
.blog-post {
    content-visibility: auto;
    contain-intrinsic-size: 0 800px;
}

.product-card {
    content-visibility: auto;
    contain-intrinsic-size: 0 400px;
}

/* Don't use on above-the-fold content */
.hero {
    /* No content-visibility here! */
}
```

**Performance Impact:**
- **Before**: Render 1000 items = slow
- **After**: Render ~10 visible items = fast!
- **Improvement**: 50-90% faster initial render

---

## 13.2 Optimization Techniques

### Minification and Compression

**Minification** removes unnecessary characters (whitespace, comments).

**Before minification:**
```css
/* Button styles */
.button {
    background: blue;
    color: white;
    padding: 10px 20px;
    border-radius: 4px;
}

.button:hover {
    background: darkblue;
}
```

**After minification:**
```css
.button{background:blue;color:white;padding:10px 20px;border-radius:4px}.button:hover{background:darkblue}
```

**Savings:** 30-40% file size reduction

**Tools:**
- **cssnano** (PostCSS plugin)
- **clean-css**
- **csso**
- Build tools (Webpack, Vite) include minification

---

**Compression (Gzip/Brotli):**

Configure server to compress CSS:

```
Before compression: 100 KB
After Gzip: 20 KB (80% reduction!)
After Brotli: 17 KB (83% reduction!)
```

**Server Configuration (example):**
```nginx
# Nginx
gzip on;
gzip_types text/css;
gzip_min_length 1000;

# Or Brotli (better!)
brotli on;
brotli_types text/css;
```

---

### Removing Unused CSS

**Problem:** CSS files often contain unused styles.

**Typical site:**
- Bootstrap CSS: 150 KB
- Actually used: 20 KB
- **Wasted: 130 KB (87%!)**

**Solutions:**

#### 1. PurgeCSS (Most Popular)

```javascript
// PostCSS config
module.exports = {
    plugins: [
        require('@fullhuman/postcss-purgecss')({
            content: [
                './src/**/*.html',
                './src/**/*.js',
            ],
            defaultExtractor: content => content.match(/[\w-/:]+(?<!:)/g) || []
        })
    ]
}
```

**What it does:**
- Scans HTML/JS files for class names
- Removes CSS for unused classes
- **Result:** 80-95% smaller CSS files!

#### 2. UnCSS

```javascript
const uncss = require('uncss');

uncss(['index.html'], function (error, output) {
    console.log(output); // Cleaned CSS
});
```

#### 3. Manual Tree Shaking

```css
/* Before: Large utility library */
.mt-0 { margin-top: 0; }
.mt-1 { margin-top: 4px; }
.mt-2 { margin-top: 8px; }
/* ... 100+ utilities */

/* After: Only used utilities */
.mt-0 { margin-top: 0; }
.mt-4 { margin-top: 16px; }
/* 98% smaller! */
```

---

### Critical CSS Extraction

**Strategy:** Inline critical CSS, defer the rest.

**Tools:**

#### 1. Critical (npm)

```javascript
const critical = require('critical');

critical.generate({
    inline: true,
    base: 'dist/',
    src: 'index.html',
    dest: 'index-critical.html',
    width: 1300,
    height: 900
});
```

**Output:**
```html
<head>
    <style>
        /* Inlined critical CSS */
        .header { ... }
        .hero { ... }
    </style>
    
    <!-- Deferred non-critical -->
    <link rel="preload" href="main.css" as="style" onload="this.rel='stylesheet'">
</head>
```

#### 2. Critters (Webpack Plugin)

```javascript
const Critters = require('critters-webpack-plugin');

module.exports = {
    plugins: [
        new Critters({
            preload: 'swap',
            pruneSource: true
        })
    ]
};
```

---

### CSS Loading Strategies

#### 1. Blocking (Default - Slowest)

```html
<link rel="stylesheet" href="styles.css">
<!-- Blocks rendering until CSS loads -->
```

**Impact:**
- **FCP delayed** until CSS loads
- **LCP delayed**
- User sees blank page

---

#### 2. Non-Blocking (Async Load)

```html
<!-- Method 1: Preload -->
<link rel="preload" href="styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="styles.css"></noscript>

<!-- Method 2: Media trick -->
<link rel="stylesheet" href="styles.css" media="print" onload="this.media='all'">
```

**Impact:**
- **Fast FCP** (doesn't wait for CSS)
- May see FOUC (Flash of Unstyled Content)
- Better for non-critical CSS

---

#### 3. Split Critical and Non-Critical

```html
<head>
    <!-- Critical: Inline (instant) -->
    <style>
        /* Above-the-fold styles */
        .header { background: blue; }
        .hero { height: 100vh; }
    </style>
    
    <!-- Non-critical: Async load -->
    <link rel="preload" href="main.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
</head>
```

**This is the BEST approach!**

---

### HTTP/2 and CSS

**HTTP/2 Advantages:**
- Multiple files can load simultaneously
- No need to concatenate everything into one file
- Can split CSS by route/component

**Before (HTTP/1.1):**
```html
<!-- One large file (better for HTTP/1.1) -->
<link rel="stylesheet" href="all-styles.css">
```

**After (HTTP/2):**
```html
<!-- Split files load in parallel -->
<link rel="stylesheet" href="critical.css">
<link rel="stylesheet" href="components.css">
<link rel="stylesheet" href="utilities.css">
```

---

## 13.3 Efficient Selectors

### Selector Performance Reality

**Common Myth:** "Complex selectors are slow!"  
**Reality:** Selector matching is **rarely** the bottleneck.

**Modern browsers are FAST at selector matching:**
- Selectors evaluated right-to-left
- Highly optimized
- Usually < 1ms total for entire page

**What actually matters:**
1. Number of style recalculations
2. Layout/reflow frequency
3. Paint operations
4. Number of DOM elements

---

### Right-to-Left Parsing

Browsers evaluate selectors **from right to left**.

```css
/* How browser reads this: */
div .container .nav ul li a { }

/* 1. Find all <a> elements (rightmost/key selector)
   2. Check if parent is <li>
   3. Check if ancestor is <ul>
   4. Check if ancestor is .nav
   5. Check if ancestor is .container
   6. Check if ancestor is <div>
*/
```

**Key Selector** (rightmost) determines initial set:

```css
/* Bad key selector (matches many elements) */
* { }           /* Matches everything */
div { }         /* Matches all divs */
.container * { } /* Matches everything in .container */

/* Good key selector (matches few elements) */
.nav-link { }
#unique-id { }
.specific-component { }
```

**However:** Modern browsers are so fast this rarely matters!

---

### Selector Efficiency (Reality Check)

**Don't worry too much about:**
```css
/* These are all fine in modern browsers */
.container .nav ul li a { }
div > p + span { }
[type="text"]:focus { }
```

**DO worry about:**
```css
/* ❌ Universal selector as key */
.container * { }
* > * { }

/* ❌ Overly complex (hard to maintain) */
body div.container #main-content .article:first-child > p.intro:nth-of-type(2) { }

/* ❌ !important overuse */
.element { color: red !important; }
```

**Focus on:**
- **Maintainability** over micro-optimization
- **Specificity management** (more important than speed)
- **Number of reflows** (way more important than selectors)

---

### Performance Best Practices for Selectors

```css
/* ✅ Good: Specific, maintainable */
.nav-link { }
.card-title { }
.button-primary { }

/* ✅ Good: Clear hierarchy */
.nav > .nav-item { }

/* ❌ Avoid: Overly complex */
div.container > ul.list li:nth-child(odd) a.link { }

/* ❌ Avoid: Unqualified attribute selectors */
[type="text"] { }  /* Matches ALL type="text", not just inputs */

/* ✅ Better: Qualified */
input[type="text"] { }
```

---

## 13.4 Properties That Affect Performance

### The Pixel Pipeline

**Every visual change goes through steps:**

```
JavaScript → Style → Layout → Paint → Composite
```

**Different properties trigger different steps:**

#### 1. Layout (Reflow) - SLOWEST ❌

**Triggers:** Changing size/position
- `width`, `height`
- `margin`, `padding`, `border`
- `top`, `left`, `right`, `bottom` (with position)
- `font-size`
- `display`

```css
/* ❌ Triggers Layout (expensive) */
.element {
    width: 200px;
    transition: width 0.3s;
}
.element:hover {
    width: 300px;  /* Reflows entire page! */
}
```

**Impact:** Recalculates layout for affected elements and children

---

#### 2. Paint - MODERATE ⚠️

**Triggers:** Changing appearance (not size/position)
- `background-color`
- `color`
- `box-shadow`
- `border-radius` (sometimes)
- `visibility`

```css
/* ⚠️ Triggers Paint (moderate cost) */
.element {
    background: blue;
    transition: background 0.3s;
}
.element:hover {
    background: red;  /* Repaints element */
}
```

**Impact:** Repaints element (doesn't affect layout)

---

#### 3. Composite Only - FASTEST ✅

**Triggers:** GPU-accelerated properties
- `transform` (all functions)
- `opacity`

```css
/* ✅ Composite only (very fast) */
.element {
    transform: translateX(0);
    opacity: 1;
    transition: transform 0.3s, opacity 0.3s;
}
.element:hover {
    transform: translateX(100px);  /* Composites only! */
    opacity: 0.8;
}
```

**Impact:** GPU handles it, no layout or paint!

---

### Performance Optimization Rules

**Rule 1: Animate only transform and opacity**

```css
/* ❌ Expensive (causes layout) */
@keyframes slideIn {
    from { left: -100px; }
    to { left: 0; }
}

/* ✅ Cheap (compositing only) */
@keyframes slideIn {
    from { transform: translateX(-100px); }
    to { transform: translateX(0); }
}
```

**Rule 2: Avoid layout thrashing**

```javascript
// ❌ Layout thrashing (read, write, read, write)
elements.forEach(el => {
    const height = el.offsetHeight;  // Read (triggers layout)
    el.style.height = height + 10 + 'px';  // Write
});

// ✅ Batch reads and writes
const heights = elements.map(el => el.offsetHeight);  // All reads
elements.forEach((el, i) => {
    el.style.height = heights[i] + 10 + 'px';  // All writes
});
```

**Rule 3: Use will-change for upcoming changes**

```css
/* Before expensive operation */
.element:hover {
    will-change: transform;
}

.element:active {
    transform: scale(0.95);
}
```

**Rule 4: Avoid forced synchronous layouts**

```javascript
// ❌ Forces layout in loop
for (let i = 0; i < 1000; i++) {
    element.style.width = element.offsetWidth + 1 + 'px';
    // offsetWidth forces layout calculation!
}

// ✅ Calculate once
const width = element.offsetWidth;
element.style.width = width + 1000 + 'px';
```

---

## 13.5 Font Performance

### Font Loading Strategies

#### 1. font-display Property

```css
@font-face {
    font-family: 'CustomFont';
    src: url('font.woff2') format('woff2');
    font-display: swap;  /* Show fallback immediately, swap when ready */
}

/* Values: */
font-display: auto;      /* Browser default (usually block) */
font-display: block;     /* Hide text 3s, then show (FOIT) */
font-display: swap;      /* Show fallback, swap when ready ✓ BEST */
font-display: fallback;  /* Short block (100ms), swap with timeout */
font-display: optional;  /* Only swap if loads very quickly */
```

**Visual Timeline:**

**block (default):**
```
0s        3s        ∞
├─────────┼─────────→
[Invisible]  [Custom font or fallback shown]
```

**swap (recommended):**
```
0s        ∞
├─────────→
[Fallback] [Swap to custom when ready]
```

**fallback:**
```
0s   0.1s     3s        ∞
├─────┼────────┼─────────→
[Hide] [Fallback] [Swap or keep fallback]
```

**Best Practice:**
```css
@font-face {
    font-family: 'MyFont';
    src: url('font.woff2') format('woff2');
    font-display: swap;  /* Always use swap! Prevents FOIT */
}
```

---

#### 2. Preload Fonts

```html
<!-- Preload critical fonts -->
<link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin>

<!-- Then define @font-face -->
<style>
    @font-face {
        font-family: 'CustomFont';
        src: url('font.woff2') format('woff2');
        font-display: swap;
    }
</style>
```

---

#### 3. Font Subsetting

**Reduce font file size** by including only needed characters.

```
Full font: 200 KB (all characters)
Subset (Latin only): 40 KB (80% smaller!)
Subset (specific chars): 10 KB (95% smaller!)
```

**Tools:**
- **Glyphhanger**: Extract used characters
- **FontSquirrel**: Generate subsets
- **Google Fonts**: Use &text= parameter

```html
<!-- Google Fonts subset -->
<link href="https://fonts.googleapis.com/css2?family=Roboto&text=ABCDEFabcdef" rel="stylesheet">
```

---

#### 4. Variable Fonts

**One file for all weights** instead of separate files.

```css
/* Traditional: Multiple files */
@font-face { font-weight: 400; src: url('font-400.woff2'); }  /* 50 KB */
@font-face { font-weight: 700; src: url('font-700.woff2'); }  /* 50 KB */
/* Total: 100 KB */

/* Variable font: One file */
@font-face {
    font-family: 'CustomFont';
    src: url('font-variable.woff2') format('woff2');
    font-weight: 100 900;  /* All weights in one file! */
}
/* Total: 70 KB (30% smaller!) */
```

---

## 13.6 Image Optimization

### Responsive Images

```html
<!-- srcset for different resolutions -->
<img 
    src="image-800.jpg"
    srcset="image-400.jpg 400w,
            image-800.jpg 800w,
            image-1200.jpg 1200w"
    sizes="(max-width: 600px) 400px,
           (max-width: 1000px) 800px,
           1200px"
    alt="Description">
```

### Modern Image Formats

```html
<picture>
    <!-- WebP for modern browsers -->
    <source srcset="image.webp" type="image/webp">
    
    <!-- AVIF for cutting-edge browsers -->
    <source srcset="image.avif" type="image/avif">
    
    <!-- JPEG fallback -->
    <img src="image.jpg" alt="Description">
</picture>
```

**File Size Comparison:**
```
JPEG: 100 KB
WebP: 60 KB (40% smaller)
AVIF: 40 KB (60% smaller!)
```

### Lazy Loading

```html
<!-- Native lazy loading -->
<img src="image.jpg" loading="lazy" alt="Description">

<!-- Critical images: Eager load -->
<img src="hero.jpg" loading="eager" alt="Hero">
```

---

## 13.7 Performance Monitoring

### CSS Performance Metrics

**Key metrics to track:**

**1. First Contentful Paint (FCP)**
- When first content appears
- Target: < 1.8s

**2. Largest Contentful Paint (LCP)**
- When main content loads
- Target: < 2.5s
- **CSS can block this!**

**3. Cumulative Layout Shift (CLS)**
- Visual stability (elements shifting)
- Target: < 0.1
- **CSS causes this** (missing dimensions)

**4. Total Blocking Time (TBT)**
- How long page is unresponsive
- CSS parsing contributes

---

### Measuring Performance

```javascript
// Performance API
const perfData = performance.getEntriesByType('navigation')[0];
console.log('DOM Content Loaded:', perfData.domContentLoadedEventEnd);

// CSS load time
const cssEntries = performance.getEntriesByType('resource')
    .filter(entry => entry.name.endsWith('.css'));
console.log('CSS load times:', cssEntries);

// Layout shift monitoring
let cls = 0;
new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
        if (!entry.hadRecentInput) {
            cls += entry.value;
        }
    }
}).observe({type: 'layout-shift', buffered: true});
```

---

## Interview Key Points

**Most Common Questions:**

**1. "How does CSS block rendering?"**
```
CSS is render-blocking by default
Browser must download and parse ALL CSS before rendering
Solution: Inline critical CSS, async load rest
```

**2. "What's critical CSS?"**
```
Above-the-fold CSS inlined in HTML
Enables fast FCP without waiting for CSS download
Extract with tools like Critical, Critters
Typically < 14 KB
```

**3. "Best properties to animate for performance?"**
```
✅ transform, opacity (GPU-accelerated, composite-only)
❌ width, height, margin, top, left (trigger layout/paint)
```

**4. "What's content-visibility?"**
```
content-visibility: auto
Skips rendering off-screen content
Massive performance boost for long pages
Must provide contain-intrinsic-size
```

**5. "What's CSS containment?"**
```
Isolates elements to prevent layout propagation
contain: layout (layout isolated)
contain: paint (paint isolated)
contain: content (layout + paint + style)
Use on independent components
```

**6. "How to optimize font loading?"**
```
1. font-display: swap (prevent FOIT)
2. Preload critical fonts
3. Subset fonts (reduce file size)
4. Use variable fonts (one file, all weights)
```

**7. "What causes layout shifts (CLS)?"**
```
- Images without dimensions
- Dynamic content insertion
- Web fonts loading (use font-display: swap)
- Ads without reserved space
Solution: Reserve space with dimensions/min-height
```

**8. "How to remove unused CSS?"**
```
Tools: PurgeCSS, UnCSS
Scans HTML/JS for used classes
Removes unused styles
Typically 80-95% reduction!
```

**9. "Difference between paint and layout?"**
```
Layout (reflow): Recalculates positions/sizes (expensive)
Paint: Redraws pixels (moderate)
Composite: GPU layers (cheap)

Prefer triggering composite > paint > layout
```

**10. "What's the render-blocking CSS solution?"**
```
1. Inline critical CSS in <head>
2. Async load non-critical CSS
3. Use preload for important CSS
4. Split CSS into critical and non-critical
```

---

## Best Practices Checklist

### ✅ Loading Strategy
```html
<!-- Critical: Inline -->
<style>/* Critical CSS */</style>

<!-- Non-critical: Async -->
<link rel="preload" href="main.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
```

### ✅ Fonts
```css
@font-face {
    font-family: 'Custom';
    src: url('font.woff2') format('woff2');
    font-display: swap;  /* Always! */
}
```

```html
<link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin>
```

### ✅ Animations
```css
/* Only animate composite properties */
.element {
    transition: transform 0.3s, opacity 0.3s;  /* ✅ */
    /* NOT: width, height, margin, etc. */
}
```

### ✅ Long Pages
```css
.section {
    content-visibility: auto;
    contain-intrinsic-size: 0 500px;
}
```

### ✅ Images
```html
<!-- Dimensions prevent CLS -->
<img src="image.jpg" width="800" height="600" loading="lazy" alt="">

<!-- Or CSS -->
<style>
.image { aspect-ratio: 16/9; }
</style>
```

### ✅ Build Process
```javascript
// Minify CSS
// Remove unused CSS (PurgeCSS)
// Extract critical CSS
// Compress (Gzip/Brotli)
// Bundle appropriately for HTTP/2
```

---

## Performance Audit Tools

**Chrome DevTools:**
- Lighthouse (Performance audit)
- Coverage tab (unused CSS)
- Performance tab (rendering analysis)
- Rendering tab (paint flashing, layer borders)

**Online Tools:**
- WebPageTest
- GTmetrix
- PageSpeed Insights
- CSS Stats

**Build Tools:**
- webpack-bundle-analyzer
- PurgeCSS
- cssnano
- Critical

---

## Real-World Performance Checklist

```css
/* ✅ Use this checklist for every project */

/* 1. Critical CSS */
- Inline above-the-fold CSS (< 14 KB)
- Async load rest

/* 2. Fonts */
- font-display: swap
- Preload critical fonts
- Subset fonts
- Consider system fonts

/* 3. Animations */
- Only transform and opacity
- Use will-change sparingly
- GPU acceleration

/* 4. Images */
- Set dimensions (prevent CLS)
- Lazy load below-fold
- Modern formats (WebP, AVIF)
- Responsive images (srcset)

/* 5. Long Pages */
- content-visibility: auto
- contain: content on components

/* 6. Build Process */
- Minify CSS
- Remove unused CSS
- Gzip/Brotli compression
- Split by route (code splitting)

/* 7. Avoid */
- !important overuse
- Deep selector nesting
- Layout properties in animations
- Synchronous fonts
- Large CSS files
```

---

## Practice Exercises

1. Extract critical CSS from a webpage
2. Implement async CSS loading
3. Optimize a font loading strategy
4. Reduce CSS file size with PurgeCSS
5. Audit a website's CSS performance
6. Refactor animations to use only transform/opacity
7. Implement content-visibility on long page
8. Set up build process with minification
9. Measure and improve LCP
10. Fix layout shifts caused by images