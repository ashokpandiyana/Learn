# Chapter 3: configureStore() - Deep Dive

## Overview

`configureStore()` is the foundation of every Redux Toolkit application. It wraps the Redux `createStore()` function with better defaults and simplifies store setup dramatically. This chapter explores everything you need to know about configuring your Redux store.

---

## 3.1 Basic Store Configuration

### Minimal Setup

The simplest store configuration requires only a reducer:

```javascript
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';

const store = configureStore({
  reducer: counterReducer
});

export default store;
```

This single line replaces this vanilla Redux setup:

```javascript
// ‚ùå Vanilla Redux equivalent
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import { composeWithDevTools } from 'redux-devtools-extension';

const store = createStore(
  counterReducer,
  composeWithDevTools(applyMiddleware(thunk))
);
```

### Configuration Options

`configureStore()` accepts an options object:

```javascript
const store = configureStore({
  reducer,           // Required: root reducer or object of slice reducers
  middleware,        // Optional: custom middleware array or function
  devTools,          // Optional: enable/disable DevTools (default: true in dev)
  preloadedState,    // Optional: initial state
  enhancers          // Optional: store enhancers array or function
});
```

### Root Reducer Concept

You can pass reducers in two ways:

#### **Method 1: Single Reducer Function**

```javascript
import { combineReducers } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';
import todosReducer from './todosSlice';

const rootReducer = combineReducers({
  counter: counterReducer,
  todos: todosReducer
});

const store = configureStore({
  reducer: rootReducer
});

// State shape:
{
  counter: { value: 0 },
  todos: []
}
```

#### **Method 2: Object of Slice Reducers (Recommended)**

```javascript
import counterReducer from './counterSlice';
import todosReducer from './todosSlice';
import userReducer from './userSlice';

const store = configureStore({
  reducer: {
    counter: counterReducer,
    todos: todosReducer,
    user: userReducer
  }
});

// Same state shape as above - configureStore calls combineReducers internally
```

**Which to use?**
- **Object form:** Simpler, more readable (use this 90% of the time)
- **Function form:** Needed for custom reducer logic or middleware injection

### Understanding State Shape

The keys in your reducer object become the top-level state properties:

```javascript
const store = configureStore({
  reducer: {
    users: usersReducer,      // state.users
    posts: postsReducer,      // state.posts
    comments: commentsReducer // state.comments
  }
});

// Accessing in components:
const users = useSelector(state => state.users);
const posts = useSelector(state => state.posts);
```

**Nested Structure Example:**

```javascript
const store = configureStore({
  reducer: {
    auth: authReducer,
    data: combineReducers({
      users: usersReducer,
      posts: postsReducer
    }),
    ui: uiReducer
  }
});

// State shape:
{
  auth: { token: '...', user: {...} },
  data: {
    users: [...],
    posts: [...]
  },
  ui: { darkMode: true, sidebarOpen: false }
}

// Access nested state:
const users = useSelector(state => state.data.users);
```

---

## 3.2 Middleware Configuration

### What is Middleware?

Middleware sits between dispatching an action and the reducer, allowing you to:
- Log actions
- Perform async operations
- Transform actions
- Cancel actions
- Dispatch other actions

**Middleware Flow:**

```
Component
    ‚Üì dispatch(action)
Middleware 1 (e.g., logger)
    ‚Üì
Middleware 2 (e.g., thunk)
    ‚Üì
Middleware 3 (e.g., custom)
    ‚Üì
Reducer
    ‚Üì
New State
    ‚Üì
Component Re-renders
```

### Default Middleware

`configureStore()` automatically adds:

1. **redux-thunk** - For async logic
2. **immutableCheck** - Warns if you mutate state (dev only)
3. **serializableCheck** - Warns if non-serializable values in state (dev only)

```javascript
// This is what's included by default:
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) => getDefaultMiddleware()
  // Includes: [thunk, immutableCheck, serializableCheck]
});
```

### Customizing Middleware

#### **Adding Custom Middleware**

```javascript
import { configureStore } from '@reduxjs/toolkit';

// Custom logger middleware
const loggerMiddleware = (storeAPI) => (next) => (action) => {
  console.log('Dispatching:', action);
  const result = next(action);
  console.log('Next state:', storeAPI.getState());
  return result;
};

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(loggerMiddleware)
});

// Middleware chain: [thunk, immutableCheck, serializableCheck, loggerMiddleware]
```

#### **Prepending Middleware**

```javascript
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().prepend(loggerMiddleware)
});

// Middleware chain: [loggerMiddleware, thunk, immutableCheck, serializableCheck]
```

#### **Replacing Default Middleware**

```javascript
// ‚ö†Ô∏è Warning: You lose default checks!
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) => [loggerMiddleware]
});

// Only loggerMiddleware - no thunk, no checks!
```

#### **Configuring Default Middleware**

```javascript
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      thunk: true, // Enable/disable thunk (default: true)
      immutableCheck: true, // Enable/disable immutability check (default: true in dev)
      serializableCheck: {
        // Customize serializable check
        ignoredActions: ['todos/addTodo'],
        ignoredPaths: ['items.date'],
      }
    })
});
```

### Real-World Middleware Examples

#### **1. API Call Logger**

```javascript
const apiLoggerMiddleware = (storeAPI) => (next) => (action) => {
  if (action.type.includes('fetch') || action.type.includes('api')) {
    console.log('API Action:', action.type);
    console.log('Payload:', action.payload);
  }
  return next(action);
};
```

#### **2. Analytics Middleware**

```javascript
const analyticsMiddleware = (storeAPI) => (next) => (action) => {
  // Send analytics event
  if (action.type.includes('/fulfilled')) {
    analytics.track('Action Completed', {
      actionType: action.type,
      timestamp: Date.now()
    });
  }
  return next(action);
};
```

#### **3. Error Reporting Middleware**

```javascript
const errorReportingMiddleware = (storeAPI) => (next) => (action) => {
  try {
    return next(action);
  } catch (error) {
    console.error('Error processing action:', action, error);
    Sentry.captureException(error);
    throw error;
  }
};
```

#### **4. Delayed Action Middleware**

```javascript
const delayMiddleware = (storeAPI) => (next) => (action) => {
  if (action.meta && action.meta.delay) {
    setTimeout(() => {
      next(action);
    }, action.meta.delay);
  } else {
    return next(action);
  }
};

// Usage:
dispatch({
  type: 'SHOW_NOTIFICATION',
  payload: 'Hello!',
  meta: { delay: 1000 } // Wait 1 second
});
```

### Complete Middleware Setup Example

```javascript
import { configureStore } from '@reduxjs/toolkit';
import { createLogger } from 'redux-logger';

const loggerMiddleware = createLogger({
  collapsed: true,
  duration: true
});

const crashReporterMiddleware = (storeAPI) => (next) => (action) => {
  try {
    return next(action);
  } catch (err) {
    console.error('Redux error:', err);
    Sentry.captureException(err, {
      extra: { action, state: storeAPI.getState() }
    });
    throw err;
  }
};

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST']
      }
    })
    .concat(crashReporterMiddleware)
    .concat(loggerMiddleware)
});
```

---

## 3.3 DevTools Integration

### Default Configuration

Redux DevTools Extension is automatically enabled in development:

```javascript
const store = configureStore({
  reducer: rootReducer
  // devTools: true (automatic in development)
});
```

### Disabling DevTools

```javascript
const store = configureStore({
  reducer: rootReducer,
  devTools: false // Completely disabled
});

// Or conditional:
const store = configureStore({
  reducer: rootReducer,
  devTools: process.env.NODE_ENV !== 'production'
});
```

### Custom DevTools Configuration

```javascript
const store = configureStore({
  reducer: rootReducer,
  devTools: {
    name: 'My App',
    trace: true, // Enable stack trace
    traceLimit: 25,
    maxAge: 50, // Max actions in history
    
    // Sanitize actions (hide sensitive data)
    actionSanitizer: (action) => {
      if (action.type === 'user/login') {
        return {
          ...action,
          payload: '<<PASSWORD_HIDDEN>>'
        };
      }
      return action;
    },
    
    // Sanitize state (hide sensitive data)
    stateSanitizer: (state) => ({
      ...state,
      auth: {
        ...state.auth,
        token: '<<TOKEN_HIDDEN>>'
      }
    })
  }
});
```

### DevTools Features You Should Know

#### **1. Time-Travel Debugging**

```javascript
// In DevTools:
// - Click any action in history
// - State rewinds to that point
// - See how UI looked then
```

#### **2. Action Filtering**

```javascript
devTools: {
  actionsDenylist: ['@@INIT', 'persist/PERSIST'],
  actionsAllowlist: ['todos/*', 'user/*']
}
```

#### **3. State Diffing**

Shows exactly what changed in state after each action.

#### **4. Manual Action Dispatch**

You can dispatch actions directly from DevTools for testing.

---

## 3.4 Advanced Store Configuration

### Preloaded State

Initialize the store with existing data:

```javascript
// Load from localStorage
const preloadedState = {
  user: JSON.parse(localStorage.getItem('user')),
  settings: JSON.parse(localStorage.getItem('settings'))
};

const store = configureStore({
  reducer: rootReducer,
  preloadedState
});
```

**When to use preloadedState?**
- Hydrating from server-side rendering
- Restoring from localStorage
- Testing with specific state
- Migration from old state shape

**Important:** Keys must match reducer keys:

```javascript
// ‚úÖ Correct
const store = configureStore({
  reducer: {
    todos: todosReducer,
    user: userReducer
  },
  preloadedState: {
    todos: [...],
    user: {...}
  }
});

// ‚ùå Wrong - 'cart' doesn't exist in reducers
preloadedState: {
  cart: [...] // This will be ignored!
}
```

### Store Enhancers

Enhancers are higher-order functions that add capabilities to the store:

```javascript
const monitorReducer = (createStore) => (reducer, initialState, enhancer) => {
  const monitoredReducer = (state, action) => {
    const start = performance.now();
    const newState = reducer(state, action);
    const end = performance.now();
    console.log(`Reducer took ${end - start}ms`);
    return newState;
  };
  
  return createStore(monitoredReducer, initialState, enhancer);
};

const store = configureStore({
  reducer: rootReducer,
  enhancers: (getDefaultEnhancers) =>
    getDefaultEnhancers().concat(monitorReducer)
});
```

### Hot Module Replacement (HMR)

Enable HMR for reducers during development:

```javascript
// store.js
import { configureStore } from '@reduxjs/toolkit';
import rootReducer from './rootReducer';

const store = configureStore({
  reducer: rootReducer
});

if (process.env.NODE_ENV === 'development' && module.hot) {
  module.hot.accept('./rootReducer', () => {
    const newRootReducer = require('./rootReducer').default;
    store.replaceReducer(newRootReducer);
  });
}

export default store;
```

**Benefits:**
- Update reducers without losing state
- Faster development cycle
- No need to recreate test scenarios

### Dynamic Reducer Injection

Add reducers at runtime (useful for code splitting):

```javascript
// store.js
const store = configureStore({
  reducer: {
    static: staticReducer // Always loaded
  }
});

// Add a property to inject reducers
store.asyncReducers = {};

store.injectReducer = (key, reducer) => {
  if (store.asyncReducers[key]) return; // Already injected
  
  store.asyncReducers[key] = reducer;
  store.replaceReducer(
    combineReducers({
      static: staticReducer,
      ...store.asyncReducers
    })
  );
};

export default store;

// Usage in lazy-loaded component:
import { useEffect } from 'react';
import { store } from './store';
import lazyReducer from './lazyReducer';

function LazyComponent() {
  useEffect(() => {
    store.injectReducer('lazy', lazyReducer);
  }, []);
  
  return <div>Lazy content</div>;
}
```

---

## 3.5 Complete Real-World Example

Here's a production-ready store configuration:

```javascript
// store.js
import { configureStore } from '@reduxjs/toolkit';
import { combineReducers } from 'redux';
import storage from 'redux-persist/lib/storage';
import { persistReducer, persistStore } from 'redux-persist';

// Import reducers
import authReducer from '../features/auth/authSlice';
import usersReducer from '../features/users/usersSlice';
import postsReducer from '../features/posts/postsSlice';
import uiReducer from '../features/ui/uiSlice';

// Custom middleware
const crashReporter = (store) => (next) => (action) => {
  try {
    return next(action);
  } catch (err) {
    console.error('Caught an exception!', err);
    Sentry.captureException(err, {
      extra: {
        action,
        state: store.getState()
      }
    });
    throw err;
  }
};

const actionLogger = (store) => (next) => (action) => {
  if (process.env.NODE_ENV === 'development') {
    console.group(action.type);
    console.info('dispatching', action);
    const result = next(action);
    console.log('next state', store.getState());
    console.groupEnd();
    return result;
  }
  return next(action);
};

// Persist configuration
const persistConfig = {
  key: 'root',
  storage,
  whitelist: ['auth', 'ui'], // Only persist these
  blacklist: ['posts'] // Don't persist these
};

const rootReducer = combineReducers({
  auth: authReducer,
  users: usersReducer,
  posts: postsReducer,
  ui: uiReducer
});

const persistedReducer = persistReducer(persistConfig, rootReducer);

// Configure store
export const store = configureStore({
  reducer: persistedReducer,
  
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: [
          'persist/PERSIST',
          'persist/REHYDRATE'
        ]
      }
    })
    .concat(crashReporter)
    .concat(actionLogger),
  
  devTools: process.env.NODE_ENV !== 'production' && {
    name: 'My Production App',
    trace: true,
    traceLimit: 25,
    
    actionSanitizer: (action) => {
      if (action.type.includes('auth/login')) {
        return {
          ...action,
          payload: {
            ...action.payload,
            password: '<<HIDDEN>>'
          }
        };
      }
      return action;
    },
    
    stateSanitizer: (state) => ({
      ...state,
      auth: {
        ...state.auth,
        token: state.auth.token ? '<<TOKEN_EXISTS>>' : null
      }
    })
  }
});

export const persistor = persistStore(store);

// Hot module replacement
if (process.env.NODE_ENV === 'development' && module.hot) {
  module.hot.accept('./rootReducer', () => {
    const newRootReducer = require('./rootReducer').default;
    store.replaceReducer(persistReducer(persistConfig, newRootReducer));
  });
}

// TypeScript types
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

---

## Best Practices Checklist

### ‚úÖ Do's

1. **Use object form for reducers** (simpler than combineReducers)
```javascript
configureStore({ reducer: { users: usersReducer } })
```

2. **Keep middleware order in mind** (prepend for priority)
```javascript
.prepend(authMiddleware).concat(loggerMiddleware)
```

3. **Disable DevTools in production**
```javascript
devTools: process.env.NODE_ENV !== 'production'
```

4. **Sanitize sensitive data in DevTools**
```javascript
actionSanitizer: (action) => ({ ...action, password: '<<HIDDEN>>' })
```

5. **Use getDefaultMiddleware() callback**
```javascript
middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(...)
```

### ‚ùå Don'ts

1. **Don't replace default middleware without good reason**
```javascript
// ‚ùå Bad - loses thunk and checks
middleware: [myMiddleware]
```

2. **Don't configure serializableCheck for everything**
```javascript
// ‚ùå Bad - defeats the purpose
serializableCheck: false
```

3. **Don't ignore preloadedState shape**
```javascript
// ‚ùå Wrong
reducer: { todos: todosReducer }
preloadedState: { tasks: [] } // Mismatch!
```

4. **Don't create multiple stores** (one store per app)

5. **Don't mutate middleware array**
```javascript
// ‚ùå Wrong
const middleware = getDefaultMiddleware();
middleware.push(myMiddleware); // Mutates!

// ‚úÖ Correct
getDefaultMiddleware().concat(myMiddleware)
```

---

## Summary

`configureStore()` is your one-stop shop for store configuration:

| Feature | What It Does | Default |
|---------|-------------|---------|
| `reducer` | Root reducer or object of reducers | Required |
| `middleware` | Customize middleware chain | Thunk + checks |
| `devTools` | Redux DevTools configuration | Enabled in dev |
| `preloadedState` | Initial state | undefined |
| `enhancers` | Store enhancers | DevTools only |

**Key Takeaways:**
1. Always use `configureStore()` instead of `createStore()`
2. Pass reducer object for simplicity
3. Customize middleware with `getDefaultMiddleware()`
4. Configure DevTools for production security
5. Use preloadedState for hydration
6. Enable HMR in development

In the next chapter, we'll dive deep into **`createSlice()`** - the most powerful Redux Toolkit API for defining state and reducers! üöÄ