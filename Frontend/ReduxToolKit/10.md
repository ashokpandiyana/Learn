# Chapter 10: Middleware and Side Effects

## Overview

Middleware is the backbone of Redux's extensibility. It intercepts actions before they reach reducers, enabling powerful patterns for side effects, logging, error handling, and more. This chapter covers everything from basic middleware to advanced patterns with createListenerMiddleware.

---

## 10.1 Understanding Redux Middleware

### What is Middleware?

Middleware is a function that sits between dispatching an action and the moment it reaches the reducer. It can:
- Log actions
- Perform async operations
- Transform actions
- Dispatch other actions
- Cancel actions
- Access state

**Flow:**

```
Component
    ‚Üì dispatch(action)
Middleware 1
    ‚Üì
Middleware 2
    ‚Üì
Middleware 3
    ‚Üì
Reducer
    ‚Üì
New State
    ‚Üì
Component re-renders
```

### Middleware Signature

```javascript
const middleware = (storeAPI) => (next) => (action) => {
  // storeAPI: { getState, dispatch }
  // next: pass to next middleware
  // action: the dispatched action
  
  // Before reducer
  console.log('Before:', action);
  
  // Pass to next middleware/reducer
  const result = next(action);
  
  // After reducer
  console.log('After:', storeAPI.getState());
  
  return result;
};
```

### Basic Middleware Example

```javascript
const loggerMiddleware = (storeAPI) => (next) => (action) => {
  console.log('Dispatching:', action.type);
  console.log('Previous state:', storeAPI.getState());
  
  // Let the action proceed
  const result = next(action);
  
  console.log('Next state:', storeAPI.getState());
  console.log('---');
  
  return result;
};

// Add to store
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(loggerMiddleware)
});
```

### Middleware Chain

Multiple middleware execute in order:

```javascript
const middleware1 = (store) => (next) => (action) => {
  console.log('MW1 before');
  const result = next(action);
  console.log('MW1 after');
  return result;
};

const middleware2 = (store) => (next) => (action) => {
  console.log('MW2 before');
  const result = next(action);
  console.log('MW2 after');
  return result;
};

// Output when action dispatched:
// MW1 before
// MW2 before
// Reducer runs
// MW2 after
// MW1 after
```

### Store Enhancers vs Middleware

**Middleware**: Intercepts actions (most common)
**Enhancers**: Wrap entire store (rare, advanced)

```javascript
// Middleware (common)
middleware: (getDefaultMiddleware) => 
  getDefaultMiddleware().concat(myMiddleware)

// Enhancer (rare)
enhancers: (getDefaultEnhancers) =>
  getDefaultEnhancers().concat(myEnhancer)
```

---

## 10.2 Built-in Middleware

### Redux Thunk (Included by Default)

Enables dispatching functions (thunks) for async logic:

```javascript
// Thunk action creator
const fetchUser = (userId) => {
  return async (dispatch, getState) => {
    dispatch({ type: 'users/fetchStart' });
    
    try {
      const response = await fetch(`/api/users/${userId}`);
      const data = await response.json();
      dispatch({ type: 'users/fetchSuccess', payload: data });
    } catch (error) {
      dispatch({ type: 'users/fetchError', error: error.message });
    }
  };
};

// Usage
dispatch(fetchUser(123));
```

**How it works:**

```javascript
// Simplified thunk middleware
const thunk = (store) => (next) => (action) => {
  // If action is a function, call it with dispatch and getState
  if (typeof action === 'function') {
    return action(store.dispatch, store.getState);
  }
  
  // Otherwise, pass it along
  return next(action);
};
```

### serializableCheck Middleware

Warns if non-serializable values in state/actions (dev only):

```javascript
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        // Ignore these action types
        ignoredActions: ['persist/PERSIST'],
        
        // Ignore these paths in state
        ignoredPaths: ['items.date'],
        
        // Disable completely (not recommended)
        // serializableCheck: false
      }
    })
});
```

**What it catches:**

```javascript
// ‚ùå Non-serializable values
dispatch({
  type: 'SET_DATA',
  payload: {
    date: new Date(),        // Date object
    func: () => {},          // Function
    promise: Promise.resolve(), // Promise
    map: new Map(),          // Map
    set: new Set()           // Set
  }
});

// Console warning: "A non-serializable value was detected..."
```

### immutableCheck Middleware

Warns if you mutate state (dev only):

```javascript
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      immutableCheck: {
        // Ignore these paths
        ignoredPaths: ['ignoredNested.path']
      }
    })
});
```

**What it catches:**

```javascript
// In a reducer (not using createSlice)
function badReducer(state, action) {
  // ‚ùå Direct mutation
  state.count = 5;
  return state;
  
  // Console warning: "A state mutation was detected..."
}
```

### actionCreatorCheck Middleware

Warns if you dispatch action creators instead of calling them:

```javascript
const incrementByAmount = (amount) => ({
  type: 'INCREMENT',
  payload: amount
});

// ‚ùå Wrong - dispatching the function
dispatch(incrementByAmount);  // Warning!

// ‚úÖ Correct - calling function first
dispatch(incrementByAmount(5));
```

---

## 10.3 Custom Middleware

### Template

```javascript
const customMiddleware = (storeAPI) => (next) => (action) => {
  // storeAPI.getState() - get current state
  // storeAPI.dispatch() - dispatch actions
  // next(action) - pass to next middleware/reducer
  // action - the dispatched action
  
  // Your logic here
  
  return next(action);
};
```

### Example 1: Analytics Middleware

```javascript
const analyticsMiddleware = (storeAPI) => (next) => (action) => {
  // Track specific actions
  if (action.type === 'todos/todoAdded') {
    analytics.track('Todo Added', {
      timestamp: Date.now(),
      text: action.payload.text
    });
  }
  
  if (action.type === 'user/login') {
    analytics.identify(action.payload.userId);
  }
  
  return next(action);
};
```

### Example 2: Error Reporting

```javascript
const errorReporterMiddleware = (storeAPI) => (next) => (action) => {
  try {
    return next(action);
  } catch (error) {
    console.error('Caught error in middleware:', error);
    
    // Report to Sentry
    Sentry.captureException(error, {
      extra: {
        action,
        state: storeAPI.getState()
      }
    });
    
    // Show user-friendly error
    storeAPI.dispatch({
      type: 'ui/showError',
      payload: 'Something went wrong!'
    });
    
    // Re-throw to stop action
    throw error;
  }
};
```

### Example 3: API Call Middleware

```javascript
const apiMiddleware = (storeAPI) => (next) => (action) => {
  // Only handle API actions
  if (action.type !== 'API_CALL') {
    return next(action);
  }
  
  const { endpoint, method, body, onSuccess, onError } = action.payload;
  
  fetch(endpoint, {
    method,
    headers: { 'Content-Type': 'application/json' },
    body: body ? JSON.stringify(body) : undefined
  })
    .then(response => response.json())
    .then(data => {
      storeAPI.dispatch({ type: onSuccess, payload: data });
    })
    .catch(error => {
      storeAPI.dispatch({ type: onError, error: error.message });
    });
  
  return next(action);
};

// Usage
dispatch({
  type: 'API_CALL',
  payload: {
    endpoint: '/api/users',
    method: 'GET',
    onSuccess: 'users/fetchSuccess',
    onError: 'users/fetchError'
  }
});
```

### Example 4: Delayed Action

```javascript
const delayMiddleware = (storeAPI) => (next) => (action) => {
  // Check for delay metadata
  if (!action.meta?.delay) {
    return next(action);
  }
  
  // Delay the action
  setTimeout(() => {
    next(action);
  }, action.meta.delay);
};

// Usage
dispatch({
  type: 'SHOW_NOTIFICATION',
  payload: 'Hello!',
  meta: { delay: 1000 }  // Wait 1 second
});
```

### Example 5: Redux Undo/Redo

```javascript
let history = [];
let historyIndex = -1;

const undoRedoMiddleware = (storeAPI) => (next) => (action) => {
  if (action.type === 'UNDO') {
    if (historyIndex > 0) {
      historyIndex--;
      return { type: 'SET_STATE', payload: history[historyIndex] };
    }
    return;
  }
  
  if (action.type === 'REDO') {
    if (historyIndex < history.length - 1) {
      historyIndex++;
      return { type: 'SET_STATE', payload: history[historyIndex] };
    }
    return;
  }
  
  const result = next(action);
  
  // Save state to history
  const newState = storeAPI.getState();
  history = history.slice(0, historyIndex + 1);
  history.push(newState);
  historyIndex = history.length - 1;
  
  return result;
};
```

### Example 6: Conditional Dispatch

```javascript
const authMiddleware = (storeAPI) => (next) => (action) => {
  // Check if user is authenticated for protected actions
  if (action.meta?.requiresAuth) {
    const state = storeAPI.getState();
    
    if (!state.auth.isAuthenticated) {
      console.warn('Action requires authentication');
      
      // Dispatch login prompt instead
      storeAPI.dispatch({
        type: 'ui/showLoginModal'
      });
      
      // Don't continue with original action
      return;
    }
  }
  
  return next(action);
};

// Usage
dispatch({
  type: 'posts/delete',
  payload: postId,
  meta: { requiresAuth: true }
});
```

---

## 10.4 createListenerMiddleware()

### What is Listener Middleware?

Modern RTK alternative to custom middleware. Provides:
- Declarative API
- Easy to write and test
- Built-in TypeScript support
- Action filtering
- State comparison
- Async support

### Basic Setup

```javascript
import { createListenerMiddleware } from '@reduxjs/toolkit';

// Create listener middleware
const listenerMiddleware = createListenerMiddleware();

// Add to store
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().prepend(listenerMiddleware.middleware)
});
```

### startListening() - Add Listeners

```javascript
// Listen for specific action
listenerMiddleware.startListening({
  actionCreator: todoAdded,
  effect: async (action, listenerApi) => {
    console.log('Todo added:', action.payload);
    
    // Can dispatch other actions
    listenerApi.dispatch(showNotification('Todo added!'));
    
    // Can access state
    const state = listenerApi.getState();
    console.log('Total todos:', state.todos.length);
  }
});
```

### Listener API

```javascript
effect: async (action, listenerApi) => {
  listenerApi.dispatch       // Dispatch actions
  listenerApi.getState       // Get current state
  listenerApi.getOriginalState  // Get state before action
  listenerApi.extra          // Extra dependencies
  listenerApi.signal         // AbortSignal for cancellation
  listenerApi.delay          // Delay execution
  listenerApi.pause          // Pause execution
  listenerApi.fork           // Create child task
  listenerApi.unsubscribe    // Remove this listener
  listenerApi.cancelActiveListeners  // Cancel all running
}
```

### Predicate Functions

Match multiple actions:

```javascript
// Match by predicate
listenerMiddleware.startListening({
  predicate: (action, currentState, previousState) => {
    // Listen for any action that ends with '/fulfilled'
    return action.type.endsWith('/fulfilled');
  },
  effect: (action, listenerApi) => {
    console.log('Async action completed:', action.type);
  }
});
```

### Matching Multiple Actions

```javascript
import { isAnyOf } from '@reduxjs/toolkit';

listenerMiddleware.startListening({
  matcher: isAnyOf(todoAdded, todoToggled, todoRemoved),
  effect: (action, listenerApi) => {
    // Runs for any of these actions
    console.log('Todo list changed');
  }
});
```

### Async Effects

```javascript
listenerMiddleware.startListening({
  actionCreator: userLoggedIn,
  effect: async (action, listenerApi) => {
    // Wait 1 second
    await listenerApi.delay(1000);
    
    // Fetch user data
    const response = await fetch(`/api/users/${action.payload.userId}`);
    const userData = await response.json();
    
    // Dispatch result
    listenerApi.dispatch(userDataLoaded(userData));
  }
});
```

### Cancellation

```javascript
listenerMiddleware.startListening({
  actionCreator: startPolling,
  effect: async (action, listenerApi) => {
    // Poll every 3 seconds
    while (true) {
      // Check if cancelled
      if (listenerApi.signal.aborted) {
        break;
      }
      
      // Fetch data
      const data = await fetch('/api/data');
      listenerApi.dispatch(dataReceived(data));
      
      // Wait 3 seconds
      await listenerApi.delay(3000);
    }
  }
});

// Cancel polling
dispatch(stopPolling());
```

### takeEvery Pattern

Run effect for every action:

```javascript
listenerMiddleware.startListening({
  actionCreator: saveData,
  effect: async (action, listenerApi) => {
    // Save to localStorage
    localStorage.setItem('data', JSON.stringify(action.payload));
  }
});
```

### takeLatest Pattern

Cancel previous, run only latest:

```javascript
listenerMiddleware.startListening({
  actionCreator: searchChanged,
  effect: async (action, listenerApi) => {
    // Cancel any in-progress searches
    listenerApi.cancelActiveListeners();
    
    // Wait a bit (debounce)
    await listenerApi.delay(300);
    
    // Perform search
    const results = await searchAPI(action.payload);
    listenerApi.dispatch(searchResults(results));
  }
});
```

### Unsubscribe Listener

```javascript
// Start listening
const unsubscribe = listenerMiddleware.startListening({
  actionCreator: todoAdded,
  effect: (action, listenerApi) => {
    console.log('Todo added');
  }
});

// Later, remove this listener
unsubscribe();

// Or remove from within effect
effect: (action, listenerApi) => {
  if (someCondition) {
    listenerApi.unsubscribe();
  }
}
```

### Complete Example

```javascript
import { 
  createListenerMiddleware, 
  isAnyOf 
} from '@reduxjs/toolkit';

const listenerMiddleware = createListenerMiddleware();

// Auto-save to localStorage
listenerMiddleware.startListening({
  matcher: isAnyOf(todoAdded, todoToggled, todoRemoved),
  effect: (action, listenerApi) => {
    const state = listenerApi.getState();
    localStorage.setItem('todos', JSON.stringify(state.todos));
  }
});

// Show notification
listenerMiddleware.startListening({
  actionCreator: todoAdded,
  effect: async (action, listenerApi) => {
    listenerApi.dispatch(
      showNotification(`Added: ${action.payload.text}`)
    );
    
    // Auto-hide after 3 seconds
    await listenerApi.delay(3000);
    listenerApi.dispatch(hideNotification());
  }
});

// Analytics
listenerMiddleware.startListening({
  predicate: (action) => action.type.startsWith('todos/'),
  effect: (action) => {
    analytics.track('Todo Action', {
      type: action.type,
      timestamp: Date.now()
    });
  }
});

// Add to store
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().prepend(listenerMiddleware.middleware)
});
```

---

## 10.5 Redux-Saga and Redux-Observable (Alternatives)

### Redux-Saga

**When to use:**
- Complex async flows
- Background tasks
- Race conditions
- Cancellation

**Example:**

```javascript
import { takeLatest, call, put } from 'redux-saga/effects';

function* fetchUserSaga(action) {
  try {
    const user = yield call(api.fetchUser, action.payload);
    yield put({ type: 'USER_FETCH_SUCCESS', user });
  } catch (error) {
    yield put({ type: 'USER_FETCH_ERROR', error });
  }
}

function* watchFetchUser() {
  yield takeLatest('USER_FETCH_REQUEST', fetchUserSaga);
}
```

**Pros:**
- Powerful for complex flows
- Easy to test (synchronous)
- Great for cancellation

**Cons:**
- Steep learning curve
- Generator syntax
- More boilerplate

### Redux-Observable

**When to use:**
- Reactive programming fans
- Complex async coordination
- WebSocket streams

**Example:**

```javascript
import { ofType } from 'redux-observable';
import { map, mergeMap } from 'rxjs/operators';

const fetchUserEpic = (action$) =>
  action$.pipe(
    ofType('USER_FETCH_REQUEST'),
    mergeMap((action) =>
      ajax.getJSON(`/api/users/${action.payload}`).pipe(
        map((user) => ({ type: 'USER_FETCH_SUCCESS', user }))
      )
    )
  );
```

**Pros:**
- Reactive programming
- Powerful operators
- Great for streams

**Cons:**
- RxJS learning curve
- Overkill for simple apps

### Comparison

| Feature | createListenerMiddleware | Redux-Saga | Redux-Observable |
|---------|-------------------------|------------|------------------|
| Learning curve | Easy | Hard | Hard |
| Async/await | ‚úÖ | ‚ùå (generators) | ‚ùå (observables) |
| Cancellation | ‚úÖ | ‚úÖ | ‚úÖ |
| TypeScript | ‚úÖ Great | ‚ö†Ô∏è OK | ‚ö†Ô∏è OK |
| Testing | ‚úÖ Easy | ‚úÖ Easy | ‚ö†Ô∏è Complex |
| Bundle size | Small | Medium | Large |

**Recommendation:** Start with `createListenerMiddleware`. Only reach for Saga/Observable if you have very complex requirements.

---

## 10.6 Real-World Patterns

### Pattern 1: Auto-save

```javascript
listenerMiddleware.startListening({
  matcher: isAnyOf(
    documentUpdated,
    documentTitleChanged,
    documentContentChanged
  ),
  effect: async (action, listenerApi) => {
    // Cancel previous save
    listenerApi.cancelActiveListeners();
    
    // Debounce: wait 2 seconds
    await listenerApi.delay(2000);
    
    // Save
    const state = listenerApi.getState();
    await fetch('/api/documents', {
      method: 'PUT',
      body: JSON.stringify(state.document)
    });
    
    listenerApi.dispatch(documentSaved());
  }
});
```

### Pattern 2: Undo/Redo

```javascript
const undoRedoMiddleware = (storeAPI) => (next) => (action) => {
  const result = next(action);
  
  // Don't track undo/redo actions themselves
  if (action.type === 'UNDO' || action.type === 'REDO') {
    return result;
  }
  
  // Store state in history
  const state = storeAPI.getState();
  storeAPI.dispatch({ 
    type: 'history/push', 
    payload: state 
  });
  
  return result;
};
```

### Pattern 3: Request Batching

```javascript
let batchedActions = [];
let batchTimeout = null;

const batchMiddleware = (storeAPI) => (next) => (action) => {
  if (action.meta?.batch) {
    // Add to batch
    batchedActions.push(action);
    
    // Clear existing timeout
    clearTimeout(batchTimeout);
    
    // Set new timeout
    batchTimeout = setTimeout(() => {
      // Dispatch all at once
      storeAPI.dispatch({
        type: 'BATCH_ACTIONS',
        payload: batchedActions
      });
      batchedActions = [];
    }, 100);
    
    return;
  }
  
  return next(action);
};
```

### Pattern 4: Rate Limiting

```javascript
const rateLimitMiddleware = (limit = 5, window = 1000) => {
  const actionCounts = new Map();
  
  return (storeAPI) => (next) => (action) => {
    const now = Date.now();
    const key = action.type;
    
    if (!actionCounts.has(key)) {
      actionCounts.set(key, []);
    }
    
    const timestamps = actionCounts.get(key);
    
    // Remove old timestamps
    const recent = timestamps.filter(t => now - t < window);
    
    if (recent.length >= limit) {
      console.warn(`Rate limit exceeded for ${key}`);
      return;
    }
    
    recent.push(now);
    actionCounts.set(key, recent);
    
    return next(action);
  };
};
```

### Pattern 5: Action Queue

```javascript
listenerMiddleware.startListening({
  actionCreator: queueAction,
  effect: async (action, listenerApi) => {
    // Process queue one at a time
    const state = listenerApi.getState();
    
    for (const queuedAction of state.queue) {
      await processAction(queuedAction);
      await listenerApi.delay(100); // Rate limit
    }
  }
});
```

---

## Best Practices

### ‚úÖ Do's

1. **Use createListenerMiddleware for side effects**
```javascript
listenerMiddleware.startListening({ actionCreator, effect });
```

2. **Keep middleware focused**
```javascript
// ‚úÖ Single responsibility
const loggerMiddleware = ...
const analyticsMiddleware = ...
```

3. **Handle errors in effects**
```javascript
effect: async (action, listenerApi) => {
  try {
    await doSomething();
  } catch (error) {
    listenerApi.dispatch(errorOccurred(error));
  }
}
```

4. **Use TypeScript**
```typescript
listenerMiddleware.startListening<RootState>({...})
```

5. **Test middleware in isolation**
```javascript
test('middleware logs actions', () => {
  const next = jest.fn();
  middleware(store)(next)(action);
  expect(next).toHaveBeenCalled();
});
```

### ‚ùå Don'ts

1. **Don't mutate action**
```javascript
// ‚ùå Bad
action.payload.mutated = true;

// ‚úÖ Good
dispatch({ ...action, payload: { ...action.payload, added: true }});
```

2. **Don't put business logic in middleware**
```javascript
// ‚ùå Complex calculations in middleware
// ‚úÖ Keep in reducers/selectors
```

3. **Don't forget to call next()**
```javascript
// ‚ùå Action won't reach reducer
return;

// ‚úÖ Pass it along
return next(action);
```

---

## Summary

Middleware enables powerful side effect patterns:

| Approach | Use Case |
|----------|----------|
| **Custom middleware** | Simple cross-cutting concerns |
| **createListenerMiddleware** | Modern async side effects |
| **Redux-Saga** | Complex async flows |
| **Redux-Observable** | Reactive streams |

**Key Takeaways:**
1. Middleware intercepts actions before reducers
2. Use for logging, analytics, side effects
3. createListenerMiddleware is RTK's modern solution
4. Keep middleware focused and simple
5. Test middleware independently
6. Consider Saga/Observable for complex flows

This completes Chapters 7-10! You now understand:
- Selectors and memoization (Chapter 7)
- Normalization with EntityAdapter (Chapter 8)
- RTK Query for data fetching (Chapter 9)
- Middleware and side effects (Chapter 10)

Ready to build production-grade Redux applications! üöÄ