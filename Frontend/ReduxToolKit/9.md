# Chapter 9: RTK Query (Advanced Data Fetching)

## Overview

RTK Query is Redux Toolkit's powerful data fetching and caching tool. It eliminates the need to write thunks, reducers, and selectors for API calls. Think of it as "React Query for Redux."

---

## 9.1 Introduction to RTK Query

### What is RTK Query?

RTK Query is a **data fetching and caching layer** built on top of Redux Toolkit that:
- Automatically manages loading states
- Caches API responses
- Handles request deduplication
- Auto-generates React hooks
- Manages cache invalidation
- Provides optimistic updates

### RTK Query vs Manual Thunks

#### **Manual Approach** (Without RTK Query)

```javascript
// Define thunk
const fetchPosts = createAsyncThunk('posts/fetch', async () => {
  const response = await fetch('/api/posts');
  return response.json();
});

// Define slice
const postsSlice = createSlice({
  name: 'posts',
  initialState: { data: [], loading: false, error: null },
  extraReducers: (builder) => {
    builder
      .addCase(fetchPosts.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.loading = false;
        state.data = action.payload;
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  }
});

// Use in component
function Posts() {
  const dispatch = useDispatch();
  const { data, loading, error } = useSelector(state => state.posts);
  
  useEffect(() => {
    dispatch(fetchPosts());
  }, [dispatch]);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  return <div>{data.map(...)}</div>;
}
```

#### **RTK Query Approach**

```javascript
// Define API
const api = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  endpoints: (builder) => ({
    getPosts: builder.query({
      query: () => '/posts'
    })
  })
});

// Auto-generated hook
export const { useGetPostsQuery } = api;

// Use in component
function Posts() {
  const { data, isLoading, error } = useGetPostsQuery();
  
  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error!</div>;
  return <div>{data.map(...)}</div>;
}
```

**90% less code!**

### When to Use RTK Query

âœ… **Use RTK Query for:**
- Fetching data from APIs
- Caching server state
- Real-time updates
- Optimistic updates
- Polling
- Complex data fetching patterns

âŒ **Don't use RTK Query for:**
- Client-only state (use regular slices)
- Form state (use local state)
- UI state (modals, themes)

### Core Concepts

1. **API Slice**: Defines endpoints and configuration
2. **Endpoints**: Individual API operations (queries/mutations)
3. **Queries**: Read operations (GET)
4. **Mutations**: Write operations (POST/PUT/DELETE)
5. **Cache**: Stores fetched data
6. **Tags**: For cache invalidation

---

## 9.2 Creating an API Slice

### Basic API Setup

```javascript
// services/api.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const api = createApi({
  // Unique key for reducer
  reducerPath: 'api',
  
  // Base query function
  baseQuery: fetchBaseQuery({ 
    baseUrl: 'https://api.example.com' 
  }),
  
  // Tag types for cache invalidation
  tagTypes: ['Posts', 'Users'],
  
  // Define endpoints
  endpoints: (builder) => ({
    // Queries go here
    // Mutations go here
  })
});
```

### Adding to Store

```javascript
// app/store.js
import { configureStore } from '@reduxjs/toolkit';
import { api } from './services/api';

export const store = configureStore({
  reducer: {
    // Add the API reducer
    [api.reducerPath]: api.reducer
  },
  
  // Add the API middleware
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(api.middleware)
});
```

**Why middleware?**
- Enables caching
- Manages request lifecycle
- Handles cache invalidation
- Enables refetching

### Base Query Configuration

```javascript
const baseQuery = fetchBaseQuery({
  baseUrl: 'https://api.example.com',
  
  // Add authentication headers
  prepareHeaders: (headers, { getState }) => {
    const token = getState().auth.token;
    if (token) {
      headers.set('authorization', `Bearer ${token}`);
    }
    return headers;
  },
  
  // Credentials
  credentials: 'include',
  
  // Default headers
  headers: {
    'Content-Type': 'application/json'
  }
});

export const api = createApi({
  reducerPath: 'api',
  baseQuery,
  endpoints: (builder) => ({})
});
```

### Custom Base Query

For more control (e.g., Axios, GraphQL):

```javascript
import axios from 'axios';

const axiosBaseQuery = ({ baseUrl }) => async ({ url, method, data }) => {
  try {
    const result = await axios({
      url: baseUrl + url,
      method,
      data
    });
    return { data: result.data };
  } catch (axiosError) {
    return {
      error: {
        status: axiosError.response?.status,
        data: axiosError.response?.data
      }
    };
  }
};

const api = createApi({
  reducerPath: 'api',
  baseQuery: axiosBaseQuery({ baseUrl: '/api' }),
  endpoints: (builder) => ({})
});
```

---

## 9.3 Query Endpoints

### Defining a Query

```javascript
const api = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  endpoints: (builder) => ({
    getPosts: builder.query({
      query: () => '/posts'
    })
  })
});

// Auto-generated hook
export const { useGetPostsQuery } = api;
```

### Query with Parameters

```javascript
endpoints: (builder) => ({
  getPostById: builder.query({
    query: (postId) => `/posts/${postId}`
  }),
  
  getPostsByUser: builder.query({
    query: (userId) => `/users/${userId}/posts`
  }),
  
  searchPosts: builder.query({
    query: ({ searchTerm, page = 1 }) => 
      `/posts/search?q=${searchTerm}&page=${page}`
  })
})

// Usage
const { data } = useGetPostByIdQuery(5);
const { data } = useGetPostsByUserQuery(123);
const { data } = useSearchPostsQuery({ searchTerm: 'redux', page: 2 });
```

### Using Query Hooks

```javascript
function PostDetail({ postId }) {
  const {
    data,           // Response data
    error,          // Error object
    isLoading,      // Loading for first time
    isFetching,     // Loading (including refetch)
    isSuccess,      // Request succeeded
    isError,        // Request failed
    refetch         // Manual refetch function
  } = useGetPostByIdQuery(postId);
  
  if (isLoading) return <div>Loading...</div>;
  if (isError) return <div>Error: {error.message}</div>;
  
  return (
    <div>
      <h1>{data.title}</h1>
      <p>{data.content}</p>
      <button onClick={refetch}>Refresh</button>
    </div>
  );
}
```

### Skip Queries

Conditionally skip queries:

```javascript
function UserProfile({ userId }) {
  const { data } = useGetUserQuery(userId, {
    skip: !userId  // Don't fetch if no userId
  });
  
  return data ? <div>{data.name}</div> : null;
}
```

### Polling (Auto-refresh)

```javascript
function LiveData() {
  const { data } = useGetLiveDataQuery(undefined, {
    pollingInterval: 3000  // Refetch every 3 seconds
  });
  
  return <div>{data?.value}</div>;
}
```

### Transform Response

```javascript
endpoints: (builder) => ({
  getPosts: builder.query({
    query: () => '/posts',
    transformResponse: (response) => {
      // Transform API response before caching
      return response.data.map(post => ({
        ...post,
        date: new Date(post.date)
      }));
    }
  })
})
```

### Transform Error

```javascript
endpoints: (builder) => ({
  getPosts: builder.query({
    query: () => '/posts',
    transformErrorResponse: (error) => {
      return {
        message: error.data?.message || 'An error occurred',
        status: error.status
      };
    }
  })
})
```

---

## 9.4 Mutation Endpoints

### Defining a Mutation

```javascript
const api = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  tagTypes: ['Posts'],
  endpoints: (builder) => ({
    addPost: builder.mutation({
      query: (newPost) => ({
        url: '/posts',
        method: 'POST',
        body: newPost
      }),
      invalidatesTags: ['Posts']  // Invalidate cache
    }),
    
    updatePost: builder.mutation({
      query: ({ id, ...patch }) => ({
        url: `/posts/${id}`,
        method: 'PATCH',
        body: patch
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'Posts', id }]
    }),
    
    deletePost: builder.mutation({
      query: (id) => ({
        url: `/posts/${id}`,
        method: 'DELETE'
      }),
      invalidatesTags: ['Posts']
    })
  })
});

export const {
  useAddPostMutation,
  useUpdatePostMutation,
  useDeletePostMutation
} = api;
```

### Using Mutation Hooks

```javascript
function AddPostForm() {
  const [addPost, { isLoading, isSuccess, isError, error }] = useAddPostMutation();
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    try {
      await addPost({ title, content }).unwrap();
      // Success! Clear form
      setTitle('');
      setContent('');
    } catch (err) {
      // Error handled automatically
      console.error('Failed to add post:', err);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        placeholder="Title"
      />
      <textarea
        value={content}
        onChange={(e) => setContent(e.target.value)}
        placeholder="Content"
      />
      <button type="submit" disabled={isLoading}>
        {isLoading ? 'Adding...' : 'Add Post'}
      </button>
      {isSuccess && <p>Post added!</p>}
      {isError && <p>Error: {error.message}</p>}
    </form>
  );
}
```

### Mutation Return Values

```javascript
const [updatePost, result] = useUpdatePostMutation();

result.data          // Response data (after success)
result.error         // Error object (if failed)
result.isLoading     // Currently loading
result.isSuccess     // Mutation succeeded
result.isError       // Mutation failed
result.isUninitialized  // Not yet called
result.reset()       // Reset mutation state
```

### unwrap() for Error Handling

```javascript
async function handleUpdate() {
  try {
    // unwrap() returns data or throws error
    const data = await updatePost({ id: 1, title: 'New Title' }).unwrap();
    console.log('Success:', data);
  } catch (error) {
    console.error('Failed:', error);
  }
}
```

---

## 9.5 Cache Management

### providesTags - Mark Cache Entries

```javascript
endpoints: (builder) => ({
  getPosts: builder.query({
    query: () => '/posts',
    providesTags: (result) =>
      result
        ? [
            ...result.map(({ id }) => ({ type: 'Posts', id })),
            { type: 'Posts', id: 'LIST' }
          ]
        : [{ type: 'Posts', id: 'LIST' }]
  }),
  
  getPostById: builder.query({
    query: (id) => `/posts/${id}`,
    providesTags: (result, error, id) => [{ type: 'Posts', id }]
  })
})
```

### invalidatesTags - Invalidate Cache

```javascript
endpoints: (builder) => ({
  addPost: builder.mutation({
    query: (post) => ({
      url: '/posts',
      method: 'POST',
      body: post
    }),
    invalidatesTags: [{ type: 'Posts', id: 'LIST' }]
    // Forces getPosts to refetch
  }),
  
  updatePost: builder.mutation({
    query: ({ id, ...patch }) => ({
      url: `/posts/${id}`,
      method: 'PATCH',
      body: patch
    }),
    invalidatesTags: (result, error, { id }) => [
      { type: 'Posts', id },
      { type: 'Posts', id: 'LIST' }
    ]
    // Forces both getPostById and getPosts to refetch
  })
})
```

### Tag Types

```javascript
const api = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  tagTypes: ['Posts', 'Users', 'Comments'],  // Define all tag types
  endpoints: (builder) => ({
    // Use these tags in endpoints
  })
});
```

### Cache Behavior Example

```javascript
const api = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  tagTypes: ['Posts'],
  endpoints: (builder) => ({
    // Query provides tags
    getPosts: builder.query({
      query: () => '/posts',
      providesTags: ['Posts']
    }),
    
    // Mutation invalidates tags
    addPost: builder.mutation({
      query: (post) => ({
        url: '/posts',
        method: 'POST',
        body: post
      }),
      invalidatesTags: ['Posts']
    })
  })
});

// Flow:
// 1. Component calls useGetPostsQuery() â†’ fetches and caches with 'Posts' tag
// 2. User adds post via addPost() â†’ invalidates 'Posts' tag
// 3. getPosts automatically refetches â†’ updates UI with new post
```

### Manual Cache Updates

Sometimes you want to update cache without refetching:

```javascript
endpoints: (builder) => ({
  addPost: builder.mutation({
    query: (post) => ({
      url: '/posts',
      method: 'POST',
      body: post
    }),
    async onQueryStarted(post, { dispatch, queryFulfilled }) {
      // Optimistic update
      const patchResult = dispatch(
        api.util.updateQueryData('getPosts', undefined, (draft) => {
          draft.push({ ...post, id: 'temp-id' });
        })
      );
      
      try {
        await queryFulfilled;
      } catch {
        // Rollback on error
        patchResult.undo();
      }
    }
  })
})
```

---

## 9.6 Advanced Patterns

### Optimistic Updates

Update UI immediately, rollback on error:

```javascript
const api = createApi({
  // ...
  endpoints: (builder) => ({
    updatePost: builder.mutation({
      query: ({ id, ...patch }) => ({
        url: `/posts/${id}`,
        method: 'PATCH',
        body: patch
      }),
      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {
        // Optimistically update cache
        const patchResult = dispatch(
          api.util.updateQueryData('getPostById', id, (draft) => {
            Object.assign(draft, patch);
          })
        );
        
        try {
          await queryFulfilled;
          // Success - optimistic update stays
        } catch {
          // Error - rollback
          patchResult.undo();
        }
      }
    })
  })
});
```

### Pessimistic Updates

Wait for server confirmation before updating:

```javascript
const api = createApi({
  // ...
  endpoints: (builder) => ({
    updatePost: builder.mutation({
      query: ({ id, ...patch }) => ({
        url: `/posts/${id}`,
        method: 'PATCH',
        body: patch
      }),
      async onQueryStarted(arg, { dispatch, queryFulfilled }) {
        try {
          const { data: updatedPost } = await queryFulfilled;
          
          // Update cache after success
          dispatch(
            api.util.updateQueryData('getPostById', arg.id, (draft) => {
              Object.assign(draft, updatedPost);
            })
          );
        } catch {
          // Handle error
        }
      }
    })
  })
});
```

### Streaming Updates (WebSockets)

```javascript
endpoints: (builder) => ({
  getMessages: builder.query({
    query: (roomId) => `/rooms/${roomId}/messages`,
    async onCacheEntryAdded(
      arg,
      { updateCachedData, cacheDataLoaded, cacheEntryRemoved }
    ) {
      // Wait for initial data
      await cacheDataLoaded;
      
      // Connect to WebSocket
      const ws = new WebSocket(`ws://api.example.com/rooms/${arg}`);
      
      ws.onmessage = (event) => {
        const message = JSON.parse(event.data);
        
        // Update cache with new message
        updateCachedData((draft) => {
          draft.push(message);
        });
      };
      
      // Cleanup when cache entry is removed
      await cacheEntryRemoved;
      ws.close();
    }
  })
})
```

### Code Splitting

Split API into multiple files:

```javascript
// api/baseApi.js
export const baseApi = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  tagTypes: ['Posts', 'Users'],
  endpoints: () => ({})
});

// api/postsApi.js
import { baseApi } from './baseApi';

export const postsApi = baseApi.injectEndpoints({
  endpoints: (builder) => ({
    getPosts: builder.query({
      query: () => '/posts'
    })
  })
});

export const { useGetPostsQuery } = postsApi;

// api/usersApi.js
import { baseApi } from './baseApi';

export const usersApi = baseApi.injectEndpoints({
  endpoints: (builder) => ({
    getUsers: builder.query({
      query: () => '/users'
    })
  })
});

export const { useGetUsersQuery } = usersApi;
```

### Prefetching

Fetch data before it's needed:

```javascript
function PostsList() {
  const { data: posts } = useGetPostsQuery();
  const [prefetchPost] = usePrefetch('getPostById');
  
  return (
    <ul>
      {posts.map(post => (
        <li
          key={post.id}
          onMouseEnter={() => prefetchPost(post.id)}  // Prefetch on hover
        >
          <Link to={`/posts/${post.id}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  );
}
```

### Conditional Fetching

```javascript
function ConditionalFetch({ userId }) {
  const skip = !userId;
  
  const { data } = useGetUserQuery(userId, {
    skip,  // Don't fetch if no userId
    pollingInterval: skip ? 0 : 5000  // Only poll if fetching
  });
  
  return skip ? null : <div>{data.name}</div>;
}
```

### Lazy Queries

Trigger queries manually:

```javascript
function SearchComponent() {
  const [trigger, result] = useLazyGetPostsQuery();
  const [searchTerm, setSearchTerm] = useState('');
  
  const handleSearch = () => {
    trigger(searchTerm);  // Manually trigger query
  };
  
  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
      />
      <button onClick={handleSearch}>Search</button>
      
      {result.isLoading && <div>Searching...</div>}
      {result.data && <div>{result.data.length} results</div>}
    </div>
  );
}
```

---

## 9.7 Complete Real-World Example

```typescript
// services/blogApi.ts
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

interface Post {
  id: number;
  title: string;
  content: string;
  authorId: number;
  tags: string[];
  createdAt: string;
}

interface User {
  id: number;
  name: string;
  email: string;
}

export const blogApi = createApi({
  reducerPath: 'blogApi',
  baseQuery: fetchBaseQuery({
    baseUrl: 'https://api.example.com',
    prepareHeaders: (headers, { getState }) => {
      const token = (getState() as RootState).auth.token;
      if (token) {
        headers.set('authorization', `Bearer ${token}`);
      }
      return headers;
    }
  }),
  tagTypes: ['Posts', 'Users'],
  endpoints: (builder) => ({
    // Queries
    getPosts: builder.query<Post[], void>({
      query: () => '/posts',
      providesTags: (result) =>
        result
          ? [
              ...result.map(({ id }) => ({ type: 'Posts' as const, id })),
              { type: 'Posts', id: 'LIST' }
            ]
          : [{ type: 'Posts', id: 'LIST' }]
    }),
    
    getPostById: builder.query<Post, number>({
      query: (id) => `/posts/${id}`,
      providesTags: (result, error, id) => [{ type: 'Posts', id }]
    }),
    
    getUsers: builder.query<User[], void>({
      query: () => '/users',
      providesTags: ['Users']
    }),
    
    // Mutations
    addPost: builder.mutation<Post, Partial<Post>>({
      query: (body) => ({
        url: '/posts',
        method: 'POST',
        body
      }),
      invalidatesTags: [{ type: 'Posts', id: 'LIST' }]
    }),
    
    updatePost: builder.mutation<Post, Partial<Post> & Pick<Post, 'id'>>({
      query: ({ id, ...patch }) => ({
        url: `/posts/${id}`,
        method: 'PATCH',
        body: patch
      }),
      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {
        // Optimistic update
        const patchResult = dispatch(
          blogApi.util.updateQueryData('getPostById', id, (draft) => {
            Object.assign(draft, patch);
          })
        );
        
        try {
          await queryFulfilled;
        } catch {
          patchResult.undo();
        }
      },
      invalidatesTags: (result, error, { id }) => [
        { type: 'Posts', id },
        { type: 'Posts', id: 'LIST' }
      ]
    }),
    
    deletePost: builder.mutation<{ success: boolean }, number>({
      query: (id) => ({
        url: `/posts/${id}`,
        method: 'DELETE'
      }),
      invalidatesTags: (result, error, id) => [
        { type: 'Posts', id },
        { type: 'Posts', id: 'LIST' }
      ]
    })
  })
});

export const {
  useGetPostsQuery,
  useGetPostByIdQuery,
  useGetUsersQuery,
  useAddPostMutation,
  useUpdatePostMutation,
  useDeletePostMutation,
  usePrefetch
} = blogApi;

// Component usage
function BlogList() {
  const { data: posts, isLoading, error } = useGetPostsQuery();
  const [deletePost] = useDeletePostMutation();
  const prefetchPost = usePrefetch('getPostById');
  
  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error loading posts</div>;
  
  const handleDelete = async (id: number) => {
    if (confirm('Delete this post?')) {
      await deletePost(id);
    }
  };
  
  return (
    <ul>
      {posts?.map(post => (
        <li
          key={post.id}
          onMouseEnter={() => prefetchPost(post.id)}
        >
          <Link to={`/posts/${post.id}`}>{post.title}</Link>
          <button onClick={() => handleDelete(post.id)}>Delete</button>
        </li>
      ))}
    </ul>
  );
}

function PostEditor({ postId }: { postId: number }) {
  const { data: post } = useGetPostByIdQuery(postId);
  const [updatePost, { isLoading }] = useUpdatePostMutation();
  
  const [title, setTitle] = useState(post?.title || '');
  const [content, setContent] = useState(post?.content || '');
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    await updatePost({ id: postId, title, content });
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />
      <textarea
        value={content}
        onChange={(e) => setContent(e.target.value)}
      />
      <button type="submit" disabled={isLoading}>
        {isLoading ? 'Saving...' : 'Save'}
      </button>
    </form>
  );
}
```

---

## Best Practices

### âœ… Do's

1. **Use tags for cache invalidation**
```typescript
providesTags: ['Posts']
invalidatesTags: ['Posts']
```

2. **Transform responses when needed**
```typescript
transformResponse: (response) => response.data
```

3. **Use optimistic updates for better UX**
```typescript
onQueryStarted: async (arg, { dispatch, queryFulfilled }) => { ... }
```

4. **Split large APIs**
```typescript
api.injectEndpoints({ endpoints: ... })
```

5. **Type your endpoints**
```typescript
builder.query<ReturnType, ArgType>({...})
```

### âŒ Don'ts

1. **Don't use for client state**
```typescript
// âŒ Wrong - use regular slice
const api = createApi({ endpoints: { getTheme: ... } })
```

2. **Don't forget middleware**
```typescript
// âŒ Missing middleware - caching won't work
middleware: (getDefaultMiddleware) => getDefaultMiddleware()

// âœ… Include API middleware
middleware: (getDefaultMiddleware) =>
  getDefaultMiddleware().concat(api.middleware)
```

3. **Don't invalidate everything**
```typescript
// âŒ Overkill - refetches all posts
invalidatesTags: ['Posts']

// âœ… Specific - only refetches one post
invalidatesTags: (result, error, { id }) => [{ type: 'Posts', id }]
```

---

## Summary

RTK Query revolutionizes data fetching in Redux:

| Feature | Benefit |
|---------|---------|
| **Auto-generated hooks** | No manual thunks/reducers |
| **Caching** | Automatic request deduplication |
| **Cache invalidation** | Smart refetching with tags |
| **Optimistic updates** | Instant UI feedback |
| **Polling** | Real-time data |
| **Code splitting** | Modular API definitions |

**Key Takeaways:**
1. RTK Query eliminates 90% of data fetching boilerplate
2. Use queries for reads, mutations for writes
3. Tags control cache invalidation
4. Optimistic updates improve UX
5. Perfect for REST APIs
6. Combines Redux power with React Query simplicity

Next: Chapter 10 covers Middleware and Side Effects! ðŸš€