# Chapter 11: TypeScript with Redux Toolkit

## Overview

TypeScript and Redux Toolkit are a perfect match. RTK was designed with TypeScript in mind, providing excellent type inference and type safety out of the box. This chapter covers everything from basic setup to advanced type patterns.

---

## 11.1 Setting Up TypeScript

### Installation

```bash
# Create React app with TypeScript template
npx create-react-app my-app --template typescript

# Or add to existing project
npm install --save-dev typescript @types/react @types/react-dom

# Redux Toolkit and React-Redux (include types)
npm install @reduxjs/toolkit react-redux
```

### tsconfig.json Configuration

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",
    "module": "ESNext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "allowJs": true,
    "noEmit": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "allowSyntheticDefaultImports": true
  },
  "include": ["src"]
}
```

### Project Structure

```
src/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ store.ts              # Store configuration
‚îÇ   ‚îî‚îÄ‚îÄ hooks.ts              # Typed hooks
‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îú‚îÄ‚îÄ counter/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ counterSlice.ts   # Slice with types
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Counter.tsx       # Component
‚îÇ   ‚îî‚îÄ‚îÄ users/
‚îÇ       ‚îú‚îÄ‚îÄ usersSlice.ts
‚îÇ       ‚îú‚îÄ‚îÄ usersAPI.ts
‚îÇ       ‚îî‚îÄ‚îÄ types.ts          # Feature types
‚îî‚îÄ‚îÄ types/
    ‚îî‚îÄ‚îÄ index.ts              # Global types
```

---

## 11.2 Type-Safe Store Setup

### Basic Store Configuration

```typescript
// app/store.ts
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from '../features/counter/counterSlice';
import usersReducer from '../features/users/usersSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer,
    users: usersReducer
  }
});

// Infer the `RootState` and `AppDispatch` types from the store itself
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

**Why these types?**

```typescript
// RootState gives you the entire state shape
type RootState = {
  counter: CounterState;
  users: UsersState;
}

// AppDispatch includes thunk support
type AppDispatch = ThunkDispatch<RootState, undefined, AnyAction> & Dispatch;
```

### Creating Typed Hooks

```typescript
// app/hooks.ts
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
import type { RootState, AppDispatch } from './store';

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
```

**Usage in components:**

```typescript
// ‚ùå Before: Manual type annotations
import { useDispatch, useSelector } from 'react-redux';

function MyComponent() {
  const dispatch = useDispatch<AppDispatch>();
  const count = useSelector((state: RootState) => state.counter.value);
}

// ‚úÖ After: Types inferred automatically
import { useAppDispatch, useAppSelector } from '../../app/hooks';

function MyComponent() {
  const dispatch = useAppDispatch(); // Type inferred!
  const count = useAppSelector(state => state.counter.value); // Type inferred!
}
```

---

## 11.3 Typing Slices

### Basic Slice with Types

```typescript
// counterSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

// Define state interface
interface CounterState {
  value: number;
  status: 'idle' | 'loading' | 'failed';
}

// Initial state with type
const initialState: CounterState = {
  value: 0,
  status: 'idle'
};

const counterSlice = createSlice({
  name: 'counter',
  initialState,
  reducers: {
    // Type the action payload
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    // PayloadAction<T> types the payload
    incrementByAmount: (state, action: PayloadAction<number>) => {
      state.value += action.payload;
    },
    // Multiple payload fields
    setStatus: (state, action: PayloadAction<{ status: CounterState['status'] }>) => {
      state.status = action.payload.status;
    }
  }
});

export const { increment, decrement, incrementByAmount, setStatus } = counterSlice.actions;
export default counterSlice.reducer;
```

### Complex State Types

```typescript
// types.ts
export interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'user' | 'guest';
  createdAt: string;
}

export interface Post {
  id: string;
  title: string;
  content: string;
  authorId: string;
  tags: string[];
  published: boolean;
}

// usersSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { User } from './types';

interface UsersState {
  entities: Record<string, User>;
  ids: string[];
  selectedUserId: string | null;
  loading: boolean;
  error: string | null;
}

const initialState: UsersState = {
  entities: {},
  ids: [],
  selectedUserId: null,
  loading: false,
  error: null
};

const usersSlice = createSlice({
  name: 'users',
  initialState,
  reducers: {
    userAdded: (state, action: PayloadAction<User>) => {
      const user = action.payload;
      state.entities[user.id] = user;
      state.ids.push(user.id);
    },
    userUpdated: (state, action: PayloadAction<{ id: string; changes: Partial<User> }>) => {
      const { id, changes } = action.payload;
      if (state.entities[id]) {
        state.entities[id] = { ...state.entities[id], ...changes };
      }
    },
    userRemoved: (state, action: PayloadAction<string>) => {
      const id = action.payload;
      delete state.entities[id];
      state.ids = state.ids.filter(userId => userId !== id);
    },
    userSelected: (state, action: PayloadAction<string | null>) => {
      state.selectedUserId = action.payload;
    }
  }
});
```

### Prepare Callbacks with Types

```typescript
import { nanoid, PayloadAction } from '@reduxjs/toolkit';

interface Todo {
  id: string;
  text: string;
  completed: boolean;
  createdAt: string;
}

const todosSlice = createSlice({
  name: 'todos',
  initialState: [] as Todo[],
  reducers: {
    todoAdded: {
      reducer: (state, action: PayloadAction<Todo>) => {
        state.push(action.payload);
      },
      prepare: (text: string) => {
        return {
          payload: {
            id: nanoid(),
            text,
            completed: false,
            createdAt: new Date().toISOString()
          } as Todo
        };
      }
    }
  }
});

// Usage - TypeScript knows you only need text parameter
dispatch(todoAdded('Learn TypeScript')); // ‚úÖ Correct
dispatch(todoAdded({ text: 'Learn' })); // ‚ùå Type error
```

---

## 11.4 Typing Async Thunks

### Basic Async Thunk Types

```typescript
import { createAsyncThunk } from '@reduxjs/toolkit';

interface User {
  id: number;
  name: string;
  email: string;
}

// createAsyncThunk<ReturnType, ArgumentType, ThunkConfig>
export const fetchUserById = createAsyncThunk<
  User,              // Return type of the payload creator
  number,            // First argument to the payload creator
  {
    rejectValue: string;  // Type for rejectWithValue
  }
>(
  'users/fetchById',
  async (userId, { rejectWithValue }) => {
    try {
      const response = await fetch(`/api/users/${userId}`);
      
      if (!response.ok) {
        return rejectWithValue('Failed to fetch user');
      }
      
      const data: User = await response.json();
      return data;
    } catch (error) {
      return rejectWithValue('Network error');
    }
  }
);
```

### ThunkAPI Type Configuration

```typescript
import { createAsyncThunk } from '@reduxjs/toolkit';
import type { RootState, AppDispatch } from '../../app/store';

export const fetchUsers = createAsyncThunk<
  User[],           // Return type
  void,             // Argument type (void if no args)
  {
    state: RootState;        // Type for getState
    dispatch: AppDispatch;   // Type for dispatch
    rejectValue: string;     // Type for rejectWithValue
  }
>(
  'users/fetchAll',
  async (_, { getState, dispatch, rejectWithValue }) => {
    // getState is now typed as () => RootState
    const state = getState();
    const token = state.auth.token; // Autocomplete works!
    
    // dispatch is typed as AppDispatch
    dispatch(setLoading(true));
    
    try {
      const response = await fetch('/api/users', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (!response.ok) {
        return rejectWithValue('Failed to fetch users');
      }
      
      return response.json();
    } catch (error) {
      return rejectWithValue('Network error');
    }
  }
);
```

### Handling Thunk Results in Slices

```typescript
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { fetchUserById } from './usersThunks';

interface UsersState {
  currentUser: User | null;
  loading: boolean;
  error: string | null;
}

const initialState: UsersState = {
  currentUser: null,
  loading: false,
  error: null
};

const usersSlice = createSlice({
  name: 'users',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUserById.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUserById.fulfilled, (state, action: PayloadAction<User>) => {
        state.loading = false;
        state.currentUser = action.payload; // Typed as User
      })
      .addCase(fetchUserById.rejected, (state, action) => {
        state.loading = false;
        // action.payload is typed as string (from rejectValue)
        state.error = action.payload ?? 'Unknown error';
      });
  }
});
```

### Multiple Argument Thunks

```typescript
interface FetchPostsParams {
  page: number;
  limit: number;
  category?: string;
}

interface FetchPostsResponse {
  posts: Post[];
  totalPages: number;
  currentPage: number;
}

export const fetchPosts = createAsyncThunk<
  FetchPostsResponse,
  FetchPostsParams,
  { rejectValue: string }
>(
  'posts/fetch',
  async ({ page, limit, category }, { rejectWithValue }) => {
    try {
      const params = new URLSearchParams({
        page: page.toString(),
        limit: limit.toString(),
        ...(category && { category })
      });
      
      const response = await fetch(`/api/posts?${params}`);
      return response.json();
    } catch (error) {
      return rejectWithValue('Failed to fetch posts');
    }
  }
);

// Usage
dispatch(fetchPosts({ page: 1, limit: 10 }));
dispatch(fetchPosts({ page: 2, limit: 20, category: 'tech' }));
```

---

## 11.5 Typing Selectors

### Basic Selectors

```typescript
import { RootState } from '../../app/store';

// Simple selector with explicit type
export const selectCounter = (state: RootState): number => state.counter.value;

// Selector returning complex type
export const selectUsers = (state: RootState): User[] => {
  return Object.values(state.users.entities);
};

// Selector with conditional return
export const selectCurrentUser = (state: RootState): User | null => {
  const userId = state.users.selectedUserId;
  if (!userId) return null;
  return state.users.entities[userId] ?? null;
};
```

### createSelector with Types

```typescript
import { createSelector } from '@reduxjs/toolkit';
import { RootState } from '../../app/store';

// Input selectors
const selectTodos = (state: RootState) => state.todos;
const selectFilter = (state: RootState) => state.filter;

// Memoized selector with inferred types
export const selectFilteredTodos = createSelector(
  [selectTodos, selectFilter],
  (todos, filter) => {
    // todos and filter types are inferred!
    switch (filter) {
      case 'active':
        return todos.filter(todo => !todo.completed);
      case 'completed':
        return todos.filter(todo => todo.completed);
      default:
        return todos;
    }
  }
);
```

### Parametric Selectors

```typescript
import { createSelector } from '@reduxjs/toolkit';
import { RootState } from '../../app/store';

// Selector that accepts parameters
export const selectUserById = createSelector(
  [
    (state: RootState) => state.users.entities,
    (state: RootState, userId: string) => userId
  ],
  (entities, userId) => entities[userId]
);

// Usage in component
function UserProfile({ userId }: { userId: string }) {
  const user = useAppSelector(state => selectUserById(state, userId));
  return <div>{user?.name}</div>;
}
```

### Selector Return Type Inference

```typescript
import { createSelector } from '@reduxjs/toolkit';

const selectTodos = (state: RootState) => state.todos;

export const selectTodoStats = createSelector(
  [selectTodos],
  (todos) => {
    const total = todos.length;
    const completed = todos.filter(t => t.completed).length;
    
    // Return type automatically inferred
    return {
      total,
      completed,
      active: total - completed,
      completionRate: total > 0 ? (completed / total) * 100 : 0
    };
  }
);

// TypeScript knows the return type:
// {
//   total: number;
//   completed: number;
//   active: number;
//   completionRate: number;
// }
```

---

## 11.6 RTK Query with TypeScript

### Defining API with Types

```typescript
// types.ts
export interface Post {
  id: number;
  title: string;
  content: string;
  authorId: number;
  tags: string[];
  published: boolean;
  createdAt: string;
}

export interface User {
  id: number;
  name: string;
  email: string;
  avatarUrl?: string;
}

export interface CreatePostRequest {
  title: string;
  content: string;
  authorId: number;
  tags: string[];
}

export interface UpdatePostRequest {
  id: number;
  title?: string;
  content?: string;
  tags?: string[];
  published?: boolean;
}

// api.ts
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
import type { Post, User, CreatePostRequest, UpdatePostRequest } from './types';

export const api = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  tagTypes: ['Posts', 'Users'],
  endpoints: (builder) => ({
    // Query with type parameters: <ResultType, ArgumentType>
    getPosts: builder.query<Post[], void>({
      query: () => '/posts',
      providesTags: (result) =>
        result
          ? [
              ...result.map(({ id }) => ({ type: 'Posts' as const, id })),
              { type: 'Posts', id: 'LIST' }
            ]
          : [{ type: 'Posts', id: 'LIST' }]
    }),
    
    getPostById: builder.query<Post, number>({
      query: (id) => `/posts/${id}`,
      providesTags: (result, error, id) => [{ type: 'Posts', id }]
    }),
    
    getUsers: builder.query<User[], void>({
      query: () => '/users',
      providesTags: ['Users']
    }),
    
    // Mutation with types
    createPost: builder.mutation<Post, CreatePostRequest>({
      query: (body) => ({
        url: '/posts',
        method: 'POST',
        body
      }),
      invalidatesTags: [{ type: 'Posts', id: 'LIST' }]
    }),
    
    updatePost: builder.mutation<Post, UpdatePostRequest>({
      query: ({ id, ...patch }) => ({
        url: `/posts/${id}`,
        method: 'PATCH',
        body: patch
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'Posts', id }]
    }),
    
    deletePost: builder.mutation<{ success: boolean }, number>({
      query: (id) => ({
        url: `/posts/${id}`,
        method: 'DELETE'
      }),
      invalidatesTags: (result, error, id) => [{ type: 'Posts', id }]
    })
  })
});

export const {
  useGetPostsQuery,
  useGetPostByIdQuery,
  useGetUsersQuery,
  useCreatePostMutation,
  useUpdatePostMutation,
  useDeletePostMutation
} = api;
```

### Using Typed Hooks

```typescript
import { useGetPostsQuery, useCreatePostMutation } from './api';

function PostsList() {
  // Query hook returns typed data
  const { 
    data,      // Type: Post[] | undefined
    isLoading, // Type: boolean
    error      // Type: FetchBaseQueryError | SerializedError | undefined
  } = useGetPostsQuery();
  
  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error!</div>;
  
  return (
    <ul>
      {data?.map(post => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}

function CreatePostForm() {
  const [createPost, { isLoading, isSuccess }] = useCreatePostMutation();
  
  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    
    // TypeScript knows the expected shape
    await createPost({
      title: 'My Post',
      content: 'Content here',
      authorId: 1,
      tags: ['typescript', 'redux']
    });
  };
  
  return <form onSubmit={handleSubmit}>...</form>;
}
```

### Transform Response Types

```typescript
interface ApiResponse<T> {
  data: T;
  meta: {
    timestamp: string;
    version: string;
  };
}

export const api = createApi({
  // ...
  endpoints: (builder) => ({
    getPosts: builder.query<Post[], void>({
      query: () => '/posts',
      // Transform from API format to app format
      transformResponse: (response: ApiResponse<Post[]>) => {
        return response.data;
      }
    })
  })
});
```

---

## 11.7 Component Types

### Typed Props

```typescript
import { FC } from 'react';

interface TodoItemProps {
  id: string;
  text: string;
  completed: boolean;
  onToggle: (id: string) => void;
  onDelete: (id: string) => void;
}

// Using FC (Functional Component)
const TodoItem: FC<TodoItemProps> = ({ id, text, completed, onToggle, onDelete }) => {
  return (
    <li>
      <input
        type="checkbox"
        checked={completed}
        onChange={() => onToggle(id)}
      />
      <span>{text}</span>
      <button onClick={() => onDelete(id)}>Delete</button>
    </li>
  );
};

// Or without FC
function TodoItem({ id, text, completed, onToggle, onDelete }: TodoItemProps) {
  return (
    <li>
      <input
        type="checkbox"
        checked={completed}
        onChange={() => onToggle(id)}
      />
      <span>{text}</span>
      <button onClick={() => onDelete(id)}>Delete</button>
    </li>
  );
}
```

### Typed Events

```typescript
import { ChangeEvent, FormEvent, MouseEvent } from 'react';

function TodoForm() {
  const [text, setText] = useState('');
  
  // Type input change events
  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    setText(e.target.value);
  };
  
  // Type form submit events
  const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    dispatch(addTodo(text));
  };
  
  // Type click events
  const handleClick = (e: MouseEvent<HTMLButtonElement>) => {
    console.log('Button clicked', e.currentTarget);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input value={text} onChange={handleChange} />
      <button type="submit" onClick={handleClick}>Add</button>
    </form>
  );
}
```

### Typed Children

```typescript
import { ReactNode, FC } from 'react';

interface ContainerProps {
  children: ReactNode;
  title?: string;
}

const Container: FC<ContainerProps> = ({ children, title }) => {
  return (
    <div>
      {title && <h2>{title}</h2>}
      {children}
    </div>
  );
};

// Usage
<Container title="My Title">
  <p>Child content</p>
</Container>
```

---

## 11.8 Advanced Type Patterns

### Discriminated Unions

```typescript
interface LoadingState {
  status: 'loading';
}

interface SuccessState<T> {
  status: 'success';
  data: T;
}

interface ErrorState {
  status: 'error';
  error: string;
}

type AsyncState<T> = LoadingState | SuccessState<T> | ErrorState;

// Slice using discriminated union
interface PostsState {
  posts: AsyncState<Post[]>;
}

const initialState: PostsState = {
  posts: { status: 'loading' }
};

// TypeScript can narrow types in reducers
extraReducers: (builder) => {
  builder
    .addCase(fetchPosts.pending, (state) => {
      state.posts = { status: 'loading' };
    })
    .addCase(fetchPosts.fulfilled, (state, action) => {
      state.posts = { status: 'success', data: action.payload };
    })
    .addCase(fetchPosts.rejected, (state, action) => {
      state.posts = { status: 'error', error: action.error.message ?? 'Unknown error' };
    });
}

// Type-safe component
function PostsList() {
  const posts = useAppSelector(state => state.posts.posts);
  
  switch (posts.status) {
    case 'loading':
      return <div>Loading...</div>;
    case 'success':
      // TypeScript knows posts.data exists here
      return <ul>{posts.data.map(...)}</ul>;
    case 'error':
      // TypeScript knows posts.error exists here
      return <div>Error: {posts.error}</div>;
  }
}
```

### Type Guards

```typescript
function isUser(obj: any): obj is User {
  return obj && typeof obj.id === 'number' && typeof obj.name === 'string';
}

// Usage
const data: unknown = await response.json();

if (isUser(data)) {
  // TypeScript knows data is User here
  console.log(data.name);
}
```

### Generic Slice Factory

```typescript
function createGenericSlice<T extends { id: string | number }>({
  name,
  initialState,
  reducers = {}
}: {
  name: string;
  initialState: T[];
  reducers?: any;
}) {
  return createSlice({
    name,
    initialState,
    reducers: {
      itemAdded: (state, action: PayloadAction<T>) => {
        state.push(action.payload);
      },
      itemRemoved: (state, action: PayloadAction<T['id']>) => {
        return state.filter(item => item.id !== action.payload);
      },
      ...reducers
    }
  });
}

// Usage
const usersSlice = createGenericSlice({
  name: 'users',
  initialState: [] as User[]
});

const postsSlice = createGenericSlice({
  name: 'posts',
  initialState: [] as Post[]
});
```

### Extending Types

```typescript
// Base types
interface BaseEntity {
  id: string;
  createdAt: string;
  updatedAt: string;
}

// Extended types
interface User extends BaseEntity {
  name: string;
  email: string;
  role: 'admin' | 'user';
}

interface Post extends BaseEntity {
  title: string;
  content: string;
  authorId: string;
  published: boolean;
}

// Generic helper
type WithTimestamps<T> = T & {
  createdAt: string;
  updatedAt: string;
};

// Usage
interface Comment {
  id: string;
  text: string;
  postId: string;
}

type CommentWithTimestamps = WithTimestamps<Comment>;
// Result: { id, text, postId, createdAt, updatedAt }
```

---

## 11.9 Common TypeScript Issues and Solutions

### Issue 1: Inference Not Working

```typescript
// ‚ùå Problem: Type not inferred
const initialState = {
  count: 0
};

// state.count could be any number
state.count = "string"; // No error!

// ‚úÖ Solution: Explicit interface
interface CounterState {
  count: number;
}

const initialState: CounterState = {
  count: 0
};

// Now state.count is strictly number
```

### Issue 2: Action Payload Type

```typescript
// ‚ùå Problem: Any type
reducers: {
  userUpdated: (state, action) => {
    state.user = action.payload; // Any type!
  }
}

// ‚úÖ Solution: PayloadAction<T>
reducers: {
  userUpdated: (state, action: PayloadAction<User>) => {
    state.user = action.payload; // Typed as User
  }
}
```

### Issue 3: Thunk Argument Type

```typescript
// ‚ùå Problem: Argument not typed
export const fetchUser = createAsyncThunk(
  'users/fetch',
  async (userId) => { // userId is any
    // ...
  }
);

// ‚úÖ Solution: Specify argument type
export const fetchUser = createAsyncThunk<User, number>(
  'users/fetch',
  async (userId) => { // userId is number
    // ...
  }
);
```

### Issue 4: Optional Chaining in Selectors

```typescript
// ‚ùå Problem: Potential undefined
export const selectUserName = (state: RootState) => {
  return state.users.currentUser.name; // Error if null
};

// ‚úÖ Solution: Optional chaining
export const selectUserName = (state: RootState) => {
  return state.users.currentUser?.name ?? 'Guest';
};
```

### Issue 5: Array Filter Type Narrowing

```typescript
interface Item {
  id: string;
  value: number | null;
}

const items: Item[] = [
  { id: '1', value: 10 },
  { id: '2', value: null },
  { id: '3', value: 20 }
];

// ‚ùå Problem: Still includes null
const values = items.map(item => item.value).filter(v => v !== null);
// Type: (number | null)[]

// ‚úÖ Solution: Type guard
const values = items
  .map(item => item.value)
  .filter((v): v is number => v !== null);
// Type: number[]
```

---

## 11.10 Complete TypeScript Example

```typescript
// types.ts
export interface Todo {
  id: string;
  text: string;
  completed: boolean;
  priority: 'low' | 'medium' | 'high';
  createdAt: string;
}

export type FilterType = 'all' | 'active' | 'completed';

// todosSlice.ts
import { createSlice, createAsyncThunk, PayloadAction, nanoid } from '@reduxjs/toolkit';
import type { RootState } from '../../app/store';
import type { Todo, FilterType } from './types';

interface TodosState {
  items: Todo[];
  filter: FilterType;
  loading: boolean;
  error: string | null;
}

const initialState: TodosState = {
  items: [],
  filter: 'all',
  loading: false,
  error: null
};

// Async thunk with types
export const fetchTodos = createAsyncThunk<
  Todo[],
  void,
  { rejectValue: string }
>(
  'todos/fetchAll',
  async (_, { rejectWithValue }) => {
    try {
      const response = await fetch('/api/todos');
      if (!response.ok) {
        return rejectWithValue('Failed to fetch todos');
      }
      return response.json();
    } catch (error) {
      return rejectWithValue('Network error');
    }
  }
);

const todosSlice = createSlice({
  name: 'todos',
  initialState,
  reducers: {
    todoAdded: {
      reducer: (state, action: PayloadAction<Todo>) => {
        state.items.push(action.payload);
      },
      prepare: (text: string, priority: Todo['priority'] = 'medium') => {
        return {
          payload: {
            id: nanoid(),
            text,
            priority,
            completed: false,
            createdAt: new Date().toISOString()
          }
        };
      }
    },
    todoToggled: (state, action: PayloadAction<string>) => {
      const todo = state.items.find(t => t.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
    todoDeleted: (state, action: PayloadAction<string>) => {
      state.items = state.items.filter(t => t.id !== action.payload);
    },
    filterChanged: (state, action: PayloadAction<FilterType>) => {
      state.filter = action.payload;
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchTodos.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchTodos.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload;
      })
      .addCase(fetchTodos.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload ?? 'Unknown error';
      });
  }
});

export const { todoAdded, todoToggled, todoDeleted, filterChanged } = todosSlice.actions;

// Selectors
export const selectTodos = (state: RootState): Todo[] => state.todos.items;
export const selectFilter = (state: RootState): FilterType => state.todos.filter;
export const selectLoading = (state: RootState): boolean => state.todos.loading;

export const selectFilteredTodos = (state: RootState): Todo[] => {
  const todos = selectTodos(state);
  const filter = selectFilter(state);
  
  switch (filter) {
    case 'active':
      return todos.filter(t => !t.completed);
    case 'completed':
      return todos.filter(t => t.completed);
    default:
      return todos;
  }
};

export default todosSlice.reducer;

// TodoList.tsx
import { FC, useEffect } from 'react';
import { useAppDispatch, useAppSelector } from '../../app/hooks';
import {
  fetchTodos,
  todoToggled,
  todoDeleted,
  selectFilteredTodos,
  selectLoading
} from './todosSlice';

export const TodoList: FC = () => {
  const dispatch = useAppDispatch();
  const todos = useAppSelector(selectFilteredTodos);
  const loading = useAppSelector(selectLoading);
  
  useEffect(() => {
    dispatch(fetchTodos());
  }, [dispatch]);
  
  if (loading) {
    return <div>Loading todos...</div>;
  }
  
  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => dispatch(todoToggled(todo.id))}
          />
          <span>{todo.text}</span>
          <button onClick={() => dispatch(todoDeleted(todo.id))}>
            Delete
          </button>
        </li>
      ))}
    </ul>
  );
};
```

---

## Best Practices

### ‚úÖ Do's

1. **Always type your state interfaces**
```typescript
interface State {
  count: number;
}
```

2. **Use PayloadAction<T>**
```typescript
(state, action: PayloadAction<User>) => {...}
```

3. **Create typed hooks**
```typescript
export const useAppDispatch = () => useDispatch<AppDispatch>();
```

4. **Type thunk configurations**
```typescript
createAsyncThunk<ReturnType, ArgType, ThunkConfig>
```

5. **Use discriminated unions for complex state**
```typescript
type State = { status: 'loading' } | { status: 'success'; data: T }
```

### ‚ùå Don'ts

1. **Don't use `any`**
```typescript
// ‚ùå Bad
const data: any = ...

// ‚úÖ Good
const data: User = ...
```

2. **Don't skip type annotations on parameters**
```typescript
// ‚ùå Bad
const selector = (state) => state.user

// ‚úÖ Good
const selector = (state: RootState) => state.user
```

3. **Don't ignore TypeScript errors**
```typescript
// ‚ùå Bad
// @ts-ignore

// ‚úÖ Good - Fix the actual issue
```

---

## Summary

TypeScript + Redux Toolkit = Type-safe Redux:

| Feature | Benefit |
|---------|---------|
| **RootState** | Complete state typing |
| **AppDispatch** | Thunk-aware dispatch |
| **PayloadAction<T>** | Typed action payloads |
| **Typed hooks** | Inference everywhere |
| **RTK Query types** | API type safety |

**Key Takeaways:**
1. Set up RootState and AppDispatch types
2. Create typed hooks (useAppDispatch, useAppSelector)
3. Use PayloadAction<T> in reducers
4. Type thunk configurations properly
5. Leverage type inference where possible
6. Use discriminated unions for complex state

Next: Chapter 12 covers Performance Optimization! üöÄ