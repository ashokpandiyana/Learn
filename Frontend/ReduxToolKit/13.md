# Chapter 13: Testing Redux Toolkit

## Overview

Testing is crucial for Redux applications. This chapter covers testing strategies for slices, thunks, selectors, components, and integration tests. We'll use Jest and React Testing Library.

---

## 13.1 Testing Philosophy

### What to Test

âœ… **Do test:**
- Reducers (state transitions)
- Selectors (data derivation)
- Thunks (async logic)
- Component behavior
- Integration flows

âŒ **Don't test:**
- Implementation details
- Redux internals
- Third-party library code

### Testing Pyramid

```
       /\
      /  \    E2E (Few)
     /â”€â”€â”€â”€\
    /      \  Integration (Some)
   /â”€â”€â”€â”€â”€â”€â”€â”€\
  /          \ Unit (Many)
 /â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\
```

**Unit Tests:** Fast, isolated, many
**Integration Tests:** Test feature flows
**E2E Tests:** Full user scenarios, few

---

## 13.2 Testing Reducers and Slices

### Basic Reducer Tests

```typescript
// counterSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface CounterState {
  value: number;
}

const initialState: CounterState = {
  value: 0
};

const counterSlice = createSlice({
  name: 'counter',
  initialState,
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action: PayloadAction<number>) => {
      state.value += action.payload;
    }
  }
});

export const { increment, decrement, incrementByAmount } = counterSlice.actions;
export default counterSlice.reducer;

// counterSlice.test.ts
import counterReducer, {
  increment,
  decrement,
  incrementByAmount
} from './counterSlice';

describe('counter reducer', () => {
  const initialState = { value: 0 };
  
  it('should handle initial state', () => {
    expect(counterReducer(undefined, { type: 'unknown' })).toEqual({
      value: 0
    });
  });
  
  it('should handle increment', () => {
    const actual = counterReducer(initialState, increment());
    expect(actual.value).toEqual(1);
  });
  
  it('should handle decrement', () => {
    const actual = counterReducer(initialState, decrement());
    expect(actual.value).toEqual(-1);
  });
  
  it('should handle incrementByAmount', () => {
    const actual = counterReducer(initialState, incrementByAmount(5));
    expect(actual.value).toEqual(5);
  });
  
  it('should handle multiple actions', () => {
    let state = counterReducer(initialState, increment());
    state = counterReducer(state, increment());
    state = counterReducer(state, decrement());
    
    expect(state.value).toEqual(1);
  });
});
```

### Testing Complex State Updates

```typescript
// todosSlice.ts
interface Todo {
  id: string;
  text: string;
  completed: boolean;
}

const todosSlice = createSlice({
  name: 'todos',
  initialState: [] as Todo[],
  reducers: {
    todoAdded: (state, action: PayloadAction<Todo>) => {
      state.push(action.payload);
    },
    todoToggled: (state, action: PayloadAction<string>) => {
      const todo = state.find(t => t.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
    todoRemoved: (state, action: PayloadAction<string>) => {
      return state.filter(t => t.id !== action.payload);
    }
  }
});

// todosSlice.test.ts
describe('todos reducer', () => {
  const mockTodo: Todo = {
    id: '1',
    text: 'Test todo',
    completed: false
  };
  
  it('should add todo', () => {
    const state = todosReducer([], todoAdded(mockTodo));
    
    expect(state).toHaveLength(1);
    expect(state[0]).toEqual(mockTodo);
  });
  
  it('should toggle todo', () => {
    const initialState = [mockTodo];
    const state = todosReducer(initialState, todoToggled('1'));
    
    expect(state[0].completed).toBe(true);
  });
  
  it('should not toggle non-existent todo', () => {
    const initialState = [mockTodo];
    const state = todosReducer(initialState, todoToggled('999'));
    
    expect(state).toEqual(initialState);
  });
  
  it('should remove todo', () => {
    const initialState = [mockTodo];
    const state = todosReducer(initialState, todoRemoved('1'));
    
    expect(state).toHaveLength(0);
  });
});
```

### Testing with Immer

```typescript
// Immer allows "mutations" but produces immutable results
it('should not mutate original state', () => {
  const initialState = [{ id: '1', text: 'Todo', completed: false }];
  
  const newState = todosReducer(initialState, todoToggled('1'));
  
  // Original state unchanged
  expect(initialState[0].completed).toBe(false);
  
  // New state has change
  expect(newState[0].completed).toBe(true);
  
  // Different references
  expect(newState).not.toBe(initialState);
  expect(newState[0]).not.toBe(initialState[0]);
});
```

---

## 13.3 Testing Async Thunks

### Basic Thunk Testing

```typescript
// usersSlice.ts
export const fetchUserById = createAsyncThunk<
  User,
  number,
  { rejectValue: string }
>(
  'users/fetchById',
  async (userId, { rejectWithValue }) => {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) {
      return rejectWithValue('Failed to fetch user');
    }
    return response.json();
  }
);

// usersSlice.test.ts
import { configureStore } from '@reduxjs/toolkit';
import userReducer, { fetchUserById } from './usersSlice';

describe('fetchUserById', () => {
  let store: ReturnType<typeof configureStore>;
  
  beforeEach(() => {
    store = configureStore({
      reducer: {
        users: userReducer
      }
    });
  });
  
  it('should fetch user successfully', async () => {
    // Mock fetch
    global.fetch = jest.fn(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ id: 1, name: 'John' })
      } as Response)
    );
    
    // Dispatch thunk
    await store.dispatch(fetchUserById(1));
    
    // Check state
    const state = store.getState().users;
    expect(state.currentUser).toEqual({ id: 1, name: 'John' });
    expect(state.loading).toBe(false);
  });
  
  it('should handle fetch error', async () => {
    // Mock failed fetch
    global.fetch = jest.fn(() =>
      Promise.resolve({
        ok: false,
        status: 404
      } as Response)
    );
    
    await store.dispatch(fetchUserById(1));
    
    const state = store.getState().users;
    expect(state.error).toBe('Failed to fetch user');
    expect(state.loading).toBe(false);
  });
});
```

### Testing Thunk Lifecycle

```typescript
describe('fetchUserById lifecycle', () => {
  it('should set loading state on pending', () => {
    const initialState = { currentUser: null, loading: false, error: null };
    
    const state = userReducer(
      initialState,
      fetchUserById.pending('requestId', 1)
    );
    
    expect(state.loading).toBe(true);
    expect(state.error).toBe(null);
  });
  
  it('should set user on fulfilled', () => {
    const initialState = { currentUser: null, loading: true, error: null };
    const user = { id: 1, name: 'John' };
    
    const state = userReducer(
      initialState,
      fetchUserById.fulfilled(user, 'requestId', 1)
    );
    
    expect(state.currentUser).toEqual(user);
    expect(state.loading).toBe(false);
  });
  
  it('should set error on rejected', () => {
    const initialState = { currentUser: null, loading: true, error: null };
    
    const state = userReducer(
      initialState,
      fetchUserById.rejected(
        new Error('Network error'),
        'requestId',
        1,
        'Network error'
      )
    );
    
    expect(state.error).toBe('Network error');
    expect(state.loading).toBe(false);
  });
});
```

### Mocking API Calls with MSW

```typescript
// setupTests.ts
import { setupServer } from 'msw/node';
import { rest } from 'msw';

export const server = setupServer(
  rest.get('/api/users/:id', (req, res, ctx) => {
    return res(
      ctx.json({
        id: Number(req.params.id),
        name: 'John Doe'
      })
    );
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

// test file
describe('fetchUserById with MSW', () => {
  it('should fetch user', async () => {
    const store = configureStore({
      reducer: { users: userReducer }
    });
    
    await store.dispatch(fetchUserById(1));
    
    const state = store.getState().users;
    expect(state.currentUser).toEqual({ id: 1, name: 'John Doe' });
  });
  
  it('should handle server error', async () => {
    // Override default handler
    server.use(
      rest.get('/api/users/:id', (req, res, ctx) => {
        return res(ctx.status(500));
      })
    );
    
    const store = configureStore({
      reducer: { users: userReducer }
    });
    
    await store.dispatch(fetchUserById(1));
    
    const state = store.getState().users;
    expect(state.error).toBeTruthy();
  });
});
```

---

## 13.4 Testing Selectors

### Basic Selector Tests

```typescript
// selectors.ts
export const selectTodos = (state: RootState) => state.todos;
export const selectCompletedTodos = (state: RootState) =>
  state.todos.filter(t => t.completed);
export const selectTodoCount = (state: RootState) => state.todos.length;

// selectors.test.ts
describe('todo selectors', () => {
  const mockState: RootState = {
    todos: [
      { id: '1', text: 'Todo 1', completed: false },
      { id: '2', text: 'Todo 2', completed: true },
      { id: '3', text: 'Todo 3', completed: false }
    ]
  };
  
  it('should select all todos', () => {
    const result = selectTodos(mockState);
    expect(result).toHaveLength(3);
  });
  
  it('should select completed todos', () => {
    const result = selectCompletedTodos(mockState);
    expect(result).toHaveLength(1);
    expect(result[0].id).toBe('2');
  });
  
  it('should select todo count', () => {
    const result = selectTodoCount(mockState);
    expect(result).toBe(3);
  });
});
```

### Testing Memoized Selectors

```typescript
import { createSelector } from '@reduxjs/toolkit';

const selectTodos = (state: RootState) => state.todos;
const selectFilter = (state: RootState) => state.filter;

const selectFilteredTodos = createSelector(
  [selectTodos, selectFilter],
  (todos, filter) => {
    console.log('Computing filtered todos');
    switch (filter) {
      case 'active':
        return todos.filter(t => !t.completed);
      case 'completed':
        return todos.filter(t => t.completed);
      default:
        return todos;
    }
  }
);

describe('selectFilteredTodos', () => {
  const mockState: RootState = {
    todos: [
      { id: '1', text: 'Todo 1', completed: false },
      { id: '2', text: 'Todo 2', completed: true }
    ],
    filter: 'all'
  };
  
  it('should filter active todos', () => {
    const state = { ...mockState, filter: 'active' as const };
    const result = selectFilteredTodos(state);
    
    expect(result).toHaveLength(1);
    expect(result[0].id).toBe('1');
  });
  
  it('should memoize results', () => {
    const consoleSpy = jest.spyOn(console, 'log');
    
    // First call - computes
    selectFilteredTodos(mockState);
    expect(consoleSpy).toHaveBeenCalledTimes(1);
    
    // Second call with same input - uses cache
    selectFilteredTodos(mockState);
    expect(consoleSpy).toHaveBeenCalledTimes(1);
    
    // Third call with different input - recomputes
    selectFilteredTodos({ ...mockState, filter: 'active' });
    expect(consoleSpy).toHaveBeenCalledTimes(2);
    
    consoleSpy.mockRestore();
  });
  
  it('should track recomputations', () => {
    selectFilteredTodos.resetRecomputations();
    
    selectFilteredTodos(mockState);
    selectFilteredTodos(mockState);
    selectFilteredTodos({ ...mockState, filter: 'active' });
    
    expect(selectFilteredTodos.recomputations()).toBe(2);
  });
});
```

---

## 13.5 Testing Components with Redux

### Setup Test Utils

```typescript
// test-utils.tsx
import { ReactElement } from 'react';
import { render, RenderOptions } from '@testing-library/react';
import { configureStore, PreloadedState } from '@reduxjs/toolkit';
import { Provider } from 'react-redux';
import { RootState, store as realStore } from '../app/store';

interface ExtendedRenderOptions extends Omit<RenderOptions, 'wrapper'> {
  preloadedState?: PreloadedState<RootState>;
  store?: typeof realStore;
}

export function renderWithProviders(
  ui: ReactElement,
  {
    preloadedState = {},
    store = configureStore({
      reducer: {
        counter: counterReducer,
        todos: todosReducer
      },
      preloadedState
    }),
    ...renderOptions
  }: ExtendedRenderOptions = {}
) {
  function Wrapper({ children }: { children: React.ReactNode }) {
    return <Provider store={store}>{children}</Provider>;
  }
  
  return { store, ...render(ui, { wrapper: Wrapper, ...renderOptions }) };
}

// Re-export everything
export * from '@testing-library/react';
export { renderWithProviders as render };
```

### Testing Connected Components

```typescript
// Counter.tsx
import { useAppSelector, useAppDispatch } from './hooks';
import { increment, decrement, selectCount } from './counterSlice';

export function Counter() {
  const count = useAppSelector(selectCount);
  const dispatch = useAppDispatch();
  
  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
    </div>
  );
}

// Counter.test.tsx
import { screen, fireEvent } from '@testing-library/react';
import { render } from './test-utils';
import { Counter } from './Counter';

describe('Counter component', () => {
  it('should render initial count', () => {
    render(<Counter />);
    
    expect(screen.getByText('Count: 0')).toBeInTheDocument();
  });
  
  it('should increment count', () => {
    render(<Counter />);
    
    const incrementButton = screen.getByText('+');
    fireEvent.click(incrementButton);
    
    expect(screen.getByText('Count: 1')).toBeInTheDocument();
  });
  
  it('should decrement count', () => {
    render(<Counter />);
    
    const decrementButton = screen.getByText('-');
    fireEvent.click(decrementButton);
    
    expect(screen.getByText('Count: -1')).toBeInTheDocument();
  });
  
  it('should start with custom initial state', () => {
    render(<Counter />, {
      preloadedState: {
        counter: { value: 10 }
      }
    });
    
    expect(screen.getByText('Count: 10')).toBeInTheDocument();
  });
});
```

### Testing Async Components

```typescript
// UserProfile.tsx
export function UserProfile({ userId }: { userId: number }) {
  const dispatch = useAppDispatch();
  const user = useAppSelector(selectCurrentUser);
  const loading = useAppSelector(selectLoading);
  const error = useAppSelector(selectError);
  
  useEffect(() => {
    dispatch(fetchUserById(userId));
  }, [userId, dispatch]);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return null;
  
  return <div>User: {user.name}</div>;
}

// UserProfile.test.tsx
import { waitFor, screen } from '@testing-library/react';
import { rest } from 'msw';
import { server } from './mocks/server';
import { render } from './test-utils';
import { UserProfile } from './UserProfile';

describe('UserProfile', () => {
  it('should show loading state', () => {
    render(<UserProfile userId={1} />);
    
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });
  
  it('should display user data', async () => {
    server.use(
      rest.get('/api/users/:id', (req, res, ctx) => {
        return res(ctx.json({ id: 1, name: 'John Doe' }));
      })
    );
    
    render(<UserProfile userId={1} />);
    
    await waitFor(() => {
      expect(screen.getByText('User: John Doe')).toBeInTheDocument();
    });
  });
  
  it('should display error message', async () => {
    server.use(
      rest.get('/api/users/:id', (req, res, ctx) => {
        return res(ctx.status(500));
      })
    );
    
    render(<UserProfile userId={1} />);
    
    await waitFor(() => {
      expect(screen.getByText(/Error:/)).toBeInTheDocument();
    });
  });
});
```

### Testing User Interactions

```typescript
// TodoForm.tsx
export function TodoForm() {
  const dispatch = useAppDispatch();
  const [text, setText] = useState('');
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (text.trim()) {
      dispatch(todoAdded({ id: nanoid(), text, completed: false }));
      setText('');
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Add todo"
      />
      <button type="submit">Add</button>
    </form>
  );
}

// TodoForm.test.tsx
import { screen, fireEvent } from '@testing-library/react';
import { render } from './test-utils';
import { TodoForm } from './TodoForm';

describe('TodoForm', () => {
  it('should add todo on submit', () => {
    const { store } = render(<TodoForm />);
    
    const input = screen.getByPlaceholderText('Add todo');
    const button = screen.getByText('Add');
    
    // Type text
    fireEvent.change(input, { target: { value: 'New todo' } });
    expect(input).toHaveValue('New todo');
    
    // Submit form
    fireEvent.click(button);
    
    // Check store
    const todos = store.getState().todos;
    expect(todos).toHaveLength(1);
    expect(todos[0].text).toBe('New todo');
    
    // Input should be cleared
    expect(input).toHaveValue('');
  });
  
  it('should not add empty todo', () => {
    const { store } = render(<TodoForm />);
    
    const button = screen.getByText('Add');
    fireEvent.click(button);
    
    expect(store.getState().todos).toHaveLength(0);
  });
});
```

---

## 13.6 Testing RTK Query

### Testing Query Hooks

```typescript
// api.ts
export const api = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  endpoints: (builder) => ({
    getPosts: builder.query<Post[], void>({
      query: () => '/posts'
    })
  })
});

// PostsList.test.tsx
import { screen, waitFor } from '@testing-library/react';
import { rest } from 'msw';
import { server } from './mocks/server';
import { setupApiStore } from './test-utils';
import { api } from './api';
import { PostsList } from './PostsList';

describe('PostsList', () => {
  const storeRef = setupApiStore(api);
  
  it('should fetch and display posts', async () => {
    server.use(
      rest.get('/api/posts', (req, res, ctx) => {
        return res(
          ctx.json([
            { id: 1, title: 'Post 1' },
            { id: 2, title: 'Post 2' }
          ])
        );
      })
    );
    
    render(<PostsList />, { store: storeRef.store });
    
    await waitFor(() => {
      expect(screen.getByText('Post 1')).toBeInTheDocument();
      expect(screen.getByText('Post 2')).toBeInTheDocument();
    });
  });
});
```

### Testing Mutations

```typescript
// AddPostForm.test.tsx
describe('AddPostForm', () => {
  it('should create post', async () => {
    server.use(
      rest.post('/api/posts', async (req, res, ctx) => {
        const body = await req.json();
        return res(
          ctx.json({
            id: 1,
            ...body
          })
        );
      })
    );
    
    const { store } = render(<AddPostForm />);
    
    const input = screen.getByPlaceholderText('Title');
    const button = screen.getByText('Add Post');
    
    fireEvent.change(input, { target: { value: 'New Post' } });
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(screen.getByText('Post created!')).toBeInTheDocument();
    });
  });
});
```

---

## 13.7 Integration Testing

### Testing Complete Features

```typescript
describe('Todo Feature', () => {
  it('should complete full todo workflow', async () => {
    const { store } = render(<TodoApp />);
    
    // Add todo
    const input = screen.getByPlaceholderText('Add todo');
    const addButton = screen.getByText('Add');
    
    fireEvent.change(input, { target: { value: 'Buy milk' } });
    fireEvent.click(addButton);
    
    // Verify todo appears
    expect(screen.getByText('Buy milk')).toBeInTheDocument();
    
    // Toggle todo
    const checkbox = screen.getByRole('checkbox');
    fireEvent.click(checkbox);
    
    // Verify completed
    const state = store.getState();
    expect(state.todos[0].completed).toBe(true);
    
    // Delete todo
    const deleteButton = screen.getByText('Delete');
    fireEvent.click(deleteButton);
    
    // Verify removed
    expect(screen.queryByText('Buy milk')).not.toBeInTheDocument();
  });
});
```

### Testing State Persistence

```typescript
describe('State Persistence', () => {
  it('should save and restore state', () => {
    const { store } = render(<App />);
    
    // Add data
    store.dispatch(todoAdded({ id: '1', text: 'Test', completed: false }));
    
    // Simulate page reload
    const savedState = store.getState();
    
    const { store: newStore } = render(<App />, {
      preloadedState: savedState
    });
    
    // Verify state restored
    const state = newStore.getState();
    expect(state.todos).toHaveLength(1);
    expect(state.todos[0].text).toBe('Test');
  });
});
```

---

## 13.8 Test Coverage

### Running Coverage

```bash
# Jest with coverage
npm test -- --coverage

# Specific file
npm test -- --coverage counterSlice.test.ts

# Coverage threshold in package.json
{
  "jest": {
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    }
  }
}
```

### Interpreting Coverage

```
File              | % Stmts | % Branch | % Funcs | % Lines
------------------|---------|----------|---------|--------
counterSlice.ts   |   100   |   100    |   100   |   100
todosSlice.ts     |   85    |   80     |   90    |   85
usersSlice.ts     |   70    |   60     |   75    |   70
```

**Goals:**
- **Statements:** 80%+
- **Branches:** 80%+
- **Functions:** 80%+
- **Lines:** 80%+

---

## Best Practices

### âœ… Do's

1. **Test behavior, not implementation**
```typescript
// âœ… Good
expect(screen.getByText('Count: 1')).toBeInTheDocument();

// âŒ Bad
expect(component.state.count).toBe(1);
```

2. **Use meaningful test descriptions**
```typescript
// âœ… Good
it('should add todo when user submits form', () => {})

// âŒ Bad
it('works', () => {})
```

3. **Mock external dependencies**
```typescript
// âœ… Mock API calls
server.use(rest.get('/api/users', ...))
```

4. **Test edge cases**
```typescript
it('should handle empty list', () => {})
it('should handle network error', () => {})
it('should handle invalid input', () => {})
```

5. **Use test utilities**
```typescript
// âœ… Reusable test setup
renderWithProviders(<Component />)
```

### âŒ Don'ts

1. **Don't test Redux internals**
```typescript
// âŒ Testing RTK implementation
expect(slice.reducer.name).toBe('counter')
```

2. **Don't test multiple things in one test**
```typescript
// âŒ Too much in one test
it('should add, toggle, and delete todo', () => {})
```

3. **Don't skip cleanup**
```typescript
// âœ… Always clean up
afterEach(() => {
  server.resetHandlers();
  jest.clearAllMocks();
});
```

---

## Summary

Testing Redux Toolkit applications:

| What to Test | How to Test |
|--------------|-------------|
| **Reducers** | Direct function calls |
| **Thunks** | Mock store + API |
| **Selectors** | Pass mock state |
| **Components** | React Testing Library |
| **Integration** | Full feature flows |

**Key Takeaways:**
1. Test behavior, not implementation
2. Use test utilities for DRY tests
3. Mock API calls with MSW
4. Test async flows completely
5. Aim for 80%+ coverage
6. Write integration tests for features

Next: Chapter 14 covers Advanced Patterns! ðŸš€