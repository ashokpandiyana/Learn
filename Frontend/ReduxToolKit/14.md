# Chapter 14: Advanced Patterns and Best Practices

## Overview

This final chapter covers advanced Redux Toolkit patterns, architectural decisions, real-world scenarios, and production-ready best practices that will make you a Redux expert.

---

## 14.1 Feature-Based File Structure

### Recommended Structure

```
src/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ store.ts                    # Store configuration
â”‚   â”œâ”€â”€ hooks.ts                    # Typed Redux hooks
â”‚   â””â”€â”€ rootReducer.ts              # Root reducer (if needed)
â”‚
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ authSlice.ts           # Slice
â”‚   â”‚   â”œâ”€â”€ authAPI.ts             # API calls
â”‚   â”‚   â”œâ”€â”€ authSelectors.ts       # Selectors (if complex)
â”‚   â”‚   â”œâ”€â”€ authTypes.ts           # TypeScript types
â”‚   â”‚   â”œâ”€â”€ authMiddleware.ts      # Feature-specific middleware
â”‚   â”‚   â”œâ”€â”€ Login.tsx              # Components
â”‚   â”‚   â”œâ”€â”€ Register.tsx
â”‚   â”‚   â””â”€â”€ authUtils.ts           # Utility functions
â”‚   â”‚
â”‚   â”œâ”€â”€ todos/
â”‚   â”‚   â”œâ”€â”€ todosSlice.ts
â”‚   â”‚   â”œâ”€â”€ TodoList.tsx
â”‚   â”‚   â”œâ”€â”€ TodoItem.tsx
â”‚   â”‚   â””â”€â”€ types.ts
â”‚   â”‚
â”‚   â””â”€â”€ users/
â”‚       â”œâ”€â”€ usersSlice.ts
â”‚       â”œâ”€â”€ usersAPI.ts
â”‚       â””â”€â”€ UserProfile.tsx
â”‚
â”œâ”€â”€ common/                          # Shared across features
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ Button.tsx
â”‚   â”‚   â””â”€â”€ Modal.tsx
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â””â”€â”€ useDebounce.ts
â”‚   â””â”€â”€ utils/
â”‚       â””â”€â”€ formatters.ts
â”‚
â”œâ”€â”€ services/                        # External services
â”‚   â”œâ”€â”€ api.ts                      # Base API config
â”‚   â””â”€â”€ analytics.ts
â”‚
â””â”€â”€ types/                           # Global types
    â””â”€â”€ index.ts
```

### Benefits

1. **Colocation**: Related code stays together
2. **Scalability**: Easy to add new features
3. **Maintainability**: Find code quickly
4. **Team collaboration**: Clear ownership

---

## 14.2 Ducks Pattern with RTK

### Modern Ducks Pattern

```typescript
// features/todos/todosSlice.ts

// 1. Types
export interface Todo {
  id: string;
  text: string;
  completed: boolean;
  priority: 'low' | 'medium' | 'high';
  createdAt: string;
}

interface TodosState {
  items: Todo[];
  filter: 'all' | 'active' | 'completed';
  loading: boolean;
  error: string | null;
}

// 2. Initial State
const initialState: TodosState = {
  items: [],
  filter: 'all',
  loading: false,
  error: null
};

// 3. Async Thunks
export const fetchTodos = createAsyncThunk<Todo[]>(
  'todos/fetchAll',
  async () => {
    const response = await fetch('/api/todos');
    return response.json();
  }
);

// 4. Slice
const todosSlice = createSlice({
  name: 'todos',
  initialState,
  reducers: {
    todoAdded: (state, action: PayloadAction<Todo>) => {
      state.items.push(action.payload);
    },
    todoToggled: (state, action: PayloadAction<string>) => {
      const todo = state.items.find(t => t.id === action.payload);
      if (todo) todo.completed = !todo.completed;
    },
    filterChanged: (state, action: PayloadAction<TodosState['filter']>) => {
      state.filter = action.payload;
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchTodos.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchTodos.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload;
      })
      .addCase(fetchTodos.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Failed to fetch';
      });
  }
});

// 5. Actions
export const { todoAdded, todoToggled, filterChanged } = todosSlice.actions;

// 6. Selectors
export const selectTodos = (state: RootState) => state.todos.items;
export const selectFilter = (state: RootState) => state.todos.filter;
export const selectLoading = (state: RootState) => state.todos.loading;

export const selectFilteredTodos = createSelector(
  [selectTodos, selectFilter],
  (todos, filter) => {
    switch (filter) {
      case 'active':
        return todos.filter(t => !t.completed);
      case 'completed':
        return todos.filter(t => t.completed);
      default:
        return todos;
    }
  }
);

// 7. Reducer (default export)
export default todosSlice.reducer;
```

---

## 14.3 Handling Complex State Updates

### Nested State Management

```typescript
interface AppState {
  user: {
    profile: {
      name: string;
      settings: {
        theme: 'light' | 'dark';
        notifications: {
          email: boolean;
          push: boolean;
        };
      };
    };
  };
}

const slice = createSlice({
  name: 'app',
  initialState: {} as AppState,
  reducers: {
    // âœ… Immer makes this easy
    notificationToggled: (state, action: PayloadAction<'email' | 'push'>) => {
      state.user.profile.settings.notifications[action.payload] = 
        !state.user.profile.settings.notifications[action.payload];
    }
  }
});
```

### State Machines Pattern

```typescript
type Status = 'idle' | 'loading' | 'succeeded' | 'failed';

interface RequestState<T> {
  status: Status;
  data: T | null;
  error: string | null;
}

// State machine transitions
const slice = createSlice({
  name: 'request',
  initialState: {
    status: 'idle',
    data: null,
    error: null
  } as RequestState<User>,
  reducers: {
    requestStarted: (state) => {
      // Can only start from idle or failed
      if (state.status === 'idle' || state.status === 'failed') {
        state.status = 'loading';
        state.error = null;
      }
    },
    requestSucceeded: (state, action: PayloadAction<User>) => {
      if (state.status === 'loading') {
        state.status = 'succeeded';
        state.data = action.payload;
      }
    },
    requestFailed: (state, action: PayloadAction<string>) => {
      if (state.status === 'loading') {
        state.status = 'failed';
        state.error = action.payload;
      }
    },
    requestReset: (state) => {
      state.status = 'idle';
      state.data = null;
      state.error = null;
    }
  }
});
```

---

## 14.4 Undo/Redo Pattern

### Using redux-undo

```typescript
import undoable from 'redux-undo';

const todosSlice = createSlice({
  name: 'todos',
  initialState: [] as Todo[],
  reducers: {
    todoAdded: (state, action: PayloadAction<Todo>) => {
      state.push(action.payload);
    },
    todoRemoved: (state, action: PayloadAction<string>) => {
      return state.filter(t => t.id !== action.payload);
    }
  }
});

// Wrap reducer with undo functionality
const undoableTodosReducer = undoable(todosSlice.reducer, {
  limit: 10, // Keep only 10 history states
  filter: (action) => {
    // Exclude certain actions from history
    return action.type !== 'todos/someIgnoredAction';
  }
});

// Store configuration
const store = configureStore({
  reducer: {
    todos: undoableTodosReducer
  }
});

// Usage
import { ActionCreators } from 'redux-undo';

dispatch(ActionCreators.undo()); // Undo last action
dispatch(ActionCreators.redo()); // Redo last undone action
dispatch(ActionCreators.clearHistory()); // Clear history

// Access state
const todos = state.todos.present; // Current state
const past = state.todos.past;     // Previous states
const future = state.todos.future; // Redoable states
```

### Custom Undo/Redo

```typescript
interface HistoryState<T> {
  past: T[];
  present: T;
  future: T[];
}

function createUndoableSlice<T>(config: {
  name: string;
  initialState: T;
  reducers: any;
}) {
  const historyInitialState: HistoryState<T> = {
    past: [],
    present: config.initialState,
    future: []
  };
  
  return createSlice({
    name: config.name,
    initialState: historyInitialState,
    reducers: {
      ...Object.keys(config.reducers).reduce((acc, key) => {
        acc[key] = (state: HistoryState<T>, action: any) => {
          const newPresent = config.reducers[key](state.present, action);
          return {
            past: [...state.past, state.present],
            present: newPresent,
            future: []
          };
        };
        return acc;
      }, {} as any),
      undo: (state: HistoryState<T>) => {
        if (state.past.length === 0) return state;
        
        const previous = state.past[state.past.length - 1];
        const newPast = state.past.slice(0, state.past.length - 1);
        
        return {
          past: newPast,
          present: previous,
          future: [state.present, ...state.future]
        };
      },
      redo: (state: HistoryState<T>) => {
        if (state.future.length === 0) return state;
        
        const next = state.future[0];
        const newFuture = state.future.slice(1);
        
        return {
          past: [...state.past, state.present],
          present: next,
          future: newFuture
        };
      }
    }
  });
}
```

---

## 14.5 Optimistic Updates Pattern

### Manual Optimistic Updates

```typescript
const postsSlice = createSlice({
  name: 'posts',
  initialState: {
    items: [] as Post[],
    optimisticUpdates: new Map<string, Post>()
  },
  reducers: {
    postUpdateStarted: (state, action: PayloadAction<Post>) => {
      // Store optimistic update
      state.optimisticUpdates.set(action.payload.id, action.payload);
    },
    postUpdateSucceeded: (state, action: PayloadAction<Post>) => {
      // Apply real update
      const index = state.items.findIndex(p => p.id === action.payload.id);
      if (index !== -1) {
        state.items[index] = action.payload;
      }
      // Clear optimistic update
      state.optimisticUpdates.delete(action.payload.id);
    },
    postUpdateFailed: (state, action: PayloadAction<string>) => {
      // Rollback optimistic update
      state.optimisticUpdates.delete(action.payload);
    }
  }
});

// Selector that merges optimistic updates
export const selectPosts = createSelector(
  [
    (state: RootState) => state.posts.items,
    (state: RootState) => state.posts.optimisticUpdates
  ],
  (items, optimistic) => {
    return items.map(item => 
      optimistic.has(item.id) ? optimistic.get(item.id)! : item
    );
  }
);
```

### RTK Query Optimistic Updates

```typescript
const api = createApi({
  // ...
  endpoints: (builder) => ({
    updatePost: builder.mutation<Post, Partial<Post> & Pick<Post, 'id'>>({
      query: ({ id, ...patch }) => ({
        url: `/posts/${id}`,
        method: 'PATCH',
        body: patch
      }),
      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {
        // Optimistic update
        const patchResult = dispatch(
          api.util.updateQueryData('getPost', id, (draft) => {
            Object.assign(draft, patch);
          })
        );
        
        try {
          await queryFulfilled;
        } catch {
          // Rollback on error
          patchResult.undo();
          
          // Show error message
          dispatch(showNotification('Update failed'));
        }
      }
    })
  })
});
```

---

## 14.6 Polling and Auto-Refresh

### Polling with RTK Query

```typescript
function LiveDataComponent() {
  const { data, error } = useGetLiveDataQuery(undefined, {
    pollingInterval: 3000, // Poll every 3 seconds
    skipPollingIfUnfocused: true // Stop when tab not visible
  });
  
  return <div>{data?.value}</div>;
}
```

### Custom Polling with Listeners

```typescript
listenerMiddleware.startListening({
  actionCreator: startPolling,
  effect: async (action, listenerApi) => {
    while (true) {
      // Check if cancelled
      if (listenerApi.signal.aborted) break;
      
      // Fetch data
      await listenerApi.dispatch(fetchData());
      
      // Wait before next poll
      await listenerApi.delay(5000);
    }
  }
});

listenerMiddleware.startListening({
  actionCreator: stopPolling,
  effect: (action, listenerApi) => {
    listenerApi.cancelActiveListeners();
  }
});
```

---

## 14.7 Real-time Updates

### WebSocket Integration

```typescript
// websocketMiddleware.ts
const websocketMiddleware: Middleware = (storeAPI) => {
  let socket: WebSocket | null = null;
  
  return (next) => (action) => {
    switch (action.type) {
      case 'websocket/connect':
        socket = new WebSocket(action.payload.url);
        
        socket.onmessage = (event) => {
          const data = JSON.parse(event.data);
          storeAPI.dispatch({
            type: 'websocket/message',
            payload: data
          });
        };
        
        socket.onclose = () => {
          storeAPI.dispatch({ type: 'websocket/disconnected' });
        };
        break;
        
      case 'websocket/disconnect':
        socket?.close();
        socket = null;
        break;
        
      case 'websocket/send':
        socket?.send(JSON.stringify(action.payload));
        break;
    }
    
    return next(action);
  };
};
```

### RTK Query WebSocket Streaming

```typescript
const api = createApi({
  // ...
  endpoints: (builder) => ({
    getMessages: builder.query<Message[], string>({
      query: (roomId) => `/rooms/${roomId}/messages`,
      async onCacheEntryAdded(
        roomId,
        { updateCachedData, cacheDataLoaded, cacheEntryRemoved }
      ) {
        // Wait for initial data
        await cacheDataLoaded;
        
        // Connect WebSocket
        const ws = new WebSocket(`ws://api.example.com/rooms/${roomId}`);
        
        ws.onmessage = (event) => {
          const message = JSON.parse(event.data);
          
          // Update cache with new message
          updateCachedData((draft) => {
            draft.push(message);
          });
        };
        
        // Cleanup
        await cacheEntryRemoved;
        ws.close();
      }
    })
  })
});
```

---

## 14.8 Authentication Patterns

### Complete Auth Flow

```typescript
// authSlice.ts
interface AuthState {
  user: User | null;
  token: string | null;
  refreshToken: string | null;
  isAuthenticated: boolean;
  loading: boolean;
  error: string | null;
}

const initialState: AuthState = {
  user: null,
  token: localStorage.getItem('token'),
  refreshToken: localStorage.getItem('refreshToken'),
  isAuthenticated: false,
  loading: false,
  error: null
};

export const login = createAsyncThunk<
  { user: User; token: string; refreshToken: string },
  { email: string; password: string }
>(
  'auth/login',
  async (credentials, { rejectWithValue }) => {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials)
      });
      
      if (!response.ok) {
        return rejectWithValue('Invalid credentials');
      }
      
      const data = await response.json();
      
      // Save to localStorage
      localStorage.setItem('token', data.token);
      localStorage.setItem('refreshToken', data.refreshToken);
      
      return data;
    } catch (error) {
      return rejectWithValue('Network error');
    }
  }
);

export const refreshAccessToken = createAsyncThunk<
  { token: string },
  void,
  { state: RootState }
>(
  'auth/refresh',
  async (_, { getState, rejectWithValue }) => {
    const refreshToken = getState().auth.refreshToken;
    
    if (!refreshToken) {
      return rejectWithValue('No refresh token');
    }
    
    const response = await fetch('/api/auth/refresh', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ refreshToken })
    });
    
    if (!response.ok) {
      return rejectWithValue('Refresh failed');
    }
    
    const data = await response.json();
    localStorage.setItem('token', data.token);
    
    return data;
  }
);

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    logout: (state) => {
      state.user = null;
      state.token = null;
      state.refreshToken = null;
      state.isAuthenticated = false;
      localStorage.removeItem('token');
      localStorage.removeItem('refreshToken');
    }
  },
  extraReducers: (builder) => {
    builder
      // Login
      .addCase(login.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(login.fulfilled, (state, action) => {
        state.loading = false;
        state.user = action.payload.user;
        state.token = action.payload.token;
        state.refreshToken = action.payload.refreshToken;
        state.isAuthenticated = true;
      })
      .addCase(login.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      
      // Refresh token
      .addCase(refreshAccessToken.fulfilled, (state, action) => {
        state.token = action.payload.token;
      })
      .addCase(refreshAccessToken.rejected, (state) => {
        // Token refresh failed - logout
        state.user = null;
        state.token = null;
        state.refreshToken = null;
        state.isAuthenticated = false;
      });
  }
});

export const { logout } = authSlice.actions;
export default authSlice.reducer;
```

### Auto Token Refresh

```typescript
// Middleware to auto-refresh token
const tokenRefreshMiddleware: Middleware = (storeAPI) => {
  let refreshPromise: Promise<any> | null = null;
  
  return (next) => async (action) => {
    const state = storeAPI.getState() as RootState;
    
    // Check if token is expired
    if (state.auth.token && isTokenExpired(state.auth.token)) {
      // Prevent multiple refresh attempts
      if (!refreshPromise) {
        refreshPromise = storeAPI.dispatch(refreshAccessToken());
        
        try {
          await refreshPromise;
        } finally {
          refreshPromise = null;
        }
      } else {
        await refreshPromise;
      }
    }
    
    return next(action);
  };
};
```

### Protected Route Pattern

```typescript
function ProtectedRoute({ children }: { children: ReactNode }) {
  const isAuthenticated = useAppSelector(state => state.auth.isAuthenticated);
  const location = useLocation();
  
  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }
  
  return <>{children}</>;
}

// Usage
<Routes>
  <Route path="/login" element={<Login />} />
  <Route
    path="/dashboard"
    element={
      <ProtectedRoute>
        <Dashboard />
      </ProtectedRoute>
    }
  />
</Routes>
```

---

## 14.9 Error Handling Strategies

### Global Error Handler

```typescript
const errorHandlerMiddleware: Middleware = (storeAPI) => (next) => (action) => {
  try {
    return next(action);
  } catch (error) {
    console.error('Redux error:', error);
    
    // Log to error tracking service
    if (process.env.NODE_ENV === 'production') {
      Sentry.captureException(error, {
        extra: {
          action,
          state: storeAPI.getState()
        }
      });
    }
    
    // Show user-friendly message
    storeAPI.dispatch({
      type: 'ui/showError',
      payload: 'Something went wrong. Please try again.'
    });
    
    throw error;
  }
};
```

### Error Boundary Integration

```typescript
// ErrorBoundary.tsx
class ErrorBoundary extends Component<
  { children: ReactNode },
  { hasError: boolean }
> {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Log to Redux
    store.dispatch({
      type: 'errors/errorCaught',
      payload: {
        error: error.message,
        stack: error.stack,
        componentStack: errorInfo.componentStack
      }
    });
  }
  
  render() {
    if (this.state.hasError) {
      return <ErrorFallback />;
    }
    
    return this.props.children;
  }
}
```

### User-Friendly Error Messages

```typescript
const errorMessages: Record<string, string> = {
  'Network request failed': 'Unable to connect. Check your internet connection.',
  '401': 'Please log in to continue.',
  '403': 'You don\'t have permission to access this.',
  '404': 'The requested resource was not found.',
  '500': 'Server error. Please try again later.'
};

function getUserFriendlyError(error: any): string {
  if (error.message in errorMessages) {
    return errorMessages[error.message];
  }
  
  if (error.status in errorMessages) {
    return errorMessages[error.status];
  }
  
  return 'An unexpected error occurred.';
}
```

---

## 14.10 Production Checklist

### Performance

- [ ] Use memoized selectors
- [ ] Implement code splitting
- [ ] Lazy load routes
- [ ] Virtualize long lists
- [ ] Profile with React DevTools
- [ ] Optimize bundle size

### Security

- [ ] Sanitize DevTools in production
- [ ] Never store passwords in state
- [ ] Use HTTPS for API calls
- [ ] Implement CSRF protection
- [ ] Validate and sanitize inputs
- [ ] Use secure token storage

### Error Handling

- [ ] Global error boundary
- [ ] Error logging service
- [ ] User-friendly error messages
- [ ] Retry logic for failed requests
- [ ] Network error handling
- [ ] Timeout handling

### Testing

- [ ] 80%+ test coverage
- [ ] Unit tests for slices
- [ ] Integration tests for features
- [ ] E2E tests for critical flows
- [ ] Mock external dependencies
- [ ] Test edge cases

### Monitoring

- [ ] Analytics tracking
- [ ] Performance monitoring
- [ ] Error tracking (Sentry)
- [ ] User session replay
- [ ] API monitoring
- [ ] Redux DevTools in staging

### Code Quality

- [ ] TypeScript strict mode
- [ ] ESLint configured
- [ ] Prettier for formatting
- [ ] Pre-commit hooks
- [ ] Code review process
- [ ] Documentation

---

## Best Practices Summary

### Architecture

âœ… **Feature-based structure**
âœ… **Ducks pattern for organization**
âœ… **Separation of concerns**
âœ… **Reusable utilities**

### State Management

âœ… **Normalize relational data**
âœ… **Use EntityAdapter for collections**
âœ… **Memoize derived data**
âœ… **Keep state minimal**

### Performance

âœ… **Code split by route**
âœ… **Lazy load heavy features**
âœ… **Memoize selectors**
âœ… **Virtualize long lists**

### TypeScript

âœ… **Type all state interfaces**
âœ… **Use PayloadAction<T>**
âœ… **Type thunk configurations**
âœ… **Create typed hooks**

### Testing

âœ… **Test behavior, not implementation**
âœ… **Mock external dependencies**
âœ… **Test edge cases**
âœ… **Integration tests for flows**

### Security

âœ… **Never store sensitive data**
âœ… **Sanitize DevTools**
âœ… **Validate inputs**
âœ… **Use HTTPS**

---

## Summary

Advanced Redux Toolkit patterns:

| Pattern | Use Case |
|---------|----------|
| **Feature structure** | Organization at scale |
| **Undo/Redo** | Rich editing experiences |
| **Optimistic updates** | Better UX |
| **Real-time** | Live data |
| **Auth flow** | Secure applications |
| **Error handling** | Production reliability |

**Key Takeaways:**
1. Organize code by feature
2. Use established patterns (Ducks, undo/redo)
3. Implement optimistic updates for UX
4. Handle errors gracefully
5. Follow production checklist
6. Test thoroughly
7. Monitor in production
8. Keep learning and adapting

---

## Congratulations! ðŸŽ‰

You've completed the comprehensive Redux Toolkit mastery guide! You now have the knowledge to:

- Build production-grade Redux applications
- Write type-safe TypeScript code
- Optimize performance
- Test effectively
- Handle complex patterns
- Deploy with confidence

**Next Steps:**
1. Build a complete project
2. Contribute to open source
3. Share your knowledge
4. Keep practicing
5. Stay updated with Redux ecosystem

**Happy coding!** ðŸš€