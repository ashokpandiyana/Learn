# Chapter 7: Selectors and Reselect

## Overview

Selectors are functions that extract and derive data from Redux state. They're essential for performance optimization and keeping your components clean. This chapter covers everything from basic selectors to advanced memoization with Reselect.

---

## 7.1 Selector Fundamentals

### What are Selectors?

A **selector** is a function that takes Redux state as an argument and returns derived data.

```javascript
// Basic selector
const selectUser = (state) => state.user;

// Derived selector
const selectUserName = (state) => state.user.name;

// Computed selector
const selectFullName = (state) => 
  `${state.user.firstName} ${state.user.lastName}`;
```

**Flow:**

```
Redux State
    â†“
Selector Function
    â†“
Derived Data
    â†“
Component
```

### Why Use Selectors?

#### **1. Encapsulation**

Hide state shape from components:

```javascript
// âŒ Component knows state structure
function UserProfile() {
  const name = useSelector(state => state.auth.currentUser.profile.name);
  //                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  //                               Tightly coupled to state shape
}

// âœ… Selector hides implementation
const selectUserName = (state) => state.auth.currentUser.profile.name;

function UserProfile() {
  const name = useSelector(selectUserName);
  // Component doesn't care about state structure
}
```

**Benefits:**
- Easy to refactor state shape
- Single place to update if structure changes
- Components stay simple

#### **2. Reusability**

Use same selector across multiple components:

```javascript
// selectors.js
export const selectActiveTodos = (state) => 
  state.todos.filter(todo => !todo.completed);

// Component A
function TodoList() {
  const activeTodos = useSelector(selectActiveTodos);
  return <div>{activeTodos.length} active</div>;
}

// Component B
function TodoSummary() {
  const activeTodos = useSelector(selectActiveTodos);
  return <p>You have {activeTodos.length} tasks</p>;
}
```

#### **3. Testability**

Easy to test selectors in isolation:

```javascript
const selectActiveTodos = (state) => 
  state.todos.filter(todo => !todo.completed);

// Test
test('selectActiveTodos returns only incomplete todos', () => {
  const state = {
    todos: [
      { id: 1, completed: false },
      { id: 2, completed: true },
      { id: 3, completed: false }
    ]
  };
  
  const result = selectActiveTodos(state);
  expect(result).toHaveLength(2);
});
```

#### **4. Performance**

Memoize expensive computations (covered in Section 7.2).

### Input Selectors vs Output Selectors

#### **Input Selectors**

Simple selectors that extract data directly from state:

```javascript
// Input selectors - just return state slices
const selectTodos = (state) => state.todos;
const selectFilter = (state) => state.filter;
const selectUser = (state) => state.user;
```

#### **Output Selectors**

Selectors that derive or compute data:

```javascript
// Output selector - computes derived data
const selectActiveTodos = (state) => {
  const todos = state.todos;
  return todos.filter(todo => !todo.completed);
};

// Output selector - combines multiple pieces
const selectUserStats = (state) => {
  const user = state.user;
  const posts = state.posts;
  return {
    name: user.name,
    postCount: posts.filter(p => p.authorId === user.id).length
  };
};
```

### Selector Naming Conventions

```javascript
// âœ… Good naming
selectUser           // Returns user object
selectUserName       // Returns specific field
selectActiveTodos    // Returns filtered array
selectTodoById       // Parametric selector
selectIsLoading      // Returns boolean
selectHasPermission  // Returns boolean

// âŒ Bad naming
getUser             // Use 'select' prefix
user                // Not a function name
fetchUser           // Sounds like an action
userSelector        // Redundant suffix
```

### Organizing Selectors

#### **Pattern 1: Co-locate with Slices**

```javascript
// todosSlice.js
const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: { /* ... */ }
});

// Export selectors with slice
export const selectAllTodos = (state) => state.todos;
export const selectActiveTodos = (state) => 
  state.todos.filter(t => !t.completed);
export const selectCompletedTodos = (state) => 
  state.todos.filter(t => t.completed);

export default todosSlice.reducer;
```

#### **Pattern 2: Separate Selectors File**

```javascript
// features/todos/selectors.js
export const selectAllTodos = (state) => state.todos.items;
export const selectTodosStatus = (state) => state.todos.status;
export const selectTodosError = (state) => state.todos.error;

export const selectActiveTodos = (state) =>
  selectAllTodos(state).filter(t => !t.completed);
```

---

## 7.2 createSelector() from Reselect

### What is Memoization?

**Memoization** caches the result of a function based on its inputs. If inputs haven't changed, return cached result instead of recalculating.

```javascript
// Without memoization
const selectActiveTodos = (state) => 
  state.todos.filter(todo => !todo.completed);
// Runs filter() every time, even if todos haven't changed

// With memoization
const selectActiveTodos = createSelector(
  [state => state.todos],
  (todos) => todos.filter(todo => !todo.completed)
);
// Only runs filter() when todos array changes
```

### Performance Problem Example

```javascript
// Component
function TodoList() {
  // âŒ Creates new array every render
  const activeTodos = useSelector(state =>
    state.todos.filter(todo => !todo.completed)
  );
  
  // Component re-renders even when todos haven't changed
  // because filter() always returns a new array reference
}

// Even if todos array is the same:
[1, 2, 3].filter(x => x > 0) !== [1, 2, 3].filter(x => x > 0)
// Different references, so React sees them as different
```

### createSelector() Syntax

```javascript
import { createSelector } from '@reduxjs/toolkit';

const selector = createSelector(
  [inputSelector1, inputSelector2, ...],  // Input selectors (dependencies)
  (result1, result2, ...) => {            // Output function
    // Compute and return derived data
  }
);
```

### Basic Example

```javascript
import { createSelector } from '@reduxjs/toolkit';

// Input selectors
const selectTodos = (state) => state.todos;

// Memoized output selector
const selectActiveTodos = createSelector(
  [selectTodos],           // Input: array of todos
  (todos) => {             // Output: filtered todos
    console.log('Computing active todos'); // Only logs when todos change
    return todos.filter(todo => !todo.completed);
  }
);

// Usage
const activeTodos = useSelector(selectActiveTodos);
// First call: "Computing active todos" (calculates)
// Second call: (returns cached result)
// Third call: (returns cached result)
// ... until todos array changes
```

### Multiple Input Selectors

```javascript
const selectTodos = (state) => state.todos;
const selectFilter = (state) => state.filter; // 'all', 'active', 'completed'

const selectFilteredTodos = createSelector(
  [selectTodos, selectFilter],
  (todos, filter) => {
    switch (filter) {
      case 'active':
        return todos.filter(t => !t.completed);
      case 'completed':
        return todos.filter(t => t.completed);
      default:
        return todos;
    }
  }
);
```

### Composition of Selectors

Build complex selectors from simpler ones:

```javascript
// Base selectors
const selectTodos = (state) => state.todos;
const selectUsers = (state) => state.users;

// Derived selector
const selectActiveTodos = createSelector(
  [selectTodos],
  (todos) => todos.filter(t => !t.completed)
);

// Compose with other selectors
const selectActiveTodosWithUsers = createSelector(
  [selectActiveTodos, selectUsers],
  (activeTodos, users) => {
    return activeTodos.map(todo => ({
      ...todo,
      author: users.find(u => u.id === todo.userId)
    }));
  }
);
```

### Inline Input Selectors

You can define input selectors inline:

```javascript
const selectTodoStats = createSelector(
  [
    state => state.todos,              // Inline input selector
    state => state.filter              // Inline input selector
  ],
  (todos, filter) => {
    const total = todos.length;
    const completed = todos.filter(t => t.completed).length;
    const active = total - completed;
    
    return { total, completed, active, filter };
  }
);
```

### Parametric Selectors

Selectors that accept additional arguments:

```javascript
// Factory function that creates a selector
const makeSelectTodoById = () => createSelector(
  [
    state => state.todos,
    (state, todoId) => todoId   // Second parameter
  ],
  (todos, todoId) => todos.find(todo => todo.id === todoId)
);

// Usage - create instance per component
function TodoDetail({ todoId }) {
  const selectTodoById = useMemo(makeSelectTodoById, []);
  const todo = useSelector(state => selectTodoById(state, todoId));
  
  return <div>{todo.text}</div>;
}
```

### Better Parametric Pattern

```javascript
import { createSelector } from '@reduxjs/toolkit';

// Single selector with parameter
const selectTodoById = createSelector(
  [
    state => state.todos,
    (state, todoId) => todoId
  ],
  (todos, todoId) => todos.find(todo => todo.id === todoId)
);

// Usage in component
function TodoDetail({ todoId }) {
  const todo = useSelector(state => selectTodoById(state, todoId));
  return <div>{todo?.text}</div>;
}
```

**Warning:** This pattern creates a new selector instance per call, losing memoization benefits across components.

### Advanced Parametric Pattern: Re-reselect

For per-component memoization, use re-reselect library:

```javascript
import { createCachedSelector } from 're-reselect';

const selectTodoById = createCachedSelector(
  state => state.todos,
  (state, todoId) => todoId,
  (todos, todoId) => todos.find(todo => todo.id === todoId)
)(
  // Cache key resolver
  (state, todoId) => todoId
);

// Each unique todoId gets its own cached result
```

---

## 7.3 Memoization Deep Dive

### How Memoization Works

```javascript
const selectExpensiveComputation = createSelector(
  [selectData],
  (data) => {
    console.log('Computing...');
    return expensiveOperation(data);
  }
);

// Call 1: data = [1, 2, 3]
selectExpensiveComputation(state); // Logs "Computing...", returns result

// Call 2: data = [1, 2, 3] (same reference)
selectExpensiveComputation(state); // Returns cached result (no log)

// Call 3: data = [4, 5, 6] (different reference)
selectExpensiveComputation(state); // Logs "Computing...", returns new result
```

### Cache Size

By default, `createSelector` caches only the **most recent** result:

```javascript
const selector = createSelector([...], (...) => {...});

// Call 1: input A
selector(stateA); // Computes, caches result for A

// Call 2: input B
selector(stateB); // Computes, caches result for B (overwrites A)

// Call 3: input A again
selector(stateA); // Computes again! (cache was overwritten)
```

### Custom Memoization

Use different memoization functions:

```javascript
import { createSelectorCreator, lruMemoize } from 'reselect';

// LRU (Least Recently Used) cache with size 10
const createLRUSelector = createSelectorCreator(
  lruMemoize,
  { maxSize: 10 }
);

const selectTodoById = createLRUSelector(
  [state => state.todos, (state, id) => id],
  (todos, id) => todos.find(t => t.id === id)
);
// Caches results for up to 10 different IDs
```

### Equality Checks

Selectors use strict equality (`===`) by default:

```javascript
const data1 = [1, 2, 3];
const data2 = [1, 2, 3];

console.log(data1 === data2); // false (different references)

// Selector recomputes even if contents are same
const selector = createSelector(
  [state => state.data],
  (data) => data.map(x => x * 2)
);
```

### Custom Equality Function

```javascript
import { createSelectorCreator, defaultMemoize } from 'reselect';
import isEqual from 'lodash/isEqual';

// Deep equality check
const createDeepEqualSelector = createSelectorCreator(
  defaultMemoize,
  isEqual
);

const selector = createDeepEqualSelector(
  [state => state.data],
  (data) => expensiveComputation(data)
);

// Now [1,2,3] equals [1,2,3] even if different references
```

---

## 7.4 Real-World Selector Patterns

### Pattern 1: Filtering and Sorting

```javascript
const selectAllTodos = (state) => state.todos.items;
const selectSortBy = (state) => state.todos.sortBy;
const selectFilterBy = (state) => state.todos.filterBy;

const selectVisibleTodos = createSelector(
  [selectAllTodos, selectSortBy, selectFilterBy],
  (todos, sortBy, filterBy) => {
    // Filter
    let filtered = todos;
    if (filterBy === 'active') {
      filtered = todos.filter(t => !t.completed);
    } else if (filterBy === 'completed') {
      filtered = todos.filter(t => t.completed);
    }
    
    // Sort
    const sorted = [...filtered].sort((a, b) => {
      switch (sortBy) {
        case 'date':
          return new Date(b.createdAt) - new Date(a.createdAt);
        case 'priority':
          return b.priority - a.priority;
        case 'alphabetical':
          return a.text.localeCompare(b.text);
        default:
          return 0;
      }
    });
    
    return sorted;
  }
);
```

### Pattern 2: Aggregations and Statistics

```javascript
const selectTodos = (state) => state.todos;

const selectTodoStats = createSelector(
  [selectTodos],
  (todos) => {
    const total = todos.length;
    const completed = todos.filter(t => t.completed).length;
    const active = total - completed;
    const completionRate = total > 0 ? (completed / total) * 100 : 0;
    
    return {
      total,
      completed,
      active,
      completionRate: completionRate.toFixed(1)
    };
  }
);

// Usage
function TodoStats() {
  const stats = useSelector(selectTodoStats);
  
  return (
    <div>
      <p>Total: {stats.total}</p>
      <p>Completed: {stats.completed}</p>
      <p>Active: {stats.active}</p>
      <p>Completion: {stats.completionRate}%</p>
    </div>
  );
}
```

### Pattern 3: Joining Data

```javascript
const selectPosts = (state) => state.posts;
const selectUsers = (state) => state.users;
const selectComments = (state) => state.comments;

// Join posts with their authors
const selectPostsWithAuthors = createSelector(
  [selectPosts, selectUsers],
  (posts, users) => {
    return posts.map(post => ({
      ...post,
      author: users.find(u => u.id === post.authorId)
    }));
  }
);

// Join posts with comments
const selectPostsWithComments = createSelector(
  [selectPostsWithAuthors, selectComments],
  (posts, comments) => {
    return posts.map(post => ({
      ...post,
      comments: comments.filter(c => c.postId === post.id)
    }));
  }
);
```

### Pattern 4: Search and Filtering

```javascript
const selectProducts = (state) => state.products;
const selectSearchTerm = (state) => state.search.term;
const selectFilters = (state) => state.search.filters;

const selectFilteredProducts = createSelector(
  [selectProducts, selectSearchTerm, selectFilters],
  (products, searchTerm, filters) => {
    let filtered = products;
    
    // Search by term
    if (searchTerm) {
      const term = searchTerm.toLowerCase();
      filtered = filtered.filter(p =>
        p.name.toLowerCase().includes(term) ||
        p.description.toLowerCase().includes(term)
      );
    }
    
    // Filter by category
    if (filters.category) {
      filtered = filtered.filter(p => p.category === filters.category);
    }
    
    // Filter by price range
    if (filters.minPrice !== null) {
      filtered = filtered.filter(p => p.price >= filters.minPrice);
    }
    if (filters.maxPrice !== null) {
      filtered = filtered.filter(p => p.price <= filters.maxPrice);
    }
    
    // Filter by rating
    if (filters.minRating) {
      filtered = filtered.filter(p => p.rating >= filters.minRating);
    }
    
    return filtered;
  }
);
```

### Pattern 5: Pagination

```javascript
const selectAllItems = (state) => state.items;
const selectPage = (state) => state.pagination.page;
const selectPageSize = (state) => state.pagination.pageSize;

const selectPaginatedItems = createSelector(
  [selectAllItems, selectPage, selectPageSize],
  (items, page, pageSize) => {
    const start = (page - 1) * pageSize;
    const end = start + pageSize;
    
    return {
      items: items.slice(start, end),
      total: items.length,
      page,
      pageSize,
      totalPages: Math.ceil(items.length / pageSize),
      hasNext: end < items.length,
      hasPrev: page > 1
    };
  }
);
```

### Pattern 6: Denormalization

```javascript
// Normalized state:
// {
//   users: { byId: { '1': {id: 1, name: 'John'} }, allIds: ['1'] },
//   posts: { byId: { '1': {id: 1, userId: '1', title: '...'} }, allIds: ['1'] }
// }

const selectUserById = (state, userId) => state.users.byId[userId];
const selectPostsByUserId = createSelector(
  [state => state.posts.byId, (state, userId) => userId],
  (postsById, userId) => {
    return Object.values(postsById).filter(post => post.userId === userId);
  }
);

// Denormalize: user with their posts
const selectUserWithPosts = createSelector(
  [selectUserById, selectPostsByUserId],
  (user, posts) => ({
    ...user,
    posts
  })
);
```

### Pattern 7: Complex Calculations

```javascript
const selectCartItems = (state) => state.cart.items;
const selectProducts = (state) => state.products;
const selectTaxRate = (state) => state.config.taxRate;
const selectShippingCost = (state) => state.config.shippingCost;
const selectDiscountCode = (state) => state.cart.discountCode;

const selectCartTotal = createSelector(
  [selectCartItems, selectProducts, selectTaxRate, selectShippingCost, selectDiscountCode],
  (cartItems, products, taxRate, shippingCost, discountCode) => {
    // Calculate subtotal
    const subtotal = cartItems.reduce((total, item) => {
      const product = products.find(p => p.id === item.productId);
      return total + (product.price * item.quantity);
    }, 0);
    
    // Apply discount
    let discount = 0;
    if (discountCode === 'SAVE10') {
      discount = subtotal * 0.1;
    } else if (discountCode === 'SAVE20') {
      discount = subtotal * 0.2;
    }
    
    const afterDiscount = subtotal - discount;
    
    // Calculate tax
    const tax = afterDiscount * taxRate;
    
    // Calculate total
    const total = afterDiscount + tax + shippingCost;
    
    return {
      subtotal: subtotal.toFixed(2),
      discount: discount.toFixed(2),
      tax: tax.toFixed(2),
      shipping: shippingCost.toFixed(2),
      total: total.toFixed(2)
    };
  }
);
```

---

## 7.5 Performance Optimization Tips

### 1. Avoid Inline Selectors

```javascript
// âŒ Bad - Creates new function every render
function TodoList() {
  const activeTodos = useSelector(state =>
    state.todos.filter(t => !t.completed)
  );
}

// âœ… Good - Reusable selector
const selectActiveTodos = createSelector(
  [state => state.todos],
  (todos) => todos.filter(t => !t.completed)
);

function TodoList() {
  const activeTodos = useSelector(selectActiveTodos);
}
```

### 2. Keep Selectors Pure

```javascript
// âŒ Bad - Uses external variable
let filterType = 'active';

const selectFilteredTodos = createSelector(
  [state => state.todos],
  (todos) => todos.filter(t => t.type === filterType)
  // Depends on external variable!
);

// âœ… Good - All inputs from state
const selectFilteredTodos = createSelector(
  [state => state.todos, state => state.filterType],
  (todos, filterType) => todos.filter(t => t.type === filterType)
);
```

### 3. Break Down Complex Selectors

```javascript
// âŒ Bad - One giant selector
const selectEverything = createSelector(
  [state => state],
  (state) => {
    // 100 lines of complex logic
    // Recomputes everything if any state changes
  }
);

// âœ… Good - Break into smaller selectors
const selectUsers = createSelector(...);
const selectPosts = createSelector(...);
const selectComments = createSelector(...);

const selectCombined = createSelector(
  [selectUsers, selectPosts, selectComments],
  (users, posts, comments) => {
    // Combine results
  }
);
```

### 4. Use shallowEqual for Arrays/Objects

```javascript
import { useSelector, shallowEqual } from 'react-redux';

function MyComponent() {
  // âœ… Compare array contents, not reference
  const todos = useSelector(
    state => state.todos,
    shallowEqual
  );
}
```

### 5. Measure Performance

```javascript
const selectExpensive = createSelector(
  [state => state.data],
  (data) => {
    console.time('Expensive Computation');
    const result = expensiveOperation(data);
    console.timeEnd('Expensive Computation');
    return result;
  }
);

// Or use reselect's built-in tools
selectExpensive.recomputations(); // How many times recalculated
selectExpensive.resetRecomputations(); // Reset counter
```

---

## 7.6 Testing Selectors

### Basic Selector Tests

```javascript
// selectors.js
export const selectActiveTodos = createSelector(
  [state => state.todos],
  (todos) => todos.filter(t => !t.completed)
);

// selectors.test.js
import { selectActiveTodos } from './selectors';

describe('selectActiveTodos', () => {
  it('returns only incomplete todos', () => {
    const state = {
      todos: [
        { id: 1, text: 'Todo 1', completed: false },
        { id: 2, text: 'Todo 2', completed: true },
        { id: 3, text: 'Todo 3', completed: false }
      ]
    };
    
    const result = selectActiveTodos(state);
    
    expect(result).toHaveLength(2);
    expect(result[0].id).toBe(1);
    expect(result[1].id).toBe(3);
  });
  
  it('returns empty array when no active todos', () => {
    const state = {
      todos: [
        { id: 1, completed: true }
      ]
    };
    
    const result = selectActiveTodos(state);
    expect(result).toEqual([]);
  });
});
```

### Testing Memoization

```javascript
describe('selectActiveTodos memoization', () => {
  it('returns same reference when input unchanged', () => {
    const state = {
      todos: [
        { id: 1, completed: false }
      ]
    };
    
    const result1 = selectActiveTodos(state);
    const result2 = selectActiveTodos(state);
    
    // Same reference - memoization working
    expect(result1).toBe(result2);
  });
  
  it('recalculates when input changes', () => {
    const state1 = {
      todos: [{ id: 1, completed: false }]
    };
    const state2 = {
      todos: [{ id: 2, completed: false }]
    };
    
    const result1 = selectActiveTodos(state1);
    const result2 = selectActiveTodos(state2);
    
    // Different references - recalculated
    expect(result1).not.toBe(result2);
  });
});
```

### Testing Complex Selectors

```javascript
const selectCartTotal = createSelector(
  [selectCartItems, selectTaxRate],
  (items, taxRate) => {
    const subtotal = items.reduce((sum, item) => sum + item.price, 0);
    const tax = subtotal * taxRate;
    return subtotal + tax;
  }
);

describe('selectCartTotal', () => {
  it('calculates total with tax', () => {
    const state = {
      cart: {
        items: [
          { price: 10 },
          { price: 20 }
        ]
      },
      config: {
        taxRate: 0.1
      }
    };
    
    const total = selectCartTotal(state);
    expect(total).toBe(33); // 30 + 3 tax
  });
});
```

---

## Best Practices Summary

### âœ… Do's

1. **Use createSelector for derived data**
```javascript
const selectFiltered = createSelector([selectData], (data) => filter(data));
```

2. **Co-locate selectors with slices**
```javascript
// todosSlice.js
export const selectTodos = (state) => state.todos;
```

3. **Keep selectors simple and focused**
```javascript
// One responsibility per selector
const selectUsers = (state) => state.users;
const selectActiveUsers = createSelector([selectUsers], (users) => filter(users));
```

4. **Test selectors thoroughly**
```javascript
test('selector returns expected value', () => {
  expect(selector(state)).toEqual(expected);
});
```

5. **Use composition**
```javascript
const selectC = createSelector([selectA, selectB], (a, b) => combine(a, b));
```

### âŒ Don'ts

1. **Don't create new objects in selectors without memoization**
```javascript
// âŒ Bad
const selectData = (state) => ({ user: state.user, posts: state.posts });
```

2. **Don't use external variables**
```javascript
// âŒ Bad
let filter = 'active';
const selectFiltered = createSelector(..., () => applyFilter(filter));
```

3. **Don't over-memoize**
```javascript
// âŒ Unnecessary for simple field access
const selectUserId = createSelector([state => state.user], (user) => user.id);

// âœ… Better
const selectUserId = (state) => state.user.id;
```

---

## Summary

Selectors are essential for Redux performance and maintainability:

| Feature | Benefit |
|---------|---------|
| **Encapsulation** | Hide state structure from components |
| **Reusability** | Share logic across components |
| **Memoization** | Cache expensive computations |
| **Composition** | Build complex selectors from simple ones |
| **Testability** | Easy to test in isolation |

**Key Takeaways:**
1. Use selectors to extract and derive state
2. Use `createSelector` for memoized computation
3. Keep selectors pure and simple
4. Compose selectors for complex logic
5. Test selectors independently
6. Co-locate selectors with slices

Next: Chapter 8 covers normalization with `createEntityAdapter()`! ðŸš€