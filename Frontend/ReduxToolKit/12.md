# Chapter 12: Performance Optimization

## Overview

Performance is critical for production Redux applications. This chapter covers techniques to optimize Redux apps, from preventing unnecessary re-renders to optimizing bundle size and runtime performance.

---

## 12.1 Preventing Unnecessary Re-renders

### Understanding React Re-renders

React components re-render when:
1. State changes (useState, useReducer)
2. Props change
3. Parent component re-renders
4. Context value changes

**With Redux:**
```javascript
function MyComponent() {
  const data = useSelector(state => state.data);
  // Re-renders when state.data reference changes
}
```

### Problem: Reference Equality

```javascript
// ‚ùå Problem: New object every time
function TodoList() {
  const todos = useSelector(state => ({
    items: state.todos,
    count: state.todos.length
  }));
  
  // Component re-renders on EVERY state change
  // because {} !== {} (different references)
}

// ‚úÖ Solution 1: Select primitives separately
function TodoList() {
  const items = useSelector(state => state.todos);
  const count = useSelector(state => state.todos.length);
  // Only re-renders when todos array or length changes
}

// ‚úÖ Solution 2: Use shallowEqual
import { useSelector, shallowEqual } from 'react-redux';

function TodoList() {
  const todos = useSelector(
    state => ({
      items: state.todos,
      count: state.todos.length
    }),
    shallowEqual
  );
  // Compares object properties, not reference
}
```

### shallowEqual Comparison

```javascript
import { shallowEqual } from 'react-redux';

// Without shallowEqual
const obj1 = { a: 1, b: 2 };
const obj2 = { a: 1, b: 2 };
console.log(obj1 === obj2); // false ‚ùå

// With shallowEqual
console.log(shallowEqual(obj1, obj2)); // true ‚úÖ

// Shallow comparison
const obj3 = { a: 1, b: { nested: true } };
const obj4 = { a: 1, b: { nested: true } };
console.log(shallowEqual(obj3, obj4)); // false (b is different reference)
```

### Custom Equality Functions

```javascript
import { useSelector } from 'react-redux';
import isEqual from 'lodash/isEqual';

function MyComponent() {
  const complexData = useSelector(
    state => state.complex,
    isEqual  // Deep equality check
  );
}

// Custom equality function
const customEqual = (a, b) => {
  // Only compare specific fields
  return a.id === b.id && a.name === b.name;
};

function UserProfile() {
  const user = useSelector(
    state => state.user,
    customEqual
  );
}
```

### React.memo for Components

```javascript
import React, { memo } from 'react';

// ‚ùå Without memo: Re-renders when parent re-renders
function TodoItem({ todo, onToggle }) {
  console.log('Rendering TodoItem');
  return (
    <li>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
      />
      {todo.text}
    </li>
  );
}

// ‚úÖ With memo: Only re-renders when props change
const TodoItem = memo(({ todo, onToggle }) => {
  console.log('Rendering TodoItem');
  return (
    <li>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
      />
      {todo.text}
    </li>
  );
});
```

### useCallback for Stable Function References

```javascript
import { useCallback } from 'react';
import { useAppDispatch } from './hooks';
import { todoToggled } from './todosSlice';

// ‚ùå Problem: New function every render
function TodoList() {
  const dispatch = useAppDispatch();
  const todos = useAppSelector(state => state.todos);
  
  // New function created on every render
  const handleToggle = (id) => {
    dispatch(todoToggled(id));
  };
  
  return (
    <ul>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={handleToggle}  // Different reference each time
        />
      ))}
    </ul>
  );
}

// ‚úÖ Solution: useCallback
function TodoList() {
  const dispatch = useAppDispatch();
  const todos = useAppSelector(state => state.todos);
  
  // Stable function reference
  const handleToggle = useCallback(
    (id) => {
      dispatch(todoToggled(id));
    },
    [dispatch]  // Only recreate if dispatch changes (never)
  );
  
  return (
    <ul>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={handleToggle}  // Same reference
        />
      ))}
    </ul>
  );
}
```

### useMemo for Expensive Computations

```javascript
import { useMemo } from 'react';

// ‚ùå Problem: Recalculates every render
function TodoStats() {
  const todos = useAppSelector(state => state.todos);
  
  // Runs on every render
  const stats = {
    total: todos.length,
    completed: todos.filter(t => t.completed).length,
    active: todos.filter(t => !t.completed).length
  };
  
  return <div>Total: {stats.total}</div>;
}

// ‚úÖ Solution: useMemo
function TodoStats() {
  const todos = useAppSelector(state => state.todos);
  
  // Only recalculates when todos change
  const stats = useMemo(() => ({
    total: todos.length,
    completed: todos.filter(t => t.completed).length,
    active: todos.filter(t => !t.completed).length
  }), [todos]);
  
  return <div>Total: {stats.total}</div>;
}

// ‚úÖ Even better: Use memoized selector
const selectTodoStats = createSelector(
  [state => state.todos],
  (todos) => ({
    total: todos.length,
    completed: todos.filter(t => t.completed).length,
    active: todos.filter(t => !t.completed).length
  })
);

function TodoStats() {
  const stats = useAppSelector(selectTodoStats);
  return <div>Total: {stats.total}</div>;
}
```

---

## 12.2 Selector Optimization

### Memoized Selectors with createSelector

```javascript
import { createSelector } from '@reduxjs/toolkit';

// ‚ùå Problem: Creates new array every time
const selectActiveTodos = (state) => 
  state.todos.filter(todo => !todo.completed);

// Component re-renders even if todos haven't changed
// because filter() returns new array

// ‚úÖ Solution: Memoized selector
const selectActiveTodos = createSelector(
  [state => state.todos],
  (todos) => todos.filter(todo => !todo.completed)
);

// Only recalculates when todos array reference changes
```

### Avoiding Inline Selectors

```javascript
// ‚ùå Bad: Inline selector
function TodoList() {
  const todos = useSelector(state => 
    state.todos.filter(t => !t.completed)
  );
}

// ‚úÖ Good: Extracted selector
const selectActiveTodos = createSelector(
  [state => state.todos],
  (todos) => todos.filter(t => !t.completed)
);

function TodoList() {
  const todos = useSelector(selectActiveTodos);
}
```

### Selector Recomputation Tracking

```javascript
import { createSelector } from '@reduxjs/toolkit';

const selectExpensiveData = createSelector(
  [state => state.data],
  (data) => {
    console.log('Expensive computation running');
    return expensiveTransform(data);
  }
);

// Check how many times selector ran
console.log(selectExpensiveData.recomputations());

// Reset counter
selectExpensiveData.resetRecomputations();
```

### Multiple Selector Instances

```javascript
// Problem: Selector with parameters
const selectTodoById = createSelector(
  [
    state => state.todos,
    (state, todoId) => todoId
  ],
  (todos, todoId) => todos.find(t => t.id === todoId)
);

// Each component creates its own selector instance
function TodoDetail({ todoId }) {
  const todo = useSelector(state => selectTodoById(state, todoId));
  // Creates new selector for each todoId
}

// Solution: re-reselect library
import { createCachedSelector } from 're-reselect';

const selectTodoById = createCachedSelector(
  state => state.todos,
  (state, todoId) => todoId,
  (todos, todoId) => todos.find(t => t.id === todoId)
)(
  (state, todoId) => todoId  // Cache key
);

// Now memoization works per todoId
```

---

## 12.3 Code Splitting and Lazy Loading

### Dynamic Reducer Injection

```javascript
// store.js
import { configureStore, combineReducers } from '@reduxjs/toolkit';

const staticReducers = {
  app: appReducer
};

export const store = configureStore({
  reducer: createReducer()
});

function createReducer(asyncReducers = {}) {
  return combineReducers({
    ...staticReducers,
    ...asyncReducers
  });
}

// Add reducer dynamically
store.asyncReducers = {};

export function injectReducer(key, reducer) {
  if (store.asyncReducers[key]) {
    return; // Already injected
  }
  
  store.asyncReducers[key] = reducer;
  store.replaceReducer(createReducer(store.asyncReducers));
}

// Usage in lazy-loaded component
import { injectReducer } from './store';
import userReducer from './userSlice';

function UserPage() {
  useEffect(() => {
    injectReducer('users', userReducer);
  }, []);
  
  return <div>User Page</div>;
}
```

### Lazy Loading Components

```javascript
import { lazy, Suspense } from 'react';

// Lazy load component
const Dashboard = lazy(() => import('./Dashboard'));
const Settings = lazy(() => import('./Settings'));

function App() {
  return (
    <Routes>
      <Route
        path="/dashboard"
        element={
          <Suspense fallback={<div>Loading...</div>}>
            <Dashboard />
          </Suspense>
        }
      />
      <Route
        path="/settings"
        element={
          <Suspense fallback={<div>Loading...</div>}>
            <Settings />
          </Suspense>
        }
      />
    </Routes>
  );
}
```

### RTK Query Code Splitting

```javascript
// Base API
export const baseApi = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  tagTypes: ['Posts', 'Users'],
  endpoints: () => ({})
});

// Inject endpoints in separate files
// postsApi.js
import { baseApi } from './baseApi';

export const postsApi = baseApi.injectEndpoints({
  endpoints: (builder) => ({
    getPosts: builder.query({
      query: () => '/posts'
    })
  })
});

// usersApi.js
import { baseApi } from './baseApi';

export const usersApi = baseApi.injectEndpoints({
  endpoints: (builder) => ({
    getUsers: builder.query({
      query: () => '/users'
    })
  })
});
```

---

## 12.4 Batching Actions

### React 18 Automatic Batching

```javascript
// React 18 automatically batches these
function handleClick() {
  dispatch(action1());
  dispatch(action2());
  dispatch(action3());
  // Only one re-render!
}

// Even in async code
async function handleAsync() {
  const data = await fetchData();
  dispatch(action1(data));
  dispatch(action2());
  // Still only one re-render!
}
```

### Manual Batching (React 17)

```javascript
import { batch } from 'react-redux';

// React 17: Manual batching needed
function handleClick() {
  batch(() => {
    dispatch(action1());
    dispatch(action2());
    dispatch(action3());
  });
  // One re-render
}
```

### Action Batching Middleware

```javascript
const batchMiddleware = (store) => (next) => (action) => {
  if (action.type === 'BATCH_ACTIONS') {
    action.payload.forEach(a => store.dispatch(a));
    return;
  }
  return next(action);
};

// Usage
dispatch({
  type: 'BATCH_ACTIONS',
  payload: [
    { type: 'ACTION_1' },
    { type: 'ACTION_2' },
    { type: 'ACTION_3' }
  ]
});
```

---

## 12.5 Immer Performance

### Immer Overhead

```javascript
// Immer adds small overhead for "mutable" syntax
const slice = createSlice({
  name: 'data',
  initialState: { items: [] },
  reducers: {
    // Uses Immer - small overhead
    itemAdded: (state, action) => {
      state.items.push(action.payload);
    }
  }
});
```

### When to Return New State

```javascript
const slice = createSlice({
  name: 'data',
  initialState: { items: [] },
  reducers: {
    // ‚úÖ Good: Simple mutation
    itemAdded: (state, action) => {
      state.items.push(action.payload);
    },
    
    // ‚úÖ Good: Return new state for complete replacement
    itemsReplaced: (state, action) => {
      return { items: action.payload };
    },
    
    // ‚ö†Ô∏è Less efficient: Don't mix
    itemUpdated: (state, action) => {
      state.items[0].name = 'test';
      return { ...state }; // Unnecessary
    }
  }
});
```

### Freezing State in Development

```javascript
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      // Enabled by default in dev
      immutableCheck: {
        warnAfter: 128  // Warn if check takes > 128ms
      },
      serializableCheck: {
        warnAfter: 32
      }
    })
});
```

---

## 12.6 DevTools in Production

### Disabling DevTools

```javascript
const store = configureStore({
  reducer: rootReducer,
  devTools: process.env.NODE_ENV !== 'production'
});
```

### Selective DevTools Configuration

```javascript
const store = configureStore({
  reducer: rootReducer,
  devTools: process.env.NODE_ENV !== 'production' && {
    // Limit action history
    maxAge: 50,
    
    // Trace actions
    trace: true,
    traceLimit: 25,
    
    // Sanitize data
    actionSanitizer: (action) => {
      if (action.type === 'users/login') {
        return {
          ...action,
          payload: '<<REDACTED>>'
        };
      }
      return action;
    },
    
    stateSanitizer: (state) => ({
      ...state,
      auth: {
        ...state.auth,
        token: state.auth.token ? '<<TOKEN>>' : null
      }
    })
  }
});
```

---

## 12.7 Bundle Size Optimization

### Analyzing Bundle Size

```bash
# Create React App
npm run build
npx source-map-explorer 'build/static/js/*.js'

# Vite
npm run build
npx vite-bundle-visualizer
```

### Import Only What You Need

```javascript
// ‚ùå Bad: Imports entire library
import _ from 'lodash';

// ‚úÖ Good: Import specific functions
import debounce from 'lodash/debounce';
import isEqual from 'lodash/isEqual';
```

### Tree Shaking

```javascript
// RTK automatically tree-shakes unused code

// ‚ùå Don't do this (imports everything)
import * as RTK from '@reduxjs/toolkit';

// ‚úÖ Do this (tree-shakeable)
import { configureStore, createSlice } from '@reduxjs/toolkit';
```

### Lazy Load Heavy Dependencies

```javascript
// Lazy load chart library
function ChartComponent({ data }) {
  const [Chart, setChart] = useState(null);
  
  useEffect(() => {
    import('chart.js').then(module => {
      setChart(() => module.Chart);
    });
  }, []);
  
  if (!Chart) return <div>Loading chart...</div>;
  
  return <Chart data={data} />;
}
```

---

## 12.8 Runtime Performance

### Profiling with React DevTools

```javascript
// Wrap app with Profiler
import { Profiler } from 'react';

function onRenderCallback(
  id,
  phase,
  actualDuration,
  baseDuration,
  startTime,
  commitTime
) {
  console.log(`${id} took ${actualDuration}ms to render`);
}

<Profiler id="App" onRender={onRenderCallback}>
  <App />
</Profiler>
```

### Measuring Selector Performance

```javascript
const selectExpensiveData = createSelector(
  [state => state.data],
  (data) => {
    const start = performance.now();
    const result = expensiveOperation(data);
    const end = performance.now();
    
    console.log(`Selector took ${end - start}ms`);
    return result;
  }
);
```

### Virtualization for Long Lists

```javascript
import { FixedSizeList } from 'react-window';

function TodoList() {
  const todos = useAppSelector(selectTodos);
  
  // Only render visible items
  return (
    <FixedSizeList
      height={600}
      itemCount={todos.length}
      itemSize={50}
      width="100%"
    >
      {({ index, style }) => (
        <div style={style}>
          <TodoItem todo={todos[index]} />
        </div>
      )}
    </FixedSizeList>
  );
}
```

### Debouncing Expensive Operations

```javascript
import { debounce } from 'lodash';

function SearchComponent() {
  const dispatch = useAppDispatch();
  
  // Debounce search
  const debouncedSearch = useMemo(
    () => debounce((term) => {
      dispatch(searchProducts(term));
    }, 300),
    [dispatch]
  );
  
  const handleChange = (e) => {
    debouncedSearch(e.target.value);
  };
  
  return <input onChange={handleChange} />;
}
```

---

## 12.9 Memory Management

### Cleaning Up Subscriptions

```javascript
function DataFetcher() {
  const dispatch = useAppDispatch();
  
  useEffect(() => {
    // Start polling
    const intervalId = setInterval(() => {
      dispatch(fetchData());
    }, 5000);
    
    // Clean up on unmount
    return () => {
      clearInterval(intervalId);
    };
  }, [dispatch]);
  
  return <div>Data</div>;
}
```

### Canceling Async Thunks

```javascript
function SearchResults({ query }) {
  const dispatch = useAppDispatch();
  
  useEffect(() => {
    // Dispatch thunk
    const promise = dispatch(searchAPI(query));
    
    // Cancel on unmount or query change
    return () => {
      promise.abort();
    };
  }, [query, dispatch]);
}
```

### Clearing Stale Data

```javascript
const dataSlice = createSlice({
  name: 'data',
  initialState: { items: [], cache: {} },
  reducers: {
    dataCached: (state, action) => {
      const { key, data } = action.payload;
      state.cache[key] = {
        data,
        timestamp: Date.now()
      };
    },
    staleDataCleared: (state) => {
      const now = Date.now();
      const maxAge = 5 * 60 * 1000; // 5 minutes
      
      // Remove stale entries
      Object.keys(state.cache).forEach(key => {
        if (now - state.cache[key].timestamp > maxAge) {
          delete state.cache[key];
        }
      });
    }
  }
});
```

---

## 12.10 Real-World Optimization Example

```typescript
// Optimized Todo App
import { createSelector } from '@reduxjs/toolkit';
import { memo, useCallback } from 'react';

// Memoized selectors
const selectTodos = (state: RootState) => state.todos.items;
const selectFilter = (state: RootState) => state.todos.filter;

const selectFilteredTodos = createSelector(
  [selectTodos, selectFilter],
  (todos, filter) => {
    switch (filter) {
      case 'active':
        return todos.filter(t => !t.completed);
      case 'completed':
        return todos.filter(t => t.completed);
      default:
        return todos;
    }
  }
);

// Memoized component
const TodoItem = memo<{ todo: Todo; onToggle: (id: string) => void }>(
  ({ todo, onToggle }) => {
    return (
      <li>
        <input
          type="checkbox"
          checked={todo.completed}
          onChange={() => onToggle(todo.id)}
        />
        {todo.text}
      </li>
    );
  }
);

// Optimized list
function TodoList() {
  const dispatch = useAppDispatch();
  const todos = useAppSelector(selectFilteredTodos);
  
  // Stable callback
  const handleToggle = useCallback(
    (id: string) => {
      dispatch(todoToggled(id));
    },
    [dispatch]
  );
  
  return (
    <ul>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={handleToggle}
        />
      ))}
    </ul>
  );
}
```

---

## Performance Checklist

### ‚úÖ Component Optimization

- [ ] Use `React.memo` for pure components
- [ ] Use `useCallback` for stable function references
- [ ] Use `useMemo` for expensive computations
- [ ] Avoid inline object/array creation in JSX
- [ ] Use `shallowEqual` for object selectors

### ‚úÖ Selector Optimization

- [ ] Use `createSelector` for derived data
- [ ] Avoid inline selectors
- [ ] Select only needed data
- [ ] Track selector recomputations in dev

### ‚úÖ Code Splitting

- [ ] Lazy load routes
- [ ] Inject reducers dynamically
- [ ] Split RTK Query endpoints
- [ ] Lazy load heavy dependencies

### ‚úÖ Bundle Optimization

- [ ] Analyze bundle size
- [ ] Import only needed functions
- [ ] Enable tree shaking
- [ ] Minimize DevTools in production

### ‚úÖ Runtime Performance

- [ ] Virtualize long lists
- [ ] Debounce expensive operations
- [ ] Profile with React DevTools
- [ ] Monitor selector performance

### ‚úÖ Memory Management

- [ ] Clean up subscriptions
- [ ] Cancel async thunks
- [ ] Clear stale cache data
- [ ] Avoid memory leaks

---

## Best Practices

### ‚úÖ Do's

1. **Use memoized selectors**
```javascript
const selector = createSelector([...], (...) => {...})
```

2. **Batch updates in React 18**
```javascript
// Automatic batching
dispatch(action1());
dispatch(action2());
```

3. **Profile before optimizing**
```javascript
// Measure actual performance
console.time('operation');
// ... code
console.timeEnd('operation');
```

4. **Virtualize long lists**
```javascript
<FixedSizeList itemCount={1000} />
```

5. **Code split heavy features**
```javascript
const Dashboard = lazy(() => import('./Dashboard'));
```

### ‚ùå Don'ts

1. **Don't create objects in selectors**
```javascript
// ‚ùå Bad
state => ({ todos: state.todos, count: state.todos.length })
```

2. **Don't optimize prematurely**
```javascript
// ‚ùå Unnecessary for 10 items
useMemo(() => items.map(...), [items])
```

3. **Don't skip profiling**
```javascript
// ‚ùå Guessing what's slow
// ‚úÖ Use React DevTools Profiler
```

---

## Summary

Performance optimization in Redux:

| Technique | Benefit |
|-----------|---------|
| **Memoized selectors** | Prevent unnecessary recalculations |
| **React.memo** | Prevent unnecessary re-renders |
| **useCallback** | Stable function references |
| **Code splitting** | Smaller initial bundle |
| **Virtualization** | Handle large lists |

**Key Takeaways:**
1. Measure before optimizing
2. Use memoized selectors for derived data
3. Prevent unnecessary re-renders with memo/useCallback
4. Code split for better load times
5. Virtualize long lists
6. Profile regularly with DevTools

Next: Chapter 13 covers Testing! üöÄ