# Chapter 6: React-Redux Integration

## Overview

React-Redux is the official React bindings library for Redux. It provides hooks and components that allow React components to interact with the Redux store seamlessly. This chapter covers everything you need to know about connecting React to Redux.

---

## 6.1 Provider Setup

### What is the Provider?

The `Provider` component makes the Redux store available to all components in your React app. It uses React Context under the hood.

### Basic Setup

```javascript
// index.js or main.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import { store } from './app/store';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));

root.render(
  <Provider store={store}>
    <App />
  </Provider>
);
```

**Flow:**

```
Provider (store prop)
    ‚Üì
Makes store available via Context
    ‚Üì
Any child component can access store
    ‚Üì
Using useSelector and useDispatch
```

### Provider Props

```javascript
<Provider store={store}>
  {/* All components here can access store */}
  <App />
</Provider>
```

The `Provider` requires only one prop:
- **store**: Your Redux store instance

### Multiple Providers (Rare)

You typically need only one Provider at the root. Multiple stores/providers is an anti-pattern:

```javascript
// ‚ùå Avoid this - Multiple stores
<Provider store={store1}>
  <PartOfApp />
</Provider>
<Provider store={store2}>
  <OtherPartOfApp />
</Provider>

// ‚úÖ Better - One store with combined reducers
<Provider store={singleStore}>
  <App />
</Provider>
```

### Store Accessibility

Once wrapped with Provider, any component can access the store:

```
<Provider store={store}>
  <App>                          ‚úÖ Can access
    <Header>                     ‚úÖ Can access
      <UserMenu>                 ‚úÖ Can access
        <UserProfile />          ‚úÖ Can access
      </UserMenu>
    </Header>
    <Main>                       ‚úÖ Can access
      <Dashboard />              ‚úÖ Can access
    </Main>
  </App>
</Provider>
```

### TypeScript Provider Setup

```typescript
// store.ts
import { configureStore } from '@reduxjs/toolkit';
import rootReducer from './rootReducer';

export const store = configureStore({
  reducer: rootReducer
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// index.tsx
import { Provider } from 'react-redux';
import { store } from './store';

root.render(
  <Provider store={store}>
    <App />
  </Provider>
);
```

---

## 6.2 useSelector Hook

### What is useSelector?

`useSelector` is a hook that lets you extract data from the Redux store state. It's the modern replacement for `mapStateToProps` (from the old `connect` API).

### Basic Usage

```javascript
import { useSelector } from 'react-redux';

function Counter() {
  // Select a value from state
  const count = useSelector((state) => state.counter.value);
  
  return <div>Count: {count}</div>;
}
```

**How it works:**

```
useSelector(selectorFunction)
         ‚Üì
Runs selector on current state
         ‚Üì
Returns selected value
         ‚Üì
Component subscribes to that value
         ‚Üì
Re-renders when value changes
```

### Selector Functions

A selector is a function that takes state and returns derived data:

```javascript
// Simple selector - returns value directly from state
const selectCount = (state) => state.counter.value;

// Computed selector - calculates derived data
const selectCountDoubled = (state) => state.counter.value * 2;

// Complex selector - filters and transforms
const selectActiveTodos = (state) => 
  state.todos.filter(todo => !todo.completed);

// Usage in component:
const count = useSelector(selectCount);
const doubled = useSelector(selectCountDoubled);
const activeTodos = useSelector(selectActiveTodos);
```

### Multiple Selectors

You can use multiple `useSelector` calls in one component:

```javascript
function UserProfile() {
  const user = useSelector(state => state.user);
  const posts = useSelector(state => state.posts);
  const isLoading = useSelector(state => state.loading);
  
  if (isLoading) return <Spinner />;
  
  return (
    <div>
      <h1>{user.name}</h1>
      <PostList posts={posts} />
    </div>
  );
}
```

### Selector Best Practices

#### **1. Define selectors outside components**

```javascript
// ‚ùå Bad - Creates new function on every render
function TodoList() {
  const todos = useSelector((state) => 
    state.todos.filter(t => !t.completed)
  );
}

// ‚úÖ Good - Reusable selector
const selectActiveTodos = (state) => 
  state.todos.filter(t => !t.completed);

function TodoList() {
  const todos = useSelector(selectActiveTodos);
}
```

#### **2. Keep selectors simple**

```javascript
// ‚úÖ Simple and focused
const selectUser = (state) => state.user;
const selectPosts = (state) => state.posts;

// ‚ùå Too complex
const selectEverything = (state) => ({
  user: state.user,
  posts: state.posts.filter(p => p.userId === state.user.id),
  comments: state.comments.filter(c => 
    state.posts.some(p => p.id === c.postId)
  )
});
```

#### **3. Co-locate selectors with slices**

```javascript
// todosSlice.js
const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: { /* ... */ }
});

// Export selectors alongside actions
export const selectAllTodos = (state) => state.todos;
export const selectActiveTodos = (state) => 
  state.todos.filter(t => !t.completed);
export const selectCompletedTodos = (state) => 
  state.todos.filter(t => t.completed);

export default todosSlice.reducer;
```

### Equality Comparisons

By default, `useSelector` uses **strict reference equality** (`===`) to determine if a component should re-render.

#### **Problem: New References**

```javascript
// ‚ùå Creates new array every time - causes re-render
const incompleteTodos = useSelector(state =>
  state.todos.filter(todo => !todo.completed)
);

// Even if todos haven't changed, filter() creates new array
// New array !== old array, so component re-renders
```

#### **Solution 1: shallowEqual**

```javascript
import { useSelector, shallowEqual } from 'react-redux';

const incompleteTodos = useSelector(
  state => state.todos.filter(todo => !todo.completed),
  shallowEqual // Compare array contents, not reference
);
```

#### **Solution 2: Memoized Selectors (Better)**

```javascript
import { createSelector } from '@reduxjs/toolkit';

// This selector is memoized
const selectIncompleteTodos = createSelector(
  [state => state.todos],
  (todos) => todos.filter(todo => !todo.completed)
);

// Only recalculates when state.todos changes
const incompleteTodos = useSelector(selectIncompleteTodos);
```

We'll cover memoized selectors in depth in Chapter 7.

### Selector Performance

#### **When Components Re-render**

```javascript
// Component re-renders when:
const value = useSelector(state => state.counter.value);
// 1. state.counter.value changes

const user = useSelector(state => state.user);
// 2. state.user reference changes

const todos = useSelector(state => state.todos);
// 3. state.todos array reference changes (even if contents same)
```

#### **Optimizing Selectors**

```javascript
// ‚ùå BAD - Always creates new object
const data = useSelector(state => ({
  user: state.user,
  posts: state.posts
}));
// Component re-renders on EVERY state change

// ‚úÖ GOOD - Select primitives separately
const user = useSelector(state => state.user);
const posts = useSelector(state => state.posts);
// Component only re-renders when user or posts change
```

### TypeScript with useSelector

```typescript
import { useSelector } from 'react-redux';
import { RootState } from './store';

function MyComponent() {
  // TypeScript knows the state type
  const count = useSelector((state: RootState) => state.counter.value);
  //                                    ‚Üë
  //                           Annotate state type
  
  return <div>{count}</div>;
}

// Better: Use typed hook (see Section 6.4)
import { useAppSelector } from './hooks';

function MyComponent() {
  // No need to annotate - type inferred
  const count = useAppSelector(state => state.counter.value);
}
```

---

## 6.3 useDispatch Hook

### What is useDispatch?

`useDispatch` returns a reference to the `dispatch` function from the Redux store. You use it to dispatch actions.

### Basic Usage

```javascript
import { useDispatch } from 'react-redux';
import { increment, decrement } from './counterSlice';

function Counter() {
  const dispatch = useDispatch();
  
  return (
    <div>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
    </div>
  );
}
```

### Dispatching Actions

#### **Action Creators**

```javascript
import { useDispatch } from 'react-redux';
import { addTodo } from './todosSlice';

function TodoForm() {
  const dispatch = useDispatch();
  const [text, setText] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Dispatch action creator
    dispatch(addTodo(text));
    
    setText('');
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button type="submit">Add</button>
    </form>
  );
}
```

#### **Plain Action Objects** (Rare)

```javascript
const dispatch = useDispatch();

// Usually you use action creators, but you can dispatch objects
dispatch({
  type: 'todos/addTodo',
  payload: { id: 1, text: 'Learn Redux' }
});
```

### Dispatching Thunks

```javascript
import { useDispatch } from 'react-redux';
import { fetchUsers } from './usersSlice';

function UsersList() {
  const dispatch = useDispatch();
  
  useEffect(() => {
    // Dispatch async thunk
    dispatch(fetchUsers());
  }, [dispatch]);
  
  // Component renders...
}
```

### Callback Handlers

```javascript
function TodoItem({ todo }) {
  const dispatch = useDispatch();
  
  // Create handler function
  const handleToggle = () => {
    dispatch(toggleTodo(todo.id));
  };
  
  const handleDelete = () => {
    dispatch(deleteTodo(todo.id));
  };
  
  return (
    <div>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={handleToggle}
      />
      <span>{todo.text}</span>
      <button onClick={handleDelete}>Delete</button>
    </div>
  );
}
```

### Extracting Dispatch Logic

For complex logic, extract into separate functions:

```javascript
function useUserActions() {
  const dispatch = useDispatch();
  
  return {
    login: (credentials) => dispatch(loginUser(credentials)),
    logout: () => dispatch(logoutUser()),
    updateProfile: (data) => dispatch(updateUserProfile(data))
  };
}

// Usage:
function UserProfile() {
  const { login, logout, updateProfile } = useUserActions();
  
  return (
    <div>
      <button onClick={logout}>Logout</button>
      {/* ... */}
    </div>
  );
}
```

### Dispatch in useEffect

Common pattern for fetching data on mount:

```javascript
function PostsList() {
  const dispatch = useDispatch();
  const posts = useSelector(state => state.posts.data);
  const status = useSelector(state => state.posts.status);
  
  useEffect(() => {
    if (status === 'idle') {
      dispatch(fetchPosts());
    }
  }, [status, dispatch]);
  
  // Render posts...
}
```

**‚ö†Ô∏è Include dispatch in dependency array:**

```javascript
// ‚úÖ Correct
useEffect(() => {
  dispatch(fetchData());
}, [dispatch]); // Include dispatch

// ‚ùå Wrong - ESLint will warn
useEffect(() => {
  dispatch(fetchData());
}, []); // Missing dispatch dependency
```

Though `dispatch` is stable and won't change, include it to satisfy ESLint rules.

### TypeScript with useDispatch

```typescript
import { useDispatch } from 'react-redux';
import { AppDispatch } from './store';

function MyComponent() {
  // Annotate dispatch type
  const dispatch = useDispatch<AppDispatch>();
  
  // TypeScript now knows about thunks
  dispatch(fetchUsers()); // ‚úÖ Works
}

// Better: Use typed hook (see Section 6.4)
import { useAppDispatch } from './hooks';

function MyComponent() {
  const dispatch = useAppDispatch(); // Type inferred
}
```

---

## 6.4 Custom Hooks Pattern

### Why Custom Hooks?

Create typed versions of `useSelector` and `useDispatch` for TypeScript:

1. Avoid repeating type annotations
2. Ensure type safety across app
3. Simplify component code

### Creating Typed Hooks

```typescript
// app/hooks.ts
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
import type { RootState, AppDispatch } from './store';

// Typed useDispatch hook
export const useAppDispatch = () => useDispatch<AppDispatch>();

// Typed useSelector hook
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
```

### Using Typed Hooks

```typescript
// ‚ùå Before: Manual type annotations
import { useDispatch, useSelector } from 'react-redux';
import type { RootState, AppDispatch } from './store';

function MyComponent() {
  const dispatch = useDispatch<AppDispatch>();
  const count = useSelector((state: RootState) => state.counter.value);
}

// ‚úÖ After: Clean and typed
import { useAppDispatch, useAppSelector } from './app/hooks';

function MyComponent() {
  const dispatch = useAppDispatch(); // Type inferred!
  const count = useAppSelector(state => state.counter.value); // Type inferred!
}
```

### Custom Domain Hooks

Create hooks for specific features:

```typescript
// features/todos/hooks.ts
import { useAppSelector, useAppDispatch } from '../../app/hooks';
import { 
  selectAllTodos, 
  selectActiveTodos,
  selectCompletedTodos,
  addTodo,
  toggleTodo,
  deleteTodo
} from './todosSlice';

export function useTodos() {
  const allTodos = useAppSelector(selectAllTodos);
  const activeTodos = useAppSelector(selectActiveTodos);
  const completedTodos = useAppSelector(selectCompletedTodos);
  
  return {
    allTodos,
    activeTodos,
    completedTodos
  };
}

export function useTodoActions() {
  const dispatch = useAppDispatch();
  
  return {
    addTodo: (text: string) => dispatch(addTodo(text)),
    toggleTodo: (id: number) => dispatch(toggleTodo(id)),
    deleteTodo: (id: number) => dispatch(deleteTodo(id))
  };
}

// Usage in component:
function TodoApp() {
  const { allTodos, activeTodos } = useTodos();
  const { addTodo, toggleTodo } = useTodoActions();
  
  return (
    <div>
      <button onClick={() => addTodo('New todo')}>Add</button>
      {/* ... */}
    </div>
  );
}
```

### Composite Hooks

Combine state and actions:

```typescript
export function useAuth() {
  const user = useAppSelector(state => state.auth.user);
  const isAuthenticated = useAppSelector(state => !!state.auth.token);
  const status = useAppSelector(state => state.auth.status);
  const dispatch = useAppDispatch();
  
  return {
    // State
    user,
    isAuthenticated,
    isLoading: status === 'loading',
    
    // Actions
    login: (credentials) => dispatch(loginUser(credentials)),
    logout: () => dispatch(logoutUser()),
    updateProfile: (data) => dispatch(updateUserProfile(data))
  };
}

// Usage:
function Header() {
  const { user, isAuthenticated, logout } = useAuth();
  
  if (!isAuthenticated) {
    return <LoginButton />;
  }
  
  return (
    <div>
      <span>Welcome, {user.name}</span>
      <button onClick={logout}>Logout</button>
    </div>
  );
}
```

### Async Data Fetching Hook

```typescript
export function useUsers() {
  const dispatch = useAppDispatch();
  const users = useAppSelector(state => state.users.entities);
  const status = useAppSelector(state => state.users.status);
  const error = useAppSelector(state => state.users.error);
  
  useEffect(() => {
    if (status === 'idle') {
      dispatch(fetchUsers());
    }
  }, [status, dispatch]);
  
  return {
    users,
    isLoading: status === 'loading',
    isError: status === 'failed',
    error,
    refetch: () => dispatch(fetchUsers())
  };
}

// Usage:
function UsersList() {
  const { users, isLoading, isError, error, refetch } = useUsers();
  
  if (isLoading) return <Spinner />;
  if (isError) return <Error message={error} onRetry={refetch} />;
  
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

---

## 6.5 Connect API (Legacy)

### What is connect()?

`connect()` is the old way to connect React components to Redux (before hooks). It's still supported but **hooks are preferred** for new code.

### Basic connect() Example

```javascript
import { connect } from 'react-redux';
import { increment, decrement } from './counterSlice';

function Counter({ count, increment, decrement }) {
  return (
    <div>
      <div>Count: {count}</div>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
    </div>
  );
}

// Map state to props
const mapStateToProps = (state) => ({
  count: state.counter.value
});

// Map dispatch to props
const mapDispatchToProps = {
  increment,
  decrement
};

// Connect component
export default connect(mapStateToProps, mapDispatchToProps)(Counter);
```

### Hooks vs connect()

```javascript
// ‚ùå OLD WAY: connect()
const mapStateToProps = (state) => ({
  count: state.counter.value
});

const mapDispatchToProps = {
  increment
};

export default connect(mapStateToProps, mapDispatchToProps)(Counter);

// ‚úÖ NEW WAY: hooks
function Counter() {
  const count = useSelector(state => state.counter.value);
  const dispatch = useDispatch();
  
  return (
    <div>
      <div>Count: {count}</div>
      <button onClick={() => dispatch(increment())}>+</button>
    </div>
  );
}
```

**Why hooks are better:**
- Less boilerplate
- Easier to understand
- Better TypeScript support
- More flexible
- Simpler testing

### When to Use connect()

You might encounter `connect()` when:
- Working with legacy codebases
- Maintaining old components
- Using class components

For new development, **always use hooks**.

### Migration from connect() to hooks

```javascript
// Before: connect()
class TodoList extends React.Component {
  render() {
    const { todos, addTodo } = this.props;
    return (
      <div>
        {todos.map(todo => <div key={todo.id}>{todo.text}</div>)}
        <button onClick={() => addTodo('New')}>Add</button>
      </div>
    );
  }
}

const mapStateToProps = (state) => ({
  todos: state.todos
});

const mapDispatchToProps = {
  addTodo
};

export default connect(mapStateToProps, mapDispatchToProps)(TodoList);

// After: hooks
function TodoList() {
  const todos = useSelector(state => state.todos);
  const dispatch = useDispatch();
  
  return (
    <div>
      {todos.map(todo => <div key={todo.id}>{todo.text}</div>)}
      <button onClick={() => dispatch(addTodo('New'))}>Add</button>
    </div>
  );
}
```

---

## 6.6 Complete Real-World Example

### Store Setup

```typescript
// app/store.ts
import { configureStore } from '@reduxjs/toolkit';
import authReducer from '../features/auth/authSlice';
import todosReducer from '../features/todos/todosSlice';
import usersReducer from '../features/users/usersSlice';

export const store = configureStore({
  reducer: {
    auth: authReducer,
    todos: todosReducer,
    users: usersReducer
  }
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

### Typed Hooks

```typescript
// app/hooks.ts
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
import type { RootState, AppDispatch } from './store';

export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
```

### Feature Slice

```typescript
// features/todos/todosSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';

interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

interface TodosState {
  items: Todo[];
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

export const fetchTodos = createAsyncThunk(
  'todos/fetchAll',
  async () => {
    const response = await fetch('/api/todos');
    return response.json();
  }
);

const todosSlice = createSlice({
  name: 'todos',
  initialState: {
    items: [],
    status: 'idle',
    error: null
  } as TodosState,
  reducers: {
    todoAdded: (state, action: PayloadAction<Todo>) => {
      state.items.push(action.payload);
    },
    todoToggled: (state, action: PayloadAction<number>) => {
      const todo = state.items.find(t => t.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchTodos.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchTodos.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.items = action.payload;
      })
      .addCase(fetchTodos.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message || 'Failed to fetch';
      });
  }
});

export const { todoAdded, todoToggled } = todosSlice.actions;
export default todosSlice.reducer;

// Selectors
export const selectAllTodos = (state: RootState) => state.todos.items;
export const selectTodosStatus = (state: RootState) => state.todos.status;
```

### Custom Hook

```typescript
// features/todos/useTodos.ts
import { useEffect } from 'react';
import { useAppDispatch, useAppSelector } from '../../app/hooks';
import {
  fetchTodos,
  todoAdded,
  todoToggled,
  selectAllTodos,
  selectTodosStatus
} from './todosSlice';

export function useTodos() {
  const dispatch = useAppDispatch();
  const todos = useAppSelector(selectAllTodos);
  const status = useAppSelector(selectTodosStatus);
  
  useEffect(() => {
    if (status === 'idle') {
      dispatch(fetchTodos());
    }
  }, [status, dispatch]);
  
  return {
    todos,
    isLoading: status === 'loading',
    addTodo: (text: string) => {
      const todo = {
        id: Date.now(),
        text,
        completed: false
      };
      dispatch(todoAdded(todo));
    },
    toggleTodo: (id: number) => {
      dispatch(todoToggled(id));
    }
  };
}
```

### Component

```typescript
// features/todos/TodoList.tsx
import React, { useState } from 'react';
import { useTodos } from './useTodos';

export function TodoList() {
  const { todos, isLoading, addTodo, toggleTodo } = useTodos();
  const [text, setText] = useState('');
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (text.trim()) {
      addTodo(text);
      setText('');
    }
  };
  
  if (isLoading) {
    return <div>Loading todos...</div>;
  }
  
  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input
          value={text}
          onChange={(e) => setText(e.target.value)}
          placeholder="Add a todo"
        />
        <button type="submit">Add</button>
      </form>
      
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            />
            <span style={{ 
              textDecoration: todo.completed ? 'line-through' : 'none' 
            }}>
              {todo.text}
            </span>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### Root App

```typescript
// index.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import { store } from './app/store';
import { TodoList } from './features/todos/TodoList';

const root = ReactDOM.createRoot(document.getElementById('root')!);

root.render(
  <React.StrictMode>
    <Provider store={store}>
      <TodoList />
    </Provider>
  </React.StrictMode>
);
```

---

## Best Practices

### ‚úÖ Do's

1. **Use hooks, not connect()**
```typescript
// ‚úÖ Modern
const todos = useSelector(selectTodos);
const dispatch = useDispatch();
```

2. **Create typed hooks**
```typescript
// hooks.ts
export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
```

3. **Co-locate selectors with slices**
```typescript
// todosSlice.ts
export const selectAllTodos = (state) => state.todos;
```

4. **Extract complex logic into custom hooks**
```typescript
export function useTodos() {
  const todos = useAppSelector(selectAllTodos);
  const dispatch = useAppDispatch();
  // ...logic
  return { todos, addTodo, toggleTodo };
}
```

5. **Include dispatch in useEffect dependencies**
```typescript
useEffect(() => {
  dispatch(fetchData());
}, [dispatch]); // Include dispatch
```

### ‚ùå Don'ts

1. **Don't select entire state object**
```typescript
// ‚ùå Bad - re-renders on any state change
const state = useSelector(state => state);

// ‚úÖ Good - only re-renders when todos change
const todos = useSelector(state => state.todos);
```

2. **Don't create new objects in selectors**
```typescript
// ‚ùå Bad - new object every time
const data = useSelector(state => ({
  user: state.user,
  posts: state.posts
}));

// ‚úÖ Good - separate selectors
const user = useSelector(state => state.user);
const posts = useSelector(state => state.posts);
```

3. **Don't forget Provider**
```typescript
// ‚ùå Missing Provider
<App />

// ‚úÖ Wrapped with Provider
<Provider store={store}>
  <App />
</Provider>
```

---

## Summary

React-Redux integration essentials:

| API | Purpose |
|-----|---------|
| `Provider` | Makes store available to components |
| `useSelector` | Extracts data from state |
| `useDispatch` | Gets dispatch function |
| Custom hooks | Typed and domain-specific hooks |
| `connect()` | Legacy API (avoid for new code) |

**Key Takeaways:**
1. Wrap app with `Provider`
2. Use `useSelector` to read state
3. Use `useDispatch` to dispatch actions
4. Create typed hooks for TypeScript
5. Extract logic into custom hooks
6. Prefer hooks over `connect()`

This completes the foundational chapters! You now understand:
- Redux fundamentals (Chapter 1)
- Redux Toolkit benefits (Chapter 2)
- Store configuration (Chapter 3)
- Creating slices (Chapter 4)
- Async operations (Chapter 5)
- React integration (Chapter 6)

Ready for more advanced topics! üöÄ