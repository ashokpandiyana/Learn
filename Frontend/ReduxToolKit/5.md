# Chapter 5: Async Operations with createAsyncThunk()

## Overview

`createAsyncThunk()` is Redux Toolkit's solution for handling asynchronous logic like API calls. It automatically generates action types and action creators for the three states of an async request: pending, fulfilled, and rejected.

---

## 5.1 Understanding Thunks

### What is a Thunk?

A **thunk** is a function that returns another function. In Redux, a thunk allows you to write async logic that interacts with the store.

**Simple Example:**

```javascript
// Regular action creator - returns action object
const increment = () => ({ type: 'INCREMENT' });

// Thunk action creator - returns function
const incrementAsync = () => {
  return (dispatch) => {
    setTimeout(() => {
      dispatch({ type: 'INCREMENT' });
    }, 1000);
  };
};

// Usage:
dispatch(increment());      // Dispatches immediately
dispatch(incrementAsync()); // Dispatches after 1 second
```

### Thunk Flow

```
Component
    â†“ dispatch(asyncThunk())
Thunk Middleware intercepts
    â†“
Executes thunk function
    â†“
Makes API call
    â†“
Dispatches success/failure action
    â†“
Reducer updates state
    â†“
Component re-renders
```

### When to Use Thunks

Use thunks for:
- âœ… API calls (fetch, axios)
- âœ… Async operations (setTimeout, file reading)
- âœ… Conditional dispatching
- âœ… Complex synchronous logic
- âœ… Accessing state before dispatching

Don't use for:
- âŒ Simple synchronous updates (use regular reducers)
- âŒ Component-level logic (keep in components)

### Manual Thunk (Before createAsyncThunk)

```javascript
// âŒ Lots of boilerplate
const FETCH_USER_REQUEST = 'FETCH_USER_REQUEST';
const FETCH_USER_SUCCESS = 'FETCH_USER_SUCCESS';
const FETCH_USER_FAILURE = 'FETCH_USER_FAILURE';

const fetchUser = (userId) => {
  return async (dispatch) => {
    // Start loading
    dispatch({ type: FETCH_USER_REQUEST });
    
    try {
      const response = await fetch(`/api/users/${userId}`);
      const data = await response.json();
      
      // Success
      dispatch({
        type: FETCH_USER_SUCCESS,
        payload: data
      });
    } catch (error) {
      // Failure
      dispatch({
        type: FETCH_USER_FAILURE,
        error: error.message
      });
    }
  };
};

// Reducer
function userReducer(state = initialState, action) {
  switch (action.type) {
    case FETCH_USER_REQUEST:
      return { ...state, loading: true, error: null };
    case FETCH_USER_SUCCESS:
      return { ...state, loading: false, user: action.payload };
    case FETCH_USER_FAILURE:
      return { ...state, loading: false, error: action.error };
    default:
      return state;
  }
}
```

---

## 5.2 createAsyncThunk() Basics

### Basic Syntax

```javascript
const asyncThunk = createAsyncThunk(
  'sliceName/actionName',  // Action type prefix
  async (arg, thunkAPI) => {
    // Payload creator function
    const response = await fetch('/api/data');
    return response.json();
  }
);
```

### Simple Example

```javascript
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

// Create the async thunk
export const fetchUserById = createAsyncThunk(
  'users/fetchById',
  async (userId) => {
    const response = await fetch(`/api/users/${userId}`);
    return response.json();
  }
);

// Usage in component:
dispatch(fetchUserById(5));
```

### Automatic Action Types

`createAsyncThunk` automatically generates three action types:

```javascript
const fetchUser = createAsyncThunk('users/fetch', async () => {
  // ...
});

// Auto-generated:
fetchUser.pending     // Action type: 'users/fetch/pending'
fetchUser.fulfilled   // Action type: 'users/fetch/fulfilled'
fetchUser.rejected    // Action type: 'users/fetch/rejected'
```

### Handling States in Slice

```javascript
const usersSlice = createSlice({
  name: 'users',
  initialState: {
    entities: [],
    loading: false,
    error: null
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUserById.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUserById.fulfilled, (state, action) => {
        state.loading = false;
        state.entities.push(action.payload);
      })
      .addCase(fetchUserById.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  }
});
```

### Complete Working Example

```javascript
// usersSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// Async thunk
export const fetchUsers = createAsyncThunk(
  'users/fetchAll',
  async () => {
    const response = await fetch('https://jsonplaceholder.typicode.com/users');
    return response.json();
  }
);

// Slice
const usersSlice = createSlice({
  name: 'users',
  initialState: {
    users: [],
    status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'
    error: null
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.users = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message;
      });
  }
});

export default usersSlice.reducer;

// Component usage:
import { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { fetchUsers } from './usersSlice';

function UsersList() {
  const dispatch = useDispatch();
  const { users, status, error } = useSelector(state => state.users);
  
  useEffect(() => {
    if (status === 'idle') {
      dispatch(fetchUsers());
    }
  }, [status, dispatch]);
  
  if (status === 'loading') return <div>Loading...</div>;
  if (status === 'failed') return <div>Error: {error}</div>;
  
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

---

## 5.3 Handling Async States

### Three States Pattern

Every async operation has three states:

```javascript
const initialState = {
  data: null,
  loading: false,
  error: null
};

// Alternative: Using status string
const initialState = {
  data: null,
  status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'
  error: null
};
```

### Pattern 1: Boolean Loading

```javascript
const slice = createSlice({
  name: 'posts',
  initialState: {
    posts: [],
    loading: false,
    error: null
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchPosts.pending, (state) => {
        state.loading = true;
        state.error = null; // Clear previous errors
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.loading = false;
        state.posts = action.payload;
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  }
});
```

### Pattern 2: Status String (Recommended)

```javascript
const slice = createSlice({
  name: 'posts',
  initialState: {
    posts: [],
    status: 'idle', // More explicit than boolean
    error: null
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchPosts.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.posts = action.payload;
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message;
      });
  }
});

// In component:
const status = useSelector(state => state.posts.status);

if (status === 'loading') return <Spinner />;
if (status === 'failed') return <Error />;
if (status === 'succeeded') return <PostsList />;
```

### Error Handling Best Practices

```javascript
// Good error handling
extraReducers: (builder) => {
  builder.addCase(fetchData.rejected, (state, action) => {
    state.status = 'failed';
    
    // Provide user-friendly error messages
    if (action.error.message === 'Network request failed') {
      state.error = 'Unable to connect. Check your internet connection.';
    } else if (action.error.message?.includes('404')) {
      state.error = 'Data not found.';
    } else {
      state.error = action.error.message || 'Something went wrong';
    }
  });
}
```

### Loading States for Multiple Operations

```javascript
const slice = createSlice({
  name: 'users',
  initialState: {
    users: [],
    fetchStatus: 'idle',
    addStatus: 'idle',
    updateStatus: 'idle',
    error: null
  },
  reducers: {},
  extraReducers: (builder) => {
    // Fetch users
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.fetchStatus = 'loading';
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.fetchStatus = 'succeeded';
        state.users = action.payload;
      })
      
      // Add user
      .addCase(addUser.pending, (state) => {
        state.addStatus = 'loading';
      })
      .addCase(addUser.fulfilled, (state, action) => {
        state.addStatus = 'succeeded';
        state.users.push(action.payload);
      })
      
      // Update user
      .addCase(updateUser.pending, (state) => {
        state.updateStatus = 'loading';
      })
      .addCase(updateUser.fulfilled, (state, action) => {
        state.updateStatus = 'succeeded';
        const index = state.users.findIndex(u => u.id === action.payload.id);
        if (index !== -1) {
          state.users[index] = action.payload;
        }
      });
  }
});
```

---

## 5.4 Advanced Thunk Patterns

### ThunkAPI Object

The second parameter to the payload creator is the `thunkAPI` object:

```javascript
const asyncThunk = createAsyncThunk(
  'type',
  async (arg, thunkAPI) => {
    // thunkAPI provides:
    thunkAPI.dispatch        // Dispatch other actions
    thunkAPI.getState        // Access current state
    thunkAPI.extra           // Extra argument from middleware
    thunkAPI.requestId       // Unique ID for this request
    thunkAPI.signal          // AbortController signal
    thunkAPI.rejectWithValue // Return custom error value
    thunkAPI.fulfillWithValue // Return custom success value
  }
);
```

### Using getState()

Access current state within the thunk:

```javascript
const fetchUserPosts = createAsyncThunk(
  'posts/fetchByUser',
  async (userId, { getState }) => {
    const state = getState();
    
    // Check if already loading
    if (state.posts.loading) {
      return; // Don't fetch again
    }
    
    // Use data from state
    const token = state.auth.token;
    
    const response = await fetch(`/api/users/${userId}/posts`, {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });
    
    return response.json();
  }
);
```

### Using dispatch()

Dispatch other actions from within the thunk:

```javascript
const loginUser = createAsyncThunk(
  'auth/login',
  async (credentials, { dispatch }) => {
    const response = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(credentials)
    });
    
    const data = await response.json();
    
    // Dispatch additional actions
    dispatch(showNotification('Login successful!'));
    dispatch(fetchUserProfile(data.userId));
    
    return data;
  }
);
```

### Using rejectWithValue()

Return custom error payloads:

```javascript
const fetchUser = createAsyncThunk(
  'users/fetch',
  async (userId, { rejectWithValue }) => {
    try {
      const response = await fetch(`/api/users/${userId}`);
      
      if (!response.ok) {
        // Return custom error
        return rejectWithValue({
          status: response.status,
          message: 'Failed to fetch user'
        });
      }
      
      return response.json();
    } catch (error) {
      return rejectWithValue({
        message: error.message
      });
    }
  }
);

// In slice:
extraReducers: (builder) => {
  builder.addCase(fetchUser.rejected, (state, action) => {
    if (action.payload) {
      // Custom error from rejectWithValue
      state.error = action.payload.message;
      state.statusCode = action.payload.status;
    } else {
      // Generic error
      state.error = action.error.message;
    }
  });
}
```

### Typed Errors with TypeScript

```typescript
interface CustomError {
  message: string;
  statusCode: number;
}

const fetchUser = createAsyncThunk<
  User,              // Return type
  number,            // Argument type
  { rejectValue: CustomError }  // ThunkAPI config
>(
  'users/fetch',
  async (userId, { rejectWithValue }) => {
    try {
      const response = await fetch(`/api/users/${userId}`);
      
      if (!response.ok) {
        return rejectWithValue({
          message: 'Failed to fetch',
          statusCode: response.status
        });
      }
      
      return response.json();
    } catch (error) {
      return rejectWithValue({
        message: error.message,
        statusCode: 500
      });
    }
  }
);
```

### Conditional Dispatch

Prevent duplicate requests:

```javascript
const fetchUser = createAsyncThunk(
  'users/fetch',
  async (userId) => {
    const response = await fetch(`/api/users/${userId}`);
    return response.json();
  },
  {
    condition: (userId, { getState }) => {
      const { users } = getState();
      
      // Don't fetch if already loading
      if (users.loading) {
        return false;
      }
      
      // Don't fetch if already have this user
      if (users.entities[userId]) {
        return false;
      }
      
      return true; // Proceed with fetch
    }
  }
);
```

### Request ID Tracking

Track individual requests:

```javascript
const fetchData = createAsyncThunk(
  'data/fetch',
  async (arg, { requestId }) => {
    console.log('Request ID:', requestId);
    // Each call gets unique requestId
    const response = await fetch('/api/data');
    return response.json();
  }
);

// In slice:
const slice = createSlice({
  name: 'data',
  initialState: {
    data: null,
    currentRequestId: null
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchData.pending, (state, action) => {
        state.currentRequestId = action.meta.requestId;
      })
      .addCase(fetchData.fulfilled, (state, action) => {
        // Only update if this is the latest request
        if (state.currentRequestId === action.meta.requestId) {
          state.data = action.payload;
        }
      });
  }
});
```

---

## 5.5 Cancellation and Request Management

### Aborting Requests

Use AbortController to cancel requests:

```javascript
const fetchUser = createAsyncThunk(
  'users/fetch',
  async (userId, { signal }) => {
    const response = await fetch(`/api/users/${userId}`, {
      signal // Pass signal to fetch
    });
    return response.json();
  }
);

// In component:
const dispatch = useDispatch();

useEffect(() => {
  const promise = dispatch(fetchUser(userId));
  
  return () => {
    // Cancel on component unmount
    promise.abort();
  };
}, [userId, dispatch]);
```

### Canceling Previous Requests

```javascript
const searchSlice = createSlice({
  name: 'search',
  initialState: {
    results: [],
    currentRequestId: null
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(searchAPI.pending, (state, action) => {
        // Cancel previous request
        if (state.currentRequestId) {
          // New request started, old one is stale
        }
        state.currentRequestId = action.meta.requestId;
      })
      .addCase(searchAPI.fulfilled, (state, action) => {
        // Only update if this is the current request
        if (state.currentRequestId === action.meta.requestId) {
          state.results = action.payload;
        }
      });
  }
});
```

### Debounced Search Example

```javascript
import { createAsyncThunk } from '@reduxjs/toolkit';

const searchUsers = createAsyncThunk(
  'users/search',
  async (query, { signal }) => {
    // Wait a bit before searching
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // Check if cancelled
    if (signal.aborted) {
      return;
    }
    
    const response = await fetch(`/api/search?q=${query}`, { signal });
    return response.json();
  }
);

// In component:
function SearchComponent() {
  const dispatch = useDispatch();
  const [searchTerm, setSearchTerm] = useState('');
  
  useEffect(() => {
    if (!searchTerm) return;
    
    const promise = dispatch(searchUsers(searchTerm));
    
    return () => {
      promise.abort(); // Cancel when searchTerm changes
    };
  }, [searchTerm, dispatch]);
  
  return (
    <input
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
    />
  );
}
```

### Handling Race Conditions

```javascript
const fetchLatestData = createAsyncThunk(
  'data/fetchLatest',
  async (_, { getState, requestId }) => {
    const response = await fetch('/api/data');
    const data = await response.json();
    
    // Check if this is still the current request
    const { currentRequestId } = getState().data;
    if (requestId !== currentRequestId) {
      // Another request was made, ignore this one
      throw new Error('Request outdated');
    }
    
    return data;
  }
);
```

---

## 5.6 Real-World Examples

### Example 1: CRUD Operations

```javascript
// API functions
const api = {
  getUsers: () => fetch('/api/users').then(r => r.json()),
  getUser: (id) => fetch(`/api/users/${id}`).then(r => r.json()),
  createUser: (user) => fetch('/api/users', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(user)
  }).then(r => r.json()),
  updateUser: (user) => fetch(`/api/users/${user.id}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(user)
  }).then(r => r.json()),
  deleteUser: (id) => fetch(`/api/users/${id}`, {
    method: 'DELETE'
  }).then(r => r.json())
};

// Thunks
export const fetchUsers = createAsyncThunk(
  'users/fetchAll',
  async () => api.getUsers()
);

export const fetchUserById = createAsyncThunk(
  'users/fetchById',
  async (userId) => api.getUser(userId)
);

export const addUser = createAsyncThunk(
  'users/add',
  async (user) => api.createUser(user)
);

export const updateUser = createAsyncThunk(
  'users/update',
  async (user) => api.updateUser(user)
);

export const deleteUser = createAsyncThunk(
  'users/delete',
  async (userId) => {
    await api.deleteUser(userId);
    return userId; // Return ID for removal
  }
);

// Slice
const usersSlice = createSlice({
  name: 'users',
  initialState: {
    users: [],
    status: 'idle',
    error: null
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      // Fetch all
      .addCase(fetchUsers.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.users = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message;
      })
      
      // Add
      .addCase(addUser.fulfilled, (state, action) => {
        state.users.push(action.payload);
      })
      
      // Update
      .addCase(updateUser.fulfilled, (state, action) => {
        const index = state.users.findIndex(u => u.id === action.payload.id);
        if (index !== -1) {
          state.users[index] = action.payload;
        }
      })
      
      // Delete
      .addCase(deleteUser.fulfilled, (state, action) => {
        state.users = state.users.filter(u => u.id !== action.payload);
      });
  }
});
```

### Example 2: Authentication Flow

```javascript
export const loginUser = createAsyncThunk(
  'auth/login',
  async (credentials, { rejectWithValue, dispatch }) => {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials)
      });
      
      if (!response.ok) {
        const error = await response.json();
        return rejectWithValue(error.message);
      }
      
      const data = await response.json();
      
      // Save token
      localStorage.setItem('token', data.token);
      
      // Fetch user profile
      dispatch(fetchUserProfile());
      
      return data;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const logoutUser = createAsyncThunk(
  'auth/logout',
  async (_, { dispatch }) => {
    localStorage.removeItem('token');
    dispatch(clearUserData());
    return null;
  }
);

const authSlice = createSlice({
  name: 'auth',
  initialState: {
    user: null,
    token: localStorage.getItem('token'),
    status: 'idle',
    error: null
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(loginUser.pending, (state) => {
        state.status = 'loading';
        state.error = null;
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.token = action.payload.token;
        state.user = action.payload.user;
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload;
      })
      .addCase(logoutUser.fulfilled, (state) => {
        state.user = null;
        state.token = null;
        state.status = 'idle';
      });
  }
});
```

### Example 3: Pagination

```javascript
export const fetchPosts = createAsyncThunk(
  'posts/fetch',
  async ({ page = 1, limit = 10 }) => {
    const response = await fetch(`/api/posts?page=${page}&limit=${limit}`);
    return response.json();
  }
);

const postsSlice = createSlice({
  name: 'posts',
  initialState: {
    posts: [],
    page: 1,
    hasMore: true,
    status: 'idle'
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchPosts.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.posts.push(...action.payload.posts);
        state.page += 1;
        state.hasMore = action.payload.hasMore;
      });
  }
});
```

---

## Best Practices

### âœ… Do's

1. **Always handle all three states**
```javascript
.addCase(thunk.pending, ...)
.addCase(thunk.fulfilled, ...)
.addCase(thunk.rejected, ...)
```

2. **Use rejectWithValue for custom errors**
```javascript
return rejectWithValue({ message: 'Custom error', code: 404 });
```

3. **Cancel requests on unmount**
```javascript
useEffect(() => {
  const promise = dispatch(fetchData());
  return () => promise.abort();
}, []);
```

4. **Use condition to prevent duplicate requests**
```javascript
createAsyncThunk('type', async (arg) => {...}, {
  condition: (arg, { getState }) => !getState().loading
});
```

### âŒ Don'ts

1. **Don't forget error handling**
```javascript
// âŒ No .rejected case
.addCase(thunk.pending, ...)
.addCase(thunk.fulfilled, ...)
// Where's .rejected?
```

2. **Don't put too much logic in thunks**
```javascript
// âŒ Bad - complex business logic in thunk
async (arg, { dispatch, getState }) => {
  // 100 lines of code...
}

// âœ… Better - keep thunks focused on async
async (arg) => {
  return await api.fetchData(arg);
}
```

3. **Don't ignore race conditions**

---

## Summary

`createAsyncThunk()` simplifies async Redux:

| Feature | Benefit |
|---------|---------|
| Auto-generates actions | No manual pending/fulfilled/rejected |
| Handles errors | Built-in error state |
| Cancellable | AbortController support |
| Type-safe | Full TypeScript support |
| ThunkAPI | Access state, dispatch, etc. |

**Key Takeaways:**
1. Generates three action types automatically
2. Use ThunkAPI for advanced features
3. Always handle pending, fulfilled, rejected
4. Use rejectWithValue for custom errors
5. Cancel requests to prevent memory leaks
6. Use condition to prevent duplicate requests

Next: Chapter 6 covers React-Redux integration! ðŸš€