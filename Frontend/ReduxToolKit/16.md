# Chapter 16: Migration and Interoperability

## Overview

This chapter covers migrating from vanilla Redux to Redux Toolkit, integrating with other state management solutions, and strategies for incremental adoption in existing applications.

---

## 16.1 Migrating from Vanilla Redux

### Assessment: What to Migrate

**Identify your current Redux setup:**

```javascript
// Current vanilla Redux structure
src/
‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îú‚îÄ‚îÄ actionTypes.js      // Constants
‚îÇ   ‚îú‚îÄ‚îÄ userActions.js      // Action creators
‚îÇ   ‚îî‚îÄ‚îÄ todoActions.js
‚îú‚îÄ‚îÄ reducers/
‚îÇ   ‚îú‚îÄ‚îÄ userReducer.js      // Reducers
‚îÇ   ‚îú‚îÄ‚îÄ todoReducer.js
‚îÇ   ‚îî‚îÄ‚îÄ index.js            // combineReducers
‚îú‚îÄ‚îÄ store/
‚îÇ   ‚îî‚îÄ‚îÄ index.js            // createStore
‚îî‚îÄ‚îÄ components/
```

**Migration candidates:**
- ‚úÖ Action types ‚Üí Remove (auto-generated)
- ‚úÖ Action creators ‚Üí Convert to slice reducers
- ‚úÖ Reducers ‚Üí Convert to createSlice
- ‚úÖ Store configuration ‚Üí Use configureStore
- ‚úÖ Thunks ‚Üí Keep or convert to createAsyncThunk

### Step-by-Step Migration Strategy

#### Phase 1: Setup RTK Alongside Vanilla Redux

```javascript
// Install RTK
npm install @reduxjs/toolkit

// Keep existing store, add new RTK slices
import { configureStore } from '@reduxjs/toolkit';
import { combineReducers } from 'redux';

// Old vanilla reducers
import oldUserReducer from './reducers/userReducer';
import oldTodoReducer from './reducers/todoReducer';

// New RTK slices
import newPostsReducer from './features/posts/postsSlice';

const rootReducer = combineReducers({
  // Keep old reducers running
  user: oldUserReducer,
  todos: oldTodoReducer,
  
  // Add new RTK slices
  posts: newPostsReducer
});

const store = configureStore({
  reducer: rootReducer,
  // RTK automatically adds thunk middleware and DevTools
});
```

#### Phase 2: Convert Action Types and Creators

**Before (Vanilla Redux):**

```javascript
// actionTypes.js
export const ADD_TODO = 'ADD_TODO';
export const TOGGLE_TODO = 'TOGGLE_TODO';
export const REMOVE_TODO = 'REMOVE_TODO';

// actions.js
export const addTodo = (text) => ({
  type: ADD_TODO,
  payload: { id: Date.now(), text, completed: false }
});

export const toggleTodo = (id) => ({
  type: TOGGLE_TODO,
  payload: id
});

export const removeTodo = (id) => ({
  type: REMOVE_TODO,
  payload: id
});

// reducer.js
const initialState = [];

export default function todosReducer(state = initialState, action) {
  switch (action.type) {
    case ADD_TODO:
      return [...state, action.payload];
    case TOGGLE_TODO:
      return state.map(todo =>
        todo.id === action.payload
          ? { ...todo, completed: !todo.completed }
          : todo
      );
    case REMOVE_TODO:
      return state.filter(todo => todo.id !== action.payload);
    default:
      return state;
  }
}
```

**After (Redux Toolkit):**

```javascript
// todosSlice.js
import { createSlice, nanoid } from '@reduxjs/toolkit';

const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo: {
      reducer: (state, action) => {
        state.push(action.payload);
      },
      prepare: (text) => ({
        payload: {
          id: nanoid(),
          text,
          completed: false
        }
      })
    },
    toggleTodo: (state, action) => {
      const todo = state.find(t => t.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
    removeTodo: (state, action) => {
      return state.filter(t => t.id !== action.payload);
    }
  }
});

export const { addTodo, toggleTodo, removeTodo } = todosSlice.actions;
export default todosSlice.reducer;
```

**Lines of code:**
- Before: ~60 lines across 3 files
- After: ~30 lines in 1 file
- **50% reduction!**

#### Phase 3: Update Components

**Before:**

```javascript
import { connect } from 'react-redux';
import { addTodo, toggleTodo } from '../actions';

class TodoList extends React.Component {
  handleAdd = () => {
    this.props.addTodo('New todo');
  };
  
  render() {
    return (
      <ul>
        {this.props.todos.map(todo => (
          <li key={todo.id} onClick={() => this.props.toggleTodo(todo.id)}>
            {todo.text}
          </li>
        ))}
        <button onClick={this.handleAdd}>Add</button>
      </ul>
    );
  }
}

const mapStateToProps = (state) => ({
  todos: state.todos
});

const mapDispatchToProps = {
  addTodo,
  toggleTodo
};

export default connect(mapStateToProps, mapDispatchToProps)(TodoList);
```

**After:**

```javascript
import { useAppSelector, useAppDispatch } from '../../app/hooks';
import { addTodo, toggleTodo } from './todosSlice';

function TodoList() {
  const dispatch = useAppDispatch();
  const todos = useAppSelector(state => state.todos);
  
  const handleAdd = () => {
    dispatch(addTodo('New todo'));
  };
  
  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id} onClick={() => dispatch(toggleTodo(todo.id))}>
          {todo.text}
        </li>
      ))}
      <button onClick={handleAdd}>Add</button>
    </ul>
  );
}

export default TodoList;
```

#### Phase 4: Convert Thunks

**Before (Manual Thunk):**

```javascript
// actions.js
export const FETCH_USERS_REQUEST = 'FETCH_USERS_REQUEST';
export const FETCH_USERS_SUCCESS = 'FETCH_USERS_SUCCESS';
export const FETCH_USERS_FAILURE = 'FETCH_USERS_FAILURE';

export const fetchUsers = () => async (dispatch) => {
  dispatch({ type: FETCH_USERS_REQUEST });
  
  try {
    const response = await fetch('/api/users');
    const data = await response.json();
    dispatch({ type: FETCH_USERS_SUCCESS, payload: data });
  } catch (error) {
    dispatch({ type: FETCH_USERS_FAILURE, error: error.message });
  }
};

// reducer.js
const initialState = {
  items: [],
  loading: false,
  error: null
};

export default function usersReducer(state = initialState, action) {
  switch (action.type) {
    case FETCH_USERS_REQUEST:
      return { ...state, loading: true, error: null };
    case FETCH_USERS_SUCCESS:
      return { ...state, loading: false, items: action.payload };
    case FETCH_USERS_FAILURE:
      return { ...state, loading: false, error: action.error };
    default:
      return state;
  }
}
```

**After (createAsyncThunk):**

```javascript
// usersSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

export const fetchUsers = createAsyncThunk(
  'users/fetchAll',
  async () => {
    const response = await fetch('/api/users');
    return response.json();
  }
);

const usersSlice = createSlice({
  name: 'users',
  initialState: {
    items: [],
    loading: false,
    error: null
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  }
});

export default usersSlice.reducer;
```

### Migration Checklist

```typescript
// Migration progress tracker
interface MigrationStatus {
  feature: string;
  status: 'pending' | 'in-progress' | 'complete';
  linesRemoved: number;
  linesAdded: number;
}

const migrationProgress: MigrationStatus[] = [
  { feature: 'todos', status: 'complete', linesRemoved: 60, linesAdded: 30 },
  { feature: 'users', status: 'in-progress', linesRemoved: 0, linesAdded: 0 },
  { feature: 'auth', status: 'pending', linesRemoved: 0, linesAdded: 0 }
];
```

---

## 16.2 Migrating from Context API

### When to Migrate from Context

**Context API works well for:**
- ‚úÖ Theme/language preferences
- ‚úÖ Authentication state
- ‚úÖ Small, infrequently changing data

**Migrate to Redux when:**
- ‚ùå Performance issues (too many re-renders)
- ‚ùå Complex state updates
- ‚ùå Need for time-travel debugging
- ‚ùå Multiple contexts getting unwieldy

### Migration Example

**Before (Context API):**

```typescript
// UserContext.tsx
import { createContext, useState, useContext, ReactNode } from 'react';

interface User {
  id: string;
  name: string;
}

interface UserContextType {
  user: User | null;
  login: (user: User) => void;
  logout: () => void;
}

const UserContext = createContext<UserContextType | undefined>(undefined);

export function UserProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  
  const login = (user: User) => {
    setUser(user);
    localStorage.setItem('user', JSON.stringify(user));
  };
  
  const logout = () => {
    setUser(null);
    localStorage.removeItem('user');
  };
  
  return (
    <UserContext.Provider value={{ user, login, logout }}>
      {children}
    </UserContext.Provider>
  );
}

export function useUser() {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error('useUser must be used within UserProvider');
  }
  return context;
}

// App.tsx
<UserProvider>
  <App />
</UserProvider>

// Component usage
function Profile() {
  const { user, logout } = useUser();
  return (
    <div>
      <p>{user?.name}</p>
      <button onClick={logout}>Logout</button>
    </div>
  );
}
```

**After (Redux Toolkit):**

```typescript
// userSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface User {
  id: string;
  name: string;
}

const userSlice = createSlice({
  name: 'user',
  initialState: null as User | null,
  reducers: {
    userLoggedIn: (state, action: PayloadAction<User>) => {
      localStorage.setItem('user', JSON.stringify(action.payload));
      return action.payload;
    },
    userLoggedOut: () => {
      localStorage.removeItem('user');
      return null;
    }
  }
});

export const { userLoggedIn, userLoggedOut } = userSlice.actions;
export default userSlice.reducer;

// App.tsx
<Provider store={store}>
  <App />
</Provider>

// Component usage
function Profile() {
  const dispatch = useAppDispatch();
  const user = useAppSelector(state => state.user);
  
  return (
    <div>
      <p>{user?.name}</p>
      <button onClick={() => dispatch(userLoggedOut())}>
        Logout
      </button>
    </div>
  );
}
```

**Benefits of migration:**
- ‚úÖ Better performance (no unnecessary re-renders)
- ‚úÖ DevTools support
- ‚úÖ Middleware capabilities
- ‚úÖ Easier testing

---

## 16.3 Coexisting with Other Libraries

### Redux + React Query

Use both for different purposes:

```typescript
// React Query for server state
import { useQuery, useMutation } from '@tanstack/react-query';

function useUserPosts(userId: string) {
  return useQuery({
    queryKey: ['posts', userId],
    queryFn: () => fetch(`/api/users/${userId}/posts`).then(r => r.json())
  });
}

// Redux for client state
const uiSlice = createSlice({
  name: 'ui',
  initialState: {
    theme: 'light',
    sidebarOpen: true
  },
  reducers: {
    themeToggled: (state) => {
      state.theme = state.theme === 'light' ? 'dark' : 'light';
    }
  }
});

// Use together in component
function Dashboard() {
  // React Query for data fetching
  const { data: posts } = useUserPosts('123');
  
  // Redux for UI state
  const theme = useAppSelector(state => state.ui.theme);
  const dispatch = useAppDispatch();
  
  return (
    <div className={theme}>
      <button onClick={() => dispatch(themeToggled())}>
        Toggle Theme
      </button>
      {posts?.map(post => <PostCard key={post.id} {...post} />)}
    </div>
  );
}
```

**Decision matrix:**

| State Type | Use |
|------------|-----|
| Server data (CRUD) | React Query / RTK Query |
| UI state | Redux / Local state |
| Form state | React Hook Form / Local |
| Global app state | Redux |

### Redux + Zustand

Gradually migrate or use for different concerns:

```typescript
// Zustand for simple stores
import create from 'zustand';

interface NotificationStore {
  notifications: Notification[];
  addNotification: (n: Notification) => void;
  removeNotification: (id: string) => void;
}

const useNotificationStore = create<NotificationStore>((set) => ({
  notifications: [],
  addNotification: (notification) =>
    set((state) => ({
      notifications: [...state.notifications, notification]
    })),
  removeNotification: (id) =>
    set((state) => ({
      notifications: state.notifications.filter(n => n.id !== id)
    }))
}));

// Redux for complex state
const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    // Complex todo logic
  }
});

// Use together
function App() {
  // Zustand for simple notifications
  const { notifications, addNotification } = useNotificationStore();
  
  // Redux for complex todos
  const todos = useAppSelector(state => state.todos);
  
  return <div>{/* ... */}</div>;
}
```

### Redux + MobX (Rare)

Typically choose one, but can coexist:

```typescript
// MobX store for specific feature
import { makeAutoObservable } from 'mobx';
import { observer } from 'mobx-react-lite';

class EditorStore {
  content = '';
  
  constructor() {
    makeAutoObservable(this);
  }
  
  updateContent(content: string) {
    this.content = content;
  }
}

const editorStore = new EditorStore();

const Editor = observer(() => {
  return (
    <textarea
      value={editorStore.content}
      onChange={(e) => editorStore.updateContent(e.target.value)}
    />
  );
});

// Redux for rest of app
function App() {
  const user = useAppSelector(state => state.user);
  
  return (
    <div>
      <Editor />  {/* Uses MobX */}
      <Profile user={user} />  {/* Uses Redux */}
    </div>
  );
}
```

---

## 16.4 Migrating to RTK Query

### From Redux Thunks to RTK Query

**Before (Thunks):**

```typescript
// postsSlice.ts with thunks
export const fetchPosts = createAsyncThunk('posts/fetch', async () => {
  const response = await fetch('/api/posts');
  return response.json();
});

export const addPost = createAsyncThunk('posts/add', async (post: Post) => {
  const response = await fetch('/api/posts', {
    method: 'POST',
    body: JSON.stringify(post)
  });
  return response.json();
});

const postsSlice = createSlice({
  name: 'posts',
  initialState: {
    items: [],
    loading: false,
    error: null
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchPosts.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload;
      })
      // ... more cases
  }
});
```

**After (RTK Query):**

```typescript
// postsApi.ts
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const postsApi = createApi({
  reducerPath: 'postsApi',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  tagTypes: ['Posts'],
  endpoints: (builder) => ({
    getPosts: builder.query<Post[], void>({
      query: () => '/posts',
      providesTags: ['Posts']
    }),
    addPost: builder.mutation<Post, Partial<Post>>({
      query: (body) => ({
        url: '/posts',
        method: 'POST',
        body
      }),
      invalidatesTags: ['Posts']
    })
  })
});

export const { useGetPostsQuery, useAddPostMutation } = postsApi;

// Component - Much simpler!
function PostsList() {
  const { data: posts, isLoading } = useGetPostsQuery();
  const [addPost] = useAddPostMutation();
  
  if (isLoading) return <div>Loading...</div>;
  
  return (
    <div>
      {posts?.map(post => <PostCard key={post.id} {...post} />)}
      <button onClick={() => addPost({ title: 'New Post' })}>
        Add Post
      </button>
    </div>
  );
}
```

**Reduction:**
- Before: ~100 lines (slice + thunks + loading states)
- After: ~30 lines
- **70% less code!**

### From Axios to RTK Query

**Before (Axios):**

```typescript
// api.ts
import axios from 'axios';

export const api = {
  getPosts: () => axios.get('/api/posts'),
  getPost: (id: string) => axios.get(`/api/posts/${id}`),
  createPost: (post: Post) => axios.post('/api/posts', post),
  updatePost: (id: string, post: Partial<Post>) => 
    axios.patch(`/api/posts/${id}`, post),
  deletePost: (id: string) => axios.delete(`/api/posts/${id}`)
};

// postsSlice.ts
export const fetchPosts = createAsyncThunk('posts/fetch', async () => {
  const { data } = await api.getPosts();
  return data;
});

// Need to manually handle caching, revalidation, etc.
```

**After (RTK Query):**

```typescript
// postsApi.ts
export const postsApi = createApi({
  reducerPath: 'postsApi',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  tagTypes: ['Posts'],
  endpoints: (builder) => ({
    getPosts: builder.query<Post[], void>({
      query: () => '/posts',
      providesTags: ['Posts']
    }),
    getPost: builder.query<Post, string>({
      query: (id) => `/posts/${id}`,
      providesTags: (result, error, id) => [{ type: 'Posts', id }]
    }),
    createPost: builder.mutation<Post, Partial<Post>>({
      query: (body) => ({ url: '/posts', method: 'POST', body }),
      invalidatesTags: ['Posts']
    }),
    updatePost: builder.mutation<Post, { id: string; body: Partial<Post> }>({
      query: ({ id, body }) => ({
        url: `/posts/${id}`,
        method: 'PATCH',
        body
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'Posts', id }]
    }),
    deletePost: builder.mutation<void, string>({
      query: (id) => ({ url: `/posts/${id}`, method: 'DELETE' }),
      invalidatesTags: (result, error, id) => [{ type: 'Posts', id }]
    })
  })
});

// Automatic caching, revalidation, optimistic updates!
```

---

## 16.5 Incremental Migration Strategy

### Week-by-Week Plan

**Week 1: Setup**
```typescript
// 1. Install RTK
npm install @reduxjs/toolkit

// 2. Create typed hooks
// app/hooks.ts
export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

// 3. Convert store config
const store = configureStore({
  reducer: {
    // Keep old reducers
    oldUsers: oldUserReducer,
    oldTodos: oldTodoReducer
  }
});
```

**Week 2: Convert Simple Slices**
```typescript
// Convert simplest slice first (e.g., UI state)
const uiSlice = createSlice({
  name: 'ui',
  initialState: { theme: 'light', sidebarOpen: true },
  reducers: {
    themeToggled: (state) => {
      state.theme = state.theme === 'light' ? 'dark' : 'light';
    },
    sidebarToggled: (state) => {
      state.sidebarOpen = !state.sidebarOpen;
    }
  }
});

// Update store
const store = configureStore({
  reducer: {
    ui: uiSlice.reducer,  // ‚úÖ Migrated
    oldUsers: oldUserReducer,
    oldTodos: oldTodoReducer
  }
});
```

**Week 3: Convert Async Logic**
```typescript
// Convert thunks
export const fetchUsers = createAsyncThunk(
  'users/fetchAll',
  async () => {
    const response = await fetch('/api/users');
    return response.json();
  }
);

const usersSlice = createSlice({
  name: 'users',
  initialState: { items: [], loading: false, error: null },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  }
});

// Update store
const store = configureStore({
  reducer: {
    ui: uiSlice.reducer,
    users: usersSlice.reducer,  // ‚úÖ Migrated
    oldTodos: oldTodoReducer
  }
});
```

**Week 4: Convert Components**
```typescript
// Convert from connect() to hooks
// Before
const TodoList = connect(
  mapStateToProps,
  mapDispatchToProps
)(TodoListComponent);

// After
function TodoList() {
  const dispatch = useAppDispatch();
  const todos = useAppSelector(state => state.todos);
  
  return <div>{/* ... */}</div>;
}
```

**Week 5-6: Finish Migration & Cleanup**
```typescript
// Delete old files
// ‚ùå Remove
- src/actions/actionTypes.js
- src/actions/userActions.js
- src/reducers/oldUserReducer.js

// Update imports in remaining components
// Clean up any unused code
```

### Migration Metrics

Track your progress:

```typescript
interface MigrationMetrics {
  totalSlices: number;
  migratedSlices: number;
  percentComplete: number;
  linesOfCodeRemoved: number;
  componentsUpdated: number;
}

const metrics: MigrationMetrics = {
  totalSlices: 8,
  migratedSlices: 6,
  percentComplete: 75,
  linesOfCodeRemoved: 450,
  componentsUpdated: 24
};
```

---

## Best Practices

### ‚úÖ Do's

1. **Migrate incrementally**
```typescript
// One feature at a time
Week 1: UI slice
Week 2: Users slice
Week 3: Posts slice
```

2. **Test after each migration**
```typescript
// Ensure nothing breaks
npm test
```

3. **Update documentation**
```typescript
// Keep README updated with migration status
## Migration Status
- [x] UI state
- [x] Users
- [ ] Todos (in progress)
```

4. **Use both systems during migration**
```typescript
const store = configureStore({
  reducer: {
    // New RTK slices
    ui: uiSlice.reducer,
    
    // Old vanilla Redux
    oldUsers: oldUserReducer
  }
});
```

5. **Communicate with team**
```typescript
// Document in PR
// "Migrated users slice to RTK"
// "Reduced code by 60 lines"
```

### ‚ùå Don'ts

1. **Don't migrate everything at once**
```typescript
// ‚ùå Bad: Big bang migration
// Rewrite entire codebase in one PR
```

2. **Don't forget to update tests**
```typescript
// ‚úÖ Update tests as you migrate
```

3. **Don't change behavior during migration**
```typescript
// ‚ùå Bad: Add new features during migration
// ‚úÖ Good: Feature-equivalent migration only
```

---

## Summary

Migration strategies:

| From | To | Effort | Benefit |
|------|----|----|---------|
| Vanilla Redux | RTK | Medium | 50-70% less code |
| Context API | RTK | Low | Better performance |
| Thunks | RTK Query | Medium | Auto-caching |
| Multiple solutions | RTK | High | Unified approach |

**Key Takeaways:**
1. Migrate incrementally, not all at once
2. Keep old and new systems running together
3. Test after each migration step
4. RTK reduces code by 50-70%
5. Update components last
6. Document progress
7. Communicate with team

Next: Chapter 17 covers Debugging and DevTools! üöÄ