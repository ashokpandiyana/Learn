# Chapter 8: Normalization with createEntityAdapter()

## Overview

`createEntityAdapter()` is a powerful Redux Toolkit utility for managing normalized collections of data. It provides standardized methods for CRUD operations and generates optimized selectors automatically.

---

## 8.1 Why Normalize State?

### The Nested Data Problem

#### **Nested/Denormalized Structure** (Problematic)

```javascript
// âŒ Nested structure
const state = {
  posts: [
    {
      id: 1,
      title: 'Post 1',
      author: {
        id: 'user1',
        name: 'John',
        email: 'john@example.com'
      },
      comments: [
        {
          id: 'c1',
          text: 'Great post!',
          author: {
            id: 'user2',
            name: 'Jane',
            email: 'jane@example.com'
          }
        },
        {
          id: 'c2',
          text: 'Thanks!',
          author: {
            id: 'user1',  // Duplicate user data!
            name: 'John',
            email: 'john@example.com'
          }
        }
      ]
    }
  ]
};
```

**Problems:**
1. **Duplication**: User data repeated multiple times
2. **Update complexity**: Must update user in many places
3. **Inconsistency**: User data can get out of sync
4. **Performance**: Deep nesting causes unnecessary re-renders

#### **Normalized Structure** (Better)

```javascript
// âœ… Normalized structure
const state = {
  users: {
    byId: {
      'user1': { id: 'user1', name: 'John', email: 'john@example.com' },
      'user2': { id: 'user2', name: 'Jane', email: 'jane@example.com' }
    },
    allIds: ['user1', 'user2']
  },
  posts: {
    byId: {
      '1': { id: 1, title: 'Post 1', authorId: 'user1', commentIds: ['c1', 'c2'] }
    },
    allIds: [1]
  },
  comments: {
    byId: {
      'c1': { id: 'c1', text: 'Great post!', authorId: 'user2' },
      'c2': { id: 'c2', text: 'Thanks!', authorId: 'user1' }
    },
    allIds: ['c1', 'c2']
  }
};
```

**Benefits:**
1. **No duplication**: Each entity stored once
2. **Easy updates**: Update user in one place
3. **Consistency**: Single source of truth
4. **Performance**: Shallow updates, efficient lookups

### Normalization Principles

1. **Each entity type gets its own table** (users, posts, comments)
2. **Store by ID** for O(1) lookups
3. **Keep an array of IDs** for ordering
4. **Reference by ID**, not embedding

### When to Normalize

âœ… **Normalize when:**
- Working with relational data
- Same data appears in multiple places
- Need to update entities independently
- Building large-scale applications
- Data comes from REST APIs

âŒ **Don't normalize when:**
- Simple, non-relational data
- Data never duplicated
- Very small datasets
- Form state (keep local)

---

## 8.2 Entity Adapter Basics

### Creating an Adapter

```javascript
import { createEntityAdapter } from '@reduxjs/toolkit';

const usersAdapter = createEntityAdapter();

// Initial state structure
const initialState = usersAdapter.getInitialState();
console.log(initialState);
// {
//   ids: [],
//   entities: {}
// }
```

### State Structure

EntityAdapter creates a standardized state shape:

```javascript
{
  ids: [1, 2, 3],           // Array of IDs (for ordering)
  entities: {               // Lookup table
    1: { id: 1, name: 'John' },
    2: { id: 2, name: 'Jane' },
    3: { id: 3, name: 'Bob' }
  }
}
```

**Why this structure?**
- `ids`: Maintains order, easy iteration
- `entities`: Fast O(1) lookup by ID

### Custom ID Selection

By default, adapter looks for `id` field. Customize if different:

```javascript
// If your entities use 'userId' instead of 'id'
const usersAdapter = createEntityAdapter({
  selectId: (user) => user.userId
});

// Or computed ID
const usersAdapter = createEntityAdapter({
  selectId: (user) => `${user.firstName}-${user.lastName}`
});
```

### Adding Additional State

```javascript
const usersAdapter = createEntityAdapter();

const initialState = usersAdapter.getInitialState({
  // Additional state beyond ids/entities
  loading: false,
  error: null,
  selectedUserId: null
});

console.log(initialState);
// {
//   ids: [],
//   entities: {},
//   loading: false,
//   error: null,
//   selectedUserId: null
// }
```

---

## 8.3 CRUD Reducers

### Adding Entities

#### **addOne** - Add single entity

```javascript
const usersSlice = createSlice({
  name: 'users',
  initialState: usersAdapter.getInitialState(),
  reducers: {
    userAdded: usersAdapter.addOne
  }
});

// Usage
dispatch(userAdded({ id: 1, name: 'John' }));

// State after:
// {
//   ids: [1],
//   entities: { 1: { id: 1, name: 'John' } }
// }
```

#### **addMany** - Add multiple entities

```javascript
const usersSlice = createSlice({
  name: 'users',
  initialState: usersAdapter.getInitialState(),
  reducers: {
    usersAdded: usersAdapter.addMany
  }
});

// Usage
dispatch(usersAdded([
  { id: 1, name: 'John' },
  { id: 2, name: 'Jane' },
  { id: 3, name: 'Bob' }
]));

// State after:
// {
//   ids: [1, 2, 3],
//   entities: {
//     1: { id: 1, name: 'John' },
//     2: { id: 2, name: 'Jane' },
//     3: { id: 3, name: 'Bob' }
//   }
// }
```

### Setting Entities

#### **setOne** - Replace single entity

```javascript
reducers: {
  userSet: usersAdapter.setOne
}

// Replaces entity if exists, adds if doesn't
dispatch(userSet({ id: 1, name: 'John Updated' }));
```

#### **setAll** - Replace all entities

```javascript
reducers: {
  usersReplaced: usersAdapter.setAll
}

// Replaces entire collection
dispatch(usersReplaced([
  { id: 4, name: 'Alice' },
  { id: 5, name: 'Charlie' }
]));

// State after:
// {
//   ids: [4, 5],
//   entities: {
//     4: { id: 4, name: 'Alice' },
//     5: { id: 5, name: 'Charlie' }
//   }
// }
```

#### **setMany** - Replace multiple entities

```javascript
reducers: {
  usersUpdated: usersAdapter.setMany
}

dispatch(usersUpdated([
  { id: 1, name: 'John v2' },
  { id: 2, name: 'Jane v2' }
]));
```

### Updating Entities

#### **updateOne** - Update single entity

```javascript
reducers: {
  userUpdated: usersAdapter.updateOne
}

// Partial update
dispatch(userUpdated({
  id: 1,
  changes: { name: 'John Smith' }
}));

// Before: { id: 1, name: 'John', email: 'john@example.com' }
// After:  { id: 1, name: 'John Smith', email: 'john@example.com' }
```

#### **updateMany** - Update multiple entities

```javascript
reducers: {
  usersUpdated: usersAdapter.updateMany
}

dispatch(usersUpdated([
  { id: 1, changes: { name: 'John Smith' } },
  { id: 2, changes: { email: 'jane.new@example.com' } }
]));
```

### Upserting Entities

**Upsert** = Update if exists, insert if doesn't

#### **upsertOne** - Upsert single entity

```javascript
reducers: {
  userUpserted: usersAdapter.upsertOne
}

// If id=1 exists: updates it
// If id=1 doesn't exist: adds it
dispatch(userUpserted({ id: 1, name: 'John' }));
```

#### **upsertMany** - Upsert multiple entities

```javascript
reducers: {
  usersUpserted: usersAdapter.upsertMany
}

dispatch(usersUpserted([
  { id: 1, name: 'John' },    // Updates if exists
  { id: 4, name: 'New User' } // Adds if new
]));
```

### Removing Entities

#### **removeOne** - Remove single entity

```javascript
reducers: {
  userRemoved: usersAdapter.removeOne
}

dispatch(userRemoved(1)); // Remove entity with id=1

// State after:
// {
//   ids: [2, 3],  // id 1 removed from array
//   entities: {
//     2: {...},
//     3: {...}
//     // id 1 removed from object
//   }
// }
```

#### **removeMany** - Remove multiple entities

```javascript
reducers: {
  usersRemoved: usersAdapter.removeMany
}

// Remove by array of IDs
dispatch(usersRemoved([1, 2, 3]));

// Or with predicate function
dispatch(usersRemoved((entity) => entity.age < 18));
```

#### **removeAll** - Remove all entities

```javascript
reducers: {
  usersCleared: usersAdapter.removeAll
}

dispatch(usersCleared());

// State after:
// {
//   ids: [],
//   entities: {}
// }
```

### Complete CRUD Example

```javascript
import { createSlice, createEntityAdapter } from '@reduxjs/toolkit';

const usersAdapter = createEntityAdapter();

const usersSlice = createSlice({
  name: 'users',
  initialState: usersAdapter.getInitialState({
    loading: false,
    error: null
  }),
  reducers: {
    // Create
    userAdded: usersAdapter.addOne,
    usersAdded: usersAdapter.addMany,
    
    // Read (handled by selectors)
    
    // Update
    userUpdated: usersAdapter.updateOne,
    usersUpdated: usersAdapter.updateMany,
    
    // Upsert
    userUpserted: usersAdapter.upsertOne,
    
    // Delete
    userRemoved: usersAdapter.removeOne,
    usersRemoved: usersAdapter.removeMany,
    allUsersRemoved: usersAdapter.removeAll,
    
    // Replace
    usersReplaced: usersAdapter.setAll
  }
});

export const {
  userAdded,
  usersAdded,
  userUpdated,
  usersUpdated,
  userUpserted,
  userRemoved,
  usersRemoved,
  allUsersRemoved,
  usersReplaced
} = usersSlice.actions;

export default usersSlice.reducer;
```

---

## 8.4 Entity Selectors

### Getting Selectors

```javascript
const usersAdapter = createEntityAdapter();

// Get selectors - pass state selector function
const usersSelectors = usersAdapter.getSelectors(
  (state) => state.users
);

// Now you have:
usersSelectors.selectAll      // Get all entities as array
usersSelectors.selectById     // Get entity by ID
usersSelectors.selectIds      // Get all IDs
usersSelectors.selectEntities // Get entities object
usersSelectors.selectTotal    // Get total count
```

### selectAll - Get All Entities

```javascript
const usersSelectors = usersAdapter.getSelectors(
  (state) => state.users
);

// In component
function UsersList() {
  const users = useSelector(usersSelectors.selectAll);
  
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// Returns: [{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }, ...]
```

### selectById - Get Single Entity

```javascript
// Parametric selector
function UserProfile({ userId }) {
  const user = useSelector(state =>
    usersSelectors.selectById(state, userId)
  );
  
  if (!user) return <div>User not found</div>;
  
  return <div>{user.name}</div>;
}

// Returns: { id: 1, name: 'John' } or undefined
```

### selectIds - Get All IDs

```javascript
function UserIdsList() {
  const userIds = useSelector(usersSelectors.selectIds);
  
  return (
    <ul>
      {userIds.map(id => (
        <li key={id}>User ID: {id}</li>
      ))}
    </ul>
  );
}

// Returns: [1, 2, 3, 4, 5]
```

### selectEntities - Get Entities Object

```javascript
function UserLookup() {
  const usersById = useSelector(usersSelectors.selectEntities);
  
  const user5 = usersById[5]; // Fast O(1) lookup
  
  return <div>{user5?.name}</div>;
}

// Returns: { 1: {...}, 2: {...}, 3: {...} }
```

### selectTotal - Get Count

```javascript
function UsersCount() {
  const totalUsers = useSelector(usersSelectors.selectTotal);
  
  return <div>Total users: {totalUsers}</div>;
}

// Returns: 5
```

### Using Selectors in Slice

```javascript
// usersSlice.js
const usersAdapter = createEntityAdapter();

const usersSlice = createSlice({
  name: 'users',
  initialState: usersAdapter.getInitialState(),
  reducers: { /* ... */ }
});

// Export selectors
export const usersSelectors = usersAdapter.getSelectors(
  (state) => state.users
);

export const {
  selectAll: selectAllUsers,
  selectById: selectUserById,
  selectIds: selectUserIds,
  selectEntities: selectUserEntities,
  selectTotal: selectTotalUsers
} = usersSelectors;

// Usage in component
import { selectAllUsers, selectUserById } from './usersSlice';

function MyComponent() {
  const users = useSelector(selectAllUsers);
  const user = useSelector(state => selectUserById(state, 1));
}
```

### Global vs Local Selectors

```javascript
// Global selectors (need full state)
const globalSelectors = usersAdapter.getSelectors(
  (state) => state.users
);

const users = globalSelectors.selectAll(state);

// Local selectors (work with slice state directly)
const localSelectors = usersAdapter.getSelectors();

const users = localSelectors.selectAll(usersSliceState);
```

---

## 8.5 Custom Sort Comparator

### Default Sorting

By default, entities maintain insertion order:

```javascript
// Add in this order:
dispatch(userAdded({ id: 3, name: 'Charlie' }));
dispatch(userAdded({ id: 1, name: 'Alice' }));
dispatch(userAdded({ id: 2, name: 'Bob' }));

// selectAll returns: [Charlie, Alice, Bob]
```

### sortComparer Option

Sort entities automatically:

```javascript
const usersAdapter = createEntityAdapter({
  // Sort alphabetically by name
  sortComparer: (a, b) => a.name.localeCompare(b.name)
});

// Now selectAll returns: [Alice, Bob, Charlie]
```

### Sorting Examples

#### **Sort by Name**

```javascript
const usersAdapter = createEntityAdapter({
  sortComparer: (a, b) => a.name.localeCompare(b.name)
});
```

#### **Sort by Date (Newest First)**

```javascript
const postsAdapter = createEntityAdapter({
  sortComparer: (a, b) => 
    new Date(b.createdAt) - new Date(a.createdAt)
});
```

#### **Sort by Multiple Fields**

```javascript
const tasksAdapter = createEntityAdapter({
  sortComparer: (a, b) => {
    // First by priority (high to low)
    if (a.priority !== b.priority) {
      return b.priority - a.priority;
    }
    // Then by date (newest first)
    return new Date(b.createdAt) - new Date(a.createdAt);
  }
});
```

#### **Sort by Boolean Then String**

```javascript
const todosAdapter = createEntityAdapter({
  sortComparer: (a, b) => {
    // Incomplete todos first
    if (a.completed !== b.completed) {
      return a.completed ? 1 : -1;
    }
    // Then alphabetically
    return a.text.localeCompare(b.text);
  }
});
```

### Performance Consideration

Sorting happens on **every update**. For large datasets, this can be expensive.

```javascript
// âš ï¸ Runs sort on every add/update
const adapter = createEntityAdapter({
  sortComparer: expensiveSortFunction
});

// âœ… Consider sorting in a selector instead
const selectSortedUsers = createSelector(
  [usersSelectors.selectAll],
  (users) => [...users].sort(expensiveSortFunction)
);
```

---

## 8.6 Real-World Patterns

### Pattern 1: With Async Thunks

```javascript
import { 
  createSlice, 
  createEntityAdapter, 
  createAsyncThunk 
} from '@reduxjs/toolkit';

const usersAdapter = createEntityAdapter();

// Async thunks
export const fetchUsers = createAsyncThunk(
  'users/fetchAll',
  async () => {
    const response = await fetch('/api/users');
    return response.json();
  }
);

export const addUser = createAsyncThunk(
  'users/add',
  async (user) => {
    const response = await fetch('/api/users', {
      method: 'POST',
      body: JSON.stringify(user)
    });
    return response.json();
  }
);

export const updateUser = createAsyncThunk(
  'users/update',
  async (user) => {
    const response = await fetch(`/api/users/${user.id}`, {
      method: 'PUT',
      body: JSON.stringify(user)
    });
    return response.json();
  }
);

export const deleteUser = createAsyncThunk(
  'users/delete',
  async (userId) => {
    await fetch(`/api/users/${userId}`, { method: 'DELETE' });
    return userId;
  }
);

// Slice
const usersSlice = createSlice({
  name: 'users',
  initialState: usersAdapter.getInitialState({
    loading: false,
    error: null
  }),
  reducers: {},
  extraReducers: (builder) => {
    builder
      // Fetch
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        usersAdapter.setAll(state, action.payload);
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      })
      
      // Add
      .addCase(addUser.fulfilled, (state, action) => {
        usersAdapter.addOne(state, action.payload);
      })
      
      // Update
      .addCase(updateUser.fulfilled, (state, action) => {
        usersAdapter.updateOne(state, {
          id: action.payload.id,
          changes: action.payload
        });
      })
      
      // Delete
      .addCase(deleteUser.fulfilled, (state, action) => {
        usersAdapter.removeOne(state, action.payload);
      });
  }
});

export default usersSlice.reducer;

// Selectors
export const usersSelectors = usersAdapter.getSelectors(
  (state) => state.users
);
```

### Pattern 2: Multiple Adapters

```javascript
// postsSlice.js
const postsAdapter = createEntityAdapter({
  sortComparer: (a, b) => b.date - a.date
});

const postsSlice = createSlice({
  name: 'posts',
  initialState: postsAdapter.getInitialState(),
  reducers: {
    postAdded: postsAdapter.addOne,
    postUpdated: postsAdapter.updateOne,
    postRemoved: postsAdapter.removeOne
  }
});

export const postsSelectors = postsAdapter.getSelectors(
  (state) => state.posts
);

// commentsSlice.js
const commentsAdapter = createEntityAdapter({
  sortComparer: (a, b) => a.date - b.date
});

const commentsSlice = createSlice({
  name: 'comments',
  initialState: commentsAdapter.getInitialState(),
  reducers: {
    commentAdded: commentsAdapter.addOne,
    commentRemoved: commentsAdapter.removeOne
  }
});

export const commentsSelectors = commentsAdapter.getSelectors(
  (state) => state.comments
);
```

### Pattern 3: Denormalized Selectors

```javascript
// Normalized state in store:
// users: { ids: [...], entities: {...} }
// posts: { ids: [...], entities: {...} }

// Denormalize for UI
export const selectPostsWithAuthors = createSelector(
  [postsSelectors.selectAll, usersSelectors.selectEntities],
  (posts, usersById) => {
    return posts.map(post => ({
      ...post,
      author: usersById[post.authorId]
    }));
  }
);

// Usage in component
function PostsList() {
  const postsWithAuthors = useSelector(selectPostsWithAuthors);
  
  return (
    <div>
      {postsWithAuthors.map(post => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>By {post.author.name}</p>
        </article>
      ))}
    </div>
  );
}
```

### Pattern 4: Filtered Selectors

```javascript
// Get posts by specific author
export const selectPostsByAuthor = createSelector(
  [postsSelectors.selectAll, (state, authorId) => authorId],
  (posts, authorId) => posts.filter(post => post.authorId === authorId)
);

// Usage
function AuthorPosts({ authorId }) {
  const posts = useSelector(state => 
    selectPostsByAuthor(state, authorId)
  );
  
  return <PostsList posts={posts} />;
}
```

### Pattern 5: Pagination with EntityAdapter

```javascript
const postsSlice = createSlice({
  name: 'posts',
  initialState: postsAdapter.getInitialState({
    currentPage: 1,
    pageSize: 10,
    totalCount: 0
  }),
  reducers: {
    pageChanged: (state, action) => {
      state.currentPage = action.payload;
    }
  },
  extraReducers: (builder) => {
    builder.addCase(fetchPosts.fulfilled, (state, action) => {
      postsAdapter.setAll(state, action.payload.items);
      state.totalCount = action.payload.total;
    });
  }
});

// Paginated selector
export const selectPaginatedPosts = createSelector(
  [
    postsSelectors.selectAll,
    (state) => state.posts.currentPage,
    (state) => state.posts.pageSize
  ],
  (posts, page, pageSize) => {
    const start = (page - 1) * pageSize;
    const end = start + pageSize;
    return posts.slice(start, end);
  }
);
```

### Pattern 6: Optimistic Updates

```javascript
export const updatePost = createAsyncThunk(
  'posts/update',
  async (post, { rejectWithValue }) => {
    try {
      const response = await fetch(`/api/posts/${post.id}`, {
        method: 'PUT',
        body: JSON.stringify(post)
      });
      return response.json();
    } catch (error) {
      return rejectWithValue(post.id);
    }
  }
);

const postsSlice = createSlice({
  name: 'posts',
  initialState: postsAdapter.getInitialState(),
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(updatePost.pending, (state, action) => {
        // Optimistic update
        postsAdapter.updateOne(state, {
          id: action.meta.arg.id,
          changes: action.meta.arg
        });
      })
      .addCase(updatePost.rejected, (state, action) => {
        // Rollback on error
        // You'd need to store original state to rollback properly
        console.error('Update failed:', action.payload);
      });
  }
});
```

---

## 8.7 Complete E-Commerce Example

```typescript
// productsSlice.ts
import {
  createSlice,
  createEntityAdapter,
  createAsyncThunk,
  createSelector,
  PayloadAction
} from '@reduxjs/toolkit';

interface Product {
  id: string;
  name: string;
  price: number;
  category: string;
  inStock: boolean;
  rating: number;
}

// Create adapter with custom sort
const productsAdapter = createEntityAdapter<Product>({
  sortComparer: (a, b) => a.name.localeCompare(b.name)
});

// Async thunk
export const fetchProducts = createAsyncThunk(
  'products/fetchAll',
  async () => {
    const response = await fetch('/api/products');
    return response.json();
  }
);

// Slice
const productsSlice = createSlice({
  name: 'products',
  initialState: productsAdapter.getInitialState({
    loading: false,
    error: null as string | null,
    selectedCategory: 'all' as string,
    searchTerm: '' as string
  }),
  reducers: {
    categoryChanged: (state, action: PayloadAction<string>) => {
      state.selectedCategory = action.payload;
    },
    searchTermChanged: (state, action: PayloadAction<string>) => {
      state.searchTerm = action.payload;
    },
    productStockUpdated: (state, action: PayloadAction<{ id: string; inStock: boolean }>) => {
      productsAdapter.updateOne(state, {
        id: action.payload.id,
        changes: { inStock: action.payload.inStock }
      });
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchProducts.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchProducts.fulfilled, (state, action) => {
        state.loading = false;
        productsAdapter.setAll(state, action.payload);
      })
      .addCase(fetchProducts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Failed to fetch';
      });
  }
});

export const {
  categoryChanged,
  searchTermChanged,
  productStockUpdated
} = productsSlice.actions;

export default productsSlice.reducer;

// Selectors
export const productsSelectors = productsAdapter.getSelectors(
  (state: RootState) => state.products
);

const selectCategory = (state: RootState) => state.products.selectedCategory;
const selectSearchTerm = (state: RootState) => state.products.searchTerm;

// Filtered products selector
export const selectFilteredProducts = createSelector(
  [productsSelectors.selectAll, selectCategory, selectSearchTerm],
  (products, category, searchTerm) => {
    let filtered = products;
    
    // Filter by category
    if (category !== 'all') {
      filtered = filtered.filter(p => p.category === category);
    }
    
    // Filter by search term
    if (searchTerm) {
      const term = searchTerm.toLowerCase();
      filtered = filtered.filter(p =>
        p.name.toLowerCase().includes(term)
      );
    }
    
    return filtered;
  }
);

// In-stock products
export const selectInStockProducts = createSelector(
  [selectFilteredProducts],
  (products) => products.filter(p => p.inStock)
);

// Products by category counts
export const selectCategoryCounts = createSelector(
  [productsSelectors.selectAll],
  (products) => {
    const counts: Record<string, number> = {};
    products.forEach(product => {
      counts[product.category] = (counts[product.category] || 0) + 1;
    });
    return counts;
  }
);
```

---

## Best Practices

### âœ… Do's

1. **Use EntityAdapter for collections**
```typescript
const adapter = createEntityAdapter<User>();
```

2. **Combine with async thunks**
```typescript
builder.addCase(fetchUsers.fulfilled, (state, action) => {
  adapter.setAll(state, action.payload);
});
```

3. **Export selectors from slices**
```typescript
export const usersSelectors = adapter.getSelectors(state => state.users);
```

4. **Use sortComparer for simple sorting**
```typescript
const adapter = createEntityAdapter({
  sortComparer: (a, b) => a.name.localeCompare(b.name)
});
```

5. **Denormalize in selectors, not reducers**
```typescript
const selectPostsWithAuthors = createSelector([...], (...) => denormalize(...));
```

### âŒ Don'ts

1. **Don't manually manage ids/entities**
```typescript
// âŒ Bad
state.ids.push(newId);
state.entities[newId] = newEntity;

// âœ… Good
adapter.addOne(state, newEntity);
```

2. **Don't use for simple data**
```typescript
// âŒ Overkill for simple state
const themeAdapter = createEntityAdapter();

// âœ… Better
const initialState = { mode: 'dark', color: 'blue' };
```

3. **Don't forget custom selectId**
```typescript
// âŒ If your entity uses 'userId'
const adapter = createEntityAdapter(); // Looks for 'id'

// âœ… Specify custom ID
const adapter = createEntityAdapter({
  selectId: (user) => user.userId
});
```

---

## Summary

EntityAdapter simplifies normalized state management:

| Feature | Benefit |
|---------|---------|
| **Standard structure** | ids + entities pattern |
| **CRUD methods** | addOne, updateOne, removeOne, etc. |
| **Generated selectors** | selectAll, selectById, etc. |
| **Automatic sorting** | sortComparer option |
| **Type-safe** | Full TypeScript support |

**Key Takeaways:**
1. Normalize relational/duplicated data
2. EntityAdapter provides standard CRUD operations
3. Use generated selectors for queries
4. Combine with async thunks for API integration
5. Denormalize in selectors for UI consumption
6. Custom sort for automatic ordering

Next: Chapter 9 covers RTK Query for advanced data fetching! ðŸš€