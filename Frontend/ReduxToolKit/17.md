# Chapter 17: Debugging and DevTools

## Overview

Debugging Redux applications is made easy with powerful tools. This chapter covers Redux DevTools, debugging techniques, common issues, and production debugging strategies.

---

## 17.1 Redux DevTools

### Installation

**Browser Extension:**

```bash
# Chrome
https://chrome.google.com/webstore/detail/redux-devtools

# Firefox
https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/

# Edge
https://microsoftedge.microsoft.com/addons/detail/redux-devtools
```

**Enable in Your App:**

```typescript
// Already enabled by default with configureStore!
const store = configureStore({
  reducer: rootReducer,
  // DevTools automatically enabled in development
});

// Or manually configure
const store = configureStore({
  reducer: rootReducer,
  devTools: process.env.NODE_ENV !== 'production' && {
    name: 'My App',
    trace: true,
    traceLimit: 25
  }
});
```

### DevTools Interface Overview

**Main Sections:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Action List ‚îÇ State Tree ‚îÇ Diff ‚îÇ Test     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ             ‚îÇ             ‚îÇ      ‚îÇ          ‚îÇ
‚îÇ @@INIT      ‚îÇ {           ‚îÇ      ‚îÇ          ‚îÇ
‚îÇ user/login  ‚îÇ   user: {   ‚îÇ +    ‚îÇ          ‚îÇ
‚îÇ todos/add   ‚îÇ     name:   ‚îÇ -    ‚îÇ          ‚îÇ
‚îÇ todos/toggle‚îÇ     email   ‚îÇ      ‚îÇ          ‚îÇ
‚îÇ             ‚îÇ   },        ‚îÇ      ‚îÇ          ‚îÇ
‚îÇ             ‚îÇ   todos: [] ‚îÇ      ‚îÇ          ‚îÇ
‚îÇ             ‚îÇ }           ‚îÇ      ‚îÇ          ‚îÇ
‚îÇ             ‚îÇ             ‚îÇ      ‚îÇ          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Key Features

#### 1. **Action History**

```typescript
// Click any action to see:
{
  type: 'todos/todoAdded',
  payload: {
    id: '1',
    text: 'Learn Redux',
    completed: false
  }
}

// See when it was dispatched
// View the resulting state change
// Jump to that point in time
```

#### 2. **State Inspector**

```typescript
// View current state tree
{
  user: {
    currentUser: {
      id: '123',
      name: 'John Doe',
      email: 'john@example.com'
    },
    isAuthenticated: true
  },
  todos: [
    { id: '1', text: 'Learn Redux', completed: false },
    { id: '2', text: 'Build App', completed: true }
  ],
  ui: {
    theme: 'dark',
    sidebarOpen: true
  }
}

// Can copy state as JSON
// Search for specific values
// Inspect nested objects
```

#### 3. **State Diff**

```typescript
// Before action:
{
  todos: [
    { id: '1', text: 'Learn Redux', completed: false }
  ]
}

// Action: todos/todoToggled { payload: '1' }

// After action (diff shows):
{
  todos: [
    { 
      id: '1', 
      text: 'Learn Redux', 
      completed: true  // ‚úÖ Changed from false to true
    }
  ]
}
```

---

## 17.2 Time-Travel Debugging

### How It Works

```typescript
// State at different points in time:

// Step 1: @@INIT
{ todos: [] }

// Step 2: todos/todoAdded
{ todos: [{ id: '1', text: 'Learn Redux', completed: false }] }

// Step 3: todos/todoAdded
{ todos: [
  { id: '1', text: 'Learn Redux', completed: false },
  { id: '2', text: 'Build App', completed: false }
] }

// Step 4: todos/todoToggled (id: '1')
{ todos: [
  { id: '1', text: 'Learn Redux', completed: true },  // ‚úÖ toggled
  { id: '2', text: 'Build App', completed: false }
] }

// Click on Step 2 ‚Üí State reverts to that point
// UI updates to show how app looked at that time
// Can move forward and backward through history
```

### Practical Use Cases

**1. Reproduce User-Reported Bugs:**

```typescript
// User says: "I added a todo, toggled it, then it disappeared"

// In DevTools:
// 1. Click through their actions
// 2. See exactly what happened at each step
// 3. Find the action that caused the bug
// 4. Fix the reducer
```

**2. Test Edge Cases:**

```typescript
// Manually dispatch actions to test edge cases
// Jump to specific state configurations
// Test undo/redo functionality
// Verify state transitions
```

### Slider Control

```typescript
// DevTools slider:
// [‚Üê] ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê [‚Üí]
//     Step 1 | 2 | 3 | 4 | 5

// Move slider to replay actions
// See UI update in real-time
// Perfect for demos and presentations
```

---

## 17.3 Action Filtering and Search

### Filter Actions

```typescript
// In DevTools action list filter:

// Show only user actions:
"user/*"

// Hide initialization:
"!@@INIT"

// Show only async actions:
"*/pending" OR "*/fulfilled" OR "*/rejected"

// Complex filter:
"todos/* && !todos/toggle"
// Shows all todos actions except toggle
```

### Search State

```typescript
// Search for specific values in state
Search: "john@example.com"

// Results:
{
  user: {
    currentUser: {
      email: "john@example.com"  // ‚úÖ Found
    }
  },
  settings: {
    notifications: {
      email: "john@example.com"  // ‚úÖ Found
    }
  }
}
```

### Action Search

```typescript
// Find specific action
Search: "todoAdded"

// Results:
todos/todoAdded - 10:32:45
todos/todoAdded - 10:33:12
todos/todoAdded - 10:35:02

// Click to jump to that action
```

---

## 17.4 Dispatch Actions Manually

### Test UI Without Clicking

```typescript
// In DevTools Dispatcher tab:

// Dispatch action directly:
{
  "type": "todos/todoAdded",
  "payload": {
    "id": "999",
    "text": "Test todo",
    "completed": false
  }
}

// Click "Dispatch" ‚Üí Action fires ‚Üí UI updates

// Great for:
// - Testing without UI interaction
// - Reproducing specific scenarios
// - QA testing
// - Demos
```

### Import/Export State

```typescript
// Export current state:
// Click "Export" ‚Üí Downloads state.json

{
  "user": { "currentUser": {...} },
  "todos": [...],
  "ui": {...}
}

// Import state:
// Click "Import" ‚Üí Upload state.json
// App instantly shows that state
// Perfect for:
// - Sharing bug reproductions
// - Testing specific configurations
// - E2E test setup
```

---

## 17.5 Debugging Techniques

### Console Logging

```typescript
// Log actions
const loggerMiddleware: Middleware = (storeAPI) => (next) => (action) => {
  console.group(action.type);
  console.log('Previous state:', storeAPI.getState());
  console.log('Action:', action);
  const result = next(action);
  console.log('Next state:', storeAPI.getState());
  console.groupEnd();
  return result;
};
```

### Breakpoints in Reducers

```typescript
const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    todoToggled: (state, action) => {
      debugger; // ‚¨ÖÔ∏è Add breakpoint
      
      const todo = state.find(t => t.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    }
  }
});

// When action dispatched:
// 1. Execution pauses at debugger
// 2. Inspect 'state' and 'action' in console
// 3. Step through code line by line
// 4. See exactly what's happening
```

### Conditional Breakpoints

```typescript
const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    todoToggled: (state, action) => {
      // Only break for specific todo
      if (action.payload === 'problem-todo-id') {
        debugger;
      }
      
      const todo = state.find(t => t.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    }
  }
});
```

### Selector Debugging

```typescript
const selectFilteredTodos = createSelector(
  [state => state.todos, state => state.filter],
  (todos, filter) => {
    console.log('Selector recalculating');
    console.log('Todos:', todos);
    console.log('Filter:', filter);
    
    const result = todos.filter(/* ... */);
    console.log('Result:', result);
    return result;
  }
);

// Track when selector runs
// See input values
// Debug computation logic
```

---

## 17.6 Common Issues and Solutions

### Issue 1: State Not Updating

**Symptom:** Dispatched action but UI doesn't update

**Debug steps:**

```typescript
// 1. Check DevTools - did action fire?
// Look in action list

// 2. Check reducer - is it handling the action?
const slice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    todoAdded: (state, action) => {
      console.log('Reducer called'); // ‚úÖ Does this log?
      state.push(action.payload);
    }
  }
});

// 3. Check if returning new reference
// ‚ùå Wrong:
state.todos.push(newTodo);
return state;  // Same reference!

// ‚úÖ Correct (with Immer):
state.todos.push(newTodo);  // Immer handles it

// 4. Check selector
const todos = useSelector(state => state.todos);
// Is 'todos' the right path?
```

### Issue 2: Too Many Re-renders

**Symptom:** Component renders too often

**Debug:**

```typescript
// 1. Check selector - creating new object?
// ‚ùå Bad - new object every time
const data = useSelector(state => ({
  user: state.user,
  posts: state.posts
}));

// ‚úÖ Good - use shallowEqual
import { shallowEqual } from 'react-redux';
const data = useSelector(
  state => ({ user: state.user, posts: state.posts }),
  shallowEqual
);

// 2. Track renders
function TodoList() {
  console.log('TodoList rendered');
  const todos = useSelector(state => state.todos);
  // Count how many times this logs
}

// 3. Use React DevTools Profiler
// See which components render and why
```

### Issue 3: Infinite Loop

**Symptom:** App freezes, DevTools shows endless actions

**Common causes:**

```typescript
// ‚ùå Cause 1: Dispatching in render
function BadComponent() {
  const dispatch = useDispatch();
  dispatch(someAction()); // ‚ö†Ô∏è Dispatches every render!
  return <div>Bad</div>;
}

// ‚úÖ Fix: Use useEffect
function GoodComponent() {
  const dispatch = useDispatch();
  useEffect(() => {
    dispatch(someAction());
  }, [dispatch]);
  return <div>Good</div>;
}

// ‚ùå Cause 2: Action triggers itself
builder.addCase(fetchData.fulfilled, (state, action) => {
  state.data = action.payload;
  dispatch(fetchData()); // ‚ö†Ô∏è Infinite loop!
});

// ‚úÖ Fix: Don't dispatch in reducer
// Dispatch in component or middleware instead

// ‚ùå Cause 3: useEffect dependency issues
useEffect(() => {
  dispatch(fetchData());
}, [data]); // ‚ö†Ô∏è Fetches new data, which updates 'data', which triggers effect...

// ‚úÖ Fix: Correct dependencies
useEffect(() => {
  dispatch(fetchData());
}, []); // Only on mount
```

### Issue 4: Async Thunk Not Working

**Debug:**

```typescript
// 1. Check thunk is dispatched
const promise = dispatch(fetchUsers());
console.log('Promise:', promise);

// 2. Check if it reaches fulfilled/rejected
extraReducers: (builder) => {
  builder
    .addCase(fetchUsers.pending, (state) => {
      console.log('Pending'); // ‚úÖ Does this log?
    })
    .addCase(fetchUsers.fulfilled, (state, action) => {
      console.log('Fulfilled:', action.payload); // ‚úÖ Does this log?
    })
    .addCase(fetchUsers.rejected, (state, action) => {
      console.log('Rejected:', action.error); // ‚ùå Error here?
    });
}

// 3. Check network tab
// Did API call succeed?

// 4. Check thunk error handling
export const fetchUsers = createAsyncThunk(
  'users/fetch',
  async (_, { rejectWithValue }) => {
    try {
      const response = await fetch('/api/users');
      if (!response.ok) {
        return rejectWithValue('Failed to fetch');
      }
      return response.json();
    } catch (error) {
      console.error('Thunk error:', error); // ‚úÖ Log errors
      return rejectWithValue(error.message);
    }
  }
);
```

### Issue 5: State Shape Mismatch

**Symptom:** Can't access expected properties

```typescript
// Expected:
state.user.profile.name

// Actual:
state.users.currentUser.name

// Debug:
// 1. Log entire state
console.log('Full state:', store.getState());

// 2. Check in DevTools
// Inspect state tree

// 3. Check slice configuration
const store = configureStore({
  reducer: {
    users: usersReducer,  // ‚Üê Note the key!
    // Not 'user', but 'users'
  }
});

// Fix: Update selector
const name = useSelector(state => state.users.currentUser.name);
```

---

## 17.7 Production Debugging

### Error Tracking Integration

```typescript
// Sentry integration
import * as Sentry from '@sentry/react';

const errorMiddleware: Middleware = (storeAPI) => (next) => (action) => {
  try {
    return next(action);
  } catch (error) {
    Sentry.captureException(error, {
      contexts: {
        redux: {
          action,
          state: storeAPI.getState()
        }
      }
    });
    throw error;
  }
};

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(errorMiddleware)
});
```

### Action Logging in Production

```typescript
// Log only errors to reduce overhead
const productionLogger: Middleware = (storeAPI) => (next) => (action) => {
  // Only log failed async actions
  if (action.type.endsWith('/rejected')) {
    console.error('Action failed:', {
      type: action.type,
      error: action.error,
      timestamp: new Date().toISOString()
    });
    
    // Send to logging service
    logToService({
      level: 'error',
      action,
      state: storeAPI.getState()
    });
  }
  
  return next(action);
};
```

### Session Replay

```typescript
// LogRocket integration
import LogRocket from 'logrocket';
import { setupLogRocketReact } from 'logrocket-react';

LogRocket.init('app-id');
setupLogRocketReact(LogRocket);

// Redux middleware
import { reduxMiddleware } from 'logrocket';

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(reduxMiddleware)
});

// Now you can replay user sessions!
// See all Redux actions they dispatched
// Debug exactly what they experienced
```

### Sanitizing Sensitive Data

```typescript
const store = configureStore({
  reducer: rootReducer,
  devTools: process.env.NODE_ENV !== 'production' && {
    // Sanitize actions
    actionSanitizer: (action) => {
      if (action.type === 'user/login') {
        return {
          ...action,
          payload: {
            ...action.payload,
            password: '***REDACTED***'
          }
        };
      }
      return action;
    },
    
    // Sanitize state
    stateSanitizer: (state) => ({
      ...state,
      auth: {
        ...state.auth,
        token: state.auth.token ? '***TOKEN***' : null,
        refreshToken: state.auth.refreshToken ? '***TOKEN***' : null
      }
    })
  }
});
```

---

## 17.8 RTK Query DevTools

### Inspecting Cache

```typescript
// In DevTools state tree:
{
  api: {
    queries: {
      'getPosts(undefined)': {
        status: 'fulfilled',
        endpointName: 'getPosts',
        requestId: 'abc123',
        data: [...],
        fulfilledTimeStamp: 1234567890
      },
      'getPost({"id":"1"})': {
        status: 'fulfilled',
        data: {...}
      }
    },
    mutations: {},
    provided: {
      Posts: ['LIST', { type: 'Posts', id: 1 }]
    },
    subscriptions: {
      'getPosts(undefined)': {
        'componentId1': { pollingInterval: 0 }
      }
    }
  }
}

// Can see:
// - Which queries are cached
// - Query status (pending/fulfilled/rejected)
// - Cache data
// - Active subscriptions
// - Provided tags
```

### Monitoring Subscriptions

```typescript
// Check which components are subscribed
api: {
  subscriptions: {
    'getPosts(undefined)': {
      'PostsList_123': { pollingInterval: 0 },
      'Dashboard_456': { pollingInterval: 5000 }
    }
  }
}

// When all components unmount:
// Subscription count ‚Üí 0
// Cache entry removed after cacheTime
```

### Debugging Cache Invalidation

```typescript
// Check provided tags
api: {
  provided: {
    Posts: [
      'LIST',
      { type: 'Posts', id: 1 },
      { type: 'Posts', id: 2 }
    ]
  }
}

// After mutation that invalidates 'Posts':
// 1. Tags removed from provided
// 2. Related queries marked for refetch
// 3. Components re-request data
// 4. New data appears in cache

// Can trace entire flow in DevTools!
```

---

## Debugging Checklist

### Before Asking for Help

- [ ] Check Redux DevTools for action history
- [ ] Verify action was dispatched
- [ ] Check reducer handles the action
- [ ] Inspect state tree for data
- [ ] Look for errors in console
- [ ] Check network tab for API calls
- [ ] Verify selector path is correct
- [ ] Test with different data
- [ ] Check for React re-render issues
- [ ] Review recent code changes

### When Reporting Bugs

Include:
- [ ] Exported Redux state
- [ ] Action that caused issue
- [ ] Expected vs actual behavior
- [ ] Steps to reproduce
- [ ] Screenshots of DevTools
- [ ] Browser and version
- [ ] Redux and RTK versions

---

## Best Practices

### ‚úÖ Do's

1. **Use DevTools during development**
```typescript
// Always have DevTools open
// Track all state changes
// Use time-travel debugging
```

2. **Log strategically**
```typescript
// Log at decision points
if (shouldDoSomething) {
  console.log('Condition met');
}
```

3. **Sanitize production data**
```typescript
actionSanitizer: (action) => sanitize(action)
```

4. **Use error boundaries**
```typescript
<ErrorBoundary>
  <App />
</ErrorBoundary>
```

### ‚ùå Don'ts

1. **Don't leave debugger statements**
```typescript
// ‚ùå Remove before committing
debugger;
```

2. **Don't log sensitive data**
```typescript
// ‚ùå Bad
console.log('Password:', password);
```

3. **Don't ignore DevTools warnings**
```typescript
// ‚ö†Ô∏è "State mutation detected"
// ‚ö†Ô∏è "Non-serializable value"
// Fix these!
```

---

## Summary

Redux debugging tools:

| Tool | Purpose |
|------|---------|
| **DevTools** | Inspect state, actions, time-travel |
| **Console logging** | Quick debugging |
| **Breakpoints** | Step through code |
| **Sentry/LogRocket** | Production errors |
| **React DevTools** | Component issues |

**Key Takeaways:**
1. Redux DevTools is essential
2. Time-travel debugging saves hours
3. Export/import state for bug reports
4. Sanitize sensitive data
5. Use error tracking in production
6. Debug systematically
7. Check DevTools first

Next: Chapter 18 covers Security Considerations! üöÄ