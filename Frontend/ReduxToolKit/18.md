# Chapter 18: Security Considerations

## Overview

Security is critical for production applications. This chapter covers Redux-specific security concerns, best practices for handling sensitive data, and protecting your application from common vulnerabilities.

---

## 18.1 Sensitive Data in State

### What NOT to Store in Redux

```typescript
// ‚ùå NEVER store these in Redux:
const badSlice = createSlice({
  name: 'auth',
  initialState: {
    password: '',              // ‚ùå Never store passwords
    creditCard: '',            // ‚ùå Never store full credit card numbers
    ssn: '',                   // ‚ùå Never store SSN
    apiSecret: '',             // ‚ùå Never store API secrets
    privateKey: ''             // ‚ùå Never store private keys
  }
});

// ‚úÖ What you CAN store:
const goodSlice = createSlice({
  name: 'auth',
  initialState: {
    token: null,               // ‚úÖ JWT tokens (but be careful)
    userId: null,              // ‚úÖ User ID
    username: null,            // ‚úÖ Username
    permissions: [],           // ‚úÖ User permissions
    lastFourDigits: null       // ‚úÖ Last 4 digits of card (if needed)
  }
});
```

### Token Storage Best Practices

```typescript
// ‚ö†Ô∏è Storing tokens in Redux
const authSlice = createSlice({
  name: 'auth',
  initialState: {
    token: null,  // Accessible in DevTools!
    refreshToken: null
  },
  reducers: {
    tokenReceived: (state, action) => {
      state.token = action.payload.token;
      // ‚ö†Ô∏è Consider: Do you need token in Redux?
      // Or just in httpOnly cookie?
    }
  }
});

// ‚úÖ Better: Store token in httpOnly cookie
// Only store token existence flag in Redux
const authSlice = createSlice({
  name: 'auth',
  initialState: {
    isAuthenticated: false,
    user: null
  },
  reducers: {
    loginSuccess: (state, action) => {
      // Token sent as httpOnly cookie by server
      state.isAuthenticated = true;
      state.user = action.payload.user;
    }
  }
});

// API calls automatically include cookie
fetch('/api/data', {
  credentials: 'include'  // Include httpOnly cookie
});
```

### Encryption for Sensitive Data

```typescript
// If you MUST store sensitive data temporarily
import CryptoJS from 'crypto-js';

// Encrypt before storing
const encryptData = (data: string, key: string): string => {
  return CryptoJS.AES.encrypt(data, key).toString();
};

// Decrypt when retrieving
const decryptData = (encrypted: string, key: string): string => {
  const bytes = CryptoJS.AES.decrypt(encrypted, key);
  return bytes.toString(CryptoJS.enc.Utf8);
};

// Usage
const slice = createSlice({
  name: 'sensitive',
  initialState: { encryptedData: null },
  reducers: {
    dataStored: (state, action) => {
      // Encrypt before storing
      state.encryptedData = encryptData(
        action.payload,
        process.env.REACT_APP_ENCRYPTION_KEY!
      );
    }
  }
});

// Selector with decryption
const selectDecryptedData = createSelector(
  [state => state.sensitive.encryptedData],
  (encrypted) => {
    if (!encrypted) return null;
    return decryptData(encrypted, process.env.REACT_APP_ENCRYPTION_KEY!);
  }
);
```

---

## 18.2 XSS Prevention

### Input Sanitization

```typescript
// ‚ùå Dangerous: Storing unsanitized user input
const messagesSlice = createSlice({
  name: 'messages',
  initialState: { items: [] },
  reducers: {
    messageAdded: (state, action) => {
      // User input stored directly
      state.items.push({
        text: action.payload,  // Could contain <script> tags!
        timestamp: Date.now()
      });
    }
  }
});

// ‚úÖ Better: Sanitize input
import DOMPurify from 'dompurify';

const messagesSlice = createSlice({
  name: 'messages',
  initialState: { items: [] },
  reducers: {
    messageAdded: (state, action) => {
      state.items.push({
        text: DOMPurify.sanitize(action.payload),  // ‚úÖ Sanitized
        timestamp: Date.now()
      });
    }
  }
});
```

### Safe Rendering

```typescript
// ‚ùå Dangerous: Using dangerouslySetInnerHTML
function Message({ text }) {
  return (
    <div dangerouslySetInnerHTML={{ __html: text }} />
    // If text contains <script>, it will execute!
  );
}

// ‚úÖ Safe: Let React escape content
function Message({ text }) {
  return <div>{text}</div>;
  // React automatically escapes HTML
}

// ‚úÖ If you need HTML: Sanitize first
import DOMPurify from 'dompurify';

function Message({ text }) {
  const sanitized = DOMPurify.sanitize(text);
  return <div dangerouslySetInnerHTML={{ __html: sanitized }} />;
}
```

### Content Security Policy

```typescript
// In your HTML or server headers:
<meta
  http-equiv="Content-Security-Policy"
  content="
    default-src 'self';
    script-src 'self' 'unsafe-inline' https://trusted-cdn.com;
    style-src 'self' 'unsafe-inline';
    img-src 'self' data: https:;
    connect-src 'self' https://api.example.com;
  "
/>

// Prevents:
// - Inline script execution (XSS)
// - Loading resources from untrusted origins
// - Eval and similar unsafe operations
```

---

## 18.3 CSRF Protection

### Token-Based Protection

```typescript
// Server sends CSRF token
const authSlice = createSlice({
  name: 'auth',
  initialState: {
    user: null,
    csrfToken: null  // Store CSRF token
  },
  reducers: {
    loginSuccess: (state, action) => {
      state.user = action.payload.user;
      state.csrfToken = action.payload.csrfToken;
    }
  }
});

// Include CSRF token in requests
export const updateProfile = createAsyncThunk(
  'user/updateProfile',
  async (data, { getState }) => {
    const state = getState() as RootState;
    const csrfToken = state.auth.csrfToken;
    
    const response = await fetch('/api/user/profile', {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken  // Include CSRF token
      },
      body: JSON.stringify(data)
    });
    
    return response.json();
  }
);
```

### SameSite Cookies

```typescript
// Server sets cookies with SameSite attribute
// Set-Cookie: sessionId=abc123; SameSite=Strict; Secure; HttpOnly

// Prevents CSRF by:
// - Not sending cookies on cross-site requests
// - SameSite=Strict: Never sent cross-site
// - SameSite=Lax: Sent on top-level navigation only

// In your API configuration:
const api = createApi({
  baseQuery: fetchBaseQuery({
    baseUrl: '/api',
    credentials: 'same-origin'  // Only send cookies to same origin
  }),
  endpoints: (builder) => ({
    // endpoints...
  })
});
```

---

## 18.4 Secure API Communication

### HTTPS Enforcement

```typescript
// ‚ùå Never use HTTP for production APIs
const api = createApi({
  baseQuery: fetchBaseQuery({
    baseUrl: 'http://api.example.com'  // ‚ùå Insecure!
  })
});

// ‚úÖ Always use HTTPS
const api = createApi({
  baseQuery: fetchBaseQuery({
    baseUrl: 'https://api.example.com'  // ‚úÖ Secure
  })
});

// Redirect HTTP to HTTPS in your app
if (window.location.protocol === 'http:' && process.env.NODE_ENV === 'production') {
  window.location.href = window.location.href.replace('http:', 'https:');
}
```

### API Key Management

```typescript
// ‚ùå NEVER hardcode API keys
const api = createApi({
  baseQuery: fetchBaseQuery({
    baseUrl: 'https://api.example.com',
    prepareHeaders: (headers) => {
      headers.set('X-API-Key', 'hardcoded-key-123');  // ‚ùå Exposed in source!
      return headers;
    }
  })
});

// ‚úÖ Use environment variables
const api = createApi({
  baseQuery: fetchBaseQuery({
    baseUrl: 'https://api.example.com',
    prepareHeaders: (headers) => {
      headers.set('X-API-Key', process.env.REACT_APP_API_KEY!);  // ‚úÖ From .env
      return headers;
    }
  })
});

// .env file (not committed to git!)
REACT_APP_API_KEY=your-api-key-here

// .gitignore
.env
.env.local
```

### Rate Limiting

```typescript
// Client-side rate limiting
class RateLimiter {
  private requests: number[] = [];
  private limit: number;
  private window: number;
  
  constructor(limit: number, windowMs: number) {
    this.limit = limit;
    this.window = windowMs;
  }
  
  canMakeRequest(): boolean {
    const now = Date.now();
    
    // Remove old requests outside window
    this.requests = this.requests.filter(
      time => now - time < this.window
    );
    
    // Check if under limit
    if (this.requests.length < this.limit) {
      this.requests.push(now);
      return true;
    }
    
    return false;
  }
}

const limiter = new RateLimiter(100, 60000); // 100 requests per minute

// Rate-limiting middleware
const rateLimitMiddleware: Middleware = (storeAPI) => (next) => (action) => {
  // Only rate-limit API calls
  if (action.type.includes('/pending')) {
    if (!limiter.canMakeRequest()) {
      console.warn('Rate limit exceeded');
      return; // Block the action
    }
  }
  
  return next(action);
};
```

---

## 18.5 Authentication Headers

### JWT Token Management

```typescript
const api = createApi({
  baseQuery: fetchBaseQuery({
    baseUrl: 'https://api.example.com',
    prepareHeaders: (headers, { getState }) => {
      const token = (getState() as RootState).auth.token;
      
      if (token) {
        headers.set('Authorization', `Bearer ${token}`);
      }
      
      return headers;
    }
  }),
  endpoints: (builder) => ({
    // endpoints...
  })
});
```

### Token Expiration Handling

```typescript
// Middleware to handle expired tokens
const tokenExpirationMiddleware: Middleware = (storeAPI) => (next) => (action) => {
  // Check for 401 Unauthorized responses
  if (action.type.includes('/rejected') && action.payload?.status === 401) {
    // Token expired - logout user
    storeAPI.dispatch(logout());
    
    // Redirect to login
    window.location.href = '/login';
  }
  
  return next(action);
};
```

### Automatic Token Refresh

```typescript
let refreshPromise: Promise<any> | null = null;

const tokenRefreshMiddleware: Middleware = (storeAPI) => (next) => async (action) => {
  const state = storeAPI.getState() as RootState;
  const token = state.auth.token;
  
  // Check if token is about to expire
  if (token && isTokenExpiringSoon(token)) {
    // Prevent multiple refresh attempts
    if (!refreshPromise) {
      refreshPromise = storeAPI.dispatch(refreshToken()).finally(() => {
        refreshPromise = null;
      });
    }
    
    // Wait for refresh to complete
    await refreshPromise;
  }
  
  return next(action);
};

function isTokenExpiringSoon(token: string): boolean {
  try {
    const payload = JSON.parse(atob(token.split('.')[1]));
    const expiresAt = payload.exp * 1000;
    const now = Date.now();
    
    // Refresh if token expires in less than 5 minutes
    return expiresAt - now < 5 * 60 * 1000;
  } catch {
    return false;
  }
}
```

---

## 18.6 Data Validation

### Input Validation

```typescript
// Validate data before storing
import { z } from 'zod';

const UserSchema = z.object({
  id: z.string().uuid(),
  username: z.string().min(3).max(20),
  email: z.string().email(),
  age: z.number().min(13).max(120).optional()
});

const usersSlice = createSlice({
  name: 'users',
  initialState: { items: [] },
  reducers: {
    userAdded: (state, action) => {
      try {
        // Validate before storing
        const validatedUser = UserSchema.parse(action.payload);
        state.items.push(validatedUser);
      } catch (error) {
        console.error('Invalid user data:', error);
        // Don't add invalid data
      }
    }
  }
});
```

### API Response Validation

```typescript
export const fetchUser = createAsyncThunk(
  'users/fetchById',
  async (userId: string, { rejectWithValue }) => {
    try {
      const response = await fetch(`/api/users/${userId}`);
      const data = await response.json();
      
      // Validate response
      const validatedData = UserSchema.parse(data);
      return validatedData;
      
    } catch (error) {
      if (error instanceof z.ZodError) {
        return rejectWithValue('Invalid data from server');
      }
      return rejectWithValue('Failed to fetch user');
    }
  }
);
```

---

## 18.7 Secure Redux DevTools

### Production Configuration

```typescript
const store = configureStore({
  reducer: rootReducer,
  devTools: process.env.NODE_ENV !== 'production'
  // ‚úÖ DevTools completely disabled in production
});
```

### Sanitizing DevTools Data

```typescript
const store = configureStore({
  reducer: rootReducer,
  devTools: process.env.NODE_ENV !== 'production' && {
    // Sanitize actions
    actionSanitizer: (action) => {
      // Remove sensitive data from actions
      if (action.type === 'user/login' || action.type === 'user/register') {
        return {
          ...action,
          payload: {
            ...action.payload,
            password: '***REDACTED***',
            email: action.payload.email?.replace(/(.{2}).*(@.*)/, '$1***$2')
          }
        };
      }
      return action;
    },
    
    // Sanitize state
    stateSanitizer: (state) => ({
      ...state,
      auth: {
        ...state.auth,
        token: state.auth.token ? '***TOKEN***' : null,
        refreshToken: state.auth.refreshToken ? '***TOKEN***' : null
      },
      payment: {
        ...state.payment,
        cardNumber: state.payment.cardNumber 
          ? `****-****-****-${state.payment.cardNumber.slice(-4)}`
          : null
      }
    }),
    
    // Limit action history
    maxAge: 25,  // Keep only last 25 actions
    
    // Don't trace sensitive actions
    trace: false,
    traceLimit: 0
  }
});
```

---

## 18.8 Preventing State Injection

### Validate Initial State

```typescript
// When hydrating state from localStorage or URL
function loadState(): RootState | undefined {
  try {
    const serialized = localStorage.getItem('state');
    
    if (!serialized) {
      return undefined;
    }
    
    const parsed = JSON.parse(serialized);
    
    // ‚úÖ Validate state structure
    if (!isValidState(parsed)) {
      console.warn('Invalid state in localStorage');
      localStorage.removeItem('state');
      return undefined;
    }
    
    return parsed;
    
  } catch (error) {
    console.error('Failed to load state:', error);
    return undefined;
  }
}

function isValidState(state: any): state is RootState {
  // Validate expected structure
  return (
    typeof state === 'object' &&
    state !== null &&
    'user' in state &&
    'todos' in state &&
    // Check critical fields aren't malicious
    !containsMaliciousData(state)
  );
}

function containsMaliciousData(data: any): boolean {
  const str = JSON.stringify(data);
  
  // Check for suspicious patterns
  const suspiciousPatterns = [
    /<script/i,
    /javascript:/i,
    /onerror=/i,
    /onclick=/i
  ];
  
  return suspiciousPatterns.some(pattern => pattern.test(str));
}
```

---

## 18.9 Security Checklist

### Development Checklist

- [ ] No sensitive data in Redux state
- [ ] Input sanitization implemented
- [ ] Output escaping (React handles this)
- [ ] CSRF protection configured
- [ ] HTTPS enforced
- [ ] API keys in environment variables
- [ ] Rate limiting implemented
- [ ] Token expiration handling
- [ ] Data validation on all inputs
- [ ] DevTools sanitized/disabled for production

### Production Checklist

- [ ] DevTools completely disabled
- [ ] All API calls use HTTPS
- [ ] Tokens stored securely (httpOnly cookies preferred)
- [ ] CSP headers configured
- [ ] No console.log statements with sensitive data
- [ ] Error messages don't leak sensitive info
- [ ] Rate limiting active
- [ ] Authentication headers secure
- [ ] State persistence validated
- [ ] Security headers configured (CORS, etc.)

### Code Review Checklist

```typescript
// Check for these patterns:
// ‚ùå Storing passwords
// ‚ùå Hardcoded API keys
// ‚ùå HTTP API calls
// ‚ùå dangerouslySetInnerHTML without sanitization
// ‚ùå eval() or Function() constructor
// ‚ùå Unsanitized user input
// ‚ùå Token in Redux without encryption
// ‚ùå DevTools enabled in production
```

---

## 18.10 Incident Response

### Security Breach Detection

```typescript
// Monitor for suspicious activity
const securityMonitoringMiddleware: Middleware = (storeAPI) => (next) => (action) => {
  // Detect rapid-fire actions (potential bot)
  if (isRapidFireActivity(action)) {
    console.warn('Suspicious activity detected');
    reportSecurityEvent('rapid_fire_actions', action);
  }
  
  // Detect unusual action patterns
  if (isUnusualPattern(action)) {
    reportSecurityEvent('unusual_pattern', action);
  }
  
  return next(action);
};

function reportSecurityEvent(type: string, data: any) {
  // Send to security monitoring service
  fetch('/api/security/report', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      type,
      timestamp: Date.now(),
      data,
      userAgent: navigator.userAgent
    })
  });
}
```

### Emergency Procedures

```typescript
// Kill switch for security incidents
const EMERGENCY_MODE = false; // Set to true if breach detected

if (EMERGENCY_MODE) {
  // 1. Force logout all users
  store.dispatch(logout());
  
  // 2. Clear all local storage
  localStorage.clear();
  sessionStorage.clear();
  
  // 3. Redirect to maintenance page
  window.location.href = '/maintenance';
  
  // 4. Disable API calls
  // (implement in baseQuery)
}
```

---

## Best Practices Summary

### ‚úÖ Do's

1. **Use HTTPS everywhere**
```typescript
baseUrl: 'https://api.example.com'
```

2. **Sanitize user input**
```typescript
DOMPurify.sanitize(userInput)
```

3. **Store tokens securely**
```typescript
// httpOnly cookies (server-side) or encrypted storage
```

4. **Validate all data**
```typescript
UserSchema.parse(data)
```

5. **Disable DevTools in production**
```typescript
devTools: process.env.NODE_ENV !== 'production'
```

### ‚ùå Don'ts

1. **Don't store passwords**
```typescript
// ‚ùå Never
initialState: { password: '' }
```

2. **Don't hardcode secrets**
```typescript
// ‚ùå Never
const API_KEY = 'secret-key-123'
```

3. **Don't trust client data**
```typescript
// ‚ùå Always validate
```

4. **Don't use HTTP**
```typescript
// ‚ùå Never in production
```

5. **Don't expose DevTools**
```typescript
// ‚ùå In production
```

---

## Summary

Security essentials:

| Concern | Solution |
|---------|----------|
| **Sensitive data** | Don't store in Redux |
| **XSS** | Sanitize input, escape output |
| **CSRF** | Tokens, SameSite cookies |
| **API security** | HTTPS, auth headers |
| **DevTools** | Sanitize, disable in prod |
| **Tokens** | httpOnly cookies or encrypt |

**Key Takeaways:**
1. Never store passwords/secrets in Redux
2. Always use HTTPS
3. Sanitize all user input
4. Validate all data
5. Disable DevTools in production
6. Use httpOnly cookies for tokens
7. Implement CSP headers
8. Monitor for suspicious activity

**Congratulations!** üéâ You've completed all 18 chapters of Redux Toolkit mastery! You're now equipped to build secure, performant, production-grade Redux applications!

---

## Final Security Resources

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [React Security Best Practices](https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml)
- [JWT Best Practices](https://tools.ietf.org/html/rfc8725)
- [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)

**Stay secure! üîí**