# Chapter 1: Redux Fundamentals (Prerequisites)

## Overview

Before diving into Redux Toolkit, understanding core Redux concepts is essential. Redux is a predictable state container for JavaScript applications that helps you manage application state in a consistent, traceable way.

---

## 1.1 Core Redux Concepts

### State Management Philosophy

**What is State?**
State is the data that drives your application at any given moment. In React, this could be:
- User information
- Form inputs
- API data
- UI states (modals open/closed, loading indicators)

**Why Do We Need Redux?**

Without Redux, in a large React application:
```
Component A (has data)
    ↓ props
Component B
    ↓ props
Component C
    ↓ props
Component D (needs data) ❌ Prop drilling nightmare!
```

With Redux:
```
         Redux Store (Single source of truth)
              ↓ ↓ ↓
    Component A  Component B  Component D
    ✅ Any component can access state directly
```

### Three Core Principles

#### 1. **Single Source of Truth**

The entire application state is stored in a single JavaScript object called the **store**.

```javascript
// ❌ Without Redux - State scattered everywhere
function App() {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState([]);
  const [comments, setComments] = useState([]);
  // State is everywhere!
}

// ✅ With Redux - One centralized store
const store = {
  user: { id: 1, name: 'John' },
  posts: [...],
  comments: [...]
}
```

**Benefits:**
- Easier to debug (one place to look)
- Easier to persist state
- Enables time-travel debugging
- Simplifies server-side rendering

#### 2. **State is Read-Only**

The only way to change state is to emit an **action** - an object describing what happened.

```javascript
// ❌ NEVER mutate state directly
state.user.name = 'Jane'; // BIG NO-NO!

// ✅ Dispatch an action
dispatch({
  type: 'USER_NAME_CHANGED',
  payload: 'Jane'
});
```

**Why is this important?**
- Makes state changes predictable
- Enables time-travel debugging (you can replay actions)
- Actions are serializable (can be logged, stored, replayed)
- Easier to test

#### 3. **Changes Made with Pure Functions**

To specify how state changes in response to actions, you write pure **reducers**.

**Pure Function Characteristics:**
1. Same input → Same output (deterministic)
2. No side effects (no API calls, no mutations)
3. No randomness (no Math.random(), Date.now())

```javascript
// ✅ Pure Function - Redux Reducer
function counterReducer(state = 0, action) {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1; // Returns NEW state
    case 'DECREMENT':
      return state - 1;
    default:
      return state;
  }
}

// ❌ Impure Function - Has side effects
function impureReducer(state = 0, action) {
  console.log('Action:', action); // Side effect: logging
  fetch('/api/log'); // Side effect: API call
  return state + Math.random(); // Non-deterministic
}
```

### Immutability Principles

**What is Immutability?**
Never modifying existing objects/arrays; instead, creating new ones.

```javascript
// ❌ WRONG - Mutating original state
function badReducer(state, action) {
  state.count++; // Mutating!
  return state; // Same reference
}

// ✅ CORRECT - Creating new state
function goodReducer(state, action) {
  return {
    ...state, // Spread existing properties
    count: state.count + 1 // New value
  };
}
```

**Why Immutability?**

```javascript
const oldState = { count: 1 };
const newState = oldState; // Same reference
newState.count = 2;

console.log(oldState.count); // 2 ❌ Original mutated!
console.log(oldState === newState); // true ❌ React won't re-render!

// Correct way
const oldState2 = { count: 1 };
const newState2 = { ...oldState2, count: 2 }; // New object

console.log(oldState2.count); // 1 ✅
console.log(oldState2 === newState2); // false ✅ React detects change!
```

### Unidirectional Data Flow

Redux enforces a strict one-way data flow:

```
┌─────────────────────────────────────────────────┐
│                                                 │
│  User clicks button                             │
│         ↓                                       │
│  dispatch(action)                               │
│         ↓                                       │
│  Middleware (optional)                          │
│         ↓                                       │
│  Reducer processes action                       │
│         ↓                                       │
│  Store updated with new state                   │
│         ↓                                       │
│  Components re-render with new state            │
│         ↓                                       │
│  User sees updated UI                           │
│                                                 │
└─────────────────────────────────────────────────┘
```

**Example Flow:**

```javascript
// 1. User clicks increment button
<button onClick={() => dispatch({ type: 'INCREMENT' })}>
  +
</button>

// 2. Action dispatched to store
{ type: 'INCREMENT' }

// 3. Reducer creates new state
function reducer(state = 0, action) {
  return state + 1; // 0 → 1
}

// 4. Store notified, components re-render
function Counter() {
  const count = useSelector(state => state.count); // Gets 1
  return <div>{count}</div>; // Shows "1"
}
```

---

## 1.2 Redux Core Building Blocks

### The Store

The store is the single source of truth that holds the application state.

**Creating a Store (Vanilla Redux):**

```javascript
import { createStore } from 'redux';

// Reducer
function counterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

// Create store
const store = createStore(counterReducer);
```

**Store Methods:**

#### 1. `getState()` - Read Current State

```javascript
const currentState = store.getState();
console.log(currentState); // { count: 0 }
```

#### 2. `dispatch(action)` - Update State

```javascript
store.dispatch({ type: 'INCREMENT' });
console.log(store.getState()); // { count: 1 }

store.dispatch({ type: 'INCREMENT' });
console.log(store.getState()); // { count: 2 }
```

#### 3. `subscribe(listener)` - Watch for Changes

```javascript
// Subscribe to store changes
const unsubscribe = store.subscribe(() => {
  console.log('State changed:', store.getState());
});

store.dispatch({ type: 'INCREMENT' }); 
// Logs: State changed: { count: 1 }

// Stop listening
unsubscribe();

store.dispatch({ type: 'INCREMENT' });
// Nothing logged (unsubscribed)
```

**Complete Store Example:**

```javascript
import { createStore } from 'redux';

// Initial state
const initialState = {
  count: 0,
  user: null
};

// Reducer
function rootReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    case 'SET_USER':
      return { ...state, user: action.payload };
    default:
      return state;
  }
}

// Create store
const store = createStore(rootReducer);

// Use the store
console.log(store.getState()); 
// { count: 0, user: null }

store.dispatch({ type: 'INCREMENT' });
console.log(store.getState()); 
// { count: 1, user: null }

store.dispatch({ 
  type: 'SET_USER', 
  payload: { id: 1, name: 'John' } 
});
console.log(store.getState()); 
// { count: 1, user: { id: 1, name: 'John' } }
```

### Actions

Actions are plain JavaScript objects that describe "what happened" in the application.

**Action Structure:**

```javascript
// Minimum requirement: type property
{
  type: 'INCREMENT'
}

// With data
{
  type: 'ADD_TODO',
  payload: {
    id: 1,
    text: 'Learn Redux',
    completed: false
  }
}

// With metadata
{
  type: 'FETCH_USER_SUCCESS',
  payload: { id: 1, name: 'John' },
  meta: { timestamp: Date.now() }
}
```

**Action Type Conventions:**

```javascript
// ✅ Good - Descriptive, past tense
'TODO_ADDED'
'USER_LOGGED_IN'
'FORM_SUBMITTED'
'DATA_FETCH_SUCCEEDED'

// ❌ Bad - Vague, imperative
'ADD'
'LOGIN'
'SUBMIT'
'FETCH'
```

**Action Creators:**

Functions that create and return action objects:

```javascript
// Without action creator - repetitive
store.dispatch({ 
  type: 'ADD_TODO', 
  payload: { id: 1, text: 'Learn Redux' } 
});

store.dispatch({ 
  type: 'ADD_TODO', 
  payload: { id: 2, text: 'Build App' } 
});

// ✅ With action creator - DRY (Don't Repeat Yourself)
function addTodo(id, text) {
  return {
    type: 'ADD_TODO',
    payload: { id, text, completed: false }
  };
}

store.dispatch(addTodo(1, 'Learn Redux'));
store.dispatch(addTodo(2, 'Build App'));
```

**Action Types as Constants:**

```javascript
// actionTypes.js
export const ADD_TODO = 'ADD_TODO';
export const REMOVE_TODO = 'REMOVE_TODO';
export const TOGGLE_TODO = 'TOGGLE_TODO';

// actions.js
import { ADD_TODO, REMOVE_TODO, TOGGLE_TODO } from './actionTypes';

export const addTodo = (id, text) => ({
  type: ADD_TODO,
  payload: { id, text }
});

export const removeTodo = (id) => ({
  type: REMOVE_TODO,
  payload: id
});

// reducer.js
import { ADD_TODO, REMOVE_TODO } from './actionTypes';

function todoReducer(state = [], action) {
  switch (action.type) {
    case ADD_TODO:
      return [...state, action.payload];
    case REMOVE_TODO:
      return state.filter(todo => todo.id !== action.payload);
    default:
      return state;
  }
}
```

**Why Use Constants?**
- Prevents typos (`'ADD_TODO'` vs `'ADD_TOOD'`)
- IDE autocomplete
- Easy refactoring
- Compile-time errors instead of runtime bugs

### Reducers

Reducers specify how the application's state changes in response to actions.

**Reducer Signature:**

```javascript
(previousState, action) => newState
```

**Basic Reducer Example:**

```javascript
const initialState = {
  count: 0
};

function counterReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return {
        ...state,
        count: state.count + 1
      };
    case 'DECREMENT':
      return {
        ...state,
        count: state.count - 1
      };
    case 'RESET':
      return initialState;
    default:
      return state; // Always return state for unknown actions
  }
}
```

**Reducer Rules:**

1. **Must be Pure Functions**
```javascript
// ❌ WRONG - Impure
function badReducer(state, action) {
  console.log(action); // Side effect
  state.count++; // Mutation
  return state;
}

// ✅ CORRECT - Pure
function goodReducer(state, action) {
  return {
    ...state,
    count: state.count + 1
  };
}
```

2. **Must Return State for Unknown Actions**
```javascript
function reducer(state = initialState, action) {
  switch (action.type) {
    case 'KNOWN_ACTION':
      return { ...state, value: action.payload };
    default:
      return state; // ✅ Essential!
  }
}
```

3. **Must Not Mutate State**

```javascript
// ❌ MUTATIONS - Don't do these!
state.count = 5; // Direct mutation
state.todos.push(newTodo); // Array mutation
state.user.name = 'Jane'; // Nested mutation
delete state.oldProp; // Deletion mutation

// ✅ IMMUTABLE UPDATES - Do these!
return { ...state, count: 5 }; // New object
return { ...state, todos: [...state.todos, newTodo] }; // New array
return { ...state, user: { ...state.user, name: 'Jane' } }; // Nested update
const { oldProp, ...rest } = state; return rest; // Deletion
```

**Complex State Updates:**

```javascript
const initialState = {
  users: [
    { id: 1, name: 'John', age: 30 },
    { id: 2, name: 'Jane', age: 25 }
  ],
  currentUserId: null
};

function userReducer(state = initialState, action) {
  switch (action.type) {
    case 'UPDATE_USER':
      return {
        ...state,
        users: state.users.map(user =>
          user.id === action.payload.id
            ? { ...user, ...action.payload.updates }
            : user
        )
      };
    
    case 'DELETE_USER':
      return {
        ...state,
        users: state.users.filter(user => user.id !== action.payload)
      };
    
    case 'SET_CURRENT_USER':
      return {
        ...state,
        currentUserId: action.payload
      };
    
    default:
      return state;
  }
}

// Usage
const action = {
  type: 'UPDATE_USER',
  payload: {
    id: 1,
    updates: { age: 31 }
  }
};

const newState = userReducer(initialState, action);
// Users array is new, but Jane's object is the same reference (optimization!)
```

### Combining Reducers

As apps grow, split reducers into separate functions managing independent parts of state:

```javascript
// todosReducer.js
function todosReducer(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, action.payload];
    case 'REMOVE_TODO':
      return state.filter(todo => todo.id !== action.payload);
    default:
      return state;
  }
}

// userReducer.js
function userReducer(state = null, action) {
  switch (action.type) {
    case 'SET_USER':
      return action.payload;
    case 'LOGOUT':
      return null;
    default:
      return state;
  }
}

// rootReducer.js
import { combineReducers } from 'redux';
import todosReducer from './todosReducer';
import userReducer from './userReducer';

const rootReducer = combineReducers({
  todos: todosReducer,
  user: userReducer
});

export default rootReducer;

// Resulting state shape
{
  todos: [], // Managed by todosReducer
  user: null // Managed by userReducer
}
```

**What `combineReducers` Does:**

```javascript
// This is essentially what combineReducers does
function manualCombineReducers(state = {}, action) {
  return {
    todos: todosReducer(state.todos, action),
    user: userReducer(state.user, action)
  };
}
```

### Initial State Handling

**Method 1: Default Parameters**

```javascript
function reducer(state = { count: 0 }, action) {
  // state will be { count: 0 } on first call
}
```

**Method 2: Explicit Initial State**

```javascript
const initialState = {
  count: 0,
  loading: false,
  error: null
};

function reducer(state = initialState, action) {
  switch (action.type) {
    // cases...
  }
}
```

**Method 3: Store Creation**

```javascript
const preloadedState = {
  count: 5 // Override default
};

const store = createStore(reducer, preloadedState);
```

### Dispatch

The dispatch function is how you trigger state changes:

```javascript
// Basic dispatch
store.dispatch({ type: 'INCREMENT' });

// Dispatch with payload
store.dispatch({
  type: 'ADD_TODO',
  payload: { id: 1, text: 'Learn Redux' }
});

// Using action creators
store.dispatch(addTodo(1, 'Learn Redux'));

// Dispatch is synchronous
console.log('Before:', store.getState().count); // 0
store.dispatch({ type: 'INCREMENT' });
console.log('After:', store.getState().count); // 1 (immediate)
```

**In React Components:**

```javascript
import { useDispatch } from 'react-redux';

function TodoForm() {
  const dispatch = useDispatch();
  
  const handleSubmit = (text) => {
    dispatch({
      type: 'ADD_TODO',
      payload: { id: Date.now(), text }
    });
  };
  
  return <form onSubmit={handleSubmit}>...</form>;
}
```

---

## Complete Example: Todo Application

Let's put everything together:

```javascript
// ===== actionTypes.js =====
export const ADD_TODO = 'ADD_TODO';
export const TOGGLE_TODO = 'TOGGLE_TODO';
export const REMOVE_TODO = 'REMOVE_TODO';

// ===== actions.js =====
import { ADD_TODO, TOGGLE_TODO, REMOVE_TODO } from './actionTypes';

export const addTodo = (text) => ({
  type: ADD_TODO,
  payload: {
    id: Date.now(),
    text,
    completed: false
  }
});

export const toggleTodo = (id) => ({
  type: TOGGLE_TODO,
  payload: id
});

export const removeTodo = (id) => ({
  type: REMOVE_TODO,
  payload: id
});

// ===== reducer.js =====
import { ADD_TODO, TOGGLE_TODO, REMOVE_TODO } from './actionTypes';

const initialState = {
  todos: []
};

export default function todoReducer(state = initialState, action) {
  switch (action.type) {
    case ADD_TODO:
      return {
        ...state,
        todos: [...state.todos, action.payload]
      };
    
    case TOGGLE_TODO:
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      };
    
    case REMOVE_TODO:
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload)
      };
    
    default:
      return state;
  }
}

// ===== store.js =====
import { createStore } from 'redux';
import todoReducer from './reducer';

const store = createStore(todoReducer);

export default store;

// ===== Usage =====
import store from './store';
import { addTodo, toggleTodo, removeTodo } from './actions';

// Subscribe to changes
store.subscribe(() => {
  console.log('State:', store.getState());
});

// Add todos
store.dispatch(addTodo('Learn Redux'));
store.dispatch(addTodo('Build an app'));

// Toggle first todo
const firstTodoId = store.getState().todos[0].id;
store.dispatch(toggleTodo(firstTodoId));

// Remove second todo
const secondTodoId = store.getState().todos[1].id;
store.dispatch(removeTodo(secondTodoId));

console.log('Final state:', store.getState());
```

---

## Key Takeaways

1. **Redux = Predictable State Container**
   - Single source of truth (store)
   - Read-only state (actions only)
   - Pure functions (reducers)

2. **Store** - Holds application state
   - `getState()` to read
   - `dispatch()` to update
   - `subscribe()` to listen

3. **Actions** - Describe what happened
   - Plain objects with `type`
   - Use action creators
   - Constants for types

4. **Reducers** - Specify how state changes
   - Pure functions
   - Never mutate state
   - Always return state

5. **Immutability** - Create new objects/arrays
   - Spread operator for objects: `{...state, newProp}`
   - Array methods: `.map()`, `.filter()`, `.concat()`
   - Never: `.push()`, `.pop()`, direct assignment

Understanding these fundamentals is crucial before moving to Redux Toolkit, which simplifies these patterns while maintaining the same core principles!