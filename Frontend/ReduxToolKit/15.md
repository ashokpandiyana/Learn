# Chapter 15: State Management Patterns

## Overview

This chapter explores advanced state management patterns, helping you decide what state belongs where, how to structure it, and when to use Redux vs other solutions.

---

## 15.1 Slice Design Principles

### Single Responsibility Principle

Each slice should manage one concern:

```typescript
// âŒ Bad: Too many responsibilities
const appSlice = createSlice({
  name: 'app',
  initialState: {
    user: null,
    todos: [],
    posts: [],
    theme: 'light',
    notifications: [],
    settings: {}
  },
  reducers: {
    // 50+ reducers managing different concerns
  }
});

// âœ… Good: Separate slices
const userSlice = createSlice({
  name: 'user',
  initialState: { currentUser: null, profile: null },
  reducers: { /* User-related actions only */ }
});

const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: { /* Todo-related actions only */ }
});

const uiSlice = createSlice({
  name: 'ui',
  initialState: { theme: 'light', sidebarOpen: false },
  reducers: { /* UI-related actions only */ }
});
```

### Slice Independence

Slices should be loosely coupled:

```typescript
// âŒ Bad: Tight coupling
const postsSlice = createSlice({
  name: 'posts',
  initialState: { items: [] },
  reducers: {
    postAdded: (state, action) => {
      state.items.push(action.payload);
      // âŒ Directly accessing another slice's state
      // This creates tight coupling
    }
  }
});

// âœ… Good: Use cross-slice actions
const postsSlice = createSlice({
  name: 'posts',
  initialState: { items: [] },
  reducers: {
    postAdded: (state, action) => {
      state.items.push(action.payload);
    }
  },
  extraReducers: (builder) => {
    // React to user logout from another slice
    builder.addCase('user/logout', (state) => {
      state.items = [];
    });
  }
});
```

### When to Split Slices

**Split when:**
```typescript
// Before: One large slice
const dataSlice = createSlice({
  name: 'data',
  initialState: {
    users: [],
    posts: [],
    comments: [],
    // 20+ different data types
  },
  reducers: {
    // 100+ reducers
  }
});

// After: Multiple focused slices
const usersSlice = createSlice({ name: 'users', ... });
const postsSlice = createSlice({ name: 'posts', ... });
const commentsSlice = createSlice({ name: 'comments', ... });
```

**Keep together when:**
```typescript
// âœ… Good: Related state stays together
const authSlice = createSlice({
  name: 'auth',
  initialState: {
    user: null,
    token: null,
    isAuthenticated: false,
    loading: false
  },
  // All auth-related logic
});
```

---

## 15.2 Derived State

### Computing in Selectors vs Storing

```typescript
// âŒ Bad: Storing derived data
const todosSlice = createSlice({
  name: 'todos',
  initialState: {
    items: [],
    completedCount: 0,    // Derived from items
    activeCount: 0,       // Derived from items
    totalCount: 0         // Derived from items
  },
  reducers: {
    todoAdded: (state, action) => {
      state.items.push(action.payload);
      state.totalCount += 1;
      state.activeCount += 1;
      // Maintaining multiple derived values is error-prone
    }
  }
});

// âœ… Good: Compute in selectors
const todosSlice = createSlice({
  name: 'todos',
  initialState: {
    items: []  // Single source of truth
  },
  reducers: {
    todoAdded: (state, action) => {
      state.items.push(action.payload);
      // That's it! No derived state to maintain
    }
  }
});

// Derive in selectors
export const selectTodoStats = createSelector(
  [state => state.todos.items],
  (items) => ({
    total: items.length,
    completed: items.filter(t => t.completed).length,
    active: items.filter(t => !t.completed).length
  })
);
```

### When to Denormalize

```typescript
// Store normalized
interface State {
  users: {
    byId: Record<string, User>;
    allIds: string[];
  };
  posts: {
    byId: Record<string, Post>;
    allIds: string[];
  };
}

// Denormalize in selector for UI
export const selectPostsWithAuthors = createSelector(
  [
    state => state.posts.byId,
    state => state.posts.allIds,
    state => state.users.byId
  ],
  (postsById, postIds, usersById) => {
    return postIds.map(id => ({
      ...postsById[id],
      author: usersById[postsById[id].authorId]
    }));
  }
);

// Use denormalized data in component
function PostsList() {
  const posts = useAppSelector(selectPostsWithAuthors);
  
  return (
    <ul>
      {posts.map(post => (
        <li key={post.id}>
          <h3>{post.title}</h3>
          <p>By {post.author.name}</p>
        </li>
      ))}
    </ul>
  );
}
```

### View Models Pattern

```typescript
// Domain model (stored in Redux)
interface TodoEntity {
  id: string;
  text: string;
  completed: boolean;
  priority: number;
  dueDate: string;
  tags: string[];
}

// View model (for UI consumption)
interface TodoViewModel {
  id: string;
  displayText: string;
  isCompleted: boolean;
  priorityLabel: string;
  dueDateFormatted: string;
  tagsList: string;
  isOverdue: boolean;
}

// Transform in selector
export const selectTodoViewModels = createSelector(
  [state => state.todos.items],
  (todos): TodoViewModel[] => {
    return todos.map(todo => ({
      id: todo.id,
      displayText: todo.text,
      isCompleted: todo.completed,
      priorityLabel: ['Low', 'Medium', 'High'][todo.priority],
      dueDateFormatted: new Date(todo.dueDate).toLocaleDateString(),
      tagsList: todo.tags.join(', '),
      isOverdue: new Date(todo.dueDate) < new Date() && !todo.completed
    }));
  }
);
```

---

## 15.3 Form State Management

### Local vs Global Form State

```typescript
// âœ… Good: Local state for simple forms
function LoginForm() {
  const dispatch = useAppDispatch();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [errors, setErrors] = useState<Record<string, string>>({});
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    // Validate
    const newErrors: Record<string, string> = {};
    if (!email) newErrors.email = 'Email required';
    if (!password) newErrors.password = 'Password required';
    
    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors);
      return;
    }
    
    // Submit to Redux
    dispatch(login({ email, password }));
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      {errors.email && <span>{errors.email}</span>}
      {/* ... */}
    </form>
  );
}

// âœ… Good: Redux for complex, multi-step forms
const checkoutSlice = createSlice({
  name: 'checkout',
  initialState: {
    step: 1,
    shippingAddress: {},
    billingAddress: {},
    paymentMethod: null,
    orderSummary: null
  },
  reducers: {
    stepChanged: (state, action) => {
      state.step = action.payload;
    },
    shippingAddressUpdated: (state, action) => {
      state.shippingAddress = action.payload;
    }
    // ... other form steps
  }
});
```

### When to Use Redux for Forms

Use Redux for forms when:
- âœ… Form state needs to persist across navigation
- âœ… Multiple components need access to form data
- âœ… Form has complex validation logic
- âœ… Multi-step/wizard forms
- âœ… Form data comes from/goes to API

Use local state when:
- âœ… Simple, single-page forms
- âœ… No need to persist across navigation
- âœ… Only one component needs the data

### Form Library Integration

```typescript
// Using React Hook Form with Redux
import { useForm } from 'react-hook-form';

function UserProfileForm() {
  const dispatch = useAppDispatch();
  const user = useAppSelector(state => state.user.profile);
  
  const { register, handleSubmit, formState: { errors } } = useForm({
    defaultValues: user
  });
  
  const onSubmit = (data: UserProfile) => {
    dispatch(updateUserProfile(data));
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('name', { required: true })} />
      {errors.name && <span>Name is required</span>}
      
      <input {...register('email', { required: true, pattern: /^\S+@\S+$/i })} />
      {errors.email && <span>Valid email required</span>}
      
      <button type="submit">Save</button>
    </form>
  );
}
```

---

## 15.4 Modal and UI State

### Managing Modal State

```typescript
// âœ… Simple modal state in Redux
const uiSlice = createSlice({
  name: 'ui',
  initialState: {
    modals: {
      deleteConfirmation: { isOpen: false, itemId: null },
      editUser: { isOpen: false, userId: null },
      imagePreview: { isOpen: false, imageUrl: null }
    }
  },
  reducers: {
    openModal: (state, action: PayloadAction<{ name: string; data?: any }>) => {
      const { name, data } = action.payload;
      state.modals[name] = { isOpen: true, ...data };
    },
    closeModal: (state, action: PayloadAction<string>) => {
      state.modals[action.payload] = { isOpen: false };
    },
    closeAllModals: (state) => {
      Object.keys(state.modals).forEach(key => {
        state.modals[key].isOpen = false;
      });
    }
  }
});

// Usage
function DeleteButton({ itemId }: { itemId: string }) {
  const dispatch = useAppDispatch();
  
  const handleClick = () => {
    dispatch(openModal({
      name: 'deleteConfirmation',
      data: { itemId }
    }));
  };
  
  return <button onClick={handleClick}>Delete</button>;
}

function DeleteConfirmationModal() {
  const dispatch = useAppDispatch();
  const modal = useAppSelector(state => state.ui.modals.deleteConfirmation);
  
  if (!modal.isOpen) return null;
  
  const handleConfirm = () => {
    dispatch(deleteItem(modal.itemId));
    dispatch(closeModal('deleteConfirmation'));
  };
  
  return (
    <Modal>
      <p>Are you sure?</p>
      <button onClick={handleConfirm}>Confirm</button>
      <button onClick={() => dispatch(closeModal('deleteConfirmation'))}>
        Cancel
      </button>
    </Modal>
  );
}
```

### Toast Notifications

```typescript
interface Notification {
  id: string;
  type: 'success' | 'error' | 'info' | 'warning';
  message: string;
  duration?: number;
}

const notificationsSlice = createSlice({
  name: 'notifications',
  initialState: {
    items: [] as Notification[]
  },
  reducers: {
    notificationAdded: (state, action: PayloadAction<Omit<Notification, 'id'>>) => {
      state.items.push({
        id: nanoid(),
        ...action.payload
      });
    },
    notificationRemoved: (state, action: PayloadAction<string>) => {
      state.items = state.items.filter(n => n.id !== action.payload);
    }
  }
});

// Auto-dismiss with listener middleware
listenerMiddleware.startListening({
  actionCreator: notificationAdded,
  effect: async (action, listenerApi) => {
    const duration = action.payload.duration || 5000;
    
    await listenerApi.delay(duration);
    
    listenerApi.dispatch(
      notificationRemoved(action.meta.arg.id)
    );
  }
});

// Toast component
function ToastNotifications() {
  const notifications = useAppSelector(state => state.notifications.items);
  
  return (
    <div className="toast-container">
      {notifications.map(notification => (
        <Toast key={notification.id} {...notification} />
      ))}
    </div>
  );
}
```

### Global UI State

```typescript
const uiSlice = createSlice({
  name: 'ui',
  initialState: {
    theme: 'light' as 'light' | 'dark',
    sidebarOpen: true,
    language: 'en',
    loading: false,
    errors: [] as string[]
  },
  reducers: {
    themeToggled: (state) => {
      state.theme = state.theme === 'light' ? 'dark' : 'light';
      localStorage.setItem('theme', state.theme);
    },
    sidebarToggled: (state) => {
      state.sidebarOpen = !state.sidebarOpen;
    },
    languageChanged: (state, action: PayloadAction<string>) => {
      state.language = action.payload;
    },
    loadingStarted: (state) => {
      state.loading = true;
    },
    loadingFinished: (state) => {
      state.loading = false;
    },
    errorAdded: (state, action: PayloadAction<string>) => {
      state.errors.push(action.payload);
    },
    errorsCleared: (state) => {
      state.errors = [];
    }
  }
});
```

---

## 15.5 Pagination Patterns

### Cursor-Based Pagination

```typescript
interface PaginatedState<T> {
  items: T[];
  nextCursor: string | null;
  hasMore: boolean;
  loading: boolean;
}

const postsSlice = createSlice({
  name: 'posts',
  initialState: {
    items: [],
    nextCursor: null,
    hasMore: true,
    loading: false
  } as PaginatedState<Post>,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchPosts.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.loading = false;
        state.items.push(...action.payload.items);
        state.nextCursor = action.payload.nextCursor;
        state.hasMore = action.payload.hasMore;
      });
  }
});

export const fetchPosts = createAsyncThunk<
  { items: Post[]; nextCursor: string | null; hasMore: boolean },
  string | null
>(
  'posts/fetch',
  async (cursor) => {
    const url = cursor 
      ? `/api/posts?cursor=${cursor}`
      : '/api/posts';
    
    const response = await fetch(url);
    return response.json();
  }
);

// Usage: Infinite scroll
function InfinitePostsList() {
  const dispatch = useAppDispatch();
  const { items, nextCursor, hasMore, loading } = useAppSelector(
    state => state.posts
  );
  
  const loadMore = () => {
    if (!loading && hasMore) {
      dispatch(fetchPosts(nextCursor));
    }
  };
  
  return (
    <InfiniteScroll
      dataLength={items.length}
      next={loadMore}
      hasMore={hasMore}
      loader={<div>Loading...</div>}
    >
      {items.map(post => (
        <PostItem key={post.id} post={post} />
      ))}
    </InfiniteScroll>
  );
}
```

### Offset-Based Pagination

```typescript
interface PaginatedData<T> {
  items: T[];
  page: number;
  pageSize: number;
  totalItems: number;
  totalPages: number;
}

const usersSlice = createSlice({
  name: 'users',
  initialState: {
    items: [],
    page: 1,
    pageSize: 20,
    totalItems: 0,
    totalPages: 0
  } as PaginatedData<User>,
  reducers: {
    pageChanged: (state, action: PayloadAction<number>) => {
      state.page = action.payload;
    }
  },
  extraReducers: (builder) => {
    builder.addCase(fetchUsers.fulfilled, (state, action) => {
      state.items = action.payload.items;
      state.totalItems = action.payload.total;
      state.totalPages = Math.ceil(action.payload.total / state.pageSize);
    });
  }
});

// Paginated selector
export const selectPaginatedUsers = createSelector(
  [
    state => state.users.items,
    state => state.users.page,
    state => state.users.pageSize
  ],
  (items, page, pageSize) => {
    const start = (page - 1) * pageSize;
    const end = start + pageSize;
    return items.slice(start, end);
  }
);
```

### Combined Approach (Cache All Pages)

```typescript
interface PagedCache<T> {
  pages: Record<number, T[]>;
  currentPage: number;
  pageSize: number;
  totalItems: number;
}

const productsSlice = createSlice({
  name: 'products',
  initialState: {
    pages: {},
    currentPage: 1,
    pageSize: 20,
    totalItems: 0
  } as PagedCache<Product>,
  reducers: {
    pageChanged: (state, action: PayloadAction<number>) => {
      state.currentPage = action.payload;
    }
  },
  extraReducers: (builder) => {
    builder.addCase(fetchProductPage.fulfilled, (state, action) => {
      const { page, items, total } = action.payload;
      state.pages[page] = items;
      state.totalItems = total;
    });
  }
});

// Smart selector - fetch if not cached
export const selectCurrentPageProducts = (state: RootState) => {
  const { pages, currentPage } = state.products;
  return pages[currentPage] || [];
};

// Hook that auto-fetches missing pages
function useProducts(page: number) {
  const dispatch = useAppDispatch();
  const products = useAppSelector(selectCurrentPageProducts);
  const hasPage = useAppSelector(
    state => !!state.products.pages[page]
  );
  
  useEffect(() => {
    if (!hasPage) {
      dispatch(fetchProductPage(page));
    }
  }, [page, hasPage, dispatch]);
  
  return products;
}
```

---

## 15.6 Filtering and Sorting

### Client-Side Filtering

```typescript
const productsSlice = createSlice({
  name: 'products',
  initialState: {
    items: [] as Product[],
    filters: {
      category: 'all',
      minPrice: 0,
      maxPrice: Infinity,
      inStock: false,
      searchTerm: ''
    }
  },
  reducers: {
    filterChanged: (state, action: PayloadAction<Partial<typeof state.filters>>) => {
      state.filters = { ...state.filters, ...action.payload };
    }
  }
});

export const selectFilteredProducts = createSelector(
  [
    state => state.products.items,
    state => state.products.filters
  ],
  (items, filters) => {
    return items.filter(product => {
      // Category filter
      if (filters.category !== 'all' && product.category !== filters.category) {
        return false;
      }
      
      // Price range
      if (product.price < filters.minPrice || product.price > filters.maxPrice) {
        return false;
      }
      
      // In stock
      if (filters.inStock && !product.inStock) {
        return false;
      }
      
      // Search term
      if (filters.searchTerm) {
        const term = filters.searchTerm.toLowerCase();
        if (!product.name.toLowerCase().includes(term)) {
          return false;
        }
      }
      
      return true;
    });
  }
);
```

### Server-Side Filtering

```typescript
// Store only filter state, fetch from server
const productsSlice = createSlice({
  name: 'products',
  initialState: {
    items: [] as Product[],
    filters: {
      category: 'all',
      sort: 'name',
      order: 'asc' as 'asc' | 'desc'
    },
    loading: false
  },
  reducers: {
    filterChanged: (state, action) => {
      state.filters = { ...state.filters, ...action.payload };
    }
  },
  extraReducers: (builder) => {
    builder.addCase(fetchFilteredProducts.fulfilled, (state, action) => {
      state.items = action.payload;
      state.loading = false;
    });
  }
});

// Fetch with filters
export const fetchFilteredProducts = createAsyncThunk(
  'products/fetchFiltered',
  async (_, { getState }) => {
    const state = getState() as RootState;
    const { category, sort, order } = state.products.filters;
    
    const params = new URLSearchParams({
      category,
      sort,
      order
    });
    
    const response = await fetch(`/api/products?${params}`);
    return response.json();
  }
);

// Auto-refetch when filters change
listenerMiddleware.startListening({
  actionCreator: filterChanged,
  effect: async (action, listenerApi) => {
    // Debounce
    listenerApi.cancelActiveListeners();
    await listenerApi.delay(300);
    
    listenerApi.dispatch(fetchFilteredProducts());
  }
});
```

### Maintaining Filter State

```typescript
// Persist filters in URL
function ProductsPage() {
  const dispatch = useAppDispatch();
  const [searchParams, setSearchParams] = useSearchParams();
  const filters = useAppSelector(state => state.products.filters);
  
  // Sync URL to Redux
  useEffect(() => {
    const category = searchParams.get('category') || 'all';
    const sort = searchParams.get('sort') || 'name';
    
    dispatch(filterChanged({ category, sort }));
  }, [searchParams, dispatch]);
  
  // Sync Redux to URL
  const handleFilterChange = (newFilters: Partial<Filters>) => {
    dispatch(filterChanged(newFilters));
    
    const params = new URLSearchParams(searchParams);
    Object.entries(newFilters).forEach(([key, value]) => {
      params.set(key, String(value));
    });
    setSearchParams(params);
  };
  
  return <ProductFilters onChange={handleFilterChange} />;
}
```

---

## 15.7 Decision Framework

### Use Redux When:

```typescript
// âœ… State shared across many components
const userSlice = createSlice({
  name: 'user',
  initialState: { currentUser: null },
  // Used by: Header, Sidebar, Profile, Settings, etc.
});

// âœ… State persists across navigation
const cartSlice = createSlice({
  name: 'cart',
  initialState: { items: [] },
  // Persists when user navigates between pages
});

// âœ… Complex state logic
const checkoutSlice = createSlice({
  name: 'checkout',
  // Multi-step form, validation, calculations
});

// âœ… State from API
const postsSlice = createSlice({
  name: 'posts',
  // Fetched from /api/posts
});
```

### Use Local State When:

```typescript
// âœ… Simple UI state
function Dropdown() {
  const [isOpen, setIsOpen] = useState(false);
  // Only this component needs to know
}

// âœ… Form input that doesn't need to persist
function SearchInput() {
  const [query, setQuery] = useState('');
  // Temporary, doesn't need Redux
}

// âœ… Temporary UI interactions
function ImageGallery() {
  const [selectedIndex, setSelectedIndex] = useState(0);
  // Only relevant while component mounted
}
```

### Use URL State When:

```typescript
// âœ… Shareable state
function ProductsPage() {
  const [searchParams] = useSearchParams();
  const category = searchParams.get('category');
  // User can share this URL
}

// âœ… Navigation state
function TabsComponent() {
  const [searchParams, setSearchParams] = useSearchParams();
  const activeTab = searchParams.get('tab') || 'profile';
  // Back button works correctly
}
```

---

## Best Practices

### âœ… Do's

1. **Keep slices focused**
```typescript
// One slice per domain concept
const authSlice = createSlice({ name: 'auth', ... });
const todosSlice = createSlice({ name: 'todos', ... });
```

2. **Compute derived state in selectors**
```typescript
const selectStats = createSelector([selectItems], (items) => ({
  total: items.length,
  completed: items.filter(i => i.done).length
}));
```

3. **Use local state for temporary UI**
```typescript
const [isOpen, setIsOpen] = useState(false);
```

4. **Normalize relational data**
```typescript
{ users: { byId: {}, allIds: [] } }
```

5. **Use URL for shareable state**
```typescript
const filters = Object.fromEntries(searchParams);
```

### âŒ Don'ts

1. **Don't store derived data**
```typescript
// âŒ Bad
{ items: [], count: items.length }
// âœ… Good
{ items: [] } // Compute count in selector
```

2. **Don't put everything in Redux**
```typescript
// âŒ Bad
const dropdownSlice = createSlice({
  name: 'dropdown',
  initialState: { isOpen: false }
});
```

3. **Don't tightly couple slices**
```typescript
// âŒ Bad: Direct cross-slice access
state.users.filter(u => u.id === state.posts.authorId)
```

---

## Summary

State management decision matrix:

| State Type | Storage Location |
|------------|------------------|
| **Shared across app** | Redux |
| **API data** | Redux (RTK Query) |
| **Temporary UI** | Local state |
| **Form inputs** | Local (usually) |
| **Shareable** | URL params |
| **Persisted** | Redux + localStorage |
| **Derived** | Selectors |

**Key Takeaways:**
1. One slice per domain concept
2. Compute, don't store derived state
3. Use local state for UI-only concerns
4. Normalize relational data
5. Filter/sort in selectors or server
6. Use URL for shareable state
7. Keep slices independent

Next: Chapter 16 covers Migration and Interoperability! ðŸš€