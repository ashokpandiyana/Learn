# Chapter 4: createSlice() - The Heart of RTK

## Overview

`createSlice()` is the most important API in Redux Toolkit. It allows you to define a slice of Redux state along with its reducers and actions in one place. This single function eliminates most of the boilerplate code associated with vanilla Redux.

---

## 4.1 Slice Fundamentals

### What is a Slice?

A **slice** is a collection of Redux reducer logic and actions for a single feature of your app. Think of your Redux state as a pizza - each slice represents one feature:

```
Redux State (Pizza)
‚îú‚îÄ‚îÄ auth (slice) üçï
‚îú‚îÄ‚îÄ users (slice) üçï
‚îú‚îÄ‚îÄ posts (slice) üçï
‚îî‚îÄ‚îÄ ui (slice) üçï
```

### Slice Anatomy

A slice has three core parts:

```javascript
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  // 1. NAME: Identifier for this slice
  name: 'counter',
  
  // 2. INITIAL STATE: Starting state
  initialState: { value: 0 },
  
  // 3. REDUCERS: How state changes
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    }
  }
});
```

### What createSlice() Generates

When you call `createSlice()`, it automatically generates:

1. **Action Creators** - Functions to create actions
2. **Action Types** - String constants for action types
3. **Reducer Function** - The actual reducer

```javascript
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value += 1;
    }
  }
});

// ‚ú® Auto-generated:

// 1. Action Creator
counterSlice.actions.increment
// Usage: dispatch(counterSlice.actions.increment())

// 2. Action Type
counterSlice.actions.increment.type
// Value: "counter/increment"

// 3. Reducer
counterSlice.reducer
// Function: (state, action) => newState
```

### Exporting from a Slice

Standard export pattern:

```javascript
// todosSlice.js
import { createSlice } from '@reduxjs/toolkit';

const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo: (state, action) => {
      state.push(action.payload);
    },
    removeTodo: (state, action) => {
      return state.filter(todo => todo.id !== action.payload);
    }
  }
});

// Export action creators (named exports)
export const { addTodo, removeTodo } = todosSlice.actions;

// Export reducer (default export)
export default todosSlice.reducer;
```

**Usage in other files:**

```javascript
// Component
import { addTodo, removeTodo } from './todosSlice';
dispatch(addTodo({ id: 1, text: 'Learn Redux' }));

// Store
import todosReducer from './todosSlice';
const store = configureStore({
  reducer: {
    todos: todosReducer
  }
});
```

### Action Types Convention

Action types follow the pattern: `sliceName/reducerName`

```javascript
const userSlice = createSlice({
  name: 'user',
  initialState: null,
  reducers: {
    setUser: (state, action) => action.payload,
    clearUser: () => null
  }
});

// Generated action types:
userSlice.actions.setUser.type    // "user/setUser"
userSlice.actions.clearUser.type  // "user/clearUser"
```

---

## 4.2 Writing Reducers with Immer

### The Magic of Immer

Redux Toolkit uses **Immer** internally, allowing you to write code that looks like mutations but produces immutable updates.

#### Traditional Immutable Updates (Vanilla Redux)

```javascript
// ‚ùå Complex, error-prone
function todosReducer(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, action.payload];
    
    case 'TOGGLE_TODO':
      return state.map(todo =>
        todo.id === action.payload.id
          ? { ...todo, completed: !todo.completed }
          : todo
      );
    
    case 'UPDATE_TODO_TEXT':
      return state.map(todo =>
        todo.id === action.payload.id
          ? { ...todo, text: action.payload.text }
          : todo
      );
    
    default:
      return state;
  }
}
```

#### With Immer (Redux Toolkit)

```javascript
// ‚úÖ Simple, intuitive
const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo: (state, action) => {
      state.push(action.payload); // "Mutation" works!
    },
    toggleTodo: (state, action) => {
      const todo = state.find(t => t.id === action.payload.id);
      if (todo) {
        todo.completed = !todo.completed; // Direct "mutation"!
      }
    },
    updateTodoText: (state, action) => {
      const todo = state.find(t => t.id === action.payload.id);
      if (todo) {
        todo.text = action.payload.text;
      }
    }
  }
});
```

### How Immer Works

```
Your "Mutating" Code
        ‚Üì
    Immer Magic
        ‚Üì
Creates "Draft" State (Proxy)
        ‚Üì
Tracks Changes
        ‚Üì
Produces New Immutable State
```

**Under the hood:**

```javascript
import produce from 'immer';

// What RTK does internally:
const newState = produce(currentState, draft => {
  // Your "mutating" code runs on draft
  draft.value += 1;
});

// draft is a proxy that records changes
// produce() creates a new immutable state based on changes
```

### Two Ways to Update State

With Immer, you have two options in reducers:

#### Option 1: Mutate the Draft State

```javascript
reducers: {
  addItem: (state, action) => {
    state.items.push(action.payload); // Mutate draft
    state.count += 1;
    // Don't return anything
  }
}
```

#### Option 2: Return a New State

```javascript
reducers: {
  addItem: (state, action) => {
    return {
      ...state,
      items: [...state.items, action.payload],
      count: state.count + 1
    };
  }
}
```

**‚ö†Ô∏è CRITICAL RULE:** Never do both!

```javascript
// ‚ùå WRONG - Mixing mutation and return
reducers: {
  addItem: (state, action) => {
    state.items.push(action.payload); // Mutation
    return {  // AND return - DON'T DO THIS!
      ...state,
      count: state.count + 1
    };
  }
}

// ‚úÖ CORRECT - Choose one approach
reducers: {
  addItem: (state, action) => {
    state.items.push(action.payload);
    state.count += 1;
    // No return statement
  }
}
```

### When Immer Doesn't Apply

Immer only works with **plain objects and arrays**. It doesn't work with:
- Classes
- Maps and Sets (though Immer v9+ has experimental support)
- Non-serializable values

```javascript
// ‚ùå Won't work with Immer
const state = new Map([['key', 'value']]);
state.set('key', 'newValue'); // Immer can't track this

// ‚úÖ Use plain objects instead
const state = { key: 'value' };
state.key = 'newValue'; // Immer can track this
```

### Complex State Updates with Immer

#### Nested State Updates

```javascript
const blogSlice = createSlice({
  name: 'blog',
  initialState: {
    posts: [
      {
        id: 1,
        title: 'Hello',
        comments: [
          { id: 1, text: 'Great!' }
        ]
      }
    ]
  },
  reducers: {
    // Add comment to specific post
    addComment: (state, action) => {
      const { postId, comment } = action.payload;
      const post = state.posts.find(p => p.id === postId);
      if (post) {
        post.comments.push(comment); // Nested "mutation"
      }
    },
    
    // Update comment text
    updateComment: (state, action) => {
      const { postId, commentId, text } = action.payload;
      const post = state.posts.find(p => p.id === postId);
      if (post) {
        const comment = post.comments.find(c => c.id === commentId);
        if (comment) {
          comment.text = text; // Deep nested "mutation"
        }
      }
    }
  }
});
```

#### Array Operations

```javascript
const cartSlice = createSlice({
  name: 'cart',
  initialState: {
    items: []
  },
  reducers: {
    // Add item
    addItem: (state, action) => {
      state.items.push(action.payload);
    },
    
    // Remove item
    removeItem: (state, action) => {
      const index = state.items.findIndex(item => item.id === action.payload);
      if (index !== -1) {
        state.items.splice(index, 1); // splice works with Immer!
      }
    },
    
    // Update quantity
    updateQuantity: (state, action) => {
      const { id, quantity } = action.payload;
      const item = state.items.find(item => item.id === id);
      if (item) {
        item.quantity = quantity;
      }
    },
    
    // Clear cart
    clearCart: (state) => {
      state.items = []; // Replace entire array
    },
    
    // Sort items
    sortItems: (state) => {
      state.items.sort((a, b) => a.price - b.price);
    }
  }
});
```

### PayloadAction Type

In TypeScript, use `PayloadAction<T>` to type action payloads:

```typescript
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

const todosSlice = createSlice({
  name: 'todos',
  initialState: [] as Todo[],
  reducers: {
    addTodo: (state, action: PayloadAction<Todo>) => {
      state.push(action.payload);
      // TypeScript knows payload is a Todo
    },
    
    toggleTodo: (state, action: PayloadAction<number>) => {
      // TypeScript knows payload is a number (id)
      const todo = state.find(t => t.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
    
    updateTodo: (state, action: PayloadAction<{ id: number; text: string }>) => {
      const todo = state.find(t => t.id === action.payload.id);
      if (todo) {
        todo.text = action.payload.text;
      }
    }
  }
});
```

---

## 4.3 Prepare Callbacks

### What are Prepare Callbacks?

Sometimes you need to customize the action payload before it reaches the reducer. Prepare callbacks let you:
- Add metadata to actions
- Generate IDs
- Add timestamps
- Transform input parameters

### Basic Prepare Callback

```javascript
const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo: {
      // The reducer function
      reducer: (state, action) => {
        state.push(action.payload);
      },
      
      // The prepare function
      prepare: (text) => {
        return {
          payload: {
            id: nanoid(), // Generate unique ID
            text,
            completed: false,
            createdAt: new Date().toISOString()
          }
        };
      }
    }
  }
});

// Usage:
dispatch(addTodo('Learn Redux'));
// Action created:
// {
//   type: 'todos/addTodo',
//   payload: {
//     id: 'abc123',
//     text: 'Learn Redux',
//     completed: false,
//     createdAt: '2024-01-15T10:30:00.000Z'
//   }
// }
```

### Multiple Parameters

```javascript
const postsSlice = createSlice({
  name: 'posts',
  initialState: [],
  reducers: {
    addPost: {
      reducer: (state, action) => {
        state.push(action.payload);
      },
      prepare: (title, content, userId) => {
        return {
          payload: {
            id: nanoid(),
            title,
            content,
            userId,
            createdAt: Date.now(),
            reactions: { thumbsUp: 0, heart: 0 }
          }
        };
      }
    }
  }
});

// Usage:
dispatch(addPost('My Title', 'Content here', 123));
```

### Adding Meta Information

```javascript
const analyticsSlice = createSlice({
  name: 'analytics',
  initialState: { events: [] },
  reducers: {
    trackEvent: {
      reducer: (state, action) => {
        state.events.push(action.payload);
      },
      prepare: (eventName, eventData) => {
        return {
          payload: {
            name: eventName,
            data: eventData,
            timestamp: Date.now()
          },
          meta: {
            source: 'user-action',
            priority: 'normal'
          }
        };
      }
    }
  }
});
```

### TypeScript with Prepare Callbacks

```typescript
import { createSlice, PayloadAction, nanoid } from '@reduxjs/toolkit';

interface Post {
  id: string;
  title: string;
  content: string;
}

const postsSlice = createSlice({
  name: 'posts',
  initialState: [] as Post[],
  reducers: {
    addPost: {
      reducer: (state, action: PayloadAction<Post>) => {
        state.push(action.payload);
      },
      prepare: (title: string, content: string) => {
        return {
          payload: {
            id: nanoid(),
            title,
            content
          } as Post
        };
      }
    }
  }
});
```

---

## 4.4 extraReducers

### What are extraReducers?

`extraReducers` allows your slice to respond to actions defined **outside** the slice, including:
- Actions from other slices
- Async thunk actions
- Any external action

### Why extraReducers?

**Problem without extraReducers:**

```javascript
// usersSlice.js
const usersSlice = createSlice({
  name: 'users',
  initialState: [],
  reducers: {
    userAdded: (state, action) => {
      state.push(action.payload);
    }
  }
});

// postsSlice.js - How to react to userAdded?
// ‚ùå Can't access userAdded action here!
```

**Solution with extraReducers:**

```javascript
import { userAdded } from './usersSlice';

const postsSlice = createSlice({
  name: 'posts',
  initialState: [],
  reducers: {
    postAdded: (state, action) => {
      state.push(action.payload);
    }
  },
  extraReducers: (builder) => {
    builder.addCase(userAdded, (state, action) => {
      // React to userAdded from another slice!
      console.log('User added, might affect posts');
    });
  }
});
```

### Builder Callback Notation

The modern way to define extraReducers uses a builder callback:

```javascript
const slice = createSlice({
  name: 'example',
  initialState: {},
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(actionCreator, (state, action) => {
        // Handle this specific action
      })
      .addMatcher(isActionType, (state, action) => {
        // Handle actions matching predicate
      })
      .addDefaultCase((state, action) => {
        // Handle all other actions
      });
  }
});
```

### addCase - Handling Specific Actions

```javascript
import { createSlice } from '@reduxjs/toolkit';
import { userLoggedOut } from '../auth/authSlice';

const cartSlice = createSlice({
  name: 'cart',
  initialState: {
    items: []
  },
  reducers: {
    addToCart: (state, action) => {
      state.items.push(action.payload);
    }
  },
  extraReducers: (builder) => {
    // Clear cart when user logs out
    builder.addCase(userLoggedOut, (state) => {
      state.items = [];
    });
  }
});
```

### Handling Async Thunks

This is the most common use of extraReducers:

```javascript
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// Async thunk
const fetchUsers = createAsyncThunk(
  'users/fetch',
  async () => {
    const response = await fetch('/api/users');
    return response.json();
  }
);

const usersSlice = createSlice({
  name: 'users',
  initialState: {
    entities: [],
    loading: 'idle', // 'idle' | 'pending' | 'succeeded' | 'failed'
    error: null
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      // Handle pending state
      .addCase(fetchUsers.pending, (state) => {
        state.loading = 'pending';
        state.error = null;
      })
      
      // Handle success
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = 'succeeded';
        state.entities = action.payload;
      })
      
      // Handle failure
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = 'failed';
        state.error = action.error.message;
      });
  }
});
```

### addMatcher - Pattern Matching

Handle multiple actions with similar patterns:

```javascript
import { isAnyOf } from '@reduxjs/toolkit';

const uiSlice = createSlice({
  name: 'ui',
  initialState: {
    isLoading: false
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      // Match any pending action
      .addMatcher(
        (action) => action.type.endsWith('/pending'),
        (state) => {
          state.isLoading = true;
        }
      )
      
      // Match any fulfilled or rejected action
      .addMatcher(
        (action) => 
          action.type.endsWith('/fulfilled') || 
          action.type.endsWith('/rejected'),
        (state) => {
          state.isLoading = false;
        }
      );
  }
});

// Using isAnyOf helper
const dataSlice = createSlice({
  name: 'data',
  initialState: { loading: false },
  reducers: {},
  extraReducers: (builder) => {
    builder.addMatcher(
      isAnyOf(fetchUsers.pending, fetchPosts.pending),
      (state) => {
        state.loading = true;
      }
    );
  }
});
```

### addDefaultCase

Handle all actions not caught by other cases:

```javascript
const loggingSlice = createSlice({
  name: 'logging',
  initialState: { actionLog: [] },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(specificAction, (state, action) => {
        // Handle specific action
      })
      .addDefaultCase((state, action) => {
        // Log all other actions
        state.actionLog.push({
          type: action.type,
          timestamp: Date.now()
        });
      });
  }
});
```

### Order of Execution

Builder methods are checked in order:

1. `addCase` (in the order they're added)
2. `addMatcher` (in the order they're added)
3. `addDefaultCase` (if present)

```javascript
extraReducers: (builder) => {
  builder
    .addCase(action1, handler1)      // Checked 1st
    .addCase(action2, handler2)      // Checked 2nd
    .addMatcher(matcher1, handler3)  // Checked 3rd
    .addMatcher(matcher2, handler4)  // Checked 4th
    .addDefaultCase(handler5);       // Checked last
}
```

---

## 4.5 Complete Real-World Example

Let's build a complete blog posts feature:

```javascript
// postsSlice.js
import { 
  createSlice, 
  createAsyncThunk, 
  nanoid,
  PayloadAction 
} from '@reduxjs/toolkit';

// Types
interface Post {
  id: string;
  title: string;
  content: string;
  author: string;
  reactions: {
    thumbsUp: number;
    heart: number;
    rocket: number;
  };
  createdAt: string;
}

interface PostsState {
  posts: Post[];
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

// Async thunks
export const fetchPosts = createAsyncThunk(
  'posts/fetchPosts',
  async () => {
    const response = await fetch('/api/posts');
    return response.json();
  }
);

export const addNewPost = createAsyncThunk(
  'posts/addNewPost',
  async (post: Omit<Post, 'id' | 'reactions' | 'createdAt'>) => {
    const response = await fetch('/api/posts', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(post)
    });
    return response.json();
  }
);

// Initial state
const initialState: PostsState = {
  posts: [],
  status: 'idle',
  error: null
};

// Slice
const postsSlice = createSlice({
  name: 'posts',
  initialState,
  reducers: {
    // Add post locally with prepare callback
    postAdded: {
      reducer: (state, action: PayloadAction<Post>) => {
        state.posts.push(action.payload);
      },
      prepare: (title: string, content: string, author: string) => {
        return {
          payload: {
            id: nanoid(),
            title,
            content,
            author,
            reactions: {
              thumbsUp: 0,
              heart: 0,
              rocket: 0
            },
            createdAt: new Date().toISOString()
          }
        };
      }
    },
    
    // Update post
    postUpdated: (state, action: PayloadAction<{ id: string; changes: Partial<Post> }>) => {
      const { id, changes } = action.payload;
      const existingPost = state.posts.find(post => post.id === id);
      if (existingPost) {
        Object.assign(existingPost, changes);
      }
    },
    
    // Delete post
    postDeleted: (state, action: PayloadAction<string>) => {
      const index = state.posts.findIndex(post => post.id === action.payload);
      if (index !== -1) {
        state.posts.splice(index, 1);
      }
    },
    
    // Add reaction
    reactionAdded: (state, action: PayloadAction<{ postId: string; reaction: keyof Post['reactions'] }>) => {
      const { postId, reaction } = action.payload;
      const post = state.posts.find(post => post.id === postId);
      if (post) {
        post.reactions[reaction]++;
      }
    }
  },
  
  extraReducers: (builder) => {
    builder
      // Fetch posts
      .addCase(fetchPosts.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.posts = action.payload;
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message || 'Failed to fetch posts';
      })
      
      // Add new post
      .addCase(addNewPost.fulfilled, (state, action) => {
        state.posts.push(action.payload);
      })
      
      // Handle user logout (from auth slice)
      .addCase('auth/logout', (state) => {
        state.posts = [];
        state.status = 'idle';
        state.error = null;
      });
  }
});

// Export actions
export const {
  postAdded,
  postUpdated,
  postDeleted,
  reactionAdded
} = postsSlice.actions;

// Export reducer
export default postsSlice.reducer;

// Selectors
export const selectAllPosts = (state: RootState) => state.posts.posts;
export const selectPostById = (state: RootState, postId: string) =>
  state.posts.posts.find(post => post.id === postId);
export const selectPostsStatus = (state: RootState) => state.posts.status;
export const selectPostsError = (state: RootState) => state.posts.error;
```

**Usage in Component:**

```javascript
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import {
  fetchPosts,
  selectAllPosts,
  selectPostsStatus,
  reactionAdded
} from './postsSlice';

function PostsList() {
  const dispatch = useDispatch();
  const posts = useSelector(selectAllPosts);
  const status = useSelector(selectPostsStatus);
  
  useEffect(() => {
    if (status === 'idle') {
      dispatch(fetchPosts());
    }
  }, [status, dispatch]);
  
  const handleReaction = (postId: string, reaction: string) => {
    dispatch(reactionAdded({ postId, reaction }));
  };
  
  if (status === 'loading') {
    return <div>Loading...</div>;
  }
  
  return (
    <div>
      {posts.map(post => (
        <article key={post.id}>
          <h3>{post.title}</h3>
          <p>{post.content}</p>
          <div>
            <button onClick={() => handleReaction(post.id, 'thumbsUp')}>
              üëç {post.reactions.thumbsUp}
            </button>
            <button onClick={() => handleReaction(post.id, 'heart')}>
              ‚ù§Ô∏è {post.reactions.heart}
            </button>
            <button onClick={() => handleReaction(post.id, 'rocket')}>
              üöÄ {post.reactions.rocket}
            </button>
          </div>
        </article>
      ))}
    </div>
  );
}
```

---

## Best Practices

### ‚úÖ Do's

1. **Use Immer's "mutation" syntax for clarity**
```javascript
reducers: {
  addItem: (state, action) => {
    state.items.push(action.payload); // Clear and simple
  }
}
```

2. **Use prepare callbacks for complex payloads**
```javascript
addTodo: {
  reducer: (state, action) => { state.push(action.payload); },
  prepare: (text) => ({ payload: { id: nanoid(), text } })
}
```

3. **Handle all async states**
```javascript
extraReducers: (builder) => {
  builder
    .addCase(thunk.pending, ...)
    .addCase(thunk.fulfilled, ...)
    .addCase(thunk.rejected, ...);
}
```

4. **Use addMatcher for common patterns**
```javascript
.addMatcher(
  action => action.type.endsWith('/pending'),
  state => { state.loading = true }
)
```

### ‚ùå Don'ts

1. **Don't mix mutation and return**
```javascript
// ‚ùå WRONG
reducer: (state, action) => {
  state.count++;
  return { ...state }; // DON'T DO THIS
}
```

2. **Don't forget TypeScript types**
```javascript
// ‚ùå Missing types
action => { ... }

// ‚úÖ With types
(state, action: PayloadAction<Todo>) => { ... }
```

3. **Don't put non-serializable values in state**
```javascript
// ‚ùå WRONG
initialState: {
  date: new Date(),      // Not serializable
  map: new Map(),        // Not serializable
  func: () => {}         // Not serializable
}

// ‚úÖ CORRECT
initialState: {
  date: new Date().toISOString(), // String
  items: {},                       // Plain object
}
```

---

## Summary

`createSlice()` is the cornerstone of Redux Toolkit:

| Feature | What It Does |
|---------|-------------|
| `name` | Prefix for action types |
| `initialState` | Starting state |
| `reducers` | Define state changes (auto-generates actions) |
| `extraReducers` | React to external actions |
| Immer | Safe "mutations" |
| `prepare` | Customize action payloads |

**Key Takeaways:**
1. One function defines state, reducers, and actions
2. Immer allows intuitive "mutating" code
3. Prepare callbacks customize action creation
4. extraReducers handle external/async actions
5. Never mix mutation and return statements
6. Always handle pending, fulfilled, rejected for async

Next: Chapter 5 will cover `createAsyncThunk()` in depth! üöÄ