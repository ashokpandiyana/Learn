# Chapter 2: Introduction to Redux Toolkit (RTK)

## Overview

Redux Toolkit (RTK) is the official, opinionated, batteries-included toolset for efficient Redux development. It was created to address three major concerns about Redux:
1. "Configuring a Redux store is too complicated"
2. "I have to add a lot of packages to get Redux to do anything useful"
3. "Redux requires too much boilerplate code"

---

## 2.1 Why Redux Toolkit?

### The Pain Points of Vanilla Redux

Let's compare the same feature in vanilla Redux vs Redux Toolkit:

**Vanilla Redux (Lots of Boilerplate):**

```javascript
// actionTypes.js
export const INCREMENT = 'counter/INCREMENT';
export const DECREMENT = 'counter/DECREMENT';
export const INCREMENT_BY_AMOUNT = 'counter/INCREMENT_BY_AMOUNT';

// actions.js
import { INCREMENT, DECREMENT, INCREMENT_BY_AMOUNT } from './actionTypes';

export const increment = () => ({ type: INCREMENT });
export const decrement = () => ({ type: DECREMENT });
export const incrementByAmount = (amount) => ({
  type: INCREMENT_BY_AMOUNT,
  payload: amount
});

// reducer.js
import { INCREMENT, DECREMENT, INCREMENT_BY_AMOUNT } from './actionTypes';

const initialState = { value: 0 };

export default function counterReducer(state = initialState, action) {
  switch (action.type) {
    case INCREMENT:
      return { ...state, value: state.value + 1 };
    case DECREMENT:
      return { ...state, value: state.value - 1 };
    case INCREMENT_BY_AMOUNT:
      return { ...state, value: state.value + action.payload };
    default:
      return state;
  }
}

// store.js
import { createStore } from 'redux';
import counterReducer from './reducer';

const store = createStore(counterReducer);

export default store;
```

**Redux Toolkit (Minimal Boilerplate):**

```javascript
// counterSlice.js
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value += 1; // âœ¨ "Mutating" code works!
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    }
  }
});

export const { increment, decrement, incrementByAmount } = counterSlice.actions;
export default counterSlice.reducer;

// store.js
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';

const store = configureStore({
  reducer: {
    counter: counterReducer
  }
});

export default store;
```

**Comparison:**
- **Vanilla Redux:** ~50 lines across 4 files
- **Redux Toolkit:** ~20 lines in 2 files
- **Action types:** Auto-generated
- **Action creators:** Auto-generated
- **Immutability:** Handled automatically by Immer

### Problems RTK Solves

#### 1. **Reduces Boilerplate Code**

Redux Toolkit eliminates repetitive code:

```javascript
// âŒ Vanilla Redux: Write everything manually
const ADD_TODO = 'ADD_TODO';
const addTodo = (text) => ({ type: ADD_TODO, payload: text });
function reducer(state, action) {
  switch (action.type) {
    case ADD_TODO: return { ...state, todos: [...state.todos, action.payload] }
  }
}

// âœ… Redux Toolkit: One declaration does it all
const slice = createSlice({
  name: 'todos',
  initialState: { todos: [] },
  reducers: {
    addTodo: (state, action) => {
      state.todos.push(action.payload); // Immer makes this safe!
    }
  }
});
```

#### 2. **Configures Store with Good Defaults**

```javascript
// âŒ Vanilla Redux: Manual configuration
import { createStore, applyMiddleware, compose } from 'redux';
import thunk from 'redux-thunk';
import { composeWithDevTools } from 'redux-devtools-extension';

const store = createStore(
  rootReducer,
  composeWithDevTools(applyMiddleware(thunk))
);

// âœ… Redux Toolkit: One line, perfect setup
import { configureStore } from '@reduxjs/toolkit';

const store = configureStore({
  reducer: rootReducer
  // Automatically includes:
  // - Redux Thunk middleware
  // - Redux DevTools extension
  // - Immutability and serializability checks (dev mode)
});
```

#### 3. **Includes Immer for Immutable Updates**

**Immer** allows you to write "mutating" code that produces immutable updates:

```javascript
// âŒ Vanilla Redux: Complex immutable updates
case 'UPDATE_USER':
  return {
    ...state,
    users: state.users.map(user =>
      user.id === action.payload.id
        ? { ...user, name: action.payload.name }
        : user
    )
  };

// âœ… Redux Toolkit: Simple "mutations"
updateUser: (state, action) => {
  const user = state.users.find(u => u.id === action.payload.id);
  if (user) {
    user.name = action.payload.name; // Looks like mutation, but isn't!
  }
}
```

**How Immer Works:**

```
Your "Mutating" Code â†’ Immer â†’ Immutable Update
     â†“                  â†“           â†“
  state.value = 5   [Magic]    { ...state, value: 5 }
```

Immer creates a "draft" of your state. Any changes to the draft are tracked and converted to immutable updates automatically.

```javascript
import produce from 'immer';

const state = { count: 0, nested: { value: 5 } };

const newState = produce(state, draft => {
  draft.count++; // "Mutate" the draft
  draft.nested.value = 10;
});

console.log(state.count); // 0 (original unchanged)
console.log(newState.count); // 1 (new state)
console.log(state !== newState); // true (different references)
```

#### 4. **Built-in Redux DevTools Integration**

```javascript
// âŒ Vanilla Redux: Complex setup
import { composeWithDevTools } from 'redux-devtools-extension';

const store = createStore(
  reducer,
  composeWithDevTools(
    applyMiddleware(...middleware),
    // other enhancers...
  )
);

// âœ… Redux Toolkit: Works out of the box!
const store = configureStore({
  reducer: rootReducer
  // DevTools automatically enabled in development
});
```

#### 5. **Simplifies Async Logic**

```javascript
// âŒ Vanilla Redux + Thunk: Manual action types and states
const FETCH_USER_REQUEST = 'FETCH_USER_REQUEST';
const FETCH_USER_SUCCESS = 'FETCH_USER_SUCCESS';
const FETCH_USER_FAILURE = 'FETCH_USER_FAILURE';

const fetchUser = (id) => async (dispatch) => {
  dispatch({ type: FETCH_USER_REQUEST });
  try {
    const response = await fetch(`/api/users/${id}`);
    const data = await response.json();
    dispatch({ type: FETCH_USER_SUCCESS, payload: data });
  } catch (error) {
    dispatch({ type: FETCH_USER_FAILURE, error: error.message });
  }
};

// Reducer
function reducer(state, action) {
  switch (action.type) {
    case FETCH_USER_REQUEST:
      return { ...state, loading: true };
    case FETCH_USER_SUCCESS:
      return { ...state, loading: false, user: action.payload };
    case FETCH_USER_FAILURE:
      return { ...state, loading: false, error: action.error };
  }
}

// âœ… Redux Toolkit: createAsyncThunk does it all
const fetchUser = createAsyncThunk(
  'users/fetch',
  async (id) => {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
  }
);

// Automatically generates:
// - users/fetch/pending
// - users/fetch/fulfilled
// - users/fetch/rejected

// In your slice
extraReducers: (builder) => {
  builder
    .addCase(fetchUser.pending, (state) => {
      state.loading = true;
    })
    .addCase(fetchUser.fulfilled, (state, action) => {
      state.loading = false;
      state.user = action.payload;
    })
    .addCase(fetchUser.rejected, (state, action) => {
      state.loading = false;
      state.error = action.error.message;
    });
}
```

---

## 2.2 Installation and Setup

### Installing Redux Toolkit

```bash
# Using npm
npm install @reduxjs/toolkit react-redux

# Using yarn
yarn add @reduxjs/toolkit react-redux

# Using pnpm
pnpm add @reduxjs/toolkit react-redux
```

**What gets installed:**
- `@reduxjs/toolkit`: RTK package (includes Redux core)
- `react-redux`: React bindings for Redux (hooks like useSelector, useDispatch)

### Project Structure Recommendations

#### **Feature-Based Structure (Recommended)**

```
src/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ store.js                 # Store configuration
â”‚   â””â”€â”€ hooks.js                 # Typed hooks (TypeScript)
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ counter/
â”‚   â”‚   â”œâ”€â”€ counterSlice.js      # Slice (state + reducers)
â”‚   â”‚   â”œâ”€â”€ Counter.jsx          # Component
â”‚   â”‚   â””â”€â”€ counterAPI.js        # API calls (optional)
â”‚   â”œâ”€â”€ todos/
â”‚   â”‚   â”œâ”€â”€ todosSlice.js
â”‚   â”‚   â”œâ”€â”€ TodoList.jsx
â”‚   â”‚   â””â”€â”€ todosAPI.js
â”‚   â””â”€â”€ user/
â”‚       â”œâ”€â”€ userSlice.js
â”‚       â”œâ”€â”€ authSlice.js
â”‚       â””â”€â”€ UserProfile.jsx
â”œâ”€â”€ components/                   # Shared components
â”œâ”€â”€ utils/                        # Utility functions
â””â”€â”€ index.js                      # App entry point
```

**Benefits:**
- Features are self-contained
- Easy to locate related code
- Scales well with team size
- Clear separation of concerns

#### **Alternative: Ducks Pattern Structure**

```
src/
â”œâ”€â”€ store/
â”‚   â”œâ”€â”€ index.js                 # Store configuration
â”‚   â”œâ”€â”€ slices/
â”‚   â”‚   â”œâ”€â”€ counterSlice.js
â”‚   â”‚   â”œâ”€â”€ todosSlice.js
â”‚   â”‚   â””â”€â”€ userSlice.js
â”‚   â””â”€â”€ middleware/
â”‚       â””â”€â”€ logger.js
â”œâ”€â”€ components/
â””â”€â”€ pages/
```

### TypeScript vs JavaScript Setup

#### **JavaScript Setup:**

```javascript
// store.js
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from '../features/counter/counterSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
});
```

#### **TypeScript Setup:**

```typescript
// store.ts
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from '../features/counter/counterSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
});

// Infer types from the store
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// hooks.ts - Create typed hooks
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
import type { RootState, AppDispatch } from './store';

export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
```

**Why TypeScript?**
- Autocomplete for state and actions
- Catch errors at compile time
- Better IDE support
- Self-documenting code

---

## 2.3 Core APIs Overview

Redux Toolkit provides several core APIs that simplify Redux development:

### 1. `configureStore()`

**Purpose:** Creates the Redux store with good defaults.

```javascript
import { configureStore } from '@reduxjs/toolkit';

const store = configureStore({
  reducer: {
    feature1: feature1Reducer,
    feature2: feature2Reducer
  }
});
```

**What it does:**
- Combines reducers automatically
- Adds Redux Thunk middleware
- Enables Redux DevTools Extension
- Adds development checks (immutability, serializability)

### 2. `createSlice()`

**Purpose:** Generates action creators and reducers together.

```javascript
import { createSlice } from '@reduxjs/toolkit';

const todoSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo: (state, action) => {
      state.push(action.payload);
    },
    removeTodo: (state, action) => {
      return state.filter(todo => todo.id !== action.payload);
    }
  }
});

// Auto-generated action creators
export const { addTodo, removeTodo } = todoSlice.actions;
// Reducer
export default todoSlice.reducer;
```

**What it generates:**
- Action creators: `addTodo()`, `removeTodo()`
- Action types: `'todos/addTodo'`, `'todos/removeTodo'`
- Reducer function

### 3. `createAsyncThunk()`

**Purpose:** Handles async operations (API calls).

```javascript
import { createAsyncThunk } from '@reduxjs/toolkit';

const fetchUserById = createAsyncThunk(
  'users/fetchById',
  async (userId) => {
    const response = await fetch(`/api/users/${userId}`);
    return response.json();
  }
);

// Automatically generates these actions:
// - fetchUserById.pending
// - fetchUserById.fulfilled
// - fetchUserById.rejected
```

### 4. `createEntityAdapter()`

**Purpose:** Manages normalized collections (arrays of objects).

```javascript
import { createEntityAdapter } from '@reduxjs/toolkit';

const usersAdapter = createEntityAdapter();

// Provides these methods:
// - addOne, addMany
// - updateOne, updateMany
// - removeOne, removeMany
// - setAll

// Provides these selectors:
// - selectAll
// - selectById
// - selectIds
```

**State shape it creates:**

```javascript
{
  ids: [1, 2, 3],
  entities: {
    1: { id: 1, name: 'John' },
    2: { id: 2, name: 'Jane' },
    3: { id: 3, name: 'Bob' }
  }
}
```

### 5. `createSelector()`

**Purpose:** Creates memoized selectors for derived state.

```javascript
import { createSelector } from '@reduxjs/toolkit';

const selectUsers = state => state.users;
const selectUserId = state => state.currentUserId;

const selectCurrentUser = createSelector(
  [selectUsers, selectUserId],
  (users, userId) => users.find(user => user.id === userId)
);

// Only recalculates when inputs change
```

---

## Complete RTK Example: Counter App

Let's build a complete counter application using Redux Toolkit:

### **Step 1: Create the Slice**

```javascript
// features/counter/counterSlice.js
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: {
    value: 0,
    history: []
  },
  reducers: {
    increment: (state) => {
      state.value += 1;
      state.history.push({ action: 'increment', value: state.value });
    },
    decrement: (state) => {
      state.value -= 1;
      state.history.push({ action: 'decrement', value: state.value });
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
      state.history.push({ 
        action: 'incrementByAmount', 
        value: state.value, 
        amount: action.payload 
      });
    },
    reset: (state) => {
      state.value = 0;
      state.history = [];
    }
  }
});

export const { increment, decrement, incrementByAmount, reset } = counterSlice.actions;
export default counterSlice.reducer;
```

### **Step 2: Configure the Store**

```javascript
// app/store.js
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from '../features/counter/counterSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
});
```

### **Step 3: Provide the Store to React**

```javascript
// index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import { store } from './app/store';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <Provider store={store}>
    <App />
  </Provider>
);
```

### **Step 4: Use in Components**

```javascript
// features/counter/Counter.jsx
import React, { useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement, incrementByAmount, reset } from './counterSlice';

function Counter() {
  const count = useSelector((state) => state.counter.value);
  const history = useSelector((state) => state.counter.history);
  const dispatch = useDispatch();
  const [amount, setAmount] = useState(5);

  return (
    <div>
      <h1>Counter: {count}</h1>
      
      <div>
        <button onClick={() => dispatch(decrement())}>-</button>
        <button onClick={() => dispatch(increment())}>+</button>
      </div>
      
      <div>
        <input
          type="number"
          value={amount}
          onChange={(e) => setAmount(Number(e.target.value))}
        />
        <button onClick={() => dispatch(incrementByAmount(amount))}>
          Add Amount
        </button>
      </div>
      
      <button onClick={() => dispatch(reset())}>Reset</button>
      
      <h2>History</h2>
      <ul>
        {history.map((entry, index) => (
          <li key={index}>
            {entry.action}: {entry.value}
            {entry.amount && ` (${entry.amount})`}
          </li>
        ))}
      </ul>
    </div>
  );
}

export default Counter;
```

---

## RTK vs Vanilla Redux: Side-by-Side

| Feature | Vanilla Redux | Redux Toolkit |
|---------|--------------|---------------|
| Action Types | Manual constants | Auto-generated |
| Action Creators | Write by hand | Auto-generated |
| Reducers | Switch statements | Object methods |
| Immutability | Manual spreading | Immer (automatic) |
| Store Setup | 10+ lines | 3 lines |
| DevTools | Manual setup | Auto-configured |
| Async Logic | Manual thunks | createAsyncThunk |
| Lines of Code | ~100 for basic feature | ~30 for basic feature |

---

## Key Concepts Summary

### âœ… **What Redux Toolkit Is:**
- Official recommended way to write Redux
- Simplifies common Redux patterns
- Reduces boilerplate by ~70%
- Includes powerful utilities
- Built on top of Redux core

### âœ… **What Redux Toolkit Includes:**
- Redux core library
- Immer (immutability helper)
- Redux Thunk (async middleware)
- Reselect (memoized selectors)
- Redux DevTools integration

### âœ… **Key Benefits:**
1. **Less Code:** Write 70% less code than vanilla Redux
2. **Safer:** Immer prevents accidental mutations
3. **Faster:** Good defaults, less configuration
4. **Better DX:** DevTools, TypeScript support
5. **Modern:** Latest best practices built-in

### âš ï¸ **Important Notes:**
- RTK is **not a different library** - it's an abstraction over Redux
- All Redux principles still apply (immutability, unidirectional flow, etc.)
- You can mix RTK with vanilla Redux code
- Learning vanilla Redux first helps understand what RTK does

---

## Migration Path

If you have existing Redux code:

1. **Install RTK** (keeps existing Redux)
2. **Convert one slice at a time** (incremental migration)
3. **Replace store configuration** when ready
4. **Update tests** as you go

```javascript
// Before: Vanilla Redux
const ADD_TODO = 'ADD_TODO';
const addTodo = text => ({ type: ADD_TODO, payload: text });
function todos(state = [], action) { /* ... */ }

// After: Redux Toolkit
const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo: (state, action) => { state.push(action.payload); }
  }
});
```

---

## Next Steps

Now that you understand **why** Redux Toolkit exists and its core APIs, the next chapter will dive deep into **`configureStore()`** - the foundation of every RTK application.

**You'll learn:**
- Advanced store configuration
- Custom middleware setup
- DevTools configuration
- Enhancers and preloaded state
- Hot module replacement

Redux Toolkit makes Redux development enjoyable again! ðŸš€