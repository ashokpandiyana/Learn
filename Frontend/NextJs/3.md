# Chapter 3: Rendering Strategies - Deep Dive

## Understanding Rendering in Next.js

Next.js offers multiple rendering strategies, each optimized for different use cases. Understanding when to use each is **critical** for building performant applications.

### The Four Rendering Strategies

1. **SSR (Server-Side Rendering)** - Render on each request
2. **SSG (Static Site Generation)** - Pre-render at build time
3. **ISR (Incremental Static Regeneration)** - SSG + periodic updates
4. **CSR (Client-Side Rendering)** - Render in browser

---

## 3.1 Server-Side Rendering (SSR)

### What is SSR?

Server-Side Rendering generates HTML on the **server for every request**.

**Flow:**
```
User Request ‚Üí Server ‚Üí Fetch Data ‚Üí Render HTML ‚Üí Send to Client ‚Üí Hydrate
```

**Timing:**
```
Build Time:  Nothing
Request Time: ‚úÖ Render page with fresh data
```

### SSR in Pages Router

```typescript
// pages/product/[id].tsx
import { GetServerSideProps } from 'next';

interface Product {
  id: number;
  name: string;
  price: number;
  stock: number;
}

export const getServerSideProps: GetServerSideProps = async (context) => {
  const { id } = context.params!;
  
  // Fetch fresh data on EVERY request
  const res = await fetch(`https://api.example.com/products/${id}`);
  const product: Product = await res.json();
  
  // Access request data
  console.log('User IP:', context.req.headers['x-forwarded-for']);
  console.log('Cookies:', context.req.cookies);
  
  return {
    props: {
      product,
    },
  };
};

export default function ProductPage({ product }: { product: Product }) {
  return (
    <div>
      <h1>{product.name}</h1>
      <p>Price: ${product.price}</p>
      <p>Stock: {product.stock} units</p>
    </div>
  );
}
```

### SSR in App Router

In the App Router, SSR is achieved by using `fetch` with `cache: 'no-store'` or dynamic functions:

```typescript
// app/product/[id]/page.tsx
interface Product {
  id: number;
  name: string;
  price: number;
  stock: number;
}

export default async function ProductPage({
  params,
}: {
  params: { id: string };
}) {
  // SSR: Fresh data on every request
  const res = await fetch(`https://api.example.com/products/${params.id}`, {
    cache: 'no-store', // Don't cache - always fetch fresh
  });
  
  const product: Product = await res.json();
  
  return (
    <div>
      <h1>{product.name}</h1>
      <p>Price: ${product.price}</p>
      <p>Stock: {product.stock} units</p>
    </div>
  );
}
```

### Dynamic Functions Trigger SSR

Using these functions automatically makes a route dynamic (SSR):

```typescript
// Any of these force SSR:
import { cookies } from 'next/headers';
import { headers } from 'next/headers';
import { searchParams } from 'next/navigation';

export default async function Page() {
  // Using cookies() makes this route dynamic
  const cookieStore = cookies();
  const token = cookieStore.get('token');
  
  // Using headers() makes this route dynamic
  const headersList = headers();
  const userAgent = headersList.get('user-agent');
  
  return <div>User Agent: {userAgent}</div>;
}
```

### When to Use SSR

‚úÖ **Use SSR when:**
- Data changes frequently (real-time dashboards)
- Content is user-specific (personalized pages)
- Need authentication/authorization
- SEO is critical AND content changes often

‚ùå **Don't use SSR when:**
- Content is static or rarely changes ‚Üí Use SSG/ISR
- Performance is critical ‚Üí SSR is slower than SSG
- High traffic ‚Üí SSR uses more server resources

### SSR Performance Optimization

```typescript
// Parallel data fetching
export default async function Dashboard() {
  // ‚ùå Bad: Sequential (slow)
  const user = await fetchUser();
  const posts = await fetchPosts();
  const analytics = await fetchAnalytics();
  
  // ‚úÖ Good: Parallel (fast)
  const [user, posts, analytics] = await Promise.all([
    fetchUser(),
    fetchPosts(),
    fetchAnalytics(),
  ]);
  
  return (
    <div>
      <UserProfile user={user} />
      <PostList posts={posts} />
      <Analytics data={analytics} />
    </div>
  );
}
```

### üî• Important: SSR Happens on Every Request

```typescript
export default async function Page() {
  console.log('This runs on EVERY request');
  console.log('Current time:', new Date().toISOString());
  
  // Fresh data every time
  const data = await fetch('https://api.example.com/data', {
    cache: 'no-store'
  });
  
  return <div>{/* content */}</div>;
}
```

**Cost:**
- More server load
- Slower than static pages
- Higher infrastructure costs

**Benefit:**
- Always fresh data
- User-specific content
- Dynamic behavior

### üìö Interview Topic: SSR vs CSR Performance

**Question: "Explain SSR performance implications"**

**Answer:**

**SSR Advantages:**
1. **Faster First Contentful Paint**: HTML arrives ready
2. **Better SEO**: Crawlers see complete content
3. **Works without JS**: Progressive enhancement

**SSR Disadvantages:**
1. **Slower TTFB** (Time to First Byte): Server must render
2. **Higher server costs**: CPU/memory usage
3. **Slower than static**: Can't use CDN caching

**Comparison:**
```
SSR:
Request ‚Üí Wait for server ‚Üí Receive HTML ‚Üí Display
TTFB: ~200-500ms, FCP: ~300-700ms

SSG (Static):
Request ‚Üí Instant CDN response ‚Üí Display
TTFB: ~20-50ms, FCP: ~100-200ms

CSR:
Request ‚Üí Receive JS ‚Üí Execute ‚Üí Fetch Data ‚Üí Display
TTFB: ~50ms, FCP: ~1000-2000ms
```

---

## 3.2 Static Site Generation (SSG)

### What is SSG?

Static Site Generation pre-renders pages **at build time**. The HTML is generated once and reused for all requests.

**Flow:**
```
Build Time: Generate HTML ‚Üí Deploy
Request Time: Serve static HTML from CDN ‚Üí Instant!
```

### SSG in Pages Router

```typescript
// pages/blog/[slug].tsx
import { GetStaticProps, GetStaticPaths } from 'next';

interface Post {
  slug: string;
  title: string;
  content: string;
  author: string;
}

// Generate pages for these paths at build time
export const getStaticPaths: GetStaticPaths = async () => {
  // Fetch all blog posts
  const posts = await fetch('https://api.example.com/posts').then(r => r.json());
  
  return {
    paths: posts.map((post: Post) => ({
      params: { slug: post.slug },
    })),
    fallback: 'blocking', // or false, true
  };
};

// Fetch data for each path at build time
export const getStaticProps: GetStaticProps = async ({ params }) => {
  const post = await fetch(
    `https://api.example.com/posts/${params!.slug}`
  ).then(r => r.json());
  
  return {
    props: {
      post,
    },
    // Optional: Enable ISR
    revalidate: 3600, // Regenerate every hour
  };
};

export default function BlogPost({ post }: { post: Post }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <p>By {post.author}</p>
      <div>{post.content}</div>
    </article>
  );
}
```

### Fallback Options Explained

```typescript
export const getStaticPaths = async () => {
  return {
    paths: [
      { params: { id: '1' } },
      { params: { id: '2' } },
    ],
    fallback: 'blocking', // or false, true
  };
};
```

**fallback: false**
```typescript
fallback: false
// ‚úÖ /products/1 ‚Üí 200 (pre-generated)
// ‚úÖ /products/2 ‚Üí 200 (pre-generated)
// ‚ùå /products/3 ‚Üí 404 (not pre-generated)
```
- Only pre-generated paths exist
- Other paths return 404
- Use when: You have all possible paths at build time

**fallback: true**
```typescript
fallback: true

export default function Page({ product }) {
  const router = useRouter();
  
  // Show loading state for non-pre-generated pages
  if (router.isFallback) {
    return <div>Loading...</div>;
  }
  
  return <div>{product.name}</div>;
}
```
- Pre-generated paths load instantly
- New paths show fallback ‚Üí generate ‚Üí cache
- Client sees loading state first
- Use when: Many possible paths, want fast builds

**fallback: 'blocking'**
```typescript
fallback: 'blocking'
// First request: Wait for generation (like SSR)
// Subsequent requests: Serve cached version
```
- Pre-generated paths load instantly
- New paths: Server waits to generate, then returns
- No loading state needed
- Use when: Many paths, better UX than fallback: true

### SSG in App Router

```typescript
// app/blog/[slug]/page.tsx
interface Post {
  slug: string;
  title: string;
  content: string;
}

// Generate static paths
export async function generateStaticParams() {
  const posts = await fetch('https://api.example.com/posts').then(r => r.json());
  
  return posts.map((post: Post) => ({
    slug: post.slug,
  }));
}

// Generate static page
export default async function BlogPost({
  params,
}: {
  params: { slug: string };
}) {
  // This fetch is cached by default (force-cache)
  const res = await fetch(`https://api.example.com/posts/${params.slug}`);
  const post: Post = await res.json();
  
  return (
    <article>
      <h1>{post.title}</h1>
      <div>{post.content}</div>
    </article>
  );
}
```

### Dynamic Params with App Router

```typescript
// Control what happens for non-generated paths
export const dynamicParams = true; // default - generate on-demand
// export const dynamicParams = false; // return 404 for non-generated paths
```

### When to Use SSG

‚úÖ **Use SSG when:**
- Content doesn't change often (blogs, docs)
- Same content for all users
- SEO is critical
- Performance is priority #1

‚ùå **Don't use SSG when:**
- Content changes frequently
- User-specific content
- Real-time data
- Thousands of pages (slow builds)

### üî• Highlight: Best for SEO and Performance

SSG provides:
- **Instant loading** from CDN
- **Perfect SEO** - crawlers see complete HTML
- **Lowest cost** - just static file hosting
- **Highest scalability** - no server needed

---

## 3.3 Incremental Static Regeneration (ISR)

### What is ISR?

ISR combines **SSG speed** with **SSR freshness**. Pages are static but can be regenerated in the background.

**Flow:**
```
Build Time: Generate initial HTML
First Request: Serve static HTML (fast)
After Revalidate Period: Regenerate in background
Next Request: Serve new HTML
```

### ISR in Pages Router

```typescript
// pages/posts/[id].tsx
export const getStaticProps: GetStaticProps = async ({ params }) => {
  const post = await fetch(
    `https://api.example.com/posts/${params!.id}`
  ).then(r => r.json());
  
  return {
    props: { post },
    revalidate: 60, // Regenerate at most every 60 seconds
  };
};

export const getStaticPaths: GetStaticPaths = async () => {
  // Only pre-generate popular posts
  const popularPosts = await fetchPopularPosts();
  
  return {
    paths: popularPosts.map(post => ({ params: { id: post.id } })),
    fallback: 'blocking', // Generate others on-demand
  };
};

export default function Post({ post }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <p>Views: {post.views}</p>
    </article>
  );
}
```

### How ISR Works (Timeline)

```
Time: 0s
User A visits /posts/1
‚Üí Serves static HTML (generated at build)
‚Üí Page is "stale" (last generated > 60s ago)
‚Üí Trigger background regeneration

Time: 0.1s
User B visits /posts/1
‚Üí Still serves OLD static HTML (instant!)
‚Üí Regeneration in progress...

Time: 2s
Regeneration completes
‚Üí New HTML ready

Time: 3s
User C visits /posts/1
‚Üí Serves NEW static HTML
```

### ISR in App Router

```typescript
// app/posts/[id]/page.tsx
export default async function Post({
  params,
}: {
  params: { id: string };
}) {
  const res = await fetch(`https://api.example.com/posts/${params.id}`, {
    next: { revalidate: 60 }, // ISR: revalidate every 60 seconds
  });
  
  const post = await res.json();
  
  return (
    <article>
      <h1>{post.title}</h1>
      <p>Views: {post.views}</p>
    </article>
  );
}
```

### On-Demand Revalidation

Revalidate specific pages without waiting:

```typescript
// app/api/revalidate/route.ts
import { revalidatePath, revalidateTag } from 'next/cache';
import { NextRequest } from 'next/server';

export async function POST(request: NextRequest) {
  const secret = request.nextUrl.searchParams.get('secret');
  
  // Verify secret token
  if (secret !== process.env.REVALIDATE_SECRET) {
    return Response.json({ message: 'Invalid secret' }, { status: 401 });
  }
  
  const path = request.nextUrl.searchParams.get('path');
  
  if (path) {
    // Revalidate specific path
    revalidatePath(path);
    return Response.json({ revalidated: true, path });
  }
  
  return Response.json({ message: 'Missing path' }, { status: 400 });
}
```

**Trigger revalidation:**
```bash
# From your CMS webhook
curl -X POST 'https://yoursite.com/api/revalidate?secret=SECRET&path=/posts/123'
```

### Tag-Based Revalidation

```typescript
// Tag your data fetches
export default async function Post({ params }) {
  const res = await fetch(`https://api.example.com/posts/${params.id}`, {
    next: { 
      revalidate: 3600,
      tags: ['posts', `post-${params.id}`]
    },
  });
  
  const post = await res.json();
  
  return <article>{post.title}</article>;
}

// Revalidate by tag
// app/api/revalidate/route.ts
import { revalidateTag } from 'next/cache';

export async function POST(request) {
  const tag = await request.json().tag;
  revalidateTag(tag); // Revalidates all fetches with this tag
  return Response.json({ revalidated: true });
}
```

### üî• Critical: ISR Combines Benefits of SSG and SSR

| Feature | SSG | ISR | SSR |
|---------|-----|-----|-----|
| Speed | ‚ö° Instant | ‚ö° Instant | üêå Slow |
| Freshness | ü•∂ Stale | ‚úÖ Fresh | ‚úÖ Always Fresh |
| Cost | üí∞ Cheap | üí∞ Cheap | üí∞üí∞ Expensive |
| Scalability | ‚úÖ Unlimited | ‚úÖ Unlimited | ‚ö†Ô∏è Limited |

### When to Use ISR

‚úÖ **Use ISR when:**
- Content updates periodically (news, blogs, e-commerce)
- Need both speed and freshness
- High traffic sites
- Product pages, listings

‚ùå **Don't use ISR when:**
- Content never changes ‚Üí Use pure SSG
- Need real-time data ‚Üí Use SSR
- User-specific content ‚Üí Use SSR

### üìö Interview Focus: Explain ISR Use Cases

**Question: "When would you use ISR over SSG or SSR?"**

**Answer:**

**ISR is perfect for:**

1. **E-commerce Product Pages**
   - Serve static HTML (fast)
   - Update prices/stock periodically
   - Handle traffic spikes easily

2. **News Websites**
   - Old articles stay static
   - Recent articles regenerate every few minutes
   - Breaking news triggers on-demand revalidation

3. **Blog Posts**
   - Post content rarely changes
   - View counts, comments update periodically
   - SEO benefits of SSG, freshness of SSR

**Example Scenario:**
```
E-commerce site with 1M products
- Build time: 10 popular products (instant deployment)
- First visit to product page: Generate on-demand (fallback)
- Revalidate: Every 5 minutes (update price/stock)
- On-demand: When inventory changes (webhook)
```

---

## 3.4 Client-Side Rendering (CSR)

### What is CSR?

Client-Side Rendering fetches and renders data in the browser using JavaScript.

**Flow:**
```
Server: Send empty HTML + JS bundle
Browser: Execute JS ‚Üí Fetch data ‚Üí Render
```

### CSR in Pages Router

```typescript
// pages/dashboard.tsx
import { useEffect, useState } from 'react';

interface User {
  name: string;
  email: string;
}

export default function Dashboard() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetch('/api/user')
      .then(res => res.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      });
  }, []);
  
  if (loading) return <div>Loading...</div>;
  if (!user) return <div>Not logged in</div>;
  
  return (
    <div>
      <h1>Welcome, {user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
```

### CSR in App Router

```typescript
// app/dashboard/page.tsx
'use client';

import { useEffect, useState } from 'react';

export default function Dashboard() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    fetch('/api/data')
      .then(r => r.json())
      .then(setData);
  }, []);
  
  return <div>{data?.title}</div>;
}
```

### Better CSR with SWR

```typescript
'use client';

import useSWR from 'swr';

const fetcher = (url: string) => fetch(url).then(r => r.json());

export default function Dashboard() {
  const { data, error, isLoading } = useSWR('/api/user', fetcher, {
    refreshInterval: 5000, // Refresh every 5 seconds
    revalidateOnFocus: true, // Revalidate when window focused
  });
  
  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error loading data</div>;
  
  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.email}</p>
    </div>
  );
}
```

### Better CSR with React Query

```typescript
'use client';

import { useQuery } from '@tanstack/react-query';

export default function Dashboard() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['user'],
    queryFn: () => fetch('/api/user').then(r => r.json()),
    staleTime: 5000,
    refetchOnWindowFocus: true,
  });
  
  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error</div>;
  
  return <div>{data.name}</div>;
}
```

### When to Use CSR

‚úÖ **Use CSR when:**
- Data is user-specific and private
- SEO doesn't matter (dashboards, admin panels)
- Data changes in real-time
- Interactive dashboards

‚ùå **Don't use CSR when:**
- SEO is important
- First load performance matters
- Content should be crawlable

---

## 3.5 Streaming and Suspense

### What is Streaming?

Streaming sends HTML in **chunks** as they're ready, rather than waiting for everything.

**Traditional SSR:**
```
Wait for ALL data ‚Üí Render ALL HTML ‚Üí Send ‚Üí Display
(5 seconds)                                  User sees page
```

**Streaming SSR:**
```
Send shell ‚Üí Stream content as ready ‚Üí Display progressively
(0.5s)       (1s)        (2s)         (3s)
User sees layout immediately, content appears progressively
```

### Suspense Boundaries

```typescript
// app/dashboard/page.tsx
import { Suspense } from 'react';

export default function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      
      {/* This loads immediately */}
      <UserGreeting />
      
      {/* This streams in when ready */}
      <Suspense fallback={<AnalyticsSkeleton />}>
        <Analytics />
      </Suspense>
      
      {/* This streams in independently */}
      <Suspense fallback={<ActivitySkeleton />}>
        <RecentActivity />
      </Suspense>
    </div>
  );
}

// Slow component - but doesn't block the page!
async function Analytics() {
  // Slow data fetch (3 seconds)
  const data = await fetch('https://api.example.com/analytics', {
    cache: 'no-store'
  });
  const analytics = await data.json();
  
  return <div>{/* Render analytics */}</div>;
}
```

### Loading.tsx with Streaming

```typescript
// app/dashboard/loading.tsx
export default function Loading() {
  return <DashboardSkeleton />;
}

// app/dashboard/page.tsx
export default async function Dashboard() {
  // Fetch data - page.tsx content streams in when ready
  const data = await fetchDashboardData();
  
  return <div>{/* Dashboard content */}</div>;
}
```

**User Experience:**
1. Navigate to `/dashboard`
2. Instantly see `loading.tsx` (layout + skeleton)
3. When data ready, content streams in

### Nested Suspense Boundaries

```typescript
export default function Page() {
  return (
    <div>
      {/* Outer boundary */}
      <Suspense fallback={<PageSkeleton />}>
        <MainContent>
          {/* Inner boundary - streams independently */}
          <Suspense fallback={<CommentsLoading />}>
            <Comments />
          </Suspense>
        </MainContent>
      </Suspense>
    </div>
  );
}
```

### üî• Highlight: Improves Perceived Performance Significantly

**Without Streaming:**
```
User waits 5 seconds ‚Üí Sees complete page
Perceived wait: 5 seconds
```

**With Streaming:**
```
User waits 0.5s ‚Üí Sees layout
Waits 1s ‚Üí Sees some content
Waits 2s ‚Üí Sees more content
Waits 3s ‚Üí Sees all content
Perceived wait: 0.5 seconds!
```

---

## Choosing the Right Strategy

### Decision Tree

```
Start
 ‚îú‚îÄ Is data user-specific or requires auth?
 ‚îÇ   ‚îî‚îÄ Yes ‚Üí SSR or CSR
 ‚îÇ       ‚îú‚îÄ Need SEO? ‚Üí SSR
 ‚îÇ       ‚îî‚îÄ No SEO needed? ‚Üí CSR
 ‚îÇ
 ‚îî‚îÄ No (public data)
     ‚îú‚îÄ Does data change?
     ‚îÇ   ‚îú‚îÄ Never or rarely ‚Üí SSG
     ‚îÇ   ‚îú‚îÄ Periodically ‚Üí ISR
     ‚îÇ   ‚îî‚îÄ Real-time ‚Üí SSR
     ‚îÇ
     ‚îî‚îÄ How many pages?
         ‚îú‚îÄ < 1000 ‚Üí SSG
         ‚îú‚îÄ > 1000 ‚Üí ISR with fallback
         ‚îî‚îÄ > 100k ‚Üí SSR or on-demand ISR
```

### Real-World Examples

**Blog:**
```typescript
// SSG for old posts
// ISR for recent posts (revalidate: 3600)
// On-demand revalidation when published
```

**E-commerce:**
```typescript
// SSG for popular products
// ISR for all products (revalidate: 300)
// SSR for cart/checkout
// CSR for live stock updates
```

**Dashboard:**
```typescript
// SSR for initial render (auth check)
// CSR with SWR for real-time updates
// Streaming for independent widgets
```

**Documentation:**
```typescript
// Pure SSG (content rarely changes)
// On-demand revalidation when docs updated
```

---

## Summary: Rendering Strategies

| Strategy | When Data Renders | Revalidation | Use Case |
|----------|------------------|--------------|----------|
| **SSR** | Every request | N/A | User-specific, real-time |
| **SSG** | Build time | Never | Static content |
| **ISR** | Build + periodic | Timed or on-demand | Frequently updated |
| **CSR** | Browser | Client-controlled | Interactive dashboards |

## Key Takeaways

1. **SSR** is slowest but always fresh
2. **SSG** is fastest but can be stale
3. **ISR** gives the best of both worlds for most use cases
4. **Streaming** improves perceived performance dramatically
5. **Mix strategies** in the same app for optimal results

## Practice Exercises

1. Build a blog with ISR:
   - Popular posts pre-generated
   - Others generated on-demand
   - Revalidate every hour

2. Create a product page:
   - SSG for product info
   - CSR for live stock updates
   - On-demand revalidation from CMS

3. Build a dashboard:
   - SSR for user-specific data
   - Streaming for independent widgets
   - CSR for real-time charts

4. Compare performance:
   - Build same page with SSR, SSG, and ISR
   - Measure TTFB, FCP, and LCP
   - Analyze trade-offs

## Interview Questions to Master

1. "Explain the difference between SSR and SSG"
2. "When would you use ISR over SSG?"
3. "How does streaming improve perceived performance?"
4. "What are the performance implications of SSR?"
5. "How would you optimize a high-traffic product listing page?"

## Next Steps

You now understand Next.js fundamentals, the App Router, and rendering strategies. Next, you should study:
- Data fetching patterns in depth
- Caching strategies
- Performance optimization
- Production deployment

Keep practicing by building real applications that use multiple rendering strategies!