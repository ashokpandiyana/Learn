# Chapter 8: State Management - In-Depth Guide

## 8.1 React State Basics

### useState Hook

#### Basic Usage

```jsx
'use client';

import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}
```

#### Functional Updates

```jsx
'use client';

import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  // ❌ Wrong - May cause issues with concurrent updates
  const incrementWrong = () => {
    setCount(count + 1);
    setCount(count + 1); // Still only increments by 1
  };

  // ✅ Correct - Uses previous state
  const incrementCorrect = () => {
    setCount(prevCount => prevCount + 1);
    setCount(prevCount => prevCount + 1); // Increments by 2
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={incrementCorrect}>Increment by 2</button>
    </div>
  );
}
```

#### Complex State Objects

```jsx
'use client';

import { useState } from 'react';

export default function UserForm() {
  const [user, setUser] = useState({
    name: '',
    email: '',
    age: 0,
    preferences: {
      newsletter: false,
      notifications: true,
    },
  });

  // ❌ Wrong - Loses other properties
  const updateNameWrong = (name) => {
    setUser({ name });
  };

  // ✅ Correct - Spread previous state
  const updateName = (name) => {
    setUser(prevUser => ({
      ...prevUser,
      name,
    }));
  };

  // ✅ Correct - Nested object update
  const toggleNewsletter = () => {
    setUser(prevUser => ({
      ...prevUser,
      preferences: {
        ...prevUser.preferences,
        newsletter: !prevUser.preferences.newsletter,
      },
    }));
  };

  return (
    <div>
      <input
        value={user.name}
        onChange={(e) => updateName(e.target.value)}
        placeholder="Name"
      />
      <input
        value={user.email}
        onChange={(e) => setUser(prev => ({ ...prev, email: e.target.value }))}
        placeholder="Email"
      />
      <label>
        <input
          type="checkbox"
          checked={user.preferences.newsletter}
          onChange={toggleNewsletter}
        />
        Subscribe to newsletter
      </label>
    </div>
  );
}
```

#### Lazy Initialization

```jsx
'use client';

import { useState } from 'react';

// Expensive computation
function getInitialState() {
  console.log('Computing initial state...');
  return Array(1000).fill(0).map((_, i) => i);
}

export default function ExpensiveComponent() {
  // ❌ Wrong - Runs on every render
  const [data, setData] = useState(getInitialState());

  // ✅ Correct - Runs only once
  const [dataBetter, setDataBetter] = useState(() => getInitialState());

  return <div>{data.length} items</div>;
}
```

### useReducer Hook

#### Basic Usage

```jsx
'use client';

import { useReducer } from 'react';

// Define reducer function
function counterReducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return { count: 0 };
    case 'set':
      return { count: action.payload };
    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

export default function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>
      <button onClick={() => dispatch({ type: 'set', payload: 10 })}>
        Set to 10
      </button>
    </div>
  );
}
```

#### Complex State Management

```jsx
'use client';

import { useReducer } from 'react';

// Complex state shape
const initialState = {
  items: [],
  selectedId: null,
  filter: 'all',
  isLoading: false,
  error: null,
};

function todoReducer(state, action) {
  switch (action.type) {
    case 'FETCH_START':
      return {
        ...state,
        isLoading: true,
        error: null,
      };
    
    case 'FETCH_SUCCESS':
      return {
        ...state,
        items: action.payload,
        isLoading: false,
      };
    
    case 'FETCH_ERROR':
      return {
        ...state,
        isLoading: false,
        error: action.payload,
      };
    
    case 'ADD_ITEM':
      return {
        ...state,
        items: [...state.items, action.payload],
      };
    
    case 'REMOVE_ITEM':
      return {
        ...state,
        items: state.items.filter(item => item.id !== action.payload),
        selectedId: state.selectedId === action.payload ? null : state.selectedId,
      };
    
    case 'UPDATE_ITEM':
      return {
        ...state,
        items: state.items.map(item =>
          item.id === action.payload.id ? action.payload : item
        ),
      };
    
    case 'SELECT_ITEM':
      return {
        ...state,
        selectedId: action.payload,
      };
    
    case 'SET_FILTER':
      return {
        ...state,
        filter: action.payload,
      };
    
    default:
      return state;
  }
}

export default function TodoApp() {
  const [state, dispatch] = useReducer(todoReducer, initialState);

  const addTodo = (text) => {
    const newTodo = {
      id: Date.now(),
      text,
      completed: false,
    };
    dispatch({ type: 'ADD_ITEM', payload: newTodo });
  };

  const removeTodo = (id) => {
    dispatch({ type: 'REMOVE_ITEM', payload: id });
  };

  const filteredItems = state.items.filter(item => {
    if (state.filter === 'completed') return item.completed;
    if (state.filter === 'active') return !item.completed;
    return true;
  });

  return (
    <div>
      {state.isLoading && <div>Loading...</div>}
      {state.error && <div>Error: {state.error}</div>}
      
      <div>
        <button onClick={() => dispatch({ type: 'SET_FILTER', payload: 'all' })}>
          All
        </button>
        <button onClick={() => dispatch({ type: 'SET_FILTER', payload: 'active' })}>
          Active
        </button>
        <button onClick={() => dispatch({ type: 'SET_FILTER', payload: 'completed' })}>
          Completed
        </button>
      </div>

      <ul>
        {filteredItems.map(item => (
          <li key={item.id}>
            {item.text}
            <button onClick={() => removeTodo(item.id)}>Remove</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### Context API

#### Basic Context

```jsx
'use client';

import { createContext, useContext, useState } from 'react';

// Create context
const ThemeContext = createContext(undefined);

// Provider component
export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// Custom hook for consuming context
export function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// Usage in component
function Header() {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <header className={theme}>
      <button onClick={toggleTheme}>
        Switch to {theme === 'light' ? 'dark' : 'light'} mode
      </button>
    </header>
  );
}

// App setup
export default function App({ children }) {
  return (
    <ThemeProvider>
      <Header />
      {children}
    </ThemeProvider>
  );
}
```

#### Complex Context with Reducer

```jsx
'use client';

import { createContext, useContext, useReducer } from 'react';

// State shape
const initialState = {
  user: null,
  isAuthenticated: false,
  token: null,
  loading: false,
};

// Reducer
function authReducer(state, action) {
  switch (action.type) {
    case 'LOGIN_START':
      return { ...state, loading: true };
    
    case 'LOGIN_SUCCESS':
      return {
        ...state,
        user: action.payload.user,
        token: action.payload.token,
        isAuthenticated: true,
        loading: false,
      };
    
    case 'LOGIN_FAILURE':
      return { ...initialState };
    
    case 'LOGOUT':
      return { ...initialState };
    
    default:
      return state;
  }
}

// Context
const AuthContext = createContext(undefined);

// Provider
export function AuthProvider({ children }) {
  const [state, dispatch] = useReducer(authReducer, initialState);

  const login = async (email, password) => {
    dispatch({ type: 'LOGIN_START' });
    
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
      });
      
      const data = await response.json();
      
      if (response.ok) {
        dispatch({
          type: 'LOGIN_SUCCESS',
          payload: { user: data.user, token: data.token },
        });
      } else {
        dispatch({ type: 'LOGIN_FAILURE' });
      }
    } catch (error) {
      dispatch({ type: 'LOGIN_FAILURE' });
    }
  };

  const logout = () => {
    dispatch({ type: 'LOGOUT' });
  };

  return (
    <AuthContext.Provider value={{ ...state, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

// Hook
export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}

// Usage
function LoginForm() {
  const { login, loading } = useAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    login(email, password);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input value={email} onChange={(e) => setEmail(e.target.value)} />
      <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} />
      <button disabled={loading}>Login</button>
    </form>
  );
}
```

#### Performance Optimization with Context

```jsx
'use client';

import { createContext, useContext, useState, useMemo, useCallback } from 'react';

// Split context for better performance
const UserStateContext = createContext(undefined);
const UserDispatchContext = createContext(undefined);

export function UserProvider({ children }) {
  const [user, setUser] = useState(null);

  // Memoize dispatch functions to prevent unnecessary re-renders
  const dispatch = useMemo(
    () => ({
      setUser,
      updateUser: (updates) => setUser(prev => ({ ...prev, ...updates })),
      clearUser: () => setUser(null),
    }),
    []
  );

  return (
    <UserStateContext.Provider value={user}>
      <UserDispatchContext.Provider value={dispatch}>
        {children}
      </UserDispatchContext.Provider>
    </UserStateContext.Provider>
  );
}

// Separate hooks for state and dispatch
export function useUserState() {
  const context = useContext(UserStateContext);
  if (context === undefined) {
    throw new Error('useUserState must be used within UserProvider');
  }
  return context;
}

export function useUserDispatch() {
  const context = useContext(UserDispatchContext);
  if (context === undefined) {
    throw new Error('useUserDispatch must be used within UserProvider');
  }
  return context;
}

// Components only re-render when their subscribed context changes
function UserProfile() {
  const user = useUserState(); // Re-renders when user changes
  return <div>{user?.name}</div>;
}

function UpdateUserButton() {
  const dispatch = useUserDispatch(); // Doesn't re-render when user changes
  return (
    <button onClick={() => dispatch.updateUser({ name: 'New Name' })}>
      Update
    </button>
  );
}
```

---

## 8.2 Global State Solutions

### Redux Toolkit

#### Setup

```bash
npm install @reduxjs/toolkit react-redux
```

#### Store Configuration

```javascript
// store/store.js
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './slices/counterSlice';
import userReducer from './slices/userSlice';
import todosReducer from './slices/todosSlice';

export const makeStore = () => {
  return configureStore({
    reducer: {
      counter: counterReducer,
      user: userReducer,
      todos: todosReducer,
    },
    middleware: (getDefaultMiddleware) =>
      getDefaultMiddleware({
        serializableCheck: {
          // Ignore these action types
          ignoredActions: ['user/setUser'],
          // Ignore these paths in the state
          ignoredPaths: ['user.timestamp'],
        },
      }),
  });
};

// Export types
export type AppStore = ReturnType<typeof makeStore>;
export type RootState = ReturnType<AppStore['getState']>;
export type AppDispatch = AppStore['dispatch'];
```

#### Provider Setup (App Router)

```jsx
// app/StoreProvider.jsx
'use client';

import { useRef } from 'react';
import { Provider } from 'react-redux';
import { makeStore } from '@/store/store';

export default function StoreProvider({ children }) {
  const storeRef = useRef();
  
  if (!storeRef.current) {
    storeRef.current = makeStore();
  }

  return <Provider store={storeRef.current}>{children}</Provider>;
}

// app/layout.js
import StoreProvider from './StoreProvider';

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <StoreProvider>{children}</StoreProvider>
      </body>
    </html>
  );
}
```

#### Creating Slices

```javascript
// store/slices/todosSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// Async thunk for API calls
export const fetchTodos = createAsyncThunk(
  'todos/fetchTodos',
  async (userId, { rejectWithValue }) => {
    try {
      const response = await fetch(`/api/todos?userId=${userId}`);
      const data = await response.json();
      return data;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const addTodoAsync = createAsyncThunk(
  'todos/addTodo',
  async (todo) => {
    const response = await fetch('/api/todos', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(todo),
    });
    return await response.json();
  }
);

const todosSlice = createSlice({
  name: 'todos',
  initialState: {
    items: [],
    status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'
    error: null,
    filter: 'all',
  },
  reducers: {
    // Synchronous actions
    addTodo: (state, action) => {
      state.items.push(action.payload);
    },
    removeTodo: (state, action) => {
      state.items = state.items.filter(todo => todo.id !== action.payload);
    },
    toggleTodo: (state, action) => {
      const todo = state.items.find(todo => todo.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
    setFilter: (state, action) => {
      state.filter = action.payload;
    },
  },
  extraReducers: (builder) => {
    // Handle async actions
    builder
      .addCase(fetchTodos.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchTodos.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.items = action.payload;
      })
      .addCase(fetchTodos.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload;
      })
      .addCase(addTodoAsync.fulfilled, (state, action) => {
        state.items.push(action.payload);
      });
  },
});

export const { addTodo, removeTodo, toggleTodo, setFilter } = todosSlice.actions;
export default todosSlice.reducer;

// Selectors
export const selectAllTodos = (state) => state.todos.items;
export const selectTodoById = (state, todoId) =>
  state.todos.items.find(todo => todo.id === todoId);
export const selectFilteredTodos = (state) => {
  const { items, filter } = state.todos;
  if (filter === 'completed') return items.filter(todo => todo.completed);
  if (filter === 'active') return items.filter(todo => !todo.completed);
  return items;
};
```

#### Using Redux in Components

```jsx
'use client';

import { useSelector, useDispatch } from 'react-redux';
import { useEffect } from 'react';
import {
  fetchTodos,
  addTodo,
  removeTodo,
  toggleTodo,
  setFilter,
  selectFilteredTodos,
} from '@/store/slices/todosSlice';

export default function TodoList() {
  const dispatch = useDispatch();
  const todos = useSelector(selectFilteredTodos);
  const status = useSelector(state => state.todos.status);
  const error = useSelector(state => state.todos.error);

  useEffect(() => {
    if (status === 'idle') {
      dispatch(fetchTodos());
    }
  }, [status, dispatch]);

  const handleAddTodo = () => {
    const newTodo = {
      id: Date.now(),
      text: 'New todo',
      completed: false,
    };
    dispatch(addTodo(newTodo));
  };

  if (status === 'loading') return <div>Loading...</div>;
  if (status === 'failed') return <div>Error: {error}</div>;

  return (
    <div>
      <div>
        <button onClick={() => dispatch(setFilter('all'))}>All</button>
        <button onClick={() => dispatch(setFilter('active'))}>Active</button>
        <button onClick={() => dispatch(setFilter('completed'))}>Completed</button>
      </div>

      <button onClick={handleAddTodo}>Add Todo</button>

      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => dispatch(toggleTodo(todo.id))}
            />
            <span>{todo.text}</span>
            <button onClick={() => dispatch(removeTodo(todo.id))}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### Zustand (Lightweight Alternative)

#### Setup

```bash
npm install zustand
```

#### Creating a Store

```javascript
// store/useStore.js
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

// Simple store
export const useCounterStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 }),
}));

// Store with async actions
export const useTodoStore = create(
  devtools(
    persist(
      (set, get) => ({
        todos: [],
        isLoading: false,
        error: null,

        // Async action
        fetchTodos: async () => {
          set({ isLoading: true });
          try {
            const response = await fetch('/api/todos');
            const todos = await response.json();
            set({ todos, isLoading: false });
          } catch (error) {
            set({ error: error.message, isLoading: false });
          }
        },

        addTodo: (todo) =>
          set((state) => ({ todos: [...state.todos, todo] })),

        removeTodo: (id) =>
          set((state) => ({
            todos: state.todos.filter((todo) => todo.id !== id),
          })),

        toggleTodo: (id) =>
          set((state) => ({
            todos: state.todos.map((todo) =>
              todo.id === id ? { ...todo, completed: !todo.completed } : todo
            ),
          })),

        // Computed values
        get completedTodos() {
          return get().todos.filter((todo) => todo.completed);
        },

        get activeTodos() {
          return get().todos.filter((todo) => !todo.completed);
        },
      }),
      {
        name: 'todo-storage', // localStorage key
        partialize: (state) => ({ todos: state.todos }), // Only persist todos
      }
    )
  )
);

// Sliced store for better performance
export const useUserStore = create((set) => ({
  user: null,
  setUser: (user) => set({ user }),
  clearUser: () => set({ user: null }),
}));
```

#### Using Zustand in Components

```jsx
'use client';

import { useTodoStore } from '@/store/useStore';
import { useEffect } from 'react';

export default function TodoList() {
  // Subscribe to specific state
  const todos = useTodoStore((state) => state.todos);
  const isLoading = useTodoStore((state) => state.isLoading);
  const fetchTodos = useTodoStore((state) => state.fetchTodos);
  const addTodo = useTodoStore((state) => state.addTodo);
  const removeTodo = useTodoStore((state) => state.removeTodo);
  const toggleTodo = useTodoStore((state) => state.toggleTodo);

  useEffect(() => {
    fetchTodos();
  }, [fetchTodos]);

  const handleAddTodo = () => {
    const newTodo = {
      id: Date.now(),
      text: 'New todo',
      completed: false,
    };
    addTodo(newTodo);
  };

  if (isLoading) return <div>Loading...</div>;

  return (
    <div>
      <button onClick={handleAddTodo}>Add Todo</button>
      <ul>
        {todos.map((todo) => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            />
            <span>{todo.text}</span>
            <button onClick={() => removeTodo(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}

// Component that only re-renders when user changes
function UserProfile() {
  const user = useUserStore((state) => state.user);
  // This component won't re-render when todos change
  return <div>{user?.name}</div>;
}
```

---

## 8.3 Server State Management

### SWR (Stale-While-Revalidate)

#### Basic Usage

```jsx
'use client';

import useSWR from 'swr';

const fetcher = (url) => fetch(url).then((res) => res.json());

export default function Profile() {
  const { data, error, isLoading } = useSWR('/api/user', fetcher);

  if (error) return <div>Failed to load</div>;
  if (isLoading) return <div>Loading...</div>;

  return <div>Hello {data.name}!</div>;
}
```

#### Advanced Configuration

```jsx
'use client';

import useSWR from 'swr';

export default function Dashboard() {
  const { data, error, isLoading, mutate } = useSWR(
    '/api/dashboard',
    fetcher,
    {
      refreshInterval: 10000, // Poll every 10 seconds
      revalidateOnFocus: true, // Revalidate when window gets focus
      revalidateOnReconnect: true, // Revalidate when internet reconnects
      dedupingInterval: 2000, // Dedupe requests within 2 seconds
      errorRetryCount: 3, // Retry failed requests 3 times
      errorRetryInterval: 5000, // Wait 5 seconds between retries
      onSuccess: (data) => {
        console.log('Data loaded successfully', data);
      },
      onError: (error) => {
        console.error('Error loading data', error);
      },
    }
  );

  const handleRefresh = () => {
    mutate(); // Manually revalidate
  };

  return (
    <div>
      <button onClick={handleRefresh}>Refresh</button>
      {data && <div>{JSON.stringify(data)}</div>}
    </div>
  );
}
```

#### Mutations and Optimistic Updates

```jsx
'use client';

import useSWR, { useSWRConfig } from 'swr';

export default function TodoList() {
  const { data: todos, mutate } = useSWR('/api/todos', fetcher);
  const { mutate: globalMutate } = useSWRConfig();

  const addTodo = async (text) => {
    const newTodo = { id: Date.now(), text, completed: false };

    // Optimistic update
    mutate(
      async (currentTodos) => {
        // Update local data immediately
        const optimisticTodos = [...currentTodos, newTodo];

        // Make API call
        try {
          const response = await fetch('/api/todos', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text }),
          });
          const addedTodo = await response.json();

          // Replace optimistic todo with server response
          return [...currentTodos, addedTodo];
        } catch (error) {
          // Rollback on error
          return currentTodos;
        }
      },
      {
        optimisticData: [...todos, newTodo],
        rollbackOnError: true,
        populateCache: true,
        revalidate: false,
      }
    );
  };

  const deleteTodo = async (id) => {
    // Optimistic delete
    mutate(
      todos.filter((todo) => todo.id !== id),
      false // Don't revalidate
    );

    // Make API call
    await fetch(`/api/todos/${id}`, { method: 'DELETE' });

    // Revalidate
    mutate();
  };

  return (
    <div>
      {todos?.map((todo) => (
        <div key={todo.id}>
          {todo.text}
          <button onClick={() => deleteTodo(todo.id)}>Delete</button>
        </div>
      ))}
      <button onClick={() => addTodo('New todo')}>Add Todo</button>
    </div>
  );
}
```

### React Query / TanStack Query

#### Setup

```bash
npm install @tanstack/react-query
```

#### Provider Setup

```jsx
// app/providers.jsx
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { useState } from 'react';

export default function Providers({ children }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000, // 1 minute
            cacheTime: 5 * 60 * 1000, // 5 minutes
            refetchOnWindowFocus: true,
            refetchOnReconnect: true,
            retry: 1,
          },
        },
      })
  );

  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}

// app/layout.js
import Providers from './providers';

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
```

#### Queries

```jsx
'use client';

import { useQuery, useQueries, useInfiniteQuery } from '@tanstack/react-query';

// Basic query
export function UserProfile() {
  const { data, error, isLoading, refetch } = useQuery({
    queryKey: ['user'],
    queryFn: () => fetch('/api/user').then((res) => res.json()),
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
    cacheTime: 10 * 60 * 1000, // Keep in cache for 10 minutes
    retry: 3,
  });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <h1>{data.name}</h1>
      <button onClick={() => refetch()}>Refresh</button>
    </div>
  );
}

// Dependent queries
export function UserPosts({ userId }) {
  const { data: user } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetch(`/api/users/${userId}`).then((res) => res.json()),
  });

  const { data: posts } = useQuery({
    queryKey: ['posts', userId],
    queryFn: () => fetch(`/api/posts?userId=${userId}`).then((res) => res.json()),
    enabled: !!user, // Only fetch when user is loaded
  });

  return <div>{posts?.map((post) => <div key={post.id}>{post.title}</div>)}</div>;
}

// Parallel queries
export function Dashboard() {
  const results = useQueries({
    queries: [
      {
        queryKey: ['users'],
        queryFn: () => fetch('/api/users').then((res) => res.json()),
      },
      {
        queryKey: ['posts'],
        queryFn: () => fetch('/api/posts').then((res) => res.json()),
      },
      {
        queryKey: ['stats'],
        queryFn: () => fetch('/api/stats').then((res) => res.json()),
      },
    ],
  });

  const [usersQuery, postsQuery, statsQuery] = results;

  if (results.some((query) => query.isLoading)) return <div>Loading...</div>;

  return (
    <div>
      <div>Users: {usersQuery.data?.length}</div>
      <div>Posts: {postsQuery.data?.length}</div>
      <div>Stats: {JSON.stringify(statsQuery.data)}</div>
    </div>
  );
}

// Infinite query (pagination)
export function InfinitePosts() {
  const {
    data,
    error,
    fetchNextPage,
    hasNextPage,
    isFetching,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ['posts'],
    queryFn: ({ pageParam = 1 }) =>
      fetch(`/api/posts?page=${pageParam}`).then((res) => res.json()),
    getNextPageParam: (lastPage, pages) => {
      return lastPage.hasMore ? pages.length + 1 : undefined;
    },
  });

  return (
    <div>
      {data?.pages.map((page, i) => (
        <div key={i}>
          {page.posts.map((post) => (
            <div key={post.id}>{post.title}</div>
          ))}
        </div>
      ))}

      <button
        onClick={() => fetchNextPage()}
        disabled={!hasNextPage || isFetchingNextPage}
      >
        {isFetchingNextPage
          ? 'Loading more...'
          : hasNextPage
          ? 'Load More'
          : 'Nothing more to load'}
      </button>

      <div>{isFetching && !isFetchingNextPage ? 'Fetching...' : null}</div>
    </div>
  );
}
```

#### Mutations

```jsx
'use client';

import { useMutation, useQueryClient } from '@tanstack/react-query';

export function CreatePost() {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: (newPost) =>
      fetch('/api/posts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newPost),
      }).then((res) => res.json()),
    
    onMutate: async (newPost) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['posts'] });

      // Snapshot previous value
      const previousPosts = queryClient.getQueryData(['posts']);

      // Optimistically update
      queryClient.setQueryData(['posts'], (old) => [...old, newPost]);

      // Return context with snapshot
      return { previousPosts };
    },
    
    onError: (err, newPost, context) => {
      // Rollback on error
      queryClient.setQueryData(['posts'], context.previousPosts);
    },
    
    onSuccess: (data) => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: ['posts'] });
    },
    
    onSettled: () => {
      // Always refetch after error or success
      queryClient.invalidateQueries({ queryKey: ['posts'] });
    },
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    const formData = new FormData(e.target);
    mutation.mutate({
      title: formData.get('title'),
      body: formData.get('body'),
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input name="title" placeholder="Title" />
      <textarea name="body" placeholder="Body" />
      <button type="submit" disabled={mutation.isLoading}>
        {mutation.isLoading ? 'Creating...' : 'Create Post'}
      </button>
      {mutation.isError && <div>Error: {mutation.error.message}</div>}
      {mutation.isSuccess && <div>Post created!</div>}
    </form>
  );
}
```

---

## 8.4 URL State

### Search Params

```jsx
'use client';

import { useSearchParams, usePathname, useRouter } from 'next/navigation';

export default function FilteredList() {
  const searchParams = useSearchParams();
  const pathname = usePathname();
  const router = useRouter();

  const filter = searchParams.get('filter') || 'all';
  const sort = searchParams.get('sort') || 'date';
  const page = parseInt(searchParams.get('page') || '1');

  const updateFilter = (newFilter) => {
    const params = new URLSearchParams(searchParams);
    params.set('filter', newFilter);
    params.set('page', '1'); // Reset to first page
    router.push(`${pathname}?${params.toString()}`);
  };

  const updateSort = (newSort) => {
    const params = new URLSearchParams(searchParams);
    params.set('sort', newSort);
    router.push(`${pathname}?${params.toString()}`);
  };

  const nextPage = () => {
    const params = new URLSearchParams(searchParams);
    params.set('page', (page + 1).toString());
    router.push(`${pathname}?${params.toString()}`);
  };

  return (
    <div>
      <div>
        <button onClick={() => updateFilter('all')}>All</button>
        <button onClick={() => updateFilter('active')}>Active</button>
        <button onClick={() => updateFilter('completed')}>Completed</button>
      </div>

      <select value={sort} onChange={(e) => updateSort(e.target.value)}>
        <option value="date">Date</option>
        <option value="name">Name</option>
        <option value="priority">Priority</option>
      </select>

      <div>Page: {page}</div>
      <button onClick={nextPage}>Next Page</button>
    </div>
  );
}
```

### Custom Hook for URL State

```javascript
// hooks/useURLState.js
'use client';

import { useSearchParams, usePathname, useRouter } from 'next/navigation';
import { useCallback } from 'react';

export function useURLState(key, defaultValue) {
  const searchParams = useSearchParams();
  const pathname = usePathname();
  const router = useRouter();

  const value = searchParams.get(key) || defaultValue;

  const setValue = useCallback(
    (newValue) => {
      const params = new URLSearchParams(searchParams);
      if (newValue === defaultValue || newValue === '') {
        params.delete(key);
      } else {
        params.set(key, newValue);
      }
      router.push(`${pathname}?${params.toString()}`);
    },
    [key, defaultValue, searchParams, pathname, router]
  );

  return [value, setValue];
}

// Usage
export default function SearchPage() {
  const [query, setQuery] = useURLState('q', '');
  const [category, setCategory] = useURLState('category', 'all');

  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      />
      <select value={category} onChange={(e) => setCategory(e.target.value)}>
        <option value="all">All</option>
        <option value="tech">Tech</option>
        <option value="business">Business</option>
      </select>
    </div>
  );
}
```

### Shareable State via URL

```jsx
'use client';

import { useSearchParams } from 'next/navigation';
import { useEffect } from 'react';

export default function SharedFilters() {
  const searchParams = useSearchParams();

  // Parse complex state from URL
  const state = {
    filters: searchParams.get('filters')?.split(',') || [],
    dateRange: {
      start: searchParams.get('start') || null,
      end: searchParams.get('end') || null,
    },
    view: searchParams.get('view') || 'grid',
  };

  // Generate shareable URL
  const getShareableURL = () => {
    return `${window.location.origin}${window.location.pathname}?${searchParams.toString()}`;
  };

  const copyLink = () => {
    navigator.clipboard.writeText(getShareableURL());
    alert('Link copied!');
  };

  return (
    <div>
      <div>Current filters: {state.filters.join(', ')}</div>
      <div>View: {state.view}</div>
      <button onClick={copyLink}>Share Filters</button>
    </div>
  );
}
```

This completes Chapter 8 on State Management with comprehensive examples for all state management approaches in Next.js!