# Chapter 13: Deployment and DevOps - In-Depth Guide

## 13.1 Vercel Deployment

### Why Vercel?

Vercel is the company behind Next.js and provides the most optimized deployment platform for Next.js applications:
- Zero-config deployment
- Automatic HTTPS
- Global CDN
- Edge Functions support
- Preview deployments for every PR
- Built-in analytics and monitoring

### Setting Up Vercel Deployment

#### 1. Install Vercel CLI

```bash
npm install -g vercel
```

#### 2. Deploy from CLI

```bash
# Login to Vercel
vercel login

# Deploy to preview
vercel

# Deploy to production
vercel --prod
```

#### 3. Git Integration (Recommended)

Connect your GitHub/GitLab/Bitbucket repository:

1. Go to https://vercel.com/new
2. Import your Git repository
3. Configure project settings
4. Deploy

**Every push to your repository will create a preview deployment.**  
**Merges to main/production branch will deploy to production.**

### Vercel Configuration

```json
// vercel.json
{
  "buildCommand": "npm run build",
  "devCommand": "npm run dev",
  "installCommand": "npm install",
  "framework": "nextjs",
  "regions": ["iad1", "sfo1"], // Specify deployment regions
  "env": {
    "DATABASE_URL": "@database-url",
    "API_KEY": "@api-key"
  },
  "build": {
    "env": {
      "NEXT_PUBLIC_API_URL": "https://api.example.com"
    }
  },
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "X-Content-Type-Options",
          "value": "nosniff"
        },
        {
          "key": "X-Frame-Options",
          "value": "DENY"
        },
        {
          "key": "X-XSS-Protection",
          "value": "1; mode=block"
        }
      ]
    }
  ],
  "redirects": [
    {
      "source": "/old-page",
      "destination": "/new-page",
      "permanent": true
    }
  ],
  "rewrites": [
    {
      "source": "/api/:path*",
      "destination": "https://api.example.com/:path*"
    }
  ]
}
```

### Environment Variables in Vercel

#### Setting Environment Variables

1. **Via Vercel Dashboard:**
   - Go to Project Settings â†’ Environment Variables
   - Add variables for Development, Preview, Production

2. **Via CLI:**
```bash
# Add environment variable
vercel env add DATABASE_URL

# Pull environment variables to local
vercel env pull .env.local
```

#### Environment Variable Types

```bash
# .env.local (local development)
DATABASE_URL="postgresql://localhost:5432/mydb"
NEXT_PUBLIC_API_URL="http://localhost:3000/api"

# Vercel Environment Variables
# Production
DATABASE_URL="postgresql://prod.example.com:5432/mydb"
NEXT_PUBLIC_API_URL="https://myapp.com/api"

# Preview
DATABASE_URL="postgresql://staging.example.com:5432/mydb"
NEXT_PUBLIC_API_URL="https://preview.myapp.com/api"
```

**Important:** Only variables prefixed with `NEXT_PUBLIC_` are exposed to the browser.

### Preview Deployments

Every PR gets a unique preview URL:

```yaml
# .github/workflows/vercel-preview.yml
name: Vercel Preview Deployment

on:
  pull_request:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v20
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.ORG_ID}}
          vercel-project-id: ${{ secrets.PROJECT_ID}}
```

### Custom Domains

```bash
# Add custom domain via CLI
vercel domains add example.com

# Add domain via Vercel Dashboard
# Go to Project Settings â†’ Domains
# Add domain and follow DNS configuration
```

DNS Configuration:
```
Type: A
Name: @
Value: 76.76.21.21

Type: CNAME
Name: www
Value: cname.vercel-dns.com
```

---

## 13.2 Self-Hosting

### Why Self-Host?

- Full control over infrastructure
- Compliance requirements
- Custom server configurations
- Cost optimization for large scale

### Standalone Mode

Next.js can output a standalone build that includes only necessary files:

```javascript
// next.config.js
module.exports = {
  output: 'standalone',
}
```

This creates a minimal deployment in `.next/standalone/`:
```
.next/
  standalone/
    node_modules/
    server.js
    .next/
  static/
```

### Node.js Server Deployment

#### 1. Build the Application

```bash
npm run build
```

#### 2. Start the Server

```bash
# Production mode
NODE_ENV=production node .next/standalone/server.js

# With PM2 (Process Manager)
npm install -g pm2
pm2 start .next/standalone/server.js --name "nextjs-app"
pm2 save
pm2 startup
```

#### 3. PM2 Ecosystem File

```javascript
// ecosystem.config.js
module.exports = {
  apps: [{
    name: 'nextjs-app',
    script: '.next/standalone/server.js',
    instances: 'max',
    exec_mode: 'cluster',
    env: {
      NODE_ENV: 'production',
      PORT: 3000,
    },
    error_file: './logs/err.log',
    out_file: './logs/out.log',
    log_date_format: 'YYYY-MM-DD HH:mm Z',
    merge_logs: true,
  }]
}

// Start with: pm2 start ecosystem.config.js
```

### Docker Deployment

#### Dockerfile (Multi-stage Build)

```dockerfile
# Dockerfile
FROM node:18-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

# Install dependencies based on the preferred package manager
COPY package.json package-lock.json* ./
RUN npm ci

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Set environment variables for build
ENV NEXT_TELEMETRY_DISABLED 1

# Build the application
RUN npm run build

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production
ENV NEXT_TELEMETRY_DISABLED 1

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

# Copy necessary files
COPY --from=builder /app/public ./public

# Set the correct permission for prerender cache
RUN mkdir .next
RUN chown nextjs:nodejs .next

# Automatically leverage output traces to reduce image size
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT 3000
ENV HOSTNAME "0.0.0.0"

CMD ["node", "server.js"]
```

#### Docker Compose

```yaml
# docker-compose.yml
version: '3.8'

services:
  nextjs:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
      - NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL}
    depends_on:
      - postgres
    restart: unless-stopped
    networks:
      - app-network

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=myuser
      - POSTGRES_PASSWORD=mypassword
      - POSTGRES_DB=mydb
    volumes:
      - postgres-data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: unless-stopped
    networks:
      - app-network

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - nextjs
    restart: unless-stopped
    networks:
      - app-network

volumes:
  postgres-data:

networks:
  app-network:
    driver: bridge
```

#### Build and Run

```bash
# Build image
docker build -t nextjs-app .

# Run container
docker run -p 3000:3000 nextjs-app

# Using docker-compose
docker-compose up -d

# View logs
docker-compose logs -f nextjs

# Stop services
docker-compose down
```

### Nginx Reverse Proxy

```nginx
# nginx.conf
events {
  worker_connections 1024;
}

http {
  upstream nextjs {
    server nextjs:3000;
  }

  # Rate limiting
  limit_req_zone $binary_remote_addr zone=limitreqsbyaddr:20m rate=10r/s;
  limit_req_status 429;

  server {
    listen 80;
    server_name example.com www.example.com;

    # Redirect HTTP to HTTPS
    return 301 https://$server_name$request_uri;
  }

  server {
    listen 443 ssl http2;
    server_name example.com www.example.com;

    # SSL configuration
    ssl_certificate /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Gzip compression
    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

    # Client body size
    client_max_body_size 10M;

    location / {
      # Rate limiting
      limit_req zone=limitreqsbyaddr burst=20 nodelay;

      proxy_pass http://nextjs;
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection 'upgrade';
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_cache_bypass $http_upgrade;
      
      # Timeouts
      proxy_connect_timeout 60s;
      proxy_send_timeout 60s;
      proxy_read_timeout 60s;
    }

    # Cache static assets
    location /_next/static {
      proxy_pass http://nextjs;
      add_header Cache-Control "public, max-age=31536000, immutable";
    }

    location /static {
      proxy_pass http://nextjs;
      add_header Cache-Control "public, max-age=31536000, immutable";
    }
  }
}
```

---

## 13.3 Static Export

### When to Use Static Export

- Documentation sites
- Blogs without dynamic features
- Marketing sites
- Sites that don't need SSR or API routes

### Configuration

```javascript
// next.config.js
module.exports = {
  output: 'export',
  images: {
    unoptimized: true, // Required for static export
  },
  trailingSlash: true, // Optional: adds trailing slash to all paths
}
```

### Build and Export

```bash
npm run build
```

This creates an `out/` directory with static HTML files.

### Limitations

- No API Routes
- No Server-Side Rendering
- No Incremental Static Regeneration
- No Image Optimization (unless using external service)
- No Rewrites or Redirects (must be handled by hosting)
- No Middleware

### Deploying Static Export

#### To GitHub Pages

```yaml
# .github/workflows/deploy.yml
name: Deploy to GitHub Pages

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build
        run: npm run build
      
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v2
        with:
          path: ./out

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v2
```

#### To AWS S3

```bash
# Install AWS CLI
aws configure

# Sync to S3
aws s3 sync out/ s3://your-bucket-name --delete

# With CloudFront invalidation
aws cloudfront create-invalidation --distribution-id YOUR_DIST_ID --paths "/*"
```

#### To Netlify

```toml
# netlify.toml
[build]
  command = "npm run build"
  publish = "out"

[[headers]]
  for = "/*"
  [headers.values]
    X-Frame-Options = "DENY"
    X-XSS-Protection = "1; mode=block"
    X-Content-Type-Options = "nosniff"

[[redirects]]
  from = "/old-path"
  to = "/new-path"
  status = 301
```

---

## 13.4 Edge Deployment

### Understanding Edge Runtime

Edge runtime runs code closer to users globally, reducing latency:

- Limited API surface (no Node.js APIs like `fs`)
- Faster cold starts
- Better performance for dynamic content
- Works with Middleware and Route Handlers

### Middleware on Edge

```typescript
// middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const country = request.geo?.country || 'US'
  const response = NextResponse.next()
  
  // Add custom header
  response.headers.set('x-user-country', country)
  
  // Redirect based on location
  if (country === 'GB' && !request.nextUrl.pathname.startsWith('/uk')) {
    return NextResponse.redirect(new URL('/uk', request.url))
  }
  
  return response
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
}
```

### Edge API Routes

```typescript
// app/api/edge-example/route.ts
import { NextRequest, NextResponse } from 'next/server'

// Specify edge runtime
export const runtime = 'edge'

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const name = searchParams.get('name') || 'World'
  
  // Access geolocation data
  const country = request.geo?.country
  const city = request.geo?.city
  
  return NextResponse.json({
    message: `Hello ${name}`,
    location: { country, city },
    timestamp: new Date().toISOString(),
  })
}
```

### Edge Function Limitations

```typescript
// âŒ These don't work in Edge Runtime
import fs from 'fs' // No filesystem access
const buffer = Buffer.from('data') // No Buffer
process.env.CUSTOM_VAR // Limited environment access

// âœ… These work in Edge Runtime
const response = await fetch('https://api.example.com')
const text = new TextEncoder().encode('data')
const url = new URL(request.url)
```

---

## 13.5 CI/CD Pipeline

### GitHub Actions Complete Pipeline

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  NODE_VERSION: '18'

jobs:
  # Job 1: Lint and Type Check
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run ESLint
        run: npm run lint
      
      - name: Type check
        run: npm run type-check

  # Job 2: Unit Tests
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm run test:coverage
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage/coverage-final.json

  # Job 3: E2E Tests
  e2e:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Install Playwright
        run: npx playwright install --with-deps
      
      - name: Run E2E tests
        run: npm run test:e2e
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: playwright-report
          path: playwright-report/

  # Job 4: Build
  build:
    runs-on: ubuntu-latest
    needs: [lint, test]
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build application
        run: npm run build
        env:
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL }}
      
      - name: Upload build artifact
        uses: actions/upload-artifact@v3
        with:
          name: build
          path: .next/

  # Job 5: Deploy to Staging
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [build, e2e]
    if: github.ref == 'refs/heads/develop'
    environment:
      name: staging
      url: https://staging.example.com
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to Vercel Staging
        uses: amondnet/vercel-action@v20
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
          working-directory: ./

  # Job 6: Deploy to Production
  deploy-production:
    runs-on: ubuntu-latest
    needs: [build, e2e]
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://example.com
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to Vercel Production
        uses: amondnet/vercel-action@v20
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
          working-directory: ./
      
      - name: Notify Slack
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Production deployment completed!'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

### GitLab CI/CD

```yaml
# .gitlab-ci.yml
stages:
  - build
  - test
  - deploy

variables:
  NODE_VERSION: '18'

cache:
  paths:
    - node_modules/
    - .next/cache/

# Build Stage
build:
  stage: build
  image: node:${NODE_VERSION}
  script:
    - npm ci
    - npm run build
  artifacts:
    paths:
      - .next/
    expire_in: 1 hour

# Test Stage
test:unit:
  stage: test
  image: node:${NODE_VERSION}
  script:
    - npm ci
    - npm run test:coverage
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml

test:e2e:
  stage: test
  image: mcr.microsoft.com/playwright:v1.40.0-focal
  script:
    - npm ci
    - npm run test:e2e
  artifacts:
    when: always
    paths:
      - playwright-report/

# Deploy to Staging
deploy:staging:
  stage: deploy
  image: node:${NODE_VERSION}
  script:
    - npm install -g vercel
    - vercel --token ${VERCEL_TOKEN} --scope ${VERCEL_ORG_ID}
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - develop

# Deploy to Production
deploy:production:
  stage: deploy
  image: node:${NODE_VERSION}
  script:
    - npm install -g vercel
    - vercel --prod --token ${VERCEL_TOKEN} --scope ${VERCEL_ORG_ID}
  environment:
    name: production
    url: https://example.com
  only:
    - main
  when: manual
```

---

## 13.6 Monitoring and Logging

### Error Tracking with Sentry

#### Installation

```bash
npm install @sentry/nextjs
```

#### Configuration

```javascript
// sentry.client.config.js
import * as Sentry from '@sentry/nextjs'

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0,
  replaysSessionSampleRate: 0.1,
  replaysOnErrorSampleRate: 1.0,
  integrations: [
    new Sentry.BrowserTracing(),
    new Sentry.Replay(),
  ],
})

// sentry.server.config.js
import * as Sentry from '@sentry/nextjs'

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0,
})

// sentry.edge.config.js
import * as Sentry from '@sentry/nextjs'

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0,
})
```

#### Usage

```typescript
// app/api/example/route.ts
import * as Sentry from '@sentry/nextjs'

export async function GET() {
  try {
    // Your code here
    const data = await fetchData()
    return Response.json(data)
  } catch (error) {
    Sentry.captureException(error)
    return Response.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    )
  }
}
```

### Performance Monitoring

```typescript
// lib/monitoring.ts
import * as Sentry from '@sentry/nextjs'

export function measurePerformance(name: string, fn: () => void) {
  const transaction = Sentry.startTransaction({
    op: 'function',
    name,
  })
  
  try {
    fn()
  } finally {
    transaction.finish()
  }
}

// Usage
measurePerformance('processData', () => {
  // Your expensive operation
  processLargeDataset()
})
```

### Custom Logging Service

```typescript
// lib/logger.ts
type LogLevel = 'info' | 'warn' | 'error' | 'debug'

interface LogEntry {
  level: LogLevel
  message: string
  timestamp: string
  metadata?: Record<string, any>
}

class Logger {
  private serviceName: string
  
  constructor(serviceName: string) {
    this.serviceName = serviceName
  }
  
  private log(level: LogLevel, message: string, metadata?: Record<string, any>) {
    const entry: LogEntry = {
      level,
      message,
      timestamp: new Date().toISOString(),
      metadata: {
        ...metadata,
        service: this.serviceName,
      },
    }
    
    // In production, send to logging service
    if (process.env.NODE_ENV === 'production') {
      this.sendToLogService(entry)
    } else {
      // In development, console log
      console[level](JSON.stringify(entry, null, 2))
    }
  }
  
  private async sendToLogService(entry: LogEntry) {
    try {
      await fetch(process.env.LOG_SERVICE_URL!, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(entry),
      })
    } catch (error) {
      console.error('Failed to send log:', error)
    }
  }
  
  info(message: string, metadata?: Record<string, any>) {
    this.log('info', message, metadata)
  }
  
  warn(message: string, metadata?: Record<string, any>) {
    this.log('warn', message, metadata)
  }
  
  error(message: string, metadata?: Record<string, any>) {
    this.log('error', message, metadata)
  }
  
  debug(message: string, metadata?: Record<string, any>) {
    this.log('debug', message, metadata)
  }
}

export const logger = new Logger('nextjs-app')
```

### Health Check Endpoint

```typescript
// app/api/health/route.ts
import { NextResponse } from 'next/server'
import prisma from '@/lib/prisma'

export async function GET() {
  const checks = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    database: 'unknown',
    memory: {
      used: process.memoryUsage().heapUsed / 1024 / 1024,
      total: process.memoryUsage().heapTotal / 1024 / 1024,
    },
  }
  
  // Check database connection
  try {
    await prisma.$queryRaw`SELECT 1`
    checks.database = 'connected'
  } catch (error) {
    checks.database = 'disconnected'
    checks.status = 'unhealthy'
  }
  
  const statusCode = checks.status === 'healthy' ? 200 : 503
  
  return NextResponse.json(checks, { status: statusCode })
}
```

### Uptime Monitoring with Automated Checks

```yaml
# .github/workflows/uptime-check.yml
name: Uptime Check

on:
  schedule:
    - cron: '*/5 * * * *' # Every 5 minutes

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Check website
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" https://example.com/api/health)
          if [ $response -ne 200 ]; then
            echo "Site is down! Status code: $response"
            exit 1
          fi
      
      - name: Notify on failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'ðŸš¨ Website is down!'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

---

## Production Deployment Checklist

### Pre-Deployment

âœ… **Code Quality**
- [ ] All tests passing
- [ ] ESLint errors resolved
- [ ] TypeScript errors resolved
- [ ] Code reviewed and approved

âœ… **Environment**
- [ ] Environment variables configured
- [ ] Database migrations completed
- [ ] API keys rotated (if needed)
- [ ] Third-party services configured

âœ… **Security**
- [ ] Security headers configured
- [ ] HTTPS enabled
- [ ] Rate limiting implemented
- [ ] Authentication working
- [ ] CORS configured properly
- [ ] Secrets not exposed to client

âœ… **Performance**
- [ ] Images optimized
- [ ] Bundle size analyzed
- [ ] Lighthouse score > 90
- [ ] Core Web Vitals passing
- [ ] Caching configured

### Post-Deployment

âœ… **Monitoring**
- [ ] Error tracking enabled (Sentry)
- [ ] Performance monitoring active
- [ ] Uptime monitoring configured
- [ ] Log aggregation working
- [ ] Alerts configured

âœ… **Validation**
- [ ] Smoke tests passed
- [ ] Critical user flows tested
- [ ] Forms submitting correctly
- [ ] Payment processing working
- [ ] Email notifications working

âœ… **SEO**
- [ ] Sitemap submitted
- [ ] robots.txt correct
- [ ] Metadata verified
- [ ] Structured data validated
- [ ] Google Search Console configured

âœ… **Documentation**
- [ ] Deployment runbook updated
- [ ] Rollback procedure documented
- [ ] Team notified
- [ ] Changelog updated

### Emergency Procedures

#### Rollback Process

```bash
# Vercel Rollback
vercel rollback [deployment-url]

# Docker Rollback
docker-compose down
docker-compose up -d --build [previous-tag]

# Git Rollback
git revert [commit-hash]
git push origin main
```

#### Database Rollback

```bash
# With Prisma
npx prisma migrate resolve --rolled-back [migration-name]

# Manual SQL
psql -U user -d database -f rollback.sql
```

This completes the comprehensive guide to Deployment and DevOps for Next.js!