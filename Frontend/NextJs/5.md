# Chapter 5: Routing Advanced - In-Depth Guide

## 5.1 Dynamic Routing Deep Dive

### Understanding File-System Based Routing

Next.js uses a file-system based router where folders define routes and files define UI. This is fundamentally different from traditional React routing.

```
app/
├── page.tsx                    → /
├── about/
│   └── page.tsx               → /about
├── blog/
│   ├── page.tsx               → /blog
│   └── [slug]/
│       └── page.tsx           → /blog/:slug
└── shop/
    └── [...categories]/
        └── page.tsx           → /shop/* (catch-all)
```

### Single Dynamic Segment: `[slug]`

**Use Case**: Blog posts, product pages, user profiles

```typescript
// app/blog/[slug]/page.tsx
interface PageProps {
  params: {
    slug: string;
  };
  searchParams: {
    [key: string]: string | string[] | undefined;
  };
}

export default function BlogPost({ params, searchParams }: PageProps) {
  return (
    <div>
      <h1>Post: {params.slug}</h1>
      {/* /blog/hello-world → slug: "hello-world" */}
    </div>
  );
}

// Generate static params at build time
export async function generateStaticParams() {
  const posts = await fetch('https://api.example.com/posts').then(res => res.json());
  
  return posts.map((post: any) => ({
    slug: post.slug,
  }));
}

// Generate metadata dynamically
export async function generateMetadata({ params }: PageProps) {
  const post = await fetch(`https://api.example.com/posts/${params.slug}`)
    .then(res => res.json());
  
  return {
    title: post.title,
    description: post.excerpt,
    openGraph: {
      title: post.title,
      description: post.excerpt,
      images: [post.coverImage],
    },
  };
}
```

### Catch-All Segments: `[...slug]`

**Use Case**: Multi-level paths like documentation, nested categories

```typescript
// app/docs/[...slug]/page.tsx
interface PageProps {
  params: {
    slug: string[];
  };
}

export default function DocsPage({ params }: PageProps) {
  const path = params.slug.join('/');
  
  // /docs/getting-started → slug: ["getting-started"]
  // /docs/api/reference → slug: ["api", "reference"]
  // /docs/guides/advanced/optimization → slug: ["guides", "advanced", "optimization"]
  
  return (
    <div>
      <h1>Documentation</h1>
      <p>Current path: {path}</p>
    </div>
  );
}

// Generate static params for nested routes
export async function generateStaticParams() {
  // Return all possible combinations
  return [
    { slug: ['getting-started'] },
    { slug: ['api', 'reference'] },
    { slug: ['guides', 'advanced', 'optimization'] },
  ];
}
```

### Optional Catch-All: `[[...slug]]`

**Use Case**: Root page + nested routes (e.g., shop landing page and category pages)

```typescript
// app/shop/[[...categories]]/page.tsx
interface PageProps {
  params: {
    categories?: string[];
  };
}

export default function ShopPage({ params }: PageProps) {
  // /shop → categories: undefined
  // /shop/electronics → categories: ["electronics"]
  // /shop/electronics/phones → categories: ["electronics", "phones"]
  
  if (!params.categories) {
    return <div>All Products</div>;
  }
  
  const categoryPath = params.categories.join(' > ');
  
  return (
    <div>
      <h1>Category: {categoryPath}</h1>
    </div>
  );
}
```

### Route Priority and Matching

When multiple routes could match, Next.js follows this priority order:

```
1. Predefined routes (static)      → /about/page.tsx
2. Dynamic routes                   → /blog/[slug]/page.tsx
3. Catch-all routes                 → /docs/[...slug]/page.tsx
4. Optional catch-all               → /shop/[[...categories]]/page.tsx
```

**Example Priority**:
```
app/
├── blog/
│   ├── page.tsx                → /blog (Highest priority)
│   ├── new/
│   │   └── page.tsx            → /blog/new (Higher priority)
│   ├── [slug]/
│   │   └── page.tsx            → /blog/:slug (Medium priority)
│   └── [...all]/
│       └── page.tsx            → /blog/* (Lowest priority)
```

---

## 5.2 Navigation

### The Link Component

The `Link` component is the primary way to navigate between routes in Next.js. It provides client-side navigation with prefetching.

```typescript
// app/components/navbar.tsx
import Link from 'next/link';

export default function Navbar() {
  return (
    <nav>
      {/* Basic link */}
      <Link href="/about">About</Link>
      
      {/* Link with dynamic route */}
      <Link href="/blog/hello-world">Hello World Post</Link>
      
      {/* Link with query params */}
      <Link href={{ pathname: '/search', query: { q: 'nextjs' } }}>
        Search Next.js
      </Link>
      
      {/* Disable prefetching */}
      <Link href="/large-page" prefetch={false}>
        Large Page (No Prefetch)
      </Link>
      
      {/* Replace instead of push (doesn't add to history) */}
      <Link href="/login" replace>
        Login
      </Link>
      
      {/* Pass custom props to child */}
      <Link href="/profile" className="nav-link">
        <span>Profile</span>
      </Link>
    </nav>
  );
}
```

### Prefetching Behavior

**Important**: Next.js automatically prefetches links in the viewport.

```typescript
// Default behavior (production)
<Link href="/about">About</Link>
// Prefetches when link enters viewport

// Disable prefetching
<Link href="/about" prefetch={false}>About</Link>
// Only fetches when clicked

// In development
// Prefetching is disabled by default in development mode
```

### Dynamic Navigation Patterns

```typescript
// app/products/page.tsx
import Link from 'next/link';

interface Product {
  id: string;
  name: string;
  slug: string;
}

export default function ProductsPage({ products }: { products: Product[] }) {
  return (
    <div>
      {products.map(product => (
        <Link
          key={product.id}
          href={`/products/${product.slug}`}
          // or using object syntax
          // href={{ pathname: '/products/[slug]', query: { slug: product.slug } }}
        >
          <div className="product-card">
            <h3>{product.name}</h3>
          </div>
        </Link>
      ))}
    </div>
  );
}
```

### useRouter Hook (App Router)

```typescript
'use client';

import { useRouter, usePathname, useSearchParams } from 'next/navigation';

export default function NavigationComponent() {
  const router = useRouter();
  const pathname = usePathname(); // Current path: /blog/hello
  const searchParams = useSearchParams(); // URLSearchParams object
  
  // Get query parameters
  const search = searchParams.get('search'); // ?search=nextjs
  
  // Programmatic navigation
  const handleNavigate = () => {
    // Push to history
    router.push('/about');
    
    // Replace current entry
    router.replace('/dashboard');
    
    // Go back
    router.back();
    
    // Go forward
    router.forward();
    
    // Refresh the current route
    router.refresh();
  };
  
  // Navigate with query params
  const handleSearch = (query: string) => {
    const params = new URLSearchParams(searchParams.toString());
    params.set('search', query);
    router.push(`${pathname}?${params.toString()}`);
  };
  
  return (
    <div>
      <p>Current path: {pathname}</p>
      <button onClick={handleNavigate}>Navigate</button>
      <button onClick={() => handleSearch('nextjs')}>Search</button>
    </div>
  );
}
```

### useRouter Hook (Pages Router)

```typescript
'use client';

import { useRouter } from 'next/router';

export default function NavigationComponent() {
  const router = useRouter();
  
  // Access route information
  console.log(router.pathname);    // /blog/[slug]
  console.log(router.query);       // { slug: 'hello' }
  console.log(router.asPath);      // /blog/hello?foo=bar
  console.log(router.route);       // /blog/[slug]
  
  // Programmatic navigation
  const navigate = () => {
    // Basic navigation
    router.push('/about');
    
    // With query params
    router.push({
      pathname: '/search',
      query: { q: 'nextjs', sort: 'recent' }
    });
    
    // Shallow routing (update URL without running data fetching)
    router.push('/?counter=10', undefined, { shallow: true });
    
    // Scroll to top after navigation
    router.push('/about', undefined, { scroll: true });
  };
  
  return <button onClick={navigate}>Navigate</button>;
}
```

### Scroll Restoration

```typescript
'use client';

import { useRouter } from 'next/navigation';

export default function ScrollExample() {
  const router = useRouter();
  
  const handleNavigate = () => {
    // Disable automatic scroll to top
    router.push('/about', { scroll: false });
  };
  
  return <button onClick={handleNavigate}>Navigate (No Scroll)</button>;
}
```

---

## 5.3 Middleware

Middleware allows you to run code before a request is completed. It runs on the Edge Runtime, making it extremely fast.

### Basic Middleware Setup

```typescript
// middleware.ts (at root level)
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  // Clone the request headers
  const requestHeaders = new Headers(request.headers);
  requestHeaders.set('x-custom-header', 'custom-value');
  
  // Log the request
  console.log(`${request.method} ${request.url}`);
  
  // Continue with modified headers
  return NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  });
}

// Configure which routes use middleware
export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization)
     * - favicon.ico (favicon file)
     * - public folder
     */
    '/((?!_next/static|_next/image|favicon.ico|public/).*)',
  ],
};
```

### Authentication Middleware

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  // Check for auth token
  const token = request.cookies.get('auth-token')?.value;
  
  // Protected routes
  const isProtectedRoute = request.nextUrl.pathname.startsWith('/dashboard');
  const isAuthRoute = request.nextUrl.pathname.startsWith('/login');
  
  // Redirect to login if accessing protected route without token
  if (isProtectedRoute && !token) {
    const loginUrl = new URL('/login', request.url);
    loginUrl.searchParams.set('from', request.nextUrl.pathname);
    return NextResponse.redirect(loginUrl);
  }
  
  // Redirect to dashboard if accessing auth routes with token
  if (isAuthRoute && token) {
    return NextResponse.redirect(new URL('/dashboard', request.url));
  }
  
  return NextResponse.next();
}

export const config = {
  matcher: ['/dashboard/:path*', '/login', '/signup'],
};
```

### Advanced Middleware Patterns

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  // 1. Geolocation-based routing
  const country = request.geo?.country || 'US';
  if (pathname === '/') {
    return NextResponse.redirect(new URL(`/${country.toLowerCase()}`, request.url));
  }
  
  // 2. A/B Testing
  const bucket = request.cookies.get('bucket')?.value;
  if (!bucket) {
    const newBucket = Math.random() < 0.5 ? 'a' : 'b';
    const response = NextResponse.next();
    response.cookies.set('bucket', newBucket);
    return response;
  }
  
  // 3. Rate Limiting
  const ip = request.ip || 'unknown';
  const rateLimitExceeded = await checkRateLimit(ip);
  if (rateLimitExceeded) {
    return new NextResponse('Too Many Requests', { status: 429 });
  }
  
  // 4. Feature Flags
  const enableNewFeature = request.cookies.get('new-feature')?.value === 'true';
  if (pathname === '/app' && enableNewFeature) {
    return NextResponse.rewrite(new URL('/app-v2', request.url));
  }
  
  // 5. Bot Detection
  const userAgent = request.headers.get('user-agent') || '';
  const isBot = /bot|crawler|spider/i.test(userAgent);
  if (isBot) {
    const response = NextResponse.next();
    response.headers.set('X-Robots-Tag', 'noindex');
    return response;
  }
  
  return NextResponse.next();
}

async function checkRateLimit(ip: string): Promise<boolean> {
  // Implement rate limiting logic
  // Could use Redis, Upstash, or in-memory store
  return false;
}

export const config = {
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
};
```

### Middleware Response Types

```typescript
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  // 1. Continue to next middleware or route handler
  return NextResponse.next();
  
  // 2. Redirect to another URL
  return NextResponse.redirect(new URL('/new-path', request.url));
  
  // 3. Rewrite to another URL (URL doesn't change in browser)
  return NextResponse.rewrite(new URL('/internal-path', request.url));
  
  // 4. Return a response directly
  return new NextResponse('Custom response', {
    status: 200,
    headers: {
      'Content-Type': 'text/plain',
    },
  });
  
  // 5. Return JSON
  return NextResponse.json({ error: 'Not found' }, { status: 404 });
}
```

### Matcher Configuration

```typescript
// Exact match
export const config = {
  matcher: '/about',
};

// Multiple paths
export const config = {
  matcher: ['/about', '/contact', '/dashboard/:path*'],
};

// Wildcard matching
export const config = {
  matcher: [
    '/dashboard/:path*',  // Matches /dashboard and all sub-paths
    '/api/:path*',        // Matches /api and all sub-paths
  ],
};

// Complex patterns with regex
export const config = {
  matcher: [
    /*
     * Match all paths except:
     * - api routes
     * - static files
     * - images
     */
    '/((?!api|_next/static|_next/image|.*\\.png$).*)',
  ],
};
```

### Conditional Middleware Logic

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  const pathname = request.nextUrl.pathname;
  
  // Apply different logic based on route
  if (pathname.startsWith('/api')) {
    return handleApiRoute(request);
  }
  
  if (pathname.startsWith('/admin')) {
    return handleAdminRoute(request);
  }
  
  if (pathname.startsWith('/blog')) {
    return handleBlogRoute(request);
  }
  
  return NextResponse.next();
}

function handleApiRoute(request: NextRequest) {
  // API-specific middleware
  const apiKey = request.headers.get('x-api-key');
  
  if (!apiKey || apiKey !== process.env.API_KEY) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  return NextResponse.next();
}

function handleAdminRoute(request: NextRequest) {
  // Admin-specific middleware
  const isAdmin = request.cookies.get('role')?.value === 'admin';
  
  if (!isAdmin) {
    return NextResponse.redirect(new URL('/login', request.url));
  }
  
  return NextResponse.next();
}

function handleBlogRoute(request: NextRequest) {
  // Blog-specific middleware (e.g., add headers)
  const response = NextResponse.next();
  response.headers.set('X-Content-Type', 'blog');
  return response;
}

export const config = {
  matcher: ['/api/:path*', '/admin/:path*', '/blog/:path*'],
};
```

---

## 5.4 Route Protection

### Protected Routes with Middleware

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { verifyToken } from '@/lib/auth';

// Define protected routes
const protectedRoutes = ['/dashboard', '/profile', '/settings'];
const authRoutes = ['/login', '/signup'];

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  const token = request.cookies.get('auth-token')?.value;
  
  const isProtectedRoute = protectedRoutes.some(route => 
    pathname.startsWith(route)
  );
  const isAuthRoute = authRoutes.some(route => 
    pathname.startsWith(route)
  );
  
  // Verify token
  let user = null;
  if (token) {
    try {
      user = await verifyToken(token);
    } catch (error) {
      // Invalid token, clear it
      const response = NextResponse.redirect(new URL('/login', request.url));
      response.cookies.delete('auth-token');
      return response;
    }
  }
  
  // Redirect to login if accessing protected route without valid token
  if (isProtectedRoute && !user) {
    const loginUrl = new URL('/login', request.url);
    loginUrl.searchParams.set('callbackUrl', pathname);
    return NextResponse.redirect(loginUrl);
  }
  
  // Redirect to dashboard if accessing auth routes with valid token
  if (isAuthRoute && user) {
    return NextResponse.redirect(new URL('/dashboard', request.url));
  }
  
  return NextResponse.next();
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
};
```

### Role-Based Access Control (RBAC)

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

interface User {
  id: string;
  role: 'user' | 'admin' | 'moderator';
}

// Define role requirements for routes
const routeRoles: Record<string, string[]> = {
  '/admin': ['admin'],
  '/moderator': ['admin', 'moderator'],
  '/dashboard': ['user', 'admin', 'moderator'],
};

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  const token = request.cookies.get('auth-token')?.value;
  
  // Find matching route role requirement
  const requiredRoles = Object.entries(routeRoles).find(([route]) =>
    pathname.startsWith(route)
  )?.[1];
  
  if (!requiredRoles) {
    return NextResponse.next();
  }
  
  if (!token) {
    return NextResponse.redirect(new URL('/login', request.url));
  }
  
  // Verify user and check role
  const user = await getUserFromToken(token);
  
  if (!user || !requiredRoles.includes(user.role)) {
    return NextResponse.redirect(new URL('/unauthorized', request.url));
  }
  
  return NextResponse.next();
}

async function getUserFromToken(token: string): Promise<User | null> {
  // Implement token verification and user retrieval
  return { id: '1', role: 'user' };
}
```

### Protected API Routes

```typescript
// app/api/protected/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { verifyAuth } from '@/lib/auth';

export async function GET(request: NextRequest) {
  try {
    const token = request.headers.get('authorization')?.split(' ')[1];
    
    if (!token) {
      return NextResponse.json(
        { error: 'Missing authentication token' },
        { status: 401 }
      );
    }
    
    const user = await verifyAuth(token);
    
    if (!user) {
      return NextResponse.json(
        { error: 'Invalid token' },
        { status: 401 }
      );
    }
    
    // User is authenticated
    return NextResponse.json({
      message: 'Success',
      user,
    });
  } catch (error) {
    return NextResponse.json(
      { error: 'Authentication failed' },
      { status: 401 }
    );
  }
}
```

### Higher-Order Component (HOC) Pattern

```typescript
// lib/withAuth.tsx
'use client';

import { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useAuth } from '@/hooks/useAuth';

export function withAuth<P extends object>(
  Component: React.ComponentType<P>,
  options?: {
    requiredRole?: string[];
    redirectTo?: string;
  }
) {
  return function ProtectedRoute(props: P) {
    const router = useRouter();
    const { user, loading } = useAuth();
    
    useEffect(() => {
      if (!loading) {
        if (!user) {
          router.push(options?.redirectTo || '/login');
          return;
        }
        
        if (options?.requiredRole && !options.requiredRole.includes(user.role)) {
          router.push('/unauthorized');
        }
      }
    }, [user, loading, router]);
    
    if (loading) {
      return <div>Loading...</div>;
    }
    
    if (!user) {
      return null;
    }
    
    if (options?.requiredRole && !options.requiredRole.includes(user.role)) {
      return null;
    }
    
    return <Component {...props} />;
  };
}

// Usage
// app/dashboard/page.tsx
'use client';

import { withAuth } from '@/lib/withAuth';

function DashboardPage() {
  return <div>Dashboard Content</div>;
}

export default withAuth(DashboardPage);

// With role requirement
export default withAuth(DashboardPage, {
  requiredRole: ['admin', 'moderator'],
  redirectTo: '/login',
});
```

### Server Component Protection

```typescript
// app/admin/page.tsx
import { redirect } from 'next/navigation';
import { cookies } from 'next/headers';
import { verifyToken } from '@/lib/auth';

async function checkAuth() {
  const cookieStore = cookies();
  const token = cookieStore.get('auth-token')?.value;
  
  if (!token) {
    return null;
  }
  
  try {
    const user = await verifyToken(token);
    return user;
  } catch (error) {
    return null;
  }
}

export default async function AdminPage() {
  const user = await checkAuth();
  
  if (!user) {
    redirect('/login');
  }
  
  if (user.role !== 'admin') {
    redirect('/unauthorized');
  }
  
  return (
    <div>
      <h1>Admin Dashboard</h1>
      <p>Welcome, {user.name}</p>
    </div>
  );
}
```

## Summary & Best Practices

### Key Takeaways

1. **Dynamic Routes**: Understand the difference between `[slug]`, `[...slug]`, and `[[...slug]]`
2. **Route Priority**: Static routes have highest priority, followed by dynamic, then catch-all
3. **Navigation**: Use `Link` for client-side navigation with automatic prefetching
4. **Programmatic Navigation**: Use `useRouter` for complex navigation scenarios
5. **Middleware**: Runs on Edge, perfect for auth, redirects, and request modification
6. **Protection**: Combine middleware, route handlers, and component-level checks

### Performance Tips

- Leverage Link prefetching for faster navigation
- Use shallow routing for URL updates without re-fetching
- Implement middleware for auth checks (faster than component-level)
- Generate static params for dynamic routes when possible
- Use loading.tsx and Suspense for better UX during navigation

### Security Considerations

- Always validate auth tokens on the server
- Implement proper RBAC for sensitive routes
- Use middleware for consistent security checks
- Never rely solely on client-side protection
- Sanitize and validate all user inputs
- Use CSRF tokens for state-changing operations