# Chapter 2: App Router (Next.js 13+) - Deep Dive

## 2.1 App Directory Structure

The App Router is a **fundamental paradigm shift** in Next.js, introducing React Server Components, nested layouts, and a new file convention.

### Why App Router?

**Problems with Pages Router:**
- Layouts require workarounds with `_app.js`
- No way to share UI between routes without re-rendering
- Loading and error states need manual implementation
- All components are client-rendered by default

**App Router Solutions:**
- Built-in nested layouts
- Server Components by default (better performance)
- Special files for loading, error, and not-found states
- Streaming and Suspense support

### App Directory Structure

```
app/
â”œâ”€â”€ layout.tsx              # Root layout (REQUIRED)
â”œâ”€â”€ page.tsx                # Home page (/)
â”œâ”€â”€ loading.tsx             # Loading UI
â”œâ”€â”€ error.tsx               # Error UI
â”œâ”€â”€ not-found.tsx           # 404 UI
â”œâ”€â”€ global.css              # Global styles
â”‚
â”œâ”€â”€ about/
â”‚   â””â”€â”€ page.tsx            # /about
â”‚
â”œâ”€â”€ blog/
â”‚   â”œâ”€â”€ layout.tsx          # Layout for all /blog/* routes
â”‚   â”œâ”€â”€ page.tsx            # /blog
â”‚   â”œâ”€â”€ loading.tsx         # Loading for blog section
â”‚   â””â”€â”€ [slug]/
â”‚       â””â”€â”€ page.tsx        # /blog/:slug
â”‚
â”œâ”€â”€ dashboard/
â”‚   â”œâ”€â”€ layout.tsx          # Dashboard layout
â”‚   â”œâ”€â”€ page.tsx            # /dashboard
â”‚   â”œâ”€â”€ settings/
â”‚   â”‚   â””â”€â”€ page.tsx        # /dashboard/settings
â”‚   â””â”€â”€ analytics/
â”‚       â””â”€â”€ page.tsx        # /dashboard/analytics
â”‚
â””â”€â”€ api/
    â””â”€â”€ users/
        â””â”€â”€ route.ts        # API route /api/users
```

### File Conventions in App Router

| File | Purpose | Required |
|------|---------|----------|
| `layout.tsx` | Shared UI for segments | Yes (root) |
| `page.tsx` | Page content | Yes |
| `loading.tsx` | Loading fallback | No |
| `error.tsx` | Error boundary | No |
| `not-found.tsx` | 404 page | No |
| `template.tsx` | Re-rendered layout | No |
| `route.ts` | API endpoint | No |

### Root Layout (Required)

Every app MUST have a root layout:

```typescript
// app/layout.tsx
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'My Next.js App',
  description: 'Built with Next.js App Router',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        {/* Any UI added here appears on ALL pages */}
        <header>
          <nav>Navigation</nav>
        </header>
        <main>{children}</main>
        <footer>Footer</footer>
      </body>
    </html>
  );
}
```

**ğŸ”¥ Critical Points:**
- Must include `<html>` and `<body>` tags
- Can't use `useRouter` or other client hooks (it's a Server Component)
- Children represent nested layouts or pages

### Page Component

```typescript
// app/page.tsx
export default function HomePage() {
  return (
    <div>
      <h1>Welcome to Next.js</h1>
      <p>This is the home page</p>
    </div>
  );
}
```

### Nested Layouts

Layouts can be nested for different sections:

```typescript
// app/dashboard/layout.tsx
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="dashboard">
      {/* Sidebar visible on all /dashboard/* routes */}
      <aside>
        <nav>
          <a href="/dashboard">Dashboard</a>
          <a href="/dashboard/settings">Settings</a>
          <a href="/dashboard/analytics">Analytics</a>
        </nav>
      </aside>
      
      <div className="content">
        {children}
      </div>
    </div>
  );
}
```

**Visual Representation:**
```
Root Layout (app/layout.tsx)
â”œâ”€â”€ Header (always visible)
â”œâ”€â”€ Dashboard Layout (app/dashboard/layout.tsx)
â”‚   â”œâ”€â”€ Sidebar (visible on all dashboard pages)
â”‚   â””â”€â”€ Page Content (changes per route)
â””â”€â”€ Footer (always visible)
```

### Loading UI

Automatically shown while a page is loading:

```typescript
// app/dashboard/loading.tsx
export default function DashboardLoading() {
  return (
    <div className="loading-skeleton">
      <div className="skeleton-header"></div>
      <div className="skeleton-content"></div>
    </div>
  );
}
```

**How it works:**
1. User navigates to `/dashboard/settings`
2. Next.js shows `loading.tsx` immediately
3. When data is ready, replaces with actual page

### Error Handling

Error boundaries for route segments:

```typescript
// app/dashboard/error.tsx
'use client'; // Error components must be Client Components

import { useEffect } from 'react';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    // Log error to error reporting service
    console.error(error);
  }, [error]);

  return (
    <div>
      <h2>Something went wrong!</h2>
      <p>{error.message}</p>
      <button onClick={reset}>Try again</button>
    </div>
  );
}
```

### Not Found Page

```typescript
// app/not-found.tsx
export default function NotFound() {
  return (
    <div>
      <h2>404 - Page Not Found</h2>
      <p>The page you're looking for doesn't exist.</p>
      <a href="/">Go home</a>
    </div>
  );
}
```

**Trigger it programmatically:**
```typescript
import { notFound } from 'next/navigation';

export default async function Page({ params }: { params: { id: string } }) {
  const data = await fetchData(params.id);
  
  if (!data) {
    notFound(); // Shows not-found.tsx
  }
  
  return <div>{data.title}</div>;
}
```

---

## 2.2 Server Components vs Client Components

This is the **MOST IMPORTANT** concept in modern Next.js.

### React Server Components (RSC) Fundamentals

**Traditional React (Client Components):**
```
Browser â†’ Server â†’ Download JS â†’ Hydrate â†’ Interactive
```

**React Server Components:**
```
Server â†’ Render â†’ Send HTML â†’ Interactive (less JS)
```

### Default: Everything is a Server Component

```typescript
// app/page.tsx
// This is a SERVER COMPONENT (default)
export default function Page() {
  // Runs ONLY on the server
  console.log('This logs on the server, not in browser');
  
  return <div>Hello</div>;
}
```

**Server Component Benefits:**
- âœ… No JavaScript sent to client
- âœ… Direct database access
- âœ… Automatic code splitting
- âœ… Better security (API keys hidden)
- âœ… Faster initial load

**Server Component Limitations:**
- âŒ No useState, useEffect, or other React hooks
- âŒ No browser APIs (localStorage, window, etc.)
- âŒ No event handlers (onClick, onChange)
- âŒ No Context providers

### Client Components: Opt-in with 'use client'

```typescript
// app/components/Counter.tsx
'use client'; // ğŸ‘ˆ This makes it a Client Component

import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}
```

### When to Use Each

**Use Server Components (default) for:**
- Fetching data
- Accessing backend resources
- Sensitive information (API keys, tokens)
- Large dependencies that don't need to be on client

**Use Client Components for:**
- Interactivity (onClick, onChange)
- React hooks (useState, useEffect, useContext)
- Browser APIs (localStorage, geolocation)
- Event listeners
- Custom hooks

### Component Composition Patterns

#### âœ… Pattern 1: Server Component with Client Children

```typescript
// app/page.tsx (Server Component)
import ClientCounter from './ClientCounter';

export default async function Page() {
  // Fetch data on server
  const data = await fetch('https://api.example.com/data');
  const posts = await data.json();
  
  return (
    <div>
      <h1>My Posts</h1>
      {posts.map(post => (
        <div key={post.id}>{post.title}</div>
      ))}
      
      {/* Client component for interactivity */}
      <ClientCounter />
    </div>
  );
}
```

#### âœ… Pattern 2: Pass Server Components as Children to Client Components

```typescript
// ClientWrapper.tsx
'use client';

export default function ClientWrapper({ children }: { children: React.ReactNode }) {
  return (
    <div className="interactive-wrapper">
      {children}
    </div>
  );
}

// page.tsx (Server Component)
import ClientWrapper from './ClientWrapper';

export default async function Page() {
  const data = await fetchData(); // Server-side
  
  return (
    <ClientWrapper>
      {/* This stays a Server Component! */}
      <ServerDataDisplay data={data} />
    </ClientWrapper>
  );
}
```

#### âŒ Pattern 3: DON'T Import Server into Client (Won't Work)

```typescript
// ServerComponent.tsx (Server Component)
export default async function ServerComponent() {
  const data = await fetchData();
  return <div>{data}</div>;
}

// ClientComponent.tsx
'use client';
import ServerComponent from './ServerComponent'; // âŒ ERROR!

export default function ClientComponent() {
  return (
    <div>
      <ServerComponent /> {/* Won't work */}
    </div>
  );
}
```

### Data Fetching in Server Components

```typescript
// app/posts/[id]/page.tsx
interface Post {
  id: number;
  title: string;
  content: string;
}

export default async function PostPage({ 
  params 
}: { 
  params: { id: string } 
}) {
  // Fetch directly in component - NO useEffect needed!
  const res = await fetch(`https://api.example.com/posts/${params.id}`, {
    cache: 'no-store', // SSR - always fresh
    // OR
    next: { revalidate: 3600 } // ISR - revalidate every hour
  });
  
  const post: Post = await res.json();
  
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  );
}
```

### Parallel Data Fetching

```typescript
// Fetch in parallel for better performance
export default async function Page() {
  // âŒ Bad: Sequential (slow)
  const posts = await fetchPosts();
  const user = await fetchUser();
  
  // âœ… Good: Parallel (fast)
  const [posts, user] = await Promise.all([
    fetchPosts(),
    fetchUser()
  ]);
  
  return (
    <div>
      <UserProfile user={user} />
      <PostList posts={posts} />
    </div>
  );
}
```

### ğŸ”¥ Critical: The Server/Client Boundary

```typescript
// Server Component boundary
export default function ServerComponent() {
  const data = fetchData(); // OK - server
  
  return (
    <div>
      {/* Still server component */}
      <ServerChild />
      
      {/* Client boundary starts here */}
      <ClientComponent data={data}>
        {/* Back to server component through children */}
        <ServerChild2 />
      </ClientComponent>
    </div>
  );
}
```

**Visualized:**
```
â”Œâ”€ Server Component â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  const data = await fetch()    â”‚
â”‚  â”Œâ”€ Client Component â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ 'use client'           â”‚    â”‚
â”‚  â”‚ onClick, useState      â”‚    â”‚
â”‚  â”‚ â”Œâ”€ Server Child â”€â”€â”    â”‚    â”‚
â”‚  â”‚ â”‚ (via children)  â”‚    â”‚    â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ“š Interview Focus: Explain RSC Benefits

**Question: "Why use Server Components?"**

**Answer:**
1. **Performance**: Less JavaScript sent to client
2. **Security**: Keep secrets on server (API keys, database queries)
3. **SEO**: Fully rendered HTML for crawlers
4. **Code Elimination**: Unused server code never reaches browser
5. **Direct Backend Access**: No need for API routes

---

## 2.3 Route Groups and Parallel Routes

### Route Groups

Group routes without affecting URL structure using `(folder)`.

```
app/
â”œâ”€â”€ (marketing)/
â”‚   â”œâ”€â”€ layout.tsx          # Layout for marketing pages
â”‚   â”œâ”€â”€ about/
â”‚   â”‚   â””â”€â”€ page.tsx        # /about (NOT /marketing/about)
â”‚   â””â”€â”€ contact/
â”‚       â””â”€â”€ page.tsx        # /contact
â”‚
â””â”€â”€ (shop)/
    â”œâ”€â”€ layout.tsx          # Different layout for shop
    â”œâ”€â”€ products/
    â”‚   â””â”€â”€ page.tsx        # /products
    â””â”€â”€ cart/
        â””â”€â”€ page.tsx        # /cart
```

**Use Cases:**
1. Different layouts for different sections
2. Organizing code without affecting URLs
3. Separating concerns (marketing vs app)

**Example:**
```typescript
// app/(marketing)/layout.tsx
export default function MarketingLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div>
      {/* Marketing-specific header */}
      <header className="marketing-header">
        <nav>Marketing Nav</nav>
      </header>
      {children}
    </div>
  );
}

// app/(shop)/layout.tsx
export default function ShopLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div>
      {/* Shop-specific header with cart */}
      <header className="shop-header">
        <nav>Shop Nav</nav>
        <CartIcon />
      </header>
      {children}
    </div>
  );
}
```

### Parallel Routes

Show multiple pages in the same layout using `@folder` slots.

```
app/
â”œâ”€â”€ layout.tsx
â”œâ”€â”€ page.tsx
â”œâ”€â”€ @analytics/
â”‚   â””â”€â”€ page.tsx
â””â”€â”€ @team/
    â””â”€â”€ page.tsx
```

**Root layout receives slots as props:**
```typescript
// app/layout.tsx
export default function Layout({
  children,
  analytics,
  team,
}: {
  children: React.ReactNode;
  analytics: React.ReactNode;
  team: React.ReactNode;
}) {
  return (
    <html>
      <body>
        {children}
        <div className="dashboard">
          <div className="analytics-panel">
            {analytics}
          </div>
          <div className="team-panel">
            {team}
          </div>
        </div>
      </body>
    </html>
  );
}
```

**Real-world Example: Dashboard with Multiple Panels**
```
app/
â””â”€â”€ dashboard/
    â”œâ”€â”€ layout.tsx
    â”œâ”€â”€ page.tsx
    â”œâ”€â”€ @stats/
    â”‚   â””â”€â”€ page.tsx         # Sales statistics
    â””â”€â”€ @activity/
        â””â”€â”€ page.tsx         # Recent activity
```

```typescript
// app/dashboard/layout.tsx
export default function DashboardLayout({
  children,
  stats,
  activity,
}: {
  children: React.ReactNode;
  stats: React.ReactNode;
  activity: React.ReactNode;
}) {
  return (
    <div className="dashboard-grid">
      <main>{children}</main>
      <aside className="stats">{stats}</aside>
      <aside className="activity">{activity}</aside>
    </div>
  );
}
```

### Intercepting Routes

Intercept navigation to show content in a modal while keeping URL.

```
app/
â”œâ”€â”€ page.tsx
â”œâ”€â”€ photos/
â”‚   â”œâ”€â”€ [id]/
â”‚   â”‚   â””â”€â”€ page.tsx        # /photos/123 (full page)
â”‚   â””â”€â”€ (..)photos/
â”‚       â””â”€â”€ [id]/
â”‚           â””â”€â”€ page.tsx    # Intercepts /photos/123 (modal)
```

**Intercepting conventions:**
- `(.)` - same level
- `(..)` - one level up
- `(..)(..)` - two levels up
- `(...)` - from app root

**Example: Photo Gallery with Modal**
```typescript
// app/photos/[id]/page.tsx (Full page)
export default function PhotoPage({ params }: { params: { id: string } }) {
  return (
    <div className="full-page">
      <img src={`/photos/${params.id}.jpg`} alt="Photo" />
      <p>Full page view</p>
    </div>
  );
}

// app/@modal/(.)photos/[id]/page.tsx (Modal)
export default function PhotoModal({ params }: { params: { id: string } }) {
  return (
    <div className="modal-overlay">
      <div className="modal">
        <img src={`/photos/${params.id}.jpg`} alt="Photo" />
        <button>Close</button>
      </div>
    </div>
  );
}
```

**User Experience:**
1. User on homepage, clicks photo â†’ Opens in modal (stays on `/`)
2. User refreshes â†’ Shows full page (`/photos/123`)
3. User shares URL â†’ Recipients see full page

---

## 2.4 Layouts and Templates

### Layouts vs Templates

Both wrap child components, but behave differently:

**Layout:**
- Preserves state between navigations
- Doesn't re-render when navigating between child routes
- Can share UI elements

**Template:**
- Re-renders on each navigation
- Each instance gets fresh state
- Useful for animations or effects that should reset

### Layout Example

```typescript
// app/dashboard/layout.tsx
'use client';
import { useState } from 'react';

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const [sidebarOpen, setSidebarOpen] = useState(true);
  
  // State PERSISTS when navigating between:
  // /dashboard/settings â†’ /dashboard/profile
  
  return (
    <div>
      <button onClick={() => setSidebarOpen(!sidebarOpen)}>
        Toggle Sidebar
      </button>
      
      {sidebarOpen && <Sidebar />}
      
      <main>{children}</main>
    </div>
  );
}
```

### Template Example

```typescript
// app/dashboard/template.tsx
'use client';
import { useEffect } from 'react';

export default function DashboardTemplate({
  children,
}: {
  children: React.ReactNode;
}) {
  // Runs on EVERY navigation
  useEffect(() => {
    console.log('Template mounted');
    
    // Track page view
    analytics.track('page_view');
  }, []);
  
  return (
    <div className="fade-in">
      {children}
    </div>
  );
}
```

### Nested Layouts Composition

```
Root Layout (app/layout.tsx)
â””â”€â”€ Blog Layout (app/blog/layout.tsx)
    â””â”€â”€ Blog Post Layout (app/blog/[slug]/layout.tsx)
        â””â”€â”€ Page (app/blog/[slug]/page.tsx)
```

**Example:**
```typescript
// app/layout.tsx (Root)
export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <Header />
        {children}
        <Footer />
      </body>
    </html>
  );
}

// app/blog/layout.tsx (Blog)
export default function BlogLayout({ children }) {
  return (
    <div className="blog-container">
      <aside>
        <Categories />
      </aside>
      <main>{children}</main>
    </div>
  );
}

// app/blog/[slug]/layout.tsx (Individual post)
export default function PostLayout({ children }) {
  return (
    <article className="post">
      <ShareButtons />
      {children}
      <Comments />
    </article>
  );
}
```

### ğŸ”¥ Highlight: Layouts Don't Re-render on Navigation

```typescript
// This layout persists across navigations
export default function Layout({ children }) {
  console.log('Layout rendered');
  // Only logs once, not on every page change!
  
  return (
    <div>
      <ExpensiveComponent /> {/* Not re-rendered */}
      {children}
    </div>
  );
}
```

**Benefits:**
- Better performance
- Preserved scroll position
- Maintained state
- Smooth transitions

---

## Key Takeaways from Chapter 2

1. **App Router is the future** - use it for new projects
2. **Server Components are default** - opt into Client Components with 'use client'
3. **Layouts persist** between navigations, Templates re-render
4. **Route groups** organize code without affecting URLs
5. **Parallel routes** show multiple pages simultaneously
6. **Every app needs a root layout** with `<html>` and `<body>`

## Practice Exercises

1. Convert a Pages Router app to App Router
2. Build a dashboard with:
   - Nested layouts
   - Loading states
   - Error boundaries
3. Create a photo gallery with intercepting routes (modal on grid, full page on refresh)
4. Experiment with Server Components vs Client Components
5. Build a layout that persists state across navigations

## Common Mistakes to Avoid

âŒ Using 'use client' on every component  
âœ… Use Server Components by default, Client Components only when needed

âŒ Importing Server Components into Client Components  
âœ… Pass Server Components as children to Client Components

âŒ Fetching data with useEffect in Server Components  
âœ… Use async components and await directly

âŒ Forgetting to add `<html>` and `<body>` to root layout  
âœ… Root layout must include both tags

## Next: Chapter 3 - Rendering Strategies

In the next chapter, we'll explore SSR, SSG, ISR, CSR in depth with the App Router, and learn when to use each strategy for optimal performance.