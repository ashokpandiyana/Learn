# Chapter 4: Data Fetching - In-Depth Guide

## 4.1 Data Fetching Patterns (App Router)

### Overview
The App Router introduces a new paradigm for data fetching that leverages React Server Components. Unlike the Pages Router, you can fetch data directly in Server Components without special functions.

### Server Components Data Fetching

**Key Concept**: Server Components run on the server and can directly access backend resources (databases, APIs, file system) without exposing sensitive data to the client.

#### Basic Example

```typescript
// app/products/page.tsx
async function getProducts() {
  const res = await fetch('https://api.example.com/products');
  
  if (!res.ok) {
    throw new Error('Failed to fetch products');
  }
  
  return res.json();
}

export default async function ProductsPage() {
  const products = await getProducts();
  
  return (
    <div>
      <h1>Products</h1>
      <ul>
        {products.map((product) => (
          <li key={product.id}>{product.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

### Extended `fetch` API with Caching

Next.js extends the native `fetch` API with powerful caching capabilities:

#### Cache Options

```typescript
// 1. Force Cache (default) - Cache indefinitely
fetch('https://api.example.com/data', {
  cache: 'force-cache'
});

// 2. No Store - Never cache, always fresh
fetch('https://api.example.com/realtime-data', {
  cache: 'no-store'
});

// 3. Revalidate - Cache with time-based revalidation
fetch('https://api.example.com/data', {
  next: { revalidate: 3600 } // Revalidate every hour
});

// 4. On-demand revalidation with tags
fetch('https://api.example.com/posts', {
  next: { tags: ['posts'] }
});
```

#### Real-World Example: Blog with Different Caching Strategies

```typescript
// app/blog/page.tsx - List page with revalidation
async function getPosts() {
  const res = await fetch('https://api.example.com/posts', {
    next: { revalidate: 60 } // Revalidate every minute
  });
  return res.json();
}

// app/blog/[slug]/page.tsx - Individual post
async function getPost(slug: string) {
  const res = await fetch(`https://api.example.com/posts/${slug}`, {
    next: { revalidate: 3600 } // Revalidate every hour
  });
  return res.json();
}

export default async function PostPage({ params }: { params: { slug: string } }) {
  const post = await getPost(params.slug);
  
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  );
}
```

### Request Memoization

**Critical Concept**: Next.js automatically memoizes `fetch` requests with the same URL and options during a React render pass.

```typescript
// These two fetches will only execute once
async function getUser(id: string) {
  const res = await fetch(`https://api.example.com/users/${id}`);
  return res.json();
}

async function UserProfile({ userId }: { userId: string }) {
  const user = await getUser(userId); // First call
  return <div>{user.name}</div>;
}

async function UserAvatar({ userId }: { userId: string }) {
  const user = await getUser(userId); // Memoized, returns cached result
  return <img src={user.avatar} />;
}

// Both components can call getUser without duplication
export default async function Page() {
  return (
    <>
      <UserProfile userId="123" />
      <UserAvatar userId="123" />
    </>
  );
}
```

### React `cache` Function for Non-Fetch Requests

For database queries or other data sources, use React's `cache` function:

```typescript
// lib/data.ts
import { cache } from 'react';
import prisma from './prisma';

export const getUser = cache(async (id: string) => {
  const user = await prisma.user.findUnique({
    where: { id }
  });
  return user;
});

// This ensures the database query only runs once per request
// even if called multiple times
```

### Parallel vs Sequential Data Fetching

#### Sequential (Waterfall) - Slower

```typescript
export default async function Page() {
  // Wait for user
  const user = await fetch('https://api.example.com/user/1').then(r => r.json());
  
  // Then wait for posts
  const posts = await fetch(`https://api.example.com/users/${user.id}/posts`)
    .then(r => r.json());
  
  return <div>{/* render */}</div>;
}
```

#### Parallel - Faster

```typescript
export default async function Page() {
  // Start both fetches simultaneously
  const userPromise = fetch('https://api.example.com/user/1').then(r => r.json());
  const postsPromise = fetch('https://api.example.com/posts').then(r => r.json());
  
  // Wait for both to complete
  const [user, posts] = await Promise.all([userPromise, postsPromise]);
  
  return <div>{/* render */}</div>;
}
```

### Streaming with Suspense

```typescript
// app/dashboard/page.tsx
import { Suspense } from 'react';

async function SlowComponent() {
  const data = await fetch('https://slow-api.example.com/data', {
    cache: 'no-store'
  }).then(r => r.json());
  
  return <div>{data.content}</div>;
}

export default function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      
      {/* Fast content renders immediately */}
      <div>Quick content here</div>
      
      {/* Slow content shows fallback while loading */}
      <Suspense fallback={<div>Loading...</div>}>
        <SlowComponent />
      </Suspense>
    </div>
  );
}
```

---

## 4.2 Data Fetching (Pages Router)

### getStaticProps - Static Site Generation

**When to use**: Data doesn't change often, can be generated at build time.

```typescript
// pages/blog/index.tsx
import { GetStaticProps } from 'next';

interface Post {
  id: string;
  title: string;
  content: string;
}

interface Props {
  posts: Post[];
}

export const getStaticProps: GetStaticProps<Props> = async () => {
  const res = await fetch('https://api.example.com/posts');
  const posts = await res.json();
  
  return {
    props: {
      posts,
    },
    // Optional: Incremental Static Regeneration
    revalidate: 60, // Revalidate every 60 seconds
  };
};

export default function BlogPage({ posts }: Props) {
  return (
    <div>
      {posts.map(post => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.content}</p>
        </article>
      ))}
    </div>
  );
}
```

### getStaticPaths - Dynamic Static Pages

**Purpose**: Generate static pages for dynamic routes at build time.

```typescript
// pages/blog/[slug].tsx
import { GetStaticPaths, GetStaticProps } from 'next';

interface Post {
  slug: string;
  title: string;
  content: string;
}

// Specify which paths to pre-render
export const getStaticPaths: GetStaticPaths = async () => {
  const res = await fetch('https://api.example.com/posts');
  const posts: Post[] = await res.json();
  
  // Generate paths from post slugs
  const paths = posts.map(post => ({
    params: { slug: post.slug }
  }));
  
  return {
    paths,
    fallback: 'blocking', // or false, or true
  };
};

// Fetch data for each path
export const getStaticProps: GetStaticProps = async ({ params }) => {
  const res = await fetch(`https://api.example.com/posts/${params?.slug}`);
  const post = await res.json();
  
  return {
    props: {
      post,
    },
    revalidate: 3600, // Revalidate every hour
  };
};

export default function PostPage({ post }: { post: Post }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <div>{post.content}</div>
    </article>
  );
}
```

### Fallback Strategies

```typescript
export const getStaticPaths: GetStaticPaths = async () => {
  return {
    paths: [
      { params: { slug: 'post-1' } },
      { params: { slug: 'post-2' } }
    ],
    
    // fallback: false
    // - Only pre-rendered paths are valid
    // - 404 for any other path
    
    // fallback: true
    // - Show fallback UI immediately
    // - Generate page in background
    // - User sees loading state
    
    // fallback: 'blocking'
    // - Wait for page generation
    // - No loading state needed
    // - Better for SEO
    
    fallback: 'blocking'
  };
};
```

### getServerSideProps - Server-Side Rendering

**When to use**: Data changes frequently, needs to be fresh on every request.

```typescript
// pages/dashboard.tsx
import { GetServerSideProps } from 'next';

interface DashboardData {
  user: {
    name: string;
    email: string;
  };
  stats: {
    views: number;
    clicks: number;
  };
}

export const getServerSideProps: GetServerSideProps<{
  data: DashboardData
}> = async (context) => {
  // Access cookies, headers, query params
  const { req, res, query } = context;
  
  // Set cache headers
  res.setHeader(
    'Cache-Control',
    'public, s-maxage=10, stale-while-revalidate=59'
  );
  
  // Fetch fresh data
  const response = await fetch('https://api.example.com/dashboard', {
    headers: {
      Cookie: req.headers.cookie || '',
    },
  });
  
  const data = await response.json();
  
  // Redirect if not authenticated
  if (!data.user) {
    return {
      redirect: {
        destination: '/login',
        permanent: false,
      },
    };
  }
  
  // Return 404
  if (!data) {
    return {
      notFound: true,
    };
  }
  
  return {
    props: {
      data,
    },
  };
};

export default function Dashboard({ data }: { data: DashboardData }) {
  return (
    <div>
      <h1>Welcome, {data.user.name}</h1>
      <p>Views: {data.stats.views}</p>
      <p>Clicks: {data.stats.clicks}</p>
    </div>
  );
}
```

---

## 4.3 API Routes & Route Handlers

### API Routes (Pages Router)

```typescript
// pages/api/users/[id].ts
import type { NextApiRequest, NextApiResponse } from 'next';

interface User {
  id: string;
  name: string;
  email: string;
}

type Data = User | { error: string };

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  const { id } = req.query;
  
  // Method handling
  if (req.method === 'GET') {
    try {
      const user = await fetchUser(id as string);
      
      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      res.status(200).json(user);
    } catch (error) {
      res.status(500).json({ error: 'Internal server error' });
    }
  } else if (req.method === 'PUT') {
    // Update user
    const updatedUser = await updateUser(id as string, req.body);
    res.status(200).json(updatedUser);
  } else if (req.method === 'DELETE') {
    // Delete user
    await deleteUser(id as string);
    res.status(204).end();
  } else {
    res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}

async function fetchUser(id: string): Promise<User | null> {
  // Database query
  return null;
}

async function updateUser(id: string, data: any): Promise<User> {
  // Database update
  return {} as User;
}

async function deleteUser(id: string): Promise<void> {
  // Database delete
}
```

### Route Handlers (App Router)

**New in Next.js 13+**: Route handlers replace API routes with a more flexible system.

```typescript
// app/api/posts/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

// Validation schema
const postSchema = z.object({
  title: z.string().min(1).max(100),
  content: z.string().min(1),
  authorId: z.string(),
});

// GET /api/posts
export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const page = searchParams.get('page') || '1';
  const limit = searchParams.get('limit') || '10';
  
  try {
    const posts = await fetchPosts(
      parseInt(page),
      parseInt(limit)
    );
    
    return NextResponse.json({
      posts,
      page: parseInt(page),
      total: posts.length,
    });
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch posts' },
      { status: 500 }
    );
  }
}

// POST /api/posts
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Validate input
    const validatedData = postSchema.parse(body);
    
    // Create post
    const post = await createPost(validatedData);
    
    return NextResponse.json(post, { status: 201 });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid input', details: error.errors },
        { status: 400 }
      );
    }
    
    return NextResponse.json(
      { error: 'Failed to create post' },
      { status: 500 }
    );
  }
}

async function fetchPosts(page: number, limit: number) {
  // Database query
  return [];
}

async function createPost(data: z.infer<typeof postSchema>) {
  // Database insert
  return { id: '1', ...data };
}
```

### Dynamic Route Handlers

```typescript
// app/api/posts/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const post = await fetchPost(params.id);
  
  if (!post) {
    return NextResponse.json(
      { error: 'Post not found' },
      { status: 404 }
    );
  }
  
  return NextResponse.json(post);
}

export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const body = await request.json();
  const updatedPost = await updatePost(params.id, body);
  
  return NextResponse.json(updatedPost);
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  await deletePost(params.id);
  
  return new NextResponse(null, { status: 204 });
}

async function fetchPost(id: string) {
  return null;
}

async function updatePost(id: string, data: any) {
  return {};
}

async function deletePost(id: string) {
  // Delete logic
}
```

### Middleware for API Routes

```typescript
// lib/middleware.ts
import { NextRequest, NextResponse } from 'next/server';
import { verify } from 'jsonwebtoken';

export async function withAuth(
  request: NextRequest,
  handler: (req: NextRequest) => Promise<NextResponse>
) {
  const token = request.headers.get('authorization')?.split(' ')[1];
  
  if (!token) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }
  
  try {
    const decoded = verify(token, process.env.JWT_SECRET!);
    // Attach user to request (in production, use a better method)
    (request as any).user = decoded;
    
    return handler(request);
  } catch (error) {
    return NextResponse.json(
      { error: 'Invalid token' },
      { status: 401 }
    );
  }
}

// Usage in route handler
// app/api/protected/route.ts
import { withAuth } from '@/lib/middleware';

export async function GET(request: NextRequest) {
  return withAuth(request, async (req) => {
    const user = (req as any).user;
    return NextResponse.json({ message: `Hello ${user.name}` });
  });
}
```

---

## 4.4 External API Integration

### REST API Integration

```typescript
// lib/api-client.ts
class ApiClient {
  private baseURL: string;
  private headers: HeadersInit;
  
  constructor(baseURL: string) {
    this.baseURL = baseURL;
    this.headers = {
      'Content-Type': 'application/json',
    };
  }
  
  async get<T>(endpoint: string, options?: RequestInit): Promise<T> {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      method: 'GET',
      headers: this.headers,
      ...options,
    });
    
    if (!response.ok) {
      throw new ApiError(response.status, await response.text());
    }
    
    return response.json();
  }
  
  async post<T>(endpoint: string, data: any, options?: RequestInit): Promise<T> {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      method: 'POST',
      headers: this.headers,
      body: JSON.stringify(data),
      ...options,
    });
    
    if (!response.ok) {
      throw new ApiError(response.status, await response.text());
    }
    
    return response.json();
  }
  
  // Add PUT, DELETE, PATCH methods...
}

class ApiError extends Error {
  constructor(public status: number, message: string) {
    super(message);
    this.name = 'ApiError';
  }
}

export const apiClient = new ApiClient(process.env.NEXT_PUBLIC_API_URL!);
```

### Error Handling with Retry Logic

```typescript
// lib/fetch-with-retry.ts
interface RetryOptions {
  maxRetries?: number;
  retryDelay?: number;
  retryOn?: number[];
}

export async function fetchWithRetry(
  url: string,
  options: RequestInit = {},
  retryOptions: RetryOptions = {}
): Promise<Response> {
  const {
    maxRetries = 3,
    retryDelay = 1000,
    retryOn = [408, 429, 500, 502, 503, 504]
  } = retryOptions;
  
  let lastError: Error;
  
  for (let i = 0; i <= maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      
      if (response.ok || !retryOn.includes(response.status)) {
        return response;
      }
      
      lastError = new Error(`HTTP ${response.status}: ${response.statusText}`);
    } catch (error) {
      lastError = error as Error;
    }
    
    if (i < maxRetries) {
      // Exponential backoff
      await new Promise(resolve => 
        setTimeout(resolve, retryDelay * Math.pow(2, i))
      );
    }
  }
  
  throw lastError!;
}

// Usage
const data = await fetchWithRetry('https://api.example.com/data', {
  method: 'GET',
}, {
  maxRetries: 3,
  retryDelay: 1000,
});
```

### GraphQL Integration with Apollo Client

```typescript
// lib/apollo-client.ts
import { ApolloClient, InMemoryCache, HttpLink } from '@apollo/client';

export const apolloClient = new ApolloClient({
  link: new HttpLink({
    uri: process.env.NEXT_PUBLIC_GRAPHQL_URL,
    credentials: 'include',
  }),
  cache: new InMemoryCache(),
  defaultOptions: {
    query: {
      fetchPolicy: 'cache-first',
    },
  },
});

// app/users/page.tsx
import { gql } from '@apollo/client';
import { apolloClient } from '@/lib/apollo-client';

const GET_USERS = gql`
  query GetUsers {
    users {
      id
      name
      email
    }
  }
`;

export default async function UsersPage() {
  const { data } = await apolloClient.query({
    query: GET_USERS,
  });
  
  return (
    <div>
      {data.users.map((user: any) => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
}
```

---

## 4.5 Database Integration

### Prisma ORM Setup and Usage

```typescript
// prisma/schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  posts     Post[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

```typescript
// lib/prisma.ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

```typescript
// app/posts/page.tsx
import { prisma } from '@/lib/prisma';

async function getPosts() {
  const posts = await prisma.post.findMany({
    where: {
      published: true,
    },
    include: {
      author: {
        select: {
          name: true,
          email: true,
        },
      },
    },
    orderBy: {
      createdAt: 'desc',
    },
  });
  
  return posts;
}

export default async function PostsPage() {
  const posts = await getPosts();
  
  return (
    <div>
      {posts.map(post => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>By {post.author.name}</p>
          <p>{post.content}</p>
        </article>
      ))}
    </div>
  );
}
```

### MongoDB Integration

```typescript
// lib/mongodb.ts
import { MongoClient } from 'mongodb';

if (!process.env.MONGODB_URI) {
  throw new Error('Please add your Mongo URI to .env.local');
}

const uri = process.env.MONGODB_URI;
const options = {};

let client: MongoClient;
let clientPromise: Promise<MongoClient>;

if (process.env.NODE_ENV === 'development') {
  const globalWithMongo = global as typeof globalThis & {
    _mongoClientPromise?: Promise<MongoClient>
  };
  
  if (!globalWithMongo._mongoClientPromise) {
    client = new MongoClient(uri, options);
    globalWithMongo._mongoClientPromise = client.connect();
  }
  clientPromise = globalWithMongo._mongoClientPromise;
} else {
  client = new MongoClient(uri, options);
  clientPromise = client.connect();
}

export default clientPromise;
```

```typescript
// app/api/products/route.ts
import clientPromise from '@/lib/mongodb';
import { NextResponse } from 'next/server';

export async function GET() {
  try {
    const client = await clientPromise;
    const db = client.db('myDatabase');
    
    const products = await db
      .collection('products')
      .find({})
      .limit(10)
      .toArray();
    
    return NextResponse.json(products);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch products' },
      { status: 500 }
    );
  }
}
```

### Connection Pooling Best Practices

**Critical**: Never create new database connections in API routes or Server Components without pooling.

```typescript
// ❌ BAD - Creates new connection every time
export async function GET() {
  const client = new MongoClient(uri);
  await client.connect(); // New connection each time!
  // ...
}

// ✅ GOOD - Reuses connection
export async function GET() {
  const client = await clientPromise; // Reuses existing connection
  // ...
}
```

### Transaction Handling with Prisma

```typescript
// app/api/transfer/route.ts
import { prisma } from '@/lib/prisma';
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  const { fromUserId, toUserId, amount } = await request.json();
  
  try {
    const result = await prisma.$transaction(async (tx) => {
      // Deduct from sender
      const sender = await tx.user.update({
        where: { id: fromUserId },
        data: {
          balance: {
            decrement: amount,
          },
        },
      });
      
      if (sender.balance < 0) {
        throw new Error('Insufficient funds');
      }
      
      // Add to receiver
      const receiver = await tx.user.update({
        where: { id: toUserId },
        data: {
          balance: {
            increment: amount,
          },
        },
      });
      
      // Create transaction record
      const transaction = await tx.transaction.create({
        data: {
          fromUserId,
          toUserId,
          amount,
          status: 'completed',
        },
      });
      
      return { sender, receiver, transaction };
    });
    
    return NextResponse.json(result);
  } catch (error) {
    return NextResponse.json(
      { error: 'Transaction failed' },
      { status: 500 }
    );
  }
}
```

## Summary & Best Practices

### Key Takeaways

1. **App Router**: Use Server Components for data fetching by default
2. **Caching**: Understand `cache: 'force-cache'` vs `'no-store'` vs `revalidate`
3. **Parallel Fetching**: Always fetch data in parallel when possible
4. **Request Memoization**: Leverage automatic deduplication
5. **Pages Router**: Choose the right method (getStaticProps vs getServerSideProps)
6. **API Routes**: Validate inputs, handle errors properly
7. **Database**: Always use connection pooling, never create connections in routes
8. **Error Handling**: Implement retry logic and proper error responses

### Performance Tips

- Use ISR for content that changes infrequently
- Implement streaming with Suspense for slow components
- Leverage React `cache` for database queries
- Always validate and sanitize user inputs
- Monitor database query performance
- Use transactions for critical operations