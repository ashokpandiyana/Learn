# Chapter 9: Authentication & Authorization - In-Depth Guide

## 9.1 Authentication Strategies

### Understanding Authentication vs Authorization

**Authentication**: Verifying *who* the user is  
**Authorization**: Verifying *what* the user can access

### JWT (JSON Web Tokens)

#### How JWT Works

```
1. User logs in with credentials
2. Server validates and creates JWT token
3. Token contains: Header + Payload + Signature
4. Client stores token (cookie/localStorage)
5. Client sends token with each request
6. Server verifies token signature
```

#### JWT Structure

```javascript
// Header
{
  "alg": "HS256",
  "typ": "JWT"
}

// Payload
{
  "userId": "123",
  "email": "user@example.com",
  "role": "admin",
  "iat": 1516239022,  // Issued at
  "exp": 1516242622   // Expiration
}

// Signature = HMACSHA256(
//   base64UrlEncode(header) + "." + base64UrlEncode(payload),
//   secret
// )
```

#### Implementing JWT Authentication

```javascript
// lib/jwt.js
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET;
const JWT_EXPIRATION = '7d';

export function signToken(payload) {
  return jwt.sign(payload, JWT_SECRET, {
    expiresIn: JWT_EXPIRATION,
  });
}

export function verifyToken(token) {
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (error) {
    return null;
  }
}

export function decodeToken(token) {
  return jwt.decode(token);
}
```

#### Login API Route

```javascript
// app/api/auth/login/route.js
import { NextResponse } from 'next/server';
import { signToken } from '@/lib/jwt';
import bcrypt from 'bcryptjs';
import { getUserByEmail } from '@/lib/db';

export async function POST(request) {
  try {
    const { email, password } = await request.json();

    // Validate input
    if (!email || !password) {
      return NextResponse.json(
        { error: 'Email and password required' },
        { status: 400 }
      );
    }

    // Find user
    const user = await getUserByEmail(email);
    if (!user) {
      return NextResponse.json(
        { error: 'Invalid credentials' },
        { status: 401 }
      );
    }

    // Verify password
    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      return NextResponse.json(
        { error: 'Invalid credentials' },
        { status: 401 }
      );
    }

    // Create JWT token
    const token = signToken({
      userId: user.id,
      email: user.email,
      role: user.role,
    });

    // Create response with httpOnly cookie
    const response = NextResponse.json(
      {
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
        },
      },
      { status: 200 }
    );

    // Set httpOnly cookie (most secure)
    response.cookies.set('token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 24 * 7, // 7 days
      path: '/',
    });

    return response;
  } catch (error) {
    console.error('Login error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

#### Protected API Route

```javascript
// app/api/profile/route.js
import { NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { verifyToken } from '@/lib/jwt';
import { getUserById } from '@/lib/db';

export async function GET() {
  try {
    // Get token from cookie
    const cookieStore = cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      return NextResponse.json(
        { error: 'Not authenticated' },
        { status: 401 }
      );
    }

    // Verify token
    const decoded = verifyToken(token);
    if (!decoded) {
      return NextResponse.json(
        { error: 'Invalid token' },
        { status: 401 }
      );
    }

    // Get user data
    const user = await getUserById(decoded.userId);
    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({ user });
  } catch (error) {
    console.error('Profile error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

#### Middleware for Route Protection

```javascript
// middleware.js
import { NextResponse } from 'next/server';
import { verifyToken } from '@/lib/jwt';

export async function middleware(request) {
  const token = request.cookies.get('token')?.value;

  // Protected routes
  const protectedPaths = ['/dashboard', '/profile', '/admin'];
  const isProtectedPath = protectedPaths.some(path =>
    request.nextUrl.pathname.startsWith(path)
  );

  if (isProtectedPath) {
    if (!token) {
      return NextResponse.redirect(new URL('/login', request.url));
    }

    const decoded = verifyToken(token);
    if (!decoded) {
      return NextResponse.redirect(new URL('/login', request.url));
    }

    // Add user info to headers for Server Components
    const requestHeaders = new Headers(request.headers);
    requestHeaders.set('x-user-id', decoded.userId);
    requestHeaders.set('x-user-role', decoded.role);

    return NextResponse.next({
      request: {
        headers: requestHeaders,
      },
    });
  }

  return NextResponse.next();
}

export const config = {
  matcher: ['/dashboard/:path*', '/profile/:path*', '/admin/:path*'],
};
```

### Session-Based Authentication

#### Using Iron Session

```bash
npm install iron-session
```

```javascript
// lib/session.js
import { getIronSession } from 'iron-session';
import { cookies } from 'next/headers';

export const sessionOptions = {
  password: process.env.SESSION_SECRET,
  cookieName: 'myapp_session',
  cookieOptions: {
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // 7 days
  },
};

export async function getSession() {
  const session = await getIronSession(cookies(), sessionOptions);
  return session;
}

// Session type
export interface SessionData {
  userId?: string;
  email?: string;
  role?: string;
  isLoggedIn: boolean;
}
```

#### Login with Session

```javascript
// app/api/auth/login/route.js
import { NextResponse } from 'next/server';
import { getSession } from '@/lib/session';
import bcrypt from 'bcryptjs';
import { getUserByEmail } from '@/lib/db';

export async function POST(request) {
  try {
    const { email, password } = await request.json();

    const user = await getUserByEmail(email);
    if (!user) {
      return NextResponse.json(
        { error: 'Invalid credentials' },
        { status: 401 }
      );
    }

    const isValid = await bcrypt.compare(password, user.password);
    if (!isValid) {
      return NextResponse.json(
        { error: 'Invalid credentials' },
        { status: 401 }
      );
    }

    // Get session and set data
    const session = await getSession();
    session.userId = user.id;
    session.email = user.email;
    session.role = user.role;
    session.isLoggedIn = true;
    await session.save();

    return NextResponse.json({ success: true });
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

#### Accessing Session in Server Component

```javascript
// app/dashboard/page.jsx
import { getSession } from '@/lib/session';
import { redirect } from 'next/navigation';
import { getUserById } from '@/lib/db';

export default async function DashboardPage() {
  const session = await getSession();

  if (!session.isLoggedIn) {
    redirect('/login');
  }

  const user = await getUserById(session.userId);

  return (
    <div>
      <h1>Welcome, {user.name}!</h1>
      <p>Email: {session.email}</p>
    </div>
  );
}
```

---

## 9.2 NextAuth.js

### Setup

```bash
npm install next-auth
```

### Configuration

```javascript
// app/api/auth/[...nextauth]/route.js
import NextAuth from 'next-auth';
import GoogleProvider from 'next-auth/providers/google';
import GitHubProvider from 'next-auth/providers/github';
import CredentialsProvider from 'next-auth/providers/credentials';
import { PrismaAdapter } from '@auth/prisma-adapter';
import { prisma } from '@/lib/prisma';
import bcrypt from 'bcryptjs';

export const authOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [
    // OAuth Providers
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    }),
    GitHubProvider({
      clientId: process.env.GITHUB_ID,
      clientSecret: process.env.GITHUB_SECRET,
    }),
    
    // Credentials Provider (email/password)
    CredentialsProvider({
      name: 'Credentials',
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          throw new Error('Invalid credentials');
        }

        const user = await prisma.user.findUnique({
          where: { email: credentials.email },
        });

        if (!user || !user.hashedPassword) {
          throw new Error('Invalid credentials');
        }

        const isValid = await bcrypt.compare(
          credentials.password,
          user.hashedPassword
        );

        if (!isValid) {
          throw new Error('Invalid credentials');
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
        };
      },
    }),
  ],
  
  pages: {
    signIn: '/login',
    signOut: '/logout',
    error: '/auth/error',
    verifyRequest: '/auth/verify',
  },
  
  callbacks: {
    async jwt({ token, user, account }) {
      // Add user info to token on sign in
      if (user) {
        token.id = user.id;
        token.role = user.role;
      }
      
      // Add OAuth provider info
      if (account) {
        token.accessToken = account.access_token;
      }
      
      return token;
    },
    
    async session({ session, token }) {
      // Add user info to session
      if (token) {
        session.user.id = token.id;
        session.user.role = token.role;
      }
      return session;
    },
    
    async redirect({ url, baseUrl }) {
      // Redirect to dashboard after login
      if (url.startsWith(baseUrl)) return url;
      if (url.startsWith('/')) return `${baseUrl}${url}`;
      return baseUrl + '/dashboard';
    },
  },
  
  session: {
    strategy: 'jwt', // Use JWT for sessions
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  
  secret: process.env.NEXTAUTH_SECRET,
  
  debug: process.env.NODE_ENV === 'development',
};

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };
```

### Session Provider (App Router)

```jsx
// app/providers.jsx
'use client';

import { SessionProvider } from 'next-auth/react';

export default function Providers({ children }) {
  return <SessionProvider>{children}</SessionProvider>;
}

// app/layout.js
import Providers from './providers';

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
```

### Using NextAuth in Components

#### Client Component

```jsx
'use client';

import { useSession, signIn, signOut } from 'next-auth/react';

export default function LoginButton() {
  const { data: session, status } = useSession();

  if (status === 'loading') {
    return <div>Loading...</div>;
  }

  if (session) {
    return (
      <div>
        <p>Signed in as {session.user.email}</p>
        <p>Role: {session.user.role}</p>
        <button onClick={() => signOut()}>Sign out</button>
      </div>
    );
  }

  return (
    <div>
      <button onClick={() => signIn('google')}>Sign in with Google</button>
      <button onClick={() => signIn('github')}>Sign in with GitHub</button>
      <button onClick={() => signIn('credentials')}>
        Sign in with Email
      </button>
    </div>
  );
}
```

#### Server Component

```javascript
// app/dashboard/page.jsx
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import { redirect } from 'next/navigation';

export default async function DashboardPage() {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect('/login');
  }

  return (
    <div>
      <h1>Dashboard</h1>
      <p>Welcome, {session.user.name}!</p>
      <p>Email: {session.user.email}</p>
      <p>Role: {session.user.role}</p>
    </div>
  );
}
```

#### Custom Login Page

```jsx
'use client';

import { signIn } from 'next-auth/react';
import { useState } from 'react';
import { useRouter } from 'next/navigation';

export default function LoginPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const router = useRouter();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      const result = await signIn('credentials', {
        email,
        password,
        redirect: false,
      });

      if (result?.error) {
        setError('Invalid email or password');
      } else {
        router.push('/dashboard');
        router.refresh();
      }
    } catch (error) {
      setError('An error occurred');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <h1>Login</h1>
      <form onSubmit={handleSubmit}>
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          placeholder="Email"
          required
        />
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          placeholder="Password"
          required
        />
        <button type="submit" disabled={loading}>
          {loading ? 'Loading...' : 'Sign in'}
        </button>
      </form>
      
      {error && <p style={{ color: 'red' }}>{error}</p>}
      
      <hr />
      
      <button onClick={() => signIn('google')}>
        Sign in with Google
      </button>
      <button onClick={() => signIn('github')}>
        Sign in with GitHub
      </button>
    </div>
  );
}
```

---

## 9.3 Authorization Patterns

### Role-Based Access Control (RBAC)

#### Defining Roles

```typescript
// types/auth.ts
export enum Role {
  USER = 'USER',
  ADMIN = 'ADMIN',
  MODERATOR = 'MODERATOR',
}

export type User = {
  id: string;
  email: string;
  name: string;
  role: Role;
};
```

#### Middleware Authorization

```javascript
// middleware.js
import { NextResponse } from 'next/server';
import { getToken } from 'next-auth/jwt';

export async function middleware(request) {
  const token = await getToken({ req: request });
  const { pathname } = request.nextUrl;

  // Admin routes
  if (pathname.startsWith('/admin')) {
    if (!token) {
      return NextResponse.redirect(new URL('/login', request.url));
    }
    if (token.role !== 'ADMIN') {
      return NextResponse.redirect(new URL('/unauthorized', request.url));
    }
  }

  // Moderator routes
  if (pathname.startsWith('/moderate')) {
    if (!token) {
      return NextResponse.redirect(new URL('/login', request.url));
    }
    if (!['ADMIN', 'MODERATOR'].includes(token.role)) {
      return NextResponse.redirect(new URL('/unauthorized', request.url));
    }
  }

  return NextResponse.next();
}

export const config = {
  matcher: ['/admin/:path*', '/moderate/:path*'],
};
```

#### Higher-Order Component for Authorization

```jsx
'use client';

import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';

export function withAuth(Component, allowedRoles = []) {
  return function AuthenticatedComponent(props) {
    const { data: session, status } = useSession();
    const router = useRouter();

    useEffect(() => {
      if (status === 'loading') return;

      if (!session) {
        router.push('/login');
        return;
      }

      if (allowedRoles.length > 0 && !allowedRoles.includes(session.user.role)) {
        router.push('/unauthorized');
      }
    }, [session, status, router]);

    if (status === 'loading') {
      return <div>Loading...</div>;
    }

    if (!session) {
      return null;
    }

    if (allowedRoles.length > 0 && !allowedRoles.includes(session.user.role)) {
      return null;
    }

    return <Component {...props} />;
  };
}

// Usage
const AdminDashboard = () => {
  return <div>Admin Dashboard</div>;
};

export default withAuth(AdminDashboard, ['ADMIN']);
```

#### Server-Side Authorization

```javascript
// app/admin/page.jsx
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import { redirect } from 'next/navigation';

export default async function AdminPage() {
  const session = await getServerSession(authOptions);

  if (!session || session.user.role !== 'ADMIN') {
    redirect('/unauthorized');
  }

  return <div>Admin Page</div>;
}
```

#### Custom Authorization Hook

```javascript
// hooks/useAuthorization.js
'use client';

import { useSession } from 'next-auth/react';

export function useAuthorization() {
  const { data: session } = useSession();

  const can = (action, resource) => {
    if (!session) return false;

    const permissions = {
      ADMIN: {
        users: ['read', 'create', 'update', 'delete'],
        posts: ['read', 'create', 'update', 'delete'],
        settings: ['read', 'update'],
      },
      MODERATOR: {
        posts: ['read', 'update', 'delete'],
        comments: ['read', 'update', 'delete'],
      },
      USER: {
        posts: ['read', 'create'],
        comments: ['read', 'create'],
        profile: ['read', 'update'],
      },
    };

    const rolePermissions = permissions[session.user.role] || {};
    const resourcePermissions = rolePermissions[resource] || [];

    return resourcePermissions.includes(action);
  };

  const hasRole = (roles) => {
    if (!session) return false;
    return roles.includes(session.user.role);
  };

  return { can, hasRole, user: session?.user };
}

// Usage
export function PostActions({ postId }) {
  const { can, hasRole } = useAuthorization();

  return (
    <div>
      {can('update', 'posts') && (
        <button>Edit Post</button>
      )}
      {can('delete', 'posts') && (
        <button>Delete Post</button>
      )}
      {hasRole(['ADMIN']) && (
        <button>Pin Post</button>
      )}
    </div>
  );
}
```

### Attribute-Based Access Control (ABAC)

```javascript
// lib/authorization.js
export function checkAccess(user, resource, action) {
  // Policy-based access control
  const policies = {
    // Users can edit their own posts
    editOwnPost: (user, resource) => {
      return resource.authorId === user.id;
    },
    
    // Admins can edit any post
    editAnyPost: (user) => {
      return user.role === 'ADMIN';
    },
    
    // Users can delete posts within 24 hours
    deleteRecentPost: (user, resource) => {
      const hoursSinceCreation = (Date.now() - new Date(resource.createdAt)) / (1000 * 60 * 60);
      return resource.authorId === user.id && hoursSinceCreation < 24;
    },
    
    // Premium users can access premium content
    accessPremiumContent: (user, resource) => {
      return user.subscription === 'premium' || user.role === 'ADMIN';
    },
  };

  // Check policies for the action
  switch (action) {
    case 'edit':
      return policies.editOwnPost(user, resource) || policies.editAnyPost(user);
    
    case 'delete':
      return policies.deleteRecentPost(user, resource) || policies.editAnyPost(user);
    
    case 'view':
      if (resource.isPremium) {
        return policies.accessPremiumContent(user, resource);
      }
      return true;
    
    default:
      return false;
  }
}

// Usage in API route
export async function DELETE(request, { params }) {
  const session = await getServerSession(authOptions);
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const post = await getPostById(params.id);
  
  if (!checkAccess(session.user, post, 'delete')) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  await deletePost(params.id);
  return NextResponse.json({ success: true });
}
```

---

## 9.4 Security Best Practices

### Password Hashing

```javascript
// lib/password.js
import bcrypt from 'bcryptjs';

export async function hashPassword(password) {
  const salt = await bcrypt.genSalt(12);
  return bcrypt.hash(password, salt);
}

export async function verifyPassword(password, hashedPassword) {
  return bcrypt.compare(password, hashedPassword);
}

// Usage in signup
export async function POST(request) {
  const { email, password } = await request.json();
  
  // Hash password before storing
  const hashedPassword = await hashPassword(password);
  
  const user = await prisma.user.create({
    data: {
      email,
      hashedPassword,
    },
  });
  
  return NextResponse.json({ success: true });
}
```

### CSRF Protection

```javascript
// lib/csrf.js
import { randomBytes } from 'crypto';

export function generateCSRFToken() {
  return randomBytes(32).toString('hex');
}

export function verifyCSRFToken(token, sessionToken) {
  return token === sessionToken;
}

// Middleware
export async function middleware(request) {
  if (request.method === 'POST' || request.method === 'DELETE' || request.method === 'PUT') {
    const csrfToken = request.headers.get('x-csrf-token');
    const session = await getSession();
    
    if (!csrfToken || !verifyCSRFToken(csrfToken, session.csrfToken)) {
      return NextResponse.json(
        { error: 'Invalid CSRF token' },
        { status: 403 }
      );
    }
  }
  
  return NextResponse.next();
}
```

### Secure Headers

```javascript
// middleware.js
export function middleware(request) {
  const response = NextResponse.next();

  // Security headers
  response.headers.set('X-DNS-Prefetch-Control', 'on');
  response.headers.set('Strict-Transport-Security', 'max-age=63072000; includeSubDomains; preload');
  response.headers.set('X-Frame-Options', 'SAMEORIGIN');
  response.headers.set('X-Content-Type-Options', 'nosniff');
  response.headers.set('X-XSS-Protection', '1; mode=block');
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');
  response.headers.set(
    'Permissions-Policy',
    'camera=(), microphone=(), geolocation=()'
  );

  return response;
}
```

### Rate Limiting

```javascript
// lib/rateLimit.js
import { LRUCache } from 'lru-cache';

const rateLimit = new LRUCache({
  max: 500,
  ttl: 60000, // 1 minute
});

export function checkRateLimit(identifier, limit = 10) {
  const tokenCount = rateLimit.get(identifier) || 0;
  
  if (tokenCount >= limit) {
    return false;
  }
  
  rateLimit.set(identifier, tokenCount + 1);
  return true;
}

// Usage in API route
export async function POST(request) {
  const ip = request.headers.get('x-forwarded-for') || 'unknown';
  
  if (!checkRateLimit(ip, 5)) {
    return NextResponse.json(
      { error: 'Too many requests' },
      { status: 429 }
    );
  }
  
  // Process request...
}
```

### Environment Variables Security

```javascript
// ❌ Never expose secrets to client
// .env.local
DATABASE_URL=postgresql://...
JWT_SECRET=super-secret-key
NEXTAUTH_SECRET=another-secret

// ✅ Prefix with NEXT_PUBLIC_ for client access
NEXT_PUBLIC_API_URL=https://api.example.com
NEXT_PUBLIC_GA_ID=G-XXXXXXXXXX

// next.config.js - Validate required env vars
const requiredEnvVars = [
  'DATABASE_URL',
  'JWT_SECRET',
  'NEXTAUTH_SECRET',
];

requiredEnvVars.forEach((envVar) => {
  if (!process.env[envVar]) {
    throw new Error(`Missing required environment variable: ${envVar}`);
  }
});

module.exports = {
  // Your config...
};
```

### Input Validation

```javascript
// lib/validation.js
import { z } from 'zod';

export const loginSchema = z.object({
  email: z.string().email('Invalid email'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
});

export const registerSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain uppercase letter')
    .regex(/[a-z]/, 'Password must contain lowercase letter')
    .regex(/[0-9]/, 'Password must contain number')
    .regex(/[^A-Za-z0-9]/, 'Password must contain special character'),
});

// Usage in API route
export async function POST(request) {
  try {
    const body = await request.json();
    const validatedData = loginSchema.parse(body);
    
    // Process valid data...
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { errors: error.errors },
        { status: 400 }
      );
    }
    return NextResponse.json(
      { error: 'Invalid input' },
      { status: 400 }
    );
  }
}
```

### SQL Injection Prevention

```javascript
// ❌ Never do this - vulnerable to SQL injection
const query = `SELECT * FROM users WHERE email = '${email}'`;

// ✅ Use parameterized queries (Prisma does this automatically)
const user = await prisma.user.findUnique({
  where: { email },
});

// ✅ Or use parameterized queries with raw SQL
const users = await prisma.$queryRaw`
  SELECT * FROM users WHERE email = ${email}
`;
```

### XSS Prevention

```jsx
// Next.js automatically escapes content in JSX
function UserProfile({ userData }) {
  // This is safe - automatically escaped
  return <div>{userData.bio}</div>;
}

// ❌ Dangerous - allows XSS
function DangerousHTML({ html }) {
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}

// ✅ Sanitize HTML before rendering
import DOMPurify from 'isomorphic-dompurify';

function SafeHTML({ html }) {
  const sanitized = DOMPurify.sanitize(html);
  return <div dangerouslySetInnerHTML={{ __html: sanitized }} />;
}
```

This completes Chapter 9 with comprehensive authentication and authorization patterns!