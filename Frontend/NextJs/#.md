# Next.js Mastery Guide - Beginner to Advanced

## Chapter 1: Next.js Fundamentals

### 1.1 Introduction to Next.js
- What is Next.js and why use it?
- React vs Next.js comparison
- Next.js features overview (SSR, SSG, ISR, API Routes, File-based routing)
- When to use Next.js vs Create React App
- **Important**: Next.js 13+ App Router vs Pages Router differences

### 1.2 Environment Setup
- Node.js and npm/yarn/pnpm installation
- Creating a Next.js project (`create-next-app`)
- Project structure understanding
- Configuration files (next.config.js, tsconfig.json)
- **Highlight**: TypeScript setup is production standard

### 1.3 File-Based Routing Basics
- Pages directory structure
- Dynamic routes (`[id].js`)
- Nested routes
- Index routes
- **Important**: Route precedence and priority

## Chapter 2: App Router (Next.js 13+)

### 2.1 App Directory Structure
- Understanding the `app` directory
- Layout components (layout.js, layout.tsx)
- Page components (page.js, page.tsx)
- Loading UI (loading.js)
- Error handling (error.js)
- Not Found pages (not-found.js)
- **Highlight**: App Router is the future of Next.js

### 2.2 Server Components vs Client Components
- React Server Components (RSC) fundamentals
- When to use 'use client' directive
- Component composition patterns
- Data fetching in Server Components
- **Critical**: Default is Server Component, opt-in to Client Components
- **Interview Focus**: Explain the benefits of RSC

### 2.3 Route Groups and Parallel Routes
- Route groups `(folder)` for organization
- Parallel routes using `@folder` convention
- Intercepting routes `(.)folder`
- **Important**: These don't affect URL structure

### 2.4 Layouts and Templates
- Root layout (mandatory)
- Nested layouts
- Layout vs Template differences
- Preserving state with layouts
- **Highlight**: Layouts don't re-render on navigation

## Chapter 3: Rendering Strategies

### 3.1 Server-Side Rendering (SSR)
- How SSR works in Next.js
- `getServerSideProps` (Pages Router)
- Dynamic rendering in App Router
- Benefits and trade-offs
- **Important**: SSR happens on every request
- **Interview Topic**: SSR vs CSR performance implications

### 3.2 Static Site Generation (SSG)
- `getStaticProps` (Pages Router)
- `generateStaticParams` (App Router)
- Build-time data fetching
- When to use SSG
- **Highlight**: Best for SEO and performance
- **Production Note**: ISR is often preferred over pure SSG

### 3.3 Incremental Static Regeneration (ISR)
- Revalidation strategies
- On-demand revalidation
- `revalidate` option
- **Critical**: Combines benefits of SSG and SSR
- **Interview Focus**: Explain ISR use cases and implementation

### 3.4 Client-Side Rendering (CSR)
- useEffect for data fetching
- SWR and React Query integration
- Progressive enhancement
- **Important**: When to choose CSR over SSR/SSG

### 3.5 Streaming and Suspense
- React Suspense in Next.js
- Streaming SSR
- Progressive hydration
- Loading.js for route segments
- **Highlight**: Improves perceived performance significantly

## Chapter 4: Data Fetching

### 4.1 Data Fetching Patterns (App Router)
- Server Components data fetching
- `fetch` with caching options
- Request memoization
- **Important**: fetch is extended with caching by default
- **Production Tip**: Understand cache: 'force-cache', 'no-store'

### 4.2 Data Fetching (Pages Router)
- getStaticProps
- getServerSideProps
- getStaticPaths
- getInitialProps (legacy)
- **Interview Topic**: When to use each method

### 4.3 API Routes & Route Handlers
- Creating API endpoints
- Route handlers in App Router (route.js)
- Request and Response objects
- Middleware for API routes
- **Important**: RESTful API design patterns
- **Production**: Error handling and validation

### 4.4 External API Integration
- REST API calls
- GraphQL integration (Apollo, urql)
- Authentication in API calls
- Error handling strategies
- **Highlight**: Implementing retry logic

### 4.5 Database Integration
- Prisma ORM integration
- MongoDB connection
- PostgreSQL with pg
- Connection pooling
- **Critical**: Database connection best practices
- **Production**: Use connection pooling, avoid creating connections in API routes

## Chapter 5: Routing Advanced

### 5.1 Dynamic Routing Deep Dive
- Single dynamic routes `[slug]`
- Catch-all routes `[...slug]`
- Optional catch-all `[[...slug]]`
- **Important**: Route matching priority
- **Interview**: Explain URL parameter extraction

### 5.2 Navigation
- Link component optimization
- useRouter hook (Pages Router)
- useRouter, usePathname, useSearchParams (App Router)
- Programmatic navigation
- **Highlight**: Prefetching behavior of Link
- **Production**: Shallow routing for URL updates

### 5.3 Middleware
- Creating middleware.js/ts
- Matching paths with matcher config
- Request/Response manipulation
- Authentication middleware
- **Critical**: Middleware runs on Edge runtime
- **Interview Focus**: Middleware execution order and use cases

### 5.4 Route Protection
- Authentication checks
- Role-based access control
- Redirect strategies
- **Production**: Implement auth guards properly

## Chapter 6: Styling Solutions

### 6.1 CSS Modules
- Component-scoped styling
- Naming conventions
- Global styles
- **Highlight**: Zero runtime overhead

### 6.2 Tailwind CSS
- Setup and configuration
- JIT mode
- Custom theme configuration
- **Production Standard**: Most common in modern Next.js apps
- **Important**: Purging unused styles

### 6.3 CSS-in-JS Solutions
- Styled-components setup
- Emotion integration
- Server Components compatibility
- **Note**: Some CSS-in-JS libraries require 'use client'

### 6.4 Sass/SCSS
- Installation and setup
- Global styles
- Module styles
- **Highlight**: Variables and mixins

## Chapter 7: Performance Optimization

### 7.1 Image Optimization
- next/image component
- Image formats (WebP, AVIF)
- Responsive images
- Priority loading
- Placeholder options (blur, empty)
- **Critical**: Proper image sizing prevents layout shift
- **Production**: Use CDN for images, optimize source images

### 7.2 Font Optimization
- next/font for Google Fonts
- Local font files
- Font display strategies
- **Highlight**: Automatic font subsetting
- **Interview**: Explain FOUT, FOIT, and font-display

### 7.3 Script Optimization
- next/script component
- Loading strategies (beforeInteractive, afterInteractive, lazyOnload)
- Third-party script management
- **Important**: Defer non-critical scripts

### 7.4 Code Splitting and Lazy Loading
- Automatic code splitting
- Dynamic imports
- React.lazy with Suspense
- **Production**: Analyze bundle size regularly
- **Tool**: Use @next/bundle-analyzer

### 7.5 Caching Strategies
- Browser caching
- CDN caching
- SWR/React Query
- **Important**: Cache-Control headers
- **Interview Focus**: Different caching layers

### 7.6 Core Web Vitals
- LCP (Largest Contentful Paint)
- FID (First Input Delay) / INP (Interaction to Next Paint)
- CLS (Cumulative Layout Shift)
- Measuring and improving metrics
- **Production Critical**: Monitor in production with RUM

## Chapter 8: State Management

### 8.1 React State Basics
- useState, useReducer
- Context API
- State lifting
- **Important**: When to use local vs global state

### 8.2 Global State Solutions
- Redux Toolkit integration
- Zustand (lightweight alternative)
- Jotai (atomic state)
- **Highlight**: Server/Client state boundary considerations

### 8.3 Server State Management
- SWR (Vercel's solution)
- React Query / TanStack Query
- Data fetching, caching, synchronization
- **Production Standard**: React Query for complex apps
- **Interview**: Explain optimistic updates

### 8.4 URL State
- Search params
- URL as state source
- **Highlight**: Shareable state via URL

## Chapter 9: Authentication & Authorization

### 9.1 Authentication Strategies
- JWT tokens
- Session-based auth
- OAuth providers
- **Important**: Secure token storage

### 9.2 NextAuth.js
- Setup and configuration
- Providers (Google, GitHub, credentials)
- Session management
- Callbacks and events
- **Production Standard**: Most popular auth solution
- **Critical**: Understand session strategies

### 9.3 Authorization Patterns
- Route protection (middleware, HOCs)
- Role-based access
- Permission systems
- **Interview**: Explain RBAC vs ABAC

### 9.4 Security Best Practices
- CSRF protection
- XSS prevention
- Secure headers
- Environment variables
- **Critical**: Never expose secrets to client

## Chapter 10: Forms and Validation

### 10.1 Form Handling
- Controlled vs uncontrolled forms
- Form submission patterns
- **Important**: Server Actions in Next.js 13+

### 10.2 React Hook Form
- Setup and usage
- Validation rules
- Error handling
- **Production Standard**: Most performant form library

### 10.3 Validation Libraries
- Zod integration
- Yup schemas
- Server-side validation
- **Critical**: Always validate on server

### 10.4 Server Actions
- Server Actions in App Router
- Form actions
- Progressive enhancement
- Revalidation after mutations
- **Highlight**: New paradigm for form submissions
- **Interview Topic**: Benefits over traditional API routes

## Chapter 11: SEO Optimization

### 11.1 Metadata API (App Router)
- Static metadata
- Dynamic metadata (generateMetadata)
- Metadata hierarchy
- **Important**: Proper Open Graph tags

### 11.2 Head Component (Pages Router)
- next/head usage
- Title and meta tags
- Canonical URLs
- **Highlight**: Per-page SEO customization

### 11.3 Structured Data
- JSON-LD implementation
- Schema.org markup
- Rich snippets
- **Production**: Validate with Google Rich Results Test

### 11.4 Sitemap and Robots
- Generating sitemaps
- robots.txt configuration
- Dynamic sitemap generation
- **Critical**: Keep sitemaps updated

### 11.5 Internationalization (i18n)
- Locale detection
- Content translation
- URL structure for i18n
- next-intl library
- **Production**: Implement proper hreflang tags

## Chapter 12: Testing

### 12.1 Unit Testing
- Jest configuration
- Testing utilities
- Mocking Next.js features
- **Standard**: Jest + React Testing Library

### 12.2 Integration Testing
- Testing API routes
- Database interactions
- **Important**: Test database setup

### 12.3 E2E Testing
- Playwright setup
- Cypress integration
- Testing user flows
- **Production**: Run E2E tests in CI/CD

### 12.4 Testing Best Practices
- Test coverage targets
- CI/CD integration
- Snapshot testing
- **Highlight**: Test behavior, not implementation

## Chapter 13: Deployment and DevOps

### 13.1 Vercel Deployment
- Git integration
- Environment variables
- Preview deployments
- Production deployments
- **Highlight**: Zero-config deployment

### 13.2 Self-Hosting
- Standalone mode
- Docker containerization
- Node.js server
- **Important**: output: 'standalone' in next.config.js

### 13.3 Static Export
- Static HTML export
- Limitations of static export
- When to use static export
- **Note**: Some features unavailable (ISR, API routes)

### 13.4 Edge Deployment
- Edge runtime
- Edge functions
- Middleware on Edge
- **Critical**: Limitations of Edge runtime

### 13.5 CI/CD Pipeline
- GitHub Actions
- GitLab CI
- Automated testing
- **Production**: Implement proper staging environment

### 13.6 Monitoring and Logging
- Error tracking (Sentry)
- Performance monitoring
- Log aggregation
- **Critical**: Real User Monitoring (RUM)

## Chapter 14: Advanced Patterns

### 14.1 Monorepo Setup
- Turborepo integration
- Shared packages
- **Production**: Scaling to multiple apps

### 14.2 Micro-Frontend Architecture
- Module federation
- Shared components
- Independent deployments
- **Interview**: When to use micro-frontends

### 14.3 Advanced Caching
- React cache() function
- Request deduplication
- Segment-level caching
- **Important**: Cache invalidation strategies

### 14.4 Optimistic Updates
- Client-side optimistic UI
- Rollback strategies
- **Highlight**: Improves perceived performance

### 14.5 Real-time Features
- WebSocket integration
- Server-Sent Events (SSE)
- Polling vs real-time
- **Production**: Consider Pusher, Ably, or Socket.io

## Chapter 15: Next.js Configuration

### 15.1 next.config.js Deep Dive
- Webpack customization
- Environment variables
- Redirects and rewrites
- Headers configuration
- **Important**: Understand all configuration options

### 15.2 Custom Server
- Express integration
- Custom routing logic
- **Note**: Loses some Next.js optimizations

### 15.3 Environment Variables
- .env.local, .env.production
- NEXT_PUBLIC_ prefix
- Build-time vs runtime variables
- **Critical**: Security implications

### 15.4 TypeScript Configuration
- Strict mode
- Path aliases
- Type checking
- **Production Standard**: Always use TypeScript

## Chapter 16: Performance Monitoring

### 16.1 Built-in Analytics
- Next.js Speed Insights
- Web Vitals reporting
- **Highlight**: Vercel Analytics integration

### 16.2 Custom Metrics
- Performance marks
- User timing API
- Custom reporting
- **Production**: Track business-critical metrics

### 16.3 Lighthouse and PageSpeed
- Running audits
- Improving scores
- Continuous monitoring
- **Important**: Mobile vs desktop performance

## Chapter 17: Common Patterns and Anti-Patterns

### 17.1 Design Patterns
- Compound components
- Render props
- Higher-order components (HOCs)
- Custom hooks
- **Interview Focus**: When to use each pattern

### 17.2 Anti-Patterns to Avoid
- Fetching data in useEffect when SSR is available
- Not using Image component
- Blocking the main thread
- Over-fetching data
- **Critical**: Learn from common mistakes

### 17.3 Code Organization
- Feature-based structure
- Shared components
- Utility functions
- **Production**: Consistent folder structure

## Chapter 18: Interview Preparation Topics

### 18.1 Core Concepts Questions
- Explain SSR, SSG, ISR differences
- Server Components vs Client Components
- Hydration process
- Routing mechanisms
- **Practice**: Be able to draw diagrams

### 18.2 Performance Questions
- How to optimize images
- Code splitting strategies
- Reducing bundle size
- Core Web Vitals optimization
- **Critical**: Understand trade-offs

### 18.3 Architecture Questions
- When to use Next.js vs other frameworks
- Scaling strategies
- State management choices
- Authentication approaches
- **Interview**: Justify architectural decisions

### 18.4 Practical Coding Challenges
- Build a page with SSR
- Implement dynamic routing
- Create an API route
- Optimize component performance
- **Practice**: Code without looking at docs

### 18.5 Production Scenario Questions
- Handling high traffic
- Debugging production issues
- SEO optimization
- Security considerations
- **Important**: Real-world problem-solving

## Chapter 19: Ecosystem and Libraries

### 19.1 Essential Libraries
- UI: Radix UI, shadcn/ui, Material-UI
- Forms: React Hook Form, Formik
- Validation: Zod, Yup
- State: Redux Toolkit, Zustand, Jotai
- Data fetching: React Query, SWR
- **Production**: Know when to use each

### 19.2 Development Tools
- ESLint and Prettier
- Husky for git hooks
- lint-staged
- **Standard**: Enforce code quality

### 19.3 Testing Libraries
- Jest, React Testing Library
- Playwright, Cypress
- MSW for API mocking
- **Production**: Comprehensive test coverage

## Chapter 20: Advanced Production Topics

### 20.1 Multi-tenancy
- Subdomain routing
- Data isolation
- Configuration per tenant
- **Enterprise**: Common in SaaS applications

### 20.2 Feature Flags
- Implementation strategies
- Gradual rollouts
- A/B testing
- **Production**: Control feature releases

### 20.3 Rate Limiting and Throttling
- API rate limiting
- DDoS protection
- Request throttling
- **Critical**: Protect your backend

### 20.4 Internationalization at Scale
- Multi-language support
- RTL languages
- Date/time localization
- Currency formatting
- **Production**: Full i18n implementation

### 20.5 Analytics and Tracking
- Google Analytics 4
- Custom event tracking
- Conversion tracking
- **Important**: Privacy compliance (GDPR)

### 20.6 Error Boundaries and Recovery
- Error boundary implementation
- Graceful degradation
- Fallback UIs
- **Production**: Never show white screen

### 20.7 Accessibility (a11y)
- ARIA attributes
- Keyboard navigation
- Screen reader support
- Color contrast
- **Critical**: WCAG compliance

---

## Interview Success Tips

### Technical Deep Dive Areas
1. **Rendering**: Master all rendering strategies and when to use each
2. **Performance**: Understand optimization techniques deeply
3. **Architecture**: Be able to design scalable Next.js applications
4. **Security**: Know authentication, authorization, and common vulnerabilities

### Practical Skills to Demonstrate
- Build a full-stack app with authentication
- Implement proper error handling
- Optimize for Core Web Vitals
- Write comprehensive tests
- Deploy to production

### Key Differentiators for Hard Interviews
- Deep understanding of React Server Components
- Experience with monorepos and scaling
- Production debugging experience
- Performance monitoring and optimization
- Micro-frontend architecture knowledge

### Resources for Practice
- Build real projects, not tutorials
- Contribute to open-source Next.js projects
- Read Next.js source code
- Follow Next.js RFCs and discussions
- Practice system design with Next.js

---

## Production Checklist

✅ TypeScript configured  
✅ ESLint and Prettier setup  
✅ Environment variables secured  
✅ Error tracking (Sentry)  
✅ Performance monitoring  
✅ SEO optimization complete  
✅ Accessibility audit passed  
✅ Security headers configured  
✅ Rate limiting implemented  
✅ Comprehensive test coverage  
✅ CI/CD pipeline configured  
✅ Monitoring and alerting setup  
✅ Documentation updated  
✅ Core Web Vitals optimized  

