# Chapter 1: Next.js Fundamentals - Deep Dive

## 1.1 Introduction to Next.js

### What is Next.js?

Next.js is a **React framework** built by Vercel that provides a structured, opinionated way to build full-stack web applications. It extends React with powerful features that solve common problems in production applications.

### Core Philosophy

Next.js follows these principles:
- **Zero Configuration**: Works out of the box with sensible defaults
- **Hybrid Rendering**: Choose the best rendering strategy per page
- **File-System Based**: Routes are created automatically from files
- **Full-Stack**: Backend and frontend in one framework

### React vs Next.js Comparison

```javascript
// REACT (Create React App)
// ‚ùå Client-Side Rendering only
// ‚ùå Poor SEO out of the box
// ‚ùå No built-in routing
// ‚ùå Manual code splitting
// ‚ùå No backend API

function App() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    // Data fetched on client - slower, bad for SEO
    fetch('/api/data')
      .then(res => res.json())
      .then(setData);
  }, []);
  
  return <div>{data?.title}</div>;
}

// NEXT.JS
// ‚úÖ Multiple rendering options (SSR, SSG, ISR)
// ‚úÖ SEO optimized by default
// ‚úÖ Built-in file-based routing
// ‚úÖ Automatic code splitting
// ‚úÖ API routes included

// Server-rendered page with data
export async function getServerSideProps() {
  // Data fetched on server - faster, better SEO
  const data = await fetch('https://api.example.com/data').then(r => r.json());
  return { props: { data } };
}

export default function Page({ data }) {
  return <div>{data.title}</div>;
}
```

### Next.js Features Overview

#### 1. **Server-Side Rendering (SSR)**
Pages are rendered on the server for each request, then sent as HTML to the client.

```javascript
// pages/product/[id].js
export async function getServerSideProps(context) {
  const { id } = context.params;
  
  const product = await fetchProduct(id);
  
  return {
    props: { product } // Passed to component as props
  };
}

export default function Product({ product }) {
  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
    </div>
  );
}
```

**When to use**: User-specific content, real-time data, authentication required

#### 2. **Static Site Generation (SSG)**
Pages are pre-rendered at build time and reused for each request.

```javascript
// pages/blog/[slug].js
export async function getStaticProps({ params }) {
  const post = await fetchBlogPost(params.slug);
  
  return {
    props: { post },
    revalidate: 3600 // Regenerate every hour (ISR)
  };
}

export async function getStaticPaths() {
  const posts = await fetchAllPosts();
  
  return {
    paths: posts.map(post => ({ params: { slug: post.slug } })),
    fallback: 'blocking' // Handle unknown paths
  };
}

export default function BlogPost({ post }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
    </article>
  );
}
```

**When to use**: Blogs, documentation, marketing pages, any content that doesn't change often

#### 3. **Incremental Static Regeneration (ISR)**
Combines SSG with revalidation - static pages that update periodically.

```javascript
export async function getStaticProps() {
  const data = await fetch('https://api.example.com/stats').then(r => r.json());
  
  return {
    props: { data },
    revalidate: 60 // Regenerate at most every 60 seconds
  };
}
```

#### 4. **API Routes**
Build backend APIs within your Next.js app.

```javascript
// pages/api/user.js
export default async function handler(req, res) {
  if (req.method === 'POST') {
    const { email, password } = req.body;
    
    // Authenticate user
    const user = await authenticateUser(email, password);
    
    if (user) {
      return res.status(200).json({ user });
    }
    
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  res.status(405).json({ error: 'Method not allowed' });
}
```

#### 5. **File-Based Routing**
Create pages by adding files to the `pages` directory.

```
pages/
‚îú‚îÄ‚îÄ index.js           ‚Üí /
‚îú‚îÄ‚îÄ about.js          ‚Üí /about
‚îú‚îÄ‚îÄ blog/
‚îÇ   ‚îú‚îÄ‚îÄ index.js      ‚Üí /blog
‚îÇ   ‚îî‚îÄ‚îÄ [slug].js     ‚Üí /blog/:slug
‚îî‚îÄ‚îÄ api/
    ‚îî‚îÄ‚îÄ hello.js      ‚Üí /api/hello
```

### When to Use Next.js vs Create React App

| Scenario | Use Next.js | Use Create React App |
|----------|------------|---------------------|
| SEO is critical | ‚úÖ Yes | ‚ùå No |
| Need backend API | ‚úÖ Yes | ‚ùå No |
| Building a blog/documentation | ‚úÖ Yes | ‚ùå No |
| E-commerce site | ‚úÖ Yes | ‚ùå No |
| Admin dashboard (internal) | ‚ö†Ô∏è Maybe | ‚úÖ Yes |
| Simple SPA with no SEO needs | ‚ö†Ô∏è Maybe | ‚úÖ Yes |
| Learning React basics | ‚ùå No | ‚úÖ Yes |

### üî• Important: Next.js 13+ App Router vs Pages Router

Next.js has two routing systems:

**Pages Router (Legacy, but still widely used)**
```
pages/
‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ about.js
‚îî‚îÄ‚îÄ blog/
    ‚îî‚îÄ‚îÄ [slug].js
```

**App Router (New, recommended for new projects)**
```
app/
‚îú‚îÄ‚îÄ page.js
‚îú‚îÄ‚îÄ layout.js
‚îú‚îÄ‚îÄ about/
‚îÇ   ‚îî‚îÄ‚îÄ page.js
‚îî‚îÄ‚îÄ blog/
    ‚îî‚îÄ‚îÄ [slug]/
        ‚îî‚îÄ‚îÄ page.js
```

**Key Differences:**

| Feature | Pages Router | App Router |
|---------|-------------|-----------|
| React Version | Any | 18+ required |
| Components | Client by default | Server by default |
| Layouts | Manual with _app.js | Built-in nested layouts |
| Loading States | Manual | loading.js |
| Error Handling | Manual | error.js |
| Data Fetching | getServerSideProps, getStaticProps | async components |

---

## 1.2 Environment Setup

### Prerequisites

1. **Node.js**: Version 18.17 or later
```bash
node --version  # Should be v18.17+
npm --version
```

2. **Package Manager**: npm, yarn, or pnpm
```bash
# Using npm (comes with Node.js)
npm --version

# Or install yarn
npm install -g yarn

# Or install pnpm
npm install -g pnpm
```

### Creating a Next.js Project

#### Method 1: Automatic Setup (Recommended)

```bash
# Using npx (comes with npm)
npx create-next-app@latest my-app

# Using yarn
yarn create next-app my-app

# Using pnpm
pnpm create next-app my-app
```

**Interactive Prompts:**
```
‚úî Would you like to use TypeScript? ‚Ä¶ No / Yes
‚úî Would you like to use ESLint? ‚Ä¶ No / Yes
‚úî Would you like to use Tailwind CSS? ‚Ä¶ No / Yes
‚úî Would you like to use `src/` directory? ‚Ä¶ No / Yes
‚úî Would you like to use App Router? (recommended) ‚Ä¶ No / Yes
‚úî Would you like to customize the default import alias (@/*)? ‚Ä¶ No / Yes
```

**Recommended Answers for Production:**
- TypeScript: **Yes** ‚úÖ
- ESLint: **Yes** ‚úÖ
- Tailwind CSS: **Yes** ‚úÖ (or your preferred styling)
- src/ directory: **Yes** ‚úÖ (cleaner structure)
- App Router: **Yes** ‚úÖ (future of Next.js)
- Import alias: **No** (default @/* is fine)

#### Method 2: Manual Setup

```bash
mkdir my-app
cd my-app
npm init -y
npm install next@latest react@latest react-dom@latest
```

Update `package.json`:
```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  }
}
```

### Project Structure Explained

```
my-app/
‚îú‚îÄ‚îÄ node_modules/          # Dependencies
‚îú‚îÄ‚îÄ public/                # Static assets (images, fonts)
‚îÇ   ‚îú‚îÄ‚îÄ favicon.ico
‚îÇ   ‚îî‚îÄ‚îÄ images/
‚îú‚îÄ‚îÄ src/                   # Source code (optional but recommended)
‚îÇ   ‚îú‚îÄ‚îÄ app/              # App Router (Next.js 13+)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx    # Root layout
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx      # Home page
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ globals.css   # Global styles
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api/          # API routes
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts
‚îÇ   ‚îú‚îÄ‚îÄ components/       # Reusable components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Header.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Footer.tsx
‚îÇ   ‚îú‚îÄ‚îÄ lib/              # Utility functions
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.ts
‚îÇ   ‚îî‚îÄ‚îÄ styles/           # Additional styles
‚îú‚îÄ‚îÄ .env.local            # Environment variables (git-ignored)
‚îú‚îÄ‚îÄ .eslintrc.json        # ESLint configuration
‚îú‚îÄ‚îÄ .gitignore            # Git ignore rules
‚îú‚îÄ‚îÄ next.config.js        # Next.js configuration
‚îú‚îÄ‚îÄ package.json          # Dependencies and scripts
‚îú‚îÄ‚îÄ tsconfig.json         # TypeScript configuration
‚îî‚îÄ‚îÄ README.md
```

### Configuration Files Deep Dive

#### 1. `next.config.js` - Next.js Configuration

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  // React strict mode for better development
  reactStrictMode: true,
  
  // Image optimization domains
  images: {
    domains: ['example.com', 'cdn.example.com'],
    // Or use remotePatterns (more secure)
    remotePatterns: [
      {
        protocol: 'https',
        hostname: '**.example.com',
      },
    ],
  },
  
  // Custom webpack config
  webpack: (config, { isServer }) => {
    // Custom webpack rules
    return config;
  },
  
  // Environment variables exposed to browser
  env: {
    CUSTOM_KEY: 'value',
  },
  
  // Redirects
  async redirects() {
    return [
      {
        source: '/old-page',
        destination: '/new-page',
        permanent: true, // 308 redirect
      },
    ];
  },
  
  // Rewrites (URL masking)
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: 'https://api.example.com/:path*',
      },
    ];
  },
  
  // Headers
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'X-DNS-Prefetch-Control',
            value: 'on'
          },
        ],
      },
    ];
  },
};

module.exports = nextConfig;
```

#### 2. `tsconfig.json` - TypeScript Configuration

```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]  // Import alias
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

**üî• Highlight: TypeScript Setup is Production Standard**

Using TypeScript provides:
- **Type Safety**: Catch errors before runtime
- **Better IDE Support**: Autocomplete and IntelliSense
- **Self-Documentation**: Types serve as inline documentation
- **Refactoring Confidence**: Rename and refactor safely

```typescript
// Without TypeScript - potential runtime errors
function getUserName(user) {
  return user.name; // What if user is null?
}

// With TypeScript - caught at compile time
interface User {
  id: number;
  name: string;
  email: string;
}

function getUserName(user: User | null): string {
  return user?.name ?? 'Guest'; // Safe access
}
```

### Running Your Next.js App

```bash
# Development mode (hot reload, source maps)
npm run dev
# Opens at http://localhost:3000

# Production build
npm run build
# Creates optimized build in .next/

# Production server
npm run start
# Runs the built app

# Linting
npm run lint
```

### Development Mode Features

When running `npm run dev`:
- **Fast Refresh**: React components update without losing state
- **Error Overlay**: Detailed error messages in browser
- **Source Maps**: Debug with original source code
- **Auto Port Selection**: Uses 3001 if 3000 is busy

---

## 1.3 File-Based Routing Basics

### How File-Based Routing Works

Next.js automatically creates routes based on the file structure in the `pages` directory (Pages Router) or `app` directory (App Router).

### Pages Directory Structure (Pages Router)

```
pages/
‚îú‚îÄ‚îÄ index.js                    ‚Üí /
‚îú‚îÄ‚îÄ about.js                    ‚Üí /about
‚îú‚îÄ‚îÄ contact.js                  ‚Üí /contact
‚îú‚îÄ‚îÄ blog/
‚îÇ   ‚îú‚îÄ‚îÄ index.js               ‚Üí /blog
‚îÇ   ‚îú‚îÄ‚îÄ [slug].js              ‚Üí /blog/:slug (dynamic)
‚îÇ   ‚îî‚îÄ‚îÄ [year]/
‚îÇ       ‚îî‚îÄ‚îÄ [month]/
‚îÇ           ‚îî‚îÄ‚îÄ [day].js       ‚Üí /blog/:year/:month/:day
‚îú‚îÄ‚îÄ products/
‚îÇ   ‚îú‚îÄ‚îÄ index.js               ‚Üí /products
‚îÇ   ‚îú‚îÄ‚îÄ [id].js                ‚Üí /products/:id
‚îÇ   ‚îî‚îÄ‚îÄ [...slug].js           ‚Üí /products/* (catch-all)
‚îî‚îÄ‚îÄ api/
    ‚îî‚îÄ‚îÄ hello.js               ‚Üí /api/hello (API route)
```

### 1. Simple Static Routes

```javascript
// pages/about.js
export default function About() {
  return (
    <div>
      <h1>About Us</h1>
      <p>This is the about page</p>
    </div>
  );
}
// Accessible at: /about
```

### 2. Index Routes

Index files map to the root of their directory:

```javascript
// pages/index.js ‚Üí /
// pages/blog/index.js ‚Üí /blog
// pages/products/index.js ‚Üí /products

// pages/blog/index.js
export default function BlogHome() {
  return (
    <div>
      <h1>Blog Home</h1>
      <ul>
        <li>Post 1</li>
        <li>Post 2</li>
      </ul>
    </div>
  );
}
```

### 3. Dynamic Routes

Use square brackets `[param]` for dynamic segments:

```javascript
// pages/blog/[slug].js
import { useRouter } from 'next/router';

export default function BlogPost() {
  const router = useRouter();
  const { slug } = router.query; // Get dynamic parameter
  
  return (
    <div>
      <h1>Blog Post: {slug}</h1>
      <p>You are viewing: /blog/{slug}</p>
    </div>
  );
}

// URLs:
// /blog/hello-world ‚Üí slug = "hello-world"
// /blog/nextjs-tutorial ‚Üí slug = "nextjs-tutorial"
```

**With Data Fetching:**

```javascript
// pages/product/[id].js
export async function getServerSideProps(context) {
  const { id } = context.params;
  
  // Fetch product data
  const res = await fetch(`https://api.example.com/products/${id}`);
  const product = await res.json();
  
  return {
    props: { product }
  };
}

export default function Product({ product }) {
  return (
    <div>
      <h1>{product.name}</h1>
      <p>Price: ${product.price}</p>
      <p>{product.description}</p>
    </div>
  );
}
```

### 4. Nested Dynamic Routes

```javascript
// pages/shop/[category]/[productId].js
import { useRouter } from 'next/router';

export default function Product() {
  const router = useRouter();
  const { category, productId } = router.query;
  
  return (
    <div>
      <h1>Product: {productId}</h1>
      <p>Category: {category}</p>
    </div>
  );
}

// URLs:
// /shop/electronics/123 ‚Üí category="electronics", productId="123"
// /shop/clothing/456 ‚Üí category="clothing", productId="456"
```

### 5. Catch-All Routes

Use `[...param]` to catch all subsequent segments:

```javascript
// pages/docs/[...slug].js
import { useRouter } from 'next/router';

export default function Docs() {
  const router = useRouter();
  const { slug } = router.query;
  
  // slug is an array
  console.log(slug);
  
  return (
    <div>
      <h1>Documentation</h1>
      <p>Path: {slug?.join('/')}</p>
    </div>
  );
}

// URLs:
// /docs/a ‚Üí slug = ["a"]
// /docs/a/b ‚Üí slug = ["a", "b"]
// /docs/a/b/c ‚Üí slug = ["a", "b", "c"]
```

### 6. Optional Catch-All Routes

Use `[[...param]]` to make catch-all optional:

```javascript
// pages/blog/[[...slug]].js
export default function Blog({ slug }) {
  if (!slug) {
    // Matches /blog
    return <h1>Blog Home</h1>;
  }
  
  // Matches /blog/a, /blog/a/b, etc.
  return <h1>Post: {slug.join('/')}</h1>;
}

// URLs:
// /blog ‚Üí slug = undefined
// /blog/2023 ‚Üí slug = ["2023"]
// /blog/2023/12/post ‚Üí slug = ["2023", "12", "post"]
```

### üî• Important: Route Matching Priority

When multiple routes could match a URL, Next.js follows this priority:

1. **Predefined routes** (static files)
2. **Dynamic routes**
3. **Catch-all routes**

```
pages/
‚îú‚îÄ‚îÄ blog/index.js              # Priority 1: /blog
‚îú‚îÄ‚îÄ blog/popular.js            # Priority 1: /blog/popular
‚îú‚îÄ‚îÄ blog/[slug].js             # Priority 2: /blog/:slug
‚îî‚îÄ‚îÄ blog/[...all].js           # Priority 3: /blog/*

URL: /blog/popular
‚úÖ Matches: blog/popular.js (static - highest priority)
‚ùå Skips: blog/[slug].js (dynamic - lower priority)

URL: /blog/my-post
‚ùå Skips: blog/popular.js (doesn't match)
‚úÖ Matches: blog/[slug].js (dynamic)

URL: /blog/2023/12/25
‚ùå Skips: All above
‚úÖ Matches: blog/[...all].js (catch-all)
```

### Linking Between Pages

```javascript
import Link from 'next/link';

export default function Navigation() {
  return (
    <nav>
      {/* Simple link */}
      <Link href="/about">About</Link>
      
      {/* Dynamic link */}
      <Link href="/blog/my-first-post">
        My First Post
      </Link>
      
      {/* Dynamic link with object */}
      <Link href={{
        pathname: '/blog/[slug]',
        query: { slug: 'my-first-post' }
      }}>
        My First Post
      </Link>
      
      {/* With additional props */}
      <Link 
        href="/dashboard" 
        prefetch={false}  // Disable prefetching
        replace            // Replace history instead of push
      >
        Dashboard
      </Link>
    </nav>
  );
}
```

### Programmatic Navigation

```javascript
import { useRouter } from 'next/router';

export default function MyComponent() {
  const router = useRouter();
  
  const handleNavigation = () => {
    // Simple navigation
    router.push('/about');
    
    // With query parameters
    router.push({
      pathname: '/search',
      query: { q: 'nextjs' }
    });
    
    // Replace (no history entry)
    router.replace('/login');
    
    // Go back
    router.back();
    
    // Reload current route
    router.reload();
  };
  
  return <button onClick={handleNavigation}>Navigate</button>;
}
```

### Summary: File-Based Routing

‚úÖ **Advantages:**
- Intuitive and easy to understand
- No need to configure routes manually
- Automatic code splitting per route
- Consistent and predictable

‚ö†Ô∏è **Things to Remember:**
- File names determine URLs
- Can't have dynamic route conflicts
- Priority matters for overlapping routes
- Special files: `_app.js`, `_document.js` don't create routes

---

## Key Takeaways from Chapter 1

1. **Next.js extends React** with SSR, SSG, ISR, routing, and API routes
2. **TypeScript is highly recommended** for production applications
3. **File-based routing** is automatic and intuitive
4. **App Router is the future** - use it for new projects
5. **Dynamic routes use square brackets** - `[param]` for dynamic, `[...param]` for catch-all
6. **Configuration is minimal** but powerful when needed

## Practice Exercises

1. Create a new Next.js project with TypeScript and App Router
2. Build a simple blog with:
   - Home page listing posts
   - Individual post pages using dynamic routes
   - About page
3. Add navigation between pages using the Link component
4. Experiment with catch-all routes for a docs section

## Next: Chapter 2 - App Router

In the next chapter, we'll dive deep into the App Router, React Server Components, and the new paradigms introduced in Next.js 13+.