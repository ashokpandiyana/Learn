# Chapter 17: Common Patterns and Anti-Patterns - Deep Dive

## 17.1 Design Patterns

### Compound Components Pattern

Create components that work together seamlessly with shared state.

```typescript
// components/Tabs/context.tsx
'use client';

import { createContext, useContext, useState } from 'react';

type TabsContextType = {
  activeTab: string;
  setActiveTab: (tab: string) => void;
};

const TabsContext = createContext<TabsContextType | undefined>(undefined);

export function useTabs() {
  const context = useContext(TabsContext);
  if (!context) {
    throw new Error('Tabs components must be used within Tabs');
  }
  return context;
}

// Main Tabs component
export function Tabs({ 
  children, 
  defaultTab 
}: { 
  children: React.ReactNode; 
  defaultTab: string;
}) {
  const [activeTab, setActiveTab] = useState(defaultTab);

  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  );
}

// Tab List component
export function TabList({ children }: { children: React.ReactNode }) {
  return <div className="tab-list">{children}</div>;
}

// Tab component
export function Tab({ 
  value, 
  children 
}: { 
  value: string; 
  children: React.ReactNode;
}) {
  const { activeTab, setActiveTab } = useTabs();
  
  return (
    <button
      className={`tab ${activeTab === value ? 'active' : ''}`}
      onClick={() => setActiveTab(value)}
    >
      {children}
    </button>
  );
}

// Tab Panel component
export function TabPanel({ 
  value, 
  children 
}: { 
  value: string; 
  children: React.ReactNode;
}) {
  const { activeTab } = useTabs();
  
  if (activeTab !== value) return null;
  
  return <div className="tab-panel">{children}</div>;
}
```

```typescript
// Usage
import { Tabs, TabList, Tab, TabPanel } from '@/components/Tabs';

export default function Page() {
  return (
    <Tabs defaultTab="profile">
      <TabList>
        <Tab value="profile">Profile</Tab>
        <Tab value="settings">Settings</Tab>
        <Tab value="notifications">Notifications</Tab>
      </TabList>

      <TabPanel value="profile">
        <h2>Profile Content</h2>
      </TabPanel>

      <TabPanel value="settings">
        <h2>Settings Content</h2>
      </TabPanel>

      <TabPanel value="notifications">
        <h2>Notifications Content</h2>
      </TabPanel>
    </Tabs>
  );
}
```

### Render Props Pattern

Share code between components using a prop whose value is a function.

```typescript
// components/DataFetcher.tsx
'use client';

import { useState, useEffect } from 'react';

type DataFetcherProps<T> = {
  url: string;
  render: (data: T | null, loading: boolean, error: Error | null) => React.ReactNode;
};

export function DataFetcher<T>({ url, render }: DataFetcherProps<T>) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(data => {
        setData(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err);
        setLoading(false);
      });
  }, [url]);

  return <>{render(data, loading, error)}</>;
}
```

```typescript
// Usage
import { DataFetcher } from '@/components/DataFetcher';

type User = {
  id: number;
  name: string;
  email: string;
};

export default function UserProfile() {
  return (
    <DataFetcher<User>
      url="/api/user"
      render={(user, loading, error) => {
        if (loading) return <div>Loading...</div>;
        if (error) return <div>Error: {error.message}</div>;
        if (!user) return <div>No user found</div>;

        return (
          <div>
            <h1>{user.name}</h1>
            <p>{user.email}</p>
          </div>
        );
      }}
    />
  );
}
```

### Higher-Order Components (HOCs)

Wrap components to add additional functionality.

```typescript
// lib/withAuth.tsx
import { redirect } from 'next/navigation';
import { getServerSession } from 'next-auth';

export function withAuth<P extends object>(
  Component: React.ComponentType<P>,
  options?: { roles?: string[] }
) {
  return async function AuthenticatedComponent(props: P) {
    const session = await getServerSession();

    if (!session) {
      redirect('/login');
    }

    // Role-based access control
    if (options?.roles && !options.roles.includes(session.user.role)) {
      redirect('/unauthorized');
    }

    return <Component {...props} session={session} />;
  };
}
```

```typescript
// app/dashboard/page.tsx
import { withAuth } from '@/lib/withAuth';

async function DashboardPage({ session }: { session: any }) {
  return (
    <div>
      <h1>Welcome, {session.user.name}</h1>
    </div>
  );
}

export default withAuth(DashboardPage, { roles: ['admin', 'user'] });
```

### Custom Hooks Pattern

Extract reusable logic into custom hooks.

```typescript
// hooks/useLocalStorage.ts
'use client';

import { useState, useEffect } from 'react';

export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((val: T) => T)) => void] {
  // State to store our value
  const [storedValue, setStoredValue] = useState<T>(() => {
    if (typeof window === 'undefined') {
      return initialValue;
    }
    
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  // Return a wrapped version of useState's setter function that
  // persists the new value to localStorage
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      // Allow value to be a function so we have same API as useState
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      
      setStoredValue(valueToStore);
      
      if (typeof window !== 'undefined') {
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue];
}
```

```typescript
// hooks/useDebounce.ts
'use client';

import { useState, useEffect } from 'react';

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
```

```typescript
// hooks/useFetch.ts
'use client';

import { useState, useEffect } from 'react';

export function useFetch<T>(url: string) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    let cancelled = false;

    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        const json = await response.json();
        
        if (!cancelled) {
          setData(json);
          setError(null);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err as Error);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };

    fetchData();

    return () => {
      cancelled = true;
    };
  }, [url]);

  return { data, loading, error };
}
```

```typescript
// Usage of custom hooks
'use client';

import { useLocalStorage } from '@/hooks/useLocalStorage';
import { useDebounce } from '@/hooks/useDebounce';
import { useFetch } from '@/hooks/useFetch';

export function SearchComponent() {
  const [search, setSearch] = useLocalStorage('search', '');
  const debouncedSearch = useDebounce(search, 500);
  const { data, loading, error } = useFetch(
    `/api/search?q=${debouncedSearch}`
  );

  return (
    <div>
      <input
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="Search..."
      />
      
      {loading && <div>Searching...</div>}
      {error && <div>Error: {error.message}</div>}
      {data && <div>{JSON.stringify(data)}</div>}
    </div>
  );
}
```

---

## 17.2 Anti-Patterns to Avoid

### ❌ Anti-Pattern 1: Fetching Data in useEffect When SSR is Available

**Bad:**
```typescript
'use client';

import { useState, useEffect } from 'react';

export default function ProductsPage() {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch('/api/products')
      .then(res => res.json())
      .then(data => {
        setProducts(data);
        setLoading(false);
      });
  }, []);

  if (loading) return <div>Loading...</div>;

  return (
    <div>
      {products.map(product => (
        <div key={product.id}>{product.name}</div>
      ))}
    </div>
  );
}
```

**Good:**
```typescript
// Server Component (no 'use client')
export default async function ProductsPage() {
  const products = await fetch('/api/products').then(r => r.json());

  return (
    <div>
      {products.map(product => (
        <div key={product.id}>{product.name}</div>
      ))}
    </div>
  );
}
```

**Why:** Server-side data fetching provides:
- Better SEO
- Faster initial page load
- No loading spinners
- Reduced client bundle size

---

### ❌ Anti-Pattern 2: Not Using the Image Component

**Bad:**
```typescript
export default function Hero() {
  return (
    <img 
      src="/hero.jpg" 
      alt="Hero image"
      style={{ width: '100%' }}
    />
  );
}
```

**Good:**
```typescript
import Image from 'next/image';

export default function Hero() {
  return (
    <Image
      src="/hero.jpg"
      alt="Hero image"
      width={1200}
      height={600}
      priority
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,..."
    />
  );
}
```

**Why:** next/image provides:
- Automatic image optimization
- WebP/AVIF format conversion
- Lazy loading by default
- Prevention of Cumulative Layout Shift
- Responsive images

---

### ❌ Anti-Pattern 3: Blocking the Main Thread

**Bad:**
```typescript
'use client';

export function SearchResults({ query }: { query: string }) {
  // Expensive computation on every render
  const results = expensiveSearch(query); // Takes 500ms!

  return (
    <div>
      {results.map(result => (
        <div key={result.id}>{result.name}</div>
      ))}
    </div>
  );
}

function expensiveSearch(query: string) {
  let results = [];
  // Synchronous expensive operation
  for (let i = 0; i < 1000000; i++) {
    // Heavy computation
  }
  return results;
}
```

**Good:**
```typescript
'use client';

import { useMemo, useTransition } from 'react';

export function SearchResults({ query }: { query: string }) {
  // Memoize expensive computation
  const results = useMemo(
    () => expensiveSearch(query),
    [query]
  );

  return (
    <div>
      {results.map(result => (
        <div key={result.id}>{result.name}</div>
      ))}
    </div>
  );
}

// Or use Web Workers
export function SearchResultsWithWorker({ query }: { query: string }) {
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();

  useEffect(() => {
    const worker = new Worker('/search-worker.js');
    
    worker.postMessage({ query });
    
    worker.onmessage = (e) => {
      startTransition(() => {
        setResults(e.data);
      });
    };

    return () => worker.terminate();
  }, [query]);

  return (
    <div>
      {isPending && <div>Searching...</div>}
      {results.map(result => (
        <div key={result.id}>{result.name}</div>
      ))}
    </div>
  );
}
```

---

### ❌ Anti-Pattern 4: Over-Fetching Data

**Bad:**
```typescript
// Fetching all user data when only name is needed
export default async function UserGreeting() {
  const user = await fetch('/api/user/complete-profile').then(r => r.json());
  // user contains: id, name, email, address, preferences, orders, etc.

  return <div>Hello, {user.name}!</div>;
}
```

**Good:**
```typescript
// Fetch only what you need
export default async function UserGreeting() {
  const user = await fetch('/api/user/name').then(r => r.json());
  // user contains only: { name: string }

  return <div>Hello, {user.name}!</div>;
}

// Or use GraphQL for precise data fetching
export default async function UserGreeting() {
  const user = await graphqlClient.request(gql`
    query {
      user {
        name
      }
    }
  `);

  return <div>Hello, {user.name}!</div>;
}
```

---

### ❌ Anti-Pattern 5: Improper Error Handling

**Bad:**
```typescript
export default async function ProductPage({ params }: { params: { id: string } }) {
  const product = await fetch(`/api/products/${params.id}`).then(r => r.json());
  // What if the fetch fails? User sees white screen!

  return <div>{product.name}</div>;
}
```

**Good:**
```typescript
// app/products/[id]/page.tsx
export default async function ProductPage({ params }: { params: { id: string } }) {
  let product;
  
  try {
    const response = await fetch(`/api/products/${params.id}`);
    
    if (!response.ok) {
      throw new Error('Failed to fetch product');
    }
    
    product = await response.json();
  } catch (error) {
    // Next.js will catch this and render error.tsx
    throw error;
  }

  return <div>{product.name}</div>;
}

// app/products/[id]/error.tsx
'use client';

export default function Error({
  error,
  reset,
}: {
  error: Error;
  reset: () => void;
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <p>{error.message}</p>
      <button onClick={reset}>Try again</button>
    </div>
  );
}
```

---

### ❌ Anti-Pattern 6: Not Implementing Loading States

**Bad:**
```typescript
export default async function DashboardPage() {
  const data = await fetchDashboardData(); // Takes 3 seconds
  
  return <DashboardContent data={data} />;
}
```

**Good:**
```typescript
// app/dashboard/page.tsx
import { Suspense } from 'react';
import { DashboardSkeleton } from './skeleton';

export default function DashboardPage() {
  return (
    <Suspense fallback={<DashboardSkeleton />}>
      <DashboardContent />
    </Suspense>
  );
}

async function DashboardContent() {
  const data = await fetchDashboardData();
  
  return <div>{/* Dashboard UI */}</div>;
}

// app/dashboard/loading.tsx
export default function Loading() {
  return <DashboardSkeleton />;
}
```

---

### ❌ Anti-Pattern 7: Creating New Functions in Render

**Bad:**
```typescript
'use client';

export function TodoList({ todos }: { todos: Todo[] }) {
  return (
    <div>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          // New function created on every render!
          onToggle={() => toggleTodo(todo.id)}
        />
      ))}
    </div>
  );
}
```

**Good:**
```typescript
'use client';

import { useCallback } from 'react';

export function TodoList({ todos }: { todos: Todo[] }) {
  const handleToggle = useCallback((id: string) => {
    toggleTodo(id);
  }, []);

  return (
    <div>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={handleToggle}
        />
      ))}
    </div>
  );
}

// Or use a separate component
function TodoItem({ todo, onToggle }: { todo: Todo; onToggle: (id: string) => void }) {
  return (
    <div onClick={() => onToggle(todo.id)}>
      {todo.text}
    </div>
  );
}
```

---

## 17.3 Code Organization

### Feature-Based Structure

```
src/
├── app/
│   ├── (auth)/
│   │   ├── login/
│   │   │   └── page.tsx
│   │   └── register/
│   │       └── page.tsx
│   ├── (dashboard)/
│   │   ├── dashboard/
│   │   │   └── page.tsx
│   │   └── settings/
│   │       └── page.tsx
│   └── layout.tsx
├── features/
│   ├── auth/
│   │   ├── components/
│   │   │   ├── LoginForm.tsx
│   │   │   └── RegisterForm.tsx
│   │   ├── hooks/
│   │   │   └── useAuth.ts
│   │   ├── api/
│   │   │   └── authService.ts
│   │   └── types.ts
│   ├── products/
│   │   ├── components/
│   │   │   ├── ProductCard.tsx
│   │   │   └── ProductList.tsx
│   │   ├── hooks/
│   │   │   └── useProducts.ts
│   │   ├── api/
│   │   │   └── productsService.ts
│   │   └── types.ts
│   └── cart/
│       ├── components/
│       ├── hooks/
│       ├── api/
│       └── types.ts
├── shared/
│   ├── components/
│   │   ├── Button.tsx
│   │   ├── Input.tsx
│   │   └── Modal.tsx
│   ├── hooks/
│   │   ├── useLocalStorage.ts
│   │   └── useDebounce.ts
│   ├── utils/
│   │   ├── formatDate.ts
│   │   └── validation.ts
│   └── types/
│       └── common.ts
└── lib/
    ├── db.ts
    ├── api.ts
    └── constants.ts
```

### Shared Components Library

```typescript
// shared/components/Button/Button.tsx
import { forwardRef } from 'react';
import { cva, type VariantProps } from 'class-variance-authority';

const buttonVariants = cva(
  'inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors',
  {
    variants: {
      variant: {
        primary: 'bg-blue-600 text-white hover:bg-blue-700',
        secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300',
        destructive: 'bg-red-600 text-white hover:bg-red-700',
        ghost: 'hover:bg-gray-100',
      },
      size: {
        sm: 'h-9 px-3',
        md: 'h-10 px-4',
        lg: 'h-11 px-8',
      },
    },
    defaultVariants: {
      variant: 'primary',
      size: 'md',
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  loading?: boolean;
}

export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, loading, children, ...props }, ref) => {
    return (
      <button
        ref={ref}
        className={buttonVariants({ variant, size, className })}
        disabled={loading || props.disabled}
        {...props}
      >
        {loading ? 'Loading...' : children}
      </button>
    );
  }
);

Button.displayName = 'Button';
```

```typescript
// shared/components/Button/index.ts
export { Button } from './Button';
export type { ButtonProps } from './Button';
```

### Utility Functions Organization

```typescript
// shared/utils/date.ts
export function formatDate(date: Date | string, format: string = 'short'): string {
  const d = new Date(date);
  
  switch (format) {
    case 'short':
      return d.toLocaleDateString();
    case 'long':
      return d.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      });
    case 'time':
      return d.toLocaleTimeString();
    default:
      return d.toISOString();
  }
}

export function getRelativeTime(date: Date | string): string {
  const d = new Date(date);
  const now = new Date();
  const diff = now.getTime() - d.getTime();
  
  const seconds = Math.floor(diff / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  
  if (days > 0) return `${days}d ago`;
  if (hours > 0) return `${hours}h ago`;
  if (minutes > 0) return `${minutes}m ago`;
  return 'Just now';
}
```

```typescript
// shared/utils/validation.ts
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

export function isValidUrl(url: string): boolean {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

export function validatePassword(password: string): {
  isValid: boolean;
  errors: string[];
} {
  const errors: string[] = [];
  
  if (password.length < 8) {
    errors.push('Password must be at least 8 characters');
  }
  if (!/[A-Z]/.test(password)) {
    errors.push('Password must contain at least one uppercase letter');
  }
  if (!/[a-z]/.test(password)) {
    errors.push('Password must contain at least one lowercase letter');
  }
  if (!/[0-9]/.test(password)) {
    errors.push('Password must contain at least one number');
  }
  
  return {
    isValid: errors.length === 0,
    errors,
  };
}
```

### Type Definitions Organization

```typescript
// shared/types/api.ts
export type ApiResponse<T> = {
  data: T;
  error: null;
  status: number;
} | {
  data: null;
  error: string;
  status: number;
};

export type PaginatedResponse<T> = {
  data: T[];
  pagination: {
    page: number;
    pageSize: number;
    total: number;
    totalPages: number;
  };
};
```

```typescript
// features/products/types.ts
export interface Product {
  id: string;
  name: string;
  description: string;
  price: number;
  imageUrl: string;
  category: string;
  stock: number;
  createdAt: string;
  updatedAt: string;
}

export type ProductFormData = Omit<Product, 'id' | 'createdAt' | 'updatedAt'>;

export type ProductFilters = {
  category?: string;
  minPrice?: number;
  maxPrice?: number;
  inStock?: boolean;
};
```

This comprehensive chapter covers essential patterns, common mistakes to avoid, and best practices for organizing your Next.js codebase!