# Chapter 20: Advanced Production Topics - In Depth

## 20.1 Multi-tenancy Implementation

### Complete Multi-tenant Architecture

**Database Schema (Prisma):**

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Tenant {
  id          String   @id @default(cuid())
  name        String
  subdomain   String   @unique
  customDomain String? @unique
  status      TenantStatus @default(ACTIVE)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Tenant-specific settings
  settings    TenantSettings?
  users       User[]
  products    Product[]
  
  @@index([subdomain])
  @@index([customDomain])
}

enum TenantStatus {
  ACTIVE
  SUSPENDED
  TRIAL
}

model TenantSettings {
  id            String  @id @default(cuid())
  tenantId      String  @unique
  tenant        Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  primaryColor  String  @default("#0070f3")
  logo          String?
  maxUsers      Int     @default(10)
  features      Json    @default("{}")
}

model User {
  id        String   @id @default(cuid())
  email     String
  name      String?
  role      UserRole @default(USER)
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([email, tenantId])
  @@index([tenantId])
}

enum UserRole {
  ADMIN
  USER
  GUEST
}

model Product {
  id          String   @id @default(cuid())
  name        String
  price       Float
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([tenantId])
}
```

**Middleware for Tenant Detection:**

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { getTenantByHost } from '@/lib/tenant-utils';

export async function middleware(request: NextRequest) {
  const hostname = request.headers.get('host') || '';
  const url = request.nextUrl;

  // Skip middleware for API routes and static files
  if (
    url.pathname.startsWith('/api') ||
    url.pathname.startsWith('/_next') ||
    url.pathname.startsWith('/static')
  ) {
    return NextResponse.next();
  }

  // Extract subdomain or custom domain
  const subdomain = hostname.split('.')[0];
  
  // Check if it's a custom domain
  let tenant;
  if (!hostname.includes('localhost') && !hostname.includes('yourdomain.com')) {
    // Custom domain
    tenant = await getTenantByHost(hostname);
  } else {
    // Subdomain
    tenant = await getTenantByHost(subdomain);
  }

  if (!tenant) {
    // Redirect to main site or show 404
    return NextResponse.redirect(new URL('/not-found', request.url));
  }

  // Check tenant status
  if (tenant.status === 'SUSPENDED') {
    return NextResponse.redirect(new URL('/suspended', request.url));
  }

  // Add tenant info to headers
  const requestHeaders = new Headers(request.headers);
  requestHeaders.set('x-tenant-id', tenant.id);
  requestHeaders.set('x-tenant-name', tenant.name);

  return NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  });
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
};
```

**Tenant Context Provider:**

```typescript
// lib/tenant-context.ts
import { headers } from 'next/headers';
import { cache } from 'react';
import { db } from './db';

export type Tenant = {
  id: string;
  name: string;
  subdomain: string;
  customDomain: string | null;
  settings: {
    primaryColor: string;
    logo: string | null;
    maxUsers: number;
    features: Record<string, boolean>;
  } | null;
};

export const getTenant = cache(async (): Promise<Tenant> => {
  const headersList = headers();
  const tenantId = headersList.get('x-tenant-id');

  if (!tenantId) {
    throw new Error('Tenant not found');
  }

  const tenant = await db.tenant.findUnique({
    where: { id: tenantId },
    include: { settings: true },
  });

  if (!tenant) {
    throw new Error('Tenant not found');
  }

  return tenant as Tenant;
});

// Tenant-scoped database queries
export const getTenantDb = cache(async () => {
  const tenant = await getTenant();

  return db.$extends({
    query: {
      // Auto-filter all models by tenantId
      $allModels: {
        async findMany({ args, query }) {
          args.where = { ...args.where, tenantId: tenant.id };
          return query(args);
        },
        async findFirst({ args, query }) {
          args.where = { ...args.where, tenantId: tenant.id };
          return query(args);
        },
        async findUnique({ args, query }) {
          args.where = { ...args.where, tenantId: tenant.id };
          return query(args);
        },
        async create({ args, query }) {
          args.data = { ...args.data, tenantId: tenant.id };
          return query(args);
        },
        async createMany({ args, query }) {
          if (Array.isArray(args.data)) {
            args.data = args.data.map(item => ({ ...item, tenantId: tenant.id }));
          }
          return query(args);
        },
        async update({ args, query }) {
          args.where = { ...args.where, tenantId: tenant.id };
          return query(args);
        },
        async updateMany({ args, query }) {
          args.where = { ...args.where, tenantId: tenant.id };
          return query(args);
        },
        async delete({ args, query }) {
          args.where = { ...args.where, tenantId: tenant.id };
          return query(args);
        },
        async deleteMany({ args, query }) {
          args.where = { ...args.where, tenantId: tenant.id };
          return query(args);
        },
      },
    },
  });
});
```

**Usage in Components:**

```tsx
// app/products/page.tsx
import { getTenant, getTenantDb } from '@/lib/tenant-context';

export default async function ProductsPage() {
  const tenant = await getTenant();
  const db = await getTenantDb();

  // Automatically filtered by tenant
  const products = await db.product.findMany({
    orderBy: { createdAt: 'desc' },
  });

  return (
    <div>
      <h1>{tenant.name} - Products</h1>
      <div style={{ color: tenant.settings?.primaryColor }}>
        {products.map(product => (
          <div key={product.id}>
            <h2>{product.name}</h2>
            <p>${product.price}</p>
          </div>
        ))}
      </div>
    </div>
  );
}
```

---

## 20.2 Feature Flags System

```typescript
// lib/feature-flags.ts
import { getTenant } from './tenant-context';
import { cache } from 'react';

export type FeatureFlag = 
  | 'analytics'
  | 'advanced_reporting'
  | 'api_access'
  | 'custom_branding'
  | 'unlimited_users'
  | 'priority_support';

type FeatureFlagConfig = {
  [key in FeatureFlag]: {
    enabled: boolean;
    description: string;
    plans: string[];
  };
};

const FEATURE_FLAGS: FeatureFlagConfig = {
  analytics: {
    enabled: true,
    description: 'Advanced analytics dashboard',
    plans: ['pro', 'enterprise'],
  },
  advanced_reporting: {
    enabled: true,
    description: 'Custom reports and exports',
    plans: ['enterprise'],
  },
  api_access: {
    enabled: true,
    description: 'RESTful API access',
    plans: ['pro', 'enterprise'],
  },
  custom_branding: {
    enabled: true,
    description: 'Custom logo and colors',
    plans: ['pro', 'enterprise'],
  },
  unlimited_users: {
    enabled: true,
    description: 'No limit on user accounts',
    plans: ['enterprise'],
  },
  priority_support: {
    enabled: true,
    description: '24/7 priority support',
    plans: ['enterprise'],
  },
};

export const checkFeatureFlag = cache(async (feature: FeatureFlag): Promise<boolean> => {
  const tenant = await getTenant();
  const flagConfig = FEATURE_FLAGS[feature];

  if (!flagConfig.enabled) return false;

  // Check tenant-specific overrides
  const tenantFeatures = tenant.settings?.features as Record<string, boolean> | undefined;
  if (tenantFeatures && feature in tenantFeatures) {
    return tenantFeatures[feature];
  }

  // Default: check against tenant's plan
  // This assumes you have a plan field on tenant
  return flagConfig.plans.includes('pro'); // Replace with actual plan check
});

// Hook version for client components
export function useFeatureFlag(feature: FeatureFlag) {
  const [isEnabled, setIsEnabled] = useState(false);

  useEffect(() => {
    checkFeatureFlag(feature).then(setIsEnabled);
  }, [feature]);

  return isEnabled;
}
```

**Feature Flag Component:**

```tsx
// components/FeatureGate.tsx
import { checkFeatureFlag, type FeatureFlag } from '@/lib/feature-flags';

type FeatureGateProps = {
  feature: FeatureFlag;
  children: React.ReactNode;
  fallback?: React.ReactNode;
};

export async function FeatureGate({ 
  feature, 
  children, 
  fallback = null 
}: FeatureGateProps) {
  const isEnabled = await checkFeatureFlag(feature);

  if (!isEnabled) {
    return <>{fallback}</>;
  }

  return <>{children}</>;
}

// Usage
export default function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      
      <FeatureGate 
        feature="analytics"
        fallback={<div>Upgrade to Pro for Analytics</div>}
      >
        <AnalyticsDashboard />
      </FeatureGate>
    </div>
  );
}
```

---

## 20.3 Rate Limiting & Throttling

```typescript
// lib/rate-limiter.ts
import { Redis } from '@upstash/redis';
import { Ratelimit } from '@upstash/ratelimit';

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});

// Different rate limiters for different use cases
export const apiRateLimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, '10 s'), // 10 requests per 10 seconds
  analytics: true,
  prefix: '@api',
});

export const authRateLimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(5, '1 h'), // 5 attempts per hour
  analytics: true,
  prefix: '@auth',
});

export const heavyOperationRateLimit = new Ratelimit({
  redis,
  limiter: Ratelimit.fixedWindow(3, '1 m'), // 3 operations per minute
  analytics: true,
  prefix: '@heavy',
});
```

**API Route with Rate Limiting:**

```typescript
// app/api/data/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { apiRateLimit } from '@/lib/rate-limiter';
import { headers } from 'next/headers';

export async function GET(request: NextRequest) {
  // Get identifier (IP or user ID)
  const headersList = headers();
  const forwarded = headersList.get('x-forwarded-for');
  const ip = forwarded?.split(',')[0] ?? 'unknown';

  // Check rate limit
  const { success, limit, remaining, reset } = await apiRateLimit.limit(ip);

  if (!success) {
    return NextResponse.json(
      { error: 'Too many requests' },
      {
        status: 429,
        headers: {
          'X-RateLimit-Limit': limit.toString(),
          'X-RateLimit-Remaining': remaining.toString(),
          'X-RateLimit-Reset': reset.toString(),
        },
      }
    );
  }

  // Process request
  const data = await fetchData();

  return NextResponse.json(data, {
    headers: {
      'X-RateLimit-Limit': limit.toString(),
      'X-RateLimit-Remaining': remaining.toString(),
      'X-RateLimit-Reset': reset.toString(),
    },
  });
}
```

**Middleware Rate Limiting:**

```typescript
// middleware.ts - Add rate limiting
import { apiRateLimit } from '@/lib/rate-limiter';

export async function middleware(request: NextRequest) {
  // Rate limit API routes
  if (request.nextUrl.pathname.startsWith('/api')) {
    const ip = request.ip ?? 'unknown';
    const { success } = await apiRateLimit.limit(ip);

    if (!success) {
      return new NextResponse('Too Many Requests', { status: 429 });
    }
  }

  return NextResponse.next();
}
```

---

## 20.4 Internationalization (i18n) at Scale

**Setup with next-intl:**

```bash
npm install next-intl
```

```typescript
// i18n.ts
import { getRequestConfig } from 'next-intl/server';
import { headers } from 'next/headers';

const locales = ['en', 'es', 'fr', 'de', 'ja', 'zh'];

export default getRequestConfig(async () => {
  // Get locale from header (set by middleware)
  const headersList = headers();
  const locale = headersList.get('x-locale') || 'en';

  return {
    locale,
    messages: (await import(`./messages/${locale}.json`)).default,
  };
});
```

```typescript
// middleware.ts - Locale detection
import { NextRequest, NextResponse } from 'next/server';
import Negotiator from 'negotiator';
import { match } from '@formatjs/intl-localematcher';

const locales = ['en', 'es', 'fr', 'de', 'ja', 'zh'];
const defaultLocale = 'en';

function getLocale(request: NextRequest): string {
  // Check URL parameter
  const urlLocale = request.nextUrl.pathname.split('/')[1];
  if (locales.includes(urlLocale)) {
    return urlLocale;
  }

  // Check cookie
  const localeCookie = request.cookies.get('NEXT_LOCALE')?.value;
  if (localeCookie && locales.includes(localeCookie)) {
    return localeCookie;
  }

  // Check Accept-Language header
  const negotiatorHeaders: Record<string, string> = {};
  request.headers.forEach((value, key) => (negotiatorHeaders[key] = value));

  const languages = new Negotiator({ headers: negotiatorHeaders }).languages();
  return match(languages, locales, defaultLocale);
}

export function middleware(request: NextRequest) {
  const locale = getLocale(request);
  const response = NextResponse.next();

  // Set locale in header for use in app
  response.headers.set('x-locale', locale);

  // Set locale cookie
  response.cookies.set('NEXT_LOCALE', locale, {
    maxAge: 60 * 60 * 24 * 365, // 1 year
  });

  return response;
}
```

**Translation Files:**

```json
// messages/en.json
{
  "HomePage": {
    "title": "Welcome to our platform",
    "description": "The best platform for your needs",
    "cta": "Get started"
  },
  "Navigation": {
    "home": "Home",
    "about": "About",
    "contact": "Contact",
    "login": "Log in"
  },
  "Products": {
    "title": "Our Products",
    "noProducts": "No products found",
    "addToCart": "Add to cart",
    "price": "Price: {price}"
  }
}
```

```json
// messages/es.json
{
  "HomePage": {
    "title": "Bienvenido a nuestra plataforma",
    "description": "La mejor plataforma para tus necesidades",
    "cta": "Comenzar"
  },
  "Navigation": {
    "home": "Inicio",
    "about": "Acerca de",
    "contact": "Contacto",
    "login": "Iniciar sesión"
  },
  "Products": {
    "title": "Nuestros Productos",
    "noProducts": "No se encontraron productos",
    "addToCart": "Añadir al carrito",
    "price": "Precio: {price}"
  }
}
```

**Usage in Components:**

```tsx
// app/[locale]/layout.tsx
import { NextIntlClientProvider } from 'next-intl';
import { getMessages } from 'next-intl/server';

export default async function LocaleLayout({
  children,
  params: { locale }
}: {
  children: React.ReactNode;
  params: { locale: string };
}) {
  const messages = await getMessages();

  return (
    <html lang={locale}>
      <body>
        <NextIntlClientProvider messages={messages}>
          {children}
        </NextIntlClientProvider>
      </body>
    </html>
  );
}
```

```tsx
// app/[locale]/page.tsx
import { useTranslations } from 'next-intl';

export default function HomePage() {
  const t = useTranslations('HomePage');

  return (
    <div>
      <h1>{t('title')}</h1>
      <p>{t('description')}</p>
      <button>{t('cta')}</button>
    </div>
  );
}
```

**Dynamic Values:**

```tsx
import { useTranslations } from 'next-intl';

export function ProductCard({ product }) {
  const t = useTranslations('Products');

  return (
    <div>
      <h2>{product.name}</h2>
      <p>{t('price', { price: product.price })}</p>
      <button>{t('addToCart')}</button>
    </div>
  );
}
```

---

## 20.5 Error Boundaries and Recovery

**Global Error Boundary:**

```tsx
// app/error.tsx
'use client';

import { useEffect } from 'react';
import { Button } from '@/components/ui/button';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    // Log error to error reporting service
    console.error('Application error:', error);
    
    // Send to Sentry, LogRocket, etc.
    if (typeof window !== 'undefined' && window.Sentry) {
      window.Sentry.captureException(error);
    }
  }, [error]);

  return (
    <div className="flex min-h-screen flex-col items-center justify-center">
      <div className="max-w-md text-center">
        <h2 className="text-2xl font-bold mb-4">Something went wrong!</h2>
        <p className="text-gray-600 mb-4">
          We're sorry for the inconvenience. Our team has been notified.
        </p>
        {error.digest && (
          <p className="text-sm text-gray-500 mb-4">
            Error ID: {error.digest}
          </p>
        )}
        <Button onClick={reset}>Try again</Button>
      </div>
    </div>
  );
}
```

**Route-Specific Error Boundary:**

```tsx
// app/dashboard/error.tsx
'use client';

export default function DashboardError({
  error,
  reset,
}: {
  error: Error;
  reset: () => void;
}) {
  return (
    <div className="p-4 bg-red-50 border border-red-200 rounded">
      <h3 className="text-red-800 font-semibold">Dashboard Error</h3>
      <p className="text-red-600">{error.message}</p>
      <button 
        onClick={reset}
        className="mt-2 bg-red-600 text-white px-4 py-2 rounded"
      >
        Reload Dashboard
      </button>
    </div>
  );
}
```

**React Error Boundary Component:**

```tsx
// components/ErrorBoundary.tsx
'use client';

import React, { Component, ReactNode } from 'react';

type Props = {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: React.ErrorInfo) => void;
};

type State = {
  hasError: boolean;
  error?: Error;
};

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('ErrorBoundary caught:', error, errorInfo);
    
    // Call custom error handler
    this.props.onError?.(error, errorInfo);
    
    // Send to error tracking service
    if (typeof window !== 'undefined' && window.Sentry) {
      window.Sentry.captureException(error, {
        contexts: { react: { componentStack: errorInfo.componentStack } },
      });
    }
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="p-4 bg-red-50 border border-red-200 rounded">
          <h3 className="text-red-800 font-semibold">
            Something went wrong
          </h3>
          <p className="text-red-600 text-sm mt-2">
            {this.state.error?.message}
          </p>
          <button
            onClick={() => this.setState({ hasError: false })}
            className="mt-3 bg-red-600 text-white px-4 py-2 rounded text-sm"
          >
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// Usage
export function ProtectedFeature() {
  return (
    <ErrorBoundary
      fallback={<div>This feature is temporarily unavailable</div>}
      onError={(error) => console.log('Feature error:', error)}
    >
      <ComplexFeature />
    </ErrorBoundary>
  );
}
```

---

## 20.6 Accessibility (a11y) Compliance

**Comprehensive Accessibility Checklist Implementation:**

```tsx
// components/AccessibleForm.tsx
'use client';

import { useState } from 'react';
import { useForm } from 'react-hook-form';

export function AccessibleForm() {
  const [submitStatus, setSubmitStatus] = useState<string>('');
  const { register, handleSubmit, formState: { errors } } = useForm();

  const onSubmit = async (data: any) => {
    // Announce submission to screen readers
    setSubmitStatus('Submitting form...');
    
    try {
      await fetch('/api/submit', {
        method: 'POST',
        body: JSON.stringify(data),
      });
      setSubmitStatus('Form submitted successfully!');
    } catch (error) {
      setSubmitStatus('Error submitting form. Please try again.');
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} noValidate>
      {/* Screen reader announcements */}
      <div
        role="status"
        aria-live="polite"
        aria-atomic="true"
        className="sr-only"
      >
        {submitStatus}
      </div>

      <fieldset>
        <legend className="text-lg font-semibold mb-4">
          Personal Information
        </legend>

        {/* Accessible input with error handling */}
        <div className="mb-4">
          <label
            htmlFor="name"
            className="block text-sm font-medium mb-2"
          >
            Full Name
            <span className="text-red-500" aria-label="required">*</span>
          </label>
          <input
            id="name"
            type="text"
            {...register('name', { required: 'Name is required' })}
            aria-required="true"
            aria-invalid={errors.name ? 'true' : 'false'}
            aria-describedby={errors.name ? 'name-error' : undefined}
            className={`border rounded px-3 py-2 w-full ${
              errors.name ? 'border-red-500' : 'border-gray-300'
            }`}
          />
          {errors.name && (
            <p
              id="name-error"
              role="alert"
              className="text-red-500 text-sm mt-1"
            >
              {errors.name.message as string}
            </p>
          )}
        </div>

        {/* Accessible select */}
        <div className="mb-4">
          <label
            htmlFor="country"
            className="block text-sm font-medium mb-2"
          >
            Country
          </label>
          <select
            id="country"
            {...register('country')}
            className="border border-gray-300 rounded px-3 py-2 w-full"
          >
            <option value="">Select a country</option>
            <option value="us">United States</option>
            <option value="uk">United Kingdom</option>
            <option value="ca">Canada</option>
          </select>
        </div>

        {/* Accessible checkbox group */}
        <fieldset className="mb-4">
          <legend className="text-sm font-medium mb-2">
            Preferences
          </legend>
          <div className="space-y-2">
            <label className="flex items-center">
              <input
                type="checkbox"
                {...register('newsletter')}
                className="mr-2"
              />
              <span>Subscribe to newsletter</span>
            </label>
            <label className="flex items-center">
              <input
                type="checkbox"
                {...register('updates')}
                className="mr-2"
              />
              <span>Receive product updates</span>
            </label>
          </div>
        </fieldset>

        <button
          type="submit"
          className="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
          aria-label="Submit registration form"
        >
          Submit
        </button>
      </fieldset>
    </form>
  );
}
```

**Keyboard Navigation Component:**

```tsx
// components/AccessibleModal.tsx
'use client';

import { useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';

type ModalProps = {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
};

export function AccessibleModal({ isOpen, onClose, title, children }: ModalProps) {
  const modalRef = useRef<HTMLDivElement>(null);
  const closeButtonRef = useRef<HTMLButtonElement>(null);
  const previousActiveElement = useRef<HTMLElement | null>(null);

  useEffect(() => {
    if (isOpen) {
      // Store currently focused element
      previousActiveElement.current = document.activeElement as HTMLElement;
      
      // Focus close button when modal opens
      closeButtonRef.current?.focus();
      
      // Trap focus within modal
      const handleKeyDown = (e: KeyboardEvent) => {
        if (e.key === 'Escape') {
          onClose();
        }

        if (e.key === 'Tab') {
          const focusableElements = modalRef.current?.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
          );
          
          if (!focusableElements || focusableElements.length === 0) return;

          const firstElement = focusableElements[0] as HTMLElement;
          const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;

          if (e.shiftKey && document.activeElement === firstElement) {
            e.preventDefault();
            lastElement.focus();
          } else if (!e.shiftKey && document.activeElement === lastElement) {
            e.preventDefault();
            firstElement.focus();
          }
        }
      };

      document.addEventListener('keydown', handleKeyDown);
      document.body.style.overflow = 'hidden';

      return () => {
        document.removeEventListener('keydown', handleKeyDown);
        document.body.style.overflow = '';
        
        // Restore focus to previous element
        previousActiveElement.current?.focus();
      };
    }
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  return createPortal(
    <>
      {/* Backdrop */}
      <div
        className="fixed inset-0 bg-black bg-opacity-50 z-40"
        onClick={onClose}
        aria-hidden="true"
      />

      {/* Modal */}
      <div
        ref={modalRef}
        role="dialog"
        aria-modal="true"
        aria-labelledby="modal-title"
        className="fixed inset-0 z-50 flex items-center justify-center p-4"
      >
        <div className="bg-white rounded-lg shadow-xl max-w-md w-full p-6">
          <div className="flex justify-between items-center mb-4">
            <h2 id="modal-title" className="text-xl font-semibold">
              {title}
            </h2>
            <button
              ref={closeButtonRef}
              onClick={onClose}
              className="text-gray-400 hover:text-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 rounded"
              aria-label="Close modal"
            >
              <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
          <div>{children}</div>
        </div>
      </div>
    </>,
    document.body
  );
}
```

**Skip Navigation Link:**

```tsx
// components/SkipLink.tsx
export function SkipLink() {
  return (
    <a
      href="#main-content"
      className="sr-only focus:not-sr-only focus:absolute focus:top-0 focus:left-0 focus:z-50 focus:p-4 focus:bg-blue-600 focus:text-white"
    >
      Skip to main content
    </a>
  );
}

// Usage in layout
export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <SkipLink />
        <nav>Navigation...</nav>
        <main id="main-content">{children}</main>
      </body>
    </html>
  );
}
```

**Screen Reader Only Class:**

```css
/* globals.css */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only:focus {
  position: static;
  width: auto;
  height: auto;
  padding: inherit;
  margin: inherit;
  overflow: visible;
  clip: auto;
  white-space: normal;
}
```

This chapter provides production-ready implementations for advanced topics that are crucial for enterprise-grade Next.js applications!