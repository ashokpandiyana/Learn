# Chapter 16: Performance Monitoring - Deep Dive

## 16.1 Built-in Analytics

### Next.js Speed Insights

Next.js provides built-in performance monitoring through Speed Insights.

```typescript
// app/layout.tsx
import { SpeedInsights } from '@vercel/speed-insights/next';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        {children}
        <SpeedInsights />
      </body>
    </html>
  );
}
```

### Web Vitals Reporting

```typescript
// app/layout.tsx
import { Analytics } from '@vercel/analytics/react';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        {children}
        <Analytics />
      </body>
    </html>
  );
}
```

### Custom Web Vitals Reporting

```typescript
// app/web-vitals.tsx
'use client';

import { useReportWebVitals } from 'next/web-vitals';

export function WebVitals() {
  useReportWebVitals((metric) => {
    console.log(metric);
    
    // Send to analytics
    switch (metric.name) {
      case 'FCP': // First Contentful Paint
      case 'LCP': // Largest Contentful Paint
      case 'CLS': // Cumulative Layout Shift
      case 'FID': // First Input Delay
      case 'TTFB': // Time to First Byte
      case 'INP': // Interaction to Next Paint
        // Send to your analytics service
        sendToAnalytics(metric);
        break;
      default:
        break;
    }
  });

  return null;
}

function sendToAnalytics(metric: any) {
  const body = JSON.stringify(metric);
  const url = '/api/analytics';

  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`
  if (navigator.sendBeacon) {
    navigator.sendBeacon(url, body);
  } else {
    fetch(url, {
      body,
      method: 'POST',
      keepalive: true,
    });
  }
}
```

```typescript
// app/layout.tsx
import { WebVitals } from './web-vitals';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <body>
        <WebVitals />
        {children}
      </body>
    </html>
  );
}
```

### Storing Metrics

```typescript
// app/api/analytics/route.ts
import { NextRequest } from 'next/server';

export async function POST(request: NextRequest) {
  const metric = await request.json();
  
  // Store in your database
  await db.webVitals.create({
    data: {
      name: metric.name,
      value: metric.value,
      rating: metric.rating,
      delta: metric.delta,
      id: metric.id,
      navigationType: metric.navigationType,
      page: metric.pathname,
      timestamp: new Date(),
    },
  });
  
  return new Response('OK', { status: 200 });
}
```

### Understanding Core Web Vitals

**LCP (Largest Contentful Paint) - Loading Performance**
- Measures: When the largest content element becomes visible
- Good: < 2.5s
- Needs Improvement: 2.5s - 4.0s
- Poor: > 4.0s

```typescript
// Optimizing LCP
export default function Page() {
  return (
    <div>
      {/* Priority load the LCP element */}
      <Image
        src="/hero.jpg"
        alt="Hero"
        width={1200}
        height={600}
        priority // This tells Next.js to preload this image
      />
    </div>
  );
}
```

**FID (First Input Delay) â†’ INP (Interaction to Next Paint)**
- Measures: Responsiveness to user interactions
- Good: < 200ms (INP < 200ms)
- Needs Improvement: 200ms - 500ms
- Poor: > 500ms

```typescript
// Optimizing INP
'use client';

import { useState, useTransition } from 'react';

export function InteractiveComponent() {
  const [isPending, startTransition] = useTransition();
  const [items, setItems] = useState([]);

  const handleClick = () => {
    // Wrap expensive updates in startTransition
    startTransition(() => {
      const newItems = expensiveCalculation();
      setItems(newItems);
    });
  };

  return (
    <button onClick={handleClick} disabled={isPending}>
      {isPending ? 'Loading...' : 'Update'}
    </button>
  );
}
```

**CLS (Cumulative Layout Shift) - Visual Stability**
- Measures: Unexpected layout shifts
- Good: < 0.1
- Needs Improvement: 0.1 - 0.25
- Poor: > 0.25

```typescript
// Preventing CLS
import Image from 'next/image';

export function ImageCard() {
  return (
    <div>
      {/* Always specify dimensions to prevent layout shift */}
      <Image
        src="/image.jpg"
        alt="Image"
        width={400}
        height={300}
        // Or use fill with aspect ratio
        // fill
        // style={{ aspectRatio: '4/3' }}
      />
    </div>
  );
}
```

---

## 16.2 Custom Metrics

### Performance Marks and Measures

```typescript
'use client';

import { useEffect } from 'react';

export function ComponentWithMetrics() {
  useEffect(() => {
    // Mark the start
    performance.mark('component-render-start');
    
    // Perform expensive operation
    expensiveOperation();
    
    // Mark the end
    performance.mark('component-render-end');
    
    // Measure the duration
    performance.measure(
      'component-render',
      'component-render-start',
      'component-render-end'
    );
    
    // Get the measurement
    const measure = performance.getEntriesByName('component-render')[0];
    console.log(`Component render took ${measure.duration}ms`);
    
    // Send to analytics
    sendMetricToAnalytics({
      name: 'component-render',
      duration: measure.duration,
    });
    
    // Cleanup
    return () => {
      performance.clearMarks('component-render-start');
      performance.clearMarks('component-render-end');
      performance.clearMeasures('component-render');
    };
  }, []);

  return <div>{/* ... */}</div>;
}
```

### Custom Performance Observer

```typescript
'use client';

import { useEffect } from 'react';

export function usePerformanceObserver() {
  useEffect(() => {
    // Observe long tasks (> 50ms)
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.duration > 50) {
          console.warn('Long task detected:', {
            name: entry.name,
            duration: entry.duration,
            startTime: entry.startTime,
          });
          
          // Send to analytics
          sendMetricToAnalytics({
            name: 'long-task',
            duration: entry.duration,
          });
        }
      }
    });

    observer.observe({ entryTypes: ['longtask'] });

    return () => observer.disconnect();
  }, []);
}
```

### Resource Timing

```typescript
'use client';

export function analyzeResourceTiming() {
  // Get all resource entries
  const resources = performance.getEntriesByType('resource');
  
  const analysis = {
    totalResources: resources.length,
    totalSize: 0,
    slowestResources: [] as any[],
    byType: {} as Record<string, number>,
  };
  
  resources.forEach((resource: any) => {
    const duration = resource.duration;
    const type = resource.initiatorType;
    
    // Track by type
    analysis.byType[type] = (analysis.byType[type] || 0) + 1;
    
    // Track slow resources (> 1s)
    if (duration > 1000) {
      analysis.slowestResources.push({
        name: resource.name,
        duration,
        type,
        size: resource.transferSize,
      });
    }
  });
  
  // Sort slowest resources
  analysis.slowestResources.sort((a, b) => b.duration - a.duration);
  
  console.log('Resource Analysis:', analysis);
  return analysis;
}
```

### Navigation Timing

```typescript
'use client';

export function analyzeNavigationTiming() {
  const [navigation] = performance.getEntriesByType('navigation') as PerformanceNavigationTiming[];
  
  if (!navigation) return null;
  
  const metrics = {
    // DNS lookup time
    dns: navigation.domainLookupEnd - navigation.domainLookupStart,
    
    // TCP connection time
    tcp: navigation.connectEnd - navigation.connectStart,
    
    // TLS negotiation time
    tls: navigation.secureConnectionStart > 0
      ? navigation.connectEnd - navigation.secureConnectionStart
      : 0,
    
    // Request time
    request: navigation.responseStart - navigation.requestStart,
    
    // Response time
    response: navigation.responseEnd - navigation.responseStart,
    
    // DOM processing
    domProcessing: navigation.domComplete - navigation.domInteractive,
    
    // Total page load
    totalPageLoad: navigation.loadEventEnd - navigation.fetchStart,
  };
  
  console.log('Navigation Metrics:', metrics);
  
  // Send to analytics
  Object.entries(metrics).forEach(([key, value]) => {
    sendMetricToAnalytics({
      name: `navigation-${key}`,
      value,
    });
  });
  
  return metrics;
}
```

### Business Metrics

```typescript
// lib/metrics.ts
class MetricsCollector {
  private metrics: Map<string, number[]> = new Map();

  record(name: string, value: number) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    this.metrics.get(name)!.push(value);
  }

  getStats(name: string) {
    const values = this.metrics.get(name) || [];
    if (values.length === 0) return null;

    const sorted = [...values].sort((a, b) => a - b);
    const sum = values.reduce((a, b) => a + b, 0);
    
    return {
      count: values.length,
      min: sorted[0],
      max: sorted[sorted.length - 1],
      avg: sum / values.length,
      median: sorted[Math.floor(sorted.length / 2)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)],
    };
  }

  flush() {
    const allStats = {} as Record<string, any>;
    
    for (const [name, _] of this.metrics) {
      allStats[name] = this.getStats(name);
    }
    
    // Send to analytics endpoint
    fetch('/api/metrics', {
      method: 'POST',
      body: JSON.stringify(allStats),
    });
    
    this.metrics.clear();
  }
}

export const metrics = new MetricsCollector();

// Usage
export async function trackApiCall<T>(
  name: string,
  fn: () => Promise<T>
): Promise<T> {
  const start = performance.now();
  
  try {
    const result = await fn();
    const duration = performance.now() - start;
    
    metrics.record(`api-${name}`, duration);
    
    return result;
  } catch (error) {
    metrics.record(`api-${name}-error`, 1);
    throw error;
  }
}
```

```typescript
// Usage in component
'use client';

import { metrics, trackApiCall } from '@/lib/metrics';

export function ProductList() {
  const fetchProducts = async () => {
    return trackApiCall('products', async () => {
      const response = await fetch('/api/products');
      return response.json();
    });
  };

  // Component tracks time to interactive
  useEffect(() => {
    performance.mark('product-list-interactive');
    const measure = performance.measure(
      'product-list-tti',
      'navigationStart',
      'product-list-interactive'
    );
    
    metrics.record('product-list-tti', measure.duration);
  }, []);

  return <div>{/* ... */}</div>;
}
```

---

## 16.3 Lighthouse and PageSpeed

### Running Lighthouse Programmatically

```javascript
// scripts/lighthouse.js
const lighthouse = require('lighthouse');
const chromeLauncher = require('chrome-launcher');
const fs = require('fs');

async function runLighthouse(url) {
  const chrome = await chromeLauncher.launch({ chromeFlags: ['--headless'] });
  
  const options = {
    logLevel: 'info',
    output: 'html',
    onlyCategories: ['performance', 'accessibility', 'best-practices', 'seo'],
    port: chrome.port,
  };
  
  const runnerResult = await lighthouse(url, options);
  
  // Extract scores
  const scores = {
    performance: runnerResult.lhr.categories.performance.score * 100,
    accessibility: runnerResult.lhr.categories.accessibility.score * 100,
    bestPractices: runnerResult.lhr.categories['best-practices'].score * 100,
    seo: runnerResult.lhr.categories.seo.score * 100,
  };
  
  console.log('Lighthouse Scores:', scores);
  
  // Save report
  fs.writeFileSync('lighthouse-report.html', runnerResult.report);
  
  await chrome.kill();
  
  return scores;
}

// Run for multiple pages
const pages = ['/', '/products', '/about'];

Promise.all(
  pages.map(page => runLighthouse(`http://localhost:3000${page}`))
).then(results => {
  console.log('All results:', results);
});
```

```json
// package.json
{
  "scripts": {
    "lighthouse": "node scripts/lighthouse.js",
    "lighthouse:ci": "lhci autorun"
  },
  "devDependencies": {
    "lighthouse": "^11.0.0",
    "chrome-launcher": "^0.15.0",
    "@lhci/cli": "^0.12.0"
  }
}
```

### Lighthouse CI Configuration

```javascript
// lighthouserc.js
module.exports = {
  ci: {
    collect: {
      startServerCommand: 'npm run start',
      startServerReadyPattern: 'ready on',
      url: [
        'http://localhost:3000/',
        'http://localhost:3000/products',
        'http://localhost:3000/about',
      ],
      numberOfRuns: 3, // Run 3 times and average
    },
    assert: {
      preset: 'lighthouse:recommended',
      assertions: {
        'categories:performance': ['error', { minScore: 0.9 }],
        'categories:accessibility': ['error', { minScore: 0.9 }],
        'categories:best-practices': ['error', { minScore: 0.9 }],
        'categories:seo': ['error', { minScore: 0.9 }],
        
        // Specific metrics
        'first-contentful-paint': ['error', { maxNumericValue: 2000 }],
        'largest-contentful-paint': ['error', { maxNumericValue: 2500 }],
        'cumulative-layout-shift': ['error', { maxNumericValue: 0.1 }],
        'total-blocking-time': ['error', { maxNumericValue: 300 }],
      },
    },
    upload: {
      target: 'temporary-public-storage',
    },
  },
};
```

### Performance Budget

```javascript
// budget.json
[
  {
    "path": "/*",
    "timings": [
      {
        "metric": "first-contentful-paint",
        "budget": 2000
      },
      {
        "metric": "largest-contentful-paint",
        "budget": 2500
      },
      {
        "metric": "cumulative-layout-shift",
        "budget": 0.1
      },
      {
        "metric": "total-blocking-time",
        "budget": 300
      },
      {
        "metric": "interactive",
        "budget": 3500
      }
    ],
    "resourceSizes": [
      {
        "resourceType": "script",
        "budget": 300
      },
      {
        "resourceType": "stylesheet",
        "budget": 50
      },
      {
        "resourceType": "image",
        "budget": 500
      },
      {
        "resourceType": "document",
        "budget": 100
      },
      {
        "resourceType": "font",
        "budget": 100
      },
      {
        "resourceType": "total",
        "budget": 1000
      }
    ],
    "resourceCounts": [
      {
        "resourceType": "script",
        "budget": 10
      },
      {
        "resourceType": "stylesheet",
        "budget": 5
      },
      {
        "resourceType": "third-party",
        "budget": 10
      }
    ]
  }
]
```

### CI/CD Integration

```yaml
# .github/workflows/lighthouse.yml
name: Lighthouse CI

on:
  pull_request:
    branches: [main]

jobs:
  lighthouse:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build
        run: npm run build
      
      - name: Run Lighthouse CI
        run: |
          npm install -g @lhci/cli
          lhci autorun
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}
```

### Monitoring Performance Over Time

```typescript
// lib/performance-tracker.ts
export class PerformanceTracker {
  private static instance: PerformanceTracker;
  private baseline: Map<string, number> = new Map();

  static getInstance() {
    if (!this.instance) {
      this.instance = new PerformanceTracker();
    }
    return this.instance;
  }

  setBaseline(metric: string, value: number) {
    this.baseline.set(metric, value);
  }

  compare(metric: string, currentValue: number) {
    const baselineValue = this.baseline.get(metric);
    
    if (!baselineValue) {
      return { status: 'no-baseline', value: currentValue };
    }

    const percentChange = ((currentValue - baselineValue) / baselineValue) * 100;
    
    let status: 'improved' | 'degraded' | 'stable';
    
    if (percentChange < -5) {
      status = 'improved';
    } else if (percentChange > 5) {
      status = 'degraded';
    } else {
      status = 'stable';
    }

    return {
      status,
      baseline: baselineValue,
      current: currentValue,
      change: percentChange,
    };
  }

  reportAll(currentMetrics: Record<string, number>) {
    const report = {} as Record<string, any>;
    
    for (const [metric, value] of Object.entries(currentMetrics)) {
      report[metric] = this.compare(metric, value);
    }
    
    return report;
  }
}

// Usage
const tracker = PerformanceTracker.getInstance();

// Set baselines (from previous build)
tracker.setBaseline('LCP', 2000);
tracker.setBaseline('FID', 50);
tracker.setBaseline('CLS', 0.05);

// Compare current metrics
const report = tracker.reportAll({
  LCP: 2100,  // Degraded
  FID: 45,    // Improved
  CLS: 0.05,  // Stable
});

console.log(report);
// {
//   LCP: { status: 'degraded', baseline: 2000, current: 2100, change: 5 },
//   FID: { status: 'improved', baseline: 50, current: 45, change: -10 },
//   CLS: { status: 'stable', baseline: 0.05, current: 0.05, change: 0 }
// }
```

### Real User Monitoring (RUM) Dashboard

```typescript
// app/api/rum/route.ts
import { NextRequest } from 'next/server';

export async function POST(request: NextRequest) {
  const metrics = await request.json();
  
  // Store in time-series database (e.g., TimescaleDB, InfluxDB)
  await db.rumMetrics.create({
    data: {
      url: metrics.url,
      userAgent: request.headers.get('user-agent'),
      country: request.geo?.country,
      metrics: {
        lcp: metrics.lcp,
        fid: metrics.fid,
        cls: metrics.cls,
        ttfb: metrics.ttfb,
        fcp: metrics.fcp,
      },
      timestamp: new Date(),
    },
  });
  
  return new Response('OK', { status: 200 });
}
```

```typescript
// app/dashboard/performance/page.tsx
export default async function PerformanceDashboard() {
  // Aggregate metrics from last 24 hours
  const metrics = await db.rumMetrics.aggregate({
    where: {
      timestamp: {
        gte: new Date(Date.now() - 24 * 60 * 60 * 1000),
      },
    },
    _avg: {
      metrics: {
        lcp: true,
        fid: true,
        cls: true,
      },
    },
    _p75: {
      metrics: {
        lcp: true,
        fid: true,
        cls: true,
      },
    },
  });
  
  return (
    <div>
      <h1>Performance Dashboard</h1>
      
      <MetricCard
        title="LCP"
        average={metrics._avg.metrics.lcp}
        p75={metrics._p75.metrics.lcp}
        threshold={2500}
      />
      
      <MetricCard
        title="FID"
        average={metrics._avg.metrics.fid}
        p75={metrics._p75.metrics.fid}
        threshold={100}
      />
      
      <MetricCard
        title="CLS"
        average={metrics._avg.metrics.cls}
        p75={metrics._p75.metrics.cls}
        threshold={0.1}
      />
    </div>
  );
}
```

This chapter provides comprehensive coverage of performance monitoring in Next.js, from built-in tools to custom implementations and CI/CD integration!