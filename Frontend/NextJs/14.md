# Chapter 14: Advanced Patterns - Deep Dive

## 14.1 Monorepo Setup

### What is a Monorepo?

A monorepo (monolithic repository) is a software development strategy where code for many projects is stored in a single repository. For Next.js applications, this allows you to share code, components, utilities, and types across multiple applications.

### Why Use Monorepos?

**Benefits:**
- **Code Sharing**: Share React components, utilities, types across multiple apps
- **Atomic Changes**: Make changes to shared code and see effects across all apps
- **Unified Dependencies**: Single version of dependencies across all projects
- **Easier Refactoring**: Refactor shared code with confidence
- **Consistent Tooling**: Shared ESLint, TypeScript, testing configs

**Use Cases:**
- Multiple customer-facing apps (web, mobile web, admin panel)
- Microservices with shared types
- Design system with multiple consumer apps
- Multi-tenant applications

### Turborepo Integration

Turborepo is the recommended tool for Next.js monorepos (created by Vercel).

#### Basic Structure

```
my-monorepo/
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ web/                 # Main Next.js app
â”‚   â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â””â”€â”€ next.config.js
â”‚   â”œâ”€â”€ admin/               # Admin dashboard Next.js app
â”‚   â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â””â”€â”€ next.config.js
â”‚   â””â”€â”€ docs/                # Documentation Next.js app
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ ui/                  # Shared UI components
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ Button.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Card.tsx
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â””â”€â”€ tsconfig.json
â”‚   â”œâ”€â”€ config/              # Shared configs
â”‚   â”‚   â”œâ”€â”€ eslint/
â”‚   â”‚   â””â”€â”€ typescript/
â”‚   â”œâ”€â”€ database/            # Database schema & client
â”‚   â”‚   â”œâ”€â”€ prisma/
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â””â”€â”€ utils/               # Shared utilities
â”‚       â”œâ”€â”€ src/
â”‚       â””â”€â”€ package.json
â”œâ”€â”€ package.json
â”œâ”€â”€ turbo.json
â””â”€â”€ pnpm-workspace.yaml
```

#### Setting Up Turborepo

```bash
# Create new turborepo
npx create-turbo@latest

# Or add to existing project
npm install turbo --save-dev
```

#### turbo.json Configuration

```json
{
  "$schema": "https://turbo.build/schema.json",
  "globalDependencies": ["**/.env.*local"],
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": [".next/**", "!.next/cache/**"]
    },
    "lint": {
      "dependsOn": ["^lint"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    },
    "test": {
      "dependsOn": ["^build"],
      "outputs": ["coverage/**"]
    }
  }
}
```

**Key Concepts:**

- `dependsOn`: Specifies task dependencies (`^build` means "dependencies' build tasks first")
- `outputs`: Files to cache for faster subsequent builds
- `cache`: Whether to cache task results
- `persistent`: For long-running tasks (like dev servers)

#### Workspace Configuration (pnpm)

```yaml
# pnpm-workspace.yaml
packages:
  - "apps/*"
  - "packages/*"
```

#### Root package.json

```json
{
  "name": "my-monorepo",
  "private": true,
  "scripts": {
    "dev": "turbo run dev",
    "build": "turbo run build",
    "lint": "turbo run lint",
    "test": "turbo run test",
    "clean": "turbo run clean && rm -rf node_modules"
  },
  "devDependencies": {
    "turbo": "latest",
    "prettier": "latest"
  },
  "packageManager": "pnpm@8.0.0"
}
```

#### Shared UI Package Example

```typescript
// packages/ui/src/Button.tsx
import * as React from 'react';

export interface ButtonProps {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary';
  onClick?: () => void;
}

export const Button: React.FC<ButtonProps> = ({ 
  children, 
  variant = 'primary',
  onClick 
}) => {
  return (
    <button
      className={`btn btn-${variant}`}
      onClick={onClick}
    >
      {children}
    </button>
  );
};
```

```json
// packages/ui/package.json
{
  "name": "@repo/ui",
  "version": "0.0.0",
  "private": true,
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "scripts": {
    "lint": "eslint . --max-warnings 0",
    "typecheck": "tsc --noEmit"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "typescript": "^5.0.0"
  },
  "peerDependencies": {
    "react": "^18.2.0"
  }
}
```

#### Using Shared Package in App

```json
// apps/web/package.json
{
  "name": "web",
  "dependencies": {
    "@repo/ui": "workspace:*",
    "@repo/utils": "workspace:*",
    "next": "14.0.0",
    "react": "^18.2.0"
  }
}
```

```typescript
// apps/web/app/page.tsx
import { Button } from '@repo/ui';
import { formatDate } from '@repo/utils';

export default function Home() {
  return (
    <div>
      <h1>Welcome to Web App</h1>
      <Button variant="primary" onClick={() => alert('Clicked!')}>
        Click Me
      </Button>
      <p>Today: {formatDate(new Date())}</p>
    </div>
  );
}
```

#### TypeScript Configuration

```json
// packages/config/typescript/base.json
{
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true
  },
  "exclude": ["node_modules"]
}
```

```json
// apps/web/tsconfig.json
{
  "extends": "@repo/typescript-config/nextjs.json",
  "compilerOptions": {
    "plugins": [{ "name": "next" }],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

### Benefits in Action

**Before Monorepo:**
```typescript
// Have to maintain Button in 3 places
// apps/web/components/Button.tsx
// apps/admin/components/Button.tsx
// apps/mobile/components/Button.tsx
```

**After Monorepo:**
```typescript
// Single source of truth
// packages/ui/src/Button.tsx

// Used everywhere:
import { Button } from '@repo/ui';
```

---

## 14.2 Micro-Frontend Architecture

### What are Micro-Frontends?

Micro-frontends extend microservices concept to frontend development. Each team builds and deploys independent frontend applications that are composed into a single user experience.

### When to Use Micro-Frontends

**Good Use Cases:**
- Large organizations with multiple teams
- Different tech stacks for different features
- Independent deployment requirements
- Domain-driven design
- Gradual migration from legacy apps

**Not Recommended For:**
- Small teams or projects
- High performance requirements (adds overhead)
- Simple applications
- When code sharing is primary goal (use monorepo instead)

### Module Federation in Next.js

Module Federation allows loading remote modules at runtime.

#### Setup with @module-federation/nextjs-mf

```bash
npm install @module-federation/nextjs-mf
```

#### Host Application (Main App)

```javascript
// apps/host/next.config.js
const { withModuleFederation } = require('@module-federation/nextjs-mf');

module.exports = withModuleFederation({
  name: 'host',
  remotes: {
    shop: 'shop@http://localhost:3001/_next/static/chunks/remoteEntry.js',
    checkout: 'checkout@http://localhost:3002/_next/static/chunks/remoteEntry.js',
  },
  shared: {
    react: { singleton: true, eager: true },
    'react-dom': { singleton: true, eager: true },
  },
});
```

```typescript
// apps/host/app/page.tsx
'use client';

import dynamic from 'next/dynamic';

const RemoteShopButton = dynamic(
  () => import('shop/Button'),
  { ssr: false }
);

const RemoteCheckout = dynamic(
  () => import('checkout/CheckoutFlow'),
  { ssr: false }
);

export default function Home() {
  return (
    <div>
      <h1>Host Application</h1>
      <RemoteShopButton />
      <RemoteCheckout />
    </div>
  );
}
```

#### Remote Application (Shop)

```javascript
// apps/shop/next.config.js
const { withModuleFederation } = require('@module-federation/nextjs-mf');

module.exports = withModuleFederation({
  name: 'shop',
  filename: 'static/chunks/remoteEntry.js',
  exposes: {
    './Button': './components/Button',
    './ProductList': './components/ProductList',
  },
  shared: {
    react: { singleton: true, eager: true },
    'react-dom': { singleton: true, eager: true },
  },
});
```

```typescript
// apps/shop/components/Button.tsx
export default function Button({ children, onClick }: any) {
  return (
    <button 
      onClick={onClick}
      className="shop-button"
    >
      {children} (From Shop App)
    </button>
  );
}
```

### Alternative: iFrame-Based Micro-Frontends

Simpler but with limitations.

```typescript
// apps/host/app/page.tsx
export default function DashboardPage() {
  return (
    <div className="dashboard-layout">
      <nav>Main Navigation</nav>
      
      <div className="content">
        {/* Analytics micro-frontend */}
        <iframe 
          src="https://analytics.example.com/widget"
          width="100%"
          height="400"
          sandbox="allow-scripts allow-same-origin"
        />
        
        {/* Reports micro-frontend */}
        <iframe 
          src="https://reports.example.com/widget"
          width="100%"
          height="400"
          sandbox="allow-scripts allow-same-origin"
        />
      </div>
    </div>
  );
}
```

**Pros:**
- Complete isolation
- Different frameworks possible
- Simple implementation

**Cons:**
- Performance overhead
- Complex communication (postMessage)
- SEO challenges
- Difficult styling coordination

### Micro-Frontend Communication

```typescript
// Shared event bus
// packages/shared/src/eventBus.ts
type EventCallback = (data: any) => void;

class EventBus {
  private events: Map<string, EventCallback[]> = new Map();

  subscribe(event: string, callback: EventCallback) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event)!.push(callback);
  }

  publish(event: string, data: any) {
    const callbacks = this.events.get(event) || [];
    callbacks.forEach(callback => callback(data));
  }

  unsubscribe(event: string, callback: EventCallback) {
    const callbacks = this.events.get(event) || [];
    const index = callbacks.indexOf(callback);
    if (index > -1) {
      callbacks.splice(index, 1);
    }
  }
}

export const eventBus = new EventBus();
```

```typescript
// In one micro-frontend
import { eventBus } from '@shared/eventBus';

// Publish
eventBus.publish('user:login', { userId: 123, name: 'John' });

// In another micro-frontend
import { eventBus } from '@shared/eventBus';

// Subscribe
useEffect(() => {
  const handleUserLogin = (data: any) => {
    console.log('User logged in:', data);
  };
  
  eventBus.subscribe('user:login', handleUserLogin);
  
  return () => {
    eventBus.unsubscribe('user:login', handleUserLogin);
  };
}, []);
```

---

## 14.3 Advanced Caching

### Understanding Next.js Caching Layers

Next.js has multiple caching layers:

1. **Request Memoization** (React-level)
2. **Data Cache** (Server-side, persistent)
3. **Full Route Cache** (Build-time)
4. **Router Cache** (Client-side)

### React cache() Function

Memoizes function results within a single request.

```typescript
// app/lib/data.ts
import { cache } from 'react';

export const getUser = cache(async (userId: string) => {
  console.log('Fetching user:', userId); // Logs once per request
  const response = await fetch(`https://api.example.com/users/${userId}`);
  return response.json();
});
```

```typescript
// app/components/UserProfile.tsx
import { getUser } from '@/lib/data';

export async function UserProfile({ userId }: { userId: string }) {
  const user = await getUser(userId); // First call
  
  return (
    <div>
      <h1>{user.name}</h1>
      <UserAvatar userId={userId} />
    </div>
  );
}

// app/components/UserAvatar.tsx
import { getUser } from '@/lib/data';

export async function UserAvatar({ userId }: { userId: string }) {
  const user = await getUser(userId); // Uses cached result!
  
  return <img src={user.avatar} alt={user.name} />;
}
```

**Key Benefits:**
- Automatically deduplicates requests within a render
- No manual cache management
- Works across Server Components

### Request Deduplication

Built into Next.js fetch:

```typescript
// These will only make ONE network request
async function Page() {
  const data1 = await fetch('https://api.example.com/data');
  const data2 = await fetch('https://api.example.com/data'); // Deduplicated!
  const data3 = await fetch('https://api.example.com/data'); // Deduplicated!
  
  return <div>{/* ... */}</div>;
}
```

### Data Cache Configuration

```typescript
// Default: cache forever
fetch('https://api.example.com/data'); // Cached indefinitely

// No caching
fetch('https://api.example.com/data', { 
  cache: 'no-store' 
});

// Time-based revalidation
fetch('https://api.example.com/data', { 
  next: { revalidate: 3600 } // Revalidate every hour
});

// Tag-based revalidation
fetch('https://api.example.com/data', { 
  next: { tags: ['products'] } 
});
```

### Segment-Level Caching

Control caching for entire route segments:

```typescript
// app/products/page.tsx

// Static rendering (default)
export default async function ProductsPage() {
  const products = await fetch('https://api.example.com/products');
  return <ProductList products={products} />;
}

// Dynamic rendering
export const dynamic = 'force-dynamic';

export default async function ProductsPage() {
  const products = await fetch('https://api.example.com/products');
  return <ProductList products={products} />;
}

// Time-based revalidation
export const revalidate = 3600; // Revalidate every hour

export default async function ProductsPage() {
  const products = await fetch('https://api.example.com/products');
  return <ProductList products={products} />;
}
```

### On-Demand Revalidation

Invalidate cache when data changes:

```typescript
// app/api/revalidate/route.ts
import { revalidatePath, revalidateTag } from 'next/cache';
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  const { path, tag } = await request.json();
  
  // Revalidate by path
  if (path) {
    revalidatePath(path);
  }
  
  // Revalidate by tag
  if (tag) {
    revalidateTag(tag);
  }
  
  return NextResponse.json({ revalidated: true, now: Date.now() });
}
```

```typescript
// When data changes (e.g., after creating a product)
async function createProduct(data: ProductData) {
  await db.products.create(data);
  
  // Trigger revalidation
  await fetch('http://localhost:3000/api/revalidate', {
    method: 'POST',
    body: JSON.stringify({ 
      path: '/products',
      tag: 'products' 
    })
  });
}
```

### Cache Strategies Comparison

```typescript
// Strategy 1: Static Generation (Best Performance)
// âœ… Use for: Marketing pages, docs, blogs
export const dynamic = 'force-static';

export default async function Page() {
  const data = await fetch('https://api.example.com/data');
  return <div>{/* ... */}</div>;
}

// Strategy 2: ISR (Balanced)
// âœ… Use for: E-commerce product pages, news
export const revalidate = 60; // Revalidate every 60 seconds

export default async function Page() {
  const data = await fetch('https://api.example.com/data');
  return <div>{/* ... */}</div>;
}

// Strategy 3: Dynamic (Fresh Data)
// âœ… Use for: User dashboards, admin panels
export const dynamic = 'force-dynamic';

export default async function Page() {
  const data = await fetch('https://api.example.com/data', {
    cache: 'no-store'
  });
  return <div>{/* ... */}</div>;
}

// Strategy 4: Mixed (Sophisticated)
// âœ… Use for: Complex pages with different data requirements
export default async function Page() {
  // Static data
  const staticData = await fetch('https://api.example.com/static');
  
  // Revalidated data
  const products = await fetch('https://api.example.com/products', {
    next: { revalidate: 3600 }
  });
  
  // Dynamic data
  const user = await fetch('https://api.example.com/user', {
    cache: 'no-store'
  });
  
  return <div>{/* ... */}</div>;
}
```

---

## 14.4 Optimistic Updates

### What are Optimistic Updates?

Optimistic updates immediately reflect changes in the UI before the server confirms, making the app feel instant.

### Basic Implementation

```typescript
'use client';

import { useState, useTransition } from 'react';

export function TodoList({ initialTodos }: { initialTodos: Todo[] }) {
  const [todos, setTodos] = useState(initialTodos);
  const [isPending, startTransition] = useTransition();

  const addTodo = async (text: string) => {
    // Optimistic update
    const optimisticTodo = {
      id: `temp-${Date.now()}`,
      text,
      completed: false,
      createdAt: new Date().toISOString(),
    };
    
    setTodos(prev => [...prev, optimisticTodo]);

    try {
      // Server mutation
      const response = await fetch('/api/todos', {
        method: 'POST',
        body: JSON.stringify({ text }),
      });
      
      const newTodo = await response.json();
      
      // Replace optimistic with real data
      setTodos(prev => 
        prev.map(todo => 
          todo.id === optimisticTodo.id ? newTodo : todo
        )
      );
    } catch (error) {
      // Rollback on error
      setTodos(prev => 
        prev.filter(todo => todo.id !== optimisticTodo.id)
      );
      console.error('Failed to add todo:', error);
    }
  };

  const toggleTodo = async (id: string) => {
    // Save current state for rollback
    const previousTodos = todos;
    
    // Optimistic update
    setTodos(prev =>
      prev.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );

    try {
      await fetch(`/api/todos/${id}`, {
        method: 'PATCH',
      });
    } catch (error) {
      // Rollback on error
      setTodos(previousTodos);
      console.error('Failed to toggle todo:', error);
    }
  };

  return (
    <div>
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            />
            <span style={{ 
              textDecoration: todo.completed ? 'line-through' : 'none',
              opacity: todo.id.startsWith('temp-') ? 0.5 : 1 
            }}>
              {todo.text}
            </span>
          </li>
        ))}
      </ul>
      {isPending && <p>Updating...</p>}
    </div>
  );
}
```

### With React Query

React Query has built-in optimistic update support:

```typescript
'use client';

import { useMutation, useQueryClient, useQuery } from '@tanstack/react-query';

export function TodoListWithReactQuery() {
  const queryClient = useQueryClient();
  
  const { data: todos = [] } = useQuery({
    queryKey: ['todos'],
    queryFn: () => fetch('/api/todos').then(r => r.json()),
  });

  const addTodoMutation = useMutation({
    mutationFn: (text: string) =>
      fetch('/api/todos', {
        method: 'POST',
        body: JSON.stringify({ text }),
      }).then(r => r.json()),
    
    // Optimistic update
    onMutate: async (text) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['todos'] });

      // Snapshot previous value
      const previousTodos = queryClient.getQueryData(['todos']);

      // Optimistically update
      queryClient.setQueryData(['todos'], (old: Todo[]) => [
        ...old,
        {
          id: `temp-${Date.now()}`,
          text,
          completed: false,
        },
      ]);

      // Return context with snapshot
      return { previousTodos };
    },
    
    // Rollback on error
    onError: (err, text, context) => {
      queryClient.setQueryData(['todos'], context?.previousTodos);
    },
    
    // Refetch after success
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    },
  });

  const toggleTodoMutation = useMutation({
    mutationFn: (id: string) =>
      fetch(`/api/todos/${id}`, { method: 'PATCH' }),
    
    onMutate: async (id) => {
      await queryClient.cancelQueries({ queryKey: ['todos'] });
      const previousTodos = queryClient.getQueryData(['todos']);

      queryClient.setQueryData(['todos'], (old: Todo[]) =>
        old.map(todo =>
          todo.id === id ? { ...todo, completed: !todo.completed } : todo
        )
      );

      return { previousTodos };
    },
    
    onError: (err, id, context) => {
      queryClient.setQueryData(['todos'], context?.previousTodos);
    },
  });

  return (
    <div>
      <ul>
        {todos.map((todo: Todo) => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodoMutation.mutate(todo.id)}
            />
            <span>{todo.text}</span>
          </li>
        ))}
      </ul>
      
      <button onClick={() => addTodoMutation.mutate('New Todo')}>
        Add Todo
      </button>
    </div>
  );
}
```

### Server Actions with useOptimistic

```typescript
'use client';

import { experimental_useOptimistic as useOptimistic } from 'react';
import { updateTodo } from './actions';

export function TodoItem({ todo }: { todo: Todo }) {
  const [optimisticTodo, setOptimisticTodo] = useOptimistic(
    todo,
    (state, newCompleted: boolean) => ({
      ...state,
      completed: newCompleted,
    })
  );

  const handleToggle = async () => {
    // Optimistic update
    setOptimisticTodo(!optimisticTodo.completed);
    
    // Server action
    await updateTodo(todo.id, { completed: !todo.completed });
  };

  return (
    <li style={{ opacity: optimisticTodo.completed !== todo.completed ? 0.5 : 1 }}>
      <input
        type="checkbox"
        checked={optimisticTodo.completed}
        onChange={handleToggle}
      />
      <span>{optimisticTodo.text}</span>
    </li>
  );
}
```

```typescript
// app/actions.ts
'use server';

import { revalidatePath } from 'next/cache';

export async function updateTodo(id: string, data: Partial<Todo>) {
  await db.todos.update({
    where: { id },
    data,
  });
  
  revalidatePath('/todos');
}
```

---

## 14.5 Real-time Features

### WebSocket Integration

```typescript
// lib/websocket.ts
import { useEffect, useState } from 'react';

export function useWebSocket(url: string) {
  const [socket, setSocket] = useState<WebSocket | null>(null);
  const [messages, setMessages] = useState<any[]>([]);
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    const ws = new WebSocket(url);

    ws.onopen = () => {
      console.log('WebSocket connected');
      setIsConnected(true);
    };

    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      setMessages(prev => [...prev, message]);
    };

    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };

    ws.onclose = () => {
      console.log('WebSocket disconnected');
      setIsConnected(false);
    };

    setSocket(ws);

    return () => {
      ws.close();
    };
  }, [url]);

  const sendMessage = (message: any) => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify(message));
    }
  };

  return { messages, sendMessage, isConnected };
}
```

```typescript
// components/Chat.tsx
'use client';

import { useWebSocket } from '@/lib/websocket';
import { useState } from 'react';

export function Chat() {
  const [input, setInput] = useState('');
  const { messages, sendMessage, isConnected } = useWebSocket(
    'ws://localhost:3001'
  );

  const handleSend = () => {
    if (input.trim()) {
      sendMessage({
        type: 'message',
        text: input,
        timestamp: Date.now(),
      });
      setInput('');
    }
  };

  return (
    <div>
      <div className="status">
        {isConnected ? 'ðŸŸ¢ Connected' : 'ðŸ”´ Disconnected'}
      </div>
      
      <div className="messages">
        {messages.map((msg, i) => (
          <div key={i} className="message">
            {msg.text}
          </div>
        ))}
      </div>
      
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        onKeyPress={(e) => e.key === 'Enter' && handleSend()}
      />
      <button onClick={handleSend}>Send</button>
    </div>
  );
}
```

### Server-Sent Events (SSE)

Better for one-way server-to-client communication:

```typescript
// app/api/events/route.ts
export async function GET() {
  const encoder = new TextEncoder();
  
  const stream = new ReadableStream({
    start(controller) {
      // Send initial message
      controller.enqueue(
        encoder.encode(`data: ${JSON.stringify({ type: 'connected' })}

`)
      );

      // Send updates every 5 seconds
      const interval = setInterval(() => {
        const data = {
          type: 'update',
          timestamp: Date.now(),
          value: Math.random(),
        };
        
        controller.enqueue(
          encoder.encode(`data: ${JSON.stringify(data)}

`)
        );
      }, 5000);

      // Cleanup
      return () => {
        clearInterval(interval);
      };
    },
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}
```

```typescript
// components/LiveUpdates.tsx
'use client';

import { useEffect, useState } from 'react';

export function LiveUpdates() {
  const [updates, setUpdates] = useState<any[]>([]);

  useEffect(() => {
    const eventSource = new EventSource('/api/events');

    eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data);
      setUpdates(prev => [...prev, data]);
    };

    eventSource.onerror = () => {
      console.error('SSE error');
      eventSource.close();
    };

    return () => {
      eventSource.close();
    };
  }, []);

  return (
    <div>
      <h2>Live Updates</h2>
      <ul>
        {updates.map((update, i) => (
          <li key={i}>
            {update.type}: {update.value} at {new Date(update.timestamp).toLocaleTimeString()}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### Polling vs Real-time Comparison

```typescript
// Polling (Simple but inefficient)
function usePolling(url: string, interval: number = 5000) {
  const [data, setData] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      const response = await fetch(url);
      const json = await response.json();
      setData(json);
    };

    fetchData(); // Initial fetch
    const intervalId = setInterval(fetchData, interval);

    return () => clearInterval(intervalId);
  }, [url, interval]);

  return data;
}

// Usage
function Dashboard() {
  const stats = usePolling('/api/stats', 10000); // Poll every 10s
  return <div>{JSON.stringify(stats)}</div>;
}
```

**When to use each:**

- **WebSocket**: Bidirectional, real-time chat, gaming, collaborative editing
- **SSE**: Server to client, live feeds, notifications, stock prices
- **Polling**: Simple implementation, less real-time requirements
