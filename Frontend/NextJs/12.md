# Chapter 12: Testing - In-Depth Guide

## 12.1 Unit Testing with Jest and React Testing Library

### Setting Up Jest in Next.js

First, install the necessary dependencies:

```bash
npm install --save-dev jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom @testing-library/user-event
```

### Jest Configuration

Create `jest.config.js` in your root directory:

```javascript
// jest.config.js
const nextJest = require('next/jest')

const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files in your test environment
  dir: './',
})

// Add any custom config to be passed to Jest
const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testEnvironment: 'jest-environment-jsdom',
  moduleNameMapper: {
    // Handle module aliases (this will be automatically configured for you soon)
    '^@/(.*)$': '<rootDir>/$1',
    '^@/components/(.*)$': '<rootDir>/components/$1',
    '^@/lib/(.*)$': '<rootDir>/lib/$1',
  },
  collectCoverageFrom: [
    'app/**/*.{js,jsx,ts,tsx}',
    'components/**/*.{js,jsx,ts,tsx}',
    'lib/**/*.{js,jsx,ts,tsx}',
    '!**/*.d.ts',
    '!**/node_modules/**',
    '!**/.next/**',
  ],
  testMatch: [
    '**/__tests__/**/*.[jt]s?(x)',
    '**/?(*.)+(spec|test).[jt]s?(x)',
  ],
  testPathIgnorePatterns: ['/node_modules/', '/.next/'],
  transformIgnorePatterns: [
    '/node_modules/',
    '^.+\\.module\\.(css|sass|scss)$',
  ],
}

// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
module.exports = createJestConfig(customJestConfig)
```

### Jest Setup File

```javascript
// jest.setup.js
import '@testing-library/jest-dom'

// Mock Next.js router
jest.mock('next/navigation', () => ({
  useRouter() {
    return {
      push: jest.fn(),
      replace: jest.fn(),
      prefetch: jest.fn(),
      back: jest.fn(),
      pathname: '/',
      query: {},
      asPath: '/',
    }
  },
  usePathname() {
    return '/'
  },
  useSearchParams() {
    return new URLSearchParams()
  },
}))

// Mock next/image
jest.mock('next/image', () => ({
  __esModule: true,
  default: (props) => {
    // eslint-disable-next-line jsx-a11y/alt-text
    return <img {...props} />
  },
}))
```

### Basic Component Testing

```typescript
// components/Button.tsx
interface ButtonProps {
  children: React.ReactNode
  onClick?: () => void
  variant?: 'primary' | 'secondary'
  disabled?: boolean
}

export default function Button({ 
  children, 
  onClick, 
  variant = 'primary',
  disabled = false 
}: ButtonProps) {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={`btn btn-${variant}`}
      data-testid="button"
    >
      {children}
    </button>
  )
}
```

```typescript
// components/__tests__/Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react'
import Button from '../Button'

describe('Button Component', () => {
  it('renders button with text', () => {
    render(<Button>Click me</Button>)
    const button = screen.getByText('Click me')
    expect(button).toBeInTheDocument()
  })
  
  it('calls onClick handler when clicked', () => {
    const handleClick = jest.fn()
    render(<Button onClick={handleClick}>Click me</Button>)
    
    const button = screen.getByTestId('button')
    fireEvent.click(button)
    
    expect(handleClick).toHaveBeenCalledTimes(1)
  })
  
  it('applies correct variant class', () => {
    render(<Button variant="secondary">Click me</Button>)
    const button = screen.getByTestId('button')
    expect(button).toHaveClass('btn-secondary')
  })
  
  it('disables button when disabled prop is true', () => {
    render(<Button disabled>Click me</Button>)
    const button = screen.getByTestId('button')
    expect(button).toBeDisabled()
  })
  
  it('does not call onClick when disabled', () => {
    const handleClick = jest.fn()
    render(<Button onClick={handleClick} disabled>Click me</Button>)
    
    const button = screen.getByTestId('button')
    fireEvent.click(button)
    
    expect(handleClick).not.toHaveBeenCalled()
  })
})
```

### Testing Components with User Interactions

```typescript
// components/Counter.tsx
'use client'
import { useState } from 'react'

export default function Counter() {
  const [count, setCount] = useState(0)
  
  return (
    <div>
      <p data-testid="count">Count: {count}</p>
      <button 
        onClick={() => setCount(count + 1)}
        data-testid="increment"
      >
        Increment
      </button>
      <button 
        onClick={() => setCount(count - 1)}
        data-testid="decrement"
      >
        Decrement
      </button>
      <button 
        onClick={() => setCount(0)}
        data-testid="reset"
      >
        Reset
      </button>
    </div>
  )
}
```

```typescript
// components/__tests__/Counter.test.tsx
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import Counter from '../Counter'

describe('Counter Component', () => {
  it('starts with count of 0', () => {
    render(<Counter />)
    expect(screen.getByTestId('count')).toHaveTextContent('Count: 0')
  })
  
  it('increments count when increment button is clicked', async () => {
    const user = userEvent.setup()
    render(<Counter />)
    
    const incrementButton = screen.getByTestId('increment')
    await user.click(incrementButton)
    
    expect(screen.getByTestId('count')).toHaveTextContent('Count: 1')
  })
  
  it('decrements count when decrement button is clicked', async () => {
    const user = userEvent.setup()
    render(<Counter />)
    
    const decrementButton = screen.getByTestId('decrement')
    await user.click(decrementButton)
    
    expect(screen.getByTestId('count')).toHaveTextContent('Count: -1')
  })
  
  it('resets count to 0', async () => {
    const user = userEvent.setup()
    render(<Counter />)
    
    // Increment a few times
    const incrementButton = screen.getByTestId('increment')
    await user.click(incrementButton)
    await user.click(incrementButton)
    await user.click(incrementButton)
    
    // Reset
    const resetButton = screen.getByTestId('reset')
    await user.click(resetButton)
    
    expect(screen.getByTestId('count')).toHaveTextContent('Count: 0')
  })
})
```

### Testing Forms

```typescript
// components/LoginForm.tsx
'use client'
import { useState } from 'react'

interface LoginFormProps {
  onSubmit: (email: string, password: string) => Promise<void>
}

export default function LoginForm({ onSubmit }: LoginFormProps) {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [error, setError] = useState('')
  const [loading, setLoading] = useState(false)
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError('')
    setLoading(true)
    
    try {
      await onSubmit(email, password)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Login failed')
    } finally {
      setLoading(false)
    }
  }
  
  return (
    <form onSubmit={handleSubmit} data-testid="login-form">
      <div>
        <label htmlFor="email">Email</label>
        <input
          id="email"
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
          data-testid="email-input"
        />
      </div>
      
      <div>
        <label htmlFor="password">Password</label>
        <input
          id="password"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
          data-testid="password-input"
        />
      </div>
      
      {error && <p data-testid="error-message">{error}</p>}
      
      <button type="submit" disabled={loading} data-testid="submit-button">
        {loading ? 'Logging in...' : 'Login'}
      </button>
    </form>
  )
}
```

```typescript
// components/__tests__/LoginForm.test.tsx
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import LoginForm from '../LoginForm'

describe('LoginForm Component', () => {
  const mockOnSubmit = jest.fn()
  
  beforeEach(() => {
    mockOnSubmit.mockClear()
  })
  
  it('renders email and password inputs', () => {
    render(<LoginForm onSubmit={mockOnSubmit} />)
    
    expect(screen.getByLabelText('Email')).toBeInTheDocument()
    expect(screen.getByLabelText('Password')).toBeInTheDocument()
  })
  
  it('submits form with email and password', async () => {
    const user = userEvent.setup()
    mockOnSubmit.mockResolvedValue(undefined)
    
    render(<LoginForm onSubmit={mockOnSubmit} />)
    
    const emailInput = screen.getByTestId('email-input')
    const passwordInput = screen.getByTestId('password-input')
    const submitButton = screen.getByTestId('submit-button')
    
    await user.type(emailInput, 'test@example.com')
    await user.type(passwordInput, 'password123')
    await user.click(submitButton)
    
    await waitFor(() => {
      expect(mockOnSubmit).toHaveBeenCalledWith('test@example.com', 'password123')
    })
  })
  
  it('displays error message on failed submission', async () => {
    const user = userEvent.setup()
    mockOnSubmit.mockRejectedValue(new Error('Invalid credentials'))
    
    render(<LoginForm onSubmit={mockOnSubmit} />)
    
    const emailInput = screen.getByTestId('email-input')
    const passwordInput = screen.getByTestId('password-input')
    const submitButton = screen.getByTestId('submit-button')
    
    await user.type(emailInput, 'test@example.com')
    await user.type(passwordInput, 'wrongpassword')
    await user.click(submitButton)
    
    await waitFor(() => {
      expect(screen.getByTestId('error-message')).toHaveTextContent('Invalid credentials')
    })
  })
  
  it('disables submit button during submission', async () => {
    const user = userEvent.setup()
    mockOnSubmit.mockImplementation(() => new Promise(resolve => setTimeout(resolve, 100)))
    
    render(<LoginForm onSubmit={mockOnSubmit} />)
    
    const emailInput = screen.getByTestId('email-input')
    const passwordInput = screen.getByTestId('password-input')
    const submitButton = screen.getByTestId('submit-button')
    
    await user.type(emailInput, 'test@example.com')
    await user.type(passwordInput, 'password123')
    await user.click(submitButton)
    
    expect(submitButton).toBeDisabled()
    expect(submitButton).toHaveTextContent('Logging in...')
  })
})
```

### Testing Custom Hooks

```typescript
// hooks/useCounter.ts
import { useState, useCallback } from 'react'

export function useCounter(initialValue: number = 0) {
  const [count, setCount] = useState(initialValue)
  
  const increment = useCallback(() => setCount(c => c + 1), [])
  const decrement = useCallback(() => setCount(c => c - 1), [])
  const reset = useCallback(() => setCount(initialValue), [initialValue])
  
  return { count, increment, decrement, reset }
}
```

```typescript
// hooks/__tests__/useCounter.test.ts
import { renderHook, act } from '@testing-library/react'
import { useCounter } from '../useCounter'

describe('useCounter Hook', () => {
  it('initializes with default value', () => {
    const { result } = renderHook(() => useCounter())
    expect(result.current.count).toBe(0)
  })
  
  it('initializes with custom value', () => {
    const { result } = renderHook(() => useCounter(10))
    expect(result.current.count).toBe(10)
  })
  
  it('increments count', () => {
    const { result } = renderHook(() => useCounter())
    
    act(() => {
      result.current.increment()
    })
    
    expect(result.current.count).toBe(1)
  })
  
  it('decrements count', () => {
    const { result } = renderHook(() => useCounter(5))
    
    act(() => {
      result.current.decrement()
    })
    
    expect(result.current.count).toBe(4)
  })
  
  it('resets to initial value', () => {
    const { result } = renderHook(() => useCounter(5))
    
    act(() => {
      result.current.increment()
      result.current.increment()
      result.current.reset()
    })
    
    expect(result.current.count).toBe(5)
  })
})
```

### Testing Components with Async Data

```typescript
// components/UserProfile.tsx
'use client'
import { useEffect, useState } from 'react'

interface User {
  id: number
  name: string
  email: string
}

export default function UserProfile({ userId }: { userId: number }) {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => {
        if (!res.ok) throw new Error('Failed to fetch user')
        return res.json()
      })
      .then(data => {
        setUser(data)
        setLoading(false)
      })
      .catch(err => {
        setError(err.message)
        setLoading(false)
      })
  }, [userId])
  
  if (loading) return <div data-testid="loading">Loading...</div>
  if (error) return <div data-testid="error">{error}</div>
  if (!user) return null
  
  return (
    <div data-testid="user-profile">
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  )
}
```

```typescript
// components/__tests__/UserProfile.test.tsx
import { render, screen, waitFor } from '@testing-library/react'
import UserProfile from '../UserProfile'

// Mock fetch
global.fetch = jest.fn()

describe('UserProfile Component', () => {
  beforeEach(() => {
    (global.fetch as jest.Mock).mockClear()
  })
  
  it('displays loading state initially', () => {
    (global.fetch as jest.Mock).mockImplementation(
      () => new Promise(() => {}) // Never resolves
    )
    
    render(<UserProfile userId={1} />)
    expect(screen.getByTestId('loading')).toBeInTheDocument()
  })
  
  it('displays user data after successful fetch', async () => {
    const mockUser = {
      id: 1,
      name: 'John Doe',
      email: 'john@example.com'
    }
    
    (global.fetch as jest.Mock).mockResolvedValue({
      ok: true,
      json: async () => mockUser
    })
    
    render(<UserProfile userId={1} />)
    
    await waitFor(() => {
      expect(screen.getByTestId('user-profile')).toBeInTheDocument()
    })
    
    expect(screen.getByText('John Doe')).toBeInTheDocument()
    expect(screen.getByText('john@example.com')).toBeInTheDocument()
  })
  
  it('displays error message on failed fetch', async () => {
    (global.fetch as jest.Mock).mockResolvedValue({
      ok: false,
      json: async () => ({})
    })
    
    render(<UserProfile userId={1} />)
    
    await waitFor(() => {
      expect(screen.getByTestId('error')).toBeInTheDocument()
    })
    
    expect(screen.getByText('Failed to fetch user')).toBeInTheDocument()
  })
})
```

---

## 12.2 Integration Testing

### Testing API Routes

```typescript
// app/api/users/route.ts
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  try {
    // Simulate database call
    const users = [
      { id: 1, name: 'John Doe', email: 'john@example.com' },
      { id: 2, name: 'Jane Smith', email: 'jane@example.com' },
    ]
    
    return NextResponse.json(users)
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch users' },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    // Validation
    if (!body.name || !body.email) {
      return NextResponse.json(
        { error: 'Name and email are required' },
        { status: 400 }
      )
    }
    
    // Simulate creating user
    const newUser = {
      id: Date.now(),
      name: body.name,
      email: body.email,
    }
    
    return NextResponse.json(newUser, { status: 201 })
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to create user' },
      { status: 500 }
    )
  }
}
```

```typescript
// app/api/users/__tests__/route.test.ts
import { GET, POST } from '../route'
import { NextRequest } from 'next/server'

describe('/api/users', () => {
  describe('GET', () => {
    it('returns list of users', async () => {
      const request = new NextRequest('http://localhost:3000/api/users')
      const response = await GET(request)
      const data = await response.json()
      
      expect(response.status).toBe(200)
      expect(Array.isArray(data)).toBe(true)
      expect(data.length).toBeGreaterThan(0)
    })
  })
  
  describe('POST', () => {
    it('creates a new user', async () => {
      const userData = {
        name: 'Test User',
        email: 'test@example.com'
      }
      
      const request = new NextRequest('http://localhost:3000/api/users', {
        method: 'POST',
        body: JSON.stringify(userData),
      })
      
      const response = await POST(request)
      const data = await response.json()
      
      expect(response.status).toBe(201)
      expect(data.name).toBe(userData.name)
      expect(data.email).toBe(userData.email)
      expect(data.id).toBeDefined()
    })
    
    it('returns 400 when name is missing', async () => {
      const request = new NextRequest('http://localhost:3000/api/users', {
        method: 'POST',
        body: JSON.stringify({ email: 'test@example.com' }),
      })
      
      const response = await POST(request)
      const data = await response.json()
      
      expect(response.status).toBe(400)
      expect(data.error).toBe('Name and email are required')
    })
  })
})
```

### Testing Database Interactions

```typescript
// lib/db.ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

export async function getUsers() {
  return await prisma.user.findMany()
}

export async function getUserById(id: number) {
  return await prisma.user.findUnique({
    where: { id }
  })
}

export async function createUser(data: { name: string; email: string }) {
  return await prisma.user.create({
    data
  })
}

export default prisma
```

```typescript
// lib/__tests__/db.test.ts
import { getUsers, getUserById, createUser } from '../db'
import prisma from '../db'

// Mock Prisma Client
jest.mock('../db', () => ({
  __esModule: true,
  default: {
    user: {
      findMany: jest.fn(),
      findUnique: jest.fn(),
      create: jest.fn(),
    },
  },
  getUsers: jest.fn(),
  getUserById: jest.fn(),
  createUser: jest.fn(),
}))

describe('Database Functions', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })
  
  describe('getUsers', () => {
    it('fetches all users from database', async () => {
      const mockUsers = [
        { id: 1, name: 'John', email: 'john@example.com' },
        { id: 2, name: 'Jane', email: 'jane@example.com' },
      ]
      
      ;(prisma.user.findMany as jest.Mock).mockResolvedValue(mockUsers)
      
      const users = await prisma.user.findMany()
      
      expect(users).toEqual(mockUsers)
      expect(prisma.user.findMany).toHaveBeenCalledTimes(1)
    })
  })
  
  describe('getUserById', () => {
    it('fetches user by id', async () => {
      const mockUser = { id: 1, name: 'John', email: 'john@example.com' }
      
      ;(prisma.user.findUnique as jest.Mock).mockResolvedValue(mockUser)
      
      const user = await prisma.user.findUnique({ where: { id: 1 } })
      
      expect(user).toEqual(mockUser)
      expect(prisma.user.findUnique).toHaveBeenCalledWith({
        where: { id: 1 }
      })
    })
  })
  
  describe('createUser', () => {
    it('creates a new user', async () => {
      const newUser = { name: 'Test', email: 'test@example.com' }
      const createdUser = { id: 1, ...newUser }
      
      ;(prisma.user.create as jest.Mock).mockResolvedValue(createdUser)
      
      const user = await prisma.user.create({ data: newUser })
      
      expect(user).toEqual(createdUser)
      expect(prisma.user.create).toHaveBeenCalledWith({ data: newUser })
    })
  })
})
```

---

## 12.3 End-to-End Testing with Playwright

### Setting Up Playwright

```bash
npm install --save-dev @playwright/test
npx playwright install
```

### Playwright Configuration

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },
  
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    // Mobile viewports
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] },
    },
  ],
  
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
})
```

### Basic E2E Test

```typescript
// e2e/homepage.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Homepage', () => {
  test('should display the homepage', async ({ page }) => {
    await page.goto('/')
    
    // Check title
    await expect(page).toHaveTitle(/My Awesome App/)
    
    // Check heading
    const heading = page.getByRole('heading', { name: 'Welcome' })
    await expect(heading).toBeVisible()
  })
  
  test('should navigate to about page', async ({ page }) => {
    await page.goto('/')
    
    // Click About link
    await page.click('text=About')
    
    // Verify URL
    await expect(page).toHaveURL('/about')
    
    // Verify page content
    const heading = page.getByRole('heading', { name: 'About Us' })
    await expect(heading).toBeVisible()
  })
})
```

### Testing User Flows

```typescript
// e2e/auth.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Authentication Flow', () => {
  test('should sign up a new user', async ({ page }) => {
    await page.goto('/signup')
    
    // Fill in the signup form
    await page.fill('[name="name"]', 'Test User')
    await page.fill('[name="email"]', 'test@example.com')
    await page.fill('[name="password"]', 'password123')
    await page.fill('[name="confirmPassword"]', 'password123')
    
    // Submit form
    await page.click('button[type="submit"]')
    
    // Should redirect to dashboard
    await expect(page).toHaveURL('/dashboard')
    
    // Should see welcome message
    await expect(page.getByText('Welcome, Test User')).toBeVisible()
  })
  
  test('should login existing user', async ({ page }) => {
    await page.goto('/login')
    
    // Fill in login form
    await page.fill('[name="email"]', 'test@example.com')
    await page.fill('[name="password"]', 'password123')
    
    // Submit
    await page.click('button[type="submit"]')
    
    // Should redirect to dashboard
    await expect(page).toHaveURL('/dashboard')
  })
  
  test('should show error for invalid credentials', async ({ page }) => {
    await page.goto('/login')
    
    await page.fill('[name="email"]', 'wrong@example.com')
    await page.fill('[name="password"]', 'wrongpassword')
    
    await page.click('button[type="submit"]')
    
    // Should show error message
    const errorMessage = page.getByText('Invalid credentials')
    await expect(errorMessage).toBeVisible()
    
    // Should stay on login page
    await expect(page).toHaveURL('/login')
  })
  
  test('should logout user', async ({ page }) => {
    // First login
    await page.goto('/login')
    await page.fill('[name="email"]', 'test@example.com')
    await page.fill('[name="password"]', 'password123')
    await page.click('button[type="submit"]')
    
    // Wait for dashboard
    await expect(page).toHaveURL('/dashboard')
    
    // Click logout
    await page.click('button:has-text("Logout")')
    
    // Should redirect to home
    await expect(page).toHaveURL('/')
  })
})
```

### Testing Form Submissions

```typescript
// e2e/contact-form.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Contact Form', () => {
  test('should submit contact form successfully', async ({ page }) => {
    await page.goto('/contact')
    
    // Fill out the form
    await page.fill('[name="name"]', 'John Doe')
    await page.fill('[name="email"]', 'john@example.com')
    await page.fill('[name="subject"]', 'Test Subject')
    await page.fill('[name="message"]', 'This is a test message')
    
    // Submit
    await page.click('button[type="submit"]')
    
    // Wait for success message
    const successMessage = page.getByText('Message sent successfully')
    await expect(successMessage).toBeVisible()
  })
  
  test('should show validation errors', async ({ page }) => {
    await page.goto('/contact')
    
    // Submit without filling form
    await page.click('button[type="submit"]')
    
    // Check for validation errors
    await expect(page.getByText('Name is required')).toBeVisible()
    await expect(page.getByText('Email is required')).toBeVisible()
    await expect(page.getByText('Message is required')).toBeVisible()
  })
  
  test('should validate email format', async ({ page }) => {
    await page.goto('/contact')
    
    await page.fill('[name="email"]', 'invalid-email')
    await page.click('button[type="submit"]')
    
    await expect(page.getByText('Invalid email format')).toBeVisible()
  })
})
```

### Testing with API Mocking

```typescript
// e2e/products.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Products Page', () => {
  test('should display products from API', async ({ page }) => {
    // Mock API response
    await page.route('**/api/products', async route => {
      await route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify([
          { id: 1, name: 'Product 1', price: 29.99 },
          { id: 2, name: 'Product 2', price: 39.99 },
        ])
      })
    })
    
    await page.goto('/products')
    
    // Verify products are displayed
    await expect(page.getByText('Product 1')).toBeVisible()
    await expect(page.getByText('Product 2')).toBeVisible()
    await expect(page.getByText('$29.99')).toBeVisible()
  })
  
  test('should handle API errors gracefully', async ({ page }) => {
    // Mock API error
    await page.route('**/api/products', async route => {
      await route.fulfill({
        status: 500,
        contentType: 'application/json',
        body: JSON.stringify({ error: 'Server error' })
      })
    })
    
    await page.goto('/products')
    
    // Should show error message
    await expect(page.getByText('Failed to load products')).toBeVisible()
  })
})
```

### Visual Regression Testing

```typescript
// e2e/visual.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Visual Regression Tests', () => {
  test('homepage should match screenshot', async ({ page }) => {
    await page.goto('/')
    await expect(page).toHaveScreenshot('homepage.png')
  })
  
  test('product page should match screenshot', async ({ page }) => {
    await page.goto('/products/1')
    await expect(page).toHaveScreenshot('product-page.png')
  })
  
  test('mobile homepage should match screenshot', async ({ page }) => {
    await page.setViewportSize({ width: 375, height: 667 })
    await page.goto('/')
    await expect(page).toHaveScreenshot('homepage-mobile.png')
  })
})
```

---

## 12.4 Testing Best Practices

### Test Organization

```
app/
  components/
    Button.tsx
    __tests__/
      Button.test.tsx
  lib/
    utils.ts
    __tests__/
      utils.test.ts
e2e/
  homepage.spec.ts
  auth.spec.ts
  products.spec.ts
jest.config.js
jest.setup.js
playwright.config.ts
```

### Writing Maintainable Tests

```typescript
// Use Page Object Model for E2E tests
// e2e/page-objects/LoginPage.ts
import { Page } from '@playwright/test'

export class LoginPage {
  constructor(private page: Page) {}
  
  async goto() {
    await this.page.goto('/login')
  }
  
  async login(email: string, password: string) {
    await this.page.fill('[name="email"]', email)
    await this.page.fill('[name="password"]', password)
    await this.page.click('button[type="submit"]')
  }
  
  async getErrorMessage() {
    return this.page.getByTestId('error-message')
  }
}

// Usage in tests
import { test, expect } from '@playwright/test'
import { LoginPage } from './page-objects/LoginPage'

test('should login user', async ({ page }) => {
  const loginPage = new LoginPage(page)
  await loginPage.goto()
  await loginPage.login('test@example.com', 'password123')
  
  await expect(page).toHaveURL('/dashboard')
})
```

### Test Coverage Configuration

```json
// package.json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "test:all": "npm run test:coverage && npm run test:e2e"
  },
  "jest": {
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    }
  }
}
```

### CI/CD Integration

```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run unit tests
        run: npm run test:coverage
      
      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
  
  e2e-tests:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Install Playwright browsers
        run: npx playwright install --with-deps
      
      - name: Run E2E tests
        run: npm run test:e2e
      
      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: playwright-report
          path: playwright-report/
```

---

## Testing Checklist

✅ **Unit Tests**
- [ ] All components have tests
- [ ] All hooks have tests
- [ ] All utility functions tested
- [ ] Edge cases covered
- [ ] Coverage > 80%

✅ **Integration Tests**
- [ ] API routes tested
- [ ] Database operations tested
- [ ] Authentication flows tested
- [ ] Error handling verified

✅ **E2E Tests**
- [ ] Critical user flows tested
- [ ] Form submissions tested
- [ ] Navigation tested
- [ ] Authentication tested
- [ ] Mobile viewports tested

✅ **CI/CD**
- [ ] Tests run on every PR
- [ ] Tests run on every push
- [ ] Coverage reports generated
- [ ] Failed tests block deployment

✅ **Best Practices**
- [ ] Tests are isolated
- [ ] Tests are deterministic
- [ ] Mocks used appropriately
- [ ] Test names are descriptive
- [ ] Setup/teardown properly handled
