# Chapter 7: Performance Optimization - In-Depth Guide

## 7.1 Image Optimization

### Understanding the Problem
Images typically account for 50-70% of a webpage's total size. Without optimization:
- Large file sizes slow down page load
- Wrong formats waste bandwidth
- Unsized images cause layout shift (CLS)
- Loading all images upfront blocks rendering

### The next/image Component

#### Basic Usage
```jsx
import Image from 'next/image';

export default function Gallery() {
  return (
    <div>
      {/* Static import - for local images */}
      <Image
        src="/hero.jpg"
        alt="Hero image"
        width={800}
        height={600}
        priority // Load immediately, don't lazy load
      />

      {/* External URL - requires width/height */}
      <Image
        src="https://example.com/photo.jpg"
        alt="External photo"
        width={800}
        height={600}
      />
    </div>
  );
}
```

#### Advanced Configuration

**Fill Mode - Responsive Images**
```jsx
// For images that should fill their container
function Banner() {
  return (
    <div style={{ position: 'relative', width: '100%', height: '400px' }}>
      <Image
        src="/banner.jpg"
        alt="Banner"
        fill
        style={{ objectFit: 'cover' }}
        sizes="100vw" // Tells browser how wide image will be
        priority
      />
    </div>
  );
}
```

**Responsive Sizes**
```jsx
function ResponsiveImage() {
  return (
    <Image
      src="/product.jpg"
      alt="Product"
      width={800}
      height={600}
      sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
      // Mobile: full width, Tablet: half width, Desktop: third width
    />
  );
}
```

**Placeholder Blur Effect**
```jsx
import Image from 'next/image';
import profilePic from '../public/me.jpg'; // Static import

function Profile() {
  return (
    <Image
      src={profilePic}
      alt="Profile"
      placeholder="blur" // Automatic blur placeholder for static imports
    />
  );
}

// For dynamic images, generate blur data URL
function DynamicProfile({ imageUrl, blurDataURL }) {
  return (
    <Image
      src={imageUrl}
      alt="Dynamic profile"
      width={400}
      height={400}
      placeholder="blur"
      blurDataURL={blurDataURL} // Base64 encoded blur image
    />
  );
}
```

#### Image Optimization Configuration

**next.config.js**
```javascript
module.exports = {
  images: {
    // Allow external domains
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'example.com',
        port: '',
        pathname: '/images/**',
      },
      {
        protocol: 'https',
        hostname: 'cdn.mysite.com',
      },
    ],
    
    // Custom image formats
    formats: ['image/avif', 'image/webp'],
    
    // Image sizes for srcset
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
    
    // Cache optimization
    minimumCacheTTL: 60, // Cache images for 60 seconds minimum
    
    // Disable static imports optimization if needed
    disableStaticImages: false,
  },
};
```

#### Loading Strategies

```jsx
function ImageLoadingStrategies() {
  return (
    <>
      {/* Above the fold - load immediately */}
      <Image
        src="/hero.jpg"
        alt="Hero"
        width={1200}
        height={600}
        priority // Disables lazy loading
      />

      {/* Below the fold - lazy load (default) */}
      <Image
        src="/gallery-1.jpg"
        alt="Gallery image"
        width={400}
        height={300}
        loading="lazy" // Default behavior
      />

      {/* Eager loading when you know it's needed */}
      <Image
        src="/logo.png"
        alt="Logo"
        width={100}
        height={50}
        loading="eager"
      />
    </>
  );
}
```

#### Performance Best Practices

```jsx
// ❌ Bad - CLS issues, no optimization
function BadImage() {
  return <img src="/large.jpg" alt="Bad" />;
}

// ✅ Good - Optimized with proper sizing
function GoodImage() {
  return (
    <Image
      src="/large.jpg"
      alt="Good"
      width={800}
      height={600}
      quality={85} // Default is 75, 85 is good balance
    />
  );
}

// ✅ Better - Responsive with art direction
function BetterImage() {
  return (
    <picture>
      <source
        media="(max-width: 768px)"
        srcSet="/mobile.jpg"
      />
      <Image
        src="/desktop.jpg"
        alt="Responsive"
        width={1200}
        height={600}
      />
    </picture>
  );
}
```

---

## 7.2 Font Optimization

### Understanding Font Loading

Font loading can cause:
- **FOIT** (Flash of Invisible Text): Text hidden until font loads
- **FOUT** (Flash of Unstyled Text): Default font shown, then custom font
- Layout shift when font metrics differ
- Multiple network requests

### next/font Usage

#### Google Fonts

```javascript
// app/layout.js (App Router)
import { Inter, Roboto_Mono, Playfair_Display } from 'next/font/google';

// Single font
const inter = Inter({
  subsets: ['latin'],
  display: 'swap', // Font display strategy
  variable: '--font-inter', // CSS variable
});

// Multiple weights
const robotoMono = Roboto_Mono({
  subsets: ['latin'],
  weight: ['400', '700'],
  style: ['normal', 'italic'],
  display: 'swap',
  variable: '--font-roboto-mono',
});

// Variable font with fallback
const playfair = Playfair_Display({
  subsets: ['latin'],
  weight: ['400', '700', '900'],
  display: 'swap',
  fallback: ['Georgia', 'serif'], // System font fallback
  adjustFontFallback: true, // Reduce layout shift
  variable: '--font-playfair',
});

export default function RootLayout({ children }) {
  return (
    <html lang="en" className={`${inter.variable} ${robotoMono.variable}`}>
      <body className={inter.className}>{children}</body>
    </html>
  );
}
```

**Using Font Variables in CSS**
```css
/* globals.css */
.heading {
  font-family: var(--font-playfair);
}

.code {
  font-family: var(--font-roboto-mono);
}

.body {
  font-family: var(--font-inter);
}
```

#### Local Fonts

```javascript
// app/layout.js
import localFont from 'next/font/local';

const myFont = localFont({
  src: [
    {
      path: './fonts/MyFont-Regular.woff2',
      weight: '400',
      style: 'normal',
    },
    {
      path: './fonts/MyFont-Bold.woff2',
      weight: '700',
      style: 'normal',
    },
    {
      path: './fonts/MyFont-Italic.woff2',
      weight: '400',
      style: 'italic',
    },
  ],
  variable: '--font-my-font',
  display: 'swap',
});

export default function RootLayout({ children }) {
  return (
    <html lang="en" className={myFont.variable}>
      <body>{children}</body>
    </html>
  );
}
```

#### Font Display Strategies

```javascript
const font = Inter({
  subsets: ['latin'],
  display: 'swap', // Options: auto, block, swap, fallback, optional
});

/*
Display strategies:
- auto: Browser default (usually block)
- block: Hide text for ~3s, then show with font (FOIT)
- swap: Show fallback immediately, swap when ready (FOUT)
- fallback: 100ms block, then fallback, swap if ready in 3s
- optional: 100ms block, browser decides if worth swapping (best for slow connections)

Recommendation: 'swap' for most cases
*/
```

#### Preloading Fonts

```javascript
// app/layout.js
import { Inter } from 'next/font/google';

const inter = Inter({
  subsets: ['latin'],
  preload: true, // Default is true
  display: 'swap',
});

// For critical fonts, Next.js automatically adds:
// <link rel="preload" as="font" type="font/woff2" crossorigin="anonymous">
```

---

## 7.3 Script Optimization

### Script Loading Strategies

#### Using next/script

```jsx
import Script from 'next/script';

function MyApp({ Component, pageProps }) {
  return (
    <>
      {/* Strategy: beforeInteractive - Load before page is interactive */}
      <Script
        src="https://polyfill.io/v3/polyfill.min.js"
        strategy="beforeInteractive"
      />

      {/* Strategy: afterInteractive - Load after page is interactive (default) */}
      <Script
        src="https://www.googletagmanager.com/gtag/js?id=GA_MEASUREMENT_ID"
        strategy="afterInteractive"
      />

      {/* Strategy: lazyOnload - Load during idle time */}
      <Script
        src="https://connect.facebook.net/en_US/sdk.js"
        strategy="lazyOnload"
      />

      {/* Inline script with onLoad callback */}
      <Script
        id="google-analytics"
        strategy="afterInteractive"
        dangerouslySetInnerHTML={{
          __html: `
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'GA_MEASUREMENT_ID');
          `,
        }}
      />

      {/* Script with onLoad and onError handlers */}
      <Script
        src="https://example.com/sdk.js"
        onLoad={() => {
          console.log('Script loaded successfully');
        }}
        onError={(e) => {
          console.error('Script failed to load', e);
        }}
        onReady={() => {
          console.log('Script is ready to use');
        }}
      />

      <Component {...pageProps} />
    </>
  );
}
```

#### Real-World Examples

**Google Analytics**
```jsx
// app/layout.js
import Script from 'next/script';

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        {children}
        <Script
          src={`https://www.googletagmanager.com/gtag/js?id=${process.env.NEXT_PUBLIC_GA_ID}`}
          strategy="afterInteractive"
        />
        <Script id="google-analytics" strategy="afterInteractive">
          {`
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', '${process.env.NEXT_PUBLIC_GA_ID}');
          `}
        </Script>
      </body>
    </html>
  );
}
```

**Third-Party Widgets**
```jsx
function ContactPage() {
  return (
    <div>
      <h1>Contact Us</h1>
      
      {/* Load chat widget only on this page */}
      <Script
        src="https://cdn.chatwidget.com/widget.js"
        strategy="lazyOnload"
        onLoad={() => {
          // Initialize widget
          window.ChatWidget.init({
            apiKey: process.env.NEXT_PUBLIC_CHAT_API_KEY,
          });
        }}
      />
      
      <div id="chat-widget"></div>
    </div>
  );
}
```

---

## 7.4 Code Splitting and Lazy Loading

### Automatic Code Splitting

Next.js automatically splits code by:
- Each page into separate bundles
- Shared code into common chunks
- Dynamic imports into separate chunks

### Dynamic Imports

#### Component Lazy Loading

```jsx
import dynamic from 'next/dynamic';
import { Suspense } from 'react';

// Basic dynamic import
const DynamicComponent = dynamic(() => import('../components/Heavy'));

// With loading state
const DynamicWithLoading = dynamic(
  () => import('../components/Heavy'),
  { 
    loading: () => <p>Loading...</p>,
    ssr: false, // Disable SSR for this component
  }
);

// Import named export
const DynamicNamed = dynamic(() =>
  import('../components/Heavy').then((mod) => mod.HeavyComponent)
);

// With Suspense (modern approach)
const DynamicWithSuspense = dynamic(() => import('../components/Heavy'), {
  suspense: true,
});

export default function Page() {
  return (
    <div>
      {/* Basic */}
      <DynamicComponent />

      {/* With loading */}
      <DynamicWithLoading />

      {/* With Suspense */}
      <Suspense fallback={<div>Loading...</div>}>
        <DynamicWithSuspense />
      </Suspense>
    </div>
  );
}
```

#### Conditional Loading

```jsx
'use client';

import dynamic from 'next/dynamic';
import { useState } from 'react';

// Load modal only when needed
const DynamicModal = dynamic(() => import('../components/Modal'), {
  ssr: false,
});

export default function Page() {
  const [showModal, setShowModal] = useState(false);

  return (
    <div>
      <button onClick={() => setShowModal(true)}>
        Open Modal
      </button>
      
      {/* Modal component loaded only when showModal is true */}
      {showModal && (
        <DynamicModal onClose={() => setShowModal(false)} />
      )}
    </div>
  );
}
```

#### Library Lazy Loading

```jsx
'use client';

import { useState } from 'react';

export default function ChartPage() {
  const [chartData, setChartData] = useState(null);

  const loadChart = async () => {
    // Load heavy chart library only when needed
    const ChartJS = await import('chart.js/auto');
    const data = {
      labels: ['Jan', 'Feb', 'Mar'],
      datasets: [{
        label: 'Sales',
        data: [12, 19, 3],
      }],
    };
    setChartData(data);
    
    // Use ChartJS...
  };

  return (
    <div>
      <button onClick={loadChart}>Load Chart</button>
      {chartData && <canvas id="myChart"></canvas>}
    </div>
  );
}
```

#### Route-Based Code Splitting

```jsx
// app/page.js
import Link from 'next/link';

export default function Home() {
  return (
    <div>
      <h1>Home</h1>
      {/* Each route is automatically code-split */}
      <Link href="/dashboard">Dashboard</Link>
      <Link href="/profile">Profile</Link>
    </div>
  );
}

// app/dashboard/page.js - Separate bundle
export default function Dashboard() {
  // Heavy dashboard code only loaded when route is visited
  return <div>Dashboard</div>;
}
```

---

## 7.5 Caching Strategies

### Browser Caching

#### Cache-Control Headers

```javascript
// next.config.js
module.exports = {
  async headers() {
    return [
      {
        source: '/static/:path*',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
            // Cache static assets for 1 year
          },
        ],
      },
      {
        source: '/api/:path*',
        headers: [
          {
            key: 'Cache-Control',
            value: 'no-store, max-age=0',
            // Never cache API responses
          },
        ],
      },
      {
        source: '/:path*.jpg',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=86400, stale-while-revalidate=604800',
            // Cache images for 1 day, serve stale for 7 days while revalidating
          },
        ],
      },
    ];
  },
};
```

### Next.js Caching Layers

#### 1. Request Memoization (App Router)

```jsx
// Multiple components can call the same fetch
// Next.js automatically deduplicates them during render

// components/UserProfile.jsx
async function UserProfile({ userId }) {
  const user = await fetch(`https://api.example.com/users/${userId}`)
    .then(r => r.json());
  
  return <div>{user.name}</div>;
}

// components/UserPosts.jsx
async function UserPosts({ userId }) {
  // Same fetch - automatically deduplicated!
  const user = await fetch(`https://api.example.com/users/${userId}`)
    .then(r => r.json());
  
  return <div>{user.posts.length} posts</div>;
}

// page.jsx - Only 1 actual request made
export default function Page() {
  return (
    <>
      <UserProfile userId="123" />
      <UserPosts userId="123" />
    </>
  );
}
```

#### 2. Data Cache

```jsx
// Default: Cache indefinitely
async function getData() {
  const res = await fetch('https://api.example.com/data');
  return res.json();
}

// Time-based revalidation
async function getDataWithRevalidation() {
  const res = await fetch('https://api.example.com/data', {
    next: { revalidate: 3600 } // Revalidate every hour
  });
  return res.json();
}

// No caching
async function getRealtimeData() {
  const res = await fetch('https://api.example.com/realtime', {
    cache: 'no-store' // Always fresh data
  });
  return res.json();
}

// On-demand revalidation
import { revalidateTag, revalidatePath } from 'next/cache';

async function getTaggedData() {
  const res = await fetch('https://api.example.com/data', {
    next: { tags: ['products'] }
  });
  return res.json();
}

// In API route or Server Action
export async function updateProduct() {
  // Update product...
  revalidateTag('products'); // Revalidate all fetches with 'products' tag
  revalidatePath('/products'); // Revalidate specific path
}
```

#### 3. Full Route Cache

```jsx
// app/products/page.js

// Static generation (cached at build time)
export default async function ProductsPage() {
  const products = await fetch('https://api.example.com/products', {
    next: { revalidate: 3600 } // ISR with 1 hour revalidation
  }).then(r => r.json());

  return (
    <div>
      {products.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}

// Dynamic rendering (not cached)
export const dynamic = 'force-dynamic'; // Opt out of caching

export default async function DynamicPage() {
  const data = await fetch('https://api.example.com/live', {
    cache: 'no-store'
  }).then(r => r.json());

  return <div>{data.value}</div>;
}
```

#### 4. Router Cache (Client-side)

```jsx
'use client';

import { useRouter } from 'next/navigation';

export default function Navigation() {
  const router = useRouter();

  const handleNavigation = () => {
    // Router caches visited routes
    router.push('/dashboard');
    
    // Refresh cache
    router.refresh();
    
    // Prefetch route
    router.prefetch('/profile');
  };

  return (
    <button onClick={handleNavigation}>
      Go to Dashboard
    </button>
  );
}
```

### Client-Side Caching with SWR

```jsx
'use client';

import useSWR from 'swr';

const fetcher = (url) => fetch(url).then((res) => res.json());

export default function Profile() {
  const { data, error, isLoading, mutate } = useSWR(
    '/api/user',
    fetcher,
    {
      revalidateOnFocus: true, // Revalidate when window refocuses
      revalidateOnReconnect: true, // Revalidate when reconnect
      dedupingInterval: 2000, // Dedupe requests within 2s
      refreshInterval: 10000, // Poll every 10s
      onSuccess: (data) => {
        console.log('Data loaded:', data);
      },
    }
  );

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error loading profile</div>;

  const updateProfile = async (newData) => {
    // Optimistic update
    mutate(
      { ...data, ...newData },
      { revalidate: false }
    );

    // Make API call
    await fetch('/api/user', {
      method: 'PUT',
      body: JSON.stringify(newData),
    });

    // Revalidate
    mutate();
  };

  return (
    <div>
      <h1>{data.name}</h1>
      <button onClick={() => updateProfile({ name: 'New Name' })}>
        Update
      </button>
    </div>
  );
}
```

---

## 7.6 Core Web Vitals

### Understanding the Metrics

#### 1. Largest Contentful Paint (LCP)
**Target: < 2.5 seconds**

LCP measures loading performance - when the largest content element becomes visible.

**Common LCP Elements:**
- Large images or video
- Block-level text elements
- Background images

**Optimization Strategies:**

```jsx
import Image from 'next/image';

// ✅ Good LCP - Optimized hero image
export default function Hero() {
  return (
    <div className="hero">
      <Image
        src="/hero.jpg"
        alt="Hero"
        width={1920}
        height={1080}
        priority // Critical for LCP
        quality={85}
        placeholder="blur"
        blurDataURL="data:image/jpeg;base64,..."
      />
    </div>
  );
}

// next.config.js - Optimize for LCP
module.exports = {
  images: {
    formats: ['image/avif', 'image/webp'],
  },
  // Enable SWC minification
  swcMinify: true,
};
```

**Server-Side Optimization:**
```javascript
// Reduce server response time
export async function generateMetadata() {
  // Cache aggressively
  const data = await fetch('https://api.example.com/data', {
    next: { revalidate: 3600 }
  }).then(r => r.json());

  return {
    title: data.title,
  };
}
```

#### 2. First Input Delay (FID) / Interaction to Next Paint (INP)
**Target: < 100ms (FID), < 200ms (INP)**

Measures responsiveness - time from user interaction to browser response.

**Optimization Strategies:**

```jsx
'use client';

import { useState, useTransition } from 'react';

export default function SearchPage() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();

  const handleSearch = (e) => {
    const value = e.target.value;
    setQuery(value); // Immediate update

    // Non-urgent update wrapped in transition
    startTransition(() => {
      const filtered = expensiveFilter(value);
      setResults(filtered);
    });
  };

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={handleSearch}
        placeholder="Search..."
      />
      {isPending && <div>Loading...</div>}
      <ResultsList results={results} />
    </div>
  );
}

// Break up long tasks
function expensiveFilter(query) {
  // Instead of one long synchronous operation
  // Use requestIdleCallback or setTimeout for chunking
  return items.filter(item => item.includes(query));
}
```

**Web Worker for Heavy Computation:**
```javascript
// worker.js
self.addEventListener('message', (e) => {
  const result = heavyComputation(e.data);
  self.postMessage(result);
});

// component.jsx
'use client';

import { useEffect, useState } from 'react';

export default function HeavyComponent() {
  const [result, setResult] = useState(null);

  useEffect(() => {
    const worker = new Worker(new URL('./worker.js', import.meta.url));
    
    worker.postMessage({ data: 'input' });
    
    worker.onmessage = (e) => {
      setResult(e.data);
    };

    return () => worker.terminate();
  }, []);

  return <div>{result}</div>;
}
```

#### 3. Cumulative Layout Shift (CLS)
**Target: < 0.1**

Measures visual stability - unexpected layout shifts.

**Common Causes & Solutions:**

```jsx
// ❌ Bad - Causes layout shift
function BadAd() {
  return (
    <div>
      <h1>Article Title</h1>
      {/* Ad loads after content, pushes everything down */}
      <div>
        <AdScript />
      </div>
      <p>Article content...</p>
    </div>
  );
}

// ✅ Good - Reserve space
function GoodAd() {
  return (
    <div>
      <h1>Article Title</h1>
      {/* Fixed height prevents shift */}
      <div style={{ minHeight: '250px', width: '300px' }}>
        <AdScript />
      </div>
      <p>Article content...</p>
    </div>
  );
}

// ✅ Better - Skeleton loading
function BetterAd() {
  const [loaded, setLoaded] = useState(false);

  return (
    <div style={{ minHeight: '250px', width: '300px' }}>
      {!loaded && <AdSkeleton />}
      <AdScript onLoad={() => setLoaded(true)} />
    </div>
  );
}
```

**Font Loading CLS:**
```javascript
// app/layout.js
import { Inter } from 'next/font/google';

const inter = Inter({
  subsets: ['latin'],
  display: 'swap',
  adjustFontFallback: true, // Minimizes CLS
  fallback: ['system-ui', 'arial'], // Similar metrics to Inter
});
```

**Image CLS Prevention:**
```jsx
// Always specify dimensions
<Image
  src="/photo.jpg"
  alt="Photo"
  width={800}
  height={600} // Prevents CLS
/>

// Or use aspect ratio
<div style={{ position: 'relative', aspectRatio: '16/9' }}>
  <Image src="/photo.jpg" alt="Photo" fill />
</div>
```

### Measuring Core Web Vitals

**Using Next.js Built-in Reporting:**
```javascript
// app/layout.js or pages/_app.js
export function reportWebVitals(metric) {
  console.log(metric);
  
  // Send to analytics
  if (metric.label === 'web-vital') {
    // Send to your analytics endpoint
    fetch('/api/analytics', {
      method: 'POST',
      body: JSON.stringify({
        name: metric.name, // LCP, FID, CLS, FCP, TTFB
        value: metric.value,
        id: metric.id,
        label: metric.label,
      }),
    });
  }
}
```

**Using web-vitals Library:**
```jsx
'use client';

import { useEffect } from 'react';
import { onCLS, onFID, onLCP, onFCP, onTTFB, onINP } from 'web-vitals';

export default function WebVitalsReporter() {
  useEffect(() => {
    onCLS(console.log);
    onFID(console.log);
    onLCP(console.log);
    onFCP(console.log);
    onTTFB(console.log);
    onINP(console.log);
  }, []);

  return null;
}
```

### Bundle Analysis

```bash
# Install bundle analyzer
npm install @next/bundle-analyzer

# Configure next.config.js
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
});

module.exports = withBundleAnalyzer({
  // Your Next.js config
});

# Run analysis
ANALYZE=true npm run build
```

### Performance Checklist

✅ Use next/image for all images  
✅ Implement next/font for custom fonts  
✅ Use next/script with proper strategies  
✅ Dynamic import heavy components  
✅ Configure proper Cache-Control headers  
✅ Optimize LCP element (priority, preload)  
✅ Minimize JavaScript execution time (FID/INP)  
✅ Prevent layout shifts (CLS)  
✅ Monitor Core Web Vitals in production  
✅ Regular bundle size analysis  
✅ Use production build for testing  
✅ Implement proper loading states  

### Production Monitoring

```javascript
// lib/analytics.js
export function sendToAnalytics(metric) {
  const body = JSON.stringify({
    name: metric.name,
    value: Math.round(metric.value),
    rating: metric.rating,
    navigationType: metric.navigationType,
    page: window.location.pathname,
  });

  // Use `navigator.sendBeacon()` if available
  if (navigator.sendBeacon) {
    navigator.sendBeacon('/api/vitals', body);
  } else {
    fetch('/api/vitals', { body, method: 'POST', keepalive: true });
  }
}

// pages/_app.js
export function reportWebVitals(metric) {
  if (metric.label === 'web-vital') {
    sendToAnalytics(metric);
  }
}
```

