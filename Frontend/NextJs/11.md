# Chapter 11: SEO Optimization - In-Depth Guide

## 11.1 Metadata API (App Router)

### Understanding the Metadata API

The Metadata API in Next.js 13+ App Router provides a powerful way to define SEO-related tags. It's built on top of React's metadata capabilities and offers both static and dynamic approaches.

### Static Metadata

Static metadata is defined directly in your layout or page files and is evaluated at build time.

```typescript
// app/layout.tsx
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: {
    default: 'My Awesome App',
    template: '%s | My Awesome App', // Will be used by child pages
  },
  description: 'The best app you will ever use',
  keywords: ['Next.js', 'React', 'JavaScript', 'SEO'],
  authors: [{ name: 'John Doe', url: 'https://johndoe.com' }],
  creator: 'John Doe',
  publisher: 'Acme Corp',
  
  // Open Graph
  openGraph: {
    type: 'website',
    locale: 'en_US',
    url: 'https://myapp.com',
    siteName: 'My Awesome App',
    title: 'My Awesome App',
    description: 'The best app you will ever use',
    images: [
      {
        url: 'https://myapp.com/og-image.jpg',
        width: 1200,
        height: 630,
        alt: 'My Awesome App Preview',
      },
    ],
  },
  
  // Twitter Card
  twitter: {
    card: 'summary_large_image',
    site: '@myapp',
    creator: '@johndoe',
    title: 'My Awesome App',
    description: 'The best app you will ever use',
    images: ['https://myapp.com/twitter-image.jpg'],
  },
  
  // Robots
  robots: {
    index: true,
    follow: true,
    googleBot: {
      index: true,
      follow: true,
      'max-video-preview': -1,
      'max-image-preview': 'large',
      'max-snippet': -1,
    },
  },
  
  // Verification
  verification: {
    google: 'google-site-verification-code',
    yandex: 'yandex-verification-code',
    yahoo: 'yahoo-verification-code',
  },
  
  // Alternate languages
  alternates: {
    canonical: 'https://myapp.com',
    languages: {
      'en-US': 'https://myapp.com/en-US',
      'es-ES': 'https://myapp.com/es-ES',
      'fr-FR': 'https://myapp.com/fr-FR',
    },
  },
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

### Dynamic Metadata with generateMetadata

For dynamic pages (like blog posts, product pages), use `generateMetadata` to generate metadata based on route parameters.

```typescript
// app/blog/[slug]/page.tsx
import { Metadata } from 'next'
import { notFound } from 'next/navigation'

// This could be a database call or API fetch
async function getBlogPost(slug: string) {
  const res = await fetch(`https://api.example.com/posts/${slug}`, {
    // Next.js extends fetch with caching
    next: { revalidate: 3600 }, // Revalidate every hour
  })
  
  if (!res.ok) return null
  return res.json()
}

// Generate metadata dynamically
export async function generateMetadata(
  { params }: { params: { slug: string } }
): Promise<Metadata> {
  const post = await getBlogPost(params.slug)
  
  if (!post) {
    return {
      title: 'Post Not Found',
    }
  }
  
  return {
    title: post.title,
    description: post.excerpt,
    authors: [{ name: post.author.name }],
    openGraph: {
      title: post.title,
      description: post.excerpt,
      type: 'article',
      publishedTime: post.publishedAt,
      authors: [post.author.name],
      images: [
        {
          url: post.coverImage,
          width: 1200,
          height: 630,
          alt: post.title,
        },
      ],
    },
    twitter: {
      card: 'summary_large_image',
      title: post.title,
      description: post.excerpt,
      images: [post.coverImage],
    },
    alternates: {
      canonical: `https://myapp.com/blog/${params.slug}`,
    },
  }
}

export default async function BlogPost({ 
  params 
}: { 
  params: { slug: string } 
}) {
  const post = await getBlogPost(params.slug)
  
  if (!post) {
    notFound()
  }
  
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  )
}
```

### Metadata Hierarchy and Inheritance

Metadata follows a hierarchical structure from root to leaf:

```
app/layout.tsx (Root)
  ‚îî‚îÄ app/blog/layout.tsx (Inherits from root)
      ‚îî‚îÄ app/blog/[slug]/page.tsx (Inherits from both)
```

Child routes can override parent metadata:

```typescript
// app/blog/layout.tsx
export const metadata: Metadata = {
  title: {
    default: 'Blog',
    template: '%s | Blog | My Awesome App',
  },
  description: 'Read our latest articles',
}

// app/blog/[slug]/page.tsx
// The title here will use the template from layout: "My Post Title | Blog | My Awesome App"
export async function generateMetadata({ params }): Promise<Metadata> {
  return {
    title: 'My Post Title', // Uses parent template
    // Other metadata overrides parent
  }
}
```

### Advanced Metadata: Icons and Manifests

```typescript
// app/layout.tsx
export const metadata: Metadata = {
  icons: {
    icon: '/favicon.ico',
    shortcut: '/shortcut-icon.png',
    apple: '/apple-icon.png',
    other: {
      rel: 'apple-touch-icon-precomposed',
      url: '/apple-touch-icon-precomposed.png',
    },
  },
  manifest: '/manifest.json',
  themeColor: [
    { media: '(prefers-color-scheme: light)', color: '#ffffff' },
    { media: '(prefers-color-scheme: dark)', color: '#000000' },
  ],
  viewport: {
    width: 'device-width',
    initialScale: 1,
    maximumScale: 5,
  },
}
```

---

## 11.2 Head Component (Pages Router)

### Using next/head for SEO

For projects using the Pages Router, the `next/head` component is used to modify the `<head>` section.

```tsx
// pages/index.tsx
import Head from 'next/head'

export default function Home() {
  return (
    <>
      <Head>
        <title>Home | My Awesome App</title>
        <meta name="description" content="Welcome to my awesome app" />
        <meta name="keywords" content="next.js, react, seo" />
        
        {/* Open Graph */}
        <meta property="og:type" content="website" />
        <meta property="og:url" content="https://myapp.com" />
        <meta property="og:title" content="My Awesome App" />
        <meta property="og:description" content="Welcome to my awesome app" />
        <meta property="og:image" content="https://myapp.com/og-image.jpg" />
        
        {/* Twitter Card */}
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:site" content="@myapp" />
        <meta name="twitter:title" content="My Awesome App" />
        <meta name="twitter:description" content="Welcome to my awesome app" />
        <meta name="twitter:image" content="https://myapp.com/twitter-image.jpg" />
        
        {/* Canonical URL */}
        <link rel="canonical" href="https://myapp.com" />
        
        {/* Favicon */}
        <link rel="icon" href="/favicon.ico" />
        
        {/* Preconnect for performance */}
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="dns-prefetch" href="https://api.example.com" />
      </Head>
      
      <main>
        <h1>Welcome to My App</h1>
      </main>
    </>
  )
}
```

### Dynamic Head with getServerSideProps

```tsx
// pages/blog/[slug].tsx
import Head from 'next/head'
import { GetServerSideProps } from 'next'

interface Post {
  title: string
  excerpt: string
  coverImage: string
  author: { name: string }
}

interface Props {
  post: Post
}

export default function BlogPost({ post }: Props) {
  return (
    <>
      <Head>
        <title>{post.title} | My Blog</title>
        <meta name="description" content={post.excerpt} />
        
        <meta property="og:type" content="article" />
        <meta property="og:title" content={post.title} />
        <meta property="og:description" content={post.excerpt} />
        <meta property="og:image" content={post.coverImage} />
        
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content={post.title} />
        <meta name="twitter:description" content={post.excerpt} />
        <meta name="twitter:image" content={post.coverImage} />
      </Head>
      
      <article>
        <h1>{post.title}</h1>
        {/* Article content */}
      </article>
    </>
  )
}

export const getServerSideProps: GetServerSideProps = async ({ params }) => {
  const res = await fetch(`https://api.example.com/posts/${params?.slug}`)
  const post = await res.json()
  
  return {
    props: { post },
  }
}
```

### Creating a Reusable SEO Component

```tsx
// components/SEO.tsx
import Head from 'next/head'

interface SEOProps {
  title: string
  description: string
  canonical?: string
  ogImage?: string
  ogType?: string
  twitterHandle?: string
}

export default function SEO({
  title,
  description,
  canonical,
  ogImage = '/default-og-image.jpg',
  ogType = 'website',
  twitterHandle = '@myapp',
}: SEOProps) {
  const siteName = 'My Awesome App'
  const fullTitle = `${title} | ${siteName}`
  
  return (
    <Head>
      <title>{fullTitle}</title>
      <meta name="description" content={description} />
      
      {canonical && <link rel="canonical" href={canonical} />}
      
      {/* Open Graph */}
      <meta property="og:type" content={ogType} />
      <meta property="og:title" content={fullTitle} />
      <meta property="og:description" content={description} />
      <meta property="og:image" content={ogImage} />
      <meta property="og:site_name" content={siteName} />
      
      {/* Twitter */}
      <meta name="twitter:card" content="summary_large_image" />
      <meta name="twitter:site" content={twitterHandle} />
      <meta name="twitter:title" content={fullTitle} />
      <meta name="twitter:description" content={description} />
      <meta name="twitter:image" content={ogImage} />
    </Head>
  )
}

// Usage in pages
// <SEO 
//   title="My Blog Post" 
//   description="This is an amazing blog post" 
//   canonical="https://myapp.com/blog/my-post"
//   ogImage="https://myapp.com/images/my-post.jpg"
//   ogType="article"
// />
```

---

## 11.3 Structured Data (JSON-LD)

### What is Structured Data?

Structured data helps search engines understand your content better and can result in rich snippets in search results (like ratings, prices, availability, etc.).

### Implementing JSON-LD in App Router

```typescript
// app/products/[id]/page.tsx
import { Metadata } from 'next'

interface Product {
  id: string
  name: string
  description: string
  price: number
  currency: string
  image: string
  brand: string
  rating: number
  reviewCount: number
  availability: string
}

async function getProduct(id: string): Promise<Product> {
  // Fetch product data
  const res = await fetch(`https://api.example.com/products/${id}`)
  return res.json()
}

export default async function ProductPage({ 
  params 
}: { 
  params: { id: string } 
}) {
  const product = await getProduct(params.id)
  
  // Product structured data
  const productJsonLd = {
    '@context': 'https://schema.org',
    '@type': 'Product',
    name: product.name,
    description: product.description,
    image: product.image,
    brand: {
      '@type': 'Brand',
      name: product.brand,
    },
    offers: {
      '@type': 'Offer',
      price: product.price,
      priceCurrency: product.currency,
      availability: `https://schema.org/${product.availability}`,
      url: `https://myapp.com/products/${product.id}`,
    },
    aggregateRating: {
      '@type': 'AggregateRating',
      ratingValue: product.rating,
      reviewCount: product.reviewCount,
    },
  }
  
  return (
    <>
      {/* Add JSON-LD to page */}
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(productJsonLd) }}
      />
      
      <div>
        <h1>{product.name}</h1>
        <p>{product.description}</p>
        <p>Price: {product.currency}{product.price}</p>
      </div>
    </>
  )
}
```

### Article/Blog Post Schema

```typescript
// app/blog/[slug]/page.tsx
export default async function BlogPost({ params }: { params: { slug: string } }) {
  const post = await getBlogPost(params.slug)
  
  const articleJsonLd = {
    '@context': 'https://schema.org',
    '@type': 'BlogPosting',
    headline: post.title,
    description: post.excerpt,
    image: post.coverImage,
    datePublished: post.publishedAt,
    dateModified: post.updatedAt,
    author: {
      '@type': 'Person',
      name: post.author.name,
      url: post.author.url,
    },
    publisher: {
      '@type': 'Organization',
      name: 'My Awesome App',
      logo: {
        '@type': 'ImageObject',
        url: 'https://myapp.com/logo.png',
      },
    },
    mainEntityOfPage: {
      '@type': 'WebPage',
      '@id': `https://myapp.com/blog/${params.slug}`,
    },
  }
  
  return (
    <>
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(articleJsonLd) }}
      />
      <article>
        <h1>{post.title}</h1>
        <div dangerouslySetInnerHTML={{ __html: post.content }} />
      </article>
    </>
  )
}
```

### Breadcrumb Schema

```typescript
// components/Breadcrumbs.tsx
interface BreadcrumbItem {
  name: string
  url: string
}

export default function Breadcrumbs({ items }: { items: BreadcrumbItem[] }) {
  const breadcrumbJsonLd = {
    '@context': 'https://schema.org',
    '@type': 'BreadcrumbList',
    itemListElement: items.map((item, index) => ({
      '@type': 'ListItem',
      position: index + 1,
      name: item.name,
      item: item.url,
    })),
  }
  
  return (
    <>
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(breadcrumbJsonLd) }}
      />
      <nav aria-label="Breadcrumb">
        <ol>
          {items.map((item, index) => (
            <li key={index}>
              <a href={item.url}>{item.name}</a>
            </li>
          ))}
        </ol>
      </nav>
    </>
  )
}

// Usage
// <Breadcrumbs 
//   items={[
//     { name: 'Home', url: 'https://myapp.com' },
//     { name: 'Products', url: 'https://myapp.com/products' },
//     { name: 'Product Name', url: 'https://myapp.com/products/123' }
//   ]} 
// />
```

### Organization Schema (For Homepage)

```typescript
// app/page.tsx
export default function HomePage() {
  const organizationJsonLd = {
    '@context': 'https://schema.org',
    '@type': 'Organization',
    name: 'My Awesome App',
    url: 'https://myapp.com',
    logo: 'https://myapp.com/logo.png',
    description: 'The best app you will ever use',
    contactPoint: {
      '@type': 'ContactPoint',
      telephone: '+1-555-123-4567',
      contactType: 'Customer Service',
      availableLanguage: ['English', 'Spanish'],
    },
    sameAs: [
      'https://facebook.com/myapp',
      'https://twitter.com/myapp',
      'https://linkedin.com/company/myapp',
      'https://instagram.com/myapp',
    ],
    address: {
      '@type': 'PostalAddress',
      streetAddress: '123 Main St',
      addressLocality: 'San Francisco',
      addressRegion: 'CA',
      postalCode: '94102',
      addressCountry: 'US',
    },
  }
  
  return (
    <>
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(organizationJsonLd) }}
      />
      {/* Homepage content */}
    </>
  )
}
```

---

## 11.4 Sitemap and Robots.txt

### Static Sitemap (App Router)

Create a `sitemap.ts` file in your app directory:

```typescript
// app/sitemap.ts
import { MetadataRoute } from 'next'

export default function sitemap(): MetadataRoute.Sitemap {
  return [
    {
      url: 'https://myapp.com',
      lastModified: new Date(),
      changeFrequency: 'yearly',
      priority: 1,
    },
    {
      url: 'https://myapp.com/about',
      lastModified: new Date(),
      changeFrequency: 'monthly',
      priority: 0.8,
    },
    {
      url: 'https://myapp.com/blog',
      lastModified: new Date(),
      changeFrequency: 'weekly',
      priority: 0.5,
    },
  ]
}
```

### Dynamic Sitemap with Database

```typescript
// app/sitemap.ts
import { MetadataRoute } from 'next'

async function getAllPosts() {
  const res = await fetch('https://api.example.com/posts')
  return res.json()
}

async function getAllProducts() {
  const res = await fetch('https://api.example.com/products')
  return res.json()
}

export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
  const baseUrl = 'https://myapp.com'
  
  // Static pages
  const staticPages: MetadataRoute.Sitemap = [
    {
      url: baseUrl,
      lastModified: new Date(),
      changeFrequency: 'daily',
      priority: 1,
    },
    {
      url: `${baseUrl}/about`,
      lastModified: new Date(),
      changeFrequency: 'monthly',
      priority: 0.8,
    },
  ]
  
  // Dynamic blog posts
  const posts = await getAllPosts()
  const postPages: MetadataRoute.Sitemap = posts.map((post: any) => ({
    url: `${baseUrl}/blog/${post.slug}`,
    lastModified: new Date(post.updatedAt),
    changeFrequency: 'weekly',
    priority: 0.6,
  }))
  
  // Dynamic products
  const products = await getAllProducts()
  const productPages: MetadataRoute.Sitemap = products.map((product: any) => ({
    url: `${baseUrl}/products/${product.id}`,
    lastModified: new Date(product.updatedAt),
    changeFrequency: 'daily',
    priority: 0.7,
  }))
  
  return [...staticPages, ...postPages, ...productPages]
}
```

### Multiple Sitemaps for Large Sites

For sites with thousands of URLs, create multiple sitemaps:

```typescript
// app/sitemap.ts (Index sitemap)
import { MetadataRoute } from 'next'

export default function sitemap(): MetadataRoute.Sitemap {
  return [
    {
      url: 'https://myapp.com/sitemap/products.xml',
      lastModified: new Date(),
    },
    {
      url: 'https://myapp.com/sitemap/blog.xml',
      lastModified: new Date(),
    },
  ]
}

// app/sitemap/products/sitemap.ts
export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
  const products = await getAllProducts()
  return products.map((product: any) => ({
    url: `https://myapp.com/products/${product.id}`,
    lastModified: new Date(product.updatedAt),
  }))
}
```

### Robots.txt Configuration

```typescript
// app/robots.ts
import { MetadataRoute } from 'next'

export default function robots(): MetadataRoute.Robots {
  return {
    rules: [
      {
        userAgent: '*',
        allow: '/',
        disallow: ['/private/', '/admin/', '/api/'],
      },
      {
        userAgent: 'Googlebot',
        allow: '/',
        disallow: '/admin/',
        crawlDelay: 2,
      },
    ],
    sitemap: 'https://myapp.com/sitemap.xml',
  }
}

// This generates:
// User-agent: *
// Allow: /
// Disallow: /private/
// Disallow: /admin/
// Disallow: /api/
//
// User-agent: Googlebot
// Allow: /
// Disallow: /admin/
// Crawl-delay: 2
//
// Sitemap: https://myapp.com/sitemap.xml
```

### Advanced Robots.txt with Environment Variables

```typescript
// app/robots.ts
import { MetadataRoute } from 'next'

export default function robots(): MetadataRoute.Robots {
  const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://myapp.com'
  const isProduction = process.env.NODE_ENV === 'production'
  
  if (!isProduction) {
    // Block all crawlers in non-production environments
    return {
      rules: {
        userAgent: '*',
        disallow: '/',
      },
    }
  }
  
  return {
    rules: [
      {
        userAgent: '*',
        allow: '/',
        disallow: ['/private/', '/admin/', '/api/', '/*.json$'],
      },
    ],
    sitemap: `${baseUrl}/sitemap.xml`,
  }
}
```

---

## 11.5 Internationalization (i18n)

### Setting Up i18n with next-intl

First, install next-intl:

```bash
npm install next-intl
```

Project structure:
```
app/
  [locale]/
    layout.tsx
    page.tsx
  layout.tsx  
messages/
  en.json
  es.json
  fr.json
middleware.ts
```

### Locale Detection Middleware

```typescript
// middleware.ts
import createMiddleware from 'next-intl/middleware'

export default createMiddleware({
  // A list of all locales that are supported
  locales: ['en', 'es', 'fr', 'de'],
  
  // Used when no locale matches
  defaultLocale: 'en',
  
  // Don't redirect if locale is in pathname
  localePrefix: 'always', // or 'as-needed'
})

export const config = {
  // Match only internationalized pathnames
  matcher: ['/', '/(en|es|fr|de)/:path*']
}
```

### Root Layout

```typescript
// app/layout.tsx
import { ReactNode } from 'react'

export default function RootLayout({
  children,
}: {
  children: ReactNode
}) {
  return children
}
```

### Locale Layout with Metadata

```typescript
// app/[locale]/layout.tsx
import { NextIntlClientProvider } from 'next-intl'
import { notFound } from 'next/navigation'
import { Metadata } from 'next'

const locales = ['en', 'es', 'fr', 'de']

export function generateStaticParams() {
  return locales.map((locale) => ({ locale }))
}

export async function generateMetadata({
  params: { locale }
}: {
  params: { locale: string }
}): Promise<Metadata> {
  const messages = (await import(`@/messages/${locale}.json`)).default
  
  return {
    title: messages.metadata.title,
    description: messages.metadata.description,
    alternates: {
      canonical: `https://myapp.com/${locale}`,
      languages: {
        'en': 'https://myapp.com/en',
        'es': 'https://myapp.com/es',
        'fr': 'https://myapp.com/fr',
        'de': 'https://myapp.com/de',
      },
    },
  }
}

export default async function LocaleLayout({
  children,
  params: { locale }
}: {
  children: ReactNode
  params: { locale: string }
}) {
  // Validate that the incoming `locale` parameter is valid
  if (!locales.includes(locale)) notFound()
  
  let messages
  try {
    messages = (await import(`@/messages/${locale}.json`)).default
  } catch (error) {
    notFound()
  }
  
  return (
    <html lang={locale}>
      <body>
        <NextIntlClientProvider locale={locale} messages={messages}>
          {children}
        </NextIntlClientProvider>
      </body>
    </html>
  )
}
```

### Translation Messages

```json
// messages/en.json
{
  "metadata": {
    "title": "My Awesome App",
    "description": "The best app you will ever use"
  },
  "HomePage": {
    "title": "Welcome to My App",
    "description": "Start building amazing things today"
  },
  "navigation": {
    "home": "Home",
    "about": "About",
    "contact": "Contact"
  }
}

// messages/es.json
{
  "metadata": {
    "title": "Mi Aplicaci√≥n Incre√≠ble",
    "description": "La mejor aplicaci√≥n que usar√°s"
  },
  "HomePage": {
    "title": "Bienvenido a Mi Aplicaci√≥n",
    "description": "Comienza a construir cosas incre√≠bles hoy"
  },
  "navigation": {
    "home": "Inicio",
    "about": "Acerca de",
    "contact": "Contacto"
  }
}
```

### Using Translations in Components

```typescript
// app/[locale]/page.tsx
import { useTranslations } from 'next-intl'

export default function HomePage() {
  const t = useTranslations('HomePage')
  
  return (
    <div>
      <h1>{t('title')}</h1>
      <p>{t('description')}</p>
    </div>
  )
}
```

### Language Switcher Component

```typescript
// components/LanguageSwitcher.tsx
'use client'

import { usePathname, useRouter } from 'next/navigation'
import { useLocale } from 'next-intl'

const languages = [
  { code: 'en', name: 'English', flag: 'üá∫üá∏' },
  { code: 'es', name: 'Espa√±ol', flag: 'üá™üá∏' },
  { code: 'fr', name: 'Fran√ßais', flag: 'üá´üá∑' },
  { code: 'de', name: 'Deutsch', flag: 'üá©üá™' },
]

export default function LanguageSwitcher() {
  const router = useRouter()
  const pathname = usePathname()
  const currentLocale = useLocale()
  
  const handleLanguageChange = (newLocale: string) => {
    // Remove current locale from pathname
    const pathnameWithoutLocale = pathname.replace(`/${currentLocale}`, '')
    // Navigate to new locale
    router.push(`/${newLocale}${pathnameWithoutLocale}`)
  }
  
  return (
    <select
      value={currentLocale}
      onChange={(e) => handleLanguageChange(e.target.value)}
      className="border rounded px-2 py-1"
    >
      {languages.map((lang) => (
        <option key={lang.code} value={lang.code}>
          {lang.flag} {lang.name}
        </option>
      ))}
    </select>
  )
}
```

### SEO Best Practices for i18n

```typescript
// app/[locale]/blog/[slug]/page.tsx
import { Metadata } from 'next'

export async function generateMetadata({
  params: { locale, slug }
}: {
  params: { locale: string; slug: string }
}): Promise<Metadata> {
  const post = await getBlogPost(slug, locale)
  
  return {
    title: post.title,
    description: post.excerpt,
    alternates: {
      canonical: `https://myapp.com/${locale}/blog/${slug}`,
      languages: {
        'en': `https://myapp.com/en/blog/${slug}`,
        'es': `https://myapp.com/es/blog/${slug}`,
        'fr': `https://myapp.com/fr/blog/${slug}`,
        'de': `https://myapp.com/de/blog/${slug}`,
        'x-default': `https://myapp.com/en/blog/${slug}`,
      },
    },
    openGraph: {
      title: post.title,
      description: post.excerpt,
      url: `https://myapp.com/${locale}/blog/${slug}`,
      locale: locale,
      alternateLocale: ['en', 'es', 'fr', 'de'].filter(l => l !== locale),
    },
  }
}
```

---

## SEO Checklist for Production

‚úÖ **Metadata**
- [ ] Unique titles for all pages (50-60 characters)
- [ ] Unique descriptions (150-160 characters)
- [ ] Open Graph tags configured
- [ ] Twitter Card tags configured
- [ ] Canonical URLs set correctly

‚úÖ **Technical SEO**
- [ ] Sitemap.xml generated and submitted
- [ ] Robots.txt configured properly
- [ ] Structured data (JSON-LD) implemented
- [ ] Mobile-friendly (responsive design)
- [ ] Fast loading times (Core Web Vitals)
- [ ] HTTPS enabled
- [ ] 404 pages customized

‚úÖ **Content SEO**
- [ ] Semantic HTML (h1, h2, h3, etc.)
- [ ] Alt text for all images
- [ ] Internal linking strategy
- [ ] External links open in new tab (when appropriate)

‚úÖ **International SEO**
- [ ] Hreflang tags for multi-language sites
- [ ] Locale-specific sitemaps
- [ ] Content translated (not just machine-translated)

‚úÖ **Tools & Validation**
- [ ] Google Search Console set up
- [ ] Google Rich Results Test passed
- [ ] Lighthouse SEO score > 90
- [ ] Schema.org validation passed

