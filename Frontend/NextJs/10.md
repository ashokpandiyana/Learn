# Chapter 10: Forms and Validation - In-Depth Guide

## 10.1 Form Handling

### Controlled vs Uncontrolled Forms

#### Controlled Components

```jsx
'use client';

import { useState } from 'react';

export default function ControlledForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: '',
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value,
    }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Form data:', formData);
    // Submit to API...
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        name="name"
        value={formData.name}
        onChange={handleChange}
        placeholder="Name"
      />
      <input
        type="email"
        name="email"
        value={formData.email}
        onChange={handleChange}
        placeholder="Email"
      />
      <textarea
        name="message"
        value={formData.message}
        onChange={handleChange}
        placeholder="Message"
      />
      <button type="submit">Submit</button>
    </form>
  );
}
```

#### Uncontrolled Components (Using useRef)

```jsx
'use client';

import { useRef } from 'react';

export default function UncontrolledForm() {
  const nameRef = useRef(null);
  const emailRef = useRef(null);
  const messageRef = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();
    
    const formData = {
      name: nameRef.current.value,
      email: emailRef.current.value,
      message: messageRef.current.value,
    };
    
    console.log('Form data:', formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        ref={nameRef}
        type="text"
        name="name"
        defaultValue=""
        placeholder="Name"
      />
      <input
        ref={emailRef}
        type="email"
        name="email"
        defaultValue=""
        placeholder="Email"
      />
      <textarea
        ref={messageRef}
        name="message"
        defaultValue=""
        placeholder="Message"
      />
      <button type="submit">Submit</button>
    </form>
  );
}
```

#### Using FormData API

```jsx
'use client';

export default function FormDataExample() {
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    const formData = new FormData(e.currentTarget);
    
    // Get individual values
    const name = formData.get('name');
    const email = formData.get('email');
    
    // Convert to object
    const data = Object.fromEntries(formData.entries());
    console.log(data);
    
    // Send to API
    const response = await fetch('/api/contact', {
      method: 'POST',
      body: formData, // Send as multipart/form-data
    });
    
    // Or send as JSON
    const jsonResponse = await fetch('/api/contact', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input name="name" type="text" placeholder="Name" />
      <input name="email" type="email" placeholder="Email" />
      <textarea name="message" placeholder="Message" />
      <input name="file" type="file" />
      <button type="submit">Submit</button>
    </form>
  );
}
```

### File Upload Handling

```jsx
'use client';

import { useState } from 'react';

export default function FileUploadForm() {
  const [file, setFile] = useState(null);
  const [preview, setPreview] = useState(null);
  const [uploading, setUploading] = useState(false);

  const handleFileChange = (e) => {
    const selectedFile = e.target.files?.[0];
    if (!selectedFile) return;

    // Validate file type
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
    if (!allowedTypes.includes(selectedFile.type)) {
      alert('Only JPEG, PNG, and GIF files are allowed');
      return;
    }

    // Validate file size (5MB max)
    const maxSize = 5 * 1024 * 1024;
    if (selectedFile.size > maxSize) {
      alert('File size must be less than 5MB');
      return;
    }

    setFile(selectedFile);

    // Create preview
    const reader = new FileReader();
    reader.onloadend = () => {
      setPreview(reader.result);
    };
    reader.readAsDataURL(selectedFile);
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!file) return;

    setUploading(true);

    try {
      const formData = new FormData();
      formData.append('file', file);
      formData.append('title', e.target.title.value);

      const response = await fetch('/api/upload', {
        method: 'POST',
        body: formData,
      });

      if (response.ok) {
        const data = await response.json();
        console.log('Upload successful:', data);
        // Reset form
        setFile(null);
        setPreview(null);
        e.target.reset();
      }
    } catch (error) {
      console.error('Upload error:', error);
    } finally {
      setUploading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input name="title" type="text" placeholder="Image title" required />
      
      <input
        type="file"
        accept="image/jpeg,image/png,image/gif"
        onChange={handleFileChange}
        required
      />

      {preview && (
        <div>
          <img src={preview} alt="Preview" style={{ maxWidth: '200px' }} />
        </div>
      )}

      <button type="submit" disabled={!file || uploading}>
        {uploading ? 'Uploading...' : 'Upload'}
      </button>
    </form>
  );
}
```

### Server Actions (Next.js 13+)

```jsx
// app/contact/page.jsx
import { revalidatePath } from 'next/cache';

// Server Action
async function submitForm(formData) {
  'use server';
  
  const name = formData.get('name');
  const email = formData.get('email');
  const message = formData.get('message');

  // Validate on server
  if (!name || !email || !message) {
    return { error: 'All fields are required' };
  }

  // Save to database
  try {
    await prisma.contact.create({
      data: { name, email, message },
    });

    // Revalidate the page
    revalidatePath('/contact');

    return { success: true, message: 'Form submitted successfully' };
  } catch (error) {
    return { error: 'Failed to submit form' };
  }
}

export default function ContactPage() {
  return (
    <form action={submitForm}>
      <input name="name" type="text" placeholder="Name" required />
      <input name="email" type="email" placeholder="Email" required />
      <textarea name="message" placeholder="Message" required />
      <button type="submit">Submit</button>
    </form>
  );
}
```

#### Server Actions with useFormState

```jsx
'use client';

import { useFormState } from 'react-dom';
import { submitForm } from './actions';

const initialState = {
  message: null,
  errors: {},
};

export default function ContactForm() {
  const [state, formAction] = useFormState(submitForm, initialState);

  return (
    <form action={formAction}>
      <input name="name" type="text" placeholder="Name" />
      {state?.errors?.name && (
        <p style={{ color: 'red' }}>{state.errors.name}</p>
      )}

      <input name="email" type="email" placeholder="Email" />
      {state?.errors?.email && (
        <p style={{ color: 'red' }}>{state.errors.email}</p>
      )}

      <textarea name="message" placeholder="Message" />
      {state?.errors?.message && (
        <p style={{ color: 'red' }}>{state.errors.message}</p>
      )}

      <button type="submit">Submit</button>

      {state?.message && (
        <p style={{ color: state.success ? 'green' : 'red' }}>
          {state.message}
        </p>
      )}
    </form>
  );
}

// actions.js
'use server';

import { z } from 'zod';

const schema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email'),
  message: z.string().min(10, 'Message must be at least 10 characters'),
});

export async function submitForm(prevState, formData) {
  const validatedFields = schema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    message: formData.get('message'),
  });

  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
      message: 'Invalid fields',
    };
  }

  try {
    // Save to database
    await prisma.contact.create({
      data: validatedFields.data,
    });

    return {
      success: true,
      message: 'Form submitted successfully!',
    };
  } catch (error) {
    return {
      message: 'Failed to submit form',
    };
  }
}
```

---

## 10.2 React Hook Form

### Installation and Basic Setup

```bash
npm install react-hook-form
```

### Basic Usage

```jsx
'use client';

import { useForm } from 'react-hook-form';

export default function BasicForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
  } = useForm();

  const onSubmit = async (data) => {
    console.log(data);
    
    // Submit to API
    await fetch('/api/contact', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });

    reset(); // Reset form after submission
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input
        {...register('name', {
          required: 'Name is required',
          minLength: {
            value: 2,
            message: 'Name must be at least 2 characters',
          },
        })}
        placeholder="Name"
      />
      {errors.name && <p style={{ color: 'red' }}>{errors.name.message}</p>}

      <input
        {...register('email', {
          required: 'Email is required',
          pattern: {
            value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
            message: 'Invalid email address',
          },
        })}
        placeholder="Email"
      />
      {errors.email && <p style={{ color: 'red' }}>{errors.email.message}</p>}

      <input
        type="number"
        {...register('age', {
          required: 'Age is required',
          min: {
            value: 18,
            message: 'Must be at least 18 years old',
          },
          max: {
            value: 120,
            message: 'Age must be realistic',
          },
        })}
        placeholder="Age"
      />
      {errors.age && <p style={{ color: 'red' }}>{errors.age.message}</p>}

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Submitting...' : 'Submit'}
      </button>
    </form>
  );
}
```

### Advanced Features

#### Watch Values

```jsx
'use client';

import { useForm } from 'react-hook-form';

export default function WatchExample() {
  const { register, watch } = useForm();

  // Watch specific field
  const firstName = watch('firstName');

  // Watch all fields
  const watchAll = watch();

  // Watch with callback
  const subscription = watch((value, { name, type }) => {
    console.log(value, name, type);
  });

  return (
    <form>
      <input {...register('firstName')} placeholder="First Name" />
      <input {...register('lastName')} placeholder="Last Name" />
      
      <p>First Name: {firstName}</p>
      <p>Full Form: {JSON.stringify(watchAll)}</p>
    </form>
  );
}
```

#### Conditional Fields

```jsx
'use client';

import { useForm } from 'react-hook-form';

export default function ConditionalForm() {
  const { register, watch, handleSubmit } = useForm();

  const hasShippingAddress = watch('hasShippingAddress');
  const country = watch('country');

  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('email')} type="email" placeholder="Email" />

      <label>
        <input {...register('hasShippingAddress')} type="checkbox" />
        Ship to different address
      </label>

      {hasShippingAddress && (
        <div>
          <input {...register('shippingAddress')} placeholder="Shipping Address" />
          <input {...register('shippingCity')} placeholder="City" />
        </div>
      )}

      <select {...register('country')}>
        <option value="">Select Country</option>
        <option value="us">United States</option>
        <option value="uk">United Kingdom</option>
        <option value="ca">Canada</option>
      </select>

      {country === 'us' && (
        <input {...register('state')} placeholder="State" />
      )}

      <button type="submit">Submit</button>
    </form>
  );
}
```

#### Array Fields

```jsx
'use client';

import { useForm, useFieldArray } from 'react-hook-form';

export default function ArrayFieldsForm() {
  const { register, control, handleSubmit } = useForm({
    defaultValues: {
      items: [{ name: '', quantity: 1 }],
    },
  });

  const { fields, append, remove } = useFieldArray({
    control,
    name: 'items',
  });

  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {fields.map((field, index) => (
        <div key={field.id}>
          <input
            {...register(`items.${index}.name`, { required: true })}
            placeholder="Item name"
          />
          <input
            type="number"
            {...register(`items.${index}.quantity`, {
              required: true,
              min: 1,
            })}
            placeholder="Quantity"
          />
          <button type="button" onClick={() => remove(index)}>
            Remove
          </button>
        </div>
      ))}

      <button
        type="button"
        onClick={() => append({ name: '', quantity: 1 })}
      >
        Add Item
      </button>

      <button type="submit">Submit</button>
    </form>
  );
}
```

#### Custom Validation

```jsx
'use client';

import { useForm } from 'react-hook-form';

export default function CustomValidationForm() {
  const {
    register,
    handleSubmit,
    formState: { errors },
    watch,
  } = useForm();

  const password = watch('password');

  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input
        {...register('username', {
          required: 'Username is required',
          validate: {
            minLength: (value) =>
              value.length >= 3 || 'Username must be at least 3 characters',
            noSpaces: (value) =>
              !/\s/.test(value) || 'Username cannot contain spaces',
            isAvailable: async (value) => {
              // Check username availability
              const response = await fetch(`/api/check-username?username=${value}`);
              const data = await response.json();
              return data.available || 'Username already taken';
            },
          },
        })}
        placeholder="Username"
      />
      {errors.username && (
        <p style={{ color: 'red' }}>{errors.username.message}</p>
      )}

      <input
        type="password"
        {...register('password', {
          required: 'Password is required',
          minLength: {
            value: 8,
            message: 'Password must be at least 8 characters',
          },
          validate: {
            hasUpperCase: (value) =>
              /[A-Z]/.test(value) || 'Must contain uppercase letter',
            hasLowerCase: (value) =>
              /[a-z]/.test(value) || 'Must contain lowercase letter',
            hasNumber: (value) =>
              /[0-9]/.test(value) || 'Must contain number',
            hasSpecial: (value) =>
              /[!@#$%^&*]/.test(value) || 'Must contain special character',
          },
        })}
        placeholder="Password"
      />
      {errors.password && (
        <p style={{ color: 'red' }}>{errors.password.message}</p>
      )}

      <input
        type="password"
        {...register('confirmPassword', {
          required: 'Please confirm password',
          validate: (value) =>
            value === password || 'Passwords do not match',
        })}
        placeholder="Confirm Password"
      />
      {errors.confirmPassword && (
        <p style={{ color: 'red' }}>{errors.confirmPassword.message}</p>
      )}

      <button type="submit">Submit</button>
    </form>
  );
}
```

#### Error Handling

```jsx
'use client';

import { useForm } from 'react-hook-form';
import { useState } from 'react';

export default function ErrorHandlingForm() {
  const {
    register,
    handleSubmit,
    formState: { errors },
    setError,
    clearErrors,
  } = useForm();

  const [serverError, setServerError] = useState('');

  const onSubmit = async (data) => {
    try {
      const response = await fetch('/api/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (!response.ok) {
        // Set server errors on specific fields
        if (result.errors) {
          Object.keys(result.errors).forEach((key) => {
            setError(key, {
              type: 'server',
              message: result.errors[key],
            });
          });
        } else {
          setServerError(result.message);
        }
      }
    } catch (error) {
      setServerError('An unexpected error occurred');
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {serverError && (
        <div style={{ color: 'red', marginBottom: '10px' }}>
          {serverError}
        </div>
      )}

      <input
        {...register('email', {
          required: 'Email is required',
          pattern: {
            value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
            message: 'Invalid email',
          },
        })}
        placeholder="Email"
        onFocus={() => {
          clearErrors('email');
          setServerError('');
        }}
      />
      {errors.email && (
        <p style={{ color: 'red' }}>{errors.email.message}</p>
      )}

      <button type="submit">Submit</button>
    </form>
  );
}
```

---

## 10.3 Validation Libraries

### Zod Integration

```bash
npm install zod @hookform/resolvers
```

#### Basic Zod Schema

```javascript
// lib/validations.js
import { z } from 'zod';

export const userSchema = z.object({
  name: z.string()
    .min(2, 'Name must be at least 2 characters')
    .max(50, 'Name must be less than 50 characters'),
  
  email: z.string()
    .email('Invalid email address'),
  
  age: z.number()
    .min(18, 'Must be at least 18 years old')
    .max(120, 'Age must be realistic'),
  
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Must contain uppercase letter')
    .regex(/[a-z]/, 'Must contain lowercase letter')
    .regex(/[0-9]/, 'Must contain number')
    .regex(/[^A-Za-z0-9]/, 'Must contain special character'),
  
  confirmPassword: z.string(),
  
  terms: z.boolean()
    .refine((val) => val === true, 'You must accept terms'),
}).refine((data) => data.password === data.confirmPassword, {
  message: 'Passwords do not match',
  path: ['confirmPassword'],
});

export type UserFormData = z.infer<typeof userSchema>;
```

#### Using Zod with React Hook Form

```jsx
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { userSchema } from '@/lib/validations';

export default function ZodForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm({
    resolver: zodResolver(userSchema),
  });

  const onSubmit = async (data) => {
    console.log(data);
    // Data is fully validated and type-safe
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('name')} placeholder="Name" />
      {errors.name && <p style={{ color: 'red' }}>{errors.name.message}</p>}

      <input {...register('email')} type="email" placeholder="Email" />
      {errors.email && <p style={{ color: 'red' }}>{errors.email.message}</p>}

      <input
        {...register('age', { valueAsNumber: true })}
        type="number"
        placeholder="Age"
      />
      {errors.age && <p style={{ color: 'red' }}>{errors.age.message}</p>}

      <input
        {...register('password')}
        type="password"
        placeholder="Password"
      />
      {errors.password && (
        <p style={{ color: 'red' }}>{errors.password.message}</p>
      )}

      <input
        {...register('confirmPassword')}
        type="password"
        placeholder="Confirm Password"
      />
      {errors.confirmPassword && (
        <p style={{ color: 'red' }}>{errors.confirmPassword.message}</p>
      )}

      <label>
        <input {...register('terms')} type="checkbox" />
        I accept the terms and conditions
      </label>
      {errors.terms && <p style={{ color: 'red' }}>{errors.terms.message}</p>}

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Submitting...' : 'Submit'}
      </button>
    </form>
  );
}
```

#### Advanced Zod Schemas

```javascript
// lib/validations.js
import { z } from 'zod';

// Nested objects
export const addressSchema = z.object({
  street: z.string().min(1, 'Street is required'),
  city: z.string().min(1, 'City is required'),
  state: z.string().length(2, 'State must be 2 characters'),
  zip: z.string().regex(/^\d{5}$/, 'Invalid ZIP code'),
});

export const profileSchema = z.object({
  name: z.string().min(2),
  address: addressSchema,
  phone: z.string()
    .regex(/^\+?[1-9]\d{1,14}$/, 'Invalid phone number')
    .optional(),
});

// Arrays
export const orderSchema = z.object({
  items: z.array(
    z.object({
      productId: z.string().uuid(),
      quantity: z.number().min(1).max(100),
      price: z.number().positive(),
    })
  ).min(1, 'Order must have at least one item'),
  
  total: z.number().positive(),
}).refine(
  (data) => {
    const calculatedTotal = data.items.reduce(
      (sum, item) => sum + item.price * item.quantity,
      0
    );
    return Math.abs(calculatedTotal - data.total) < 0.01;
  },
  {
    message: 'Total does not match items',
    path: ['total'],
  }
);

// Union types
export const paymentSchema = z.object({
  method: z.enum(['card', 'paypal', 'bank']),
  details: z.discriminatedUnion('method', [
    z.object({
      method: z.literal('card'),
      cardNumber: z.string().length(16),
      cvv: z.string().length(3),
      expiry: z.string().regex(/^\d{2}\/\d{2}$/),
    }),
    z.object({
      method: z.literal('paypal'),
      email: z.string().email(),
    }),
    z.object({
      method: z.literal('bank'),
      accountNumber: z.string(),
      routingNumber: z.string(),
    }),
  ]),
});

// Custom refinements
export const eventSchema = z.object({
  title: z.string().min(1),
  startDate: z.date(),
  endDate: z.date(),
}).refine(
  (data) => data.endDate > data.startDate,
  {
    message: 'End date must be after start date',
    path: ['endDate'],
  }
);

// Transform
export const searchSchema = z.object({
  query: z.string()
    .transform((val) => val.trim().toLowerCase()),
  
  tags: z.string()
    .transform((val) => val.split(',').map(tag => tag.trim()))
    .pipe(z.array(z.string()).min(1)),
  
  page: z.string()
    .transform((val) => parseInt(val, 10))
    .pipe(z.number().min(1)),
});
```

### Server-Side Validation

```javascript
// app/api/register/route.js
import { NextResponse } from 'next/server';
import { userSchema } from '@/lib/validations';

export async function POST(request) {
  try {
    const body = await request.json();
    
    // Validate with Zod
    const validatedData = userSchema.parse(body);
    
    // Safe to use validatedData - it's fully validated
    // Create user...
    
    return NextResponse.json({ success: true });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          errors: error.errors.map((err) => ({
            path: err.path.join('.'),
            message: err.message,
          })),
        },
        { status: 400 }
      );
    }
    
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

---

## 10.4 Server Actions with Validation

### Complete Example with Server Actions

```jsx
// app/register/page.jsx
'use client';

import { useFormState } from 'react-dom';
import { useFormStatus } from 'react-dom';
import { registerUser } from './actions';

function SubmitButton() {
  const { pending } = useFormStatus();
  
  return (
    <button type="submit" disabled={pending}>
      {pending ? 'Registering...' : 'Register'}
    </button>
  );
}

export default function RegisterPage() {
  const [state, formAction] = useFormState(registerUser, {
    errors: {},
    message: null,
  });

  return (
    <form action={formAction}>
      <div>
        <input name="name" placeholder="Name" defaultValue="" />
        {state.errors?.name && (
          <p style={{ color: 'red' }}>{state.errors.name[0]}</p>
        )}
      </div>

      <div>
        <input name="email" type="email" placeholder="Email" defaultValue="" />
        {state.errors?.email && (
          <p style={{ color: 'red' }}>{state.errors.email[0]}</p>
        )}
      </div>

      <div>
        <input
          name="password"
          type="password"
          placeholder="Password"
          defaultValue=""
        />
        {state.errors?.password && (
          <p style={{ color: 'red' }}>{state.errors.password[0]}</p>
        )}
      </div>

      <div>
        <input
          name="confirmPassword"
          type="password"
          placeholder="Confirm Password"
          defaultValue=""
        />
        {state.errors?.confirmPassword && (
          <p style={{ color: 'red' }}>{state.errors.confirmPassword[0]}</p>
        )}
      </div>

      <SubmitButton />

      {state.message && (
        <p style={{ color: state.success ? 'green' : 'red' }}>
          {state.message}
        </p>
      )}
    </form>
  );
}

// actions.js
'use server';

import { z } from 'zod';
import { redirect } from 'next/navigation';
import { revalidatePath } from 'next/cache';
import bcrypt from 'bcryptjs';
import { prisma } from '@/lib/prisma';

const registerSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Must contain uppercase')
    .regex(/[a-z]/, 'Must contain lowercase')
    .regex(/[0-9]/, 'Must contain number'),
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: 'Passwords do not match',
  path: ['confirmPassword'],
});

export async function registerUser(prevState, formData) {
  // Parse form data
  const rawData = {
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
    confirmPassword: formData.get('confirmPassword'),
  };

  // Validate
  const validatedFields = registerSchema.safeParse(rawData);

  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
      message: 'Please fix the errors below',
    };
  }

  // Check if user exists
  const existingUser = await prisma.user.findUnique({
    where: { email: validatedFields.data.email },
  });

  if (existingUser) {
    return {
      errors: {
        email: ['Email already registered'],
      },
      message: 'Email already in use',
    };
  }

  try {
    // Hash password
    const hashedPassword = await bcrypt.hash(validatedFields.data.password, 12);

    // Create user
    await prisma.user.create({
      data: {
        name: validatedFields.data.name,
        email: validatedFields.data.email,
        hashedPassword,
      },
    });

    // Revalidate and redirect
    revalidatePath('/');
    redirect('/login?registered=true');
  } catch (error) {
    return {
      message: 'Failed to create account. Please try again.',
    };
  }
}
```

### Multi-Step Form with Server Actions

```jsx
'use client';

import { useState } from 'react';
import { useFormState } from 'react-dom';
import { submitMultiStepForm } from './actions';

export default function MultiStepForm() {
  const [step, setStep] = useState(1);
  const [formData, setFormData] = useState({});
  const [state, formAction] = useFormState(submitMultiStepForm, null);

  const updateFormData = (newData) => {
    setFormData((prev) => ({ ...prev, ...newData }));
  };

  const handleStep1Submit = (e) => {
    e.preventDefault();
    const data = new FormData(e.currentTarget);
    updateFormData({
      name: data.get('name'),
      email: data.get('email'),
    });
    setStep(2);
  };

  const handleStep2Submit = (e) => {
    e.preventDefault();
    const data = new FormData(e.currentTarget);
    updateFormData({
      address: data.get('address'),
      city: data.get('city'),
    });
    setStep(3);
  };

  const handleFinalSubmit = (e) => {
    e.preventDefault();
    const data = new FormData(e.currentTarget);
    const finalData = {
      ...formData,
      cardNumber: data.get('cardNumber'),
      cvv: data.get('cvv'),
    };

    // Create FormData for server action
    const formDataForAction = new FormData();
    Object.entries(finalData).forEach(([key, value]) => {
      formDataForAction.append(key, value);
    });

    formAction(formDataForAction);
  };

  return (
    <div>
      <div>Step {step} of 3</div>

      {step === 1 && (
        <form onSubmit={handleStep1Submit}>
          <h2>Personal Information</h2>
          <input name="name" defaultValue={formData.name} placeholder="Name" required />
          <input name="email" type="email" defaultValue={formData.email} placeholder="Email" required />
          <button type="submit">Next</button>
        </form>
      )}

      {step === 2 && (
        <form onSubmit={handleStep2Submit}>
          <h2>Address</h2>
          <input name="address" defaultValue={formData.address} placeholder="Address" required />
          <input name="city" defaultValue={formData.city} placeholder="City" required />
          <button type="button" onClick={() => setStep(1)}>Back</button>
          <button type="submit">Next</button>
        </form>
      )}

      {step === 3 && (
        <form onSubmit={handleFinalSubmit}>
          <h2>Payment</h2>
          <input name="cardNumber" placeholder="Card Number" required />
          <input name="cvv" placeholder="CVV" required />
          <button type="button" onClick={() => setStep(2)}>Back</button>
          <button type="submit">Submit</button>
        </form>
      )}

      {state?.message && <p>{state.message}</p>}
    </div>
  );
}
```

This completes all four chapters (7-10) with comprehensive, production-ready examples!