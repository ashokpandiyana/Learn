# Chapter 18: Interview Preparation Topics - In Depth

## 18.1 Core Concepts Questions

### Question 1: Explain the differences between SSR, SSG, and ISR

**Expected Answer Structure:**

**Server-Side Rendering (SSR)**
- **What**: HTML is generated on the server for each request
- **When to use**: Dynamic content that changes frequently, user-specific data, real-time data
- **How in Next.js**:
  ```tsx
  // Pages Router
  export async function getServerSideProps(context) {
    const res = await fetch('https://api.example.com/data');
    const data = await res.json();
    return { props: { data } };
  }
  
  // App Router - Dynamic rendering
  async function getData() {
    const res = await fetch('https://api.example.com/data', {
      cache: 'no-store' // Forces dynamic rendering
    });
    return res.json();
  }
  
  export default async function Page() {
    const data = await getData();
    return <div>{data.title}</div>;
  }
  ```

- **Pros**: Always fresh data, good for personalized content
- **Cons**: Slower TTFB (Time to First Byte), higher server load
- **Interview Insight**: "SSR is ideal when you need fresh data on every request, like a user dashboard with real-time updates."

**Static Site Generation (SSG)**
- **What**: HTML is generated at build time
- **When to use**: Content that rarely changes, blog posts, marketing pages
- **How in Next.js**:
  ```tsx
  // Pages Router
  export async function getStaticProps() {
    const res = await fetch('https://api.example.com/posts');
    const posts = await res.json();
    return { props: { posts } };
  }
  
  // For dynamic routes
  export async function getStaticPaths() {
    const res = await fetch('https://api.example.com/posts');
    const posts = await res.json();
    
    const paths = posts.map(post => ({
      params: { id: post.id.toString() }
    }));
    
    return { paths, fallback: false };
  }
  
  // App Router - Static rendering (default)
  async function getPosts() {
    const res = await fetch('https://api.example.com/posts', {
      cache: 'force-cache' // Static at build time
    });
    return res.json();
  }
  
  export default async function PostsPage() {
    const posts = await getPosts();
    return <PostList posts={posts} />;
  }
  ```

- **Pros**: Fastest performance, can be CDN-cached, low server load
- **Cons**: Stale data, need to rebuild to update
- **Interview Insight**: "SSG gives you the best performance because the page is pre-built and served from CDN, but it's only suitable when data doesn't change often."

**Incremental Static Regeneration (ISR)**
- **What**: Combines SSG with ability to update static pages after build
- **When to use**: Content that changes periodically but not on every request
- **How in Next.js**:
  ```tsx
  // Pages Router
  export async function getStaticProps() {
    const res = await fetch('https://api.example.com/products');
    const products = await res.json();
    
    return {
      props: { products },
      revalidate: 60 // Revalidate every 60 seconds
    };
  }
  
  // App Router
  export const revalidate = 60; // Revalidate every 60 seconds
  
  async function getProducts() {
    const res = await fetch('https://api.example.com/products');
    return res.json();
  }
  
  export default async function ProductsPage() {
    const products = await getProducts();
    return <ProductList products={products} />;
  }
  ```

- **On-Demand Revalidation**:
  ```tsx
  // app/api/revalidate/route.ts
  import { revalidatePath, revalidateTag } from 'next/cache';
  
  export async function POST(request: Request) {
    const { path, tag } = await request.json();
    
    if (path) {
      revalidatePath(path);
    }
    
    if (tag) {
      revalidateTag(tag);
    }
    
    return Response.json({ revalidated: true });
  }
  ```

- **Pros**: Best of both worlds - fast like SSG, fresh like SSR
- **Cons**: Slight complexity, first visitor after revalidation might see old content briefly
- **Interview Insight**: "ISR is my go-to for most production apps - you get CDN-level performance but can update content without rebuilding. It's perfect for e-commerce product pages."

**Comparison Table**:
```
| Feature          | SSR            | SSG           | ISR                |
|------------------|----------------|---------------|--------------------|
| Build Time       | N/A            | Long          | Long (first time)  |
| Request Time     | Slow           | Instant       | Instant            |
| Data Freshness   | Always fresh   | Stale         | Periodically fresh |
| Server Load      | High           | None          | Low                |
| Best For         | Dashboards     | Blogs         | E-commerce         |
```

---

### Question 2: Explain Server Components vs Client Components

**Deep Dive Answer:**

**Server Components (Default in App Router)**

```tsx
// This is a Server Component by default (no 'use client')
import { db } from '@/lib/db';

export default async function ProductPage({ params }) {
  // This runs ONLY on the server
  const product = await db.product.findUnique({
    where: { id: params.id }
  });
  
  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
    </div>
  );
}
```

**Key Characteristics:**
- Render only on the server
- Can directly access backend resources (databases, file system)
- Can use async/await at component level
- Zero JavaScript sent to client for these components
- Cannot use browser APIs (localStorage, addEventListener)
- Cannot use React hooks (useState, useEffect)
- Better for SEO

**Client Components**

```tsx
'use client'; // Required directive

import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}
```

**Key Characteristics:**
- Can use React hooks
- Can use browser APIs
- Enable interactivity
- JavaScript bundle sent to client
- Rendered on both server (initial) and client (hydration)

**Composition Patterns**:

```tsx
// ✅ CORRECT: Server Component imports Client Component
// app/page.tsx (Server Component)
import ClientCounter from './ClientCounter';

export default async function Page() {
  const data = await fetchData(); // Server-side only
  
  return (
    <div>
      <h1>Server Content: {data.title}</h1>
      <ClientCounter /> {/* Client Component */}
    </div>
  );
}

// app/ClientCounter.tsx
'use client';
export default function ClientCounter() { /* ... */ }
```

```tsx
// ❌ WRONG: Client Component trying to import Server Component
'use client';

import ServerComponent from './ServerComponent'; // Won't work!

export default function ClientComponent() {
  return <ServerComponent />;
}
```

```tsx
// ✅ CORRECT: Pass Server Component as children to Client Component
// app/page.tsx (Server Component)
import ClientWrapper from './ClientWrapper';
import ServerContent from './ServerContent';

export default function Page() {
  return (
    <ClientWrapper>
      <ServerContent /> {/* Works because passed as children */}
    </ClientWrapper>
  );
}

// app/ClientWrapper.tsx
'use client';
export default function ClientWrapper({ children }) {
  const [isOpen, setIsOpen] = useState(false);
  
  return (
    <div>
      <button onClick={() => setIsOpen(!isOpen)}>Toggle</button>
      {isOpen && children}
    </div>
  );
}
```

**Interview Key Points:**
- "Server Components are the default and preferred. I only use 'use client' when I need interactivity or browser APIs."
- "Server Components reduce JavaScript bundle size significantly - they don't ship to the client at all."
- "You can't import Server Components into Client Components, but you can pass them as props/children."

---

### Question 3: Explain the Hydration Process

**Visual Explanation:**

```
1. Server-Side Render (SSR Phase)
   ┌─────────────┐
   │   Server    │
   │             │  Renders React components to HTML
   │  React App  │ ─────────────────────────────────►  HTML String
   │             │
   └─────────────┘

2. HTML Sent to Browser
   ┌─────────────┐
   │   Browser   │
   │             │  Receives and displays HTML
   │    HTML     │  (User sees content immediately!)
   │             │
   └─────────────┘

3. JavaScript Downloaded
   ┌─────────────┐
   │   Browser   │
   │             │  Downloads React bundle
   │  HTML + JS  │
   │             │
   └─────────────┘

4. Hydration
   ┌─────────────┐
   │   Browser   │  React "hydrates" the HTML
   │             │  - Attaches event listeners
   │ Interactive │  - Initializes state
   │   React     │  - Makes it interactive
   └─────────────┘
```

**Code Example Showing Hydration Mismatch:**

```tsx
// ❌ BAD: Causes hydration mismatch
'use client';

export default function TimeDisplay() {
  // Server renders one time, client renders different time
  return <div>Current time: {new Date().toLocaleTimeString()}</div>;
}

// Error: Hydration failed because the initial UI does not match 
// what was rendered on the server.
```

**Fix Options:**

```tsx
// ✅ Option 1: Use useEffect (only runs on client)
'use client';

import { useState, useEffect } from 'react';

export default function TimeDisplay() {
  const [time, setTime] = useState<string | null>(null);
  
  useEffect(() => {
    setTime(new Date().toLocaleTimeString());
  }, []);
  
  if (!time) return <div>Current time: Loading...</div>;
  return <div>Current time: {time}</div>;
}
```

```tsx
// ✅ Option 2: Suppress hydration warning (use sparingly)
'use client';

export default function TimeDisplay() {
  return (
    <div suppressHydrationWarning>
      Current time: {new Date().toLocaleTimeString()}
    </div>
  );
}
```

```tsx
// ✅ Option 3: Use dynamic import with ssr: false
import dynamic from 'next/dynamic';

const TimeDisplay = dynamic(() => import('./TimeDisplay'), {
  ssr: false,
  loading: () => <div>Loading time...</div>
});

export default function Page() {
  return <TimeDisplay />;
}
```

**Interview Points:**
- "Hydration is when React attaches to the server-rendered HTML and makes it interactive"
- "The HTML sent from server must match what React renders on client, or you get hydration mismatches"
- "Common causes: using random values, Date.now(), or browser-only APIs during render"

---

### Question 4: How does Next.js routing work?

**File-System Based Routing:**

```
app/
├── page.tsx                    → /
├── about/
│   └── page.tsx               → /about
├── blog/
│   ├── page.tsx               → /blog
│   └── [slug]/
│       └── page.tsx           → /blog/:slug
├── products/
│   ├── [...categories]/
│   │   └── page.tsx           → /products/* (catch-all)
│   └── [[...categories]]/
│       └── page.tsx           → /products (optional catch-all)
└── dashboard/
    ├── layout.tsx             → Shared layout
    ├── page.tsx               → /dashboard
    └── settings/
        └── page.tsx           → /dashboard/settings
```

**Dynamic Routes Example:**

```tsx
// app/blog/[slug]/page.tsx
type Props = {
  params: { slug: string };
  searchParams: { [key: string]: string | string[] | undefined };
};

export default async function BlogPost({ params, searchParams }: Props) {
  const post = await getPost(params.slug);
  const comments = searchParams.comments === 'true';
  
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
      {comments && <Comments postId={post.id} />}
    </article>
  );
}

// Generate static params for SSG
export async function generateStaticParams() {
  const posts = await getAllPosts();
  
  return posts.map((post) => ({
    slug: post.slug,
  }));
}

// Generate metadata
export async function generateMetadata({ params }: Props) {
  const post = await getPost(params.slug);
  
  return {
    title: post.title,
    description: post.excerpt,
  };
}
```

**Catch-All Routes:**

```tsx
// app/docs/[...slug]/page.tsx
// Matches: /docs/a, /docs/a/b, /docs/a/b/c

export default function DocsPage({
  params
}: {
  params: { slug: string[] }
}) {
  // params.slug is an array: ['a', 'b', 'c']
  const path = params.slug.join('/');
  return <div>Docs path: {path}</div>;
}
```

```tsx
// app/shop/[[...categories]]/page.tsx
// Matches: /shop, /shop/electronics, /shop/electronics/phones

export default function ShopPage({
  params
}: {
  params: { categories?: string[] }
}) {
  const categories = params.categories || [];
  
  if (categories.length === 0) {
    return <AllProducts />;
  }
  
  return <CategoryProducts categories={categories} />;
}
```

**Route Groups (Don't affect URL):**

```
app/
├── (marketing)/           → Route group (not in URL)
│   ├── layout.tsx         → Shared layout for marketing
│   ├── page.tsx          → /
│   └── about/
│       └── page.tsx      → /about
├── (shop)/               → Different route group
│   ├── layout.tsx         → Different layout
│   └── products/
│       └── page.tsx      → /products
└── (auth)/
    ├── login/
    │   └── page.tsx      → /login
    └── register/
        └── page.tsx      → /register
```

---

## 18.2 Performance Questions

### Question: How would you optimize a slow Next.js page?

**Systematic Approach:**

**Step 1: Identify the Problem**

```tsx
// Use React Profiler
'use client';

import { Profiler } from 'react';

export default function Page() {
  const onRenderCallback = (
    id, phase, actualDuration, baseDuration, startTime, commitTime
  ) => {
    console.log({
      id, phase, actualDuration, baseDuration, startTime, commitTime
    });
  };

  return (
    <Profiler id="PageProfiler" onRender={onRenderCallback}>
      <YourComponent />
    </Profiler>
  );
}
```

**Step 2: Optimize Images**

```tsx
// ❌ Before
<img src="/hero.jpg" alt="Hero" width="1200" height="600" />

// ✅ After
import Image from 'next/image';

<Image
  src="/hero.jpg"
  alt="Hero"
  width={1200}
  height={600}
  priority // For above-the-fold images
  placeholder="blur"
  blurDataURL="data:image/jpeg;base64,..." // Low-quality placeholder
  sizes="(max-width: 768px) 100vw, 1200px"
/>
```

**Step 3: Implement Code Splitting**

```tsx
// ❌ Before: Large component loaded immediately
import HeavyChart from '@/components/HeavyChart';

export default function Dashboard() {
  return <HeavyChart data={data} />;
}

// ✅ After: Lazy load heavy components
import dynamic from 'next/dynamic';

const HeavyChart = dynamic(() => import('@/components/HeavyChart'), {
  loading: () => <div>Loading chart...</div>,
  ssr: false // Don't render on server if not needed
});

export default function Dashboard() {
  return <HeavyChart data={data} />;
}
```

**Step 4: Optimize Data Fetching**

```tsx
// ❌ Before: Sequential fetches (waterfall)
export default async function Page() {
  const user = await fetchUser();
  const posts = await fetchPosts(user.id);
  const comments = await fetchComments(posts[0].id);
  
  return <div>...</div>;
}

// ✅ After: Parallel fetches
export default async function Page() {
  const [user, postsData, commentsData] = await Promise.all([
    fetchUser(),
    fetchPosts(),
    fetchComments()
  ]);
  
  return <div>...</div>;
}
```

**Step 5: Use Streaming with Suspense**

```tsx
import { Suspense } from 'react';

async function SlowComponent() {
  const data = await fetchSlowData();
  return <div>{data}</div>;
}

export default function Page() {
  return (
    <div>
      <h1>Page loads immediately</h1>
      <Suspense fallback={<div>Loading slow data...</div>}>
        <SlowComponent />
      </Suspense>
    </div>
  );
}
```

**Step 6: Optimize Bundle Size**

```bash
# Analyze bundle
npm run build
# Then check .next/server and .next/static

# Use bundle analyzer
npm install @next/bundle-analyzer

# next.config.js
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
});

module.exports = withBundleAnalyzer({
  // your config
});

# Run
ANALYZE=true npm run build
```

**Step 7: Implement Proper Caching**

```tsx
// Aggressive caching for static data
export const revalidate = 3600; // Cache for 1 hour

async function getData() {
  const res = await fetch('https://api.example.com/data', {
    next: { 
      revalidate: 3600,
      tags: ['products'] // For on-demand revalidation
    }
  });
  return res.json();
}
```

**Interview Answer Template:**
"I would approach performance optimization systematically:
1. Profile to identify bottlenecks using Chrome DevTools and React Profiler
2. Optimize images with next/image
3. Implement code splitting for large components
4. Parallelize data fetching to avoid waterfalls
5. Use Suspense and streaming for progressive loading
6. Analyze and reduce bundle size
7. Implement proper caching strategies
8. Monitor Core Web Vitals in production"

---

## 18.3 Architecture Questions

### Question: Design a multi-tenant SaaS application architecture in Next.js

**Solution:**

```typescript
// Subdomain-based multi-tenancy architecture

// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  const hostname = request.headers.get('host');
  const url = request.nextUrl;

  // Extract subdomain
  const subdomain = hostname?.split('.')[0];
  
  // Custom domain support
  const customDomains = await getCustomDomains();
  const tenant = customDomains[hostname] || subdomain;

  // Add tenant to headers for use in app
  const requestHeaders = new Headers(request.headers);
  requestHeaders.set('x-tenant-id', tenant);

  return NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  });
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
};
```

```typescript
// lib/tenant.ts
import { headers } from 'next/headers';
import { cache } from 'react';

export const getTenant = cache(async () => {
  const headersList = headers();
  const tenantId = headersList.get('x-tenant-id');
  
  if (!tenantId) throw new Error('No tenant found');
  
  // Fetch tenant config from database
  const tenant = await db.tenant.findUnique({
    where: { subdomain: tenantId },
    include: { settings: true, features: true }
  });
  
  return tenant;
});
```

```typescript
// app/page.tsx
import { getTenant } from '@/lib/tenant';

export default async function HomePage() {
  const tenant = await getTenant();
  
  return (
    <div>
      <h1>{tenant.name}</h1>
      <p>Theme: {tenant.settings.theme}</p>
    </div>
  );
}
```

```typescript
// lib/db.ts - Tenant-scoped database queries
import { getTenant } from './tenant';
import { Prisma } from '@prisma/client';

export async function getTenantDb() {
  const tenant = await getTenant();
  
  // Create a Prisma client extension for tenant filtering
  return prisma.$extends({
    query: {
      $allModels: {
        async findMany({ args, query }) {
          args.where = { ...args.where, tenantId: tenant.id };
          return query(args);
        },
        async findFirst({ args, query }) {
          args.where = { ...args.where, tenantId: tenant.id };
          return query(args);
        },
        async create({ args, query }) {
          args.data = { ...args.data, tenantId: tenant.id };
          return query(args);
        },
      },
    },
  });
}
```

```typescript
// Usage
import { getTenantDb } from '@/lib/db';

export default async function UsersPage() {
  const db = await getTenantDb();
  
  // Automatically filtered by tenantId
  const users = await db.user.findMany();
  
  return <UserList users={users} />;
}
```

**Key Architecture Points:**
- Subdomain-based tenant identification
- Tenant context available server-side via headers
- Database-level tenant isolation
- Custom domain support
- Feature flags per tenant
- Shared infrastructure with data isolation

---

## 18.4 Practical Coding Challenges

### Challenge 1: Build an Infinite Scroll with SSR

```tsx
// app/posts/page.tsx
import { Suspense } from 'react';
import InfinitePostList from './InfinitePostList';

async function getInitialPosts() {
  const res = await fetch('https://api.example.com/posts?page=1');
  return res.json();
}

export default async function PostsPage() {
  const initialPosts = await getInitialPosts();
  
  return (
    <div>
      <h1>Posts</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <InfinitePostList initialPosts={initialPosts} />
      </Suspense>
    </div>
  );
}
```

```tsx
// app/posts/InfinitePostList.tsx
'use client';

import { useState, useEffect, useRef } from 'react';

type Post = {
  id: string;
  title: string;
  content: string;
};

export default function InfinitePostList({ 
  initialPosts 
}: { 
  initialPosts: Post[] 
}) {
  const [posts, setPosts] = useState<Post[]>(initialPosts);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  const observerTarget = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !loading) {
          loadMore();
        }
      },
      { threshold: 1.0 }
    );

    if (observerTarget.current) {
      observer.observe(observerTarget.current);
    }

    return () => observer.disconnect();
  }, [hasMore, loading, page]);

  const loadMore = async () => {
    setLoading(true);
    
    try {
      const res = await fetch(`/api/posts?page=${page + 1}`);
      const newPosts = await res.json();
      
      if (newPosts.length === 0) {
        setHasMore(false);
      } else {
        setPosts(prev => [...prev, ...newPosts]);
        setPage(prev => prev + 1);
      }
    } catch (error) {
      console.error('Error loading posts:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      {posts.map(post => (
        <article key={post.id} className="post">
          <h2>{post.title}</h2>
          <p>{post.content}</p>
        </article>
      ))}
      
      <div ref={observerTarget} className="h-10">
        {loading && <div>Loading more...</div>}
        {!hasMore && <div>No more posts</div>}
      </div>
    </div>
  );
}
```

### Challenge 2: Implement Optimistic Updates

```tsx
// app/todos/TodoList.tsx
'use client';

import { useOptimistic, useTransition } from 'react';
import { addTodo, deleteTodo } from './actions';

type Todo = {
  id: string;
  text: string;
  completed: boolean;
};

export default function TodoList({ initialTodos }: { initialTodos: Todo[] }) {
  const [optimisticTodos, addOptimisticTodo] = useOptimistic(
    initialTodos,
    (state, newTodo: Todo) => [...state, newTodo]
  );
  
  const [isPending, startTransition] = useTransition();

  const handleAddTodo = async (formData: FormData) => {
    const text = formData.get('text') as string;
    const tempId = `temp-${Date.now()}`;
    
    // Optimistically add todo
    startTransition(() => {
      addOptimisticTodo({
        id: tempId,
        text,
        completed: false
      });
    });

    // Actually add to database
    await addTodo(text);
  };

  const handleDelete = async (id: string) => {
    startTransition(() => {
      addOptimisticTodo(
        optimisticTodos.filter(todo => todo.id !== id)
      );
    });

    await deleteTodo(id);
  };

  return (
    <div>
      <form action={handleAddTodo}>
        <input name="text" required />
        <button type="submit" disabled={isPending}>
          Add Todo
        </button>
      </form>

      <ul>
        {optimisticTodos.map(todo => (
          <li key={todo.id}>
            {todo.text}
            <button onClick={() => handleDelete(todo.id)}>
              Delete
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

```typescript
// app/todos/actions.ts
'use server';

import { revalidatePath } from 'next/cache';
import { db } from '@/lib/db';

export async function addTodo(text: string) {
  await db.todo.create({
    data: { text, completed: false }
  });
  
  revalidatePath('/todos');
}

export async function deleteTodo(id: string) {
  await db.todo.delete({
    where: { id }
  });
  
  revalidatePath('/todos');
}
```

This chapter provides you with comprehensive answers and code examples for the most common Next.js interview questions!