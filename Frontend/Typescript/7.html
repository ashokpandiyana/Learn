<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 7: Hooks with TypeScript</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #e4e4e7;
      line-height: 1.7;
      padding: 40px 20px;
      min-height: 100vh;
    }
    .container { max-width: 900px; margin: 0 auto; }
    h1 {
      font-size: 2.5rem;
      background: linear-gradient(90deg, #8b5cf6, #ec4899);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 10px;
    }
    .subtitle { color: #94a3b8; font-size: 1.1rem; margin-bottom: 40px; }
    .section {
      background: rgba(255,255,255,0.05);
      border-radius: 16px;
      padding: 30px;
      margin-bottom: 30px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    h2 {
      color: #a78bfa;
      font-size: 1.5rem;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    h2::before {
      content: '';
      width: 4px;
      height: 24px;
      background: linear-gradient(180deg, #8b5cf6, #ec4899);
      border-radius: 2px;
    }
    h3 { color: #c4b5fd; font-size: 1.2rem; margin: 25px 0 15px; }
    h4 { color: #ddd6fe; margin: 15px 0 10px; }
    p { margin-bottom: 15px; color: #cbd5e1; }
    .code-block {
      background: #0f172a;
      border-radius: 12px;
      padding: 20px;
      margin: 15px 0;
      overflow-x: auto;
      border: 1px solid #334155;
    }
    pre { font-family: 'Fira Code', 'Consolas', monospace; font-size: 14px; line-height: 1.6; }
    .keyword { color: #c678dd; }
    .type { color: #e5c07b; }
    .string { color: #98c379; }
    .number { color: #d19a66; }
    .comment { color: #5c6370; font-style: italic; }
    .function { color: #61afef; }
    .variable { color: #e06c75; }
    .tag { color: #e06c75; }
    .attr { color: #d19a66; }
    .alert {
      padding: 20px;
      border-radius: 12px;
      margin: 20px 0;
      display: flex;
      gap: 15px;
      align-items: flex-start;
    }
    .alert-interview { background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); }
    .alert-tip { background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.3); }
    .alert-note { background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); }
    .alert-icon { font-size: 1.5rem; }
    .alert-content h4 { color: #f87171; margin-bottom: 5px; }
    .alert-tip .alert-content h4 { color: #4ade80; }
    .alert-note .alert-content h4 { color: #60a5fa; }
    .visual-box {
      background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(236,72,153,0.1));
      border-radius: 12px;
      padding: 25px;
      margin: 20px 0;
      border: 1px solid rgba(167,139,250,0.3);
    }
    .visual-title { color: #a78bfa; font-weight: 600; margin-bottom: 15px; text-align: center; }
    .hook-card {
      background: rgba(0,0,0,0.3);
      border-radius: 12px;
      padding: 20px;
      margin: 15px 0;
      border-left: 4px solid #8b5cf6;
    }
    .hook-card h4 { color: #a78bfa; margin-bottom: 10px; font-family: monospace; font-size: 1.1rem; }
    .comparison-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
    .comparison-box { background: rgba(0,0,0,0.2); border-radius: 12px; padding: 20px; }
    .comparison-box.good { border: 2px solid #22c55e; }
    .comparison-box.bad { border: 2px solid #ef4444; }
    .comparison-label { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; font-weight: 600; }
    .comparison-box.good .comparison-label { color: #4ade80; }
    .comparison-box.bad .comparison-label { color: #f87171; }
    ul { padding-left: 25px; margin: 10px 0; }
    li { margin: 8px 0; color: #cbd5e1; }
    table { width: 100%; border-collapse: collapse; margin: 15px 0; }
    th, td { padding: 12px; text-align: left; border-bottom: 1px solid #334155; }
    th { background: rgba(139,92,246,0.2); color: #a78bfa; }
    code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px; font-family: monospace; }
    .nav-buttons { display: flex; justify-content: center; gap: 15px; margin-top: 40px; }
    .nav-btn {
      padding: 12px 30px;
      background: linear-gradient(135deg, #8b5cf6, #ec4899);
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>‚öõÔ∏è Chapter 7: Hooks with TypeScript</h1>
    <p class="subtitle">Type-safe state management and side effects with React Hooks</p>

    <!-- Section 7.1 -->
    <div class="section">
      <h2>7.1 useState</h2>
      
      <p>The <code>useState</code> hook is the most commonly used hook. TypeScript can often infer the type, but sometimes you need explicit typing.</p>

      <h3>Type Inference</h3>
      <div class="code-block">
<pre><span class="keyword">import</span> { <span class="function">useState</span> } <span class="keyword">from</span> <span class="string">'react'</span>;

<span class="keyword">function</span> <span class="function">Counter</span>() {
  <span class="comment">// TypeScript infers: number</span>
  <span class="keyword">const</span> [<span class="variable">count</span>, <span class="variable">setCount</span>] = <span class="function">useState</span>(<span class="number">0</span>);
  
  <span class="comment">// TypeScript infers: string</span>
  <span class="keyword">const</span> [<span class="variable">name</span>, <span class="variable">setName</span>] = <span class="function">useState</span>(<span class="string">'John'</span>);
  
  <span class="comment">// TypeScript infers: boolean</span>
  <span class="keyword">const</span> [<span class="variable">isActive</span>, <span class="variable">setIsActive</span>] = <span class="function">useState</span>(<span class="keyword">true</span>);
  
  <span class="comment">// TypeScript infers: string[] (from initial value)</span>
  <span class="keyword">const</span> [<span class="variable">items</span>, <span class="variable">setItems</span>] = <span class="function">useState</span>([<span class="string">'apple'</span>, <span class="string">'banana'</span>]);
  
  <span class="keyword">return</span> (
    &lt;<span class="tag">div</span>&gt;
      &lt;<span class="tag">p</span>&gt;Count: {<span class="variable">count</span>}&lt;/<span class="tag">p</span>&gt;
      &lt;<span class="tag">button</span> <span class="attr">onClick</span>={() => <span class="function">setCount</span>(<span class="variable">count</span> + <span class="number">1</span>)}&gt;Increment&lt;/<span class="tag">button</span>&gt;
    &lt;/<span class="tag">div</span>&gt;
  );
}</pre>
      </div>

      <h3>Explicit Typing</h3>
      <p>Use explicit typing when the initial value doesn't represent all possible states:</p>

      <div class="code-block">
<pre><span class="keyword">interface</span> <span class="type">User</span> {
  <span class="variable">id</span>: <span class="type">string</span>;
  <span class="variable">name</span>: <span class="type">string</span>;
  <span class="variable">email</span>: <span class="type">string</span>;
}

<span class="keyword">function</span> <span class="function">UserProfile</span>() {
  <span class="comment">// ‚ùå BAD: Would infer as 'null' type only</span>
  <span class="comment">// const [user, setUser] = useState(null);</span>
  
  <span class="comment">// ‚úÖ GOOD: Explicitly type as User | null</span>
  <span class="keyword">const</span> [<span class="variable">user</span>, <span class="variable">setUser</span>] = <span class="function">useState</span>&lt;<span class="type">User</span> | <span class="type">null</span>&gt;(<span class="keyword">null</span>);
  
  <span class="comment">// For arrays that start empty</span>
  <span class="keyword">const</span> [<span class="variable">users</span>, <span class="variable">setUsers</span>] = <span class="function">useState</span>&lt;<span class="type">User</span>[]&gt;([]);
  
  <span class="comment">// For objects with optional initial state</span>
  <span class="keyword">const</span> [<span class="variable">data</span>, <span class="variable">setData</span>] = <span class="function">useState</span>&lt;<span class="type">User</span> | <span class="type">undefined</span>&gt;();
  
  <span class="comment">// Union types for loading states</span>
  <span class="keyword">type</span> <span class="type">Status</span> = <span class="string">'idle'</span> | <span class="string">'loading'</span> | <span class="string">'success'</span> | <span class="string">'error'</span>;
  <span class="keyword">const</span> [<span class="variable">status</span>, <span class="variable">setStatus</span>] = <span class="function">useState</span>&lt;<span class="type">Status</span>&gt;(<span class="string">'idle'</span>);
  
  <span class="comment">// Using the state</span>
  <span class="keyword">const</span> <span class="function">fetchUser</span> = <span class="keyword">async</span> () => {
    <span class="function">setStatus</span>(<span class="string">'loading'</span>);
    <span class="keyword">try</span> {
      <span class="keyword">const</span> <span class="variable">response</span> = <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'/api/user'</span>);
      <span class="keyword">const</span> <span class="variable">userData</span>: <span class="type">User</span> = <span class="keyword">await</span> <span class="variable">response</span>.<span class="function">json</span>();
      <span class="function">setUser</span>(<span class="variable">userData</span>);
      <span class="function">setStatus</span>(<span class="string">'success'</span>);
    } <span class="keyword">catch</span> {
      <span class="function">setStatus</span>(<span class="string">'error'</span>);
    }
  };
  
  <span class="keyword">return</span> (
    &lt;<span class="tag">div</span>&gt;
      {<span class="variable">user</span> && &lt;<span class="tag">p</span>&gt;Welcome, {<span class="variable">user</span>.<span class="variable">name</span>}!&lt;/<span class="tag">p</span>&gt;}
      {<span class="comment">/* TypeScript knows user could be null, so we must check */</span>}
    &lt;/<span class="tag">div</span>&gt;
  );
}</pre>
      </div>

      <h3>Lazy Initialization</h3>
      <div class="code-block">
<pre><span class="comment">// Lazy initialization for expensive computations</span>
<span class="keyword">function</span> <span class="function">ExpensiveComponent</span>() {
  <span class="comment">// The function is only called on initial render</span>
  <span class="keyword">const</span> [<span class="variable">data</span>, <span class="variable">setData</span>] = <span class="function">useState</span>&lt;<span class="type">ComplexData</span>&gt;(() => {
    <span class="comment">// Expensive computation here</span>
    <span class="keyword">return</span> <span class="function">computeExpensiveInitialValue</span>();
  });
  
  <span class="comment">// Reading from localStorage</span>
  <span class="keyword">const</span> [<span class="variable">theme</span>, <span class="variable">setTheme</span>] = <span class="function">useState</span>&lt;<span class="string">'light'</span> | <span class="string">'dark'</span>&gt;(() => {
    <span class="keyword">const</span> <span class="variable">saved</span> = localStorage.<span class="function">getItem</span>(<span class="string">'theme'</span>);
    <span class="keyword">return</span> (<span class="variable">saved</span> <span class="keyword">as</span> <span class="string">'light'</span> | <span class="string">'dark'</span>) || <span class="string">'light'</span>;
  });
  
  <span class="keyword">return</span> &lt;<span class="tag">div</span>&gt;...&lt;/<span class="tag">div</span>&gt;;
}</pre>
      </div>

      <div class="alert alert-tip">
        <span class="alert-icon">üí°</span>
        <div class="alert-content">
          <h4>When to Explicitly Type useState</h4>
          <ul>
            <li>Initial value is <code>null</code> or <code>undefined</code></li>
            <li>Empty arrays <code>[]</code></li>
            <li>Union types (status states, etc.)</li>
            <li>Complex objects where inference isn't clear</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Section 7.2 -->
    <div class="section">
      <h2>7.2 useReducer</h2>
      
      <p>The <code>useReducer</code> hook is ideal for complex state logic. TypeScript shines here with discriminated unions for actions.</p>

      <div class="code-block">
<pre><span class="keyword">import</span> { <span class="function">useReducer</span> } <span class="keyword">from</span> <span class="string">'react'</span>;

<span class="comment">// 1. Define State type</span>
<span class="keyword">interface</span> <span class="type">State</span> {
  <span class="variable">count</span>: <span class="type">number</span>;
  <span class="variable">error</span>: <span class="type">string</span> | <span class="type">null</span>;
  <span class="variable">isLoading</span>: <span class="type">boolean</span>;
}

<span class="comment">// 2. Define Action types using discriminated union</span>
<span class="keyword">type</span> <span class="type">Action</span> =
  | { <span class="variable">type</span>: <span class="string">'INCREMENT'</span> }
  | { <span class="variable">type</span>: <span class="string">'DECREMENT'</span> }
  | { <span class="variable">type</span>: <span class="string">'SET_COUNT'</span>; <span class="variable">payload</span>: <span class="type">number</span> }
  | { <span class="variable">type</span>: <span class="string">'SET_ERROR'</span>; <span class="variable">payload</span>: <span class="type">string</span> }
  | { <span class="variable">type</span>: <span class="string">'CLEAR_ERROR'</span> }
  | { <span class="variable">type</span>: <span class="string">'SET_LOADING'</span>; <span class="variable">payload</span>: <span class="type">boolean</span> };

<span class="comment">// 3. Initial state</span>
<span class="keyword">const</span> <span class="variable">initialState</span>: <span class="type">State</span> = {
  <span class="variable">count</span>: <span class="number">0</span>,
  <span class="variable">error</span>: <span class="keyword">null</span>,
  <span class="variable">isLoading</span>: <span class="keyword">false</span>,
};

<span class="comment">// 4. Reducer function with full type safety</span>
<span class="keyword">function</span> <span class="function">reducer</span>(<span class="variable">state</span>: <span class="type">State</span>, <span class="variable">action</span>: <span class="type">Action</span>): <span class="type">State</span> {
  <span class="keyword">switch</span> (<span class="variable">action</span>.<span class="variable">type</span>) {
    <span class="keyword">case</span> <span class="string">'INCREMENT'</span>:
      <span class="keyword">return</span> { ...<span class="variable">state</span>, <span class="variable">count</span>: <span class="variable">state</span>.<span class="variable">count</span> + <span class="number">1</span> };
    <span class="keyword">case</span> <span class="string">'DECREMENT'</span>:
      <span class="keyword">return</span> { ...<span class="variable">state</span>, <span class="variable">count</span>: <span class="variable">state</span>.<span class="variable">count</span> - <span class="number">1</span> };
    <span class="keyword">case</span> <span class="string">'SET_COUNT'</span>:
      <span class="comment">// TypeScript knows action.payload is number here</span>
      <span class="keyword">return</span> { ...<span class="variable">state</span>, <span class="variable">count</span>: <span class="variable">action</span>.<span class="variable">payload</span> };
    <span class="keyword">case</span> <span class="string">'SET_ERROR'</span>:
      <span class="comment">// TypeScript knows action.payload is string here</span>
      <span class="keyword">return</span> { ...<span class="variable">state</span>, <span class="variable">error</span>: <span class="variable">action</span>.<span class="variable">payload</span> };
    <span class="keyword">case</span> <span class="string">'CLEAR_ERROR'</span>:
      <span class="keyword">return</span> { ...<span class="variable">state</span>, <span class="variable">error</span>: <span class="keyword">null</span> };
    <span class="keyword">case</span> <span class="string">'SET_LOADING'</span>:
      <span class="keyword">return</span> { ...<span class="variable">state</span>, <span class="variable">isLoading</span>: <span class="variable">action</span>.<span class="variable">payload</span> };
    <span class="keyword">default</span>:
      <span class="comment">// Exhaustive check - TypeScript errors if case is missing</span>
      <span class="keyword">const</span> <span class="variable">_exhaustive</span>: <span class="type">never</span> = <span class="variable">action</span>;
      <span class="keyword">return</span> <span class="variable">state</span>;
  }
}

<span class="comment">// 5. Using the reducer</span>
<span class="keyword">function</span> <span class="function">Counter</span>() {
  <span class="keyword">const</span> [<span class="variable">state</span>, <span class="variable">dispatch</span>] = <span class="function">useReducer</span>(<span class="variable">reducer</span>, <span class="variable">initialState</span>);
  
  <span class="keyword">return</span> (
    &lt;<span class="tag">div</span>&gt;
      &lt;<span class="tag">p</span>&gt;Count: {<span class="variable">state</span>.<span class="variable">count</span>}&lt;/<span class="tag">p</span>&gt;
      {<span class="variable">state</span>.<span class="variable">error</span> && &lt;<span class="tag">p</span> <span class="attr">className</span>=<span class="string">"error"</span>&gt;{<span class="variable">state</span>.<span class="variable">error</span>}&lt;/<span class="tag">p</span>&gt;}
      
      <span class="comment">{/* TypeScript ensures correct action types */}</span>
      &lt;<span class="tag">button</span> <span class="attr">onClick</span>={() => <span class="function">dispatch</span>({ <span class="variable">type</span>: <span class="string">'INCREMENT'</span> })}&gt;+&lt;/<span class="tag">button</span>&gt;
      &lt;<span class="tag">button</span> <span class="attr">onClick</span>={() => <span class="function">dispatch</span>({ <span class="variable">type</span>: <span class="string">'DECREMENT'</span> })}&gt;-&lt;/<span class="tag">button</span>&gt;
      &lt;<span class="tag">button</span> <span class="attr">onClick</span>={() => <span class="function">dispatch</span>({ <span class="variable">type</span>: <span class="string">'SET_COUNT'</span>, <span class="variable">payload</span>: <span class="number">10</span> })}&gt;
        Set to 10
      &lt;/<span class="tag">button</span>&gt;
      
      <span class="comment">{/* ‚ùå This would error - wrong payload type */}</span>
      <span class="comment">{/* dispatch({ type: 'SET_COUNT', payload: 'ten' }) */}</span>
    &lt;/<span class="tag">div</span>&gt;
  );
}</pre>
      </div>

      <div class="alert alert-interview">
        <span class="alert-icon">‚ö†Ô∏è</span>
        <div class="alert-content">
          <h4>Interview Alert: Why Discriminated Unions for Actions?</h4>
          <p>Discriminated unions provide:</p>
          <ul>
            <li><strong>Type narrowing:</strong> TypeScript knows the exact payload type in each case</li>
            <li><strong>Exhaustive checking:</strong> Compiler errors if you miss a case</li>
            <li><strong>Autocomplete:</strong> IDE suggests valid action types</li>
            <li><strong>Refactoring safety:</strong> Renaming action types updates everywhere</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Section 7.3 -->
    <div class="section">
      <h2>7.3 useRef</h2>
      
      <p>The <code>useRef</code> hook has two distinct use cases with different typing requirements:</p>

      <div class="visual-box">
        <div class="visual-title">üéØ Two Types of Refs</div>
        <div class="comparison-grid">
          <div class="hook-card">
            <h4>DOM Refs (Readonly)</h4>
            <p>Reference to DOM elements. The <code>.current</code> is managed by React.</p>
            <code>useRef&lt;HTMLElement&gt;(null)</code>
          </div>
          <div class="hook-card">
            <h4>Mutable Refs</h4>
            <p>Store any mutable value that persists across renders.</p>
            <code>useRef&lt;T&gt;(initialValue)</code>
          </div>
        </div>
      </div>

      <h3>DOM Refs</h3>
      <div class="code-block">
<pre><span class="keyword">import</span> { <span class="function">useRef</span>, <span class="function">useEffect</span> } <span class="keyword">from</span> <span class="string">'react'</span>;

<span class="keyword">function</span> <span class="function">TextInput</span>() {
  <span class="comment">// DOM ref - initialized with null, typed as element</span>
  <span class="keyword">const</span> <span class="variable">inputRef</span> = <span class="function">useRef</span>&lt;<span class="type">HTMLInputElement</span>&gt;(<span class="keyword">null</span>);
  <span class="keyword">const</span> <span class="variable">divRef</span> = <span class="function">useRef</span>&lt;<span class="type">HTMLDivElement</span>&gt;(<span class="keyword">null</span>);
  <span class="keyword">const</span> <span class="variable">buttonRef</span> = <span class="function">useRef</span>&lt;<span class="type">HTMLButtonElement</span>&gt;(<span class="keyword">null</span>);
  
  <span class="function">useEffect</span>(() => {
    <span class="comment">// Must check for null before accessing</span>
    <span class="keyword">if</span> (<span class="variable">inputRef</span>.<span class="variable">current</span>) {
      <span class="variable">inputRef</span>.<span class="variable">current</span>.<span class="function">focus</span>();
    }
    
    <span class="comment">// Or use optional chaining</span>
    <span class="variable">inputRef</span>.<span class="variable">current</span>?.<span class="function">focus</span>();
  }, []);
  
  <span class="keyword">const</span> <span class="function">handleClick</span> = () => {
    <span class="comment">// Access DOM properties with full type safety</span>
    <span class="keyword">if</span> (<span class="variable">inputRef</span>.<span class="variable">current</span>) {
      console.<span class="function">log</span>(<span class="variable">inputRef</span>.<span class="variable">current</span>.<span class="variable">value</span>);
      <span class="variable">inputRef</span>.<span class="variable">current</span>.<span class="function">select</span>();
    }
  };
  
  <span class="keyword">return</span> (
    &lt;<span class="tag">div</span> <span class="attr">ref</span>={<span class="variable">divRef</span>}&gt;
      &lt;<span class="tag">input</span> <span class="attr">ref</span>={<span class="variable">inputRef</span>} <span class="attr">type</span>=<span class="string">"text"</span> /&gt;
      &lt;<span class="tag">button</span> <span class="attr">ref</span>={<span class="variable">buttonRef</span>} <span class="attr">onClick</span>={<span class="function">handleClick</span>}&gt;Click&lt;/<span class="tag">button</span>&gt;
    &lt;/<span class="tag">div</span>&gt;
  );
}</pre>
      </div>

      <h3>Mutable Refs</h3>
      <div class="code-block">
<pre><span class="keyword">import</span> { <span class="function">useRef</span>, <span class="function">useEffect</span> } <span class="keyword">from</span> <span class="string">'react'</span>;

<span class="keyword">function</span> <span class="function">Timer</span>() {
  <span class="comment">// Mutable ref for timer ID</span>
  <span class="keyword">const</span> <span class="variable">timerIdRef</span> = <span class="function">useRef</span>&lt;<span class="type">number</span> | <span class="type">null</span>&gt;(<span class="keyword">null</span>);
  
  <span class="comment">// Mutable ref for previous value</span>
  <span class="keyword">const</span> <span class="variable">prevCountRef</span> = <span class="function">useRef</span>&lt;<span class="type">number</span>&gt;(<span class="number">0</span>);
  
  <span class="comment">// Mutable ref for tracking renders</span>
  <span class="keyword">const</span> <span class="variable">renderCount</span> = <span class="function">useRef</span>(<span class="number">0</span>);
  <span class="variable">renderCount</span>.<span class="variable">current</span>++; <span class="comment">// ‚úÖ OK - can mutate .current</span>
  
  <span class="keyword">const</span> <span class="function">startTimer</span> = () => {
    <span class="variable">timerIdRef</span>.<span class="variable">current</span> = window.<span class="function">setInterval</span>(() => {
      console.<span class="function">log</span>(<span class="string">'Tick'</span>);
    }, <span class="number">1000</span>);
  };
  
  <span class="keyword">const</span> <span class="function">stopTimer</span> = () => {
    <span class="keyword">if</span> (<span class="variable">timerIdRef</span>.<span class="variable">current</span>) {
      window.<span class="function">clearInterval</span>(<span class="variable">timerIdRef</span>.<span class="variable">current</span>);
      <span class="variable">timerIdRef</span>.<span class="variable">current</span> = <span class="keyword">null</span>;
    }
  };
  
  <span class="function">useEffect</span>(() => {
    <span class="keyword">return</span> () => <span class="function">stopTimer</span>(); <span class="comment">// Cleanup on unmount</span>
  }, []);
  
  <span class="keyword">return</span> (
    &lt;<span class="tag">div</span>&gt;
      &lt;<span class="tag">p</span>&gt;Render count: {<span class="variable">renderCount</span>.<span class="variable">current</span>}&lt;/<span class="tag">p</span>&gt;
      &lt;<span class="tag">button</span> <span class="attr">onClick</span>={<span class="function">startTimer</span>}&gt;Start&lt;/<span class="tag">button</span>&gt;
      &lt;<span class="tag">button</span> <span class="attr">onClick</span>={<span class="function">stopTimer</span>}&gt;Stop&lt;/<span class="tag">button</span>&gt;
    &lt;/<span class="tag">div</span>&gt;
  );
}</pre>
      </div>

      <div class="alert alert-interview">
        <span class="alert-icon">‚ö†Ô∏è</span>
        <div class="alert-content">
          <h4>Interview Alert: The Null Difference</h4>
          <p><strong><code>useRef&lt;T&gt;(null)</code></strong> ‚Üí Creates <code>RefObject&lt;T&gt;</code> with readonly <code>.current</code></p>
          <p><strong><code>useRef&lt;T | null&gt;(null)</code></strong> ‚Üí Creates <code>MutableRefObject&lt;T | null&gt;</code> with mutable <code>.current</code></p>
          <p>For DOM refs, use the first pattern. For mutable values, use the second or provide a non-null initial value.</p>
        </div>
      </div>
    </div>

    <!-- Section 7.4 -->
    <div class="section">
      <h2>7.4 useContext</h2>
      
      <p>Creating type-safe context requires careful typing of the context value and a custom hook pattern for safe consumption.</p>

      <div class="code-block">
<pre><span class="keyword">import</span> { <span class="function">createContext</span>, <span class="function">useContext</span>, <span class="function">useState</span>, <span class="type">ReactNode</span> } <span class="keyword">from</span> <span class="string">'react'</span>;

<span class="comment">// 1. Define the context value type</span>
<span class="keyword">interface</span> <span class="type">ThemeContextType</span> {
  <span class="variable">theme</span>: <span class="string">'light'</span> | <span class="string">'dark'</span>;
  <span class="variable">toggleTheme</span>: () => <span class="type">void</span>;
  <span class="variable">setTheme</span>: (<span class="variable">theme</span>: <span class="string">'light'</span> | <span class="string">'dark'</span>) => <span class="type">void</span>;
}

<span class="comment">// 2. Create context with undefined default</span>
<span class="keyword">const</span> <span class="variable">ThemeContext</span> = <span class="function">createContext</span>&lt;<span class="type">ThemeContextType</span> | <span class="type">undefined</span>&gt;(<span class="keyword">undefined</span>);

<span class="comment">// 3. Create a custom hook for safe consumption</span>
<span class="keyword">function</span> <span class="function">useTheme</span>(): <span class="type">ThemeContextType</span> {
  <span class="keyword">const</span> <span class="variable">context</span> = <span class="function">useContext</span>(<span class="variable">ThemeContext</span>);
  
  <span class="keyword">if</span> (<span class="variable">context</span> === <span class="keyword">undefined</span>) {
    <span class="keyword">throw new</span> <span class="type">Error</span>(<span class="string">'useTheme must be used within a ThemeProvider'</span>);
  }
  
  <span class="keyword">return</span> <span class="variable">context</span>;
}

<span class="comment">// 4. Create the provider component</span>
<span class="keyword">interface</span> <span class="type">ThemeProviderProps</span> {
  <span class="variable">children</span>: <span class="type">ReactNode</span>;
  <span class="variable">defaultTheme</span>?: <span class="string">'light'</span> | <span class="string">'dark'</span>;
}

<span class="keyword">function</span> <span class="function">ThemeProvider</span>({ <span class="variable">children</span>, <span class="variable">defaultTheme</span> = <span class="string">'light'</span> }: <span class="type">ThemeProviderProps</span>) {
  <span class="keyword">const</span> [<span class="variable">theme</span>, <span class="variable">setTheme</span>] = <span class="function">useState</span>&lt;<span class="string">'light'</span> | <span class="string">'dark'</span>&gt;(<span class="variable">defaultTheme</span>);
  
  <span class="keyword">const</span> <span class="function">toggleTheme</span> = () => {
    <span class="function">setTheme</span>(<span class="variable">prev</span> => <span class="variable">prev</span> === <span class="string">'light'</span> ? <span class="string">'dark'</span> : <span class="string">'light'</span>);
  };
  
  <span class="keyword">const</span> <span class="variable">value</span>: <span class="type">ThemeContextType</span> = {
    <span class="variable">theme</span>,
    <span class="variable">toggleTheme</span>,
    <span class="variable">setTheme</span>,
  };
  
  <span class="keyword">return</span> (
    &lt;<span class="variable">ThemeContext</span>.<span class="variable">Provider</span> <span class="attr">value</span>={<span class="variable">value</span>}&gt;
      {<span class="variable">children</span>}
    &lt;/<span class="variable">ThemeContext</span>.<span class="variable">Provider</span>&gt;
  );
}

<span class="comment">// 5. Usage in components</span>
<span class="keyword">function</span> <span class="function">ThemedButton</span>() {
  <span class="keyword">const</span> { <span class="variable">theme</span>, <span class="variable">toggleTheme</span> } = <span class="function">useTheme</span>(); <span class="comment">// ‚úÖ Type-safe!</span>
  
  <span class="keyword">return</span> (
    &lt;<span class="tag">button</span>
      <span class="attr">onClick</span>={<span class="variable">toggleTheme</span>}
      <span class="attr">className</span>={<span class="variable">theme</span> === <span class="string">'dark'</span> ? <span class="string">'btn-dark'</span> : <span class="string">'btn-light'</span>}
    &gt;
      Current: {<span class="variable">theme</span|}
    &lt;/<span class="tag">button</span>&gt;
  );
}

<span class="comment">// 6. App setup</span>
<span class="keyword">function</span> <span class="function">App</span>() {
  <span class="keyword">return</span> (
    &lt;<span class="type">ThemeProvider</span> <span class="attr">defaultTheme</span>=<span class="string">"dark"</span>&gt;
      &lt;<span class="type">ThemedButton</span> /&gt;
    &lt;/<span class="type">ThemeProvider</span>&gt;
  );
}

<span class="comment">// Export for use in other files</span>
<span class="keyword">export</span> { <span class="type">ThemeProvider</span>, <span class="function">useTheme</span> };</pre>
      </div>

      <div class="alert alert-tip">
        <span class="alert-icon">üí°</span>
        <div class="alert-content">
          <h4>Production Tip: Context Pattern</h4>
          <p>Always create a custom hook for context consumption. This provides:</p>
          <ul>
            <li>Runtime error if used outside provider</li>
            <li>Better type inference (no undefined checks in components)</li>
            <li>Single point of documentation</li>
            <li>Easier refactoring</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Section 7.5 -->
    <div class="section">
      <h2>7.5 useMemo and useCallback</h2>
      
      <p>Both hooks are used for optimization. TypeScript infers return types, but you can be explicit when needed.</p>

      <div class="code-block">
<pre><span class="keyword">import</span> { <span class="function">useMemo</span>, <span class="function">useCallback</span>, <span class="function">useState</span> } <span class="keyword">from</span> <span class="string">'react'</span>;

<span class="keyword">interface</span> <span class="type">User</span> {
  <span class="variable">id</span>: <span class="type">string</span>;
  <span class="variable">name</span>: <span class="type">string</span>;
  <span class="variable">age</span>: <span class="type">number</span>;
}

<span class="keyword">function</span> <span class="function">UserList</span>({ <span class="variable">users</span> }: { <span class="variable">users</span>: <span class="type">User</span>[] }) {
  <span class="keyword">const</span> [<span class="variable">filter</span>, <span class="variable">setFilter</span>] = <span class="function">useState</span>(<span class="string">''</span>);
  <span class="keyword">const</span> [<span class="variable">sortBy</span>, <span class="variable">setSortBy</span>] = <span class="function">useState</span>&lt;<span class="string">'name'</span> | <span class="string">'age'</span>&gt;(<span class="string">'name'</span>);
  
  <span class="comment">// useMemo - TypeScript infers return type as User[]</span>
  <span class="keyword">const</span> <span class="variable">filteredUsers</span> = <span class="function">useMemo</span>(() => {
    <span class="keyword">return</span> <span class="variable">users</span>
      .<span class="function">filter</span>(<span class="variable">user</span> => <span class="variable">user</span>.<span class="variable">name</span>.<span class="function">toLowerCase</span>().<span class="function">includes</span>(<span class="variable">filter</span>.<span class="function">toLowerCase</span>()))
      .<span class="function">sort</span>((<span class="variable">a</span>, <span class="variable">b</span>) => {
        <span class="keyword">if</span> (<span class="variable">sortBy</span> === <span class="string">'name'</span>) {
          <span class="keyword">return</span> <span class="variable">a</span>.<span class="variable">name</span>.<span class="function">localeCompare</span>(<span class="variable">b</span>.<span class="variable">name</span>);
        }
        <span class="keyword">return</span> <span class="variable">a</span>.<span class="variable">age</span> - <span class="variable">b</span>.<span class="variable">age</span>;
      });
  }, [<span class="variable">users</span>, <span class="variable">filter</span>, <span class="variable">sortBy</span>]);
  
  <span class="comment">// Explicit typing when needed</span>
  <span class="keyword">const</span> <span class="variable">userStats</span> = <span class="function">useMemo</span>&lt;{ <span class="variable">total</span>: <span class="type">number</span>; <span class="variable">avgAge</span>: <span class="type">number</span> }&gt;(() => {
    <span class="keyword">const</span> <span class="variable">total</span> = <span class="variable">users</span>.<span class="variable">length</span>;
    <span class="keyword">const</span> <span class="variable">avgAge</span> = <span class="variable">users</span>.<span class="function">reduce</span>((<span class="variable">sum</span>, <span class="variable">u</span>) => <span class="variable">sum</span> + <span class="variable">u</span>.<span class="variable">age</span>, <span class="number">0</span>) / <span class="variable">total</span>;
    <span class="keyword">return</span> { <span class="variable">total</span>, <span class="variable">avgAge</span> };
  }, [<span class="variable">users</span>]);
  
  <span class="comment">// useCallback - TypeScript infers function type</span>
  <span class="keyword">const</span> <span class="function">handleUserClick</span> = <span class="function">useCallback</span>((<span class="variable">userId</span>: <span class="type">string</span>) => {
    console.<span class="function">log</span>(<span class="string">'Clicked user:'</span>, <span class="variable">userId</span>);
  }, []);
  
  <span class="comment">// useCallback with event handler</span>
  <span class="keyword">const</span> <span class="function">handleInputChange</span> = <span class="function">useCallback</span>(
    (<span class="variable">e</span>: <span class="type">React</span>.<span class="type">ChangeEvent</span>&lt;<span class="type">HTMLInputElement</span>&gt;) => {
      <span class="function">setFilter</span>(<span class="variable">e</span>.<span class="variable">target</span>.<span class="variable">value</span>);
    },
    []
  );
  
  <span class="comment">// useCallback with explicit typing</span>
  <span class="keyword">const</span> <span class="function">handleSort</span> = <span class="function">useCallback</span>&lt;(<span class="variable">field</span>: <span class="string">'name'</span> | <span class="string">'age'</span>) => <span class="type">void</span>&gt;(
    (<span class="variable">field</span>) => {
      <span class="function">setSortBy</span>(<span class="variable">field</span>);
    },
    []
  );
  
  <span class="keyword">return</span> (
    &lt;<span class="tag">div</span>&gt;
      &lt;<span class="tag">input</span> <span class="attr">value</span>={<span class="variable">filter</span>} <span class="attr">onChange</span>={<span class="function">handleInputChange</span>} /&gt;
      &lt;<span class="tag">p</span>&gt;Total: {<span class="variable">userStats</span>.<span class="variable">total</span>}, Avg Age: {<span class="variable">userStats</span>.<span class="variable">avgAge</span>.<span class="function">toFixed</span>(<span class="number">1</span>)}&lt;/<span class="tag">p</span>&gt;
      {<span class="variable">filteredUsers</span>.<span class="function">map</span>(<span class="variable">user</span> => (
        &lt;<span class="tag">div</span> <span class="attr">key</span>={<span class="variable">user</span>.<span class="variable">id</span>} <span class="attr">onClick</span>={() => <span class="function">handleUserClick</span>(<span class="variable">user</span>.<span class="variable">id</span>)}&gt;
          {<span class="variable">user</span>.<span class="variable">name</span>} - {<span class="variable">user</span>.<span class="variable">age</span>}
        &lt;/<span class="tag">div</span>&gt;
      ))}
    &lt;/<span class="tag">div</span>&gt;
  );
}</pre>
      </div>
    </div>

    <!-- Section 7.6 & 7.7 -->
    <div class="section">
      <h2>7.6 Custom Hooks</h2>
      
      <p>Custom hooks encapsulate reusable logic. Proper typing makes them powerful and safe to use.</p>

      <div class="code-block">
<pre><span class="keyword">import</span> { <span class="function">useState</span>, <span class="function">useEffect</span>, <span class="function">useCallback</span> } <span class="keyword">from</span> <span class="string">'react'</span>;

<span class="comment">// 1. Simple custom hook with explicit return type</span>
<span class="keyword">function</span> <span class="function">useToggle</span>(<span class="variable">initialValue</span>: <span class="type">boolean</span> = <span class="keyword">false</span>): [<span class="type">boolean</span>, () => <span class="type">void</span>] {
  <span class="keyword">const</span> [<span class="variable">value</span>, <span class="variable">setValue</span>] = <span class="function">useState</span>(<span class="variable">initialValue</span>);
  <span class="keyword">const</span> <span class="function">toggle</span> = <span class="function">useCallback</span>(() => <span class="function">setValue</span>(<span class="variable">v</span> => !<span class="variable">v</span>), []);
  <span class="keyword">return</span> [<span class="variable">value</span>, <span class="variable">toggle</span>];
}

<span class="comment">// 2. Generic custom hook</span>
<span class="keyword">function</span> <span class="function">useLocalStorage</span>&lt;<span class="type">T</span>&gt;(
  <span class="variable">key</span>: <span class="type">string</span>,
  <span class="variable">initialValue</span>: <span class="type">T</span>
): [<span class="type">T</span>, (<span class="variable">value</span>: <span class="type">T</span> | ((<span class="variable">prev</span>: <span class="type">T</span>) => <span class="type">T</span>)) => <span class="type">void</span>] {
  <span class="keyword">const</span> [<span class="variable">storedValue</span>, <span class="variable">setStoredValue</span>] = <span class="function">useState</span>&lt;<span class="type">T</span>&gt;(() => {
    <span class="keyword">try</span> {
      <span class="keyword">const</span> <span class="variable">item</span> = localStorage.<span class="function">getItem</span>(<span class="variable">key</span>);
      <span class="keyword">return</span> <span class="variable">item</span> ? <span class="function">JSON</span>.<span class="function">parse</span>(<span class="variable">item</span>) : <span class="variable">initialValue</span>;
    } <span class="keyword">catch</span> {
      <span class="keyword">return</span> <span class="variable">initialValue</span>;
    }
  });
  
  <span class="keyword">const</span> <span class="function">setValue</span> = <span class="function">useCallback</span>(
    (<span class="variable">value</span>: <span class="type">T</span> | ((<span class="variable">prev</span>: <span class="type">T</span>) => <span class="type">T</span>)) => {
      <span class="function">setStoredValue</span>(<span class="variable">prev</span> => {
        <span class="keyword">const</span> <span class="variable">newValue</span> = <span class="variable">value</span> <span class="keyword">instanceof</span> <span class="type">Function</span> ? <span class="function">value</span>(<span class="variable">prev</span>) : <span class="variable">value</span>;
        localStorage.<span class="function">setItem</span>(<span class="variable">key</span>, <span class="function">JSON</span>.<span class="function">stringify</span>(<span class="variable">newValue</span>));
        <span class="keyword">return</span> <span class="variable">newValue</span>;
      });
    },
    [<span class="variable">key</span>]
  );
  
  <span class="keyword">return</span> [<span class="variable">storedValue</span>, <span class="variable">setValue</span>];
}

<span class="comment">// 3. Async data fetching hook</span>
<span class="keyword">interface</span> <span class="type">UseFetchResult</span>&lt;<span class="type">T</span>&gt; {
  <span class="variable">data</span>: <span class="type">T</span> | <span class="type">null</span>;
  <span class="variable">loading</span>: <span class="type">boolean</span>;
  <span class="variable">error</span>: <span class="type">Error</span> | <span class="type">null</span>;
  <span class="variable">refetch</span>: () => <span class="type">Promise</span>&lt;<span class="type">void</span>&gt;;
}

<span class="keyword">function</span> <span class="function">useFetch</span>&lt;<span class="type">T</span>&gt;(<span class="variable">url</span>: <span class="type">string</span>): <span class="type">UseFetchResult</span>&lt;<span class="type">T</span>&gt; {
  <span class="keyword">const</span> [<span class="variable">data</span>, <span class="variable">setData</span>] = <span class="function">useState</span>&lt;<span class="type">T</span> | <span class="type">null</span>&gt;(<span class="keyword">null</span>);
  <span class="keyword">const</span> [<span class="variable">loading</span>, <span class="variable">setLoading</span>] = <span class="function">useState</span>(<span class="keyword">true</span>);
  <span class="keyword">const</span> [<span class="variable">error</span>, <span class="variable">setError</span>] = <span class="function">useState</span>&lt;<span class="type">Error</span> | <span class="type">null</span>&gt;(<span class="keyword">null</span>);
  
  <span class="keyword">const</span> <span class="function">fetchData</span> = <span class="function">useCallback</span>(<span class="keyword">async</span> () => {
    <span class="function">setLoading</span>(<span class="keyword">true</span>);
    <span class="function">setError</span>(<span class="keyword">null</span>);
    
    <span class="keyword">try</span> {
      <span class="keyword">const</span> <span class="variable">response</span> = <span class="keyword">await</span> <span class="function">fetch</span>(<span class="variable">url</span>);
      <span class="keyword">if</span> (!<span class="variable">response</span>.<span class="variable">ok</span>) {
        <span class="keyword">throw new</span> <span class="type">Error</span>(<span class="string">`HTTP error! status: </span>${<span class="variable">response</span>.<span class="variable">status</span>}<span class="string">`</span>);
      }
      <span class="keyword">const</span> <span class="variable">result</span> = <span class="keyword">await</span> <span class="variable">response</span>.<span class="function">json</span>() <span class="keyword">as</span> <span class="type">T</span>;
      <span class="function">setData</span>(<span class="variable">result</span>);
    } <span class="keyword">catch</span> (<span class="variable">err</span>) {
      <span class="function">setError</span>(<span class="variable">err</span> <span class="keyword">instanceof</span> <span class="type">Error</span> ? <span class="variable">err</span> : <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">'Unknown error'</span>));
    } <span class="keyword">finally</span> {
      <span class="function">setLoading</span>(<span class="keyword">false</span>);
    }
  }, [<span class="variable">url</span>]);
  
  <span class="function">useEffect</span>(() => {
    <span class="function">fetchData</span>();
  }, [<span class="variable">fetchData</span>]);
  
  <span class="keyword">return</span> { <span class="variable">data</span>, <span class="variable">loading</span>, <span class="variable">error</span>, <span class="variable">refetch</span>: <span class="variable">fetchData</span> };
}

<span class="comment">// Usage</span>
<span class="keyword">interface</span> <span class="type">User</span> {
  <span class="variable">id</span>: <span class="type">number</span>;
  <span class="variable">name</span>: <span class="type">string</span>;
}

<span class="keyword">function</span> <span class="function">UserComponent</span>() {
  <span class="keyword">const</span> { <span class="variable">data</span>, <span class="variable">loading</span>, <span class="variable">error</span>, <span class="variable">refetch</span> } = <span class="function">useFetch</span>&lt;<span class="type">User</span>[]&gt;(<span class="string">'/api/users'</span>);
  <span class="keyword">const</span> [<span class="variable">theme</span>, <span class="variable">setTheme</span>] = <span class="function">useLocalStorage</span>&lt;<span class="string">'light'</span> | <span class="string">'dark'</span>&gt;(<span class="string">'theme'</span>, <span class="string">'light'</span>);
  <span class="keyword">const</span> [<span class="variable">isOpen</span>, <span class="variable">toggle</span>] = <span class="function">useToggle</span>();
  
  <span class="keyword">if</span> (<span class="variable">loading</span>) <span class="keyword">return</span> &lt;<span class="tag">p</span>&gt;Loading...&lt;/<span class="tag">p</span>&gt;;
  <span class="keyword">if</span> (<span class="variable">error</span>) <span class="keyword">return</span> &lt;<span class="tag">p</span>&gt;Error: {<span class="variable">error</span>.<span class="variable">message</span>}&lt;/<span class="tag">p</span>&gt;;
  
  <span class="keyword">return</span> (
    &lt;<span class="tag">div</span>&gt;
      {<span class="variable">data</span>?.<span class="function">map</span>(<span class="variable">user</span> => &lt;<span class="tag">p</span> <span class="attr">key</span>={<span class="variable">user</span>.<span class="variable">id</span>}&gt;{<span class="variable">user</span>.<span class="variable">name</span>}&lt;/<span class="tag">p</span>&gt;)}
    &lt;/<span class="tag">div</span>&gt;
  );
}</pre>
      </div>

      <div class="alert alert-tip">
        <span class="alert-icon">üí°</span>
        <div class="alert-content">
          <h4>Custom Hook Return Type Tips</h4>
          <ul>
            <li><strong>Tuple:</strong> <code>[value, setValue]</code> - Use for simple state-like returns (allows destructuring with custom names)</li>
            <li><strong>Object:</strong> <code>{ data, loading, error }</code> - Use for complex returns (clearer, allows partial destructuring)</li>
            <li><strong>Always type the return</strong> for public/shared hooks</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="nav-buttons">
      <button class="nav-btn">‚Üê Chapter 6</button>
      <button class="nav-btn">Chapter 8: Patterns ‚Üí</button>
    </div>
  </div>
</body>
</html>
