# TypeScript with React: Complete Mastery Guide
## From Beginner to Production-Grade (Interview Ready)

---

# PART I: TYPESCRIPT FOUNDATIONS

## Chapter 1: TypeScript Basics

### 1.1 Type Annotations
- Primitive types: `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`
- Type inference vs explicit annotations
- The `any` type and why to avoid it
- The `unknown` type (safer alternative to `any`)
- The `never` type (functions that never return)
- The `void` type

> ‚ö†Ô∏è **Interview Alert**: Explain the difference between `any` and `unknown`. Answer: `unknown` requires type checking before use, making it type-safe.

### 1.2 Arrays and Tuples
- Array syntax: `string[]` vs `Array<string>`
- Readonly arrays: `readonly string[]` or `ReadonlyArray<string>`
- Tuples: fixed-length arrays with specific types `[string, number]`
- Named tuples: `[name: string, age: number]`
- Optional tuple elements: `[string, number?]`
- Rest elements in tuples: `[string, ...number[]]`

> üí° **Production Tip**: Use tuples for function return values when returning multiple related values.

### 1.3 Objects and Interfaces
- Object type annotations
- Optional properties: `property?: type`
- Readonly properties: `readonly property: type`
- Index signatures: `[key: string]: type`
- Interface declaration and extension
- Interface merging (declaration merging)

### 1.4 Type Aliases
- Creating type aliases with `type`
- Difference between `type` and `interface`
- When to use each (interfaces for objects/classes, types for unions/primitives)

> ‚ö†Ô∏è **Interview Alert**: Interfaces can be merged and extended; type aliases cannot be merged but can use intersections.

### 1.5 Union and Intersection Types
- Union types: `type A = string | number`
- Intersection types: `type A = TypeB & TypeC`
- Discriminated unions (tagged unions)
- Type narrowing with unions

### 1.6 Literal Types
- String literals: `type Direction = "north" | "south"`
- Numeric literals: `type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6`
- Boolean literals
- Template literal types: `` type EventName = `on${string}` ``

---

## Chapter 2: Functions in TypeScript

### 2.1 Function Type Annotations
- Parameter types and return types
- Optional parameters: `(param?: type)`
- Default parameters: `(param: type = defaultValue)`
- Rest parameters: `(...args: type[])`

### 2.2 Function Overloads
- Multiple function signatures
- Implementation signature vs overload signatures
- When to use overloads vs union types

```typescript
function process(x: string): string;
function process(x: number): number;
function process(x: string | number): string | number {
  return x;
}
```

### 2.3 Generic Functions
- Basic generics: `function identity<T>(arg: T): T`
- Multiple type parameters: `<T, U>`
- Generic constraints: `<T extends SomeType>`
- Default type parameters: `<T = DefaultType>`

> üí° **Production Tip**: Use generics to create reusable, type-safe utilities.

### 2.4 Function Types
- Arrow function types: `type Fn = (x: string) => number`
- Call signatures in object types
- Construct signatures: `new (x: string) => Object`

---

## Chapter 3: Advanced Types

### 3.1 Type Guards and Narrowing
- `typeof` type guards
- `instanceof` type guards
- `in` operator narrowing
- Equality narrowing
- Custom type guards: `function isType(x): x is Type`
- Assertion functions: `function assert(x): asserts x is Type`

> ‚ö†Ô∏è **Interview Alert**: Be ready to write custom type guard functions.

### 3.2 Conditional Types
- Basic syntax: `T extends U ? X : Y`
- Distributive conditional types
- `infer` keyword for type inference
- Nested conditional types

```typescript
type ExtractReturnType<T> = T extends (...args: any[]) => infer R ? R : never;
```

### 3.3 Mapped Types
- Basic mapped types: `{ [K in keyof T]: T[K] }`
- Key remapping: `as` clause
- Modifiers: `readonly`, `?`, `-readonly`, `-?`

```typescript
type Partial<T> = { [K in keyof T]?: T[K] };
type Required<T> = { [K in keyof T]-?: T[K] };
type Readonly<T> = { readonly [K in keyof T]: T[K] };
```

### 3.4 Template Literal Types
- Basic template literals: `` `${string}Handler` ``
- Intrinsic string manipulation: `Uppercase`, `Lowercase`, `Capitalize`, `Uncapitalize`
- Combining with union types

### 3.5 Utility Types (Must Know!)
- `Partial<T>` - All properties optional
- `Required<T>` - All properties required
- `Readonly<T>` - All properties readonly
- `Record<K, V>` - Object with keys K and values V
- `Pick<T, K>` - Pick specific properties
- `Omit<T, K>` - Omit specific properties
- `Exclude<T, U>` - Exclude types from union
- `Extract<T, U>` - Extract types from union
- `NonNullable<T>` - Remove null/undefined
- `ReturnType<T>` - Get function return type
- `Parameters<T>` - Get function parameters as tuple
- `Awaited<T>` - Unwrap Promise type
- `InstanceType<T>` - Get instance type of constructor

> ‚ö†Ô∏è **Interview Alert**: Be able to implement these utility types from scratch!

---

## Chapter 4: Classes and OOP in TypeScript

### 4.1 Class Basics
- Class declarations with types
- Constructor parameter properties
- Access modifiers: `public`, `private`, `protected`
- `readonly` properties
- Static members

### 4.2 Abstract Classes
- Abstract class declaration
- Abstract methods
- When to use abstract classes vs interfaces

### 4.3 Class Type Compatibility
- Structural typing with classes
- `implements` vs `extends`
- Multiple interface implementation

### 4.4 Advanced Class Patterns
- Mixins pattern
- Decorators (experimental but important)
- `this` types in classes
- Generic classes

---

## Chapter 5: Modules and Namespaces

### 5.1 ES Modules in TypeScript
- Import/export syntax
- Type-only imports: `import type { Type }`
- Re-exporting: `export { x } from 'module'`
- Default exports vs named exports

### 5.2 Module Resolution
- `moduleResolution` options
- Path mapping in `tsconfig.json`
- Ambient module declarations

### 5.3 Declaration Files
- `.d.ts` files
- `declare` keyword
- Ambient declarations
- DefinitelyTyped (`@types/*`)

> üí° **Production Tip**: Always use `import type` for type-only imports to improve build performance.

---

# PART II: REACT WITH TYPESCRIPT

## Chapter 6: React Component Types

### 6.1 Function Component Types
- `React.FC<Props>` (and why many avoid it)
- Direct typing: `function Component(props: Props): JSX.Element`
- Generic components

```typescript
// Preferred approach
interface Props {
  name: string;
  children?: React.ReactNode;
}

function Component({ name, children }: Props) {
  return <div>{name}{children}</div>;
}
```

> ‚ö†Ô∏è **Interview Alert**: Know the downsides of `React.FC` (implicit children, no generic support, issues with defaultProps).

### 6.2 Props Typing
- Required vs optional props
- Default props with destructuring
- `React.ReactNode` vs `React.ReactElement` vs `JSX.Element`
- `React.PropsWithChildren<P>`
- `React.ComponentProps<typeof Component>`
- `React.ComponentPropsWithRef<'button'>`
- `React.ComponentPropsWithoutRef<'button'>`

### 6.3 Children Types
- `React.ReactNode` - Most flexible (strings, elements, fragments, null)
- `React.ReactElement` - Only React elements
- `React.ReactChild` - Element or primitive (deprecated)
- Function as children (render props)

### 6.4 Event Handler Types
- `React.MouseEvent<HTMLButtonElement>`
- `React.ChangeEvent<HTMLInputElement>`
- `React.FormEvent<HTMLFormElement>`
- `React.KeyboardEvent<HTMLInputElement>`
- `React.FocusEvent<HTMLInputElement>`
- `React.DragEvent<HTMLDivElement>`

```typescript
const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
  e.preventDefault();
};

const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  setValue(e.target.value);
};
```

### 6.5 Style Types
- `React.CSSProperties` for inline styles
- CSS modules typing

---

## Chapter 7: Hooks with TypeScript

### 7.1 useState
- Type inference: `useState(initialValue)`
- Explicit typing: `useState<Type>(initialValue)`
- Union types for multiple states
- Lazy initialization typing

```typescript
const [user, setUser] = useState<User | null>(null);
const [items, setItems] = useState<string[]>([]);
```

### 7.2 useReducer
- Typing actions with discriminated unions
- Typing state
- Reducer function type

```typescript
type State = { count: number };
type Action = 
  | { type: 'increment' }
  | { type: 'decrement' }
  | { type: 'set'; payload: number };

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'increment': return { count: state.count + 1 };
    case 'decrement': return { count: state.count - 1 };
    case 'set': return { count: action.payload };
  }
}
```

> üí° **Production Tip**: Always use discriminated unions for actions to get exhaustive type checking.

### 7.3 useRef
- DOM refs: `useRef<HTMLInputElement>(null)`
- Mutable refs: `useRef<number>(0)`
- Difference between `null` and `undefined` initialization

```typescript
// DOM ref (readonly .current)
const inputRef = useRef<HTMLInputElement>(null);

// Mutable ref
const countRef = useRef<number>(0);
countRef.current = 5; // OK
```

> ‚ö†Ô∏è **Interview Alert**: `useRef<T>(null)` creates `RefObject<T>` (readonly), `useRef<T | null>(null)` creates `MutableRefObject<T | null>`.

### 7.4 useContext
- Creating typed context
- Context with undefined default
- Context with custom hook pattern

```typescript
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}
```

### 7.5 useMemo and useCallback
- Return type inference
- Generic typing when needed
- Dependencies array typing

### 7.6 useEffect and useLayoutEffect
- Return type (cleanup function or undefined)
- Async effects pattern

### 7.7 Custom Hooks
- Return type annotations
- Generic custom hooks
- Tuple returns vs object returns

```typescript
function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T) => void] {
  // implementation
}
```

---

## Chapter 8: Advanced React Patterns with TypeScript

### 8.1 Generic Components
- Components with type parameters
- Constraining generic types
- Default generic types

```typescript
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
  keyExtractor: (item: T) => string;
}

function List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {
  return (
    <ul>
      {items.map(item => (
        <li key={keyExtractor(item)}>{renderItem(item)}</li>
      ))}
    </ul>
  );
}

// Usage
<List<User> items={users} renderItem={u => u.name} keyExtractor={u => u.id} />
```

> ‚ö†Ô∏è **Interview Alert**: This is a common interview question - implement a generic List/Table component.

### 8.2 Higher-Order Components (HOCs)
- Typing HOC props
- Extracting and injecting props
- `ComponentType<P>` usage
- Preserving static properties

```typescript
function withLoading<P extends object>(
  WrappedComponent: React.ComponentType<P>
) {
  return function WithLoadingComponent(
    props: P & { isLoading: boolean }
  ) {
    const { isLoading, ...rest } = props;
    if (isLoading) return <Spinner />;
    return <WrappedComponent {...(rest as P)} />;
  };
}
```

### 8.3 Render Props Pattern
- Typing render prop functions
- Children as render prop
- Generic render props

```typescript
interface RenderProps<T> {
  data: T;
  loading: boolean;
  error: Error | null;
}

interface FetcherProps<T> {
  url: string;
  children: (props: RenderProps<T>) => React.ReactNode;
}

function Fetcher<T>({ url, children }: FetcherProps<T>) {
  // implementation
  return <>{children({ data, loading, error })}</>;
}
```

### 8.4 Compound Components
- Context-based compound components
- Type-safe compound component APIs
- Static component properties

### 8.5 Polymorphic Components
- The `as` prop pattern
- Type-safe element props

```typescript
type AsProp<C extends React.ElementType> = {
  as?: C;
};

type PropsToOmit<C extends React.ElementType, P> = keyof (AsProp<C> & P);

type PolymorphicComponentProp<
  C extends React.ElementType,
  Props = {}
> = React.PropsWithChildren<Props & AsProp<C>> &
  Omit<React.ComponentPropsWithoutRef<C>, PropsToOmit<C, Props>>;

interface ButtonProps {
  variant?: 'primary' | 'secondary';
}

function Button<C extends React.ElementType = 'button'>({
  as,
  children,
  variant = 'primary',
  ...props
}: PolymorphicComponentProp<C, ButtonProps>) {
  const Component = as || 'button';
  return <Component {...props}>{children}</Component>;
}

// Usage
<Button as="a" href="/home">Link Button</Button>
<Button onClick={() => {}}>Regular Button</Button>
```

> üí° **Production Tip**: Polymorphic components are essential for design system libraries.

### 8.6 Discriminated Union Props
- Mutually exclusive props
- Conditional required props

```typescript
type ButtonProps = 
  | { variant: 'link'; href: string; onClick?: never }
  | { variant: 'button'; onClick: () => void; href?: never };

function Button(props: ButtonProps) {
  if (props.variant === 'link') {
    return <a href={props.href}>Link</a>;
  }
  return <button onClick={props.onClick}>Button</button>;
}
```

---

## Chapter 9: Forms in TypeScript

### 9.1 Controlled Components
- Input event typing
- Form state typing
- Select and textarea typing

### 9.2 Uncontrolled Components
- Ref typing for form elements
- Form submission typing

### 9.3 Form Libraries Integration
- React Hook Form with TypeScript
- Formik with TypeScript
- Zod schema validation integration

```typescript
// React Hook Form + Zod
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const schema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
});

type FormData = z.infer<typeof schema>;

function Form() {
  const { register, handleSubmit, formState: { errors } } = 
    useForm<FormData>({ resolver: zodResolver(schema) });
  
  const onSubmit = (data: FormData) => console.log(data);
  
  return <form onSubmit={handleSubmit(onSubmit)}>...</form>;
}
```

> üí° **Production Tip**: Use Zod for runtime validation + TypeScript inference.

---

## Chapter 10: State Management with TypeScript

### 10.1 Redux Toolkit
- Typed store configuration
- Typed slices
- Typed selectors with `useSelector`
- Typed dispatch with `useDispatch`
- `PayloadAction<T>` type
- Async thunks typing

```typescript
// store.ts
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';

export const store = configureStore({
  reducer: { counter: counterReducer },
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// hooks.ts
import { useDispatch, useSelector, TypedUseSelectorHook } from 'react-redux';

export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
```

### 10.2 Zustand
- Typed store creation
- Middleware typing
- Persist middleware

```typescript
import { create } from 'zustand';

interface BearStore {
  bears: number;
  increase: (by: number) => void;
  reset: () => void;
}

const useBearStore = create<BearStore>((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
  reset: () => set({ bears: 0 }),
}));
```

### 10.3 React Query / TanStack Query
- Typed query functions
- Typed mutations
- Generic query hooks
- Error typing

```typescript
import { useQuery, useMutation } from '@tanstack/react-query';

interface User {
  id: string;
  name: string;
}

function useUser(id: string) {
  return useQuery<User, Error>({
    queryKey: ['user', id],
    queryFn: () => fetchUser(id),
  });
}

function useUpdateUser() {
  return useMutation<User, Error, Partial<User>>({
    mutationFn: (updates) => updateUser(updates),
  });
}
```

---

## Chapter 11: Routing with TypeScript

### 11.1 React Router v6+
- Typed route parameters with `useParams`
- Typed search params with `useSearchParams`
- Typed navigation with `useNavigate`
- Loader and action typing

```typescript
import { useParams, useSearchParams } from 'react-router-dom';

interface UserParams {
  userId: string;
}

function UserProfile() {
  const { userId } = useParams<keyof UserParams>() as UserParams;
  const [searchParams] = useSearchParams();
  const tab = searchParams.get('tab');
  
  return <div>User: {userId}, Tab: {tab}</div>;
}
```

### 11.2 Type-Safe Routing Patterns
- Centralized route definitions
- Route path constants
- Type-safe link generation

---

# PART III: PRODUCTION PATTERNS

## Chapter 12: API Integration

### 12.1 Fetch with TypeScript
- Typed fetch wrapper
- Generic API client
- Error handling types

```typescript
async function fetchJson<T>(url: string, options?: RequestInit): Promise<T> {
  const response = await fetch(url, options);
  if (!response.ok) {
    throw new ApiError(response.status, await response.text());
  }
  return response.json() as Promise<T>;
}

// Usage
const user = await fetchJson<User>('/api/user/1');
```

### 12.2 Axios with TypeScript
- Typed request/response interceptors
- Generic request methods
- Error type narrowing

### 12.3 API Response Types
- Discriminated union responses
- Pagination types
- Error response types

```typescript
type ApiResponse<T> = 
  | { success: true; data: T }
  | { success: false; error: { code: string; message: string } };

interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    pageSize: number;
    total: number;
    totalPages: number;
  };
}
```

### 12.4 OpenAPI/Swagger Integration
- Generating types from OpenAPI specs
- Tools: `openapi-typescript`, `swagger-typescript-api`
- Keeping types in sync with backend

> üí° **Production Tip**: Auto-generate API types from OpenAPI specs to ensure frontend-backend type safety.

---

## Chapter 13: Testing with TypeScript

### 13.1 Jest Configuration
- `ts-jest` setup
- Type checking in tests
- Custom matchers typing

### 13.2 React Testing Library
- Typed queries
- Custom render with providers
- User event typing

```typescript
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

function renderWithProviders(ui: React.ReactElement) {
  return render(
    <QueryClientProvider client={queryClient}>
      <ThemeProvider>{ui}</ThemeProvider>
    </QueryClientProvider>
  );
}

test('submits form correctly', async () => {
  const user = userEvent.setup();
  renderWithProviders(<LoginForm onSubmit={mockSubmit} />);
  
  await user.type(screen.getByLabelText(/email/i), 'test@example.com');
  await user.click(screen.getByRole('button', { name: /submit/i }));
  
  expect(mockSubmit).toHaveBeenCalledWith({ email: 'test@example.com' });
});
```

### 13.3 Mocking with TypeScript
- Typed mocks with `jest.Mock`
- `jest.Mocked<T>` utility
- Mocking modules

```typescript
const mockFetch = jest.fn() as jest.MockedFunction<typeof fetchUser>;
mockFetch.mockResolvedValue({ id: '1', name: 'Test' });
```

### 13.4 MSW (Mock Service Worker)
- Typed request handlers
- Response typing

---

## Chapter 14: Performance Optimization Types

### 14.1 React.memo with TypeScript
- Typed memo components
- Custom comparison functions
- Generic memoized components

```typescript
const MemoizedList = React.memo(function List<T>({ items }: { items: T[] }) {
  return <ul>{items.map(renderItem)}</ul>;
}) as <T>(props: { items: T[] }) => JSX.Element;
```

### 14.2 Lazy Loading
- `React.lazy` with TypeScript
- Dynamic imports typing
- Suspense boundary typing

```typescript
const LazyComponent = React.lazy(
  () => import('./HeavyComponent')
) as React.LazyExoticComponent<React.ComponentType<HeavyComponentProps>>;
```

### 14.3 Code Splitting Patterns
- Route-based splitting
- Component-based splitting
- Library splitting

---

## Chapter 15: Error Handling

### 15.1 Error Boundaries with TypeScript
- Class-based error boundaries
- Error boundary props and state
- `getDerivedStateFromError` typing

```typescript
interface ErrorBoundaryProps {
  fallback: React.ReactNode;
  children: React.ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  state: ErrorBoundaryState = { hasError: false, error: null };
  
  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    return { hasError: true, error };
  }
  
  render() {
    if (this.state.hasError) return this.props.fallback;
    return this.props.children;
  }
}
```

### 15.2 Error Types
- Custom error classes
- Error type narrowing
- Result/Either pattern

```typescript
class ApiError extends Error {
  constructor(
    public statusCode: number,
    message: string
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

// Result pattern
type Result<T, E = Error> = 
  | { ok: true; value: T }
  | { ok: false; error: E };
```

---

## Chapter 16: Design System & Component Library Patterns

### 16.1 Theme Typing
- Typed theme objects
- CSS-in-JS typing (styled-components, Emotion)
- Tailwind with TypeScript

```typescript
// styled-components theme typing
import 'styled-components';

declare module 'styled-components' {
  export interface DefaultTheme {
    colors: {
      primary: string;
      secondary: string;
      error: string;
    };
    spacing: (factor: number) => string;
  }
}
```

### 16.2 Variant Props Pattern
- Using `cva` (class-variance-authority)
- Type-safe variant components

```typescript
import { cva, type VariantProps } from 'class-variance-authority';

const buttonVariants = cva('base-button', {
  variants: {
    intent: { primary: 'btn-primary', secondary: 'btn-secondary' },
    size: { sm: 'btn-sm', md: 'btn-md', lg: 'btn-lg' },
  },
  defaultVariants: { intent: 'primary', size: 'md' },
});

type ButtonProps = VariantProps<typeof buttonVariants> & 
  React.ButtonHTMLAttributes<HTMLButtonElement>;

function Button({ intent, size, className, ...props }: ButtonProps) {
  return <button className={buttonVariants({ intent, size, className })} {...props} />;
}
```

### 16.3 Component Documentation
- Storybook with TypeScript
- Auto-generated prop tables
- JSDoc comments for IntelliSense

---

## Chapter 17: Advanced TypeScript Patterns

### 17.1 Builder Pattern
- Fluent API with TypeScript
- Method chaining types

### 17.2 Factory Pattern
- Generic factories
- Abstract factories

### 17.3 Branded Types
- Nominal typing in TypeScript
- Type-safe IDs

```typescript
type Brand<T, B> = T & { __brand: B };

type UserId = Brand<string, 'UserId'>;
type PostId = Brand<string, 'PostId'>;

function createUserId(id: string): UserId {
  return id as UserId;
}

function getUser(id: UserId) { /* ... */ }

const userId = createUserId('123');
const postId = '456' as PostId;

getUser(userId); // OK
getUser(postId); // Error! PostId is not assignable to UserId
```

> üí° **Production Tip**: Use branded types to prevent mixing up IDs of different entities.

### 17.4 Exhaustive Checking
- `never` type for exhaustive switches
- `assertNever` utility

```typescript
function assertNever(x: never): never {
  throw new Error(`Unexpected value: ${x}`);
}

type Status = 'pending' | 'success' | 'error';

function handleStatus(status: Status) {
  switch (status) {
    case 'pending': return 'Loading...';
    case 'success': return 'Done!';
    case 'error': return 'Failed!';
    default: return assertNever(status); // Compile error if case missed
  }
}
```

### 17.5 Type-Safe Event Emitter
- Generic event maps
- Typed listeners

---

## Chapter 18: Configuration & Tooling

### 18.1 tsconfig.json Deep Dive
- Essential compiler options:
  - `strict`: Enable all strict checks
  - `noImplicitAny`: Error on implicit any
  - `strictNullChecks`: Null/undefined checking
  - `noUncheckedIndexedAccess`: Safer array/object access
  - `exactOptionalPropertyTypes`: Stricter optional properties
  - `noImplicitReturns`: Ensure all paths return
  - `noFallthroughCasesInSwitch`: Prevent switch fallthrough
- Path aliases configuration
- Project references

> ‚ö†Ô∏è **Interview Alert**: Know what `strict: true` enables and why each option matters.

### 18.2 ESLint Configuration
- `@typescript-eslint` rules
- Important rules:
  - `@typescript-eslint/no-explicit-any`
  - `@typescript-eslint/explicit-function-return-type`
  - `@typescript-eslint/no-floating-promises`
  - `@typescript-eslint/no-misused-promises`
  - `@typescript-eslint/strict-boolean-expressions`

### 18.3 Monorepo Setup
- Turborepo/Nx with TypeScript
- Shared types packages
- Internal packages configuration

---

## Chapter 19: Security Considerations

### 19.1 XSS Prevention
- `dangerouslySetInnerHTML` typing
- DOMPurify integration
- Content Security Policy types

### 19.2 Type-Safe Environment Variables
- Zod validation for env vars
- Typed process.env

```typescript
import { z } from 'zod';

const envSchema = z.object({
  VITE_API_URL: z.string().url(),
  VITE_ENV: z.enum(['development', 'staging', 'production']),
});

export const env = envSchema.parse(import.meta.env);
```

---

## Chapter 20: Interview Preparation

### 20.1 Common Coding Challenges
1. Implement `Pick`, `Omit`, `Partial` from scratch
2. Create a type-safe event emitter
3. Build a generic Table component
4. Implement a polymorphic Button component
5. Create a type-safe form hook
6. Build a typed API client

### 20.2 Conceptual Questions
1. Difference between `interface` and `type`
2. Explain type narrowing techniques
3. When to use `unknown` vs `any`
4. How does structural typing work?
5. Explain discriminated unions
6. What are conditional types?
7. How do mapped types work?
8. Explain the `infer` keyword
9. What is declaration merging?
10. How to handle async/await types?

### 20.3 React + TypeScript Questions
1. `React.FC` pros and cons
2. Typing custom hooks
3. Generic components implementation
4. Context with TypeScript
5. Ref typing (DOM vs mutable)
6. Event handler types
7. HOC typing challenges
8. Render props with generics

### 20.4 Production Scenarios
1. How to share types between frontend and backend?
2. Strategies for migrating JavaScript to TypeScript
3. Handling third-party libraries without types
4. Performance implications of TypeScript
5. Type-safe API integration approaches

---

# APPENDIX

## A: Cheat Sheet - Essential Types

```typescript
// React Types
React.ReactNode        // Any renderable content
React.ReactElement     // React element specifically  
React.FC<Props>        // Function component (controversial)
React.ComponentType<P> // Class or function component
React.ElementType      // String tag or component
React.CSSProperties    // Inline style object

// Event Types
React.MouseEvent<HTMLButtonElement>
React.ChangeEvent<HTMLInputElement>
React.FormEvent<HTMLFormElement>
React.KeyboardEvent<HTMLElement>

// Ref Types
React.RefObject<T>        // Readonly ref (DOM)
React.MutableRefObject<T> // Mutable ref
React.ForwardedRef<T>     // For forwardRef

// Props Utilities
React.ComponentProps<typeof Comp>
React.ComponentPropsWithRef<'button'>
React.ComponentPropsWithoutRef<'button'>
React.PropsWithChildren<Props>

// Utility Types  
Partial<T>    Required<T>    Readonly<T>
Pick<T, K>    Omit<T, K>     Record<K, V>
Exclude<T,U>  Extract<T,U>   NonNullable<T>
ReturnType<T> Parameters<T>  Awaited<T>
```

## B: Common Mistakes to Avoid

1. ‚ùå Using `any` instead of proper typing
2. ‚ùå Ignoring `null` and `undefined` cases
3. ‚ùå Not using discriminated unions for related types
4. ‚ùå Over-using type assertions (`as`)
5. ‚ùå Forgetting to type async function returns
6. ‚ùå Using `object` type instead of proper interface
7. ‚ùå Not leveraging type inference
8. ‚ùå Ignoring strict mode warnings
9. ‚ùå Not using `readonly` where appropriate
10. ‚ùå Mixing up `useRef<T>(null)` patterns

## C: Resources
- TypeScript Handbook (official)
- React TypeScript Cheatsheet (GitHub)
- Total TypeScript by Matt Pocock
- Type Challenges Repository
- DefinitelyTyped Repository
