<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 12: API Integration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .content {
            padding: 40px;
        }
        
        .section {
            margin-bottom: 50px;
        }
        
        .section h2 {
            color: #f5576c;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #f5576c;
        }
        
        .section h3 {
            color: #f093fb;
            font-size: 1.5em;
            margin: 30px 0 15px 0;
        }
        
        .subsection {
            margin-bottom: 30px;
        }
        
        p {
            margin-bottom: 15px;
            font-size: 1.05em;
        }
        
        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #f5576c;
        }
        
        .code-block pre {
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
        }
        
        .highlight {
            background: #fff3cd;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }
        
        .tip, .warning, .info {
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 5px solid;
        }
        
        .tip {
            background: #d4edda;
            border-color: #28a745;
        }
        
        .warning {
            background: #fff3cd;
            border-color: #ffc107;
        }
        
        .info {
            background: #d1ecf1;
            border-color: #17a2b8;
        }
        
        .tip::before, .warning::before, .info::before {
            font-weight: bold;
            display: block;
            margin-bottom: 10px;
        }
        
        .tip::before {
            content: "üí° Pro Tip:";
            color: #28a745;
        }
        
        .warning::before {
            content: "‚ö†Ô∏è Important:";
            color: #ffc107;
        }
        
        .info::before {
            content: "‚ÑπÔ∏è Note:";
            color: #17a2b8;
        }
        
        .diagram {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 30px;
            margin: 30px 0;
        }
        
        .flow-diagram {
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .flow-box {
            background: white;
            border: 2px solid #f5576c;
            border-radius: 8px;
            padding: 20px;
            min-width: 150px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .flow-arrow {
            font-size: 2em;
            color: #f5576c;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-bottom: 20px;
        }
        
        li {
            margin-bottom: 10px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            border: 1px solid #dee2e6;
            padding: 12px;
            text-align: left;
        }
        
        th {
            background: #f5576c;
            color: white;
        }
        
        tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-card {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
        }
        
        .comparison-card h4 {
            color: #f5576c;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåê Chapter 12: API Integration</h1>
            <p>Building Type-Safe API Communication Layers</p>
        </div>
        
        <div class="content">
            <!-- Section 12.1 -->
            <div class="section">
                <h2>12.1 Fetch with TypeScript</h2>
                
                <p>The native Fetch API provides a clean way to make HTTP requests, but lacks built-in TypeScript typing for responses. Let's build a type-safe wrapper.</p>
                
                <div class="subsection">
                    <h3>Basic Typed Fetch Wrapper</h3>
                    
                    <div class="diagram">
                        <h4>Fetch Request/Response Flow</h4>
                        <div class="flow-diagram">
                            <div class="flow-box">
                                <strong>Request</strong><br>
                                Type-safe input
                            </div>
                            <div class="flow-arrow">‚Üí</div>
                            <div class="flow-box">
                                <strong>Fetch</strong><br>
                                HTTP call
                            </div>
                            <div class="flow-arrow">‚Üí</div>
                            <div class="flow-box">
                                <strong>Parse</strong><br>
                                JSON conversion
                            </div>
                            <div class="flow-arrow">‚Üí</div>
                            <div class="flow-box">
                                <strong>Response</strong><br>
                                Type-safe output
                            </div>
                        </div>
                    </div>
                    
                    <div class="code-block">
<pre>
// api/fetch-wrapper.ts

// Custom error class for API errors
export class ApiError extends Error {
  constructor(
    public status: number,
    public statusText: string,
    message: string,
    public response?: any
  ) {
    super(message);
    this.name = 'ApiError';
    
    // Maintains proper stack trace for where our error was thrown
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ApiError);
    }
  }
}

// Generic fetch wrapper with type safety
export async function fetchJson&lt;TResponse&gt;(
  url: string,
  options?: RequestInit
): Promise&lt;TResponse&gt; {
  try {
    const response = await fetch(url, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
      },
    });
    
    // Handle non-OK responses
    if (!response.ok) {
      const errorBody = await response.text();
      throw new ApiError(
        response.status,
        response.statusText,
        `API request failed: ${response.statusText}`,
        errorBody
      );
    }
    
    // Handle empty responses (204 No Content, etc.)
    const contentType = response.headers.get('content-type');
    if (!contentType?.includes('application/json')) {
      return null as TResponse;
    }
    
    // Parse and return JSON with type
    const data = await response.json();
    return data as TResponse;
    
  } catch (error) {
    // Re-throw ApiError as-is
    if (error instanceof ApiError) {
      throw error;
    }
    
    // Wrap other errors (network errors, etc.)
    throw new ApiError(
      0,
      'Network Error',
      error instanceof Error ? error.message : 'Unknown error',
    );
  }
}

// Convenience methods for different HTTP verbs
export const api = {
  get: &lt;T&gt;(url: string, options?: RequestInit) =&gt;
    fetchJson&lt;T&gt;(url, { ...options, method: 'GET' }),
  
  post: &lt;T, TBody = any&gt;(url: string, body: TBody, options?: RequestInit) =&gt;
    fetchJson&lt;T&gt;(url, {
      ...options,
      method: 'POST',
      body: JSON.stringify(body),
    }),
  
  put: &lt;T, TBody = any&gt;(url: string, body: TBody, options?: RequestInit) =&gt;
    fetchJson&lt;T&gt;(url, {
      ...options,
      method: 'PUT',
      body: JSON.stringify(body),
    }),
  
  patch: &lt;T, TBody = any&gt;(url: string, body: TBody, options?: RequestInit) =&gt;
    fetchJson&lt;T&gt;(url, {
      ...options,
      method: 'PATCH',
      body: JSON.stringify(body),
    }),
  
  delete: &lt;T&gt;(url: string, options?: RequestInit) =&gt;
    fetchJson&lt;T&gt;(url, { ...options, method: 'DELETE' }),
};
</pre>
                    </div>
                </div>
                
                <div class="subsection">
                    <h3>Type-Safe API Client with Interceptors</h3>
                    
                    <p>A more advanced implementation with request/response interceptors for authentication, logging, and error handling.</p>
                    
                    <div class="code-block">
<pre>
// api/api-client.ts

type RequestInterceptor = (config: RequestInit) => RequestInit | Promise&lt;RequestInit&gt;;
type ResponseInterceptor&lt;T&gt; = (response: T) => T | Promise&lt;T&gt;;
type ErrorInterceptor = (error: ApiError) => never | Promise&lt;never&gt;;

interface ApiClientConfig {
  baseURL: string;
  timeout?: number;
  headers?: Record&lt;string, string&gt;;
  requestInterceptors?: RequestInterceptor[];
  responseInterceptors?: ResponseInterceptor&lt;any&gt;[];
  errorInterceptors?: ErrorInterceptor[];
}

export class ApiClient {
  private config: ApiClientConfig;
  private requestInterceptors: RequestInterceptor[] = [];
  private responseInterceptors: ResponseInterceptor&lt;any&gt;[] = [];
  private errorInterceptors: ErrorInterceptor[] = [];
  
  constructor(config: ApiClientConfig) {
    this.config = config;
    
    // Add default interceptors
    this.requestInterceptors = config.requestInterceptors || [];
    this.responseInterceptors = config.responseInterceptors || [];
    this.errorInterceptors = config.errorInterceptors || [];
  }
  
  // Add interceptors dynamically
  addRequestInterceptor(interceptor: RequestInterceptor) {
    this.requestInterceptors.push(interceptor);
  }
  
  addResponseInterceptor&lt;T&gt;(interceptor: ResponseInterceptor&lt;T&gt;) {
    this.responseInterceptors.push(interceptor);
  }
  
  addErrorInterceptor(interceptor: ErrorInterceptor) {
    this.errorInterceptors.push(interceptor);
  }
  
  // Main request method
  async request&lt;TResponse&gt;(
    endpoint: string,
    options: RequestInit = {}
  ): Promise&lt;TResponse&gt; {
    const url = `${this.config.baseURL}${endpoint}`;
    
    // Apply request interceptors
    let requestConfig = {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...this.config.headers,
        ...options.headers,
      },
    };
    
    for (const interceptor of this.requestInterceptors) {
      requestConfig = await interceptor(requestConfig);
    }
    
    // Handle timeout
    const controller = new AbortController();
    const timeoutId = this.config.timeout
      ? setTimeout(() =&gt; controller.abort(), this.config.timeout)
      : null;
    
    try {
      const response = await fetch(url, {
        ...requestConfig,
        signal: controller.signal,
      });
      
      if (timeoutId) clearTimeout(timeoutId);
      
      if (!response.ok) {
        const errorBody = await response.text();
        const error = new ApiError(
          response.status,
          response.statusText,
          `API request failed: ${response.statusText}`,
          errorBody
        );
        
        // Apply error interceptors
        for (const interceptor of this.errorInterceptors) {
          await interceptor(error);
        }
        
        throw error;
      }
      
      let data = await response.json() as TResponse;
      
      // Apply response interceptors
      for (const interceptor of this.responseInterceptors) {
        data = await interceptor(data);
      }
      
      return data;
      
    } catch (error) {
      if (timeoutId) clearTimeout(timeoutId);
      
      if (error instanceof ApiError) {
        throw error;
      }
      
      const apiError = new ApiError(
        0,
        'Network Error',
        error instanceof Error ? error.message : 'Unknown error'
      );
      
      // Apply error interceptors
      for (const interceptor of this.errorInterceptors) {
        await interceptor(apiError);
      }
      
      throw apiError;
    }
  }
  
  // Convenience methods
  get&lt;T&gt;(endpoint: string, options?: RequestInit) {
    return this.request&lt;T&gt;(endpoint, { ...options, method: 'GET' });
  }
  
  post&lt;T, TBody = any&gt;(endpoint: string, body: TBody, options?: RequestInit) {
    return this.request&lt;T&gt;(endpoint, {
      ...options,
      method: 'POST',
      body: JSON.stringify(body),
    });
  }
  
  put&lt;T, TBody = any&gt;(endpoint: string, body: TBody, options?: RequestInit) {
    return this.request&lt;T&gt;(endpoint, {
      ...options,
      method: 'PUT',
      body: JSON.stringify(body),
    });
  }
  
  patch&lt;T, TBody = any&gt;(endpoint: string, body: TBody, options?: RequestInit) {
    return this.request&lt;T&gt;(endpoint, {
      ...options,
      method: 'PATCH',
      body: JSON.stringify(body),
    });
  }
  
  delete&lt;T&gt;(endpoint: string, options?: RequestInit) {
    return this.request&lt;T&gt;(endpoint, { ...options, method: 'DELETE' });
  }
}

// Create and configure API client instance
const apiClient = new ApiClient({
  baseURL: import.meta.env.VITE_API_URL || 'https://api.example.com',
  timeout: 30000,
});

// Add authentication interceptor
apiClient.addRequestInterceptor((config) =&gt; {
  const token = localStorage.getItem('auth_token');
  if (token) {
    config.headers = {
      ...config.headers,
      Authorization: `Bearer ${token}`,
    };
  }
  return config;
});

// Add logging interceptor
apiClient.addResponseInterceptor((response) =&gt; {
  console.log('API Response:', response);
  return response;
});

// Add error handling interceptor
apiClient.addErrorInterceptor((error) =&gt; {
  if (error.status === 401) {
    // Handle unauthorized - redirect to login
    window.location.href = '/login';
  }
  console.error('API Error:', error);
  throw error;
});

export default apiClient;
</pre>
                    </div>
                </div>
                
                <div class="subsection">
                    <h3>Usage Examples</h3>
                    
                    <div class="code-block">
<pre>
// types/user.ts
export interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'user';
  createdAt: string;
}

export interface CreateUserDto {
  name: string;
  email: string;
  password: string;
}

export interface UpdateUserDto {
  name?: string;
  email?: string;
}

// api/users.ts
import apiClient from './api-client';
import type { User, CreateUserDto, UpdateUserDto } from '../types/user';

export const userApi = {
  // Get all users
  getAll: () =&gt; 
    apiClient.get&lt;User[]&gt;('/users'),
  
  // Get user by ID
  getById: (id: string) =&gt; 
    apiClient.get&lt;User&gt;(`/users/${id}`),
  
  // Create new user
  create: (userData: CreateUserDto) =&gt; 
    apiClient.post&lt;User, CreateUserDto&gt;('/users', userData),
  
  // Update user
  update: (id: string, updates: UpdateUserDto) =&gt; 
    apiClient.patch&lt;User, UpdateUserDto&gt;(`/users/${id}`, updates),
  
  // Delete user
  delete: (id: string) =&gt; 
    apiClient.delete&lt;void&gt;(`/users/${id}`),
};

// In a React component
function UserList() {
  const [users, setUsers] = useState&lt;User[]&gt;([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;string | null&gt;(null);
  
  useEffect(() =&gt; {
    loadUsers();
  }, []);
  
  const loadUsers = async () =&gt; {
    try {
      setLoading(true);
      setError(null);
      const data = await userApi.getAll(); // ‚úÖ Type-safe!
      setUsers(data);
    } catch (err) {
      if (err instanceof ApiError) {
        setError(err.message);
      } else {
        setError('An unexpected error occurred');
      }
    } finally {
      setLoading(false);
    }
  };
  
  const handleCreateUser = async (userData: CreateUserDto) =&gt; {
    try {
      const newUser = await userApi.create(userData); // ‚úÖ Type-safe!
      setUsers(prev =&gt; [...prev, newUser]);
    } catch (err) {
      // Handle error
    }
  };
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  
  return (
    &lt;ul&gt;
      {users.map(user =&gt; (
        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}
</pre>
                    </div>
                </div>
            </div>
            
            <!-- Section 12.2 -->
            <div class="section">
                <h2>12.2 Axios with TypeScript</h2>
                
                <p>Axios is a popular HTTP client that provides a more feature-rich alternative to fetch, with built-in request/response transformation and better error handling.</p>
                
                <div class="comparison-grid">
                    <div class="comparison-card">
                        <h4>‚úÖ Fetch Advantages</h4>
                        <ul>
                            <li>Native browser API (no dependencies)</li>
                            <li>Smaller bundle size</li>
                            <li>Modern Promise-based API</li>
                            <li>Built into all modern browsers</li>
                        </ul>
                    </div>
                    <div class="comparison-card">
                        <h4>‚úÖ Axios Advantages</h4>
                        <ul>
                            <li>Better error handling out of the box</li>
                            <li>Request/response interceptors</li>
                            <li>Automatic JSON transformation</li>
                            <li>Progress tracking for uploads</li>
                            <li>Request cancellation</li>
                        </ul>
                    </div>
                </div>
                
                <div class="subsection">
                    <h3>Type-Safe Axios Setup</h3>
                    
                    <div class="code-block">
<pre>
// api/axios-client.ts
import axios, { 
  AxiosInstance, 
  AxiosRequestConfig, 
  AxiosResponse, 
  AxiosError 
} from 'axios';

// Custom error type for better type safety
export interface ApiErrorResponse {
  message: string;
  code: string;
  errors?: Record&lt;string, string[]&gt;;
}

// Create typed axios instance
const axiosClient: AxiosInstance = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'https://api.example.com',
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor with type safety
axiosClient.interceptors.request.use(
  (config) =&gt; {
    // Add authentication token
    const token = localStorage.getItem('auth_token');
    if (token && config.headers) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    
    // Log request (development only)
    if (import.meta.env.DEV) {
      console.log('‚Üí Request:', config.method?.toUpperCase(), config.url);
    }
    
    return config;
  },
  (error) =&gt; {
    return Promise.reject(error);
  }
);

// Response interceptor with type safety
axiosClient.interceptors.response.use(
  (response: AxiosResponse) =&gt; {
    // Log response (development only)
    if (import.meta.env.DEV) {
      console.log('‚Üê Response:', response.status, response.config.url);
    }
    
    return response;
  },
  (error: AxiosError&lt;ApiErrorResponse&gt;) =&gt; {
    // Type-safe error handling
    if (error.response) {
      // Server responded with error status
      const { status, data } = error.response;
      
      switch (status) {
        case 401:
          // Unauthorized - clear token and redirect
          localStorage.removeItem('auth_token');
          window.location.href = '/login';
          break;
        
        case 403:
          // Forbidden
          console.error('Access denied:', data.message);
          break;
        
        case 404:
          // Not found
          console.error('Resource not found:', data.message);
          break;
        
        case 422:
          // Validation errors
          console.error('Validation errors:', data.errors);
          break;
        
        case 500:
          // Server error
          console.error('Server error:', data.message);
          break;
      }
    } else if (error.request) {
      // Request made but no response received
      console.error('Network error - no response received');
    } else {
      // Something else happened
      console.error('Request setup error:', error.message);
    }
    
    return Promise.reject(error);
  }
);

// Type-safe wrapper methods
export const axiosApi = {
  get: &lt;T&gt;(url: string, config?: AxiosRequestConfig) =&gt;
    axiosClient.get&lt;T&gt;(url, config).then(res =&gt; res.data),
  
  post: &lt;T, TData = any&gt;(url: string, data: TData, config?: AxiosRequestConfig) =&gt;
    axiosClient.post&lt;T&gt;(url, data, config).then(res =&gt; res.data),
  
  put: &lt;T, TData = any&gt;(url: string, data: TData, config?: AxiosRequestConfig) =&gt;
    axiosClient.put&lt;T&gt;(url, data, config).then(res =&gt; res.data),
  
  patch: &lt;T, TData = any&gt;(url: string, data: TData, config?: AxiosRequestConfig) =&gt;
    axiosClient.patch&lt;T&gt;(url, data, config).then(res =&gt; res.data),
  
  delete: &lt;T&gt;(url: string, config?: AxiosRequestConfig) =&gt;
    axiosClient.delete&lt;T&gt;(url, config).then(res =&gt; res.data),
};

export default axiosClient;
</pre>
                    </div>
                </div>
                
                <div class="subsection">
                    <h3>Error Handling with Axios</h3>
                    
                    <div class="code-block">
<pre>
// utils/error-handler.ts
import { AxiosError } from 'axios';
import type { ApiErrorResponse } from './axios-client';

export function handleApiError(error: unknown): string {
  if (axios.isAxiosError(error)) {
    const axiosError = error as AxiosError&lt;ApiErrorResponse&gt;;
    
    if (axiosError.response) {
      // Server responded with error
      return axiosError.response.data.message || 'An error occurred';
    } else if (axiosError.request) {
      // No response received
      return 'Network error. Please check your connection.';
    }
  }
  
  return 'An unexpected error occurred';
}

// Custom hook for API calls with error handling
export function useApiCall&lt;T&gt;() {
  const [data, setData] = useState&lt;T | null&gt;(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState&lt;string | null&gt;(null);
  
  const execute = async (apiCall: () =&gt; Promise&lt;T&gt;) =&gt; {
    try {
      setLoading(true);
      setError(null);
      const result = await apiCall();
      setData(result);
      return result;
    } catch (err) {
      const errorMessage = handleApiError(err);
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  };
  
  return { data, loading, error, execute };
}

// Usage
function UserProfile({ userId }: { userId: string }) {
  const { data: user, loading, error, execute } = useApiCall&lt;User&gt;();
  
  useEffect(() =&gt; {
    execute(() =&gt; userApi.getById(userId));
  }, [userId]);
  
  if (loading) return &lt;Spinner /&gt;;
  if (error) return &lt;ErrorMessage message={error} /&gt;;
  if (!user) return null;
  
  return &lt;div&gt;{user.name}&lt;/div&gt;;
}
</pre>
                    </div>
                </div>
            </div>
            
            <!-- Section 12.3 -->
            <div class="section">
                <h2>12.3 API Response Types</h2>
                
                <p>Defining proper types for API responses ensures type safety throughout your application and catches errors at compile time.</p>
                
                <div class="subsection">
                    <h3>Discriminated Union Responses</h3>
                    
                    <p>Use discriminated unions to represent different response states. This pattern provides exhaustive type checking.</p>
                    
                    <div class="code-block">
<pre>
// types/api-response.ts

// Success/Error response pattern
export type ApiResponse&lt;T&gt; = 
  | { success: true; data: T }
  | { success: false; error: ApiError };

export interface ApiError {
  code: string;
  message: string;
  details?: Record&lt;string, any&gt;;
}

// Usage in API functions
async function fetchUser(id: string): Promise&lt;ApiResponse&lt;User&gt;&gt; {
  try {
    const data = await axiosApi.get&lt;User&gt;(`/users/${id}`);
    return { success: true, data };
  } catch (error) {
    return {
      success: false,
      error: {
        code: 'USER_FETCH_FAILED',
        message: handleApiError(error),
      },
    };
  }
}

// Component usage with type narrowing
function UserProfile({ userId }: { userId: string }) {
  const [response, setResponse] = useState&lt;ApiResponse&lt;User&gt; | null&gt;(null);
  
  useEffect(() =&gt; {
    fetchUser(userId).then(setResponse);
  }, [userId]);
  
  if (!response) return &lt;Spinner /&gt;;
  
  // ‚úÖ TypeScript ensures exhaustive checking
  if (response.success) {
    return &lt;div&gt;{response.data.name}&lt;/div&gt;; // data is available
  } else {
    return &lt;div&gt;Error: {response.error.message}&lt;/div&gt;; // error is available
  }
}

// Alternative: Result/Either pattern
export type Result&lt;T, E = Error&gt; = 
  | { ok: true; value: T }
  | { ok: false; error: E };

// More functional approach
function handleResult&lt;T, E&gt;(
  result: Result&lt;T, E&gt;,
  onSuccess: (value: T) =&gt; void,
  onError: (error: E) =&gt; void
) {
  if (result.ok) {
    onSuccess(result.value);
  } else {
    onError(result.error);
  }
}
</pre>
                    </div>
                </div>
                
                <div class="subsection">
                    <h3>Pagination Types</h3>
                    
                    <div class="code-block">
<pre>
// types/pagination.ts

export interface PaginationMeta {
  page: number;
  pageSize: number;
  total: number;
  totalPages: number;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
}

export interface PaginatedResponse&lt;T&gt; {
  data: T[];
  pagination: PaginationMeta;
}

// Alternative: Cursor-based pagination
export interface CursorPaginationMeta {
  nextCursor: string | null;
  previousCursor: string | null;
  hasMore: boolean;
}

export interface CursorPaginatedResponse&lt;T&gt; {
  data: T[];
  pagination: CursorPaginationMeta;
}

// API function for paginated data
export const postApi = {
  getAll: (page: number = 1, pageSize: number = 20) =&gt;
    axiosApi.get&lt;PaginatedResponse&lt;Post&gt;&gt;(
      `/posts?page=${page}&pageSize=${pageSize}`
    ),
};

// Custom hook for pagination
function usePagination&lt;T&gt;(
  fetchFn: (page: number, pageSize: number) =&gt; Promise&lt;PaginatedResponse&lt;T&gt;&gt;,
  initialPageSize: number = 20
) {
  const [data, setData] = useState&lt;T[]&gt;([]);
  const [pagination, setPagination] = useState&lt;PaginationMeta | null&gt;(null);
  const [loading, setLoading] = useState(false);
  const [currentPage, setCurrentPage] = useState(1);
  
  const loadPage = async (page: number) =&gt; {
    setLoading(true);
    try {
      const response = await fetchFn(page, initialPageSize);
      setData(response.data);
      setPagination(response.pagination);
      setCurrentPage(page);
    } catch (error) {
      console.error('Failed to load page:', error);
    } finally {
      setLoading(false);
    }
  };
  
  useEffect(() =&gt; {
    loadPage(1);
  }, []);
  
  return {
    data,
    pagination,
    loading,
    currentPage,
    nextPage: () =&gt; pagination?.hasNextPage && loadPage(currentPage + 1),
    previousPage: () =&gt; pagination?.hasPreviousPage && loadPage(currentPage - 1),
    goToPage: loadPage,
  };
}
</pre>
                    </div>
                </div>
                
                <div class="subsection">
                    <h3>Comprehensive Error Response Types</h3>
                    
                    <div class="code-block">
<pre>
// types/error-response.ts

export interface ValidationError {
  field: string;
  message: string;
  code: string;
}

export interface ErrorResponse {
  error: {
    code: string;
    message: string;
    timestamp: string;
    path: string;
    validationErrors?: ValidationError[];
    stackTrace?: string; // Only in development
  };
}

// HTTP status-specific error types
export type ApiErrorType =
  | { status: 400; type: 'BAD_REQUEST'; details: ValidationError[] }
  | { status: 401; type: 'UNAUTHORIZED'; message: string }
  | { status: 403; type: 'FORBIDDEN'; message: string }
  | { status: 404; type: 'NOT_FOUND'; resource: string }
  | { status: 409; type: 'CONFLICT'; message: string }
  | { status: 422; type: 'VALIDATION_ERROR'; errors: ValidationError[] }
  | { status: 429; type: 'RATE_LIMIT'; retryAfter: number }
  | { status: 500; type: 'SERVER_ERROR'; message: string }
  | { status: 503; type: 'SERVICE_UNAVAILABLE'; message: string };

// Error handler with type narrowing
export function handleTypedApiError(error: ApiErrorType): string {
  switch (error.type) {
    case 'BAD_REQUEST':
      return `Invalid request: ${error.details.map(d =&gt; d.message).join(', ')}`;
    
    case 'UNAUTHORIZED':
      return 'Please log in to continue';
    
    case 'FORBIDDEN':
      return 'You do not have permission to perform this action';
    
    case 'NOT_FOUND':
      return `${error.resource} not found`;
    
    case 'VALIDATION_ERROR':
      return error.errors.map(e =&gt; `${e.field}: ${e.message}`).join(', ');
    
    case 'RATE_LIMIT':
      return `Too many requests. Please try again in ${error.retryAfter} seconds`;
    
    case 'SERVER_ERROR':
    case 'SERVICE_UNAVAILABLE':
      return 'Server error. Please try again later';
    
    default:
      // This will cause a TypeScript error if we miss a case
      const exhaustiveCheck: never = error;
      return 'An unknown error occurred';
  }
}
</pre>
                    </div>
                </div>
            </div>
            
            <!-- Section 12.4 -->
            <div class="section">
                <h2>12.4 OpenAPI/Swagger Integration</h2>
                
                <p>OpenAPI (Swagger) specifications allow you to automatically generate TypeScript types from your API documentation, ensuring perfect synchronization between frontend and backend.</p>
                
                <div class="diagram">
                    <h4>OpenAPI Type Generation Workflow</h4>
                    <div class="flow-diagram">
                        <div class="flow-box">
                            <strong>Backend</strong><br>
                            OpenAPI spec
                        </div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-box">
                            <strong>Generator</strong><br>
                            openapi-typescript
                        </div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-box">
                            <strong>Types</strong><br>
                            TypeScript interfaces
                        </div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-box">
                            <strong>Frontend</strong><br>
                            Type-safe API
                        </div>
                    </div>
                </div>
                
                <div class="subsection">
                    <h3>Setup and Generation</h3>
                    
                    <div class="code-block">
<pre>
// package.json scripts
{
  "scripts": {
    "generate-api-types": "openapi-typescript https://api.example.com/openapi.json -o src/types/api.ts",
    "generate-api-types:local": "openapi-typescript ./openapi.json -o src/types/api.ts"
  }
}

// Install the package
// npm install --save-dev openapi-typescript

// Generated types will look like this:
// types/api.ts (auto-generated)
export interface paths {
  '/users': {
    get: {
      responses: {
        200: {
          content: {
            'application/json': components['schemas']['UserList'];
          };
        };
      };
    };
    post: {
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateUserDto'];
        };
      };
      responses: {
        201: {
          content: {
            'application/json': components['schemas']['User'];
          };
        };
      };
    };
  };
  '/users/{userId}': {
    get: {
      parameters: {
        path: {
          userId: string;
        };
      };
      responses: {
        200: {
          content: {
            'application/json': components['schemas']['User'];
          };
        };
      };
    };
  };
}

export interface components {
  schemas: {
    User: {
      id: string;
      name: string;
      email: string;
      role: 'admin' | 'user';
      createdAt: string;
    };
    CreateUserDto: {
      name: string;
      email: string;
      password: string;
    };
    UserList: {
      data: components['schemas']['User'][];
      pagination: {
        page: number;
        total: number;
      };
    };
  };
}
</pre>
                    </div>
                </div>
                
                <div class="subsection">
                    <h3>Using Generated Types</h3>
                    
                    <div class="code-block">
<pre>
// api/typed-api-client.ts
import type { paths, components } from '../types/api';

// Extract type helpers
type ApiPath = keyof paths;
type ApiMethod&lt;P extends ApiPath&gt; = keyof paths[P];
type ApiResponse&lt;P extends ApiPath, M extends ApiMethod&lt;P&gt;&gt; = 
  paths[P][M] extends { responses: { 200: { content: { 'application/json': infer R } } } }
    ? R
    : never;

// Type-safe API client
class TypedApiClient {
  async get&lt;P extends ApiPath&gt;(
    path: P
  ): Promise&lt;ApiResponse&lt;P, 'get'&gt;&gt; {
    const response = await fetch(`https://api.example.com${path}`);
    return response.json();
  }
  
  async post&lt;P extends ApiPath&gt;(
    path: P,
    body: paths[P]['post'] extends { requestBody: { content: { 'application/json': infer B } } }
      ? B
      : never
  ): Promise&lt;ApiResponse&lt;P, 'post'&gt;&gt; {
    const response = await fetch(`https://api.example.com${path}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    return response.json();
  }
}

const typedApi = new TypedApiClient();

// Usage with perfect type safety
async function example() {
  // ‚úÖ Full autocomplete and type checking
  const users = await typedApi.get('/users');
  // users is typed as UserList
  
  const newUser = await typedApi.post('/users', {
    name: 'John Doe',
    email: 'john@example.com',
    password: 'secure123',
  });
  // newUser is typed as User
  
  // ‚ùå TypeScript error - invalid path
  // await typedApi.get('/invalid-path');
  
  // ‚ùå TypeScript error - missing required field
  // await typedApi.post('/users', { name: 'John' });
}
</pre>
                    </div>
                </div>
                
                <div class="tip">
                    <strong>Best Practices for API Integration:</strong>
                    <ul>
                        <li>Always use discriminated unions for response states</li>
                        <li>Create custom hooks to encapsulate API logic</li>
                        <li>Implement proper error handling with typed errors</li>
                        <li>Use OpenAPI generation for large APIs to maintain sync</li>
                        <li>Add request/response interceptors for cross-cutting concerns</li>
                        <li>Implement retry logic for transient failures</li>
                        <li>Cache responses where appropriate</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</body>
</html>