# Chapter 24: Coding Challenges

## Overview

This chapter covers common React coding challenges you'll encounter in technical interviews. These patterns appear frequently and demonstrate your understanding of React fundamentals, state management, and best practices.

---

## 24.1 Common Patterns

### Pattern 1: Todo App with CRUD Operations

This is the most common interview challenge. It tests state management, event handling, forms, and list rendering.

#### Basic Todo Implementation

```javascript
import { useState } from 'react';

function TodoApp() {
  const [todos, setTodos] = useState([]);
  const [input, setInput] = useState('');
  const [filter, setFilter] = useState('all'); // all, active, completed

  // CREATE
  const addTodo = (e) => {
    e.preventDefault();
    if (input.trim() === '') return;
    
    const newTodo = {
      id: Date.now(),
      text: input,
      completed: false,
      createdAt: new Date().toISOString()
    };
    
    setTodos([...todos, newTodo]);
    setInput('');
  };

  // READ (with filtering)
  const getFilteredTodos = () => {
    switch (filter) {
      case 'active':
        return todos.filter(todo => !todo.completed);
      case 'completed':
        return todos.filter(todo => todo.completed);
      default:
        return todos;
    }
  };

  // UPDATE
  const toggleTodo = (id) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const editTodo = (id, newText) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, text: newText } : todo
    ));
  };

  // DELETE
  const deleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  const clearCompleted = () => {
    setTodos(todos.filter(todo => !todo.completed));
  };

  // Statistics
  const activeCount = todos.filter(t => !t.completed).length;
  const completedCount = todos.filter(t => t.completed).length;

  return (
    <div className="todo-app">
      <h1>Todo List</h1>
      
      {/* Input Form */}
      <form onSubmit={addTodo}>
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="What needs to be done?"
        />
        <button type="submit">Add</button>
      </form>

      {/* Statistics */}
      <div className="stats">
        <span>Active: {activeCount}</span>
        <span>Completed: {completedCount}</span>
        <span>Total: {todos.length}</span>
      </div>

      {/* Filters */}
      <div className="filters">
        <button 
          onClick={() => setFilter('all')}
          className={filter === 'all' ? 'active' : ''}
        >
          All
        </button>
        <button 
          onClick={() => setFilter('active')}
          className={filter === 'active' ? 'active' : ''}
        >
          Active
        </button>
        <button 
          onClick={() => setFilter('completed')}
          className={filter === 'completed' ? 'active' : ''}
        >
          Completed
        </button>
      </div>

      {/* Todo List */}
      <ul className="todo-list">
        {getFilteredTodos().map(todo => (
          <TodoItem
            key={todo.id}
            todo={todo}
            onToggle={toggleTodo}
            onDelete={deleteTodo}
            onEdit={editTodo}
          />
        ))}
      </ul>

      {/* Bulk Actions */}
      {completedCount > 0 && (
        <button onClick={clearCompleted}>
          Clear Completed
        </button>
      )}
    </div>
  );
}

function TodoItem({ todo, onToggle, onDelete, onEdit }) {
  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(todo.text);

  const handleEdit = () => {
    if (editText.trim() === '') return;
    onEdit(todo.id, editText);
    setIsEditing(false);
  };

  const handleCancel = () => {
    setEditText(todo.text);
    setIsEditing(false);
  };

  if (isEditing) {
    return (
      <li className="editing">
        <input
          type="text"
          value={editText}
          onChange={(e) => setEditText(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === 'Enter') handleEdit();
            if (e.key === 'Escape') handleCancel();
          }}
          autoFocus
        />
        <button onClick={handleEdit}>Save</button>
        <button onClick={handleCancel}>Cancel</button>
      </li>
    );
  }

  return (
    <li className={todo.completed ? 'completed' : ''}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
      />
      <span onDoubleClick={() => setIsEditing(true)}>
        {todo.text}
      </span>
      <button onClick={() => onDelete(todo.id)}>Delete</button>
    </li>
  );
}

export default TodoApp;
```

#### Advanced Todo with localStorage

```javascript
import { useState, useEffect } from 'react';

function useTodos() {
  const [todos, setTodos] = useState(() => {
    // Initialize from localStorage
    const saved = localStorage.getItem('todos');
    return saved ? JSON.parse(saved) : [];
  });

  // Sync to localStorage
  useEffect(() => {
    localStorage.setItem('todos', JSON.stringify(todos));
  }, [todos]);

  const addTodo = (text) => {
    const newTodo = {
      id: Date.now(),
      text,
      completed: false,
      createdAt: new Date().toISOString()
    };
    setTodos([...todos, newTodo]);
  };

  const updateTodo = (id, updates) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, ...updates } : todo
    ));
  };

  const deleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  return {
    todos,
    addTodo,
    updateTodo,
    deleteTodo
  };
}
```

### Pattern 2: Infinite Scroll

Load more items as the user scrolls down. Tests understanding of refs, effects, and performance.

```javascript
import { useState, useEffect, useRef, useCallback } from 'react';

function InfiniteScrollList() {
  const [items, setItems] = useState([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  
  const observer = useRef();
  const lastItemRef = useCallback(node => {
    if (loading) return;
    if (observer.current) observer.current.disconnect();
    
    observer.current = new IntersectionObserver(entries => {
      if (entries[0].isIntersecting && hasMore) {
        setPage(prevPage => prevPage + 1);
      }
    });
    
    if (node) observer.current.observe(node);
  }, [loading, hasMore]);

  useEffect(() => {
    const fetchItems = async () => {
      setLoading(true);
      try {
        const response = await fetch(
          `https://api.example.com/items?page=${page}&limit=20`
        );
        const data = await response.json();
        
        setItems(prev => [...prev, ...data.items]);
        setHasMore(data.hasMore);
      } catch (error) {
        console.error('Failed to fetch items:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchItems();
  }, [page]);

  return (
    <div className="infinite-scroll">
      <h1>Infinite Scroll Example</h1>
      <div className="items-list">
        {items.map((item, index) => {
          // Attach ref to last item
          if (items.length === index + 1) {
            return (
              <div ref={lastItemRef} key={item.id} className="item">
                {item.title}
              </div>
            );
          }
          
          return (
            <div key={item.id} className="item">
              {item.title}
            </div>
          );
        })}
      </div>
      
      {loading && <div className="loading">Loading more...</div>}
      {!hasMore && <div className="end">No more items</div>}
    </div>
  );
}

export default InfiniteScrollList;
```

#### Alternative: Using Window Scroll

```javascript
function InfiniteScrollWindow() {
  const [items, setItems] = useState([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);

  const handleScroll = useCallback(() => {
    if (loading || !hasMore) return;

    const scrollTop = document.documentElement.scrollTop;
    const scrollHeight = document.documentElement.scrollHeight;
    const clientHeight = document.documentElement.clientHeight;

    if (scrollTop + clientHeight >= scrollHeight - 100) {
      setPage(prev => prev + 1);
    }
  }, [loading, hasMore]);

  useEffect(() => {
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, [handleScroll]);

  useEffect(() => {
    const fetchItems = async () => {
      setLoading(true);
      // Fetch logic here
      setLoading(false);
    };
    fetchItems();
  }, [page]);

  return (
    <div>
      {items.map(item => (
        <div key={item.id}>{item.title}</div>
      ))}
      {loading && <div>Loading...</div>}
    </div>
  );
}
```

### Pattern 3: Autocomplete/Search with Debouncing

Search as user types, with debouncing to avoid excessive API calls.

```javascript
import { useState, useEffect, useRef } from 'react';

// Custom debounce hook
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

function Autocomplete() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [selectedIndex, setSelectedIndex] = useState(-1);
  const [isOpen, setIsOpen] = useState(false);
  
  const debouncedQuery = useDebounce(query, 300);
  const inputRef = useRef(null);
  const resultsRef = useRef(null);

  useEffect(() => {
    if (debouncedQuery.length < 2) {
      setResults([]);
      setIsOpen(false);
      return;
    }

    const searchUsers = async () => {
      setLoading(true);
      try {
        const response = await fetch(
          `https://api.github.com/search/users?q=${debouncedQuery}&per_page=10`
        );
        const data = await response.json();
        setResults(data.items || []);
        setIsOpen(true);
      } catch (error) {
        console.error('Search failed:', error);
        setResults([]);
      } finally {
        setLoading(false);
      }
    };

    searchUsers();
  }, [debouncedQuery]);

  const handleKeyDown = (e) => {
    if (!isOpen) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev => 
          prev < results.length - 1 ? prev + 1 : prev
        );
        break;
      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => (prev > 0 ? prev - 1 : -1));
        break;
      case 'Enter':
        e.preventDefault();
        if (selectedIndex >= 0) {
          selectUser(results[selectedIndex]);
        }
        break;
      case 'Escape':
        setIsOpen(false);
        setSelectedIndex(-1);
        break;
      default:
        break;
    }
  };

  const selectUser = (user) => {
    setQuery(user.login);
    setIsOpen(false);
    setSelectedIndex(-1);
    console.log('Selected user:', user);
  };

  // Click outside to close
  useEffect(() => {
    const handleClickOutside = (e) => {
      if (
        inputRef.current && 
        !inputRef.current.contains(e.target) &&
        resultsRef.current && 
        !resultsRef.current.contains(e.target)
      ) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  return (
    <div className="autocomplete">
      <input
        ref={inputRef}
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        onKeyDown={handleKeyDown}
        placeholder="Search GitHub users..."
      />

      {loading && <div className="loading">Searching...</div>}

      {isOpen && results.length > 0 && (
        <ul ref={resultsRef} className="results">
          {results.map((user, index) => (
            <li
              key={user.id}
              className={index === selectedIndex ? 'selected' : ''}
              onClick={() => selectUser(user)}
              onMouseEnter={() => setSelectedIndex(index)}
            >
              <img src={user.avatar_url} alt={user.login} />
              <span>{user.login}</span>
            </li>
          ))}
        </ul>
      )}

      {isOpen && query.length >= 2 && results.length === 0 && !loading && (
        <div className="no-results">No users found</div>
      )}
    </div>
  );
}

export default Autocomplete;
```

### Pattern 4: Data Fetching with Error Handling

Proper loading states, error handling, and retry logic.

```javascript
import { useState, useEffect } from 'react';

// Custom hook for data fetching
function useFetch(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const fetchData = async () => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch(url, options);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
  }, [url]);

  const refetch = () => {
    fetchData();
  };

  return { data, loading, error, refetch };
}

function DataFetchingComponent() {
  const [userId, setUserId] = useState(1);
  const { data, loading, error, refetch } = useFetch(
    `https://jsonplaceholder.typicode.com/users/${userId}`
  );

  if (loading) {
    return (
      <div className="loading-state">
        <div className="spinner"></div>
        <p>Loading user data...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="error-state">
        <h3>⚠️ Error Loading Data</h3>
        <p>{error}</p>
        <button onClick={refetch}>Try Again</button>
      </div>
    );
  }

  return (
    <div className="data-display">
      <h2>{data.name}</h2>
      <p>Email: {data.email}</p>
      <p>Phone: {data.phone}</p>
      
      <div className="controls">
        <button onClick={() => setUserId(prev => prev - 1)} disabled={userId <= 1}>
          Previous User
        </button>
        <button onClick={() => setUserId(prev => prev + 1)} disabled={userId >= 10}>
          Next User
        </button>
        <button onClick={refetch}>Refresh</button>
      </div>
    </div>
  );
}

export default DataFetchingComponent;
```

#### Advanced: With Caching and Retry Logic

```javascript
function useAdvancedFetch(url) {
  const [state, setState] = useState({
    data: null,
    loading: true,
    error: null,
    retryCount: 0
  });

  const cache = useRef({});

  const fetchData = async (retryCount = 0) => {
    // Check cache first
    if (cache.current[url]) {
      setState({
        data: cache.current[url],
        loading: false,
        error: null,
        retryCount: 0
      });
      return;
    }

    setState(prev => ({ ...prev, loading: true, error: null }));

    try {
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      const data = await response.json();
      
      // Cache the result
      cache.current[url] = data;
      
      setState({
        data,
        loading: false,
        error: null,
        retryCount: 0
      });
    } catch (err) {
      if (retryCount < 3) {
        // Exponential backoff: 1s, 2s, 4s
        const delay = Math.pow(2, retryCount) * 1000;
        
        setTimeout(() => {
          fetchData(retryCount + 1);
        }, delay);
        
        setState(prev => ({
          ...prev,
          loading: true,
          retryCount: retryCount + 1,
          error: `Retrying... (${retryCount + 1}/3)`
        }));
      } else {
        setState({
          data: null,
          loading: false,
          error: err.message,
          retryCount
        });
      }
    }
  };

  useEffect(() => {
    fetchData();
  }, [url]);

  return state;
}
```

---

## 24.2 Hooks Implementation

### Custom Hook: useDebounce

```javascript
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    // Set timeout to update debounced value
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Cleanup function to cancel timeout if value changes
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// Usage
function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  useEffect(() => {
    if (debouncedSearchTerm) {
      // Make API call
      console.log('Searching for:', debouncedSearchTerm);
    }
  }, [debouncedSearchTerm]);

  return (
    <input
      type="text"
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
      placeholder="Search..."
    />
  );
}
```

### Custom Hook: usePrevious

```javascript
function usePrevious(value) {
  const ref = useRef();
  
  useEffect(() => {
    ref.current = value;
  }, [value]);
  
  return ref.current;
}

// Usage
function Counter() {
  const [count, setCount] = useState(0);
  const previousCount = usePrevious(count);

  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {previousCount}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

### Custom Hook: useLocalStorage

```javascript
function useLocalStorage(key, initialValue) {
  // State to store our value
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  // Return a wrapped version of useState's setter function
  const setValue = (value) => {
    try {
      // Allow value to be a function (same API as useState)
      const valueToStore = value instanceof Function 
        ? value(storedValue) 
        : value;
      
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };

  // Listen for changes in other tabs/windows
  useEffect(() => {
    const handleStorageChange = (e) => {
      if (e.key === key && e.newValue) {
        setStoredValue(JSON.parse(e.newValue));
      }
    };

    window.addEventListener('storage', handleStorageChange);
    return () => window.removeEventListener('storage', handleStorageChange);
  }, [key]);

  return [storedValue, setValue];
}

// Usage
function ThemeToggle() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');

  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      Current theme: {theme}
    </button>
  );
}
```

### Custom Hook: useClickOutside

```javascript
function useClickOutside(ref, callback) {
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (ref.current && !ref.current.contains(event.target)) {
        callback();
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [ref, callback]);
}

// Usage
function Dropdown() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef(null);

  useClickOutside(dropdownRef, () => {
    setIsOpen(false);
  });

  return (
    <div ref={dropdownRef}>
      <button onClick={() => setIsOpen(!isOpen)}>
        Toggle Dropdown
      </button>
      {isOpen && (
        <div className="dropdown-menu">
          <div>Option 1</div>
          <div>Option 2</div>
          <div>Option 3</div>
        </div>
      )}
    </div>
  );
}
```

### Custom Hook: useWindowSize

```javascript
function useWindowSize() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });

  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return windowSize;
}

// Usage
function ResponsiveComponent() {
  const { width, height } = useWindowSize();

  return (
    <div>
      <p>Window width: {width}px</p>
      <p>Window height: {height}px</p>
      {width < 768 ? (
        <MobileView />
      ) : (
        <DesktopView />
      )}
    </div>
  );
}
```

---

## 24.3 Component Challenges

### Challenge 1: Modal/Dialog Component

```javascript
import { useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';

function Modal({ isOpen, onClose, title, children }) {
  const modalRef = useRef(null);

  // Handle escape key
  useEffect(() => {
    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleEscape);
      document.body.style.overflow = 'unset';
    };
  }, [isOpen, onClose]);

  // Handle click outside
  const handleBackdropClick = (e) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };

  if (!isOpen) return null;

  return createPortal(
    <div className="modal-backdrop" onClick={handleBackdropClick}>
      <div className="modal" ref={modalRef} role="dialog" aria-modal="true">
        <div className="modal-header">
          <h2>{title}</h2>
          <button 
            onClick={onClose} 
            aria-label="Close modal"
            className="close-button"
          >
            ×
          </button>
        </div>
        <div className="modal-body">
          {children}
        </div>
        <div className="modal-footer">
          <button onClick={onClose}>Close</button>
        </div>
      </div>
    </div>,
    document.body
  );
}

// Usage
function App() {
  const [isModalOpen, setIsModalOpen] = useState(false);

  return (
    <div>
      <button onClick={() => setIsModalOpen(true)}>
        Open Modal
      </button>

      <Modal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        title="Example Modal"
      >
        <p>This is the modal content!</p>
      </Modal>
    </div>
  );
}
```

### Challenge 2: Tabs Component

```javascript
import { useState, Children, cloneElement } from 'react';

// Compound component pattern
function Tabs({ children, defaultTab = 0 }) {
  const [activeTab, setActiveTab] = useState(defaultTab);

  // Find TabList and TabPanels children
  const tabList = Children.toArray(children).find(
    child => child.type === TabList
  );
  const tabPanels = Children.toArray(children).find(
    child => child.type === TabPanels
  );

  // Clone children with additional props
  const enhancedTabList = cloneElement(tabList, {
    activeTab,
    onTabChange: setActiveTab
  });

  const enhancedTabPanels = cloneElement(tabPanels, {
    activeTab
  });

  return (
    <div className="tabs">
      {enhancedTabList}
      {enhancedTabPanels}
    </div>
  );
}

function TabList({ children, activeTab, onTabChange }) {
  return (
    <div className="tab-list" role="tablist">
      {Children.map(children, (child, index) =>
        cloneElement(child, {
          isActive: activeTab === index,
          onClick: () => onTabChange(index),
          id: `tab-${index}`,
          'aria-controls': `panel-${index}`,
          'aria-selected': activeTab === index
        })
      )}
    </div>
  );
}

function Tab({ children, isActive, onClick, ...props }) {
  return (
    <button
      className={`tab ${isActive ? 'active' : ''}`}
      onClick={onClick}
      role="tab"
      {...props}
    >
      {children}
    </button>
  );
}

function TabPanels({ children, activeTab }) {
  return (
    <div className="tab-panels">
      {Children.map(children, (child, index) =>
        cloneElement(child, {
          isActive: activeTab === index,
          id: `panel-${index}`,
          'aria-labelledby': `tab-${index}`
        })
      )}
    </div>
  );
}

function TabPanel({ children, isActive, ...props }) {
  if (!isActive) return null;

  return (
    <div className="tab-panel" role="tabpanel" {...props}>
      {children}
    </div>
  );
}

// Export components
Tabs.TabList = TabList;
Tabs.Tab = Tab;
Tabs.TabPanels = TabPanels;
Tabs.TabPanel = TabPanel;

export default Tabs;

// Usage
function App() {
  return (
    <Tabs defaultTab={0}>
      <Tabs.TabList>
        <Tabs.Tab>Profile</Tabs.Tab>
        <Tabs.Tab>Settings</Tabs.Tab>
        <Tabs.Tab>Messages</Tabs.Tab>
      </Tabs.TabList>

      <Tabs.TabPanels>
        <Tabs.TabPanel>
          <h2>Profile Content</h2>
          <p>User profile information goes here</p>
        </Tabs.TabPanel>
        <Tabs.TabPanel>
          <h2>Settings Content</h2>
          <p>User settings go here</p>
        </Tabs.TabPanel>
        <Tabs.TabPanel>
          <h2>Messages Content</h2>
          <p>User messages go here</p>
        </Tabs.TabPanel>
      </Tabs.TabPanels>
    </Tabs>
  );
}
```

### Challenge 3: Accordion Component

```javascript
import { useState, createContext, useContext } from 'react';

const AccordionContext = createContext();

function Accordion({ children, allowMultiple = false }) {
  const [openItems, setOpenItems] = useState(new Set());

  const toggleItem = (id) => {
    setOpenItems(prev => {
      const newSet = new Set(prev);
      
      if (newSet.has(id)) {
        newSet.delete(id);
      } else {
        if (!allowMultiple) {
          newSet.clear();
        }
        newSet.add(id);
      }
      
      return newSet;
    });
  };

  const isOpen = (id) => openItems.has(id);

  return (
    <AccordionContext.Provider value={{ isOpen, toggleItem }}>
      <div className="accordion">
        {children}
      </div>
    </AccordionContext.Provider>
  );
}

function AccordionItem({ id, children }) {
  const { isOpen, toggleItem } = useContext(AccordionContext);
  const open = isOpen(id);

  return (
    <div className={`accordion-item ${open ? 'open' : ''}`}>
      {children}
    </div>
  );
}

function AccordionHeader({ id, children }) {
  const { isOpen, toggleItem } = useContext(AccordionContext);
  const open = isOpen(id);

  return (
    <button
      className="accordion-header"
      onClick={() => toggleItem(id)}
      aria-expanded={open}
    >
      {children}
      <span className="accordion-icon">{open ? '−' : '+'}</span>
    </button>
  );
}

function AccordionPanel({ id, children }) {
  const { isOpen } = useContext(AccordionContext);
  const open = isOpen(id);

  return (
    <div 
      className={`accordion-panel ${open ? 'open' : ''}`}
      style={{
        maxHeight: open ? '1000px' : '0',
        overflow: 'hidden',
        transition: 'max-height 0.3s ease'
      }}
    >
      <div className="accordion-content">
        {children}
      </div>
    </div>
  );
}

// Export
Accordion.Item = AccordionItem;
Accordion.Header = AccordionHeader;
Accordion.Panel = AccordionPanel;

export default Accordion;

// Usage
function FAQ() {
  return (
    <Accordion allowMultiple={false}>
      <Accordion.Item id="item-1">
        <Accordion.Header id="item-1">
          What is React?
        </Accordion.Header>
        <Accordion.Panel id="item-1">
          React is a JavaScript library for building user interfaces.
        </Accordion.Panel>
      </Accordion.Item>

      <Accordion.Item id="item-2">
        <Accordion.Header id="item-2">
          What are Hooks?
        </Accordion.Header>
        <Accordion.Panel id="item-2">
          Hooks are functions that let you use state and other React features
          without writing a class.
        </Accordion.Panel>
      </Accordion.Item>

      <Accordion.Item id="item-3">
        <Accordion.Header id="item-3">
          What is JSX?
        </Accordion.Header>
        <Accordion.Panel id="item-3">
          JSX is a syntax extension for JavaScript that looks similar to HTML.
        </Accordion.Panel>
      </Accordion.Item>
    </Accordion>
  );
}
```

### Challenge 4: Carousel/Slider Component

```javascript
import { useState, useEffect, useRef } from 'react';

function Carousel({ images, autoPlay = true, interval = 3000 }) {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isPlaying, setIsPlaying] = useState(autoPlay);
  const timerRef = useRef(null);

  const goToNext = () => {
    setCurrentIndex((prevIndex) =>
      prevIndex === images.length - 1 ? 0 : prevIndex + 1
    );
  };

  const goToPrevious = () => {
    setCurrentIndex((prevIndex) =>
      prevIndex === 0 ? images.length - 1 : prevIndex - 1
    );
  };

  const goToSlide = (index) => {
    setCurrentIndex(index);
  };

  // Auto play
  useEffect(() => {
    if (isPlaying) {
      timerRef.current = setInterval(goToNext, interval);
    }

    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, [isPlaying, currentIndex, interval]);

  // Keyboard navigation
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === 'ArrowLeft') goToPrevious();
      if (e.key === 'ArrowRight') goToNext();
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  // Touch/swipe support
  const [touchStart, setTouchStart] = useState(0);
  const [touchEnd, setTouchEnd] = useState(0);

  const handleTouchStart = (e) => {
    setTouchStart(e.targetTouches[0].clientX);
  };

  const handleTouchMove = (e) => {
    setTouchEnd(e.targetTouches[0].clientX);
  };

  const handleTouchEnd = () => {
    if (touchStart - touchEnd > 50) {
      goToNext();
    }

    if (touchStart - touchEnd < -50) {
      goToPrevious();
    }
  };

  return (
    <div className="carousel">
      <div 
        className="carousel-inner"
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleTouchEnd}
      >
        <div
          className="carousel-slides"
          style={{
            transform: `translateX(-${currentIndex * 100}%)`,
            transition: 'transform 0.5s ease-in-out'
          }}
        >
          {images.map((image, index) => (
            <div key={index} className="carousel-slide">
              <img src={image.src} alt={image.alt} />
            </div>
          ))}
        </div>

        {/* Navigation Buttons */}
        <button 
          className="carousel-button prev"
          onClick={goToPrevious}
          aria-label="Previous slide"
        >
          ‹
        </button>
        <button 
          className="carousel-button next"
          onClick={goToNext}
          aria-label="Next slide"
        >
          ›
        </button>
      </div>

      {/* Indicators */}
      <div className="carousel-indicators">
        {images.map((_, index) => (
          <button
            key={index}
            className={`indicator ${index === currentIndex ? 'active' : ''}`}
            onClick={() => goToSlide(index)}
            aria-label={`Go to slide ${index + 1}`}
          />
        ))}
      </div>

      {/* Play/Pause Control */}
      <button
        className="carousel-control"
        onClick={() => setIsPlaying(!isPlaying)}
        aria-label={isPlaying ? 'Pause' : 'Play'}
      >
        {isPlaying ? '⏸' : '▶'}
      </button>
    </div>
  );
}

export default Carousel;
```

---

## Interview Tips for Coding Challenges

### 1. **Clarify Requirements**
Before coding, ask:
- What are the edge cases?
- Should it work on mobile?
- Do we need accessibility?
- What browsers to support?
- Performance requirements?

### 2. **Think Out Loud**
- Explain your approach
- Discuss trade-offs
- Mention alternatives

### 3. **Write Clean Code**
- Use meaningful names
- Keep functions small
- Add comments for complex logic
- Handle errors gracefully

### 4. **Test Your Code**
- Test happy path
- Test edge cases
- Test error scenarios
- Manual testing walkthrough

### 5. **Optimize If Needed**
- Don't prematurely optimize
- Profile first
- Discuss Big O complexity
- Consider memoization

### 6. **Common Mistakes to Avoid**
- ❌ Not handling loading states
- ❌ Forgetting error handling
- ❌ Missing cleanup in useEffect
- ❌ Not using keys in lists
- ❌ Ignoring accessibility
- ❌ Over-complicating solutions

This completes Chapter 24 on Coding Challenges!