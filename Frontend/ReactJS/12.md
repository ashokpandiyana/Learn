# Chapter 12: Forms and Validation - In-Depth Explanation

## Why Forms are Complex in React

Forms in React require careful state management because:
1. **Multiple inputs** need synchronized state
2. **Validation** must happen at the right time
3. **Error handling** needs clear UX
4. **Performance** matters with many fields
5. **Accessibility** is crucial for forms

**Form State to Manage:**
- Field values
- Validation errors
- Touched/dirty state
- Submission state
- Focus state

---

## 12.1 Form Libraries

### Why Use Form Libraries?

**Without a library (manual approach):**
```javascript
function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [emailError, setEmailError] = useState('');
  const [passwordError, setPasswordError] = useState('');
  const [emailTouched, setEmailTouched] = useState(false);
  const [passwordTouched, setPasswordTouched] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  // Lots of boilerplate code...
}
// ðŸ˜“ Repetitive for every form!
```

**With a library:**
```javascript
function LoginForm() {
  const { register, handleSubmit, formState: { errors } } = useForm();
  
  const onSubmit = (data) => console.log(data);
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('email', { required: true })} />
      <button type="submit">Submit</button>
    </form>
  );
}
// ðŸŽ‰ Much simpler!
```

---

## 12.2 React Hook Form (Recommended)

### Why React Hook Form?

**Advantages:**
- âœ… Best performance (minimal re-renders)
- âœ… Smaller bundle size (~9KB)
- âœ… Built-in validation
- âœ… TypeScript support
- âœ… Easy integration with UI libraries
- âœ… Uncontrolled inputs (better performance)

**Installation:**
```bash
npm install react-hook-form
```

### Basic Example

```javascript
import { useForm } from 'react-hook-form';

function RegistrationForm() {
  const { 
    register,           // Register inputs
    handleSubmit,       // Handle form submission
    formState: { errors, isSubmitting }  // Form state
  } = useForm();
  
  const onSubmit = async (data) => {
    console.log(data);
    // { email: "user@example.com", password: "123456" }
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Email field */}
      <div>
        <label>Email</label>
        <input 
          {...register('email', {
            required: 'Email is required',
            pattern: {
              value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
              message: 'Invalid email address'
            }
          })}
        />
        {errors.email && <span>{errors.email.message}</span>}
      </div>
      
      {/* Password field */}
      <div>
        <label>Password</label>
        <input 
          type="password"
          {...register('password', {
            required: 'Password is required',
            minLength: {
              value: 8,
              message: 'Password must be at least 8 characters'
            }
          })}
        />
        {errors.password && <span>{errors.password.message}</span>}
      </div>
      
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Submitting...' : 'Submit'}
      </button>
    </form>
  );
}
```

### Register Options (Validation Rules)

```javascript
// All register options
<input {...register('fieldName', {
  required: 'This field is required',
  
  minLength: {
    value: 5,
    message: 'Minimum length is 5'
  },
  
  maxLength: {
    value: 20,
    message: 'Maximum length is 20'
  },
  
  min: {
    value: 18,
    message: 'Must be at least 18'
  },
  
  max: {
    value: 99,
    message: 'Must be less than 100'
  },
  
  pattern: {
    value: /^[A-Za-z]+$/,
    message: 'Only letters allowed'
  },
  
  validate: {
    // Custom validation
    positive: (value) => parseInt(value) > 0 || 'Must be positive',
    lessThan100: (value) => parseInt(value) < 100 || 'Must be less than 100'
  },
  
  // Or single custom validation
  validate: (value) => value !== 'admin' || 'Username cannot be admin',
  
  // Async validation
  validate: async (value) => {
    const response = await fetch(`/api/check-username/${value}`);
    const available = await response.json();
    return available || 'Username taken';
  }
})} />
```

### Watch Field Values

```javascript
function DependentFields() {
  const { register, watch } = useForm();
  
  // Watch specific field
  const password = watch('password');
  const watchAll = watch(); // Watch all fields
  
  return (
    <form>
      <input {...register('password')} type="password" />
      
      <input 
        {...register('confirmPassword', {
          validate: (value) => value === password || 'Passwords do not match'
        })}
        type="password"
      />
      
      {/* Show password strength */}
      {password && (
        <div>
          Password strength: {password.length > 10 ? 'Strong' : 'Weak'}
        </div>
      )}
    </form>
  );
}
```

### setValue and Reset

```javascript
function Form() {
  const { register, setValue, reset } = useForm({
    defaultValues: {
      username: '',
      email: ''
    }
  });
  
  const fillDemoData = () => {
    setValue('username', 'johndoe');
    setValue('email', 'john@example.com');
  };
  
  const clearForm = () => {
    reset();
  };
  
  return (
    <form>
      <input {...register('username')} />
      <input {...register('email')} />
      
      <button type="button" onClick={fillDemoData}>
        Fill Demo Data
      </button>
      <button type="button" onClick={clearForm}>
        Clear
      </button>
    </form>
  );
}
```

### Form State

```javascript
function Form() {
  const { 
    register, 
    handleSubmit, 
    formState: { 
      errors,          // Validation errors
      isSubmitting,    // Currently submitting
      isSubmitted,     // Has been submitted
      isDirty,         // Any field has been modified
      isValid,         // All validations pass
      touchedFields,   // Which fields have been touched
      dirtyFields      // Which fields have been modified
    } 
  } = useForm({ mode: 'onChange' });  // Validate on change
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('email', { required: true })} />
      {errors.email && <span>Error</span>}
      
      <button type="submit" disabled={!isValid || isSubmitting}>
        {isSubmitting ? 'Submitting...' : 'Submit'}
      </button>
      
      {isDirty && <p>You have unsaved changes</p>}
    </form>
  );
}
```

### Different Input Types

```javascript
function AllInputTypes() {
  const { register, handleSubmit } = useForm();
  
  const onSubmit = (data) => console.log(data);
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Text input */}
      <input {...register('username')} />
      
      {/* Email */}
      <input type="email" {...register('email')} />
      
      {/* Number */}
      <input 
        type="number" 
        {...register('age', { valueAsNumber: true })}
      />
      
      {/* Checkbox */}
      <input 
        type="checkbox" 
        {...register('subscribe')}
      />
      
      {/* Radio buttons */}
      <input type="radio" {...register('gender')} value="male" />
      <input type="radio" {...register('gender')} value="female" />
      
      {/* Select */}
      <select {...register('country')}>
        <option value="us">USA</option>
        <option value="uk">UK</option>
      </select>
      
      {/* Textarea */}
      <textarea {...register('message')} />
      
      {/* File */}
      <input 
        type="file" 
        {...register('avatar')}
        accept="image/*"
      />
      
      <button type="submit">Submit</button>
    </form>
  );
}
```

### Controller (for third-party components)

```javascript
import { useForm, Controller } from 'react-hook-form';

function FormWithDatePicker() {
  const { control, handleSubmit } = useForm();
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* For custom components that don't expose ref */}
      <Controller
        name="birthdate"
        control={control}
        rules={{ required: 'Birthdate is required' }}
        render={({ field, fieldState: { error } }) => (
          <div>
            <DatePicker
              selected={field.value}
              onChange={field.onChange}
            />
            {error && <span>{error.message}</span>}
          </div>
        )}
      />
      
      <button type="submit">Submit</button>
    </form>
  );
}
```

---

## 12.3 Formik

### Basic Setup

```javascript
import { Formik, Form, Field, ErrorMessage } from 'formik';

function LoginForm() {
  return (
    <Formik
      initialValues={{ email: '', password: '' }}
      onSubmit={(values, { setSubmitting }) => {
        setTimeout(() => {
          console.log(values);
          setSubmitting(false);
        }, 400);
      }}
      validate={(values) => {
        const errors = {};
        
        if (!values.email) {
          errors.email = 'Required';
        } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(values.email)) {
          errors.email = 'Invalid email';
        }
        
        if (!values.password) {
          errors.password = 'Required';
        } else if (values.password.length < 6) {
          errors.password = 'Must be at least 6 characters';
        }
        
        return errors;
      }}
    >
      {({ isSubmitting }) => (
        <Form>
          <div>
            <label htmlFor="email">Email</label>
            <Field type="email" name="email" />
            <ErrorMessage name="email" component="div" />
          </div>
          
          <div>
            <label htmlFor="password">Password</label>
            <Field type="password" name="password" />
            <ErrorMessage name="password" component="div" />
          </div>
          
          <button type="submit" disabled={isSubmitting}>
            Submit
          </button>
        </Form>
      )}
    </Formik>
  );
}
```

### Formik with Render Props

```javascript
function Form() {
  return (
    <Formik
      initialValues={{ email: '', password: '' }}
      onSubmit={handleSubmit}
    >
      {({ values, errors, touched, handleChange, handleBlur, handleSubmit, isSubmitting }) => (
        <form onSubmit={handleSubmit}>
          <input
            type="email"
            name="email"
            value={values.email}
            onChange={handleChange}
            onBlur={handleBlur}
          />
          {errors.email && touched.email && <span>{errors.email}</span>}
          
          <input
            type="password"
            name="password"
            value={values.password}
            onChange={handleChange}
            onBlur={handleBlur}
          />
          {errors.password && touched.password && <span>{errors.password}</span>}
          
          <button type="submit" disabled={isSubmitting}>
            Submit
          </button>
        </form>
      )}
    </Formik>
  );
}
```

---

## 12.4 Validation Libraries

### Yup (Object Schema Validation)

**Installation:**
```bash
npm install yup
```

**Basic Schema:**
```javascript
import * as Yup from 'yup';

const validationSchema = Yup.object({
  email: Yup.string()
    .email('Invalid email address')
    .required('Email is required'),
  
  password: Yup.string()
    .min(8, 'Must be at least 8 characters')
    .matches(/[a-z]/, 'Must contain lowercase letter')
    .matches(/[A-Z]/, 'Must contain uppercase letter')
    .matches(/[0-9]/, 'Must contain number')
    .required('Password is required'),
  
  age: Yup.number()
    .min(18, 'Must be at least 18')
    .max(120, 'Invalid age')
    .required('Age is required'),
  
  website: Yup.string()
    .url('Must be a valid URL'),
  
  terms: Yup.boolean()
    .oneOf([true], 'You must accept terms and conditions')
});
```

**With Formik:**
```javascript
import { Formik, Form, Field } from 'formik';
import * as Yup from 'yup';

const schema = Yup.object({
  firstName: Yup.string().required('Required'),
  lastName: Yup.string().required('Required'),
  email: Yup.string().email('Invalid email').required('Required')
});

function SignupForm() {
  return (
    <Formik
      initialValues={{ firstName: '', lastName: '', email: '' }}
      validationSchema={schema}
      onSubmit={(values) => console.log(values)}
    >
      {({ errors, touched }) => (
        <Form>
          <Field name="firstName" />
          {errors.firstName && touched.firstName && (
            <div>{errors.firstName}</div>
          )}
          
          <Field name="lastName" />
          {errors.lastName && touched.lastName && (
            <div>{errors.lastName}</div>
          )}
          
          <Field name="email" type="email" />
          {errors.email && touched.email && (
            <div>{errors.email}</div>
          )}
          
          <button type="submit">Submit</button>
        </Form>
      )}
    </Formik>
  );
}
```

**Advanced Yup Schemas:**
```javascript
const userSchema = Yup.object({
  // Conditional validation
  country: Yup.string().required(),
  zipCode: Yup.string().when('country', {
    is: 'US',
    then: (schema) => schema.matches(/^\d{5}$/, 'Invalid ZIP code').required(),
    otherwise: (schema) => schema
  }),
  
  // Nested objects
  address: Yup.object({
    street: Yup.string().required(),
    city: Yup.string().required(),
    zipCode: Yup.string().required()
  }),
  
  // Arrays
  tags: Yup.array()
    .of(Yup.string())
    .min(1, 'At least one tag required')
    .max(5, 'Maximum 5 tags'),
  
  // Array of objects
  phoneNumbers: Yup.array().of(
    Yup.object({
      type: Yup.string().oneOf(['home', 'work', 'mobile']),
      number: Yup.string().matches(/^\d{10}$/, 'Invalid phone number')
    })
  ),
  
  // Custom validation
  username: Yup.string()
    .test('unique', 'Username already taken', async (value) => {
      if (!value) return true;
      const response = await fetch(`/api/check-username/${value}`);
      return response.ok;
    }),
  
  // Transform data
  email: Yup.string()
    .email()
    .lowercase()
    .trim()
    .required()
});
```

### Zod (TypeScript-First Validation)

**Installation:**
```bash
npm install zod
npm install @hookform/resolvers
```

**Why Zod?**
- TypeScript-first design
- Type inference from schemas
- Better error messages
- Smaller bundle size
- More modern API

**Basic Example:**
```typescript
import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

// Define schema
const schema = z.object({
  email: z.string().email('Invalid email'),
  password: z.string()
    .min(8, 'Must be at least 8 characters')
    .regex(/[A-Z]/, 'Must contain uppercase letter')
    .regex(/[0-9]/, 'Must contain number'),
  age: z.number().min(18, 'Must be 18 or older'),
  terms: z.boolean().refine((val) => val === true, {
    message: 'You must accept terms'
  })
});

// Infer TypeScript type from schema
type FormData = z.infer<typeof schema>;

function RegisterForm() {
  const { register, handleSubmit, formState: { errors } } = useForm<FormData>({
    resolver: zodResolver(schema)
  });
  
  const onSubmit = (data: FormData) => {
    console.log(data);
    // TypeScript knows exact type!
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('email')} />
      {errors.email && <span>{errors.email.message}</span>}
      
      <input type="password" {...register('password')} />
      {errors.password && <span>{errors.password.message}</span>}
      
      <input type="number" {...register('age', { valueAsNumber: true })} />
      {errors.age && <span>{errors.age.message}</span>}
      
      <input type="checkbox" {...register('terms')} />
      {errors.terms && <span>{errors.terms.message}</span>}
      
      <button type="submit">Register</button>
    </form>
  );
}
```

**Advanced Zod Schemas:**
```typescript
// Nested objects
const addressSchema = z.object({
  street: z.string(),
  city: z.string(),
  zipCode: z.string().regex(/^\d{5}$/, 'Invalid ZIP')
});

const userSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  address: addressSchema
});

// Arrays
const tagsSchema = z.array(z.string()).min(1).max(5);

// Enums
const roleSchema = z.enum(['admin', 'user', 'guest']);

// Union types
const idSchema = z.union([z.string(), z.number()]);

// Conditional validation
const formSchema = z.object({
  accountType: z.enum(['personal', 'business']),
  companyName: z.string().optional()
}).refine((data) => {
  if (data.accountType === 'business' && !data.companyName) {
    return false;
  }
  return true;
}, {
  message: 'Company name required for business accounts',
  path: ['companyName']
});

// Transform data
const userSchema = z.object({
  email: z.string().email().transform((val) => val.toLowerCase()),
  age: z.string().transform((val) => parseInt(val))
});
```

---

## 12.5 Complex Forms

### Multi-Step Forms

```javascript
function MultiStepForm() {
  const [step, setStep] = useState(1);
  const [formData, setFormData] = useState({
    // Step 1
    firstName: '',
    lastName: '',
    // Step 2
    email: '',
    phone: '',
    // Step 3
    address: '',
    city: ''
  });
  
  const updateFormData = (data) => {
    setFormData({ ...formData, ...data });
  };
  
  const nextStep = () => setStep(step + 1);
  const prevStep = () => setStep(step - 1);
  
  const handleFinalSubmit = () => {
    console.log('Final data:', formData);
    // Submit to API
  };
  
  return (
    <div>
      {/* Progress indicator */}
      <div className="progress">
        Step {step} of 3
      </div>
      
      {step === 1 && (
        <Step1Form 
          data={formData}
          onNext={(data) => {
            updateFormData(data);
            nextStep();
          }}
        />
      )}
      
      {step === 2 && (
        <Step2Form 
          data={formData}
          onNext={(data) => {
            updateFormData(data);
            nextStep();
          }}
          onBack={prevStep}
        />
      )}
      
      {step === 3 && (
        <Step3Form 
          data={formData}
          onSubmit={(data) => {
            updateFormData(data);
            handleFinalSubmit();
          }}
          onBack={prevStep}
        />
      )}
    </div>
  );
}

function Step1Form({ data, onNext }) {
  const { register, handleSubmit, formState: { errors } } = useForm({
    defaultValues: data
  });
  
  return (
    <form onSubmit={handleSubmit(onNext)}>
      <h2>Personal Information</h2>
      
      <input 
        {...register('firstName', { required: 'First name is required' })}
        placeholder="First Name"
      />
      {errors.firstName && <span>{errors.firstName.message}</span>}
      
      <input 
        {...register('lastName', { required: 'Last name is required' })}
        placeholder="Last Name"
      />
      {errors.lastName && <span>{errors.lastName.message}</span>}
      
      <button type="submit">Next</button>
    </form>
  );
}
```

### Dynamic Fields (Field Arrays)

```javascript
import { useForm, useFieldArray } from 'react-hook-form';

function DynamicForm() {
  const { register, control, handleSubmit } = useForm({
    defaultValues: {
      users: [{ name: '', email: '' }]
    }
  });
  
  const { fields, append, remove } = useFieldArray({
    control,
    name: 'users'
  });
  
  const onSubmit = (data) => {
    console.log(data);
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {fields.map((field, index) => (
        <div key={field.id}>
          <input
            {...register(`users.${index}.name`, { required: true })}
            placeholder="Name"
          />
          
          <input
            {...register(`users.${index}.email`, { required: true })}
            placeholder="Email"
          />
          
          <button type="button" onClick={() => remove(index)}>
            Remove
          </button>
        </div>
      ))}
      
      <button 
        type="button" 
        onClick={() => append({ name: '', email: '' })}
      >
        Add User
      </button>
      
      <button type="submit">Submit</button>
    </form>
  );
}
```

### Nested Forms

```javascript
function NestedForm() {
  const { register, handleSubmit, formState: { errors } } = useForm();
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* User info */}
      <input {...register('user.name')} />
      <input {...register('user.email')} />
      
      {/* Address */}
      <input {...register('user.address.street')} />
      <input {...register('user.address.city')} />
      <input {...register('user.address.zipCode')} />
      
      {/* Phone numbers array */}
      <input {...register('user.phoneNumbers.0.number')} />
      <input {...register('user.phoneNumbers.1.number')} />
      
      <button type="submit">Submit</button>
    </form>
  );
}

// Data structure:
{
  user: {
    name: "John",
    email: "john@example.com",
    address: {
      street: "123 Main St",
      city: "New York",
      zipCode: "10001"
    },
    phoneNumbers: [
      { number: "555-1234" },
      { number: "555-5678" }
    ]
  }
}
```

---

## 12.6 Form UX Best Practices

### Show Errors at Right Time

```javascript
// Bad UX: Show errors immediately
<input 
  {...register('email')}
  // User sees error while typing first character!
/>

// Good UX: Show errors after blur
const { register, formState: { errors, touchedFields } } = useForm({
  mode: 'onBlur'  // Validate on blur
});

<input {...register('email')} />
{touchedFields.email && errors.email && (
  <span>{errors.email.message}</span>
)}
```

### Loading States

```javascript
function Form() {
  const { register, handleSubmit, formState: { isSubmitting } } = useForm();
  
  const onSubmit = async (data) => {
    await fetch('/api/submit', {
      method: 'POST',
      body: JSON.stringify(data)
    });
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('email')} disabled={isSubmitting} />
      
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? (
          <>
            <Spinner />
            Submitting...
          </>
        ) : (
          'Submit'
        )}
      </button>
    </form>
  );
}
```

### Success/Error Messages

```javascript
function Form() {
  const [submitStatus, setSubmitStatus] = useState(null);
  const { register, handleSubmit, reset } = useForm();
  
  const onSubmit = async (data) => {
    try {
      await fetch('/api/submit', {
        method: 'POST',
        body: JSON.stringify(data)
      });
      
      setSubmitStatus({ type: 'success', message: 'Form submitted successfully!' });
      reset();
    } catch (error) {
      setSubmitStatus({ type: 'error', message: 'Failed to submit form' });
    }
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {submitStatus && (
        <div className={submitStatus.type === 'success' ? 'success' : 'error'}>
          {submitStatus.message}
        </div>
      )}
      
      <input {...register('email')} />
      <button type="submit">Submit</button>
    </form>
  );
}
```

### Unsaved Changes Warning

```javascript
function FormWithUnsavedWarning() {
  const { register, formState: { isDirty } } = useForm();
  
  useEffect(() => {
    const handleBeforeUnload = (e) => {
      if (isDirty) {
        e.preventDefault();
        e.returnValue = '';
      }
    };
    
    window.addEventListener('beforeunload', handleBeforeUnload);
    
    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, [isDirty]);
  
  return (
    <form>
      <input {...register('email')} />
      {isDirty && <p className="warning">You have unsaved changes</p>}
      <button type="submit">Submit</button>
    </form>
  );
}
```

---

## 12.7 Form Patterns

### Wizard/Multi-Step Form with Validation

```javascript
function WizardForm() {
  const [step, setStep] = useState(0);
  const [formData, setFormData] = useState({});
  
  const steps = [
    {
      title: 'Personal Info',
      fields: ['firstName', 'lastName', 'email'],
      schema: z.object({
        firstName: z.string().min(2),
        lastName: z.string().min(2),
        email: z.string().email()
      })
    },
    {
      title: 'Account Details',
      fields: ['username', 'password'],
      schema: z.object({
        username: z.string().min(4),
        password: z.string().min(8)
      })
    },
    {
      title: 'Preferences',
      fields: ['newsletter', 'notifications'],
      schema: z.object({
        newsletter: z.boolean(),
        notifications: z.boolean()
      })
    }
  ];
  
  const currentStep = steps[step];
  
  const { register, handleSubmit, formState: { errors } } = useForm({
    resolver: zodResolver(currentStep.schema),
    defaultValues: formData
  });
  
  const onNext = (data) => {
    setFormData({ ...formData, ...data });
    if (step < steps.length - 1) {
      setStep(step + 1);
    } else {
      // Final submission
      console.log('Complete data:', { ...formData, ...data });
    }
  };
  
  return (
    <div>
      {/* Progress bar */}
      <div className="progress-bar">
        {steps.map((s, i) => (
          <div 
            key={i} 
            className={i <= step ? 'active' : 'inactive'}
          >
            {s.title}
          </div>
        ))}
      </div>
      
      <form onSubmit={handleSubmit(onNext)}>
        <h2>{currentStep.title}</h2>
        
        {currentStep.fields.map(field => (
          <div key={field}>
            <input {...register(field)} placeholder={field} />
            {errors[field] && <span>{errors[field].message}</span>}
          </div>
        ))}
        
        <div>
          {step > 0 && (
            <button type="button" onClick={() => setStep(step - 1)}>
              Back
            </button>
          )}
          
          <button type="submit">
            {step === steps.length - 1 ? 'Submit' : 'Next'}
          </button>
        </div>
      </form>
    </div>
  );
}
```

### Conditional Fields

```javascript
function ConditionalForm() {
  const { register, watch, formState: { errors } } = useForm();
  
  // Watch specific field
  const accountType = watch('accountType');
  const hasCompany = watch('hasCompany');
  
  return (
    <form>
      {/* Always visible */}
      <select {...register('accountType')}>
        <option value="personal">Personal</option>
        <option value="business">Business</option>
      </select>
      
      {/* Conditional: Only for business accounts */}
      {accountType === 'business' && (
        <div>
          <input 
            {...register('companyName', { 
              required: 'Company name is required for business accounts' 
            })}
            placeholder="Company Name"
          />
          {errors.companyName && <span>{errors.companyName.message}</span>}
          
          <input 
            {...register('taxId')}
            placeholder="Tax ID"
          />
        </div>
      )}
      
      {/* Checkbox-dependent fields */}
      <label>
        <input type="checkbox" {...register('hasCompany')} />
        I have a company
      </label>
      
      {hasCompany && (
        <input 
          {...register('companyWebsite')}
          placeholder="Company Website"
        />
      )}
      
      <button type="submit">Submit</button>
    </form>
  );
}
```

---

## Summary of Chapter 12

**Key Takeaways:**

1. **React Hook Form** - Modern standard, best performance
2. **Formik** - Popular alternative, more features
3. **Yup** - Schema validation for JavaScript
4. **Zod** - TypeScript-first validation
5. **Validation timing** - onBlur for best UX
6. **Multi-step forms** - Manage state across steps
7. **Dynamic fields** - useFieldArray for arrays
8. **Form state** - Errors, touched, dirty, submitting

**React Hook Form vs Formik:**

| Feature | React Hook Form | Formik |
|---------|----------------|--------|
| Bundle Size | ~9KB | ~15KB |
| Re-renders | Minimal | More frequent |
| Performance | Excellent | Good |
| API | Uncontrolled | Controlled |
| Learning Curve | Easy | Easy |
| TypeScript | Excellent | Good |
| Popularity | Growing | Established |

**Validation Library Choice:**

| Use Case | Library |
|----------|---------|
| JavaScript projects | Yup |
| TypeScript projects | Zod |
| Simple validation | Built-in HTML5 |
| Complex schemas | Zod or Yup |

**Best Practices:**

```javascript
// âœ… Use React Hook Form for new projects
// âœ… Validate on blur (not onChange)
// âœ… Show clear error messages
// âœ… Disable submit while submitting
// âœ… Reset form after successful submit
// âœ… Use TypeScript with Zod
// âœ… Handle loading and error states
// âœ… Provide feedback on success
```

**Common Form Patterns:**

1. **Login Form** - Email + password with validation
2. **Registration** - Multiple fields, password confirmation
3. **Profile Edit** - Pre-filled values, partial updates
4. **Search Form** - Debounced submission
5. **Multi-step** - Wizard with progress indicator
6. **Dynamic Fields** - Add/remove items
7. **Nested Forms** - Address, contacts, etc.

**Interview Focus:**
- Explain controlled vs uncontrolled
- Show validation strategies
- Demonstrate form library usage
- Handle complex form scenarios
- Discuss performance considerations