# Chapter 5: Hooks Deep Dive - In-Depth Explanation

## What are Hooks?

Hooks are **functions that let you "hook into" React features** from functional components. Introduced in React 16.8, they allow you to use state and lifecycle methods without writing class components.

**Why Hooks?**
- ‚úÖ Simpler code (no `this` binding)
- ‚úÖ Reusable stateful logic (custom hooks)
- ‚úÖ Better code organization
- ‚úÖ Easier to test
- ‚úÖ Smaller bundle size

**Rules of Hooks:**
```javascript
// 1. Only call hooks at the TOP LEVEL (not in loops, conditions, or nested functions)
// ‚ùå Wrong
if (condition) {
  useState(0);  // Don't do this!
}

// ‚úÖ Correct
const [state, setState] = useState(0);
if (condition) {
  setState(1);  // This is fine
}

// 2. Only call hooks from REACT FUNCTIONS (components or custom hooks)
// ‚ùå Wrong
function regularFunction() {
  useState(0);  // Don't do this!
}

// ‚úÖ Correct
function MyComponent() {
  useState(0);  // Component
}

function useCustomHook() {
  useState(0);  // Custom hook
}
```

---

## 5.1 useState

### Basic Usage

The `useState` hook adds state to functional components.

**Syntax:**
```javascript
const [state, setState] = useState(initialValue);
```

**Example:**
```javascript
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

### Multiple State Variables

You can use `useState` multiple times:

```javascript
function UserForm() {
  const [name, setName] = useState('');
  const [age, setAge] = useState(0);
  const [email, setEmail] = useState('');
  const [isSubscribed, setIsSubscribed] = useState(false);
  
  return (
    <div>
      <input value={name} onChange={e => setName(e.target.value)} />
      <input type="number" value={age} onChange={e => setAge(Number(e.target.value))} />
      <input value={email} onChange={e => setEmail(e.target.value)} />
      <input type="checkbox" checked={isSubscribed} onChange={e => setIsSubscribed(e.target.checked)} />
    </div>
  );
}
```

**When to split vs combine state:**

```javascript
// ‚úÖ Good: Related data together
const [user, setUser] = useState({
  name: '',
  email: '',
  age: 0
});

// Update specific field
setUser(prev => ({ ...prev, name: 'John' }));

// ‚úÖ Good: Independent data separate
const [theme, setTheme] = useState('light');
const [language, setLanguage] = useState('en');
const [notifications, setNotifications] = useState([]);

// ‚ùå Bad: Unrelated data together
const [state, setState] = useState({
  theme: 'light',
  currentUser: null,
  shoppingCart: [],
  isModalOpen: false
});
```

### Lazy Initialization

When initial state requires expensive computation:

```javascript
// ‚ùå Expensive computation runs every render
function Component() {
  const [data, setData] = useState(expensiveComputation());
  // expensiveComputation() is called EVERY RENDER
}

// ‚úÖ Computation runs only once
function Component() {
  const [data, setData] = useState(() => expensiveComputation());
  // expensiveComputation() runs ONLY ON FIRST RENDER
}

// Example
function TodoList() {
  const [todos, setTodos] = useState(() => {
    console.log('Loading todos from localStorage...');
    const saved = localStorage.getItem('todos');
    return saved ? JSON.parse(saved) : [];
  });
  
  return <div>{todos.length} todos</div>;
}
```

### Functional Updates

Use functional updates when **new state depends on previous state**:

```javascript
function Counter() {
  const [count, setCount] = useState(0);
  
  // ‚ùå Problem with multiple updates
  const incrementThree = () => {
    setCount(count + 1);  // count = 1
    setCount(count + 1);  // count = 1 (still uses old value!)
    setCount(count + 1);  // count = 1 (still uses old value!)
    // Result: count = 1 (not 3!)
  };
  
  // ‚úÖ Solution: Functional updates
  const incrementThreeCorrect = () => {
    setCount(c => c + 1);  // c = 0, returns 1
    setCount(c => c + 1);  // c = 1, returns 2
    setCount(c => c + 1);  // c = 2, returns 3
    // Result: count = 3 ‚úì
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={incrementThree}>Increment 3 (wrong)</button>
      <button onClick={incrementThreeCorrect}>Increment 3 (correct)</button>
    </div>
  );
}
```

**More Examples:**

```javascript
// Toggle boolean
setIsOpen(prev => !prev);

// Add to array
setItems(prev => [...prev, newItem]);

// Remove from array
setItems(prev => prev.filter(item => item.id !== id));

// Update object property
setUser(prev => ({ ...prev, age: prev.age + 1 }));

// Complex update
setTodos(prev => 
  prev.map(todo => 
    todo.id === id 
      ? { ...todo, completed: !todo.completed }
      : todo
  )
);
```

### Batching (React 18+)

React 18 automatically batches all state updates:

```javascript
function Component() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);
  
  function handleClick() {
    setCount(c => c + 1);
    setFlag(f => !f);
    // Both updates are batched ‚Üí Only ONE render
  }
  
  // React 17 and earlier: 2 renders
  // React 18: 1 render (automatic batching)
  
  return <div>Count: {count}, Flag: {flag}</div>;
}
```

---

## 5.2 useEffect

Covered extensively in Chapter 4, but here are advanced patterns:

### Effect Execution Order

```javascript
function Component() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    console.log('1. Effect with no deps (runs after EVERY render)');
  });
  
  useEffect(() => {
    console.log('2. Effect with [] (runs once on mount)');
    return () => console.log('2b. Cleanup on unmount');
  }, []);
  
  useEffect(() => {
    console.log('3. Effect with [count] (runs when count changes)');
    return () => console.log('3b. Cleanup before next effect');
  }, [count]);
  
  console.log('4. Render');
  
  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;
}

// Execution order on mount:
// 4. Render
// 2. Effect with []
// 1. Effect with no deps
// 3. Effect with [count]

// On update (count changes):
// 4. Render
// 3b. Cleanup before next effect
// 1. Effect with no deps
// 3. Effect with [count]

// On unmount:
// 2b. Cleanup on unmount
// 3b. Cleanup before next effect
```

### Effect Dependencies Deep Dive

**Primitive vs Reference Types:**

```javascript
function Component({ userId, config }) {
  // ‚úÖ Primitive - works correctly
  useEffect(() => {
    fetchUser(userId);
  }, [userId]);  // Re-runs when userId changes
  
  // ‚ùå Object - may cause issues
  useEffect(() => {
    applyConfig(config);
  }, [config]);  // Re-runs EVERY render if parent creates new object
  
  // ‚úÖ Solution 1: Destructure specific properties
  useEffect(() => {
    applyConfig(config);
  }, [config.theme, config.language]);  // Only re-run when these change
  
  // ‚úÖ Solution 2: useMemo in parent
  // Parent: const config = useMemo(() => ({ theme, language }), [theme, language]);
}
```

**Functions as Dependencies:**

```javascript
function Component({ fetchData }) {
  // ‚ùå Problem: fetchData is new function every render
  useEffect(() => {
    fetchData();
  }, [fetchData]);  // Re-runs every render!
  
  // ‚úÖ Solution 1: Wrap in useCallback (parent component)
  // Parent: const fetchData = useCallback(() => { ... }, []);
  
  // ‚úÖ Solution 2: Define inside effect
  useEffect(() => {
    function fetchData() {
      // fetch logic
    }
    fetchData();
  }, []);  // No external dependency
}
```

---

## 5.3 useContext

### What is Context?

Context provides a way to **pass data through the component tree without manually passing props** at every level.

**Problem Without Context:**

```javascript
function App() {
  const [theme, setTheme] = useState('light');
  
  return <Page theme={theme} setTheme={setTheme} />;
}

function Page({ theme, setTheme }) {
  return <Section theme={theme} setTheme={setTheme} />;
}

function Section({ theme, setTheme }) {
  return <Article theme={theme} setTheme={setTheme} />;
}

function Article({ theme, setTheme }) {
  return (
    <div className={theme}>
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        Toggle
      </button>
    </div>
  );
}
// Prop drilling! üòì
```

**Solution With Context:**

```javascript
// 1. Create context
const ThemeContext = createContext();

// 2. Provide context value
function App() {
  const [theme, setTheme] = useState('light');
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <Page />
    </ThemeContext.Provider>
  );
}

// 3. Consume context with useContext
function Article() {
  const { theme, setTheme } = useContext(ThemeContext);
  
  return (
    <div className={theme}>
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        Toggle
      </button>
    </div>
  );
}

// No prop drilling! üéâ
```

### Complete Context Example

```javascript
import { createContext, useContext, useState } from 'react';

// 1. Create context with default value
const UserContext = createContext({
  user: null,
  login: () => {},
  logout: () => {}
});

// 2. Create provider component
function UserProvider({ children }) {
  const [user, setUser] = useState(null);
  
  const login = (username, password) => {
    // Authenticate user
    setUser({ id: 1, username, role: 'user' });
  };
  
  const logout = () => {
    setUser(null);
  };
  
  const value = {
    user,
    login,
    logout
  };
  
  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  );
}

// 3. Create custom hook for convenience
function useUser() {
  const context = useContext(UserContext);
  
  if (context === undefined) {
    throw new Error('useUser must be used within UserProvider');
  }
  
  return context;
}

// 4. Use in components
function App() {
  return (
    <UserProvider>
      <Header />
      <Main />
      <Footer />
    </UserProvider>
  );
}

function Header() {
  const { user, logout } = useUser();
  
  return (
    <header>
      {user ? (
        <>
          <span>Welcome, {user.username}!</span>
          <button onClick={logout}>Logout</button>
        </>
      ) : (
        <LoginButton />
      )}
    </header>
  );
}

function LoginButton() {
  const { login } = useUser();
  
  return (
    <button onClick={() => login('john', 'password')}>
      Login
    </button>
  );
}
```

### Multiple Contexts

You can use multiple contexts:

```javascript
const ThemeContext = createContext();
const UserContext = createContext();
const LanguageContext = createContext();

function App() {
  return (
    <ThemeContext.Provider value={{ theme: 'dark' }}>
      <UserContext.Provider value={{ user: userData }}>
        <LanguageContext.Provider value={{ lang: 'en' }}>
          <Page />
        </LanguageContext.Provider>
      </UserContext.Provider>
    </ThemeContext.Provider>
  );
}

function Component() {
  const { theme } = useContext(ThemeContext);
  const { user } = useContext(UserContext);
  const { lang } = useContext(LanguageContext);
  
  return <div className={theme}>{user.name}</div>;
}
```

### Context Performance Considerations

**Problem: Context changes re-render ALL consumers**

```javascript
function AppProvider({ children }) {
  const [theme, setTheme] = useState('light');
  const [user, setUser] = useState(null);
  
  // ‚ùå Problem: When theme changes, ALL consumers re-render
  const value = { theme, setTheme, user, setUser };
  
  return (
    <AppContext.Provider value={value}>
      {children}
    </AppContext.Provider>
  );
}

function ThemeButton() {
  const { theme, setTheme } = useContext(AppContext);
  // Re-renders when user changes (even though it doesn't use user)
  return <button onClick={() => setTheme('dark')}>{theme}</button>;
}
```

**Solution: Split contexts**

```javascript
// ‚úÖ Solution: Separate contexts
const ThemeContext = createContext();
const UserContext = createContext();

function AppProvider({ children }) {
  const [theme, setTheme] = useState('light');
  const [user, setUser] = useState(null);
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <UserContext.Provider value={{ user, setUser }}>
        {children}
      </UserContext.Provider>
    </ThemeContext.Provider>
  );
}

function ThemeButton() {
  const { theme, setTheme } = useContext(ThemeContext);
  // Only re-renders when theme changes
  return <button onClick={() => setTheme('dark')}>{theme}</button>;
}
```

---

## 5.4 useReducer

### What is useReducer?

`useReducer` is an alternative to `useState` for **complex state logic**. It's similar to Redux reducers.

**When to use useReducer:**
- State has complex update logic
- Multiple sub-values in state
- Next state depends on previous state
- Want to optimize performance (pass dispatch down instead of callbacks)

**Basic Syntax:**

```javascript
const [state, dispatch] = useReducer(reducer, initialState);

// reducer function
function reducer(state, action) {
  switch (action.type) {
    case 'ACTION_TYPE':
      return newState;
    default:
      return state;
  }
}
```

### Simple Counter Example

```javascript
function Counter() {
  const initialState = { count: 0 };
  
  function reducer(state, action) {
    switch (action.type) {
      case 'INCREMENT':
        return { count: state.count + 1 };
      case 'DECREMENT':
        return { count: state.count - 1 };
      case 'RESET':
        return initialState;
      default:
        throw new Error(`Unknown action: ${action.type}`);
    }
  }
  
  const [state, dispatch] = useReducer(reducer, initialState);
  
  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-</button>
      <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>
    </div>
  );
}
```

### Complex State Example: Todo List

```javascript
function TodoList() {
  const initialState = {
    todos: [],
    filter: 'all'  // 'all' | 'active' | 'completed'
  };
  
  function todoReducer(state, action) {
    switch (action.type) {
      case 'ADD_TODO':
        return {
          ...state,
          todos: [
            ...state.todos,
            {
              id: Date.now(),
              text: action.payload,
              completed: false
            }
          ]
        };
      
      case 'TOGGLE_TODO':
        return {
          ...state,
          todos: state.todos.map(todo =>
            todo.id === action.payload
              ? { ...todo, completed: !todo.completed }
              : todo
          )
        };
      
      case 'DELETE_TODO':
        return {
          ...state,
          todos: state.todos.filter(todo => todo.id !== action.payload)
        };
      
      case 'SET_FILTER':
        return {
          ...state,
          filter: action.payload
        };
      
      case 'CLEAR_COMPLETED':
        return {
          ...state,
          todos: state.todos.filter(todo => !todo.completed)
        };
      
      default:
        return state;
    }
  }
  
  const [state, dispatch] = useReducer(todoReducer, initialState);
  
  const addTodo = (text) => {
    dispatch({ type: 'ADD_TODO', payload: text });
  };
  
  const toggleTodo = (id) => {
    dispatch({ type: 'TOGGLE_TODO', payload: id });
  };
  
  const deleteTodo = (id) => {
    dispatch({ type: 'DELETE_TODO', payload: id });
  };
  
  const setFilter = (filter) => {
    dispatch({ type: 'SET_FILTER', payload: filter });
  };
  
  const clearCompleted = () => {
    dispatch({ type: 'CLEAR_COMPLETED' });
  };
  
  const filteredTodos = state.todos.filter(todo => {
    if (state.filter === 'active') return !todo.completed;
    if (state.filter === 'completed') return todo.completed;
    return true;
  });
  
  return (
    <div>
      <input onKeyPress={(e) => {
        if (e.key === 'Enter') {
          addTodo(e.target.value);
          e.target.value = '';
        }
      }} />
      
      <ul>
        {filteredTodos.map(todo => (
          <li key={todo.id}>
            <input 
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            />
            <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>
              {todo.text}
            </span>
            <button onClick={() => deleteTodo(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>
      
      <div>
        <button onClick={() => setFilter('all')}>All</button>
        <button onClick={() => setFilter('active')}>Active</button>
        <button onClick={() => setFilter('completed')}>Completed</button>
        <button onClick={clearCompleted}>Clear Completed</button>
      </div>
    </div>
  );
}
```

### useReducer vs useState

```javascript
// useState - Simple state
function Component() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <input value={name} onChange={e => setName(e.target.value)} />
    </div>
  );
}

// useReducer - Complex state with multiple actions
function Component() {
  const [state, dispatch] = useReducer(reducer, {
    count: 0,
    name: ''
  });
  
  return (
    <div>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>Increment</button>
      <input 
        value={state.name} 
        onChange={e => dispatch({ type: 'SET_NAME', payload: e.target.value })} 
      />
    </div>
  );
}
```

**When to use which:**

| Use useState | Use useReducer |
|-------------|----------------|
| Simple state (primitives) | Complex state (objects with multiple fields) |
| Independent state updates | Related state updates |
| No complex update logic | Complex update logic |
| 1-2 state variables | Multiple related state variables |

### Lazy Initialization

```javascript
function Component() {
  const init = (initialCount) => {
    return { count: initialCount };
  };
  
  const [state, dispatch] = useReducer(reducer, 10, init);
  // init(10) is called only once on mount
}
```

---

## 5.5 useCallback

### What is useCallback?

`useCallback` returns a **memoized callback function**. It only creates a new function when dependencies change.

**Why?** Prevents unnecessary re-renders of child components that depend on callback stability.

**Syntax:**
```javascript
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b]  // Dependencies
);
```

### Problem Without useCallback

```javascript
function Parent() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');
  
  // ‚ùå New function created on every render
  const handleClick = () => {
    console.log('Clicked:', name);
  };
  
  return (
    <div>
      <input value={name} onChange={e => setName(e.target.value)} />
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      
      {/* Child re-renders even when name doesn't change */}
      <ExpensiveChild onClick={handleClick} />
    </div>
  );
}

const ExpensiveChild = React.memo(({ onClick }) => {
  console.log('ExpensiveChild rendered');
  return <button onClick={onClick}>Click Me</button>;
});

// Every time Parent renders (count changes), ExpensiveChild re-renders
// because handleClick is a new function reference each time
```

### Solution With useCallback

```javascript
function Parent() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');
  
  // ‚úÖ Function only recreated when name changes
  const handleClick = useCallback(() => {
    console.log('Clicked:', name);
  }, [name]);
  
  return (
    <div>
      <input value={name} onChange={e => setName(e.target.value)} />
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      
      {/* Child only re-renders when name changes */}
      <ExpensiveChild onClick={handleClick} />
    </div>
  );
}

const ExpensiveChild = React.memo(({ onClick }) => {
  console.log('ExpensiveChild rendered');
  return <button onClick={onClick}>Click Me</button>;
});

// Now ExpensiveChild only re-renders when name changes
```

### Real-World Example

```javascript
function SearchComponent() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  
  // ‚úÖ Search function doesn't change unless dependencies change
  const handleSearch = useCallback(async (searchTerm) => {
    const response = await fetch(`/api/search?q=${searchTerm}`);
    const data = await response.json();
    setResults(data);
  }, []);  // Empty deps - function never changes
  
  return (
    <div>
      <SearchInput 
        value={query}
        onChange={setQuery}
        onSearch={handleSearch}
      />
      <ResultsList results={results} />
    </div>
  );
}

const SearchInput = React.memo(({ value, onChange, onSearch }) => {
  console.log('SearchInput rendered');
  
  return (
    <input 
      value={value}
      onChange={e => onChange(e.target.value)}
      onKeyPress={e => {
        if (e.key === 'Enter') {
          onSearch(value);
        }
      }}
    />
  );
});
```

### When NOT to use useCallback

```javascript
// ‚ùå Unnecessary - no child components
function Component() {
  const handleClick = useCallback(() => {
    console.log('Clicked');
  }, []);
  
  return <button onClick={handleClick}>Click</button>;
  // Just use: onClick={() => console.log('Clicked')}
}

// ‚ùå Unnecessary - child not memoized
function Parent() {
  const handleClick = useCallback(() => {
    console.log('Clicked');
  }, []);
  
  return <Child onClick={handleClick} />;
  // Child will re-render anyway if not wrapped in React.memo
}
```

---

## 5.6 useMemo

### What is useMemo?

`useMemo` returns a **memoized value**. It only recomputes when dependencies change.

**Difference from useCallback:**
- `useCallback` memoizes **functions**
- `useMemo` memoizes **values** (results of computations)

**Syntax:**
```javascript
const memoizedValue = useMemo(
  () => computeExpensiveValue(a, b),
  [a, b]  // Dependencies
);
```

### Problem Without useMemo

```javascript
function Component({ items, filter }) {
  // ‚ùå Expensive filtering happens on EVERY render
  const filteredItems = items.filter(item => 
    item.name.toLowerCase().includes(filter.toLowerCase())
  );
  
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <ul>
        {filteredItems.map(item => <li key={item.id}>{item.name}</li>)}
      </ul>
    </div>
  );
  
  // Every time count changes, filtering happens again!
}
```

### Solution With useMemo

```javascript
function Component({ items, filter }) {
  // ‚úÖ Filtering only happens when items or filter change
  const filteredItems = useMemo(() => {
    console.log('Filtering items...');
    return items.filter(item => 
      item.name.toLowerCase().includes(filter.toLowerCase())
    );
  }, [items, filter]);
  
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <ul>
        {filteredItems.map(item => <li key={item.id}>{item.name}</li>)}
      </ul>
    </div>
  );
  
  // Count changes don't trigger filtering!
}
```

### Common Use Cases

**1. Expensive Calculations:**

```javascript
function DataVisualization({ data }) {
  // ‚úÖ Only recalculate when data changes
  const processedData = useMemo(() => {
    console.log('Processing data...');
    
    // Expensive operations
    return data
      .map(item => ({
        ...item,
        normalized: item.value / 100,
        formatted: formatCurrency(item.value)
      }))
      .sort((a, b) => b.value - a.value);
  }, [data]);
  
  return <Chart data={processedData} />;
}
```

**2. Referential Equality:**

```javascript
function Parent() {
  const [count, setCount] = useState(0);
  
  // ‚ùå New object on every render
  const style = { color: 'red', fontSize: 16 };
  
  // ‚úÖ Same object reference unless dependencies change
  const memoizedStyle = useMemo(() => ({
    color: 'red',
    fontSize: 16
  }), []);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <ChildComponent style={memoizedStyle} />
    </div>
  );
}

const ChildComponent = React.memo(({ style }) => {
  console.log('Child rendered');
  return <div style={style}>Content</div>;
});
```

**3. Sorting/Filtering Large Lists:**

```javascript
function UserList({ users, sortBy, filterText }) {
  const processedUsers = useMemo(() => {
    let result = users;
    
    // Filter
    if (filterText) {
      result = result.filter(user =>
        user.name.toLowerCase().includes(filterText.toLowerCase())
      );
    }
    
    // Sort
    result = [...result].sort((a, b) => {
      if (sortBy === 'name') {
        return a.name.localeCompare(b.name);
      }
      if (sortBy === 'age') {
        return a.age - b.age;
      }
      return 0;
    });
    
    return result;
  }, [users, sortBy, filterText]);
  
  return (
    <ul>
      {processedUsers.map(user => (
        <li key={user.id}>{user.name} - {user.age}</li>
      ))}
    </ul>
  );
}
```

### When NOT to use useMemo

```javascript
// ‚ùå Premature optimization - simple calculation
const doubled = useMemo(() => count * 2, [count]);
// Just use: const doubled = count * 2;

// ‚ùå No performance benefit - child not memoized
const value = useMemo(() => ({ name, age }), [name, age]);
return <Child value={value} />;
// Child re-renders anyway if not wrapped in React.memo

// ‚ùå Dependencies change frequently
const result = useMemo(() => expensiveCalc(props), [props]);
// If props change every render, useMemo adds overhead
```

### useCallback vs useMemo

```javascript
// These are equivalent:

// useCallback
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);

// useMemo
const memoizedCallback = useMemo(() => {
  return () => {
    doSomething(a, b);
  };
}, [a, b]);

// Rule of thumb:
// useCallback(fn, deps) === useMemo(() => fn, deps)
```

---

## 5.7 useRef

### What is useRef?

`useRef` returns a **mutable object** that persists across renders.

**Key characteristics:**
- Doesn't trigger re-render when changed
- Persists between renders
- Can reference DOM elements

**Syntax:**
```javascript
const ref = useRef(initialValue);
// Access: ref.current
```

### Use Case 1: DOM References

```javascript
function TextInput() {
  const inputRef = useRef(null);
  
  const focusInput = () => {
    inputRef.current.focus();
  };
  
  const selectText = () => {
    inputRef.current.select();
  };
  
  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus</button>
      <button onClick={selectText}>Select</button>
    </div>
  );
}
```

**More DOM Examples:**

```javascript
function ScrollToTop() {
  const topRef = useRef(null);
  
  const scrollToTop = () => {
    topRef.current.scrollIntoView({ behavior: 'smooth' });
  };
  
  return (
    <div>
      <div ref={topRef}>Top of page</div>
      {/* Long content */}
      <button onClick={scrollToTop}>Back to top</button>
    </div>
  );
}

function VideoPlayer() {
  const videoRef = useRef(null);
  
  const play = () => videoRef.current.play();
  const pause = () => videoRef.current.pause();
  const stop = () => {
    videoRef.current.pause();
    videoRef.current.currentTime = 0;
  };
  
  return (
    <div>
      <video ref={videoRef} src="video.mp4" />
      <button onClick={play}>Play</button>
      <button onClick={pause}>Pause</button>
      <button onClick={stop}>Stop</button>
    </div>
  );
}
```

### Use Case 2: Storing Mutable Values

```javascript
function Timer() {
  const [seconds, setSeconds] = useState(0);
  const intervalRef = useRef(null);
  
  const start = () => {
    if (intervalRef.current) return;  // Already running
    
    intervalRef.current = setInterval(() => {
      setSeconds(s => s + 1);
    }, 1000);
  };
  
  const stop = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  };
  
  const reset = () => {
    stop();
    setSeconds(0);
  };
  
  useEffect(() => {
    return () => {
      // Cleanup on unmount
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);
  
  return (
    <div>
      <p>Seconds: {seconds}</p>
      <button onClick={start}>Start</button>
      <button onClick={stop}>Stop</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

### Use Case 3: Previous Value

```javascript
function usePrevious(value) {
  const ref = useRef();
  
  useEffect(() => {
    ref.current = value;
  }, [value]);
  
  return ref.current;
}

// Usage
function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);
  
  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {prevCount}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

### Use Case 4: Avoiding Stale Closures

```javascript
function Component() {
  const [count, setCount] = useState(0);
  const countRef = useRef(count);
  
  useEffect(() => {
    countRef.current = count;  // Always keep ref in sync
  }, [count]);
  
  const handleClick = () => {
    setTimeout(() => {
      // ‚ùå count is stale (captured at time of click)
      console.log('Stale count:', count);
      
      // ‚úÖ countRef.current is always current
      console.log('Current count:', countRef.current);
    }, 3000);
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={handleClick}>Log after 3s</button>
    </div>
  );
}
```

### useRef vs useState

```javascript
// useState - Triggers re-render
const [count, setCount] = useState(0);
setCount(1);  // Component re-renders

// useRef - Doesn't trigger re-render
const countRef = useRef(0);
countRef.current = 1;  // No re-render!

// When to use which:
// useState: When you need UI to update
// useRef: When you need to store value without triggering render
```

---

## 5.8 useImperativeHandle

### What is useImperativeHandle?

`useImperativeHandle` customizes the instance value exposed to parent components when using `ref`.

**Rarely used** - only when you need to expose imperative methods to parent.

**Syntax:**
```javascript
useImperativeHandle(ref, () => ({
  // Methods to expose
}), [dependencies]);
```

### Example: Custom Input

```javascript
import { forwardRef, useRef, useImperativeHandle } from 'react';

const CustomInput = forwardRef((props, ref) => {
  const inputRef = useRef();
  
  useImperativeHandle(ref, () => ({
    // Expose only these methods to parent
    focus: () => {
      inputRef.current.focus();
    },
    clear: () => {
      inputRef.current.value = '';
    },
    getValue: () => {
      return inputRef.current.value;
    }
  }));
  
  return <input ref={inputRef} {...props} />;
});

// Parent component
function Parent() {
  const inputRef = useRef();
  
  return (
    <div>
      <CustomInput ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>Focus</button>
      <button onClick={() => inputRef.current.clear()}>Clear</button>
      <button onClick={() => alert(inputRef.current.getValue())}>
        Get Value
      </button>
    </div>
  );
}
```

---

## 5.9 useLayoutEffect

### What is useLayoutEffect?

`useLayoutEffect` is identical to `useEffect` but fires **synchronously after DOM mutations** and **before browser paint**.

**Execution Order:**
```
1. React renders component
2. DOM is updated
3. useLayoutEffect runs (synchronous)
4. Browser paints screen
5. useEffect runs (asynchronous)
```

### When to Use

Use `useLayoutEffect` when you need to:
- Measure DOM elements
- Update DOM synchronously before paint
- Prevent visual flicker

```javascript
function Component() {
  const [height, setHeight] = useState(0);
  const ref = useRef(null);
  
  // ‚ùå useEffect - causes flicker
  useEffect(() => {
    setHeight(ref.current.offsetHeight);
    // Screen paints with old height, then updates
  }, []);
  
  // ‚úÖ useLayoutEffect - no flicker
  useLayoutEffect(() => {
    setHeight(ref.current.offsetHeight);
    // Screen paints with correct height immediately
  }, []);
  
  return <div ref={ref}>Content</div>;
}
```

### Example: Tooltip Positioning

```javascript
function Tooltip({ children, text }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const tooltipRef = useRef(null);
  const targetRef = useRef(null);
  
  useLayoutEffect(() => {
    if (tooltipRef.current && targetRef.current) {
      const targetRect = targetRef.current.getBoundingClientRect();
      const tooltipRect = tooltipRef.current.getBoundingClientRect();
      
      // Calculate position before paint
      setPosition({
        x: targetRect.left + (targetRect.width - tooltipRect.width) / 2,
        y: targetRect.top - tooltipRect.height - 10
      });
    }
  }, [text]);
  
  return (
    <div>
      <div ref={targetRef}>{children}</div>
      <div 
        ref={tooltipRef}
        style={{
          position: 'fixed',
          left: position.x,
          top: position.y
        }}
      >
        {text}
      </div>
    </div>
  );
}
```

**‚ö†Ô∏è Warning:** `useLayoutEffect` blocks visual updates. Use sparingly!

---

## 5.10 useTransition (React 18)

### What is useTransition?

`useTransition` marks state updates as **non-urgent** (transitions). Allows React to interrupt rendering to keep UI responsive.

**Syntax:**
```javascript
const [isPending, startTransition] = useTransition();

startTransition(() => {
  // Non-urgent state updates
  setState(newValue);
});
```

### Example: Search with Heavy Rendering

```javascript
function SearchPage() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();
  
  const handleSearch = (value) => {
    // Urgent: Update input immediately
    setQuery(value);
    
    // Non-urgent: Update results (can be interrupted)
    startTransition(() => {
      const filtered = bigList.filter(item =>
        item.includes(value)
      );
      setResults(filtered);
    });
  };
  
  return (
    <div>
      <input 
        value={query}
        onChange={e => handleSearch(e.target.value)}
      />
      
      {isPending && <Spinner />}
      
      <Results items={results} />
    </div>
  );
}
```

---

## 5.11 useDeferredValue (React 18)

### What is useDeferredValue?

`useDeferredValue` returns a **deferred version of a value**. React delays updating it to keep UI responsive.

**Syntax:**
```javascript
const deferredValue = useDeferredValue(value);
```

### Example: Debouncing Without Extra State

```javascript
function SearchResults({ query }) {
  const deferredQuery = useDeferredValue(query);
  
  // Expensive filtering
  const results = useMemo(() => {
    return bigList.filter(item =>
      item.includes(deferredQuery)
    );
  }, [deferredQuery]);
  
  return (
    <div>
      {/* Input updates immediately */}
      <input value={query} onChange={...} />
      
      {/* Results update with delay */}
      <Results items={results} />
    </div>
  );
}
```

---

## 5.12 useId (React 18)

### What is useId?

`useId` generates **unique IDs** for accessibility attributes. IDs are stable across server/client rendering.

**Syntax:**
```javascript
const id = useId();
```

### Example: Accessible Form

```javascript
function FormField({ label, type = 'text' }) {
  const id = useId();
  
  return (
    <div>
      <label htmlFor={id}>{label}</label>
      <input id={id} type={type} />
    </div>
  );
}

// Usage
function Form() {
  return (
    <form>
      <FormField label="Name" />
      <FormField label="Email" type="email" />
      {/* Each field gets unique ID */}
    </form>
  );
}
```

---

## Summary of Chapter 5

**Core Hooks:**
- `useState` - Add state to functional components
- `useEffect` - Handle side effects and lifecycle
- `useContext` - Access context values
- `useReducer` - Complex state management
- `useCallback` - Memoize functions
- `useMemo` - Memoize values
- `useRef` - DOM refs and mutable values

**Advanced Hooks:**
- `useImperativeHandle` - Customize ref exposure
- `useLayoutEffect` - Synchronous DOM updates
- `useTransition` (React 18) - Mark non-urgent updates
- `useDeferredValue` (React 18) - Defer value updates
- `useId` (React 18) - Generate unique IDs

**Quick Reference:**

| Hook | Purpose | Returns |
|------|---------|---------|
| useState | State management | [state, setState] |
| useEffect | Side effects | cleanup function |
| useContext | Context consumption | context value |
| useReducer | Complex state | [state, dispatch] |
| useCallback | Memoize function | memoized function |
| useMemo | Memoize value | memoized value |
| useRef | Mutable ref | { current: value } |

**Key Takeaways:**

1. **useState**: Use functional updates when new state depends on old
2. **useEffect**: Always specify dependencies correctly
3. **useContext**: Split contexts to avoid unnecessary re-renders
4. **useReducer**: Use for complex state with multiple related updates
5. **useCallback/useMemo**: Only optimize when needed (measure first!)
6. **useRef**: Doesn't trigger re-renders, perfect for DOM refs
7. **Always follow Rules of Hooks**: Top level, React functions only

**Practice Exercises:**

1. Build a form with useReducer
2. Create a custom useLocalStorage hook
3. Implement useDebounce and useThrottle
4. Build a data fetching hook with loading/error states
5. Create a useToggle hook
6. Implement usePrevious
7. Build a useOnClickOutside hook
8. Create a useMediaQuery hook