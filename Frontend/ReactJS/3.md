# Chapter 3: Event Handling - In-Depth Explanation

## 3.1 Event Basics

### What are Events in React?

Events are **actions that happen in the browser** - user clicks, keyboard input, mouse movements, form submissions, etc. React wraps native browser events in a cross-browser wrapper called **SyntheticEvent**.

**Common Events:**
- Mouse: click, doubleClick, mouseEnter, mouseLeave, mouseMove
- Keyboard: keyDown, keyUp, keyPress
- Form: submit, change, input, focus, blur
- Touch: touchStart, touchMove, touchEnd
- Scroll: scroll
- Clipboard: copy, paste, cut

### Synthetic Events

React's **SyntheticEvent** is a cross-browser wrapper around native browser events.

**Why SyntheticEvents?**

**Problem with Native Events:**
```javascript
// Browser differences:
// IE: event.srcElement
// Chrome/Firefox: event.target

// Different event objects across browsers
element.addEventListener('click', (e) => {
  const target = e.target || e.srcElement; // Need to check both!
});
```

**Solution: React's SyntheticEvent:**
```javascript
// Same API across all browsers
<button onClick={(e) => {
  console.log(e.target); // Works everywhere!
}}>
  Click me
</button>
```

**Key Features of SyntheticEvents:**

1. **Cross-browser compatibility** - Same API everywhere
2. **Performance optimization** - Event pooling (React 16 and earlier)
3. **Familiar API** - Similar to native events
4. **Automatic cleanup** - No memory leaks

**SyntheticEvent Properties:**
```javascript
function handleClick(e) {
  // Event properties
  console.log(e.type);           // "click"
  console.log(e.target);         // Element that triggered event
  console.log(e.currentTarget);  // Element with event handler
  console.log(e.clientX);        // Mouse X coordinate
  console.log(e.clientY);        // Mouse Y coordinate
  console.log(e.timeStamp);      // When event occurred
  
  // Methods
  e.preventDefault();            // Prevent default behavior
  e.stopPropagation();          // Stop event bubbling
  
  // Native event (if needed)
  console.log(e.nativeEvent);   // Access browser's native event
}
```

**Important Note (React 17+):**
Event pooling was removed in React 17. You can now safely access event properties asynchronously.

```javascript
// React 16 and earlier
function handleClick(e) {
  setTimeout(() => {
    console.log(e.type); // ❌ Error! Event was pooled/nullified
  }, 1000);
}

// React 17+
function handleClick(e) {
  setTimeout(() => {
    console.log(e.type); // ✅ Works! No pooling
  }, 1000);
}
```

### Event Handlers

**Basic Syntax:**

```javascript
// HTML vs React syntax
// HTML: onclick (lowercase, string)
<button onclick="handleClick()">Click</button>

// React: onClick (camelCase, function)
<button onClick={handleClick}>Click</button>
```

**Method 1: Inline Function**
```javascript
function App() {
  return (
    <button onClick={() => console.log('Clicked!')}>
      Click me
    </button>
  );
}

// Good for: Simple logic, one-liners
// Avoid for: Complex logic, performance-sensitive components
```

**Method 2: Named Function**
```javascript
function App() {
  const handleClick = () => {
    console.log('Clicked!');
  };
  
  return <button onClick={handleClick}>Click me</button>;
}

// Good for: Reusability, readability, complex logic
// Preferred for: Most scenarios
```

**Method 3: Function Declaration**
```javascript
function App() {
  function handleClick() {
    console.log('Clicked!');
  }
  
  return <button onClick={handleClick}>Click me</button>;
}
```

**Method 4: Class Component Methods**
```javascript
class App extends React.Component {
  handleClick = () => {
    console.log('Clicked!');
  }
  
  // Or with binding in constructor
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
  }
  
  handleClick() {
    console.log('Clicked!');
  }
  
  render() {
    return <button onClick={this.handleClick}>Click me</button>;
  }
}
```

### Event Binding (Class Components)

In class components, **binding is crucial** for accessing `this`.

**Problem: Losing `this` Context**
```javascript
class Button extends React.Component {
  constructor(props) {
    super(props);
    this.state = { clicks: 0 };
  }
  
  handleClick() {
    // ❌ Error: Cannot read property 'setState' of undefined
    this.setState({ clicks: this.state.clicks + 1 });
  }
  
  render() {
    return (
      <button onClick={this.handleClick}>
        Clicks: {this.state.clicks}
      </button>
    );
  }
}
```

**Solution 1: Bind in Constructor (Traditional)**
```javascript
class Button extends React.Component {
  constructor(props) {
    super(props);
    this.state = { clicks: 0 };
    this.handleClick = this.handleClick.bind(this); // ✅ Bind here
  }
  
  handleClick() {
    this.setState({ clicks: this.state.clicks + 1 });
  }
  
  render() {
    return (
      <button onClick={this.handleClick}>
        Clicks: {this.state.clicks}
      </button>
    );
  }
}
```

**Solution 2: Arrow Function Property (Modern, Recommended)**
```javascript
class Button extends React.Component {
  state = { clicks: 0 };
  
  // ✅ Arrow function automatically binds 'this'
  handleClick = () => {
    this.setState({ clicks: this.state.clicks + 1 });
  }
  
  render() {
    return (
      <button onClick={this.handleClick}>
        Clicks: {this.state.clicks}
      </button>
    );
  }
}
```

**Solution 3: Arrow Function in JSX (Works but creates new function each render)**
```javascript
class Button extends React.Component {
  state = { clicks: 0 };
  
  handleClick() {
    this.setState({ clicks: this.state.clicks + 1 });
  }
  
  render() {
    return (
      <button onClick={() => this.handleClick()}>
        Clicks: {this.state.clicks}
      </button>
    );
  }
}
// ⚠️ Creates new function every render - avoid for performance-critical components
```

**Functional Components (No Binding Needed!)**
```javascript
function Button() {
  const [clicks, setClicks] = useState(0);
  
  // ✅ No binding issues with functional components
  const handleClick = () => {
    setClicks(clicks + 1);
  };
  
  return (
    <button onClick={handleClick}>
      Clicks: {clicks}
    </button>
  );
}
```

### Passing Arguments to Event Handlers

**Method 1: Arrow Function Wrapper**
```javascript
function ProductList() {
  const handleDelete = (productId) => {
    console.log('Deleting product:', productId);
  };
  
  const products = [
    { id: 1, name: 'Product 1' },
    { id: 2, name: 'Product 2' }
  ];
  
  return (
    <div>
      {products.map(product => (
        <div key={product.id}>
          <span>{product.name}</span>
          {/* Arrow function wrapper */}
          <button onClick={() => handleDelete(product.id)}>
            Delete
          </button>
        </div>
      ))}
    </div>
  );
}
```

**Method 2: Currying (Higher-Order Function)**
```javascript
function ProductList() {
  // Returns a function that takes the event
  const handleDelete = (productId) => (event) => {
    console.log('Deleting:', productId);
    console.log('Event:', event);
  };
  
  const products = [
    { id: 1, name: 'Product 1' },
    { id: 2, name: 'Product 2' }
  ];
  
  return (
    <div>
      {products.map(product => (
        <div key={product.id}>
          <span>{product.name}</span>
          {/* No wrapper needed */}
          <button onClick={handleDelete(product.id)}>
            Delete
          </button>
        </div>
      ))}
    </div>
  );
}
```

**Method 3: Data Attributes**
```javascript
function ProductList() {
  const handleDelete = (event) => {
    const productId = event.target.dataset.productId;
    console.log('Deleting:', productId);
  };
  
  const products = [
    { id: 1, name: 'Product 1' },
    { id: 2, name: 'Product 2' }
  ];
  
  return (
    <div>
      {products.map(product => (
        <div key={product.id}>
          <span>{product.name}</span>
          {/* Store ID in data attribute */}
          <button 
            onClick={handleDelete}
            data-product-id={product.id}
          >
            Delete
          </button>
        </div>
      ))}
    </div>
  );
}
```

**Comparison:**
```javascript
// Performance consideration in lists

// ❌ Creates new function on EVERY render for EVERY item
<button onClick={() => handleClick(id)}>Click</button>

// ✅ Better: Creates function once per component
<button onClick={handleClick(id)}>Click</button>
// (where handleClick returns a function)

// ✅ Best for large lists: Use data attributes or refs
<button onClick={handleClick} data-id={id}>Click</button>
```

### Common Event Examples

**1. Click Events**
```javascript
function ClickDemo() {
  const handleClick = (e) => {
    console.log('Button clicked!');
    console.log('Target:', e.target.tagName);
  };
  
  const handleDoubleClick = () => {
    console.log('Double clicked!');
  };
  
  const handleRightClick = (e) => {
    e.preventDefault(); // Prevent context menu
    console.log('Right clicked!');
  };
  
  return (
    <div>
      <button onClick={handleClick}>Click me</button>
      <button onDoubleClick={handleDoubleClick}>Double click me</button>
      <button onContextMenu={handleRightClick}>Right click me</button>
    </div>
  );
}
```

**2. Mouse Events**
```javascript
function MouseDemo() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [isHovered, setIsHovered] = useState(false);
  
  const handleMouseMove = (e) => {
    setPosition({ x: e.clientX, y: e.clientY });
  };
  
  const handleMouseEnter = () => {
    setIsHovered(true);
  };
  
  const handleMouseLeave = () => {
    setIsHovered(false);
  };
  
  return (
    <div 
      onMouseMove={handleMouseMove}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      style={{ 
        width: '300px', 
        height: '300px', 
        border: '1px solid black',
        backgroundColor: isHovered ? 'lightblue' : 'white'
      }}
    >
      <p>Mouse position: {position.x}, {position.y}</p>
      <p>{isHovered ? 'Mouse inside!' : 'Mouse outside'}</p>
    </div>
  );
}
```

**3. Keyboard Events**
```javascript
function KeyboardDemo() {
  const [key, setKey] = useState('');
  
  const handleKeyDown = (e) => {
    console.log('Key pressed:', e.key);
    console.log('Key code:', e.keyCode);
    console.log('Ctrl pressed:', e.ctrlKey);
    console.log('Shift pressed:', e.shiftKey);
    console.log('Alt pressed:', e.altKey);
    
    setKey(e.key);
    
    // Check for specific keys
    if (e.key === 'Enter') {
      console.log('Enter key pressed!');
    }
    
    // Keyboard shortcuts
    if (e.ctrlKey && e.key === 's') {
      e.preventDefault(); // Prevent browser save dialog
      console.log('Ctrl+S pressed!');
    }
  };
  
  return (
    <div>
      <input 
        type="text"
        onKeyDown={handleKeyDown}
        placeholder="Press any key..."
      />
      <p>Last key pressed: {key}</p>
    </div>
  );
}
```

**4. Focus Events**
```javascript
function FocusDemo() {
  const [isFocused, setIsFocused] = useState(false);
  
  const handleFocus = (e) => {
    console.log('Input focused');
    setIsFocused(true);
  };
  
  const handleBlur = (e) => {
    console.log('Input blurred');
    setIsFocused(false);
    
    // Validate on blur
    if (e.target.value === '') {
      alert('Field cannot be empty!');
    }
  };
  
  return (
    <div>
      <input 
        type="text"
        onFocus={handleFocus}
        onBlur={handleBlur}
        style={{ 
          border: isFocused ? '2px solid blue' : '1px solid gray' 
        }}
      />
      <p>{isFocused ? 'Input is focused' : 'Input is not focused'}</p>
    </div>
  );
}
```

**5. Scroll Events**
```javascript
function ScrollDemo() {
  const [scrollY, setScrollY] = useState(0);
  const [showButton, setShowButton] = useState(false);
  
  useEffect(() => {
    const handleScroll = () => {
      setScrollY(window.scrollY);
      setShowButton(window.scrollY > 300);
    };
    
    window.addEventListener('scroll', handleScroll);
    
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);
  
  const scrollToTop = () => {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };
  
  return (
    <div>
      <p>Scroll position: {scrollY}px</p>
      {showButton && (
        <button onClick={scrollToTop}>Back to top</button>
      )}
    </div>
  );
}
```

### Event Propagation

**Event Bubbling** - Events propagate from target element up to the root.

```javascript
function EventBubbling() {
  const handleDivClick = () => {
    console.log('Div clicked');
  };
  
  const handleButtonClick = (e) => {
    console.log('Button clicked');
    // Event will bubble up to div (both handlers fire)
  };
  
  const handleButtonClickNoBubble = (e) => {
    e.stopPropagation(); // ✅ Stop bubbling
    console.log('Button clicked (no bubble)');
    // Only button handler fires, not div
  };
  
  return (
    <div onClick={handleDivClick} style={{ padding: '20px', background: 'lightgray' }}>
      <button onClick={handleButtonClick}>
        Click me (bubbles)
      </button>
      <button onClick={handleButtonClickNoBubble}>
        Click me (no bubble)
      </button>
    </div>
  );
}

// When clicking first button:
// 1. "Button clicked" logged
// 2. "Div clicked" logged (bubbled up)

// When clicking second button:
// 1. "Button clicked (no bubble)" logged
// 2. No div click (stopped propagation)
```

**Preventing Default Behavior**
```javascript
function PreventDefaultDemo() {
  const handleSubmit = (e) => {
    e.preventDefault(); // ✅ Prevent form submission/page reload
    console.log('Form submitted programmatically');
    // Handle form data here
  };
  
  const handleLinkClick = (e) => {
    e.preventDefault(); // ✅ Prevent navigation
    console.log('Link clicked, but not navigating');
  };
  
  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input type="text" />
        <button type="submit">Submit</button>
      </form>
      
      <a href="https://example.com" onClick={handleLinkClick}>
        Click me (won't navigate)
      </a>
    </div>
  );
}
```

---

## 3.2 Form Handling

### Controlled Components

**Controlled components** are form inputs whose value is controlled by React state.

**How They Work:**
```
1. React state holds input value
2. User types in input
3. onChange event fires
4. State updates
5. Component re-renders
6. Input shows new value from state
```

**Basic Example:**
```javascript
function ControlledInput() {
  const [value, setValue] = useState('');
  
  const handleChange = (e) => {
    setValue(e.target.value);
  };
  
  return (
    <div>
      <input 
        type="text"
        value={value}           // ✅ Controlled by state
        onChange={handleChange} // ✅ Update state on change
      />
      <p>You typed: {value}</p>
    </div>
  );
}
```

**Why Use Controlled Components?**
1. **Single Source of Truth** - React state is the authority
2. **Easy Validation** - Validate while user types
3. **Conditional Logic** - Enable/disable based on values
4. **Instant Feedback** - Show errors immediately
5. **Easy to Debug** - State is visible in DevTools

**Complete Form Example:**
```javascript
function LoginForm() {
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    rememberMe: false
  });
  
  const [errors, setErrors] = useState({});
  
  // Single handler for all inputs
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };
  
  const validate = () => {
    const newErrors = {};
    
    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email is invalid';
    }
    
    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 6) {
      newErrors.password = 'Password must be at least 6 characters';
    }
    
    return newErrors;
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    const newErrors = validate();
    
    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors);
      return;
    }
    
    console.log('Form submitted:', formData);
    // API call here
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Email:</label>
        <input 
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
        />
        {errors.email && <span className="error">{errors.email}</span>}
      </div>
      
      <div>
        <label>Password:</label>
        <input 
          type="password"
          name="password"
          value={formData.password}
          onChange={handleChange}
        />
        {errors.password && <span className="error">{errors.password}</span>}
      </div>
      
      <div>
        <label>
          <input 
            type="checkbox"
            name="rememberMe"
            checked={formData.rememberMe}
            onChange={handleChange}
          />
          Remember me
        </label>
      </div>
      
      <button type="submit">Login</button>
    </form>
  );
}
```

**Different Input Types:**

**Text Input:**
```javascript
const [text, setText] = useState('');

<input 
  type="text"
  value={text}
  onChange={(e) => setText(e.target.value)}
/>
```

**Textarea:**
```javascript
const [message, setMessage] = useState('');

<textarea 
  value={message}
  onChange={(e) => setMessage(e.target.value)}
  rows={5}
/>
```

**Select/Dropdown:**
```javascript
const [country, setCountry] = useState('');

<select value={country} onChange={(e) => setCountry(e.target.value)}>
  <option value="">Select country...</option>
  <option value="us">United States</option>
  <option value="uk">United Kingdom</option>
  <option value="ca">Canada</option>
</select>
```

**Multi-Select:**
```javascript
const [selectedOptions, setSelectedOptions] = useState([]);

const handleMultiSelect = (e) => {
  const options = Array.from(e.target.selectedOptions, option => option.value);
  setSelectedOptions(options);
};

<select multiple value={selectedOptions} onChange={handleMultiSelect}>
  <option value="1">Option 1</option>
  <option value="2">Option 2</option>
  <option value="3">Option 3</option>
</select>
```

**Checkbox:**
```javascript
const [isChecked, setIsChecked] = useState(false);

<input 
  type="checkbox"
  checked={isChecked}
  onChange={(e) => setIsChecked(e.target.checked)}
/>
```

**Radio Buttons:**
```javascript
const [selectedOption, setSelectedOption] = useState('option1');

<div>
  <label>
    <input 
      type="radio"
      value="option1"
      checked={selectedOption === 'option1'}
      onChange={(e) => setSelectedOption(e.target.value)}
    />
    Option 1
  </label>
  
  <label>
    <input 
      type="radio"
      value="option2"
      checked={selectedOption === 'option2'}
      onChange={(e) => setSelectedOption(e.target.value)}
    />
    Option 2
  </label>
</div>
```

**File Input (Special Case):**
```javascript
const [file, setFile] = useState(null);

const handleFileChange = (e) => {
  const selectedFile = e.target.files[0];
  setFile(selectedFile);
};

<input 
  type="file"
  onChange={handleFileChange}
  // ⚠️ File input is always uncontrolled (cannot set value)
/>
```

### Uncontrolled Components

**Uncontrolled components** use refs to access DOM values directly, without React state.

**Basic Example:**
```javascript
import { useRef } from 'react';

function UncontrolledInput() {
  const inputRef = useRef(null);
  
  const handleSubmit = (e) => {
    e.preventDefault();
    // Access value directly from DOM
    console.log('Value:', inputRef.current.value);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input 
        type="text"
        ref={inputRef}
        defaultValue="Initial value"  // ✅ Use defaultValue, not value
      />
      <button type="submit">Submit</button>
    </form>
  );
}
```

**When to Use Uncontrolled Components:**
1. Integrating with non-React code
2. Simple forms where you only need value on submit
3. File inputs (always uncontrolled)
4. Performance optimization for very large forms

**Uncontrolled Form Example:**
```javascript
function UncontrolledForm() {
  const nameRef = useRef(null);
  const emailRef = useRef(null);
  const passwordRef = useRef(null);
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    const formData = {
      name: nameRef.current.value,
      email: emailRef.current.value,
      password: passwordRef.current.value
    };
    
    console.log('Form data:', formData);
  };
  
  const handleReset = () => {
    nameRef.current.value = '';
    emailRef.current.value = '';
    passwordRef.current.value = '';
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input ref={nameRef} type="text" defaultValue="" placeholder="Name" />
      <input ref={emailRef} type="email" defaultValue="" placeholder="Email" />
      <input ref={passwordRef} type="password" defaultValue="" placeholder="Password" />
      
      <button type="submit">Submit</button>
      <button type="button" onClick={handleReset}>Reset</button>
    </form>
  );
}
```

**Controlled vs Uncontrolled:**

| Feature | Controlled | Uncontrolled |
|---------|-----------|--------------|
| Data storage | React state | DOM |
| Access value | From state | From ref |
| Validation | Real-time | On submit |
| Updates | setState | Direct DOM manipulation |
| Initial value | value prop | defaultValue prop |
| Best for | Most forms | Simple forms, file inputs |

### useRef for Form Access

**useRef** creates a mutable reference that persists across renders.

**Basic Usage:**
```javascript
import { useRef } from 'react';

function Component() {
  const inputRef = useRef(null);
  
  const focusInput = () => {
    inputRef.current.focus(); // Access DOM element directly
  };
  
  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}
```

**Common useRef Patterns:**

**1. Focus Management:**
```javascript
function FocusDemo() {
  const firstNameRef = useRef(null);
  const lastNameRef = useRef(null);
  const emailRef = useRef(null);
  
  useEffect(() => {
    firstNameRef.current.focus(); // Auto-focus on mount
  }, []);
  
  const handleFirstNameKeyDown = (e) => {
    if (e.key === 'Enter') {
      lastNameRef.current.focus();
    }
  };
  
  const handleLastNameKeyDown = (e) => {
    if (e.key === 'Enter') {
      emailRef.current.focus();
    }
  };
  
  return (
    <div>
      <input 
        ref={firstNameRef}
        onKeyDown={handleFirstNameKeyDown}
        placeholder="First Name"
      />
      <input 
        ref={lastNameRef}
        onKeyDown={handleLastNameKeyDown}
        placeholder="Last Name"
      />
      <input 
        ref={emailRef}
        placeholder="Email"
      />
    </div>
  );
}
```

**2. Measuring Elements:**
```javascript
function MeasureDemo() {
  const divRef = useRef(null);
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  
  const measureElement = () => {
    if (divRef.current) {
      setDimensions({
        width: divRef.current.offsetWidth,
        height: divRef.current.offsetHeight
      });
    }
  };
  
  useEffect(() => {
    measureElement();
    window.addEventListener('resize', measureElement);
    return () => window.removeEventListener('resize', measureElement);
  }, []);
  
  return (
    <div ref={divRef}>
      <p>Width: {dimensions.width}px</p>
      <p>Height: {dimensions.height}px</p>
    </div>
  );
}
```

**3. Previous Value Tracking:**
```javascript
function usePrevious(value) {
  const ref = useRef();
  
  useEffect(() => {
    ref.current = value;
  }, [value]);
  
  return ref.current;
}

function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);
  
  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {prevCount}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

### Form Validation

**Client-Side Validation Strategies:**

**1. Inline Validation (Real-time)**
```javascript
function EmailInput() {
  const [email, setEmail] = useState('');
  const [error, setError] = useState('');
  
  const validateEmail = (value) => {
    if (!value) {
      return 'Email is required';
    }
    if (!/\S+@\S+\.\S+/.test(value)) {
      return 'Email is invalid';
    }
    return '';
  };
  
  const handleChange = (e) => {
    const value = e.target.value;
    setEmail(value);
    setError(validateEmail(value));
  };
  
  return (
    <div>
      <input 
        type="email"
        value={email}
        onChange={handleChange}
        className={error ? 'error' : ''}
      />
      {error && <span className="error-message">{error}</span>}
    </div>
  );
}
```

**2. On Blur Validation**
```javascript
function PasswordInput() {
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [touched, setTouched] = useState(false);
  
  const validatePassword = (value) => {
    if (!value) return 'Password is required';
    if (value.length < 8) return 'Password must be at least 8 characters';
    if (!/[A-Z]/.test(value)) return 'Password must contain uppercase letter';
    if (!/[a-z]/.test(value)) return 'Password must contain lowercase letter';
    if (!/[0-9]/.test(value)) return 'Password must contain number';
    return '';
  };
  
  const handleBlur = () => {
    setTouched(true);
    setError(validatePassword(password));
  };
  
  return (
    <div>
      <input 
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        onBlur={handleBlur}
      />
      {touched && error && <span className="error">{error}</span>}
    </div>
  );
}
```

**3. Submit Validation**
```javascript
function RegistrationForm() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: ''
  });
  
  const [errors, setErrors] = useState({});
  const [submitted, setSubmitted] = useState(false);
  
  const validate = () => {
    const newErrors = {};
    
    if (!formData.username) {
      newErrors.username = 'Username is required';
    } else if (formData.username.length < 3) {
      newErrors.username = 'Username must be at least 3 characters';
    }
    
    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email is invalid';
    }
    
    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 8) {
      newErrors.password = 'Password must be at least 8 characters';
    }
    
    if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'Passwords do not match';
    }
    
    return newErrors;
  };
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
    
    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    setSubmitted(true);
    
    const newErrors = validate();
    setErrors(newErrors);
    
    if (Object.keys(newErrors).length === 0) {
      console.log('Form is valid!', formData);
      // Submit to API
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input 
          name="username"
          value={formData.username}
          onChange={handleChange}
          placeholder="Username"
        />
        {submitted && errors.username && (
          <span className="error">{errors.username}</span>
        )}
      </div>
      
      <div>
        <input 
          name="email"
          type="email"
          value={formData.email}
          onChange={handleChange}
          placeholder="Email"
        />
        {submitted && errors.email && (
          <span className="error">{errors.email}</span>
        )}
      </div>
      
      <div>
        <input 
          name="password"
          type="password"
          value={formData.password}
          onChange={handleChange}
          placeholder="Password"
        />
        {submitted && errors.password && (
          <span className="error">{errors.password}</span>
        )}
      </div>
      
      <div>
        <input 
          name="confirmPassword"
          type="password"
          value={formData.confirmPassword}
          onChange={handleChange}
          placeholder="Confirm Password"
        />
        {submitted && errors.confirmPassword && (
          <span className="error">{errors.confirmPassword}</span>
        )}
      </div>
      
      <button type="submit">Register</button>
    </form>
  );
}
```

**4. Custom Validation Hook**
```javascript
function useFormValidation(initialValues, validate) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setValues(prev => ({ ...prev, [name]: value }));
  };
  
  const handleBlur = (e) => {
    const { name } = e.target;
    setTouched(prev => ({ ...prev, [name]: true }));
    
    const fieldErrors = validate(values);
    setErrors(fieldErrors);
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    const allTouched = Object.keys(values).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {});
    setTouched(allTouched);
    
    const validationErrors = validate(values);
    setErrors(validationErrors);
    
    if (Object.keys(validationErrors).length === 0) {
      return values;
    }
    return null;
  };
  
  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit
  };
}

// Usage
function MyForm() {
  const validate = (values) => {
    const errors = {};
    if (!values.email) errors.email = 'Required';
    if (!values.password) errors.password = 'Required';
    return errors;
  };
  
  const {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit
  } = useFormValidation({ email: '', password: '' }, validate);
  
  const onSubmit = (e) => {
    const result = handleSubmit(e);
    if (result) {
      console.log('Valid form:', result);
    }
  };
  
  return (
    <form onSubmit={onSubmit}>
      <input 
        name="email"
        value={values.email}
        onChange={handleChange}
        onBlur={handleBlur}
      />
      {touched.email && errors.email && <span>{errors.email}</span>}
      
      <input 
        name="password"
        type="password"
        value={values.password}
        onChange={handleChange}
        onBlur={handleBlur}
      />
      {touched.password && errors.password && <span>{errors.password}</span>}
      
      <button type="submit">Submit</button>
    </form>
  );
}
```

---

## Summary of Chapter 3

**Key Takeaways:**

1. **SyntheticEvents**: React's cross-browser event wrapper
2. **Event Naming**: camelCase (onClick, onChange, onSubmit)
3. **Handler Syntax**: Pass function reference, not call
4. **Event Object**: Access via parameter (e) in handler
5. **Controlled Components**: React state controls input value
6. **Uncontrolled Components**: Use refs, access DOM directly
7. **Form Validation**: Inline, onBlur, onSubmit strategies
8. **preventDefault()**: Stop default browser behavior
9. **stopPropagation()**: Stop event bubbling

**Common Patterns:**

```javascript
// ✅ Correct event handler
<button onClick={handleClick}>Click</button>

// ❌ Wrong - calls function immediately
<button onClick={handleClick()}>Click</button>

// ✅ Passing arguments
<button onClick={() => handleClick(id)}>Click</button>
<button onClick={handleClick(id)}>Click</button> // curried

// ✅ Controlled input
<input value={text} onChange={(e) => setText(e.target.value)} />

// ✅ Uncontrolled input
<input ref={inputRef} defaultValue="" />
```

**Best Practices:**

- Use controlled components for most forms
- Use uncontrolled components for file inputs and simple forms
- Validate on blur for better UX
- Clear errors as user types
- Use preventDefault() for forms
- Use stopPropagation() carefully (usually not needed)
- Name event handlers with "handle" prefix
- Keep event handlers outside JSX for complex logic

**Practice Exercises:**

1. Build a search bar with debouncing
2. Create a multi-step form with validation
3. Build a todo app with keyboard shortcuts
4. Make a drag-and-drop interface
5. Create a form with real-time validation
6. Build a modal that closes on outside click
7. Create a custom dropdown component
8. Build an autocomplete search