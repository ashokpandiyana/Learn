# Chapter 16: Advanced Hooks & Patterns - In-Depth Explanation

## Introduction to Advanced Hooks

These hooks solve **specific problems** in complex React applications:
- **useDebugValue** - Debugging custom hooks
- **useTransition** - Non-blocking state updates (React 18)
- **useDeferredValue** - Defer expensive updates (React 18)
- **useId** - Unique IDs for accessibility
- **useImperativeHandle** - Customize ref behavior
- **useLayoutEffect** - Synchronous DOM updates
- **Portal** - Render outside DOM hierarchy
- **Suspense** - Declarative loading states

---

## 16.1 useDebugValue

### What is useDebugValue?

**useDebugValue** displays custom labels in React DevTools for custom hooks.

**Why?**
- Makes debugging easier
- Shows meaningful values in DevTools
- Only runs in development mode
- No performance impact in production

### Basic Usage

```javascript
function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true);
  
  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  
  // Shows "Online" or "Offline" in DevTools
  useDebugValue(isOnline ? 'Online' : 'Offline');
  
  return isOnline;
}

// In DevTools: useOnlineStatus: "Online"
```

### With Formatting Function

```javascript
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(data => {
        setData(data);
        setLoading(false);
      });
  }, [url]);
  
  // Expensive formatting only happens if DevTools is open
  useDebugValue(data, (data) => {
    // This only runs when DevTools inspects the hook
    return data ? `Loaded ${data.length} items` : 'No data';
  });
  
  return { data, loading };
}

// In DevTools: useFetch: "Loaded 10 items"
```

### Complex Example

```javascript
function useUser(userId) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    fetchUser(userId)
      .then(setUser)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [userId]);
  
  // Custom debug label
  useDebugValue(
    { user, loading, error },
    ({ user, loading, error }) => {
      if (loading) return '⏳ Loading...';
      if (error) return `❌ Error: ${error.message}`;
      if (user) return `✅ ${user.name} (ID: ${user.id})`;
      return '⭕ No user';
    }
  );
  
  return { user, loading, error };
}

// In DevTools: useUser: "✅ John Doe (ID: 123)"
```

---

## 16.2 useTransition (React 18)

### What is useTransition?

**useTransition** marks state updates as **non-urgent** (transitions), allowing React to keep the UI responsive during expensive updates.

**Problem Without useTransition:**
```javascript
function SearchPage() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  
  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);
    
    // Expensive filtering (10,000 items)
    const filtered = items.filter(item => 
      item.name.toLowerCase().includes(value.toLowerCase())
    );
    setResults(filtered);
    
    // UI freezes while filtering! Input feels laggy!
  };
  
  return (
    <div>
      <input value={query} onChange={handleChange} />
      <Results items={results} />
    </div>
  );
}
```

**Solution With useTransition:**
```javascript
import { useState, useTransition } from 'react';

function SearchPage() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();
  
  const handleChange = (e) => {
    const value = e.target.value;
    
    // Urgent: Update input immediately (stays responsive)
    setQuery(value);
    
    // Non-urgent: Update results (can be interrupted)
    startTransition(() => {
      const filtered = items.filter(item => 
        item.name.toLowerCase().includes(value.toLowerCase())
      );
      setResults(filtered);
    });
  };
  
  return (
    <div>
      <input value={query} onChange={handleChange} />
      {isPending && <Spinner />}
      <Results items={results} />
    </div>
  );
}
```

**How it Works:**
```
Without useTransition:
User types "a" → Update input + filter 10,000 items → UI freezes → Show results
User types "b" → Update input + filter 10,000 items → UI freezes → Show results

With useTransition:
User types "a" → Update input (instant) → Filter in background → Show results
User types "b" → Update input (instant) → Cancel previous filter → Filter new → Show results

Result: Input stays responsive!
```

### Use Cases

```javascript
// 1. Filtering large lists
startTransition(() => {
  setFilteredItems(expensiveFilter(items, query));
});

// 2. Switching tabs with heavy content
const handleTabChange = (tab) => {
  setActiveTab(tab);  // Urgent: Update tab UI
  
  startTransition(() => {
    loadTabContent(tab);  // Non-urgent: Load content
  });
};

// 3. Sorting/processing data
startTransition(() => {
  setSortedData(expensiveSort(data, sortBy));
});
```

### isPending State

```javascript
function Component() {
  const [isPending, startTransition] = useTransition();
  
  const handleUpdate = () => {
    startTransition(() => {
      setExpensiveState(newValue);
    });
  };
  
  return (
    <div>
      <button onClick={handleUpdate} disabled={isPending}>
        {isPending ? 'Updating...' : 'Update'}
      </button>
      
      {isPending && <div className="loading-overlay">Processing...</div>}
    </div>
  );
}
```

---

## 16.3 useDeferredValue (React 18)

### What is useDeferredValue?

**useDeferredValue** returns a **deferred version** of a value that lags behind the original value, allowing React to prioritize more urgent updates.

**Similar to useTransition but for values instead of callbacks.**

**Basic Example:**
```javascript
import { useState, useDeferredValue } from 'react';

function SearchResults({ query }) {
  // Deferred value lags behind query
  const deferredQuery = useDeferredValue(query);
  
  // Expensive filtering uses deferred value
  const results = useMemo(() => {
    return items.filter(item => 
      item.name.includes(deferredQuery)
    );
  }, [deferredQuery]);
  
  return (
    <div>
      {/* Input uses original query (stays responsive) */}
      <input value={query} />
      
      {/* Results use deferred value (can lag) */}
      <ul>
        {results.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

**Complete Example:**
```javascript
function App() {
  const [query, setQuery] = useState('');
  
  return (
    <div>
      <input 
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      />
      
      <SearchResults query={query} />
    </div>
  );
}

function SearchResults({ query }) {
  const deferredQuery = useDeferredValue(query);
  
  // Show stale UI while updating
  const isStale = query !== deferredQuery;
  
  const results = useMemo(() => {
    console.log('Filtering with:', deferredQuery);
    return bigList.filter(item => 
      item.includes(deferredQuery)
    );
  }, [deferredQuery]);
  
  return (
    <div style={{ opacity: isStale ? 0.5 : 1 }}>
      {results.map(result => (
        <div key={result}>{result}</div>
      ))}
    </div>
  );
}
```

### useTransition vs useDeferredValue

```javascript
// useTransition - For callbacks
function Component() {
  const [isPending, startTransition] = useTransition();
  
  const handleClick = () => {
    startTransition(() => {
      setExpensiveState(newValue);
    });
  };
}

// useDeferredValue - For values
function Component({ value }) {
  const deferredValue = useDeferredValue(value);
  
  return <ExpensiveComponent value={deferredValue} />;
}

// When to use:
// useTransition: You control when update happens (callbacks, events)
// useDeferredValue: Value comes from props/parent
```

---

## 16.4 useId (React 18)

### What is useId?

**useId** generates **unique IDs** that are stable across server and client rendering.

**Why?**
- Accessibility (aria-describedby, aria-labelledby)
- Form field associations
- Server-client ID matching (SSR)

**Problem Without useId:**
```javascript
let id = 0;

function FormField({ label }) {
  const inputId = `input-${id++}`;
  
  return (
    <div>
      <label htmlFor={inputId}>{label}</label>
      <input id={inputId} />
    </div>
  );
}

// Problems:
// 1. IDs differ between server and client (hydration mismatch)
// 2. IDs change on re-render
// 3. Not safe for multiple instances
```

**Solution With useId:**
```javascript
function FormField({ label }) {
  const id = useId();
  
  return (
    <div>
      <label htmlFor={id}>{label}</label>
      <input id={id} />
    </div>
  );
}

// Benefits:
// - Unique ID per component instance
// - Stable across renders
// - Server-client match guaranteed
```

### Multiple IDs in Same Component

```javascript
function PasswordField() {
  const id = useId();
  
  return (
    <div>
      <label htmlFor={id}>Password</label>
      <input 
        id={id}
        type="password"
        aria-describedby={`${id}-hint`}
        aria-errormessage={`${id}-error`}
      />
      <div id={`${id}-hint`}>
        Must be at least 8 characters
      </div>
      <div id={`${id}-error`}>
        {/* Error message */}
      </div>
    </div>
  );
}

// All IDs are related but unique
```

### Real-World Example

```javascript
function Form() {
  return (
    <form>
      <FormField label="First Name" />
      <FormField label="Last Name" />
      <FormField label="Email" />
    </form>
  );
}

function FormField({ label }) {
  const id = useId();
  
  return (
    <div>
      <label htmlFor={id}>{label}</label>
      <input id={id} />
    </div>
  );
}

// Each field gets unique ID:
// :r1: (First Name)
// :r2: (Last Name)
// :r3: (Email)
```

---

## 16.5 useImperativeHandle

### What is useImperativeHandle?

**useImperativeHandle** customizes the instance value exposed when using `ref`, allowing parent components to call child methods.

**Rarely used** - only when you need imperative API.

**Problem:**
```javascript
// Parent wants to focus child input
function Parent() {
  const inputRef = useRef();
  
  return (
    <div>
      <CustomInput ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>
        Focus Input
      </button>
    </div>
  );
}

// But CustomInput doesn't expose DOM ref directly
```

**Solution:**
```javascript
import { forwardRef, useRef, useImperativeHandle } from 'react';

const CustomInput = forwardRef((props, ref) => {
  const inputRef = useRef();
  
  // Expose custom methods to parent
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    },
    scrollIntoView: () => {
      inputRef.current.scrollIntoView({ behavior: 'smooth' });
    },
    getValue: () => {
      return inputRef.current.value;
    },
    setValue: (value) => {
      inputRef.current.value = value;
    }
  }));
  
  return <input ref={inputRef} {...props} />;
});

// Parent component
function Parent() {
  const customInputRef = useRef();
  
  return (
    <div>
      <CustomInput ref={customInputRef} />
      
      <button onClick={() => customInputRef.current.focus()}>
        Focus
      </button>
      <button onClick={() => customInputRef.current.setValue('Hello')}>
        Set Value
      </button>
      <button onClick={() => alert(customInputRef.current.getValue())}>
        Get Value
      </button>
    </div>
  );
}
```

### Real-World Example: Video Player

```javascript
const VideoPlayer = forwardRef((props, ref) => {
  const videoRef = useRef();
  
  useImperativeHandle(ref, () => ({
    play: () => {
      videoRef.current.play();
    },
    pause: () => {
      videoRef.current.pause();
    },
    stop: () => {
      videoRef.current.pause();
      videoRef.current.currentTime = 0;
    },
    seek: (time) => {
      videoRef.current.currentTime = time;
    },
    getTime: () => {
      return videoRef.current.currentTime;
    },
    getDuration: () => {
      return videoRef.current.duration;
    }
  }));
  
  return <video ref={videoRef} src={props.src} />;
});

// Usage
function VideoControls() {
  const playerRef = useRef();
  
  return (
    <div>
      <VideoPlayer ref={playerRef} src="video.mp4" />
      
      <button onClick={() => playerRef.current.play()}>Play</button>
      <button onClick={() => playerRef.current.pause()}>Pause</button>
      <button onClick={() => playerRef.current.stop()}>Stop</button>
      <button onClick={() => playerRef.current.seek(30)}>Skip 30s</button>
    </div>
  );
}
```

### When to Use

```javascript
// ✅ Use when:
// - Building reusable component libraries
// - Need imperative API (focus, play, reset)
// - Wrapping third-party components
// - Modal dialogs, video players, canvas

// ❌ Avoid when:
// - Declarative approach works
// - Can use props/callbacks
// - Adds unnecessary complexity
```

---

## 16.6 useLayoutEffect

### What is useLayoutEffect?

**useLayoutEffect** is identical to useEffect but fires **synchronously after DOM mutations** and **before browser paint**.

**Execution Order:**
```
1. React updates DOM
2. useLayoutEffect runs (synchronous, blocks paint)
3. Browser paints screen
4. useEffect runs (asynchronous)
```

### When to Use

**Use useLayoutEffect when you need to:**
- Read layout from DOM
- Synchronously re-render based on DOM measurements
- Prevent visual flicker

```javascript
function Tooltip({ children, text }) {
  const [coords, setCoords] = useState({ x: 0, y: 0 });
  const targetRef = useRef();
  const tooltipRef = useRef();
  
  // ❌ useEffect - causes flicker
  useEffect(() => {
    const targetRect = targetRef.current.getBoundingClientRect();
    const tooltipRect = tooltipRef.current.getBoundingClientRect();
    
    setCoords({
      x: targetRect.left + (targetRect.width - tooltipRect.width) / 2,
      y: targetRect.top - tooltipRect.height - 10
    });
  }, [text]);
  // User sees tooltip jump from wrong position to correct position
  
  // ✅ useLayoutEffect - no flicker
  useLayoutEffect(() => {
    const targetRect = targetRef.current.getBoundingClientRect();
    const tooltipRect = tooltipRef.current.getBoundingClientRect();
    
    setCoords({
      x: targetRect.left + (targetRect.width - tooltipRect.width) / 2,
      y: targetRect.top - tooltipRect.height - 10
    });
  }, [text]);
  // Tooltip appears in correct position immediately
  
  return (
    <div>
      <div ref={targetRef}>{children}</div>
      <div 
        ref={tooltipRef}
        style={{ position: 'fixed', left: coords.x, top: coords.y }}
      >
        {text}
      </div>
    </div>
  );
}
```

### Measuring Elements

```javascript
function MeasuredComponent() {
  const [height, setHeight] = useState(0);
  const divRef = useRef();
  
  useLayoutEffect(() => {
    // Measure before paint
    const newHeight = divRef.current.offsetHeight;
    setHeight(newHeight);
  }, []);
  
  return (
    <div>
      <div ref={divRef}>Content to measure</div>
      <p>Height: {height}px</p>
    </div>
  );
}
```

### Performance Warning

```javascript
// ⚠️ useLayoutEffect blocks painting
useLayoutEffect(() => {
  // Heavy computation here will freeze UI
  expensiveCalculation();
});

// ✅ Use useEffect for most cases
useEffect(() => {
  // Doesn't block painting
  expensiveCalculation();
});

// Only use useLayoutEffect when you must measure/update DOM before paint
```

**When to Use:**

| Scenario | Use |
|----------|-----|
| Measure DOM elements | useLayoutEffect |
| Prevent visual flicker | useLayoutEffect |
| Synchronize animations | useLayoutEffect |
| Most other effects | useEffect |
| API calls | useEffect |
| Subscriptions | useEffect |

---

## 16.7 Portal

### What is Portal?

**Portal** renders children into a DOM node that exists **outside the parent component's DOM hierarchy**.

**Use Cases:**
- Modals/Dialogs
- Tooltips
- Popovers
- Notifications/Toasts
- Dropdown menus

**Basic Usage:**
```javascript
import ReactDOM from 'react-dom';

function Modal({ children, isOpen }) {
  if (!isOpen) return null;
  
  return ReactDOM.createPortal(
    <div className="modal-overlay">
      <div className="modal-content">
        {children}
      </div>
    </div>,
    document.body  // Render into body instead of parent
  );
}

// Usage
function App() {
  const [isOpen, setIsOpen] = useState(false);
  
  return (
    <div className="app-container">
      <button onClick={() => setIsOpen(true)}>Open Modal</button>
      
      <Modal isOpen={isOpen}>
        <h2>Modal Title</h2>
        <p>Modal content</p>
        <button onClick={() => setIsOpen(false)}>Close</button>
      </Modal>
    </div>
  );
}
```

**Why Portal?**
```
Without Portal:
<div class="app-container" style="overflow: hidden">
  <div class="modal">...</div>  ← Trapped inside container!
</div>

With Portal:
<div class="app-container" style="overflow: hidden">
  <!-- Modal not here -->
</div>
<div class="modal">...</div>  ← Outside container, at body level
```

### Complete Modal Example

```javascript
function Modal({ isOpen, onClose, children }) {
  const [portalRoot, setPortalRoot] = useState(null);
  
  useEffect(() => {
    // Create or get portal root
    let root = document.getElementById('modal-root');
    
    if (!root) {
      root = document.createElement('div');
      root.id = 'modal-root';
      document.body.appendChild(root);
    }
    
    setPortalRoot(root);
  }, []);
  
  useEffect(() => {
    // Lock body scroll when modal is open
    if (isOpen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = 'unset';
    }
    
    return () => {
      document.body.style.overflow = 'unset';
    };
  }, [isOpen]);
  
  // Close on Escape key
  useEffect(() => {
    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };
    
    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
      return () => document.removeEventListener('keydown', handleEscape);
    }
  }, [isOpen, onClose]);
  
  if (!isOpen || !portalRoot) return null;
  
  return ReactDOM.createPortal(
    <div 
      className="modal-overlay"
      onClick={onClose}
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0,0,0,0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000
      }}
    >
      <div 
        className="modal-content"
        onClick={(e) => e.stopPropagation()}
        style={{
          backgroundColor: 'white',
          padding: '20px',
          borderRadius: '8px',
          maxWidth: '500px',
          width: '90%'
        }}
      >
        {children}
      </div>
    </div>,
    portalRoot
  );
}
```

### Tooltip with Portal

```javascript
function Tooltip({ children, text }) {
  const [isVisible, setIsVisible] = useState(false);
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const targetRef = useRef();
  
  const handleMouseEnter = () => {
    const rect = targetRef.current.getBoundingClientRect();
    setPosition({
      x: rect.left + rect.width / 2,
      y: rect.top - 10
    });
    setIsVisible(true);
  };
  
  const handleMouseLeave = () => {
    setIsVisible(false);
  };
  
  return (
    <>
      <span 
        ref={targetRef}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
      >
        {children}
      </span>
      
      {isVisible && ReactDOM.createPortal(
        <div
          style={{
            position: 'fixed',
            left: position.x,
            top: position.y,
            transform: 'translate(-50%, -100%)',
            backgroundColor: 'black',
            color: 'white',
            padding: '5px 10px',
            borderRadius: '4px',
            fontSize: '12px',
            zIndex: 1000
          }}
        >
          {text}
        </div>,
        document.body
      )}
    </>
  );
}

// Usage
<Tooltip text="This is a tooltip">
  Hover over me
</Tooltip>
```

---

## 16.8 Suspense

### What is Suspense?

**Suspense** lets you declaratively specify loading states for components that are loading data or code.

**Current Uses (React 18):**
- Code splitting (React.lazy)
- Data fetching (with frameworks like Relay, or experimental)
- Server Components (Next.js 13+)

### With React.lazy (Code Splitting)

```javascript
import { lazy, Suspense } from 'react';

// Lazy load component
const Dashboard = lazy(() => import('./Dashboard'));
const Profile = lazy(() => import('./Profile'));
const Settings = lazy(() => import('./Settings'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading Dashboard...</div>}>
        <Dashboard />
      </Suspense>
      
      <Suspense fallback={<div>Loading Profile...</div>}>
        <Profile />
      </Suspense>
    </div>
  );
}
```

### Nested Suspense

```javascript
function App() {
  return (
    <Suspense fallback={<PageSkeleton />}>
      <Layout>
        <Suspense fallback={<SidebarSkeleton />}>
          <Sidebar />
        </Suspense>
        
        <Suspense fallback={<ContentSkeleton />}>
          <Content />
        </Suspense>
      </Layout>
    </Suspense>
  );
}

// Progressive loading:
// 1. Shows PageSkeleton
// 2. Layout loads
// 3. Shows SidebarSkeleton and ContentSkeleton
// 4. Each loads independently
```

### Error Boundaries with Suspense

```javascript
class ErrorBoundary extends React.Component {
  state = { hasError: false };
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}

function App() {
  return (
    <ErrorBoundary>
      <Suspense fallback={<Loading />}>
        <LazyComponent />
      </Suspense>
    </ErrorBoundary>
  );
}
```

### Suspense with Data Fetching (Experimental)

```javascript
// Note: This is experimental and requires special setup
// Works with frameworks like Relay or experimental React

function ProfilePage({ userId }) {
  return (
    <Suspense fallback={<ProfileSkeleton />}>
      <ProfileDetails userId={userId} />
      <Suspense fallback={<PostsSkeleton />}>
        <ProfilePosts userId={userId} />
      </Suspense>
    </Suspense>
  );
}

// ProfileDetails and ProfilePosts can suspend while loading
```

---

## 16.9 Advanced Patterns

### Combining Multiple Advanced Hooks

```javascript
function AdvancedForm() {
  const formId = useId();
  const [isPending, startTransition] = useTransition();
  const inputRef = useRef();
  
  // Imperative handle
  useImperativeHandle(ref, () => ({
    focusFirstField: () => inputRef.current.focus(),
    resetForm: () => {
      // Reset logic
    }
  }));
  
  // Layout effect for measurements
  useLayoutEffect(() => {
    // Measure form height
    const height = inputRef.current.offsetHeight;
    console.log('Form height:', height);
  }, []);
  
  const handleSubmit = (data) => {
    startTransition(() => {
      // Non-blocking submission
      submitForm(data);
    });
  };
  
  return (
    <form id={formId}>
      <input ref={inputRef} id={`${formId}-email`} />
      <button type="submit" disabled={isPending}>
        {isPending ? 'Submitting...' : 'Submit'}
      </button>
    </form>
  );
}
```

### Custom Hook with useDebugValue

```javascript
function useMediaQuery(query) {
  const [matches, setMatches] = useState(() => {
    return window.matchMedia(query).matches;
  });
  
  useEffect(() => {
    const mediaQuery = window.matchMedia(query);
    const handleChange = (e) => setMatches(e.matches);
    
    mediaQuery.addEventListener('change', handleChange);
    return () => mediaQuery.removeEventListener('change', handleChange);
  }, [query]);
  
  // Debug label
  useDebugValue(
    matches,
    (matches) => matches ? `Matches: ${query}` : `No match: ${query}`
  );
  
  return matches;
}

// In DevTools: useMediaQuery: "Matches: (min-width: 768px)"
```

---

## Summary of Chapter 16

**Advanced Hooks Overview:**

1. **useDebugValue** - Custom labels in DevTools
   - Only for custom hooks
   - Development-only feature
   - Improves debugging experience

2. **useTransition** - Non-blocking updates (React 18)
   - Mark updates as non-urgent
   - Keep UI responsive
   - Use for expensive state updates

3. **useDeferredValue** - Defer expensive updates (React 18)
   - Defer value updates
   - Keep UI responsive
   - Alternative to debouncing

4. **useId** - Unique IDs (React 18)
   - Server-client ID matching
   - Accessibility (aria-*)
   - Multiple instances safe

5. **useImperativeHandle** - Customize ref exposure
   - Expose custom methods to parent
   - Used with forwardRef
   - Rarely needed

6. **useLayoutEffect** - Synchronous effects
   - Before browser paint
   - Measure/update DOM synchronously
   - Prevents visual flicker

7. **Portal** - Render outside hierarchy
   - Modals, tooltips, popovers
   - Escape CSS overflow/z-index
   - Event bubbling still works

8. **Suspense** - Declarative loading
   - Code splitting
   - Data fetching (experimental)
   - Progressive loading

**When to Use Each:**

| Hook/Pattern | Use Case | Frequency |
|--------------|----------|-----------|
| useDebugValue | Custom hooks debugging | Rare |
| useTransition | Expensive updates | Common (React 18+) |
| useDeferredValue | Deferred rendering | Common (React 18+) |
| useId | Accessibility IDs | Common |
| useImperativeHandle | Imperative APIs | Rare |
| useLayoutEffect | DOM measurements | Rare |
| Portal | Modals, tooltips | Common |
| Suspense | Code splitting, loading | Common |

**React 18 Concurrent Features:**

```javascript
// Old way (React 17)
const [query, setQuery] = useState('');
const [results, setResults] = useState([]);

const handleChange = (value) => {
  setQuery(value);
  setResults(expensiveFilter(value));  // Blocks UI
};

// New way (React 18)
const [query, setQuery] = useState('');
const [results, setResults] = useState([]);
const [isPending, startTransition] = useTransition();

const handleChange = (value) => {
  setQuery(value);  // Urgent
  startTransition(() => {
    setResults(expensiveFilter(value));  // Non-urgent
  });
};
```

**Best Practices:**

```javascript
// ✅ Use useTransition for user-triggered updates
startTransition(() => setExpensiveState(value));

// ✅ Use useDeferredValue for props from parent
const deferredValue = useDeferredValue(propsValue);

// ✅ Use useLayoutEffect sparingly (blocks paint)
useLayoutEffect(() => {
  // Only DOM measurements
}, []);

// ✅ Use Portal for overlays
ReactDOM.createPortal(<Modal />, document.body);

// ✅ Use Suspense for code splitting
<Suspense fallback={<Loading />}>
  <LazyComponent />
</Suspense>
```

**Interview Focus:**
- Explain useTransition for responsive UI
- Show Portal for modals
- Demonstrate useLayoutEffect vs useEffect
- Discuss React 18 concurrent features
- Know when to use each advanced hook