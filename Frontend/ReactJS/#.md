# React JS Mastery Guide - Beginner to Advanced

## Part I: Fundamentals

### Chapter 1: React Basics
**1.1 Introduction to React**
- What is React and why use it?
- Virtual DOM concept
- React vs other frameworks
- **Important:** React is a library, not a framework

**1.2 Setting Up Development Environment**
- Node.js and npm/yarn
- Create React App (CRA)
- Vite (modern alternative)
- **Highlight:** Vite is faster for development than CRA

**1.3 JSX (JavaScript XML)**
- JSX syntax and rules
- Expressions in JSX
- JSX vs HTML differences
- Fragments (`<>` and `<React.Fragment>`)
- **Important:** JSX is syntactic sugar for `React.createElement()`
- **Note:** className not class, htmlFor not for

**1.4 Components**
- Functional Components
- Class Components (legacy but important for interviews)
- Component composition
- **Highlight:** Modern React heavily favors functional components

### Chapter 2: Props and State
**2.1 Props**
- Passing props
- Props destructuring
- Children prop
- Prop types and validation
- Default props
- **Important:** Props are read-only (immutable)
- **Note:** Props flow down (unidirectional data flow)

**2.2 State**
- useState Hook
- State immutability
- State updates are asynchronous
- Functional updates
- **Critical:** Never mutate state directly
- **Highlight:** Use callback form when new state depends on previous state

**2.3 Conditional Rendering**
- if/else statements
- Ternary operators
- Logical && operator
- Switch statements
- **Note:** Falsy values rendering gotcha (0, false, null, undefined)

**2.4 Lists and Keys**
- Rendering lists with map()
- Key prop importance
- Index as key (when and why to avoid)
- **Critical:** Keys must be stable, unique, and predictable
- **Important:** Keys help React identify which items changed

---

## Part II: Core Concepts

### Chapter 3: Event Handling
**3.1 Event Basics**
- Synthetic Events
- Event handlers
- Event binding
- Passing arguments to handlers
- **Important:** SyntheticEvent is cross-browser compatible
- **Note:** Events are camelCase in React (onClick not onclick)

**3.2 Form Handling**
- Controlled components
- Uncontrolled components
- useRef for form access
- Form validation
- **Highlight:** Controlled components are the React way
- **Important:** Single source of truth principle

### Chapter 4: Component Lifecycle
**4.1 Class Component Lifecycle**
- Mounting: constructor, render, componentDidMount
- Updating: shouldComponentUpdate, render, componentDidUpdate
- Unmounting: componentWillUnmount
- Error boundaries: componentDidCatch
- **Interview Focus:** Still asked frequently
- **Note:** Deprecated methods: componentWillMount, componentWillReceiveProps

**4.2 Functional Component Lifecycle (Hooks)**
- useEffect for side effects
- Dependency array
- Cleanup functions
- **Critical:** Empty array [] runs once, no array runs every render
- **Important:** Always specify dependencies correctly

### Chapter 5: Hooks Deep Dive
**5.1 useState**
- Basic usage
- Lazy initialization
- Functional updates
- Multiple state variables vs object state
- **Highlight:** State updates are batched in React 18+

**5.2 useEffect**
- Side effects concept
- Effect dependencies
- Cleanup mechanism
- Common pitfalls
- **Critical:** Missing dependencies cause stale closures
- **Important:** Each effect should do one thing

**5.3 useContext**
- Context API
- Creating and providing context
- Consuming context with useContext
- **Note:** Avoid prop drilling with context
- **Caution:** Context changes re-render all consumers

**5.4 useReducer**
- Reducer pattern
- When to use over useState
- Complex state logic
- useReducer vs Redux
- **Highlight:** Great for complex state with multiple sub-values
- **Important:** Reducer must be pure function

**5.5 useCallback**
- Memoizing callbacks
- Preventing unnecessary re-renders
- Dependency array
- **Interview Question:** Difference from useMemo
- **Important:** Returns memoized callback, not result

**5.6 useMemo**
- Memoizing expensive computations
- Performance optimization
- When to use vs when not to
- **Critical:** Don't over-optimize prematurely
- **Note:** Returns memoized value

**5.7 useRef**
- Persisting values across renders
- DOM references
- Mutable values without re-render
- **Important:** Changing ref doesn't trigger re-render
- **Use Case:** Previous value tracking, DOM manipulation

**5.8 useImperativeHandle**
- Customizing ref exposure
- Forward refs
- **Advanced:** Rarely used but important for libraries

**5.9 useLayoutEffect**
- Synchronous effects
- DOM measurements
- Difference from useEffect
- **Important:** Runs before browser paint
- **Caution:** Can hurt performance if misused

**5.10 useTransition (React 18)**
- Marking updates as non-urgent
- Concurrent rendering
- **Modern:** Part of React 18 features

**5.11 useDeferredValue (React 18)**
- Deferring expensive updates
- Debouncing without extra libraries

**5.12 useId (React 18)**
- Generating unique IDs for accessibility
- Server-client ID matching

### Chapter 6: Custom Hooks
**6.1 Creating Custom Hooks**
- Hook naming convention (use prefix)
- Extracting logic
- Reusability patterns
- **Important:** Custom hooks can call other hooks
- **Best Practice:** One responsibility per hook

**6.2 Common Custom Hook Patterns**
- useFetch
- useLocalStorage
- useDebounce
- useThrottle
- useWindowSize
- useClickOutside
- **Interview Favorite:** Be ready to implement these

---

## Part III: Advanced Patterns

### Chapter 7: Component Patterns
**7.1 Higher-Order Components (HOC)**
- HOC concept
- withRouter, withAuth examples
- Props proxy pattern
- **Legacy but Important:** Still in interview questions
- **Caution:** Can cause wrapper hell

**7.2 Render Props**
- Render prop pattern
- Children as function
- Component composition
- **Note:** Alternative to HOCs
- **Modern:** Hooks often replace this pattern

**7.3 Compound Components**
- Building component families
- Implicit state sharing
- Context in compound components
- **Example:** Tabs, Accordion, Menu

**7.4 Controlled vs Uncontrolled Components**
- Pattern differences
- When to use each
- **Production:** Controlled components for predictability

**7.5 Container/Presentational Pattern**
- Separation of concerns
- Smart vs Dumb components
- **Architecture:** Still relevant for large apps

**7.6 Component Composition**
- Composition over inheritance
- Props.children usage
- Slot pattern
- **React Philosophy:** Favor composition

### Chapter 8: State Management Patterns
**8.1 Component State**
- Local state management
- Lifting state up
- State colocation
- **Best Practice:** Keep state as local as possible

**8.2 Context API**
- Global state with Context
- Multiple contexts
- Context composition
- **Pitfall:** Performance issues with frequent updates
- **Solution:** Split contexts by update frequency

**8.3 Redux**
- Store, actions, reducers
- Middleware (Thunk, Saga)
- Redux Toolkit (modern approach)
- Redux DevTools
- **Interview Heavy:** Very common topic
- **Modern:** Redux Toolkit is the standard

**8.4 Zustand**
- Lightweight state management
- Simpler alternative to Redux
- **Modern:** Growing in popularity

**8.5 Recoil**
- Atom-based state management
- Facebook's approach
- **Advanced:** Great for complex apps

**8.6 Jotai**
- Primitive and flexible
- Atomic state management

**8.7 State Management Decision Tree**
- When to use what
- Complexity vs simplicity trade-offs
- **Production Critical:** Right tool for the right job

### Chapter 9: Performance Optimization
**9.1 React.memo**
- Memoizing functional components
- Custom comparison function
- When to use
- **Important:** Shallow comparison by default
- **Caution:** Not always beneficial

**9.2 PureComponent**
- Class component optimization
- Shallow prop/state comparison
- **Legacy:** Functional equivalent is React.memo

**9.3 Code Splitting**
- React.lazy
- Dynamic imports
- Suspense component
- Route-based splitting
- **Production Critical:** Reduces initial bundle size
- **Important:** Use with Suspense

**9.4 useMemo and useCallback Deep Dive**
- When optimization helps
- Profiling before optimizing
- Dependency arrays
- **Critical:** Measure, don't guess

**9.5 Virtualization**
- react-window
- react-virtualized
- Rendering large lists efficiently
- **Use Case:** 1000+ items in list

**9.6 Debouncing and Throttling**
- Input optimization
- Event handler optimization
- Custom hooks for both

**9.7 Bundle Size Optimization**
- Tree shaking
- Analyzing bundle
- Webpack Bundle Analyzer
- **Production:** Smaller bundles = faster loads

**9.8 Image Optimization**
- Lazy loading images
- Responsive images
- Next.js Image component
- **Web Vitals:** Impacts LCP

**9.9 React Profiler**
- Profiling component renders
- Identifying bottlenecks
- Chrome DevTools
- **Essential:** Must know for production debugging

---

## Part IV: Advanced Topics

### Chapter 10: TypeScript with React
**10.1 TypeScript Basics for React**
- Props typing
- State typing
- Event typing
- **Production Standard:** Most companies use TypeScript

**10.2 Advanced Types**
- Generics in components
- Utility types (Partial, Pick, Omit)
- Union and intersection types
- **Interview Common:** Type manipulation questions

**10.3 Hooks with TypeScript**
- Typing useState
- Typing useRef
- Typing useContext
- Custom hooks typing
- **Important:** Generic type inference

### Chapter 11: React Router
**11.1 Router Basics**
- BrowserRouter vs HashRouter
- Route, Routes, Link
- Navigation
- **Standard:** React Router v6 syntax

**11.2 Advanced Routing**
- Nested routes
- Dynamic routes
- Protected routes
- Route parameters
- Query parameters
- **Production:** Auth-based routing is common

**11.3 Programmatic Navigation**
- useNavigate hook
- Navigate component
- History API

**11.4 Code Splitting with Routes**
- Lazy loading routes
- Route-based splitting
- **Best Practice:** Split by route

### Chapter 12: Forms and Validation
**12.1 Form Libraries**
- Formik
- React Hook Form (modern choice)
- Final Form
- **Production:** React Hook Form is most performant

**12.2 Validation**
- Yup schema validation
- Zod (TypeScript-first)
- Custom validation
- **Important:** Client + server validation

**12.3 Complex Forms**
- Multi-step forms
- Dynamic fields
- Field arrays
- **Interview Favorite:** Dynamic form questions

### Chapter 13: API Integration
**13.1 Data Fetching Methods**
- Fetch API
- Axios
- useEffect for API calls
- **Important:** Handle loading, error, success states

**13.2 Data Fetching Libraries**
- React Query (TanStack Query)
- SWR
- RTK Query
- **Modern Standard:** React Query is industry favorite
- **Features:** Caching, refetching, optimistic updates

**13.3 Error Handling**
- Error boundaries
- Try-catch in async
- Fallback UI
- **Production Critical:** Graceful degradation

**13.4 Loading States**
- Skeleton screens
- Spinners
- Progressive loading
- **UX Important:** Never show blank screens

**13.5 Optimistic Updates**
- Immediate UI updates
- Rollback on error
- **Advanced:** Great user experience

### Chapter 14: Testing
**14.1 Testing Library**
- React Testing Library
- Jest
- Testing user behavior, not implementation
- **Philosophy:** Test like a user
- **Important:** Query priorities

**14.2 Unit Testing**
- Testing components
- Testing hooks
- Testing utilities
- **Coverage:** Aim for critical paths

**14.3 Integration Testing**
- Testing component interactions
- Mock API calls
- MSW (Mock Service Worker)

**14.4 E2E Testing**
- Cypress
- Playwright
- Testing full user flows
- **Production:** Critical for confidence

**14.5 Test Patterns**
- AAA (Arrange, Act, Assert)
- Test IDs vs queries
- Accessibility in tests
- **Best Practice:** Accessible apps are testable apps

### Chapter 15: Server-Side Rendering
**15.1 Next.js Fundamentals**
- Pages and routing
- Server components
- Client components
- **Modern:** Next.js 13+ App Router

**15.2 Data Fetching in Next.js**
- getServerSideProps
- getStaticProps
- getStaticPaths
- **Important:** Choose right method for use case

**15.3 SSR vs SSG vs ISR**
- Server-Side Rendering
- Static Site Generation
- Incremental Static Regeneration
- **Decision:** Based on content update frequency

### Chapter 16: Advanced Hooks & Patterns
**16.1 useDebugValue**
- Custom hook debugging
- DevTools integration

**16.2 useTransition & useDeferredValue**
- Concurrent features
- Non-blocking updates
- **React 18:** New concurrent features

**16.3 Custom Hook Composition**
- Combining multiple hooks
- Hook dependency management
- **Advanced:** Building complex abstractions

**16.4 Portal**
- ReactDOM.createPortal
- Modals and tooltips
- **Use Case:** Breaking out of DOM hierarchy

**16.5 Suspense**
- React.Suspense
- Lazy loading
- Future: Data fetching
- **Modern:** Key to concurrent rendering

---

## Part V: Production-Grade Development

### Chapter 17: Architecture & Folder Structure
**17.1 Project Structure**
- Feature-based structure
- Atomic design
- Module boundaries
- **Scale:** Structure for growth

**17.2 Code Organization**
- Component organization
- Hook organization
- Utility organization
- **Maintainability:** Consistent structure

**17.3 Naming Conventions**
- Component naming
- File naming
- Variable naming
- **Team Standard:** Consistency is key

### Chapter 18: Error Handling & Logging
**18.1 Error Boundaries**
- Class component boundaries
- Error boundary placement
- Fallback UIs
- **Production:** Catch rendering errors

**18.2 Error Logging**
- Sentry
- LogRocket
- Custom logging
- **Monitoring:** Know when things break

**18.3 User Feedback**
- Toast notifications
- Error messages
- Loading states
- **UX:** Always inform users

### Chapter 19: Security
**19.1 XSS Prevention**
- Sanitizing user input
- dangerouslySetInnerHTML risks
- **Critical:** Never trust user input

**19.2 Authentication**
- JWT tokens
- OAuth
- Session management
- **Security:** Secure storage of tokens

**19.3 Authorization**
- Role-based access
- Protected routes
- Conditional rendering
- **Production:** Defense in depth

**19.4 CORS**
- Cross-origin requests
- Proxy configuration
- **Backend Integration:** Common issue

### Chapter 20: Accessibility (a11y)
**20.1 Semantic HTML**
- Proper HTML elements
- ARIA labels
- **Foundation:** HTML first

**20.2 Keyboard Navigation**
- Tab order
- Focus management
- **Critical:** Must be keyboard accessible

**20.3 Screen Readers**
- ARIA roles
- Live regions
- Alt text
- **Inclusive:** Design for all users

**20.4 Testing Accessibility**
- axe DevTools
- Lighthouse
- Manual testing
- **Requirement:** Legal and moral obligation

### Chapter 21: Build & Deployment
**21.1 Build Optimization**
- Production builds
- Environment variables
- Tree shaking
- **Performance:** Optimize for production

**21.2 Deployment Strategies**
- Vercel
- Netlify
- AWS Amplify
- Docker containers
- **DevOps:** Choose based on needs

**21.3 CI/CD**
- GitHub Actions
- Jenkins
- Automated testing
- **Automation:** Reduce human error

**21.4 Monitoring**
- Performance monitoring
- Error tracking
- Analytics
- **Continuous:** Monitor production always

### Chapter 22: Styling Solutions
**22.1 CSS Modules**
- Scoped styles
- Composition
- **Classic:** Still very popular

**22.2 Styled Components**
- CSS-in-JS
- Dynamic styling
- Theming
- **Popular:** Component-level styles

**22.3 Emotion**
- Alternative CSS-in-JS
- Performance focused

**22.4 Tailwind CSS**
- Utility-first CSS
- Rapid development
- **Modern Trend:** Very popular now

**22.5 CSS Variables**
- Native CSS custom properties
- Theming
- **Modern:** Browser support is good

---

## Part VI: Interview-Specific Topics

### Chapter 23: Common Interview Questions
**23.1 Conceptual Questions**
- Virtual DOM explained
- Reconciliation algorithm
- Fiber architecture
- **Deep Dive:** Understand internals

**23.2 Hooks Rules**
- Why hooks rules exist
- Common violations
- ESLint plugin
- **Critical:** Must follow rules

**23.3 Performance Questions**
- Identifying bottlenecks
- Optimization strategies
- Measuring performance
- **Practical:** Be ready to optimize

**23.4 State Management**
- When to lift state
- Context vs Redux
- Local vs global state
- **Decision Making:** Show understanding

### Chapter 24: Coding Challenges
**24.1 Common Patterns**
- Todo app with CRUD
- Infinite scroll
- Autocomplete/search
- Data fetching with error handling
- **Practice:** Build these multiple times

**24.2 Hooks Implementation**
- Custom hooks from scratch
- useDebounce
- usePrevious
- useLocalStorage
- **Implementation:** Show mastery

**24.3 Component Challenges**
- Modal/Dialog
- Tabs component
- Accordion
- Carousel
- **Building Blocks:** Common UI patterns

### Chapter 25: System Design
**25.1 Component Architecture**
- Breaking down features
- Component hierarchy
- Data flow design
- **Thinking:** Plan before coding

**25.2 State Management Design**
- Where state lives
- How data flows
- Update patterns
- **Architecture:** Scale considerations

**25.3 Performance Considerations**
- Lazy loading strategy
- Caching strategy
- Bundle size management
- **Production:** Real-world constraints

---

## Appendix

### Essential Tools & Libraries
- React DevTools
- Redux DevTools
- ESLint
- Prettier
- Husky (git hooks)
- TypeScript
- Vite/Webpack
- Babel

### Learning Resources
- Official React Docs (beta.reactjs.org)
- React patterns
- GitHub repositories
- Tech blogs

### Best Practices Checklist
- ✅ Always use keys in lists
- ✅ Keep components small and focused
- ✅ Follow hooks rules
- ✅ Don't mutate state
- ✅ Use TypeScript
- ✅ Write tests
- ✅ Optimize bundle size
- ✅ Make apps accessible
- ✅ Handle errors gracefully
- ✅ Profile before optimizing

### Interview Preparation Strategy
1. Build projects using concepts
2. Explain concepts verbally
3. Practice coding challenges
4. Review common patterns
5. Understand trade-offs
6. Study system design
7. Mock interviews

---

## Quick Reference: React 18 Features
- Concurrent rendering
- Automatic batching
- Transitions
- Suspense improvements
- New hooks: useId, useTransition, useDeferredValue
- Streaming SSR
- **Modern:** Essential for 2024+ interviews