# Chapter 7: Component Patterns - In-Depth Explanation

## What are Component Patterns?

Component patterns are **proven solutions to common problems** in React component design. They help you write:
- **Reusable** components
- **Maintainable** code
- **Flexible** APIs
- **Scalable** applications

**Pattern Evolution:**
```
Class Components (2013-2018)
  ↓
HOCs + Render Props (2016-2018)
  ↓
Hooks + Composition (2019-present)
```

---

## 7.1 Higher-Order Components (HOC)

### What is a Higher-Order Component?

A **Higher-Order Component (HOC)** is a function that takes a component and returns a new component with additional props or behavior.

**Concept:**
```
Component A  ─┐
Component B  ─┤→ HOC (withFeature) → Enhanced Components
Component C  ─┘
```

**Pattern Structure:**
```javascript
function withFeature(Component) {
  return function EnhancedComponent(props) {
    // Add logic here
    const additionalProps = { /* ... */ };
    
    return <Component {...props} {...additionalProps} />;
  };
}
```

### Basic HOC Example

```javascript
// HOC: Adds loading state to any component
function withLoading(Component) {
  return function WithLoadingComponent({ isLoading, ...props }) {
    if (isLoading) {
      return <div>Loading...</div>;
    }
    
    return <Component {...props} />;
  };
}

// Original component
function UserList({ users }) {
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// Enhanced component
const UserListWithLoading = withLoading(UserList);

// Usage
function App() {
  const [users, setUsers] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  
  return (
    <UserListWithLoading 
      users={users} 
      isLoading={isLoading} 
    />
  );
}
```

### Common HOC Patterns

#### 1. withAuth - Authentication HOC

```javascript
function withAuth(Component) {
  return function AuthenticatedComponent(props) {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);
    
    useEffect(() => {
      // Check authentication
      fetch('/api/auth/me')
        .then(res => res.json())
        .then(data => {
          setUser(data);
          setLoading(false);
        })
        .catch(() => {
          setLoading(false);
        });
    }, []);
    
    if (loading) {
      return <div>Authenticating...</div>;
    }
    
    if (!user) {
      return <div>Please log in to access this page.</div>;
    }
    
    return <Component {...props} user={user} />;
  };
}

// Usage
function Dashboard({ user }) {
  return (
    <div>
      <h1>Welcome, {user.name}!</h1>
      <p>Dashboard content here...</p>
    </div>
  );
}

const AuthenticatedDashboard = withAuth(Dashboard);

function App() {
  return <AuthenticatedDashboard />;
}
```

#### 2. withLogger - Logging HOC

```javascript
function withLogger(Component) {
  return function LoggedComponent(props) {
    useEffect(() => {
      console.log(`Component ${Component.name} mounted with props:`, props);
      
      return () => {
        console.log(`Component ${Component.name} unmounting`);
      };
    }, [props]);
    
    return <Component {...props} />;
  };
}

// Usage
function MyComponent({ data }) {
  return <div>{data}</div>;
}

const LoggedComponent = withLogger(MyComponent);
```

#### 3. withData - Data Fetching HOC

```javascript
function withData(url) {
  return function(Component) {
    return function DataFetchingComponent(props) {
      const [data, setData] = useState(null);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);
      
      useEffect(() => {
        fetch(url)
          .then(res => res.json())
          .then(data => {
            setData(data);
            setLoading(false);
          })
          .catch(err => {
            setError(err);
            setLoading(false);
          });
      }, []);
      
      if (loading) return <div>Loading...</div>;
      if (error) return <div>Error: {error.message}</div>;
      
      return <Component {...props} data={data} />;
    };
  };
}

// Usage
function UserList({ data }) {
  return (
    <ul>
      {data.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

const UserListWithData = withData('/api/users')(UserList);
```

#### 4. withTheme - Theme HOC

```javascript
const ThemeContext = createContext();

function withTheme(Component) {
  return function ThemedComponent(props) {
    const theme = useContext(ThemeContext);
    return <Component {...props} theme={theme} />;
  };
}

// Usage
function Button({ theme, children }) {
  return (
    <button style={{ 
      backgroundColor: theme.primary,
      color: theme.text 
    }}>
      {children}
    </button>
  );
}

const ThemedButton = withTheme(Button);
```

### Composing Multiple HOCs

```javascript
// Multiple HOCs
const enhance = compose(
  withAuth,
  withLogger,
  withTheme,
  withData('/api/users')
);

const EnhancedComponent = enhance(MyComponent);

// Or using function composition
const EnhancedComponent = withAuth(
  withLogger(
    withTheme(
      withData('/api/users')(MyComponent)
    )
  )
);
```

### HOC Best Practices

```javascript
// ✅ Good: Pass through props
function withFeature(Component) {
  return function Enhanced(props) {
    return <Component {...props} additionalProp="value" />;
  };
}

// ✅ Good: Display name for debugging
function withFeature(Component) {
  const WithFeature = (props) => <Component {...props} />;
  WithFeature.displayName = `WithFeature(${Component.displayName || Component.name})`;
  return WithFeature;
}

// ✅ Good: Static methods
function withFeature(Component) {
  const Enhanced = (props) => <Component {...props} />;
  
  // Copy static methods
  Enhanced.someStaticMethod = Component.someStaticMethod;
  
  return Enhanced;
}

// ❌ Bad: Mutating component
function withFeature(Component) {
  Component.prototype.newMethod = () => {}; // Don't mutate!
  return Component;
}

// ❌ Bad: Using HOC inside render
function MyComponent() {
  const EnhancedComponent = withFeature(SomeComponent); // Don't do this!
  return <EnhancedComponent />;
}
```

### HOC Limitations

```javascript
// Problems with HOCs:

// 1. Wrapper Hell
const Enhanced = withA(withB(withC(withD(Component))));
// Results in deeply nested components

// 2. Name Collisions
const Enhanced = withUser(withData(Component));
// What if both add 'data' prop?

// 3. Static Composition
const Enhanced = withAuth(Component);
// Can't change HOC dynamically

// 4. Ref Forwarding Issues
const Enhanced = withFeature(Component);
// Refs don't automatically pass through
```

**Modern Alternative: Custom Hooks**
```javascript
// Instead of HOC:
const WithAuth = withAuth(Component);

// Use custom hook:
function Component() {
  const { user, loading } = useAuth();
  
  if (loading) return <div>Loading...</div>;
  if (!user) return <div>Please log in</div>;
  
  return <div>Content</div>;
}
```

---

## 7.2 Render Props

### What are Render Props?

A **render prop** is a function prop that a component uses to determine what to render. It's a technique for sharing code between components.

**Pattern Structure:**
```javascript
<DataProvider render={(data) => (
  <Component data={data} />
)} />
```

### Basic Example

```javascript
// Component with render prop
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  useEffect(() => {
    const handleMouseMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };
    
    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);
  
  return render(position);
}

// Usage
function App() {
  return (
    <MouseTracker 
      render={({ x, y }) => (
        <div>
          <h1>Mouse position:</h1>
          <p>X: {x}, Y: {y}</p>
        </div>
      )}
    />
  );
}
```

### Children as Function Pattern

```javascript
// Using children prop instead of 'render'
function DataProvider({ children }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetch('/api/data')
      .then(res => res.json())
      .then(data => {
        setData(data);
        setLoading(false);
      });
  }, []);
  
  return children({ data, loading });
}

// Usage
function App() {
  return (
    <DataProvider>
      {({ data, loading }) => (
        loading ? (
          <div>Loading...</div>
        ) : (
          <div>Data: {JSON.stringify(data)}</div>
        )
      )}
    </DataProvider>
  );
}
```

### Real-World Examples

#### 1. Toggle Component

```javascript
function Toggle({ children }) {
  const [on, setOn] = useState(false);
  
  const toggle = () => setOn(!on);
  const setTrue = () => setOn(true);
  const setFalse = () => setOn(false);
  
  return children({
    on,
    toggle,
    setTrue,
    setFalse
  });
}

// Usage
function App() {
  return (
    <Toggle>
      {({ on, toggle }) => (
        <div>
          <button onClick={toggle}>
            {on ? 'ON' : 'OFF'}
          </button>
          {on && <div>Content is visible!</div>}
        </div>
      )}
    </Toggle>
  );
}
```

#### 2. Window Size Component

```javascript
function WindowSize({ children }) {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  
  useEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };
    
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  return children(size);
}

// Usage
function App() {
  return (
    <WindowSize>
      {({ width, height }) => (
        <div>
          <p>Window size: {width} x {height}</p>
          {width < 768 ? (
            <MobileLayout />
          ) : (
            <DesktopLayout />
          )}
        </div>
      )}
    </WindowSize>
  );
}
```

#### 3. Media Query Component

```javascript
function Media({ query, children }) {
  const [matches, setMatches] = useState(
    window.matchMedia(query).matches
  );
  
  useEffect(() => {
    const mediaQuery = window.matchMedia(query);
    const handleChange = (e) => setMatches(e.matches);
    
    mediaQuery.addEventListener('change', handleChange);
    return () => mediaQuery.removeEventListener('change', handleChange);
  }, [query]);
  
  return children(matches);
}

// Usage
function App() {
  return (
    <div>
      <Media query="(max-width: 768px)">
        {(matches) => (
          matches ? <MobileMenu /> : <DesktopMenu />
        )}
      </Media>
    </div>
  );
}
```

### Render Props vs HOC

```javascript
// HOC
const EnhancedComponent = withMouse(Component);

// Render Props
<Mouse render={(mouse) => <Component mouse={mouse} />} />

// Comparison:
// HOC: Static composition, wrapper components
// Render Props: Dynamic composition, more flexible
```

### Render Props Limitations

```javascript
// Problem 1: Callback Hell
<Provider1>
  {data1 => (
    <Provider2>
      {data2 => (
        <Provider3>
          {data3 => (
            <Component data1={data1} data2={data2} data3={data3} />
          )}
        </Provider3>
      )}
    </Provider2>
  )}
</Provider1>

// Problem 2: Performance
// Inline functions create new instances each render
<Mouse render={position => <Cat position={position} />} />
// New function on every render
```

**Modern Alternative: Custom Hooks**
```javascript
// Instead of render props:
<Mouse render={position => <Component position={position} />} />

// Use custom hook:
function Component() {
  const position = useMousePosition();
  return <div>Position: {position.x}, {position.y}</div>;
}
```

---

## 7.3 Compound Components

### What are Compound Components?

**Compound components** work together to form a complete UI component. They share implicit state and communicate through React Context.

**Think of it like HTML elements:**
```html
<select>
  <option>Option 1</option>
  <option>Option 2</option>
</select>
```

### Basic Structure

```javascript
const TabsContext = createContext();

function Tabs({ children, defaultTab = 0 }) {
  const [activeTab, setActiveTab] = useState(defaultTab);
  
  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  );
}

function TabList({ children }) {
  return <div className="tab-list">{children}</div>;
}

function Tab({ index, children }) {
  const { activeTab, setActiveTab } = useContext(TabsContext);
  const isActive = activeTab === index;
  
  return (
    <button
      className={isActive ? 'tab active' : 'tab'}
      onClick={() => setActiveTab(index)}
    >
      {children}
    </button>
  );
}

function TabPanels({ children }) {
  return <div className="tab-panels">{children}</div>;
}

function TabPanel({ index, children }) {
  const { activeTab } = useContext(TabsContext);
  
  if (activeTab !== index) return null;
  
  return <div className="tab-panel">{children}</div>;
}

// Export as compound component
Tabs.List = TabList;
Tabs.Tab = Tab;
Tabs.Panels = TabPanels;
Tabs.Panel = TabPanel;

export default Tabs;
```

### Usage

```javascript
function App() {
  return (
    <Tabs defaultTab={0}>
      <Tabs.List>
        <Tabs.Tab index={0}>Tab 1</Tabs.Tab>
        <Tabs.Tab index={1}>Tab 2</Tabs.Tab>
        <Tabs.Tab index={2}>Tab 3</Tabs.Tab>
      </Tabs.List>
      
      <Tabs.Panels>
        <Tabs.Panel index={0}>
          <h2>Content 1</h2>
          <p>This is the first tab</p>
        </Tabs.Panel>
        <Tabs.Panel index={1}>
          <h2>Content 2</h2>
          <p>This is the second tab</p>
        </Tabs.Panel>
        <Tabs.Panel index={2}>
          <h2>Content 3</h2>
          <p>This is the third tab</p>
        </Tabs.Panel>
      </Tabs.Panels>
    </Tabs>
  );
}
```

### More Examples

#### Accordion Component

```javascript
const AccordionContext = createContext();

function Accordion({ children, allowMultiple = false }) {
  const [openItems, setOpenItems] = useState([]);
  
  const toggleItem = (index) => {
    if (allowMultiple) {
      setOpenItems(prev => 
        prev.includes(index)
          ? prev.filter(i => i !== index)
          : [...prev, index]
      );
    } else {
      setOpenItems(prev => 
        prev.includes(index) ? [] : [index]
      );
    }
  };
  
  return (
    <AccordionContext.Provider value={{ openItems, toggleItem }}>
      <div className="accordion">{children}</div>
    </AccordionContext.Provider>
  );
}

function AccordionItem({ index, children }) {
  return <div className="accordion-item">{children}</div>;
}

function AccordionHeader({ index, children }) {
  const { openItems, toggleItem } = useContext(AccordionContext);
  const isOpen = openItems.includes(index);
  
  return (
    <button
      className="accordion-header"
      onClick={() => toggleItem(index)}
    >
      {children}
      <span>{isOpen ? '▲' : '▼'}</span>
    </button>
  );
}

function AccordionPanel({ index, children }) {
  const { openItems } = useContext(AccordionContext);
  
  if (!openItems.includes(index)) return null;
  
  return <div className="accordion-panel">{children}</div>;
}

Accordion.Item = AccordionItem;
Accordion.Header = AccordionHeader;
Accordion.Panel = AccordionPanel;

// Usage
function App() {
  return (
    <Accordion>
      <Accordion.Item index={0}>
        <Accordion.Header index={0}>Section 1</Accordion.Header>
        <Accordion.Panel index={0}>Content 1</Accordion.Panel>
      </Accordion.Item>
      
      <Accordion.Item index={1}>
        <Accordion.Header index={1}>Section 2</Accordion.Header>
        <Accordion.Panel index={1}>Content 2</Accordion.Panel>
      </Accordion.Item>
    </Accordion>
  );
}
```

#### Menu Component

```javascript
const MenuContext = createContext();

function Menu({ children }) {
  const [isOpen, setIsOpen] = useState(false);
  
  return (
    <MenuContext.Provider value={{ isOpen, setIsOpen }}>
      <div className="menu">{children}</div>
    </MenuContext.Provider>
  );
}

function MenuButton({ children }) {
  const { isOpen, setIsOpen } = useContext(MenuContext);
  
  return (
    <button onClick={() => setIsOpen(!isOpen)}>
      {children}
    </button>
  );
}

function MenuList({ children }) {
  const { isOpen } = useContext(MenuContext);
  
  if (!isOpen) return null;
  
  return <ul className="menu-list">{children}</ul>;
}

function MenuItem({ onClick, children }) {
  const { setIsOpen } = useContext(MenuContext);
  
  const handleClick = () => {
    onClick?.();
    setIsOpen(false);
  };
  
  return (
    <li className="menu-item" onClick={handleClick}>
      {children}
    </li>
  );
}

Menu.Button = MenuButton;
Menu.List = MenuList;
Menu.Item = MenuItem;

// Usage
function App() {
  return (
    <Menu>
      <Menu.Button>Options ▼</Menu.Button>
      <Menu.List>
        <Menu.Item onClick={() => console.log('Edit')}>Edit</Menu.Item>
        <Menu.Item onClick={() => console.log('Delete')}>Delete</Menu.Item>
        <Menu.Item onClick={() => console.log('Share')}>Share</Menu.Item>
      </Menu.List>
    </Menu>
  );
}
```

### Benefits of Compound Components

```javascript
// ✅ Flexible API - arrange components as needed
<Tabs>
  <Tabs.List>
    <Tabs.Tab>Tab 1</Tabs.Tab>
  </Tabs.List>
  <Tabs.Panels>
    <Tabs.Panel>Content 1</Tabs.Panel>
  </Tabs.Panels>
</Tabs>

// ✅ Implicit state sharing - no prop drilling
// Parent manages state, children access via context

// ✅ Single responsibility - each component does one thing
// Tabs.Tab only handles tab button
// Tabs.Panel only handles panel content

// ✅ Composable - add custom elements
<Tabs>
  <div className="custom-wrapper">
    <Tabs.List>
      <Tabs.Tab>Tab</Tabs.Tab>
    </Tabs.List>
  </div>
  <Tabs.Panels>
    <Tabs.Panel>Content</Tabs.Panel>
  </Tabs.Panels>
</Tabs>
```

---

## 7.4 Controlled vs Uncontrolled Components

### Controlled Components

**Controlled components** are form inputs whose value is controlled by React state.

```javascript
function ControlledInput() {
  const [value, setValue] = useState('');
  
  return (
    <input 
      value={value}  // React controls value
      onChange={(e) => setValue(e.target.value)}
    />
  );
}
```

**Complete Form Example:**
```javascript
function ControlledForm() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: ''
  });
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Submit:', formData);
  };
  
  return (
    <div onSubmit={handleSubmit}>
      <input 
        name="username"
        value={formData.username}
        onChange={handleChange}
      />
      <input 
        name="email"
        value={formData.email}
        onChange={handleChange}
      />
      <input 
        name="password"
        type="password"
        value={formData.password}
        onChange={handleChange}
      />
      <button type="submit">Submit</button>
    </div>
  );
}
```

### Uncontrolled Components

**Uncontrolled components** store their own state internally (like regular HTML).

```javascript
function UncontrolledInput() {
  const inputRef = useRef();
  
  const handleSubmit = () => {
    console.log('Value:', inputRef.current.value);
  };
  
  return (
    <div>
      <input ref={inputRef} defaultValue="Initial" />
      <button onClick={handleSubmit}>Submit</button>
    </div>
  );
}
```

**Complete Form Example:**
```javascript
function UncontrolledForm() {
  const usernameRef = useRef();
  const emailRef = useRef();
  const passwordRef = useRef();
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    const formData = {
      username: usernameRef.current.value,
      email: emailRef.current.value,
      password: passwordRef.current.value
    };
    
    console.log('Submit:', formData);
  };
  
  return (
    <div onSubmit={handleSubmit}>
      <input ref={usernameRef} defaultValue="" />
      <input ref={emailRef} defaultValue="" />
      <input ref={passwordRef} type="password" defaultValue="" />
      <button type="submit">Submit</button>
    </div>
  );
}
```

### Comparison

| Feature | Controlled | Uncontrolled |
|---------|-----------|--------------|
| **Value Source** | React state | DOM |
| **Access Value** | From state | From ref |
| **Initial Value** | `value` prop | `defaultValue` prop |
| **Validation** | Real-time | On submit |
| **Updates** | Via `setState` | Direct DOM |
| **Best For** | Most forms | Simple forms, file inputs |

### Hybrid Approach

```javascript
function HybridForm() {
  // Controlled for validation
  const [email, setEmail] = useState('');
  const [emailError, setEmailError] = useState('');
  
  // Uncontrolled for simple fields
  const nameRef = useRef();
  
  const validateEmail = (value) => {
    if (!value) {
      setEmailError('Email required');
    } else if (!/\S+@\S+\.\S+/.test(value)) {
      setEmailError('Email invalid');
    } else {
      setEmailError('');
    }
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    const data = {
      name: nameRef.current.value,
      email
    };
    
    console.log('Submit:', data);
  };
  
  return (
    <div onSubmit={handleSubmit}>
      {/* Uncontrolled - no validation needed */}
      <input ref={nameRef} placeholder="Name" />
      
      {/* Controlled - needs validation */}
      <input 
        value={email}
        onChange={(e) => {
          setEmail(e.target.value);
          validateEmail(e.target.value);
        }}
        placeholder="Email"
      />
      {emailError && <span>{emailError}</span>}
      
      <button type="submit">Submit</button>
    </div>
  );
}
```

---

## 7.5 Container/Presentational Pattern

### What is this Pattern?

Separate **logic** (container) from **UI** (presentational).

**Structure:**
```
Container Component (Smart)
  ↓ passes data and handlers
Presentational Component (Dumb)
```

### Example: User List

**Container Component (Logic):**
```javascript
function UserListContainer() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState('');
  
  useEffect(() => {
    fetch('/api/users')
      .then(res => res.json())
      .then(data => {
        setUsers(data);
        setLoading(false);
      });
  }, []);
  
  const filteredUsers = users.filter(user =>
    user.name.toLowerCase().includes(filter.toLowerCase())
  );
  
  const handleDelete = (id) => {
    setUsers(users.filter(u => u.id !== id));
  };
  
  return (
    <UserListPresentation 
      users={filteredUsers}
      loading={loading}
      filter={filter}
      onFilterChange={setFilter}
      onDelete={handleDelete}
    />
  );
}
```

**Presentational Component (UI):**
```javascript
function UserListPresentation({ 
  users, 
  loading, 
  filter, 
  onFilterChange, 
  onDelete 
}) {
  if (loading) {
    return <div>Loading...</div>;
  }
  
  return (
    <div>
      <input 
        value={filter}
        onChange={(e) => onFilterChange(e.target.value)}
        placeholder="Filter users..."
      />
      
      <ul>
        {users.map(user => (
          <li key={user.id}>
            {user.name}
            <button onClick={() => onDelete(user.id)}>
              Delete
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### More Examples

#### Todo List

**Container:**
```javascript
function TodoListContainer() {
  const [todos, setTodos] = useState([]);
  const [input, setInput] = useState('');
  
  const addTodo = () => {
    if (input.trim()) {
      setTodos([...todos, {
        id: Date.now(),
        text: input,
        completed: false
      }]);
      setInput('');
    }
  };
  
  const toggleTodo = (id) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };
  
  const deleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };
  
  return (
    <TodoListPresentation 
      todos={todos}
      input={input}
      onInputChange={setInput}
      onAdd={addTodo}
      onToggle={toggleTodo}
      onDelete={deleteTodo}
    />
  );
}
```

**Presentational:**
```javascript
function TodoListPresentation({ 
  todos, 
  input, 
  onInputChange, 
  onAdd, 
  onToggle, 
  onDelete 
}) {
  return (
    <div>
      <div>
        <input 
          value={input}
          onChange={(e) => onInputChange(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && onAdd()}
        />
        <button onClick={onAdd}>Add</button>
      </div>
      
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input 
              type="checkbox"
              checked={todo.completed}
              onChange={() => onToggle(todo.id)}
            />
            <span style={{ 
              textDecoration: todo.completed ? 'line-through' : 'none' 
            }}>
              {todo.text}
            </span>
            <button onClick={() => onDelete(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### Benefits

```javascript
// ✅ Reusability - same presentational component, different containers
<UserListPresentation users={activeUsers} />
<UserListPresentation users={inactiveUsers} />

// ✅ Testability - test logic and UI separately
// Test container: logic, state, effects
// Test presentational: rendering, props

// ✅ Maintainability - changes in logic don't affect UI
// Update API endpoint in container
// Presentational component unchanged

// ✅ Collaboration - designers work on presentational, devs on container
```

### Modern Alternative: Hooks

```javascript
// Instead of container/presentational:
function UserList() {
  const { users, loading, filter, setFilter, deleteUser } = useUsers();
  
  if (loading) return <div>Loading...</div>;
  
  return (
    <div>
      <input value={filter} onChange={(e) => setFilter(e.target.value)} />
      <ul>
        {users.map(user => (
          <li key={user.id}>
            {user.name}
            <button onClick={() => deleteUser(user.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}

// Logic in custom hook
function useUsers() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState('');
  
  useEffect(() => {
    fetch('/api/users')
      .then(res => res.json())
      .then(data => {
        setUsers(data);
        setLoading(false);
      });
  }, []);
  
  const filteredUsers = users.filter(user =>
    user.name.toLowerCase().includes(filter.toLowerCase())
  );
  
  const deleteUser = (id) => {
    setUsers(users.filter(u => u.id !== id));
  };
  
  return { users: filteredUsers, loading, filter, setFilter, deleteUser };
}
```

---

## 7.6 Component Composition

### What is Component Composition?

Building complex UIs by **combining simple components** rather than inheritance.

**React Philosophy:** "Composition over Inheritance"

### Basic Composition

```javascript
// Simple components
function Header() {
  return <header>Header</header>;
}

function Sidebar() {
  return <aside>Sidebar</aside>;
}

function Content() {
  return <main>Content</main>;
}

function Footer() {
  return <footer>Footer</footer>;
}

// Composed layout
function Layout() {
  return (
    <div className="layout">
      <Header />
      <div className="body">
        <Sidebar />
        <Content />
      </div>
      <Footer />
    </div>
  );
}
```

### Composition with Children

```javascript
function Card({ children }) {
  return (
    <div className="card">
      {children}
    </div>
  );
}

function CardHeader({ children }) {
  return <div className="card-header">{children}</div>;
}

function CardBody({ children }) {
  return <div className="card-body">{children}</div>;
}

function CardFooter({ children }) {
  return <div className="card-footer">{children}</div>;
}

// Usage - flexible composition
function App() {
  return (
    <Card>
      <CardHeader>
        <h2>Title</h2>
      </CardHeader>
      <CardBody>
        <p>Content goes here</p>
      </CardBody>
      <CardFooter>
        <button>Action</button>
      </CardFooter>
    </Card>
  );
}
```

### Slot Pattern

```javascript
function Layout({ header, sidebar, content, footer }) {
  return (
    <div className="layout">
      <div className="header">{header}</div>
      <div className="body">
        <div className="sidebar">{sidebar}</div>
        <div className="content">{content}</div>
      </div>
      <div className="footer">{footer}</div>
    </div>
  );
}

// Usage
function App() {
  return (
    <Layout
      header={<Header />}
      sidebar={<Sidebar />}
      content={<MainContent />}
      footer={<Footer />}
    />
  );
}
```

### Specialized Components

```javascript
// Generic Dialog
function Dialog({ title, children }) {
  return (
    <div className="dialog">
      <h1>{title}</h1>
      <div>{children}</div>
    </div>
  );
}

// Specialized WelcomeDialog
function WelcomeDialog() {
  return (
    <Dialog title="Welcome">
      <p>Thank you for visiting!</p>
    </Dialog>
  );
}

// Specialized ConfirmDialog
function ConfirmDialog({ message, onConfirm, onCancel }) {
  return (
    <Dialog title="Confirm">
      <p>{message}</p>
      <button onClick={onConfirm}>Yes</button>
      <button onClick={onCancel}>No</button>
    </Dialog>
  );
}
```

---

## Summary of Chapter 7

**Component Patterns Overview:**

1. **HOC (Higher-Order Components)**
   - Function that takes component, returns enhanced component
   - Good for: cross-cutting concerns, reusable logic
   - Modern alternative: Custom hooks

2. **Render Props**
   - Component with function prop that returns JSX
   - Good for: dynamic composition, sharing code
   - Modern alternative: Custom hooks

3. **Compound Components**
   - Components that work together, share implicit state
   - Good for: complex UI components (tabs, accordion, menu)
   - Still relevant in modern React

4. **Controlled vs Uncontrolled**
   - Controlled: React manages state
   - Uncontrolled: DOM manages state
   - Use controlled for most cases

5. **Container/Presentational**
   - Separate logic from UI
   - Container: state, effects, logic
   - Presentational: pure UI, props
   - Modern alternative: Custom hooks

6. **Component Composition**
   - Build complex UIs from simple components
   - Composition over inheritance
   - Still the core React principle

**When to Use What:**

| Pattern | Use When | Modern Alternative |
|---------|----------|-------------------|
| HOC | Adding same behavior to multiple components | Custom hooks |
| Render Props | Sharing stateful logic | Custom hooks |
| Compound Components | Building complex UI widgets | Still relevant |
| Controlled | Need validation, real-time updates | Still relevant |
| Container/Presentational | Separating logic from UI | Custom hooks |
| Composition | Always! Core React principle | Still relevant |

**Key Takeaways:**

- Modern React favors **hooks** over HOCs and render props
- **Compound components** are still excellent for complex UI
- **Composition** is fundamental to React
- **Controlled components** are preferred for forms
- Patterns evolve, but principles remain