# Chapter 25: System Design

## Overview

System design interviews test your ability to architect scalable, maintainable React applications. This chapter covers how to approach frontend system design, make architectural decisions, and design complex React applications.

---

## 25.1 Component Architecture

### Breaking Down Features

When designing a React application, start by breaking down the UI into components following the single responsibility principle.

#### Example: E-commerce Product Page

```
App
├── Header
│   ├── Logo
│   ├── SearchBar
│   ├── Navigation
│   └── UserMenu
│       ├── CartIcon
│       └── UserProfile
├── ProductPage
│   ├── ProductGallery
│   │   ├── MainImage
│   │   └── ThumbnailList
│   ├── ProductInfo
│   │   ├── ProductTitle
│   │   ├── PriceDisplay
│   │   ├── RatingStars
│   │   ├── ProductDescription
│   │   └── VariantSelector
│   ├── AddToCart
│   │   ├── QuantitySelector
│   │   └── AddToCartButton
│   └── ProductReviews
│       ├── ReviewSummary
│       ├── ReviewFilters
│       └── ReviewList
│           └── ReviewItem
└── Footer
    ├── Links
    ├── Newsletter
    └── SocialMedia
```

### Component Hierarchy Best Practices

```javascript
// ❌ Bad: Monolithic component
function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);
  const [reviews, setReviews] = useState([]);
  const [cart, setCart] = useState([]);
  const [selectedVariant, setSelectedVariant] = useState(null);
  const [quantity, setQuantity] = useState(1);
  // ... 200 more lines of logic
  
  return (
    <div>
      {/* 500 lines of JSX */}
    </div>
  );
}

// ✅ Good: Decomposed into smaller components
function ProductPage({ productId }) {
  const product = useProduct(productId);
  
  if (!product) return <ProductSkeleton />;
  
  return (
    <div className="product-page">
      <ProductGallery images={product.images} />
      <ProductInfo product={product} />
      <AddToCartSection product={product} />
      <ProductReviews productId={productId} />
    </div>
  );
}

function ProductGallery({ images }) {
  const [selectedImage, setSelectedImage] = useState(images[0]);
  
  return (
    <div className="gallery">
      <MainImage src={selectedImage} />
      <ThumbnailList 
        images={images} 
        onSelect={setSelectedImage}
        selected={selectedImage}
      />
    </div>
  );
}

function ProductInfo({ product }) {
  return (
    <div className="product-info">
      <h1>{product.name}</h1>
      <PriceDisplay price={product.price} discount={product.discount} />
      <RatingDisplay rating={product.rating} reviewCount={product.reviewCount} />
      <ProductDescription description={product.description} />
      <VariantSelector variants={product.variants} />
    </div>
  );
}
```

### Container vs Presentational Pattern

```javascript
// Container Component (Smart/Logic)
function ProductListContainer() {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filters, setFilters] = useState({
    category: 'all',
    priceRange: [0, 1000],
    sortBy: 'popular'
  });

  useEffect(() => {
    fetchProducts(filters).then(data => {
      setProducts(data);
      setLoading(false);
    });
  }, [filters]);

  const handleFilterChange = (newFilters) => {
    setFilters({ ...filters, ...newFilters });
  };

  if (loading) return <LoadingSpinner />;

  return (
    <ProductListView
      products={products}
      filters={filters}
      onFilterChange={handleFilterChange}
    />
  );
}

// Presentational Component (Dumb/UI)
function ProductListView({ products, filters, onFilterChange }) {
  return (
    <div className="product-list">
      <FilterPanel filters={filters} onChange={onFilterChange} />
      <div className="products-grid">
        {products.map(product => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>
    </div>
  );
}

function ProductCard({ product }) {
  return (
    <div className="product-card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p>${product.price}</p>
      <button>Add to Cart</button>
    </div>
  );
}
```

### Composition Patterns

```javascript
// Slot Pattern
function Dialog({ title, actions, children }) {
  return (
    <div className="dialog">
      <div className="dialog-header">
        {title}
      </div>
      <div className="dialog-body">
        {children}
      </div>
      <div className="dialog-footer">
        {actions}
      </div>
    </div>
  );
}

// Usage
<Dialog
  title={<h2>Confirm Action</h2>}
  actions={
    <>
      <button>Cancel</button>
      <button>Confirm</button>
    </>
  }
>
  <p>Are you sure you want to proceed?</p>
</Dialog>

// Compound Components
function Tabs({ children }) {
  const [activeTab, setActiveTab] = useState(0);
  
  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  );
}

Tabs.List = function TabList({ children }) {
  return <div className="tab-list">{children}</div>;
};

Tabs.Tab = function Tab({ index, children }) {
  const { activeTab, setActiveTab } = useContext(TabsContext);
  return (
    <button
      className={activeTab === index ? 'active' : ''}
      onClick={() => setActiveTab(index)}
    >
      {children}
    </button>
  );
};

Tabs.Panel = function TabPanel({ index, children }) {
  const { activeTab } = useContext(TabsContext);
  return activeTab === index ? <div>{children}</div> : null;
};

// Render Props
function DataFetcher({ url, render }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(data => {
        setData(data);
        setLoading(false);
      });
  }, [url]);

  return render({ data, loading });
}

// Usage
<DataFetcher
  url="/api/users"
  render={({ data, loading }) =>
    loading ? <Spinner /> : <UserList users={data} />
  }
/>
```

---

## 25.2 State Management Design

### State Placement Decision Tree

```
Where should state live?
├─ Used by single component?
│  └─ Local state (useState)
│
├─ Used by 2-3 nearby components?
│  └─ Lift state to common parent
│
├─ Used across distant components?
│  └─ Context API
│
├─ Complex state with actions?
│  └─ useReducer or Redux
│
└─ Server state (API data)?
   └─ React Query or SWR
```

### Example: Shopping Cart Architecture

```javascript
// 1. Global State with Context (Medium Complexity)
const CartContext = createContext();

export function CartProvider({ children }) {
  const [cart, setCart] = useState([]);

  const addToCart = (product, quantity = 1) => {
    setCart(prevCart => {
      const existingItem = prevCart.find(item => item.id === product.id);
      
      if (existingItem) {
        return prevCart.map(item =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + quantity }
            : item
        );
      }
      
      return [...prevCart, { ...product, quantity }];
    });
  };

  const removeFromCart = (productId) => {
    setCart(prevCart => prevCart.filter(item => item.id !== productId));
  };

  const updateQuantity = (productId, quantity) => {
    if (quantity <= 0) {
      removeFromCart(productId);
      return;
    }
    
    setCart(prevCart =>
      prevCart.map(item =>
        item.id === productId ? { ...item, quantity } : item
      )
    );
  };

  const clearCart = () => {
    setCart([]);
  };

  const getTotalPrice = () => {
    return cart.reduce((total, item) => total + item.price * item.quantity, 0);
  };

  const getTotalItems = () => {
    return cart.reduce((total, item) => total + item.quantity, 0);
  };

  return (
    <CartContext.Provider
      value={{
        cart,
        addToCart,
        removeFromCart,
        updateQuantity,
        clearCart,
        getTotalPrice,
        getTotalItems
      }}
    >
      {children}
    </CartContext.Provider>
  );
}

export function useCart() {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error('useCart must be used within CartProvider');
  }
  return context;
}

// 2. Redux (Complex Applications)
// actions/cartActions.js
export const ADD_TO_CART = 'cart/addToCart';
export const REMOVE_FROM_CART = 'cart/removeFromCart';
export const UPDATE_QUANTITY = 'cart/updateQuantity';
export const CLEAR_CART = 'cart/clearCart';

export const addToCart = (product, quantity) => ({
  type: ADD_TO_CART,
  payload: { product, quantity }
});

// reducers/cartReducer.js
const initialState = {
  items: [],
  totalPrice: 0,
  totalItems: 0
};

export function cartReducer(state = initialState, action) {
  switch (action.type) {
    case ADD_TO_CART: {
      const { product, quantity } = action.payload;
      const existingItem = state.items.find(item => item.id === product.id);
      
      let newItems;
      if (existingItem) {
        newItems = state.items.map(item =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + quantity }
            : item
        );
      } else {
        newItems = [...state.items, { ...product, quantity }];
      }
      
      return {
        ...state,
        items: newItems,
        totalPrice: calculateTotal(newItems),
        totalItems: calculateItemCount(newItems)
      };
    }
    
    case REMOVE_FROM_CART: {
      const newItems = state.items.filter(
        item => item.id !== action.payload
      );
      return {
        ...state,
        items: newItems,
        totalPrice: calculateTotal(newItems),
        totalItems: calculateItemCount(newItems)
      };
    }
    
    default:
      return state;
  }
}

// 3. Zustand (Modern Alternative)
import create from 'zustand';
import { persist } from 'zustand/middleware';

export const useCartStore = create(
  persist(
    (set, get) => ({
      items: [],
      
      addToCart: (product, quantity = 1) => {
        set((state) => {
          const existingItem = state.items.find(item => item.id === product.id);
          
          if (existingItem) {
            return {
              items: state.items.map(item =>
                item.id === product.id
                  ? { ...item, quantity: item.quantity + quantity }
                  : item
              )
            };
          }
          
          return { items: [...state.items, { ...product, quantity }] };
        });
      },
      
      removeFromCart: (productId) => {
        set((state) => ({
          items: state.items.filter(item => item.id !== productId)
        }));
      },
      
      updateQuantity: (productId, quantity) => {
        set((state) => ({
          items: state.items.map(item =>
            item.id === productId ? { ...item, quantity } : item
          )
        }));
      },
      
      clearCart: () => set({ items: [] }),
      
      getTotalPrice: () => {
        return get().items.reduce(
          (total, item) => total + item.price * item.quantity,
          0
        );
      },
      
      getTotalItems: () => {
        return get().items.reduce((total, item) => total + item.quantity, 0);
      }
    }),
    {
      name: 'shopping-cart',
      getStorage: () => localStorage
    }
  )
);
```

### Server State Management

```javascript
// Using React Query
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// Fetch products
export function useProducts(filters) {
  return useQuery({
    queryKey: ['products', filters],
    queryFn: () => fetchProducts(filters),
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
  });
}

// Add to cart (optimistic update)
export function useAddToCart() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (product) => addToCartAPI(product),
    
    // Optimistic update
    onMutate: async (newProduct) => {
      await queryClient.cancelQueries({ queryKey: ['cart'] });
      
      const previousCart = queryClient.getQueryData(['cart']);
      
      queryClient.setQueryData(['cart'], (old) => {
        return [...old, newProduct];
      });
      
      return { previousCart };
    },
    
    // Rollback on error
    onError: (err, newProduct, context) => {
      queryClient.setQueryData(['cart'], context.previousCart);
    },
    
    // Refetch on success
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['cart'] });
    }
  });
}

// Using SWR
import useSWR from 'swr';

const fetcher = url => fetch(url).then(res => res.json());

export function useProducts() {
  const { data, error, isLoading, mutate } = useSWR(
    '/api/products',
    fetcher,
    {
      revalidateOnFocus: false,
      revalidateOnReconnect: true,
      refreshInterval: 0
    }
  );
  
  return {
    products: data,
    isLoading,
    isError: error,
    refetch: mutate
  };
}
```

---

## 25.3 Performance Considerations

### Code Splitting Strategy

```javascript
// 1. Route-based splitting
import { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

// Lazy load routes
const Home = lazy(() => import('./pages/Home'));
const Products = lazy(() => import('./pages/Products'));
const ProductDetail = lazy(() => import('./pages/ProductDetail'));
const Cart = lazy(() => import('./pages/Cart'));
const Checkout = lazy(() => import('./pages/Checkout'));
const AdminDashboard = lazy(() => import('./pages/Admin/Dashboard'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<PageLoader />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/products" element={<Products />} />
          <Route path="/products/:id" element={<ProductDetail />} />
          <Route path="/cart" element={<Cart />} />
          <Route path="/checkout" element={<Checkout />} />
          <Route path="/admin/*" element={<AdminDashboard />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}

// 2. Component-based splitting
function ProductPage() {
  const [showReviews, setShowReviews] = useState(false);
  
  // Only load reviews component when needed
  const Reviews = lazy(() => import('./components/Reviews'));
  
  return (
    <div>
      <ProductInfo />
      <button onClick={() => setShowReviews(true)}>
        Show Reviews
      </button>
      {showReviews && (
        <Suspense fallback={<ReviewsSkeleton />}>
          <Reviews />
        </Suspense>
      )}
    </div>
  );
}

// 3. Prefetching
function Navigation() {
  const prefetchProducts = () => {
    const ProductsPage = import('./pages/Products');
  };
  
  return (
    <nav>
      <Link 
        to="/products"
        onMouseEnter={prefetchProducts}
        onTouchStart={prefetchProducts}
      >
        Products
      </Link>
    </nav>
  );
}
```

### Rendering Optimization

```javascript
// 1. Memoization Strategy
const ProductCard = memo(function ProductCard({ product, onAddToCart }) {
  console.log('ProductCard rendered:', product.id);
  
  return (
    <div className="product-card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p>${product.price}</p>
      <button onClick={() => onAddToCart(product)}>
        Add to Cart
      </button>
    </div>
  );
}, (prevProps, nextProps) => {
  // Custom comparison
  return (
    prevProps.product.id === nextProps.product.id &&
    prevProps.product.price === nextProps.product.price
  );
});

// 2. Expensive Calculations
function ProductList({ products, sortBy, filters }) {
  // Only recalculate when dependencies change
  const filteredAndSortedProducts = useMemo(() => {
    console.log('Filtering and sorting products...');
    
    let result = products;
    
    // Apply filters
    if (filters.category !== 'all') {
      result = result.filter(p => p.category === filters.category);
    }
    if (filters.priceRange) {
      result = result.filter(p =>
        p.price >= filters.priceRange[0] &&
        p.price <= filters.priceRange[1]
      );
    }
    
    // Apply sorting
    result = result.sort((a, b) => {
      switch (sortBy) {
        case 'price-asc':
          return a.price - b.price;
        case 'price-desc':
          return b.price - a.price;
        case 'name':
          return a.name.localeCompare(b.name);
        default:
          return 0;
      }
    });
    
    return result;
  }, [products, sortBy, filters]);

  return (
    <div className="product-grid">
      {filteredAndSortedProducts.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}

// 3. Callback Memoization
function ProductFilters({ onFilterChange }) {
  const [filters, setFilters] = useState({
    category: 'all',
    priceRange: [0, 1000]
  });

  // Memoize callback to prevent child re-renders
  const handleCategoryChange = useCallback((category) => {
    setFilters(prev => ({ ...prev, category }));
    onFilterChange({ ...filters, category });
  }, [filters, onFilterChange]);

  const handlePriceChange = useCallback((priceRange) => {
    setFilters(prev => ({ ...prev, priceRange }));
    onFilterChange({ ...filters, priceRange });
  }, [filters, onFilterChange]);

  return (
    <div className="filters">
      <CategoryFilter onChange={handleCategoryChange} />
      <PriceRangeFilter onChange={handlePriceChange} />
    </div>
  );
}
```

### List Virtualization

```javascript
import { FixedSizeList } from 'react-window';

function VirtualizedProductList({ products }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      <ProductCard product={products[index]} />
    </div>
  );

  return (
    <FixedSizeList
      height={800}
      itemCount={products.length}
      itemSize={200}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}

// For dynamic heights
import { VariableSizeList } from 'react-window';

function DynamicProductList({ products }) {
  const listRef = useRef();
  const rowHeights = useRef({});

  const getRowHeight = (index) => {
    return rowHeights.current[index] || 200;
  };

  const setRowHeight = (index, size) => {
    listRef.current.resetAfterIndex(0);
    rowHeights.current[index] = size;
  };

  const Row = ({ index, style }) => {
    const rowRef = useRef();

    useEffect(() => {
      if (rowRef.current) {
        setRowHeight(index, rowRef.current.clientHeight);
      }
    }, []);

    return (
      <div style={style}>
        <div ref={rowRef}>
          <ProductCard product={products[index]} />
        </div>
      </div>
    );
  };

  return (
    <VariableSizeList
      ref={listRef}
      height={800}
      itemCount={products.length}
      itemSize={getRowHeight}
      width="100%"
    >
      {Row}
    </VariableSizeList>
  );
}
```

### Image Optimization

```javascript
// 1. Lazy Loading Images
function LazyImage({ src, alt, placeholder }) {
  const [imageSrc, setImageSrc] = useState(placeholder);
  const [imageRef, setImageRef] = useState();

  useEffect(() => {
    let observer;
    
    if (imageRef && imageSrc === placeholder) {
      observer = new IntersectionObserver(
        entries => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              setImageSrc(src);
              observer.unobserve(imageRef);
            }
          });
        },
        { threshold: 0.01 }
      );
      
      observer.observe(imageRef);
    }
    
    return () => {
      if (observer && imageRef) {
        observer.unobserve(imageRef);
      }
    };
  }, [imageRef, imageSrc, placeholder, src]);

  return (
    <img
      ref={setImageRef}
      src={imageSrc}
      alt={alt}
      loading="lazy"
    />
  );
}

// 2. Progressive Image Loading
function ProgressiveImage({ src, placeholder }) {
  const [imgSrc, setImgSrc] = useState(placeholder);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const img = new Image();
    img.src = src;
    img.onload = () => {
      setImgSrc(src);
      setLoading(false);
    };
  }, [src]);

  return (
    <div className="progressive-image">
      <img
        src={imgSrc}
        alt=""
        style={{
          filter: loading ? 'blur(20px)' : 'none',
          transition: 'filter 0.3s'
        }}
      />
    </div>
  );
}

// 3. Responsive Images
function ResponsiveImage({ src, alt }) {
  return (
    <picture>
      <source
        media="(max-width: 768px)"
        srcSet={`${src}-mobile.webp`}
        type="image/webp"
      />
      <source
        media="(min-width: 769px)"
        srcSet={`${src}-desktop.webp`}
        type="image/webp"
      />
      <img
        src={`${src}.jpg`}
        alt={alt}
        loading="lazy"
      />
    </picture>
  );
}
```

---

## 25.4 API Design and Error Handling

### API Layer Architecture

```javascript
// api/client.js
class APIClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.defaultHeaders = {
      'Content-Type': 'application/json'
    };
  }

  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const config = {
      ...options,
      headers: {
        ...this.defaultHeaders,
        ...options.headers
      }
    };

    try {
      const response = await fetch(url, config);
      
      if (!response.ok) {
        const error = await response.json();
        throw new APIError(error.message, response.status, error);
      }
      
      return await response.json();
    } catch (error) {
      if (error instanceof APIError) {
        throw error;
      }
      throw new NetworkError('Network request failed', error);
    }
  }

  get(endpoint, options) {
    return this.request(endpoint, { ...options, method: 'GET' });
  }

  post(endpoint, data, options) {
    return this.request(endpoint, {
      ...options,
      method: 'POST',
      body: JSON.stringify(data)
    });
  }

  put(endpoint, data, options) {
    return this.request(endpoint, {
      ...options,
      method: 'PUT',
      body: JSON.stringify(data)
    });
  }

  delete(endpoint, options) {
    return this.request(endpoint, { ...options, method: 'DELETE' });
  }
}

class APIError extends Error {
  constructor(message, status, data) {
    super(message);
    this.name = 'APIError';
    this.status = status;
    this.data = data;
  }
}

class NetworkError extends Error {
  constructor(message, originalError) {
    super(message);
    this.name = 'NetworkError';
    this.originalError = originalError;
  }
}

export const apiClient = new APIClient('https://api.example.com');

// api/products.js
export const productAPI = {
  getAll: (params) => apiClient.get('/products', { params }),
  getById: (id) => apiClient.get(`/products/${id}`),
  create: (data) => apiClient.post('/products', data),
  update: (id, data) => apiClient.put(`/products/${id}`, data),
  delete: (id) => apiClient.delete(`/products/${id}`)
};
```

### Error Boundary Implementation

```javascript
// ErrorBoundary.jsx
class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null
    };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    this.setState({
      error,
      errorInfo
    });
    
    // Log to error reporting service
    logErrorToService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <ErrorFallback
          error={this.state.error}
          errorInfo={this.state.errorInfo}
          onReset={() => this.setState({ hasError: false })}
        />
      );
    }

    return this.props.children;
  }
}

function ErrorFallback({ error, errorInfo, onReset }) {
  return (
    <div className="error-boundary">
      <h2>Something went wrong</h2>
      <details>
        <summary>Error details</summary>
        <pre>{error && error.toString()}</pre>
        <pre>{errorInfo.componentStack}</pre>
      </details>
      <button onClick={onReset}>Try again</button>
    </div>
  );
}

// Usage with granular boundaries
function App() {
  return (
    <ErrorBoundary fallback={<AppCrashScreen />}>
      <Header />
      <ErrorBoundary fallback={<FeatureErrorScreen />}>
        <MainContent />
      </ErrorBoundary>
      <Footer />
    </ErrorBoundary>
  );
}
```

### Global Error Handling

```javascript
// hooks/useErrorHandler.js
function useErrorHandler() {
  const [error, setError] = useState(null);

  const handleError = useCallback((error) => {
    console.error('Error caught:', error);
    
    if (error instanceof APIError) {
      switch (error.status) {
        case 401:
          // Redirect to login
          window.location.href = '/login';
          break;
        case 403:
          toast.error('You don\'t have permission to perform this action');
          break;
        case 404:
          toast.error('Resource not found');
          break;
        case 500:
          toast.error('Server error. Please try again later');
          break;
        default:
          toast.error(error.message);
      }
    } else if (error instanceof NetworkError) {
      toast.error('Network error. Please check your connection');
    } else {
      toast.error('An unexpected error occurred');
    }
    
    setError(error);
    
    // Send to monitoring service
    if (window.Sentry) {
      window.Sentry.captureException(error);
    }
  }, []);

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  return { error, handleError, clearError };
}

// Usage in components
function ProductList() {
  const { handleError } = useErrorHandler();
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchProducts = async () => {
      try {
        const data = await productAPI.getAll();
        setProducts(data);
      } catch (error) {
        handleError(error);
      } finally {
        setLoading(false);
      }
    };

    fetchProducts();
  }, [handleError]);

  return (
    <div>
      {/* Render products */}
    </div>
  );
}
```

---

## System Design Interview Strategy

### 1. Clarify Requirements (5-10 minutes)

**Ask these questions:**
- What are the core features?
- Expected user base and scale?
- Performance requirements?
- Browser/device support?
- SEO requirements?
- Offline capabilities needed?
- Real-time features?
- Authentication needed?

### 2. High-Level Architecture (10-15 minutes)

Draw a diagram showing:
- Component hierarchy
- State management approach
- Data flow
- API interactions
- Route structure

### 3. Component Design (15-20 minutes)

- Break down into components
- Define props and state
- Identify reusable components
- Plan component composition

### 4. State Management (10-15 minutes)

- Identify state types (UI, server, global)
- Choose appropriate solutions
- Plan data flow
- Consider caching strategy

### 5. Performance Optimization (5-10 minutes)

- Code splitting strategy
- Memoization opportunities
- List virtualization
- Image optimization
- Caching strategy

### 6. Error Handling & Edge Cases (5 minutes)

- Loading states
- Error scenarios
- Empty states
- Network failures

This completes Chapter 25 on System Design!