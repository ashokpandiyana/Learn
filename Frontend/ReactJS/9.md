# Chapter 9: Performance Optimization - In-Depth Explanation

## Introduction to React Performance

**Performance optimization** ensures your app runs smoothly and responds quickly to user interactions.

**Performance Bottlenecks:**
1. **Unnecessary re-renders** - Components render when they don't need to
2. **Large bundle size** - Slow initial load
3. **Expensive calculations** - Blocking the main thread
4. **Memory leaks** - Accumulating unused resources
5. **Unoptimized images** - Slow loading assets

**Golden Rule:** "Premature optimization is the root of all evil" - Profile first, then optimize!

---

## 9.1 React.memo

### What is React.memo?

**React.memo** is a higher-order component that memoizes functional components. It prevents re-renders if props haven't changed.

**How it Works:**
```
Parent re-renders
  ↓
React.memo checks: Did props change?
  ↓ NO              ↓ YES
Skip render    Re-render component
```

### Basic Usage

```javascript
// Without React.memo
function ExpensiveComponent({ data }) {
  console.log('Rendering ExpensiveComponent');
  // Expensive rendering logic
  return <div>{data}</div>;
}

// Parent component
function Parent() {
  const [count, setCount] = useState(0);
  const data = "Hello";
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <ExpensiveComponent data={data} />
      {/* Re-renders every time count changes, even though data didn't change! */}
    </div>
  );
}
```

```javascript
// With React.memo
const ExpensiveComponent = React.memo(function ExpensiveComponent({ data }) {
  console.log('Rendering ExpensiveComponent');
  return <div>{data}</div>;
});

// Parent component
function Parent() {
  const [count, setCount] = useState(0);
  const data = "Hello";
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <ExpensiveComponent data={data} />
      {/* Only re-renders when data changes! */}
    </div>
  );
}
```

### Shallow Comparison

React.memo does **shallow comparison** by default:

```javascript
// Primitive props (shallow comparison works)
const Component = React.memo(({ count, name }) => {
  return <div>{count} - {name}</div>;
});

<Component count={5} name="John" />
// Re-renders only when count or name change ✅

// Object props (shallow comparison fails!)
function Parent() {
  const [count, setCount] = useState(0);
  
  // ❌ New object every render!
  const user = { name: 'John', age: 25 };
  
  return <Component user={user} />;
  // Component re-renders every time because user is a new object reference!
}

// ✅ Solution: useMemo
function Parent() {
  const [count, setCount] = useState(0);
  
  const user = useMemo(() => ({
    name: 'John',
    age: 25
  }), []); // Same object reference
  
  return <Component user={user} />;
}
```

### Custom Comparison Function

```javascript
const Component = React.memo(
  function Component({ user, settings }) {
    return <div>{user.name}</div>;
  },
  (prevProps, nextProps) => {
    // Return true if props are equal (skip render)
    // Return false if props are different (re-render)
    
    return (
      prevProps.user.id === nextProps.user.id &&
      prevProps.settings.theme === nextProps.settings.theme
    );
  }
);

// More complex comparison
const UserCard = React.memo(
  ({ user }) => <div>{user.name}</div>,
  (prev, next) => {
    // Only re-render if specific fields change
    return (
      prev.user.name === next.user.name &&
      prev.user.email === next.user.email &&
      prev.user.avatar === next.user.avatar
    );
    // Ignore changes to other user fields
  }
);
```

### When to Use React.memo

```javascript
// ✅ Use when:
// - Component is pure (same props = same output)
// - Component renders often with same props
// - Component is expensive to render
// - Props are stable (primitives or memoized objects)

// ❌ Don't use when:
// - Component rarely re-renders
// - Props change frequently
// - Component is cheap to render
// - Premature optimization (measure first!)
```

---

## 9.2 PureComponent

### What is PureComponent?

**PureComponent** is a class component that implements `shouldComponentUpdate` with shallow prop and state comparison.

```javascript
// Class component with automatic optimization
class MyComponent extends React.PureComponent {
  render() {
    console.log('Rendering');
    return <div>{this.props.name}</div>;
  }
}

// Equivalent to:
class MyComponent extends React.Component {
  shouldComponentUpdate(nextProps, nextState) {
    return (
      !shallowEqual(this.props, nextProps) ||
      !shallowEqual(this.state, nextState)
    );
  }
  
  render() {
    return <div>{this.props.name}</div>;
  }
}
```

**Functional Equivalent:**
```javascript
// PureComponent (class)
class UserCard extends React.PureComponent {
  render() {
    return <div>{this.props.user.name}</div>;
  }
}

// React.memo (functional - modern way)
const UserCard = React.memo(function UserCard({ user }) {
  return <div>{user.name}</div>;
});
```

---

## 9.3 Code Splitting

### What is Code Splitting?

**Code splitting** breaks your bundle into smaller chunks that are loaded on demand, reducing initial load time.

**Without Code Splitting:**
```
App loads → Downloads entire bundle (500KB) → User sees page
Time: 5 seconds
```

**With Code Splitting:**
```
App loads → Downloads critical code (100KB) → User sees page
              ↓
          User navigates → Downloads route chunk (50KB)
Time: 1 second initial, then on-demand
```

### React.lazy

```javascript
import React, { lazy, Suspense } from 'react';

// ❌ Regular import (included in main bundle)
import Dashboard from './Dashboard';

// ✅ Lazy import (separate chunk)
const Dashboard = lazy(() => import('./Dashboard'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <Dashboard />
      </Suspense>
    </div>
  );
}
```

### Route-Based Code Splitting

```javascript
import { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

// Lazy load route components
const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Profile = lazy(() => import('./pages/Profile'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/profile" element={<Profile />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

### Named Exports with Lazy

```javascript
// ❌ Won't work - lazy only works with default exports
const { Dashboard } = lazy(() => import('./components'));

// ✅ Solution 1: Re-export as default
// components/Dashboard/index.js
export { default } from './Dashboard';

// ✅ Solution 2: Create wrapper
const Dashboard = lazy(() => 
  import('./components').then(module => ({ default: module.Dashboard }))
);
```

### Error Boundaries with Code Splitting

```javascript
class ErrorBoundary extends React.Component {
  state = { hasError: false };
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  render() {
    if (this.state.hasError) {
      return <h1>Failed to load component</h1>;
    }
    return this.props.children;
  }
}

function App() {
  return (
    <ErrorBoundary>
      <Suspense fallback={<Loading />}>
        <LazyComponent />
      </Suspense>
    </ErrorBoundary>
  );
}
```

---

## 9.4 useMemo and useCallback Deep Dive

### useMemo - Memoize Values

**Problem:**
```javascript
function Component({ items, filter }) {
  // ❌ Expensive filtering runs on EVERY render
  const filteredItems = items.filter(item => 
    item.name.includes(filter)
  );
  
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      {/* Filtering happens even when only count changes! */}
      <List items={filteredItems} />
    </div>
  );
}
```

**Solution:**
```javascript
function Component({ items, filter }) {
  // ✅ Only recompute when items or filter change
  const filteredItems = useMemo(() => {
    console.log('Filtering items...');
    return items.filter(item => item.name.includes(filter));
  }, [items, filter]);
  
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      {/* Filtering doesn't happen when count changes */}
      <List items={filteredItems} />
    </div>
  );
}
```

**Complex Example:**
```javascript
function DataTable({ data, sortColumn, sortDirection }) {
  // Expensive operations
  const sortedAndFormattedData = useMemo(() => {
    console.log('Processing data...');
    
    // Sort
    const sorted = [...data].sort((a, b) => {
      const aVal = a[sortColumn];
      const bVal = b[sortColumn];
      
      if (sortDirection === 'asc') {
        return aVal > bVal ? 1 : -1;
      }
      return aVal < bVal ? 1 : -1;
    });
    
    // Format
    return sorted.map(row => ({
      ...row,
      formattedDate: new Date(row.date).toLocaleDateString(),
      formattedPrice: `$${row.price.toFixed(2)}`
    }));
  }, [data, sortColumn, sortDirection]);
  
  return (
    <table>
      {sortedAndFormattedData.map(row => (
        <tr key={row.id}>
          <td>{row.formattedDate}</td>
          <td>{row.formattedPrice}</td>
        </tr>
      ))}
    </table>
  );
}
```

### useCallback - Memoize Functions

**Problem:**
```javascript
function Parent() {
  const [count, setCount] = useState(0);
  
  // ❌ New function created on every render
  const handleClick = () => {
    console.log('Clicked');
  };
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <ExpensiveChild onClick={handleClick} />
      {/* Child re-renders even though onClick logic didn't change */}
    </div>
  );
}

const ExpensiveChild = React.memo(({ onClick }) => {
  console.log('Child rendered');
  return <button onClick={onClick}>Click me</button>;
});
```

**Solution:**
```javascript
function Parent() {
  const [count, setCount] = useState(0);
  
  // ✅ Same function reference across renders
  const handleClick = useCallback(() => {
    console.log('Clicked');
  }, []); // No dependencies = never changes
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <ExpensiveChild onClick={handleClick} />
      {/* Child doesn't re-render when count changes */}
    </div>
  );
}
```

**With Dependencies:**
```javascript
function SearchComponent({ onSearch }) {
  const [query, setQuery] = useState('');
  
  // Recreate function when query changes
  const handleSearch = useCallback(() => {
    onSearch(query);
  }, [query, onSearch]);
  
  return (
    <div>
      <input value={query} onChange={(e) => setQuery(e.target.value)} />
      <SearchButton onSearch={handleSearch} />
    </div>
  );
}
```

### When NOT to Optimize

```javascript
// ❌ Unnecessary - no child components
function Component() {
  const value = useMemo(() => props.count * 2, [props.count]);
  return <div>{value}</div>;
  // Just use: const value = props.count * 2;
}

// ❌ Unnecessary - cheap calculation
const doubled = useMemo(() => count * 2, [count]);
// Just use: const doubled = count * 2;

// ❌ Unnecessary - child not memoized
const handleClick = useCallback(() => {}, []);
return <Child onClick={handleClick} />;
// Child re-renders anyway if not wrapped in React.memo

// ✅ Use optimization when:
// - Expensive calculation
// - Child is memoized
// - Large lists
// - Measured performance issue
```

---

## 9.5 Virtualization

### What is Virtualization?

**Virtualization** renders only visible items in a long list, dramatically improving performance.

**Without Virtualization:**
```
Render 10,000 items → 10,000 DOM nodes → Slow!
```

**With Virtualization:**
```
Render only ~20 visible items → 20 DOM nodes → Fast!
```

### react-window

```javascript
import { FixedSizeList } from 'react-window';

function VirtualList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      Item {index}: {items[index].name}
    </div>
  );
  
  return (
    <FixedSizeList
      height={400}        // Container height
      itemCount={items.length}
      itemSize={50}       // Each item height
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}

// Usage
function App() {
  const items = Array.from({ length: 10000 }, (_, i) => ({
    id: i,
    name: `Item ${i}`
  }));
  
  return <VirtualList items={items} />;
}
```

**Variable Size List:**
```javascript
import { VariableSizeList } from 'react-window';

function VirtualList({ items }) {
  const getItemSize = (index) => {
    // Return different heights for different items
    return items[index].type === 'header' ? 80 : 50;
  };
  
  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index].content}
    </div>
  );
  
  return (
    <VariableSizeList
      height={400}
      itemCount={items.length}
      itemSize={getItemSize}
      width="100%"
    >
      {Row}
    </VariableSizeList>
  );
}
```

---

## 9.6 Debouncing and Throttling

### Debouncing

**Debouncing** delays execution until after a pause in events.

```javascript
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => clearTimeout(timer);
  }, [value, delay]);
  
  return debouncedValue;
}

// Usage: Search
function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);
  
  useEffect(() => {
    if (debouncedSearchTerm) {
      // API call only happens 500ms after user stops typing
      fetch(`/api/search?q=${debouncedSearchTerm}`)
        .then(res => res.json())
        .then(data => console.log(data));
    }
  }, [debouncedSearchTerm]);
  
  return (
    <input 
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
      placeholder="Search..."
    />
  );
}
```

### Throttling

**Throttling** limits execution to once per time period.

```javascript
function useThrottle(callback, delay) {
  const lastRun = useRef(Date.now());
  
  return useCallback((...args) => {
    const now = Date.now();
    
    if (now - lastRun.current >= delay) {
      callback(...args);
      lastRun.current = now;
    }
  }, [callback, delay]);
}

// Usage: Scroll
function ScrollComponent() {
  const [scrollY, setScrollY] = useState(0);
  
  const handleScroll = useThrottle(() => {
    setScrollY(window.scrollY);
  }, 100); // Update at most once per 100ms
  
  useEffect(() => {
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, [handleScroll]);
  
  return <div>Scroll position: {scrollY}</div>;
}
```

**Debounce vs Throttle:**
```
User types: A...B...C...D...E

Debounce (500ms):
A...B...C...D...E → Wait 500ms → Execute once with "ABCDE"

Throttle (500ms):
A...B → Execute with "AB" → C...D...E → Execute with "CDE"
```

---

## 9.7 Bundle Size Optimization

### Analyzing Bundle

```bash
# Install bundle analyzer
npm install --save-dev webpack-bundle-analyzer

# Create React App
npm run build
npx webpack-bundle-analyzer build/static/js/*.js

# Vite
npm run build
npx vite-bundle-visualizer
```

### Tree Shaking

Import only what you need:

```javascript
// ❌ Imports entire library
import _ from 'lodash';
const result = _.debounce(fn, 300);

// ✅ Import specific function
import debounce from 'lodash/debounce';
const result = debounce(fn, 300);

// ❌ Imports all icons
import * as Icons from 'react-icons/fa';
<Icons.FaHome />

// ✅ Import specific icon
import { FaHome } from 'react-icons/fa';
<FaHome />
```

### Dynamic Imports

```javascript
// Load library only when needed
function Component() {
  const [ChartComponent, setChartComponent] = useState(null);
  
  const loadChart = async () => {
    const { Chart } = await import('chart.js');
    setChartComponent(() => Chart);
  };
  
  return (
    <div>
      <button onClick={loadChart}>Load Chart</button>
      {ChartComponent && <ChartComponent />}
    </div>
  );
}
```

---

## 9.8 Image Optimization

### Lazy Loading Images

```javascript
function LazyImage({ src, alt }) {
  const [imageSrc, setImageSrc] = useState(null);
  const imgRef = useRef();
  
  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            setImageSrc(src);
            observer.disconnect();
          }
        });
      },
      { threshold: 0.1 }
    );
    
    if (imgRef.current) {
      observer.observe(imgRef.current);
    }
    
    return () => observer.disconnect();
  }, [src]);
  
  return (
    <img 
      ref={imgRef}
      src={imageSrc || 'placeholder.jpg'}
      alt={alt}
      loading="lazy" // Native lazy loading
    />
  );
}
```

### Responsive Images

```javascript
function ResponsiveImage({ src, alt }) {
  return (
    <picture>
      <source media="(max-width: 768px)" srcSet={`${src}-mobile.jpg`} />
      <source media="(max-width: 1024px)" srcSet={`${src}-tablet.jpg`} />
      <img src={`${src}-desktop.jpg`} alt={alt} />
    </picture>
  );
}

// Or with srcSet
function OptimizedImage({ src, alt }) {
  return (
    <img 
      src={`${src}-800w.jpg`}
      srcSet={`
        ${src}-400w.jpg 400w,
        ${src}-800w.jpg 800w,
        ${src}-1200w.jpg 1200w
      `}
      sizes="(max-width: 768px) 400px, (max-width: 1024px) 800px, 1200px"
      alt={alt}
      loading="lazy"
    />
  );
}
```

---

## 9.9 React Profiler

### Using React DevTools Profiler

```javascript
// 1. Open React DevTools
// 2. Go to Profiler tab
// 3. Click record button
// 4. Interact with your app
// 5. Stop recording
// 6. Analyze flame graph

// What to look for:
// - Components that render too often
// - Expensive render times
// - Unnecessary re-renders
```

### Profiler API

```javascript
import { Profiler } from 'react';

function onRenderCallback(
  id,         // Component id
  phase,      // "mount" or "update"
  actualDuration,  // Time spent rendering
  baseDuration,    // Estimated time without memoization
  startTime,       // When React began rendering
  commitTime,      // When React committed update
  interactions     // Set of interactions
) {
  console.log(`${id} (${phase}) took ${actualDuration}ms`);
}

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <Dashboard />
    </Profiler>
  );
}
```

---

## Summary of Chapter 9

**Performance Optimization Checklist:**

1. **React.memo** - Prevent unnecessary re-renders
2. **useMemo** - Memoize expensive calculations
3. **useCallback** - Memoize functions for child components
4. **Code Splitting** - Lazy load routes and components
5. **Virtualization** - Render only visible items in long lists
6. **Debouncing** - Delay execution (search, resize)
7. **Throttling** - Limit execution frequency (scroll)
8. **Bundle Optimization** - Tree shaking, dynamic imports
9. **Image Optimization** - Lazy loading, responsive images
10. **Profiling** - Measure before optimizing

**Golden Rules:**

1. **Profile First** - Use React DevTools Profiler
2. **Measure Impact** - Confirm optimization helps
3. **Start Simple** - Don't optimize prematurely
4. **Focus on UX** - Optimize what users feel
5. **Code Split Routes** - Easy wins

**Common Optimizations:**

```javascript
// 1. Memoize expensive child
const MemoizedChild = React.memo(ExpensiveChild);

// 2. Memoize expensive calculation
const result = useMemo(() => expensiveCalc(data), [data]);

// 3. Memoize callbacks
const handleClick = useCallback(() => {}, []);

// 4. Code split routes
const Dashboard = lazy(() => import('./Dashboard'));

// 5. Virtualize long lists
<FixedSizeList itemCount={10000} />
```

**Interview Focus:**
- Explain React.memo vs useMemo vs useCallback
- When to use each optimization
- How to identify performance issues
- Code splitting strategies