# Chapter 4: Component Lifecycle - In-Depth Explanation

## What is Component Lifecycle?

Every React component goes through **phases** from creation to removal:

```
1. MOUNTING    → Component is created and inserted into DOM
2. UPDATING    → Component re-renders due to state/props changes
3. UNMOUNTING  → Component is removed from DOM
4. ERROR       → Component encounters an error during rendering
```

**Visual Representation:**
```
Birth → Life → Death
  ↓      ↓      ↓
Mount → Update → Unmount
```

---

## 4.1 Class Component Lifecycle

### Overview of Lifecycle Phases

**Complete Lifecycle Diagram:**
```
┌─────────────────────────────────────────────────────┐
│                   MOUNTING PHASE                     │
├─────────────────────────────────────────────────────┤
│ 1. constructor()                                     │
│ 2. static getDerivedStateFromProps()                │
│ 3. render()                                         │
│ 4. componentDidMount()                              │
└─────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│                   UPDATING PHASE                     │
├─────────────────────────────────────────────────────┤
│ 1. static getDerivedStateFromProps()                │
│ 2. shouldComponentUpdate()                          │
│ 3. render()                                         │
│ 4. getSnapshotBeforeUpdate()                       │
│ 5. componentDidUpdate()                             │
└─────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│                 UNMOUNTING PHASE                     │
├─────────────────────────────────────────────────────┤
│ 1. componentWillUnmount()                           │
└─────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│                   ERROR HANDLING                     │
├─────────────────────────────────────────────────────┤
│ 1. static getDerivedStateFromError()                │
│ 2. componentDidCatch()                              │
└─────────────────────────────────────────────────────┘
```

### Mounting Phase

Components are **created and inserted into DOM**.

#### 1. constructor(props)

**First method called** when component is created.

**Purpose:**
- Initialize state
- Bind event handlers
- Don't call setState() here

**Example:**
```javascript
class Counter extends React.Component {
  constructor(props) {
    super(props);  // MUST call super(props) first!
    
    // Initialize state
    this.state = {
      count: 0,
      name: props.name || 'Guest'
    };
    
    // Bind methods (if not using arrow functions)
    this.handleClick = this.handleClick.bind(this);
    
    console.log('1. Constructor called');
  }
  
  handleClick() {
    this.setState({ count: this.state.count + 1 });
  }
  
  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.handleClick}>Increment</button>
      </div>
    );
  }
}
```

**Rules:**
```javascript
// ✅ Correct
constructor(props) {
  super(props);  // Must be first
  this.state = { count: 0 };
}

// ❌ Wrong - setState not allowed
constructor(props) {
  super(props);
  this.setState({ count: 0 });  // Don't do this!
}

// ❌ Wrong - forgot super()
constructor(props) {
  this.state = { count: 0 };  // Error: Must call super()
}

// ❌ Wrong - accessing this.props before super()
constructor(props) {
  console.log(this.props);  // undefined!
  super(props);
}
```

#### 2. static getDerivedStateFromProps(props, state)

**Rarely used** - derives state from props changes.

**Purpose:**
- Update state based on props changes
- Called before every render
- Static method (no access to `this`)

**Example:**
```javascript
class EmailInput extends React.Component {
  state = {
    email: '',
    isValid: false
  };
  
  static getDerivedStateFromProps(props, state) {
    // Update validation when props change
    if (props.required !== state.wasRequired) {
      return {
        isValid: props.required ? state.email.length > 0 : true,
        wasRequired: props.required
      };
    }
    return null;  // No state update needed
  }
  
  render() {
    return <input type="email" />;
  }
}
```

**When to Use:**
- Rare cases where state depends on props
- Most cases: use componentDidUpdate instead

**Anti-pattern:**
```javascript
// ❌ Don't use for copying props to state
static getDerivedStateFromProps(props, state) {
  return { value: props.value };  // Usually wrong!
}

// ✅ Better: Use props directly
render() {
  return <div>{this.props.value}</div>;
}
```

#### 3. render()

**Only required method** in class components.

**Purpose:**
- Return JSX to be rendered
- Must be pure (no side effects)
- Can return: JSX, arrays, fragments, strings, numbers, null

**Example:**
```javascript
class MyComponent extends React.Component {
  render() {
    console.log('3. Render called');
    
    // Can return JSX
    return <div>Hello</div>;
    
    // Can return array
    return [
      <div key="1">First</div>,
      <div key="2">Second</div>
    ];
    
    // Can return fragment
    return (
      <>
        <div>First</div>
        <div>Second</div>
      </>
    );
    
    // Can return null (render nothing)
    if (!this.props.show) return null;
    
    // Can return string/number
    return 'Hello';
  }
}
```

**Rules:**
```javascript
// ✅ Correct - Pure function
render() {
  const { name, age } = this.props;
  return <div>{name}, {age}</div>;
}

// ❌ Wrong - Side effects
render() {
  this.setState({ count: 1 });  // Infinite loop!
  fetch('/api/data');           // Don't do this!
  localStorage.setItem('key', 'value');  // Don't do this!
  return <div>Hello</div>;
}
```

#### 4. componentDidMount()

**Called immediately after component is mounted** (inserted into DOM).

**Purpose:**
- Initialize data from API
- Set up subscriptions
- Set up timers
- Direct DOM manipulation (if needed)
- Add event listeners

**Example:**
```javascript
class UserProfile extends React.Component {
  state = {
    user: null,
    loading: true,
    error: null
  };
  
  componentDidMount() {
    console.log('4. Component Did Mount');
    
    // Fetch data from API
    fetch(`/api/users/${this.props.userId}`)
      .then(res => res.json())
      .then(user => {
        this.setState({ user, loading: false });
      })
      .catch(error => {
        this.setState({ error, loading: false });
      });
    
    // Set up timer
    this.timerId = setInterval(() => {
      console.log('Tick');
    }, 1000);
    
    // Add event listener
    window.addEventListener('resize', this.handleResize);
    
    // Direct DOM manipulation (if needed)
    this.inputRef.focus();
  }
  
  componentWillUnmount() {
    // Clean up!
    clearInterval(this.timerId);
    window.removeEventListener('resize', this.handleResize);
  }
  
  handleResize = () => {
    console.log('Window resized');
  };
  
  render() {
    if (this.state.loading) return <div>Loading...</div>;
    if (this.state.error) return <div>Error: {this.state.error.message}</div>;
    return <div>{this.state.user.name}</div>;
  }
}
```

**Common Patterns:**
```javascript
componentDidMount() {
  // 1. API Calls
  this.fetchData();
  
  // 2. Subscriptions
  this.subscription = dataSource.subscribe(this.handleData);
  
  // 3. Timers
  this.interval = setInterval(this.tick, 1000);
  
  // 4. Third-party libraries
  this.chart = new Chart(this.canvasRef, options);
  
  // 5. Event listeners
  document.addEventListener('keydown', this.handleKeyPress);
}
```

### Updating Phase

Component **re-renders due to state or props changes**.

#### 1. shouldComponentUpdate(nextProps, nextState)

**Controls whether component should re-render**.

**Purpose:**
- Performance optimization
- Return `false` to skip rendering
- Default: always returns `true`

**Example:**
```javascript
class ExpensiveComponent extends React.Component {
  shouldComponentUpdate(nextProps, nextState) {
    // Only re-render if relevant data changed
    if (this.props.importantData !== nextProps.importantData) {
      return true;  // Re-render
    }
    if (this.state.count !== nextState.count) {
      return true;  // Re-render
    }
    return false;  // Skip render
  }
  
  render() {
    console.log('Rendering...');
    return <div>{this.props.importantData}</div>;
  }
}
```

**Common Pattern - Shallow Comparison:**
```javascript
shouldComponentUpdate(nextProps, nextState) {
  // Shallow compare all props and state
  return (
    !shallowEqual(this.props, nextProps) ||
    !shallowEqual(this.state, nextState)
  );
}

// Or use PureComponent (does this automatically)
class MyComponent extends React.PureComponent {
  // Automatic shallow comparison!
}
```

**Performance Example:**
```javascript
class ListItem extends React.Component {
  shouldComponentUpdate(nextProps) {
    // Only re-render if this item's data changed
    return this.props.item.id !== nextProps.item.id ||
           this.props.item.name !== nextProps.item.name;
  }
  
  render() {
    console.log(`Rendering item ${this.props.item.id}`);
    return <div>{this.props.item.name}</div>;
  }
}

// Usage:
class List extends React.Component {
  state = {
    items: [/* 1000 items */],
    unrelatedData: ''
  };
  
  render() {
    return (
      <div>
        {this.state.items.map(item => (
          <ListItem key={item.id} item={item} />
        ))}
      </div>
    );
  }
}

// When unrelatedData changes, ListItems won't re-render
// because their props didn't change!
```

**Important Notes:**
```javascript
// ⚠️ This method is complex and error-prone
// Modern alternative: React.memo() for functional components

// ⚠️ Returning false doesn't prevent child updates
// Children can still update if their state changes
```

#### 2. render()

Same as mounting phase - returns JSX.

#### 3. getSnapshotBeforeUpdate(prevProps, prevState)

**Called right before DOM changes are committed**.

**Purpose:**
- Capture information from DOM before update
- Return value passed to componentDidUpdate
- Rarely used

**Example:**
```javascript
class ChatThread extends React.Component {
  chatContainerRef = React.createRef();
  
  getSnapshotBeforeUpdate(prevProps, prevState) {
    // Capture scroll position before new messages are added
    if (prevProps.messages.length < this.props.messages.length) {
      const container = this.chatContainerRef.current;
      return container.scrollHeight - container.scrollTop;
    }
    return null;
  }
  
  componentDidUpdate(prevProps, prevState, snapshot) {
    // Restore scroll position after DOM update
    if (snapshot !== null) {
      const container = this.chatContainerRef.current;
      container.scrollTop = container.scrollHeight - snapshot;
    }
  }
  
  render() {
    return (
      <div ref={this.chatContainerRef}>
        {this.props.messages.map(msg => (
          <div key={msg.id}>{msg.text}</div>
        ))}
      </div>
    );
  }
}
```

**Use Cases:**
- Scroll position preservation
- DOM measurements before update
- Cursor position in text editors

#### 4. componentDidUpdate(prevProps, prevState, snapshot)

**Called immediately after update is committed to DOM**.

**Purpose:**
- Operate on DOM after update
- Make network requests based on prop changes
- Update state based on prop changes (with condition!)

**Example:**
```javascript
class UserProfile extends React.Component {
  state = {
    user: null
  };
  
  componentDidUpdate(prevProps, prevState, snapshot) {
    // Fetch new user if userId prop changed
    if (this.props.userId !== prevProps.userId) {
      this.fetchUser(this.props.userId);
    }
    
    // Compare state
    if (this.state.user !== prevState.user) {
      console.log('User changed:', this.state.user);
    }
    
    // Use snapshot from getSnapshotBeforeUpdate
    if (snapshot !== null) {
      console.log('Snapshot value:', snapshot);
    }
  }
  
  fetchUser(userId) {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(user => this.setState({ user }));
  }
  
  render() {
    return <div>{this.state.user?.name}</div>;
  }
}
```

**Important Pattern - Conditional setState:**
```javascript
componentDidUpdate(prevProps) {
  // ✅ Correct - with condition
  if (this.props.userId !== prevProps.userId) {
    this.setState({ loading: true });
    this.fetchData();
  }
  
  // ❌ Wrong - infinite loop!
  this.setState({ loading: true });  // Causes re-render → componentDidUpdate → setState → ...
}
```

**Common Use Cases:**
```javascript
componentDidUpdate(prevProps, prevState) {
  // 1. Fetch data when props change
  if (this.props.query !== prevProps.query) {
    this.fetchSearchResults(this.props.query);
  }
  
  // 2. Update third-party library
  if (this.props.chartData !== prevProps.chartData) {
    this.chart.update(this.props.chartData);
  }
  
  // 3. Animate based on state change
  if (this.state.count > prevState.count) {
    this.animateIncrease();
  }
  
  // 4. Sync with external storage
  if (this.state.preferences !== prevState.preferences) {
    localStorage.setItem('prefs', JSON.stringify(this.state.preferences));
  }
}
```

### Unmounting Phase

Component is **being removed from DOM**.

#### componentWillUnmount()

**Called immediately before component is unmounted and destroyed**.

**Purpose:**
- Clean up subscriptions
- Clear timers
- Remove event listeners
- Cancel network requests
- Clean up third-party libraries

**Example:**
```javascript
class Timer extends React.Component {
  state = { seconds: 0 };
  
  componentDidMount() {
    // Set up timer
    this.intervalId = setInterval(() => {
      this.setState(prev => ({ seconds: prev.seconds + 1 }));
    }, 1000);
    
    // Add event listener
    window.addEventListener('beforeunload', this.handleBeforeUnload);
    
    // Set up subscription
    this.subscription = dataSource.subscribe(this.handleData);
  }
  
  componentWillUnmount() {
    console.log('Component is unmounting, cleaning up...');
    
    // Clear timer
    clearInterval(this.intervalId);
    
    // Remove event listener
    window.removeEventListener('beforeunload', this.handleBeforeUnload);
    
    // Cancel subscription
    this.subscription.unsubscribe();
    
    // Cancel pending network requests (if using AbortController)
    this.abortController?.abort();
  }
  
  handleBeforeUnload = (e) => {
    e.preventDefault();
    e.returnValue = '';
  };
  
  handleData = (data) => {
    console.log('Received data:', data);
  };
  
  render() {
    return <div>Timer: {this.state.seconds}s</div>;
  }
}
```

**Critical Rules:**
```javascript
componentWillUnmount() {
  // ✅ Clean up everything set up in componentDidMount
  clearInterval(this.timerId);
  clearTimeout(this.timeoutId);
  window.removeEventListener('resize', this.handler);
  this.subscription.unsubscribe();
  
  // ❌ Don't call setState - component is being destroyed!
  this.setState({ data: null });  // Won't work, will cause warning
}
```

**Memory Leak Prevention:**
```javascript
class LeakyComponent extends React.Component {
  componentDidMount() {
    // ❌ Memory leak - listener never removed
    window.addEventListener('scroll', this.handleScroll);
    
    // ❌ Memory leak - interval never cleared
    setInterval(() => {
      this.setState({ time: new Date() });
    }, 1000);
  }
  
  // Missing componentWillUnmount - memory leaks!
}

class CorrectComponent extends React.Component {
  componentDidMount() {
    window.addEventListener('scroll', this.handleScroll);
    this.intervalId = setInterval(() => {
      this.setState({ time: new Date() });
    }, 1000);
  }
  
  componentWillUnmount() {
    // ✅ Clean up
    window.removeEventListener('scroll', this.handleScroll);
    clearInterval(this.intervalId);
  }
}
```

### Error Handling

Components can **catch errors in child components**.

#### 1. static getDerivedStateFromError(error)

**Called when child component throws error during render**.

**Purpose:**
- Update state to show fallback UI
- Must be static
- Called during render phase

**Example:**
```javascript
class ErrorBoundary extends React.Component {
  state = { hasError: false, error: null };
  
  static getDerivedStateFromError(error) {
    // Update state so next render shows fallback UI
    return { hasError: true, error };
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h1>Something went wrong.</h1>
          <p>{this.state.error?.message}</p>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage:
<ErrorBoundary>
  <MyComponent />
</ErrorBoundary>
```

#### 2. componentDidCatch(error, errorInfo)

**Called when child component throws error**.

**Purpose:**
- Log error information
- Report to error tracking service
- Can have side effects

**Example:**
```javascript
class ErrorBoundary extends React.Component {
  state = { hasError: false };
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    // Log error details
    console.error('Error caught:', error);
    console.error('Error info:', errorInfo.componentStack);
    
    // Report to error tracking service
    logErrorToService(error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}
```

**Complete Error Boundary Example:**
```javascript
class ErrorBoundary extends React.Component {
  state = {
    hasError: false,
    error: null,
    errorInfo: null
  };
  
  static getDerivedStateFromError(error) {
    // Update state to show fallback UI
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    // Log error details
    this.setState({
      error,
      errorInfo
    });
    
    // Report to monitoring service
    if (process.env.NODE_ENV === 'production') {
      // Sentry.captureException(error, { contexts: { react: { componentStack: errorInfo.componentStack } } });
    }
  }
  
  resetError = () => {
    this.setState({ hasError: false, error: null, errorInfo: null });
  };
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Oops! Something went wrong</h2>
          <details>
            <summary>Error Details</summary>
            <p><strong>Error:</strong> {this.state.error?.toString()}</p>
            <pre>{this.state.errorInfo?.componentStack}</pre>
          </details>
          <button onClick={this.resetError}>Try Again</button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage:
function App() {
  return (
    <ErrorBoundary>
      <Header />
      <ErrorBoundary>
        <Main />
      </ErrorBoundary>
      <Footer />
    </ErrorBoundary>
  );
}
```

**What Error Boundaries Catch:**
- ✅ Errors during rendering
- ✅ Errors in lifecycle methods
- ✅ Errors in constructors

**What Error Boundaries DON'T Catch:**
- ❌ Event handlers (use try-catch)
- ❌ Asynchronous code (use try-catch)
- ❌ Server-side rendering errors
- ❌ Errors in error boundary itself

```javascript
// ❌ Error boundary won't catch this
handleClick = () => {
  throw new Error('I will not be caught!');
};

// ✅ Use try-catch for event handlers
handleClick = () => {
  try {
    riskyOperation();
  } catch (error) {
    this.setState({ error });
  }
};
```

### Deprecated Lifecycle Methods

**⚠️ These are UNSAFE and should not be used:**

```javascript
// ❌ Deprecated - don't use!
UNSAFE_componentWillMount()      // Use componentDidMount instead
UNSAFE_componentWillReceiveProps() // Use getDerivedStateFromProps or componentDidUpdate
UNSAFE_componentWillUpdate()     // Use getSnapshotBeforeUpdate or componentDidUpdate
```

**Why deprecated:**
- Cause bugs in async rendering (React 18+)
- Difficult to reason about
- Often misused

---

## 4.2 Functional Component Lifecycle (Hooks)

### useEffect Hook

**The `useEffect` hook handles all lifecycle phases in functional components.**

**Basic Syntax:**
```javascript
useEffect(() => {
  // Effect code here
  
  return () => {
    // Cleanup code here
  };
}, [dependencies]);
```

**Conceptual Mapping:**
```
useEffect with []               → componentDidMount
useEffect with [deps]           → componentDidUpdate (when deps change)
useEffect cleanup              → componentWillUnmount
useEffect with no deps array   → componentDidMount + componentDidUpdate
```

### Dependency Array Explained

The **dependency array controls when effect runs**:

#### 1. Empty Array `[]` - Run Once on Mount

```javascript
function Component() {
  useEffect(() => {
    console.log('Component mounted');
    
    return () => {
      console.log('Component unmounting');
    };
  }, []);  // ← Empty array = run once
  
  return <div>Hello</div>;
}

// Equivalent class component:
class Component extends React.Component {
  componentDidMount() {
    console.log('Component mounted');
  }
  
  componentWillUnmount() {
    console.log('Component unmounting');
  }
}
```

**Use Cases:**
- Initial data fetching
- Setting up subscriptions
- Adding event listeners

**Examples:**
```javascript
// Fetch data on mount
useEffect(() => {
  fetch('/api/data')
    .then(res => res.json())
    .then(data => setData(data));
}, []);

// Set up event listener
useEffect(() => {
  const handleResize = () => {
    setWindowWidth(window.innerWidth);
  };
  
  window.addEventListener('resize', handleResize);
  
  return () => {
    window.removeEventListener('resize', handleResize);
  };
}, []);

// Initialize third-party library
useEffect(() => {
  const chart = new Chart(canvasRef.current, options);
  
  return () => {
    chart.destroy();
  };
}, []);
```

#### 2. With Dependencies `[dep1, dep2]` - Run When Dependencies Change

```javascript
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  
  useEffect(() => {
    console.log('Query changed, fetching results...');
    
    fetch(`/api/search?q=${query}`)
      .then(res => res.json())
      .then(data => setResults(data));
  }, [query]);  // ← Runs when query changes
  
  return <div>{results.length} results</div>;
}

// Equivalent class component:
class SearchResults extends React.Component {
  componentDidMount() {
    this.fetchResults(this.props.query);
  }
  
  componentDidUpdate(prevProps) {
    if (prevProps.query !== this.props.query) {
      this.fetchResults(this.props.query);
    }
  }
  
  fetchResults(query) {
    fetch(`/api/search?q=${query}`)
      .then(res => res.json())
      .then(data => this.setState({ results: data }));
  }
}
```

**Rules for Dependencies:**
```javascript
function Component({ userId, filter }) {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    // ✅ All external values used in effect are in deps
    fetchData(userId, filter).then(setData);
  }, [userId, filter]);
  
  // ❌ Wrong - missing dependencies
  useEffect(() => {
    fetchData(userId, filter).then(setData);
  }, [userId]);  // Missing filter!
  
  // ❌ Wrong - unnecessary dependency
  useEffect(() => {
    fetchData(userId).then(setData);
  }, [userId, filter]);  // filter not used in effect
}
```

**ESLint Plugin:**
```bash
# Install eslint-plugin-react-hooks
npm install eslint-plugin-react-hooks --save-dev

# Add to .eslintrc
{
  "plugins": ["react-hooks"],
  "rules": {
    "react-hooks/exhaustive-deps": "warn"
  }
}
```

#### 3. No Dependency Array - Run After Every Render

```javascript
function Component({ count }) {
  useEffect(() => {
    console.log('Component rendered');
    // Runs after EVERY render
  });  // ← No dependency array
  
  return <div>{count}</div>;
}

// Usually not what you want!
// Can cause performance issues
```

**When to use:**
- Rarely! Usually indicates a problem
- Logging/debugging during development

### Cleanup Functions

**Cleanup functions prevent memory leaks and bugs.**

**Pattern:**
```javascript
useEffect(() => {
  // Setup
  const subscription = dataSource.subscribe();
  
  return () => {
    // Cleanup - called before next effect or unmount
    subscription.unsubscribe();
  };
}, [dependencies]);
```

**Execution Order:**
```
1. Component mounts
2. Effect runs (setup)
3. Component re-renders
4. Cleanup runs (previous effect)
5. Effect runs again (new effect)
6. Component unmounts
7. Cleanup runs (final cleanup)
```

**Examples:**

**1. Event Listeners:**
```javascript
function MouseTracker() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  useEffect(() => {
    const handleMouseMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };
    
    // Add listener
    window.addEventListener('mousemove', handleMouseMove);
    
    // Remove listener on cleanup
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
    };
  }, []);
  
  return <div>Mouse: {position.x}, {position.y}</div>;
}
```

**2. Timers:**
```javascript
function Timer() {
  const [seconds, setSeconds] = useState(0);
  
  useEffect(() => {
    // Start timer
    const intervalId = setInterval(() => {
      setSeconds(s => s + 1);
    }, 1000);
    
    // Clear timer on cleanup
    return () => {
      clearInterval(intervalId);
    };
  }, []);
  
  return <div>Time: {seconds}s</div>;
}
```

**3. Subscriptions:**
```javascript
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  
  useEffect(() => {
    // Subscribe to room
    const subscription = chatAPI.subscribe(roomId, (message) => {
      setMessages(msgs => [...msgs, message]);
    });
    
    // Unsubscribe on cleanup
    return () => {
      subscription.unsubscribe();
    };
  }, [roomId]);  // Re-subscribe when room changes
  
  return <div>{messages.map(m => <p key={m.id}>{m.text}</p>)}</div>;
}
```

**4. Abort Fetch Requests:**
```javascript
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    const abortController = new AbortController();
    
    fetch(`/api/users/${userId}`, {
      signal: abortController.signal
    })
      .then(res => res.json())
      .then(data => setUser(data))
      .catch(error => {
        if (error.name !== 'AbortError') {
          console.error('Fetch error:', error);
        }
      });
    
    // Cancel request if userId changes or component unmounts
    return () => {
      abortController.abort();
    };
  }, [userId]);
  
  return <div>{user?.name}</div>;
}
```

### Common useEffect Patterns

#### 1. Fetching Data
```javascript
function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    setLoading(true);
    
    fetch('/api/users')
      .then(res => res.json())
      .then(data => {
        setUsers(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err);
        setLoading(false);
      });
  }, []);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```

#### 2. Syncing with External System
```javascript
function DocumentTitle({ title }) {
  useEffect(() => {
    // Update document title
    document.title = title;
    
    // Restore on unmount
    return () => {
      document.title = 'Default Title';
    };
  }, [title]);
  
  return null;
}
```

#### 3. Debouncing
```javascript
function SearchInput() {
  const [query, setQuery] = useState('');
  const [debouncedQuery, setDebouncedQuery] = useState('');
  
  // Debounce query
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      setDebouncedQuery(query);
    }, 500);  // 500ms delay
    
    return () => {
      clearTimeout(timeoutId);
    };
  }, [query]);
  
  // Fetch results when debounced query changes
  useEffect(() => {
    if (debouncedQuery) {
      fetch(`/api/search?q=${debouncedQuery}`)
        .then(res => res.json())
        .then(results => console.log(results));
    }
  }, [debouncedQuery]);
  
  return (
    <input 
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder="Search..."
    />
  );
}
```

#### 4. Local Storage Sync
```javascript
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : initialValue;
  });
  
  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);
  
  return [value, setValue];
}

// Usage:
function Settings() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  
  return (
    <select value={theme} onChange={(e) => setTheme(e.target.value)}>
      <option value="light">Light</option>
      <option value="dark">Dark</option>
    </select>
  );
}
```

### Common Pitfalls

#### 1. Stale Closures
```javascript
// ❌ Problem: Stale closure
function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const intervalId = setInterval(() => {
      setCount(count + 1);  // Always uses initial count (0)!
    }, 1000);
    
    return () => clearInterval(intervalId);
  }, []);  // Empty deps - count is stale
  
  return <div>{count}</div>;
}

// ✅ Solution 1: Functional update
function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const intervalId = setInterval(() => {
      setCount(c => c + 1);  // Uses current count
    }, 1000);
    
    return () => clearInterval(intervalId);
  }, []);
  
  return <div>{count}</div>;
}

// ✅ Solution 2: Add to dependencies
function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const intervalId = setInterval(() => {
      setCount(count + 1);
    }, 1000);
    
    return () => clearInterval(intervalId);
  }, [count]);  // Effect re-runs when count changes
  
  return <div>{count}</div>;
}
```

#### 2. Missing Dependencies
```javascript
// ❌ Problem: Missing dependency
function SearchResults({ query, filter }) {
  useEffect(() => {
    fetchResults(query, filter);
  }, [query]);  // Missing filter!
  
  // When filter changes, effect doesn't run
}

// ✅ Solution: Include all dependencies
function SearchResults({ query, filter }) {
  useEffect(() => {
    fetchResults(query, filter);
  }, [query, filter]);
}
```

#### 3. Infinite Loops
```javascript
// ❌ Problem: Infinite loop
function Component() {
  const [data, setData] = useState([]);
  
  useEffect(() => {
    setData([...data, 'new item']);  // Causes re-render
  }, [data]);  // Re-runs when data changes → infinite loop!
}

// ✅ Solution: Remove data from dependencies
function Component() {
  const [data, setData] = useState([]);
  
  const addItem = () => {
    setData(d => [...d, 'new item']);
  };
  
  // No useEffect needed for this!
}
```

---

## Summary of Chapter 4

**Class Component Lifecycle:**
```
Mounting:
1. constructor()
2. render()
3. componentDidMount()      → API calls, subscriptions

Updating:
1. render()
2. componentDidUpdate()      → React to prop/state changes

Unmounting:
1. componentWillUnmount()    → Cleanup!

Error Handling:
1. getDerivedStateFromError()
2. componentDidCatch()       → Log errors
```

**Functional Component (useEffect):**
```
Mount + Unmount:
useEffect(() => {
  // Setup
  return () => cleanup;
}, []);

Update on Changes:
useEffect(() => {
  // Effect
  return () => cleanup;
}, [dep1, dep2]);

Every Render:
useEffect(() => {
  // Effect
});
```

**Key Takeaways:**

1. **componentDidMount** = useEffect with `[]`
2. **componentDidUpdate** = useEffect with `[deps]`
3. **componentWillUnmount** = useEffect cleanup function
4. **Always clean up** subscriptions, timers, listeners
5. **Use Error Boundaries** for production apps
6. **Avoid stale closures** with functional updates
7. **Include all dependencies** in useEffect

**Practice Exercises:**

1. Build a timer that cleans up on unmount
2. Fetch data with loading and error states
3. Create a window resize tracker
4. Build a chat subscription component
5. Implement debounced search
6. Create an error boundary component
7. Build a component that syncs with localStorage
8. Create a component with multiple effects