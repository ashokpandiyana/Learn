# Chapter 13: API Integration - In-Depth Explanation

## What is API Integration?

**API Integration** is how your React app communicates with backend servers to fetch, create, update, and delete data.

**Common Operations (CRUD):**
```
CREATE  → POST   → Add new data
READ    → GET    → Fetch data
UPDATE  → PUT/PATCH → Modify data
DELETE  → DELETE → Remove data
```

**State to Manage:**
- **Data** - The actual response data
- **Loading** - Is request in progress?
- **Error** - Did request fail?
- **Cache** - Store previous responses

---

## 13.1 Data Fetching Methods

### Method 1: Fetch API with useEffect

**Basic Pattern:**
```javascript
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(response => response.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      })
      .catch(error => {
        setError(error);
        setLoading(false);
      });
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return <div>Welcome, {user.name}!</div>;
}
```

**Problem with Basic Fetch:**
```javascript
// ❌ Race condition - what if userId changes quickly?
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(setUser);
  }, [userId]);
  
  // If userId changes from 1 → 2 → 3 quickly:
  // Request 1 might finish AFTER request 3
  // Showing wrong user!
}
```

**Solution 1: Cleanup Flag**
```javascript
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let cancelled = false;
    
    setLoading(true);
    setError(null);
    
    fetch(`/api/users/${userId}`)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        if (!cancelled) {
          setUser(data);
          setLoading(false);
        }
      })
      .catch(error => {
        if (!cancelled) {
          setError(error);
          setLoading(false);
        }
      });
    
    return () => {
      cancelled = true;
    };
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return <div>{user?.name}</div>;
}
```

**Solution 2: AbortController (Better)**
```javascript
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const abortController = new AbortController();
    
    setLoading(true);
    setError(null);
    
    fetch(`/api/users/${userId}`, {
      signal: abortController.signal
    })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        setUser(data);
        setLoading(false);
      })
      .catch(error => {
        if (error.name !== 'AbortError') {
          setError(error);
          setLoading(false);
        }
      });
    
    return () => {
      abortController.abort();
    };
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return <div>{user?.name}</div>;
}
```

### Method 2: Axios

**Why Axios?**
- ✅ Automatic JSON transformation
- ✅ Request/response interceptors
- ✅ Better error handling
- ✅ Timeout support
- ✅ Request cancellation built-in

**Installation:**
```bash
npm install axios
```

**Basic Usage:**
```javascript
import axios from 'axios';

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const source = axios.CancelToken.source();
    
    const fetchUser = async () => {
      try {
        setLoading(true);
        const response = await axios.get(`/api/users/${userId}`, {
          cancelToken: source.token
        });
        setUser(response.data);
        setLoading(false);
      } catch (error) {
        if (!axios.isCancel(error)) {
          setError(error);
          setLoading(false);
        }
      }
    };
    
    fetchUser();
    
    return () => {
      source.cancel('Component unmounted');
    };
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return <div>{user?.name}</div>;
}
```

**Axios Configuration:**
```javascript
// Create axios instance with defaults
const api = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Request interceptor (add auth token)
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor (handle errors globally)
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Redirect to login
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

// Usage
function Component() {
  useEffect(() => {
    api.get('/users/1')
      .then(response => setUser(response.data))
      .catch(error => setError(error));
  }, []);
}
```

### Custom useFetch Hook

```javascript
function useFetch(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const abortController = new AbortController();
    
    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const response = await fetch(url, {
          ...options,
          signal: abortController.signal
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const json = await response.json();
        setData(json);
        setLoading(false);
      } catch (error) {
        if (error.name !== 'AbortError') {
          setError(error);
          setLoading(false);
        }
      }
    };
    
    fetchData();
    
    return () => {
      abortController.abort();
    };
  }, [url]);
  
  return { data, loading, error };
}

// Usage
function UserList() {
  const { data: users, loading, error } = useFetch('/api/users');
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

---

## 13.2 React Query (TanStack Query)

### Why React Query?

**Problems with manual fetch + useEffect:**
- ❌ Manual loading/error state management
- ❌ No caching
- ❌ No background refetching
- ❌ No request deduplication
- ❌ Race conditions
- ❌ Stale data

**React Query solves:**
- ✅ Automatic caching
- ✅ Background refetching
- ✅ Request deduplication
- ✅ Optimistic updates
- ✅ Pagination support
- ✅ Infinite scroll
- ✅ DevTools

**Installation:**
```bash
npm install @tanstack/react-query
```

### Basic Setup

```javascript
import { QueryClient, QueryClientProvider, useQuery } from '@tanstack/react-query';

// Create client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,  // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
      retry: 3,
      refetchOnWindowFocus: true
    }
  }
});

// Wrap app
function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourApp />
    </QueryClientProvider>
  );
}
```

### Basic Query

```javascript
function UserList() {
  const { 
    data, 
    isLoading, 
    isError, 
    error,
    isFetching,
    refetch 
  } = useQuery({
    queryKey: ['users'],
    queryFn: async () => {
      const response = await fetch('/api/users');
      if (!response.ok) {
        throw new Error('Network error');
      }
      return response.json();
    }
  });
  
  if (isLoading) return <div>Loading...</div>;
  if (isError) return <div>Error: {error.message}</div>;
  
  return (
    <div>
      <button onClick={() => refetch()}>Refresh</button>
      {isFetching && <span>Updating...</span>}
      
      <ul>
        {data.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

### Query Keys (Important!)

```javascript
// Query keys uniquely identify queries

// Simple key
useQuery({
  queryKey: ['users'],
  queryFn: fetchUsers
});

// Key with parameters
useQuery({
  queryKey: ['user', userId],
  queryFn: () => fetchUser(userId)
});

// Complex key with filters
useQuery({
  queryKey: ['users', { page, filter, sort }],
  queryFn: () => fetchUsers(page, filter, sort)
});

// React Query uses keys to:
// - Cache results
// - Invalidate cache
// - Deduplicate requests
```

### Dependent Queries

```javascript
function UserPosts({ userId }) {
  // First query: Get user
  const { data: user } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId)
  });
  
  // Second query: Get posts (depends on user)
  const { data: posts } = useQuery({
    queryKey: ['posts', user?.id],
    queryFn: () => fetchUserPosts(user.id),
    enabled: !!user  // Only run if user exists
  });
  
  return (
    <div>
      <h2>{user?.name}</h2>
      <ul>
        {posts?.map(post => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

### Mutations (Create/Update/Delete)

```javascript
import { useMutation, useQueryClient } from '@tanstack/react-query';

function AddUserForm() {
  const queryClient = useQueryClient();
  
  const mutation = useMutation({
    mutationFn: async (newUser) => {
      const response = await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newUser)
      });
      return response.json();
    },
    onSuccess: () => {
      // Invalidate and refetch users list
      queryClient.invalidateQueries({ queryKey: ['users'] });
    },
    onError: (error) => {
      console.error('Failed to add user:', error);
    }
  });
  
  const handleSubmit = (e) => {
    e.preventDefault();
    mutation.mutate({ name: 'John Doe', email: 'john@example.com' });
  };
  
  return (
    <form onSubmit={handleSubmit}>
      {/* Form fields */}
      <button type="submit" disabled={mutation.isPending}>
        {mutation.isPending ? 'Adding...' : 'Add User'}
      </button>
      
      {mutation.isError && (
        <div>Error: {mutation.error.message}</div>
      )}
      
      {mutation.isSuccess && (
        <div>User added successfully!</div>
      )}
    </form>
  );
}
```

### Optimistic Updates

```javascript
function TodoList() {
  const queryClient = useQueryClient();
  
  const toggleMutation = useMutation({
    mutationFn: async (todoId) => {
      const response = await fetch(`/api/todos/${todoId}/toggle`, {
        method: 'PATCH'
      });
      return response.json();
    },
    
    // Optimistic update
    onMutate: async (todoId) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['todos'] });
      
      // Snapshot previous value
      const previousTodos = queryClient.getQueryData(['todos']);
      
      // Optimistically update cache
      queryClient.setQueryData(['todos'], (old) =>
        old.map(todo =>
          todo.id === todoId
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      );
      
      // Return context with snapshot
      return { previousTodos };
    },
    
    // Rollback on error
    onError: (error, todoId, context) => {
      queryClient.setQueryData(['todos'], context.previousTodos);
    },
    
    // Always refetch after error or success
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    }
  });
  
  const { data: todos } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos
  });
  
  return (
    <ul>
      {todos?.map(todo => (
        <li key={todo.id}>
          <input 
            type="checkbox"
            checked={todo.completed}
            onChange={() => toggleMutation.mutate(todo.id)}
          />
          {todo.text}
        </li>
      ))}
    </ul>
  );
}
```

### Pagination

```javascript
function PaginatedUsers() {
  const [page, setPage] = useState(1);
  
  const { data, isLoading, isError } = useQuery({
    queryKey: ['users', page],
    queryFn: () => fetchUsers(page),
    keepPreviousData: true  // Keep old data while fetching new
  });
  
  return (
    <div>
      {isLoading && <div>Loading...</div>}
      
      <ul>
        {data?.users.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
      
      <div>
        <button 
          onClick={() => setPage(p => Math.max(1, p - 1))}
          disabled={page === 1}
        >
          Previous
        </button>
        
        <span>Page {page}</span>
        
        <button 
          onClick={() => setPage(p => p + 1)}
          disabled={!data?.hasMore}
        >
          Next
        </button>
      </div>
    </div>
  );
}
```

### Infinite Scroll

```javascript
import { useInfiniteQuery } from '@tanstack/react-query';

function InfiniteUserList() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    isLoading
  } = useInfiniteQuery({
    queryKey: ['users', 'infinite'],
    queryFn: async ({ pageParam = 1 }) => {
      const response = await fetch(`/api/users?page=${pageParam}`);
      return response.json();
    },
    getNextPageParam: (lastPage, pages) => {
      return lastPage.hasMore ? pages.length + 1 : undefined;
    }
  });
  
  if (isLoading) return <div>Loading...</div>;
  
  return (
    <div>
      {data.pages.map((page, i) => (
        <div key={i}>
          {page.users.map(user => (
            <div key={user.id}>{user.name}</div>
          ))}
        </div>
      ))}
      
      <button
        onClick={() => fetchNextPage()}
        disabled={!hasNextPage || isFetchingNextPage}
      >
        {isFetchingNextPage
          ? 'Loading more...'
          : hasNextPage
          ? 'Load More'
          : 'No more data'}
      </button>
    </div>
  );
}
```

### Prefetching

```javascript
function UserList() {
  const queryClient = useQueryClient();
  
  const { data: users } = useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers
  });
  
  const handleMouseEnter = (userId) => {
    // Prefetch user details on hover
    queryClient.prefetchQuery({
      queryKey: ['user', userId],
      queryFn: () => fetchUser(userId)
    });
  };
  
  return (
    <ul>
      {users?.map(user => (
        <li 
          key={user.id}
          onMouseEnter={() => handleMouseEnter(user.id)}
        >
          <Link to={`/users/${user.id}`}>{user.name}</Link>
        </li>
      ))}
    </ul>
  );
}
```

---

## 13.3 SWR (Alternative to React Query)

### What is SWR?

**SWR** stands for "stale-while-revalidate" - a HTTP cache invalidation strategy.

**Installation:**
```bash
npm install swr
```

**Basic Usage:**
```javascript
import useSWR from 'swr';

const fetcher = (url) => fetch(url).then(res => res.json());

function UserProfile({ userId }) {
  const { data, error, isLoading } = useSWR(
    `/api/users/${userId}`,
    fetcher
  );
  
  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return <div>{data.name}</div>;
}
```

**With Options:**
```javascript
const { data, error, isLoading, mutate } = useSWR(
  '/api/users',
  fetcher,
  {
    refreshInterval: 3000,        // Refresh every 3 seconds
    revalidateOnFocus: true,      // Revalidate on window focus
    revalidateOnReconnect: true,  // Revalidate on reconnect
    dedupingInterval: 2000,       // Dedupe requests within 2 seconds
    onSuccess: (data) => {
      console.log('Data fetched:', data);
    },
    onError: (error) => {
      console.error('Error:', error);
    }
  }
);

// Manual revalidation
<button onClick={() => mutate()}>Refresh</button>
```

**Mutations with SWR:**
```javascript
function AddUser() {
  const { mutate } = useSWR('/api/users', fetcher);
  
  const addUser = async (newUser) => {
    // Optimistic update
    mutate(
      async (users) => {
        // Update cache immediately
        return [...users, newUser];
      },
      false  // Don't revalidate immediately
    );
    
    // Send request
    await fetch('/api/users', {
      method: 'POST',
      body: JSON.stringify(newUser)
    });
    
    // Revalidate to get server data
    mutate();
  };
  
  return <button onClick={() => addUser({ name: 'John' })}>Add</button>;
}
```

**SWR vs React Query:**

| Feature | React Query | SWR |
|---------|------------|-----|
| Bundle Size | ~13 KB | ~5 KB |
| DevTools | ✅ | ❌ |
| Optimistic Updates | Easier | Manual |
| Infinite Scroll | Built-in | Manual |
| Prefetching | Built-in | Manual |
| Learning Curve | Moderate | Easy |
| Best For | Complex apps | Simple apps |

---

## 13.4 Error Handling Patterns

### Comprehensive Error Handling

```javascript
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchUser = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const response = await fetch(`/api/users/${userId}`);
        
        // Check HTTP status
        if (!response.ok) {
          if (response.status === 404) {
            throw new Error('User not found');
          } else if (response.status === 403) {
            throw new Error('Access denied');
          } else if (response.status >= 500) {
            throw new Error('Server error. Please try again later.');
          } else {
            throw new Error('Something went wrong');
          }
        }
        
        const data = await response.json();
        
        // Validate data
        if (!data || !data.id) {
          throw new Error('Invalid data received');
        }
        
        setUser(data);
        setLoading(false);
      } catch (error) {
        console.error('Error fetching user:', error);
        setError(error);
        setLoading(false);
      }
    };
    
    fetchUser();
  }, [userId]);
  
  // Different UI for different errors
  if (loading) {
    return <LoadingSpinner />;
  }
  
  if (error) {
    if (error.message === 'User not found') {
      return <NotFoundPage />;
    } else if (error.message === 'Access denied') {
      return <UnauthorizedPage />;
    } else {
      return <ErrorPage message={error.message} onRetry={() => window.location.reload()} />;
    }
  }
  
  return <div>{user.name}</div>;
}
```

### Error Boundary for API Errors

```javascript
class APIErrorBoundary extends React.Component {
  state = { hasError: false, error: null };
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    // Log to error reporting service
    logErrorToSentry(error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-container">
          <h2>Failed to load data</h2>
          <p>{this.state.error?.message}</p>
          <button onClick={() => window.location.reload()}>
            Retry
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage
function App() {
  return (
    <APIErrorBoundary>
      <UserList />
    </APIErrorBoundary>
  );
}
```

---

## 13.5 Loading States

### Skeleton Screens

```javascript
function UserCard({ userId }) {
  const { data: user, isLoading } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId)
  });
  
  if (isLoading) {
    return (
      <div className="user-card">
        {/* Skeleton loading */}
        <div className="skeleton avatar" />
        <div className="skeleton name" />
        <div className="skeleton email" />
      </div>
    );
  }
  
  return (
    <div className="user-card">
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
    </div>
  );
}

// CSS for skeleton
.skeleton {
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: loading 1.5s infinite;
}

@keyframes loading {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}
```

### Progressive Loading

```javascript
function UserProfile({ userId }) {
  const { data: user, isLoading } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId)
  });
  
  const { data: posts, isLoading: postsLoading } = useQuery({
    queryKey: ['posts', userId],
    queryFn: () => fetchUserPosts(userId),
    enabled: !!user  // Wait for user to load first
  });
  
  return (
    <div>
      {isLoading ? (
        <Skeleton />
      ) : (
        <>
          <UserHeader user={user} />
          
          {postsLoading ? (
            <PostsSkeleton />
          ) : (
            <PostsList posts={posts} />
          )}
        </>
      )}
    </div>
  );
}
```

### Loading Indicators

```javascript
function DataTable() {
  const { data, isLoading, isFetching, refetch } = useQuery({
    queryKey: ['data'],
    queryFn: fetchData
  });
  
  return (
    <div>
      <div className="header">
        <h2>Data Table</h2>
        <button onClick={() => refetch()}>
          Refresh
        </button>
        
        {/* Show background fetching indicator */}
        {isFetching && !isLoading && (
          <span className="fetching-indicator">Updating...</span>
        )}
      </div>
      
      {/* Initial loading */}
      {isLoading ? (
        <TableSkeleton />
      ) : (
        <Table data={data} />
      )}
    </div>
  );
}
```

---

## 13.6 Advanced Patterns

### Request Deduplication

```javascript
// React Query automatically deduplicates
function Dashboard() {
  return (
    <div>
      <UserWidget />    {/* Fetches /api/user */}
      <StatsWidget />   {/* Also fetches /api/user */}
      <ProfileWidget /> {/* Also fetches /api/user */}
    </div>
  );
}

// Only 1 request is made!
// All components share the cached result
```

### Polling (Auto-refresh)

```javascript
function LiveData() {
  const { data } = useQuery({
    queryKey: ['liveData'],
    queryFn: fetchLiveData,
    refetchInterval: 5000  // Refetch every 5 seconds
  });
  
  return <div>Live data: {data?.value}</div>;
}

// Conditional polling
const { data } = useQuery({
  queryKey: ['liveData'],
  queryFn: fetchLiveData,
  refetchInterval: (data) => {
    // Stop polling if data meets condition
    return data?.status === 'complete' ? false : 5000;
  }
});
```

### Retry Logic

```javascript
const { data, error } = useQuery({
  queryKey: ['users'],
  queryFn: fetchUsers,
  retry: 3,  // Retry 3 times on failure
  retryDelay: (attemptIndex) => {
    // Exponential backoff: 1s, 2s, 4s
    return Math.min(1000 * 2 ** attemptIndex, 30000);
  }
});
```

### Parallel Queries

```javascript
function Dashboard() {
  // All queries run in parallel
  const userQuery = useQuery({
    queryKey: ['user'],
    queryFn: fetchUser
  });
  
  const postsQuery = useQuery({
    queryKey: ['posts'],
    queryFn: fetchPosts
  });
  
  const statsQuery = useQuery({
    queryKey: ['stats'],
    queryFn: fetchStats
  });
  
  if (userQuery.isLoading || postsQuery.isLoading || statsQuery.isLoading) {
    return <div>Loading...</div>;
  }
  
  return (
    <div>
      <UserInfo user={userQuery.data} />
      <PostsList posts={postsQuery.data} />
      <Stats stats={statsQuery.data} />
    </div>
  );
}

// Or use useQueries for dynamic list
const results = useQueries({
  queries: userIds.map(id => ({
    queryKey: ['user', id],
    queryFn: () => fetchUser(id)
  }))
});
```

---

## 13.7 Complete CRUD Example

```javascript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

function TodoApp() {
  const queryClient = useQueryClient();
  
  // READ - Fetch todos
  const { data: todos, isLoading } = useQuery({
    queryKey: ['todos'],
    queryFn: async () => {
      const response = await fetch('/api/todos');
      return response.json();
    }
  });
  
  // CREATE - Add todo
  const addMutation = useMutation({
    mutationFn: async (newTodo) => {
      const response = await fetch('/api/todos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newTodo)
      });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    }
  });
  
  // UPDATE - Toggle todo
  const updateMutation = useMutation({
    mutationFn: async ({ id, updates }) => {
      const response = await fetch(`/api/todos/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      });
      return response.json();
    },
    onMutate: async ({ id, updates }) => {
      // Optimistic update
      await queryClient.cancelQueries({ queryKey: ['todos'] });
      const previous = queryClient.getQueryData(['todos']);
      
      queryClient.setQueryData(['todos'], (old) =>
        old.map(todo => todo.id === id ? { ...todo, ...updates } : todo)
      );
      
      return { previous };
    },
    onError: (err, variables, context) => {
      queryClient.setQueryData(['todos'], context.previous);
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    }
  });
  
  // DELETE - Remove todo
  const deleteMutation = useMutation({
    mutationFn: async (id) => {
      await fetch(`/api/todos/${id}`, { method: 'DELETE' });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    }
  });
  
  const handleAdd = (text) => {
    addMutation.mutate({ text, completed: false });
  };
  
  const handleToggle = (id, completed) => {
    updateMutation.mutate({ id, updates: { completed: !completed } });
  };
  
  const handleDelete = (id) => {
    if (window.confirm('Delete this todo?')) {
      deleteMutation.mutate(id);
    }
  };
  
  if (isLoading) return <div>Loading...</div>;
  
  return (
    <div>
      <AddTodoForm onAdd={handleAdd} />
      
      <ul>
        {todos?.map(todo => (
          <li key={todo.id}>
            <input 
              type="checkbox"
              checked={todo.completed}
              onChange={() => handleToggle(todo.id, todo.completed)}
            />
            {todo.text}
            <button onClick={() => handleDelete(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

## Summary of Chapter 13

**Key Concepts:**

1. **Manual Fetching** - fetch + useEffect (basic, but manual)
2. **AbortController** - Cancel requests on unmount
3. **Axios** - Better DX, interceptors, automatic JSON
4. **React Query** - Best for most apps (caching, refetching)
5. **SWR** - Simpler alternative to React Query
6. **Loading States** - Skeletons, spinners, progressive loading
7. **Error Handling** - HTTP status codes, error boundaries, retry logic
8. **Optimistic Updates** - Update UI immediately, rollback on error
9. **Caching** - Store responses, reduce network requests

**Data Fetching Evolution:**

```
Manual fetch + useEffect (2019)
  ↓
Custom useFetch hook (2020)
  ↓
React Query / SWR (2021-present)
  ↓
React Query is the standard (2024)
```

**When to Use What:**

| Scenario | Solution |
|----------|----------|
| Simple GET request | fetch + useEffect |
| Multiple endpoints | Custom useFetch hook |
| Complex data fetching | React Query |
| Real-time updates | React Query + WebSocket |
| Simple app | SWR |
| Need DevTools | React Query |
| Need interceptors | Axios |

**Best Practices:**

```javascript
// ✅ Always handle 3 states
const [data, setData] = useState(null);    // Success
const [loading, setLoading] = useState(true);  // Loading
const [error, setError] = useState(null);  // Error

// ✅ Cancel requests on unmount
useEffect(() => {
  const controller = new AbortController();
  fetch(url, { signal: controller.signal });
  return () => controller.abort();
}, []);

// ✅ Use React Query for server state
const { data } = useQuery({ queryKey: ['users'], queryFn: fetchUsers });

// ✅ Separate server state from client state
// React Query: server data
// Zustand/Context: client state

// ✅ Show loading indicators
{isLoading && <Spinner />}
{isFetching && !isLoading && <span>Updating...</span>}

// ✅ Provide retry functionality
<button onClick={() => refetch()}>Retry</button>
```

**Common Patterns:**

```javascript
// Pattern 1: Fetch on mount
useEffect(() => {
  fetchData();
}, []);

// Pattern 2: Fetch on prop change
useEffect(() => {
  fetchData(userId);
}, [userId]);

// Pattern 3: Fetch on button click
const handleClick = async () => {
  const data = await fetchData();
};

// Pattern 4: Optimistic update
const handleUpdate = (id) => {
  // Update UI immediately
  setData(data.map(item => 
    item.id === id ? { ...item, done: true } : item
  ));
  
  // Send to server
  updateItem(id).catch(() => {
    // Rollback on error
    setData(originalData);
  });
};
```

**Interview Focus:**
- Demonstrate fetch with loading/error states
- Show React Query usage
- Handle race conditions
- Implement optimistic updates
- Explain caching strategies