# Chapter 18: Error Handling & Logging - Complete In-Depth Guide

## 18.1 Understanding Errors in React

### Types of Errors

**1. Render Errors (Component Errors):**
```javascript
function BuggyComponent() {
  const data = null;
  return <div>{data.name}</div>;  // TypeError: Cannot read property 'name' of null
}
```

**2. Event Handler Errors:**
```javascript
function Button() {
  const handleClick = () => {
    throw new Error('Button error');  // Error in event handler
  };
  
  return <button onClick={handleClick}>Click</button>;
}
```

**3. Async Errors:**
```javascript
function DataFetcher() {
  useEffect(() => {
    fetch('/api/data')
      .then(res => res.json())
      .catch(error => {
        // Network error, parsing error, etc.
      });
  }, []);
}
```

**4. Lifecycle Errors:**
```javascript
function Component() {
  useEffect(() => {
    throw new Error('Error in useEffect');
  }, []);
}
```

### Error Propagation

```javascript
Child Component throws error
  ↓
Parent Error Boundary catches (if exists)
  ↓
Shows fallback UI
  ↓
App continues working (doesn't crash entire app)

Without Error Boundary:
Child throws error → Entire app crashes → White screen
```

---

## 18.2 Error Boundaries (Deep Dive)

### Basic Implementation

```javascript
import React from 'react';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { 
      hasError: false,
      error: null,
      errorInfo: null
    };
  }
  
  // Called when error is thrown during render
  static getDerivedStateFromError(error) {
    // Update state to trigger fallback UI
    return { hasError: true };
  }
  
  // Called after error is caught
  componentDidCatch(error, errorInfo) {
    // Log error details
    console.error('Error Boundary caught an error:', error);
    console.error('Component stack:', errorInfo.componentStack);
    
    // Store error details in state
    this.setState({
      error,
      errorInfo
    });
    
    // Log to external service (production only)
    if (process.env.NODE_ENV === 'production') {
      logErrorToService(error, errorInfo);
    }
  }
  
  render() {
    if (this.state.hasError) {
      // Render fallback UI
      return this.props.fallback || (
        <div style={{ padding: '20px', border: '1px solid red' }}>
          <h2>Something went wrong</h2>
          <p>We're sorry for the inconvenience.</p>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage
function App() {
  return (
    <ErrorBoundary>
      <MyComponent />
    </ErrorBoundary>
  );
}
```

### Advanced Error Boundary with Reset

```javascript
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    // Log to error reporting service
    this.props.onError?.(error, errorInfo);
    
    // Log to console in development
    if (process.env.NODE_ENV === 'development') {
      console.group('Error Boundary Caught Error');
      console.error('Error:', error);
      console.error('Error Info:', errorInfo);
      console.groupEnd();
    }
  }
  
  resetError = () => {
    this.setState({ hasError: false, error: null });
    this.props.onReset?.();
  };
  
  render() {
    if (this.state.hasError) {
      // Custom fallback component
      if (this.props.fallback) {
        return this.props.fallback({
          error: this.state.error,
          resetError: this.resetError
        });
      }
      
      // Default fallback
      return (
        <div className="error-boundary-fallback">
          <h1>Oops! Something went wrong</h1>
          <p>{this.state.error?.message}</p>
          
          <button onClick={this.resetError}>
            Try Again
          </button>
          
          <button onClick={() => window.location.href = '/'}>
            Go to Home
          </button>
          
          {/* Show stack in development */}
          {process.env.NODE_ENV === 'development' && (
            <details>
              <summary>Error Details (Dev Only)</summary>
              <pre>{this.state.error?.stack}</pre>
            </details>
          )}
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage with custom fallback
function App() {
  return (
    <ErrorBoundary
      fallback={({ error, resetError }) => (
        <div className="custom-error-page">
          <h1>Custom Error Page</h1>
          <p>{error.message}</p>
          <button onClick={resetError}>Retry</button>
        </div>
      )}
      onError={(error, errorInfo) => {
        // Custom error handler
        sendToAnalytics('error', { error, errorInfo });
      }}
      onReset={() => {
        // Custom reset handler
        console.log('Error boundary reset');
      }}
    >
      <MyApp />
    </ErrorBoundary>
  );
}
```

### Strategic Error Boundary Placement

```javascript
function App() {
  return (
    <ErrorBoundary fallback={<FullPageError />}>
      {/* Top-level boundary - catches catastrophic errors */}
      
      <Header />
      
      <div className="layout">
        {/* Sidebar can fail independently */}
        <ErrorBoundary fallback={<SidebarError />}>
          <Sidebar />
        </ErrorBoundary>
        
        {/* Main content can fail independently */}
        <ErrorBoundary fallback={<ContentError />}>
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route path="/profile" element={
              {/* Profile-specific error handling */}
              <ErrorBoundary fallback={<ProfileError />}>
                <ProfilePage />
              </ErrorBoundary>
            } />
          </Routes>
        </ErrorBoundary>
      </div>
      
      <Footer />
    </ErrorBoundary>
  );
}

// Benefits:
// - Granular error isolation
// - Better UX (partial failures)
// - Sidebar error doesn't crash main content
// - Footer always visible
```

---

## 18.3 Handling Different Error Scenarios

### Try-Catch for Event Handlers

```javascript
function FormComponent() {
  const [error, setError] = useState(null);
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(null);
    
    try {
      // Risky operation
      const result = await submitForm(formData);
      
      if (!result.success) {
        throw new Error(result.message);
      }
      
      // Success handling
      showSuccessMessage();
    } catch (error) {
      // Error handling
      console.error('Form submission error:', error);
      setError(error.message);
      
      // Log to service
      logError(error, { context: 'form_submission' });
    }
  };
  
  return (
    <div>
      {error && (
        <div className="error-message" role="alert">
          {error}
        </div>
      )}
      
      <div onSubmit={handleSubmit}>
        {/* Form fields */}
        <button type="submit">Submit</button>
      </div>
    </div>
  );
}
```

### Async Error Handling Patterns

```javascript
// Pattern 1: Try-Catch with Async/Await
async function fetchUserData(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Fetch error:', error);
    throw error;  // Re-throw for caller to handle
  }
}

// Pattern 2: Promise .catch()
function fetchUserData(userId) {
  return fetch(`/api/users/${userId}`)
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
    .catch(error => {
      console.error('Fetch error:', error);
      throw error;
    });
}

// Pattern 3: In Component
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let cancelled = false;
    
    const loadUser = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const userData = await fetchUserData(userId);
        
        if (!cancelled) {
          setUser(userData);
          setLoading(false);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err);
          setLoading(false);
        }
      }
    };
    
    loadUser();
    
    return () => {
      cancelled = true;
    };
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return <div>{user.name}</div>;
}
```

---

## 18.4 Error Logging Services

### Sentry - Complete Setup

**Installation:**
```bash
npm install @sentry/react
```

**Configuration:**
```javascript
// src/utils/sentry.js
import * as Sentry from '@sentry/react';
import { BrowserTracing } from '@sentry/tracing';

export function initSentry() {
  Sentry.init({
    dsn: process.env.REACT_APP_SENTRY_DSN,
    
    // Environment
    environment: process.env.NODE_ENV,
    
    // Release version
    release: process.env.REACT_APP_VERSION,
    
    // Performance monitoring
    integrations: [
      new BrowserTracing(),
      new Sentry.Replay({
        maskAllText: true,
        blockAllMedia: true,
      })
    ],
    
    // Sample rate for error events (0.0 to 1.0)
    sampleRate: 1.0,
    
    // Sample rate for performance monitoring
    tracesSampleRate: 0.1,  // 10% of transactions
    
    // Sample rate for session replay
    replaysSessionSampleRate: 0.1,
    replaysOnErrorSampleRate: 1.0,  // 100% when error occurs
    
    // Filter errors before sending
    beforeSend(event, hint) {
      // Don't send in development
      if (process.env.NODE_ENV === 'development') {
        console.log('Sentry event (dev):', event);
        return null;
      }
      
      // Filter out specific errors
      if (event.exception) {
        const error = hint.originalException;
        
        // Ignore browser extension errors
        if (error?.stack?.includes('chrome-extension://')) {
          return null;
        }
        
        // Ignore ResizeObserver errors (common browser quirk)
        if (error?.message?.includes('ResizeObserver')) {
          return null;
        }
      }
      
      return event;
    },
    
    // Modify events before sending
    beforeBreadcrumb(breadcrumb, hint) {
      // Don't log console breadcrumbs in production
      if (breadcrumb.category === 'console') {
        return null;
      }
      
      return breadcrumb;
    }
  });
}

// src/index.js
import { initSentry } from './utils/sentry';

initSentry();

ReactDOM.render(<App />, document.getElementById('root'));
```

**Error Boundary with Sentry:**
```javascript
import * as Sentry from '@sentry/react';

const SentryErrorBoundary = Sentry.ErrorBoundary;

function App() {
  return (
    <SentryErrorBoundary 
      fallback={({ error, componentStack, resetError }) => (
        <div>
          <h1>Application Error</h1>
          <p>{error.toString()}</p>
          <button onClick={resetError}>Try again</button>
        </div>
      )}
      showDialog  // Shows user feedback dialog
    >
      <MyApp />
    </SentryErrorBoundary>
  );
}
```

**Manual Error Capture:**
```javascript
// Capture exception
try {
  processPayment();
} catch (error) {
  Sentry.captureException(error, {
    // Add context
    tags: {
      section: 'checkout',
      payment_method: 'credit_card'
    },
    extra: {
      orderId: '12345',
      amount: 99.99,
      timestamp: Date.now()
    },
    level: 'error'  // 'fatal', 'error', 'warning', 'info', 'debug'
  });
}

// Capture message (not an exception)
Sentry.captureMessage('User completed checkout', {
  level: 'info',
  tags: { user_id: userId }
});

// Set user context
Sentry.setUser({
  id: user.id,
  email: user.email,
  username: user.name
});

// Set custom context
Sentry.setContext('order', {
  id: orderId,
  total: totalAmount,
  items: itemCount
});

// Add breadcrumbs (track user actions)
Sentry.addBreadcrumb({
  category: 'user_action',
  message: 'User clicked checkout button',
  level: 'info',
  data: {
    cartTotal: 99.99,
    itemCount: 3
  }
});
```

### Creating Custom Error Classes

```javascript
// Base API Error
class APIError extends Error {
  constructor(message, statusCode, response) {
    super(message);
    this.name = 'APIError';
    this.statusCode = statusCode;
    this.response = response;
  }
}

// Specific error types
class NotFoundError extends APIError {
  constructor(resource) {
    super(`${resource} not found`, 404);
    this.name = 'NotFoundError';
  }
}

class UnauthorizedError extends APIError {
  constructor() {
    super('Unauthorized access', 401);
    this.name = 'UnauthorizedError';
  }
}

class ValidationError extends Error {
  constructor(errors) {
    super('Validation failed');
    this.name = 'ValidationError';
    this.errors = errors;  // { field: 'error message' }
  }
}

// Usage
async function fetchUser(userId) {
  const response = await fetch(`/api/users/${userId}`);
  
  if (response.status === 404) {
    throw new NotFoundError('User');
  }
  
  if (response.status === 401) {
    throw new UnauthorizedError();
  }
  
  if (!response.ok) {
    throw new APIError('Request failed', response.status);
  }
  
  return response.json();
}

// Handle specific errors
try {
  const user = await fetchUser(123);
} catch (error) {
  if (error instanceof NotFoundError) {
    showNotFoundPage();
  } else if (error instanceof UnauthorizedError) {
    redirectToLogin();
  } else if (error instanceof APIError) {
    showErrorMessage(`Server error: ${error.statusCode}`);
  }
}
```

---

## 18.5 Error Recovery Strategies

### Retry with Exponential Backoff

```javascript
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      const isLastAttempt = attempt === maxRetries;
      
      if (isLastAttempt) {
        throw error;
      }
      
      // Exponential backoff: 1s, 2s, 4s, 8s...
      const delay = Math.min(1000 * Math.pow(2, attempt), 10000);
      
      console.log(`Retry attempt ${attempt + 1} after ${delay}ms`);
      
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// Usage in component
function DataComponent() {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [retrying, setRetrying] = useState(false);
  
  const loadData = async () => {
    try {
      setRetrying(true);
      const result = await fetchWithRetry('/api/data');
      setData(result);
      setError(null);
    } catch (err) {
      setError(err);
    } finally {
      setRetrying(false);
    }
  };
  
  useEffect(() => {
    loadData();
  }, []);
  
  if (error) {
    return (
      <div>
        <p>Error: {error.message}</p>
        <button onClick={loadData} disabled={retrying}>
          {retrying ? 'Retrying...' : 'Try Again'}
        </button>
      </div>
    );
  }
  
  return <div>{data}</div>;
}
```

### Circuit Breaker Pattern

```javascript
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.failureThreshold = threshold;
    this.timeout = timeout;
    this.failureCount = 0;
    this.lastFailureTime = null;
    this.state = 'CLOSED';  // CLOSED, OPEN, HALF_OPEN
  }
  
  async execute(fn) {
    if (this.state === 'OPEN') {
      // Check if timeout has passed
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }
    
    try {
      const result = await fn();
      
      // Success - reset on half-open or keep closed
      if (this.state === 'HALF_OPEN') {
        this.state = 'CLOSED';
        this.failureCount = 0;
      }
      
      return result;
    } catch (error) {
      this.failureCount++;
      this.lastFailureTime = Date.now();
      
      if (this.failureCount >= this.failureThreshold) {
        this.state = 'OPEN';
      }
      
      throw error;
    }
  }
}

// Usage
const apiCircuitBreaker = new CircuitBreaker(5, 60000);

async function fetchData() {
  try {
    return await apiCircuitBreaker.execute(() => 
      fetch('/api/data').then(r => r.json())
    );
  } catch (error) {
    if (error.message === 'Circuit breaker is OPEN') {
      // Show cached data or friendly message
      return getCachedData();
    }
    throw error;
  }
}
```

---

## 18.6 User-Friendly Error Messages

### Error Message Component Library

```javascript
// components/ErrorMessage.jsx
function ErrorMessage({ 
  type = 'error',  // 'error' | 'warning' | 'info'
  title,
  message, 
  actions = [],
  onDismiss 
}) {
  const configs = {
    error: {
      icon: '❌',
      bgColor: 'bg-red-50',
      borderColor: 'border-red-300',
      textColor: 'text-red-700'
    },
    warning: {
      icon: '⚠️',
      bgColor: 'bg-yellow-50',
      borderColor: 'border-yellow-300',
      textColor: 'text-yellow-700'
    },
    info: {
      icon: 'ℹ️',
      bgColor: 'bg-blue-50',
      borderColor: 'border-blue-300',
      textColor: 'text-blue-700'
    }
  };
  
  const config = configs[type];
  
  return (
    <div className={`${config.bgColor} border ${config.borderColor} rounded p-4`}>
      <div className="flex items-start gap-3">
        <div className="text-2xl">{config.icon}</div>
        <div className="flex-1">
          {title && (
            <h3 className={`font-semibold ${config.textColor} mb-1`}>
              {title}
            </h3>
          )}
          <p className="text-sm">{message}</p>
          
          {actions.length > 0 && (
            <div className="mt-3 flex gap-2">
              {actions.map((action, i) => (
                <button
                  key={i}
                  onClick={action.onClick}
                  className="px-3 py-1 bg-white border rounded text-sm"
                >
                  {action.label}
                </button>
              ))}
            </div>
          )}
        </div>
        
        {onDismiss && (
          <button onClick={onDismiss} className="text-gray-500 hover:text-gray-700">
            ×
          </button>
        )}
      </div>
    </div>
  );
}

// Usage
function Component() {
  const [showError, setShowError] = useState(false);
  
  return (
    <div>
      {showError && (
        <ErrorMessage
          type="error"
          title="Failed to save changes"
          message="The server is not responding. Your changes have been saved locally."
          actions={[
            { label: 'Try Again', onClick: handleRetry },
            { label: 'View Offline Data', onClick: showOfflineData }
          ]}
          onDismiss={() => setShowError(false)}
        />
      )}
    </div>
  );
}
```

### HTTP Status Code Handler

```javascript
function getErrorMessage(statusCode, defaultMessage = 'An error occurred') {
  const messages = {
    400: 'Bad request. Please check your input.',
    401: 'You need to log in to access this resource.',
    403: 'You don\'t have permission to access this resource.',
    404: 'The requested resource was not found.',
    408: 'Request timeout. Please try again.',
    429: 'Too many requests. Please slow down.',
    500: 'Server error. Please try again later.',
    502: 'Bad gateway. The server is temporarily unavailable.',
    503: 'Service unavailable. Please try again later.',
    504: 'Gateway timeout. The request took too long.'
  };
  
  return messages[statusCode] || defaultMessage;
}

// Usage
async function fetchData() {
  try {
    const response = await fetch('/api/data');
    
    if (!response.ok) {
      const errorMessage = getErrorMessage(
        response.status,
        'Failed to fetch data'
      );
      
      throw new Error(errorMessage);
    }
    
    return await response.json();
  } catch (error) {
    // User-friendly error message
    setError(error.message);
  }
}
```

---

## 18.7 Toast Notification System

### Complete Toast Implementation

```javascript
// context/ToastContext.jsx
import { createContext, useContext, useState, useCallback } from 'react';

const ToastContext = createContext();

export function ToastProvider({ children }) {
  const [toasts, setToasts] = useState([]);
  
  const addToast = useCallback((message, type = 'info', duration = 5000) => {
    const id = Date.now() + Math.random();
    const toast = { id, message, type };
    
    setToasts(prev => [...prev, toast]);
    
    if (duration > 0) {
      setTimeout(() => {
        removeToast(id);
      }, duration);
    }
    
    return id;
  }, []);
  
  const removeToast = useCallback((id) => {
    setToasts(prev => prev.filter(t => t.id !== id));
  }, []);
  
  const success = useCallback((message, duration) => {
    return addToast(message, 'success', duration);
  }, [addToast]);
  
  const error = useCallback((message, duration) => {
    return addToast(message, 'error', duration);
  }, [addToast]);
  
  const warning = useCallback((message, duration) => {
    return addToast(message, 'warning', duration);
  }, [addToast]);
  
  const info = useCallback((message, duration) => {
    return addToast(message, 'info', duration);
  }, [addToast]);
  
  return (
    <ToastContext.Provider value={{ toasts, addToast, removeToast, success, error, warning, info }}>
      {children}
      <ToastContainer />
    </ToastContext.Provider>
  );
}

export function useToast() {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within ToastProvider');
  }
  return context;
}

// components/ToastContainer.jsx
function ToastContainer() {
  const { toasts, removeToast } = useToast();
  
  const icons = {
    success: '✅',
    error: '❌',
    warning: '⚠️',
    info: 'ℹ️'
  };
  
  const colors = {
    success: 'bg-green-500',
    error: 'bg-red-500',
    warning: 'bg-yellow-500',
    info: 'bg-blue-500'
  };
  
  return (
    <div className="fixed top-4 right-4 z-50 space-y-2">
      {toasts.map(toast => (
        <div
          key={toast.id}
          className={`${colors[toast.type]} text-white px-4 py-3 rounded shadow-lg flex items-center gap-3 min-w-80 animate-slide-in`}
        >
          <span className="text-xl">{icons[toast.type]}</span>
          <span className="flex-1">{toast.message}</span>
          <button
            onClick={() => removeToast(toast.id)}
            className="text-white hover:text-gray-200 font-bold text-xl"
          >
            ×
          </button>
        </div>
      ))}
    </div>
  );
}

// Usage in components
function MyComponent() {
  const toast = useToast();
  
  const handleSave = async () => {
    try {
      await saveData();
      toast.success('Data saved successfully!');
    } catch (error) {
      toast.error('Failed to save data');
    }
  };
  
  const handleWarning = () => {
    toast.warning('You have unsaved changes');
  };
  
  return (
    <div>
      <button onClick={handleSave}>Save</button>
    </div>
  );
}
```

---

## Summary

**Error Handling Checklist:**

✅ **Error Boundaries**
- Wrap app in top-level boundary
- Add granular boundaries for sections
- Provide fallback UI
- Reset functionality

✅ **Event Handlers**
- Use try-catch
- Show user-friendly errors
- Log to service

✅ **Async Operations**
- Try-catch with async/await
- Handle network errors
- Implement retry logic

✅ **Error Logging**
- Integrate Sentry/LogRocket
- Log context and breadcrumbs
- Filter noise
- Monitor in production

✅ **User Experience**
- User-friendly messages
- Toast notifications
- Action buttons (retry, dismiss)
- Never show stack traces to users

**Key Patterns:**

```javascript
// 1. Error Boundary for render errors
<ErrorBoundary fallback={<ErrorPage />}>
  <App />
</ErrorBoundary>

// 2. Try-catch for events
const handle = () => {
  try {
    operation();
  } catch (e) {
    setError(e);
  }
};

// 3. Async error handling
try {
  const data = await fetch();
} catch (error) {
  handleError(error);
}

// 4. Log to service
Sentry.captureException(error);
```