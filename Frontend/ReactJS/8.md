# Chapter 8: State Management Patterns - In-Depth Explanation

## What is State Management?

**State management** is how you handle data that changes over time in your application. As apps grow, managing state becomes complex.

**State Types:**
```
1. LOCAL STATE      → useState, useReducer (component-level)
2. LIFTED STATE     → Shared between parent/children
3. GLOBAL STATE     → Shared across entire app
4. SERVER STATE     → Data from APIs (React Query, SWR)
5. URL STATE        → Router params, query strings
```

**State Management Evolution:**
```
2013: Component State only
2015: Redux (centralized store)
2018: Context API (built-in)
2019: Hooks (useState, useReducer)
2020: Modern solutions (Zustand, Jotai, Recoil)
2021: Server State (React Query, SWR)
```

---

## 8.1 Component State

### Local State with useState

**When to use:** State needed only in one component.

```javascript
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

### Lifting State Up

**When to use:** Multiple components need to share state.

```javascript
// Parent manages shared state
function Parent() {
  const [sharedData, setSharedData] = useState('');
  
  return (
    <div>
      <ChildA data={sharedData} setData={setSharedData} />
      <ChildB data={sharedData} />
    </div>
  );
}

function ChildA({ data, setData }) {
  return (
    <input 
      value={data}
      onChange={(e) => setData(e.target.value)}
    />
  );
}

function ChildB({ data }) {
  return <div>Data: {data}</div>;
}
```

### State Colocation

**Principle:** Keep state as close as possible to where it's used.

```javascript
// ❌ Bad: State too high up
function App() {
  const [userFormData, setUserFormData] = useState({});
  const [productFormData, setProductFormData] = useState({});
  
  return (
    <div>
      <HomePage />
      <UserForm data={userFormData} setData={setUserFormData} />
      <ProductForm data={productFormData} setData={setProductFormData} />
    </div>
  );
}

// ✅ Good: State colocated in components
function App() {
  return (
    <div>
      <HomePage />
      <UserForm /> {/* Manages own state */}
      <ProductForm /> {/* Manages own state */}
    </div>
  );
}

function UserForm() {
  const [formData, setFormData] = useState({});
  // State is local, only needed here
  return <form>{/* form fields */}</form>;
}
```

### Complex State with useReducer

**When to use:** Complex state logic with multiple actions.

```javascript
const initialState = {
  items: [],
  loading: false,
  error: null,
  filter: 'all'
};

function reducer(state, action) {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };
    
    case 'FETCH_SUCCESS':
      return { ...state, loading: false, items: action.payload };
    
    case 'FETCH_ERROR':
      return { ...state, loading: false, error: action.payload };
    
    case 'SET_FILTER':
      return { ...state, filter: action.payload };
    
    case 'ADD_ITEM':
      return { ...state, items: [...state.items, action.payload] };
    
    case 'DELETE_ITEM':
      return { 
        ...state, 
        items: state.items.filter(item => item.id !== action.payload) 
      };
    
    default:
      return state;
  }
}

function ItemManager() {
  const [state, dispatch] = useReducer(reducer, initialState);
  
  useEffect(() => {
    dispatch({ type: 'FETCH_START' });
    
    fetch('/api/items')
      .then(res => res.json())
      .then(data => dispatch({ type: 'FETCH_SUCCESS', payload: data }))
      .catch(err => dispatch({ type: 'FETCH_ERROR', payload: err }));
  }, []);
  
  return (
    <div>
      {state.loading && <div>Loading...</div>}
      {state.error && <div>Error: {state.error.message}</div>}
      
      <select 
        value={state.filter}
        onChange={(e) => dispatch({ type: 'SET_FILTER', payload: e.target.value })}
      >
        <option value="all">All</option>
        <option value="active">Active</option>
      </select>
      
      <ul>
        {state.items.map(item => (
          <li key={item.id}>
            {item.name}
            <button onClick={() => dispatch({ type: 'DELETE_ITEM', payload: item.id })}>
              Delete
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

## 8.2 Context API

### What is Context?

Context provides a way to pass data through the component tree without prop drilling.

**Visual Representation:**
```
Without Context (Prop Drilling):
App (data) 
  → Page (data) 
    → Section (data) 
      → Component (uses data)

With Context:
App (Provider)
  → Page
    → Section
      → Component (useContext to access data directly)
```

### Basic Context Pattern

```javascript
import { createContext, useContext, useState } from 'react';

// 1. Create Context
const ThemeContext = createContext();

// 2. Create Provider Component
export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  const value = {
    theme,
    toggleTheme
  };
  
  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

// 3. Create Custom Hook
export function useTheme() {
  const context = useContext(ThemeContext);
  
  if (context === undefined) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  
  return context;
}

// 4. Use in Components
function App() {
  return (
    <ThemeProvider>
      <Header />
      <Main />
      <Footer />
    </ThemeProvider>
  );
}

function Header() {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <header className={theme}>
      <button onClick={toggleTheme}>
        Switch to {theme === 'light' ? 'dark' : 'light'} mode
      </button>
    </header>
  );
}
```

### Multiple Contexts

```javascript
const UserContext = createContext();
const ThemeContext = createContext();
const LanguageContext = createContext();

function App() {
  return (
    <UserProvider>
      <ThemeProvider>
        <LanguageProvider>
          <MainApp />
        </LanguageProvider>
      </ThemeProvider>
    </UserProvider>
  );
}

function Component() {
  const { user } = useUser();
  const { theme } = useTheme();
  const { language } = useLanguage();
  
  return <div>{/* Use all contexts */}</div>;
}
```

### Context Performance Optimization

**Problem:** Context updates re-render all consumers.

```javascript
// ❌ Problem: Everything re-renders on any change
function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  const [settings, setSettings] = useState({});
  
  // All data in one context
  const value = { user, setUser, theme, setTheme, settings, setSettings };
  
  return (
    <AppContext.Provider value={value}>
      {children}
    </AppContext.Provider>
  );
}

// When theme changes, components using only user still re-render!
```

**Solution 1: Split Contexts**

```javascript
// ✅ Split into separate contexts
function App() {
  return (
    <UserProvider>
      <ThemeProvider>
        <SettingsProvider>
          <MainApp />
        </SettingsProvider>
      </ThemeProvider>
    </UserProvider>
  );
}

// Now components only re-render when their specific context changes
function ThemeButton() {
  const { theme, toggleTheme } = useTheme();
  // Only re-renders when theme changes, not user or settings
  return <button onClick={toggleTheme}>{theme}</button>;
}
```

**Solution 2: useMemo for Provider Value**

```javascript
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  // Memoize value object to prevent unnecessary re-renders
  const value = useMemo(() => ({
    theme,
    setTheme
  }), [theme]);
  
  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}
```

**Solution 3: Context Selectors (Manual)**

```javascript
function useUserName() {
  const { user } = useUser();
  return user?.name; // Only re-render when name changes
}

function useUserEmail() {
  const { user } = useUser();
  return user?.email; // Only re-render when email changes
}
```

### Complete Context Example: Auth

```javascript
const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Check if user is logged in
    const token = localStorage.getItem('token');
    
    if (token) {
      fetch('/api/auth/me', {
        headers: { Authorization: `Bearer ${token}` }
      })
        .then(res => res.json())
        .then(data => {
          setUser(data);
          setLoading(false);
        })
        .catch(() => {
          localStorage.removeItem('token');
          setLoading(false);
        });
    } else {
      setLoading(false);
    }
  }, []);
  
  const login = async (email, password) => {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    });
    
    const data = await response.json();
    
    localStorage.setItem('token', data.token);
    setUser(data.user);
    
    return data;
  };
  
  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
  };
  
  const value = useMemo(() => ({
    user,
    loading,
    login,
    logout
  }), [user, loading]);
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  
  if (context === undefined) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  
  return context;
}

// Protected Route Component
function ProtectedRoute({ children }) {
  const { user, loading } = useAuth();
  
  if (loading) return <div>Loading...</div>;
  if (!user) return <Navigate to="/login" />;
  
  return children;
}

// Usage
function App() {
  return (
    <AuthProvider>
      <Router>
        <Routes>
          <Route path="/login" element={<Login />} />
          <Route 
            path="/dashboard" 
            element={
              <ProtectedRoute>
                <Dashboard />
              </ProtectedRoute>
            } 
          />
        </Routes>
      </Router>
    </AuthProvider>
  );
}
```

---

## 8.3 Redux

### What is Redux?

Redux is a **predictable state container** with a centralized store and strict rules for updates.

**Core Principles:**
1. **Single source of truth** - One store for entire app
2. **State is read-only** - Only update via actions
3. **Changes via pure functions** - Reducers are pure functions

**Redux Flow:**
```
Component
  ↓ dispatch(action)
Store → Reducer → New State
  ↓ subscribe
Component (re-renders with new state)
```

### Basic Redux Setup (Legacy)

```javascript
// 1. Actions
const INCREMENT = 'INCREMENT';
const DECREMENT = 'DECREMENT';

const increment = () => ({ type: INCREMENT });
const decrement = () => ({ type: DECREMENT });

// 2. Reducer
const initialState = { count: 0 };

function counterReducer(state = initialState, action) {
  switch (action.type) {
    case INCREMENT:
      return { count: state.count + 1 };
    case DECREMENT:
      return { count: state.count - 1 };
    default:
      return state;
  }
}

// 3. Store
import { createStore } from 'redux';
const store = createStore(counterReducer);

// 4. React Integration
import { Provider, useSelector, useDispatch } from 'react-redux';

function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  );
}

function Counter() {
  const count = useSelector(state => state.count);
  const dispatch = useDispatch();
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
    </div>
  );
}
```

### Redux Toolkit (Modern Approach)

**Redux Toolkit** is the modern, recommended way to use Redux.

```javascript
// store.js
import { configureStore, createSlice } from '@reduxjs/toolkit';

// 1. Create Slice
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value += 1; // Immer allows "mutations"
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    }
  }
});

export const { increment, decrement, incrementByAmount } = counterSlice.actions;

// 2. Configure Store
export const store = configureStore({
  reducer: {
    counter: counterSlice.reducer
  }
});

// 3. Use in Components
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement } from './store';

function Counter() {
  const count = useSelector(state => state.counter.value);
  const dispatch = useDispatch();
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
    </div>
  );
}
```

### Redux Toolkit - Complex Example

```javascript
// features/todos/todosSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// Async thunk for API calls
export const fetchTodos = createAsyncThunk(
  'todos/fetchTodos',
  async () => {
    const response = await fetch('/api/todos');
    return response.json();
  }
);

const todosSlice = createSlice({
  name: 'todos',
  initialState: {
    items: [],
    status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'
    error: null,
    filter: 'all'
  },
  reducers: {
    todoAdded: (state, action) => {
      state.items.push(action.payload);
    },
    todoToggled: (state, action) => {
      const todo = state.items.find(t => t.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
    todoDeleted: (state, action) => {
      state.items = state.items.filter(t => t.id !== action.payload);
    },
    filterChanged: (state, action) => {
      state.filter = action.payload;
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchTodos.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchTodos.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.items = action.payload;
      })
      .addCase(fetchTodos.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message;
      });
  }
});

export const { todoAdded, todoToggled, todoDeleted, filterChanged } = todosSlice.actions;

// Selectors
export const selectAllTodos = (state) => state.todos.items;
export const selectFilteredTodos = (state) => {
  const { items, filter } = state.todos;
  
  if (filter === 'active') return items.filter(t => !t.completed);
  if (filter === 'completed') return items.filter(t => t.completed);
  return items;
};

export default todosSlice.reducer;

// Component Usage
function TodoList() {
  const dispatch = useDispatch();
  const todos = useSelector(selectFilteredTodos);
  const status = useSelector(state => state.todos.status);
  const filter = useSelector(state => state.todos.filter);
  
  useEffect(() => {
    if (status === 'idle') {
      dispatch(fetchTodos());
    }
  }, [status, dispatch]);
  
  if (status === 'loading') return <div>Loading...</div>;
  if (status === 'failed') return <div>Error loading todos</div>;
  
  return (
    <div>
      <select 
        value={filter}
        onChange={(e) => dispatch(filterChanged(e.target.value))}
      >
        <option value="all">All</option>
        <option value="active">Active</option>
        <option value="completed">Completed</option>
      </select>
      
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input 
              type="checkbox"
              checked={todo.completed}
              onChange={() => dispatch(todoToggled(todo.id))}
            />
            {todo.text}
            <button onClick={() => dispatch(todoDeleted(todo.id))}>
              Delete
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### Redux DevTools

```javascript
// Automatically works with Redux Toolkit
const store = configureStore({
  reducer: {
    counter: counterReducer,
    todos: todosReducer
  }
});

// View in browser: Redux DevTools Extension
// - See all actions
// - Time-travel debugging
// - State diff viewer
```

---

## 8.4 Zustand

### What is Zustand?

**Zustand** is a small, fast, and scalable state management solution. Much simpler than Redux.

**Key Features:**
- No boilerplate
- No providers needed
- TypeScript-friendly
- Works outside React
- Middleware support

### Basic Zustand Setup

```javascript
import create from 'zustand';

// Create store
const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 })
}));

// Use in components
function Counter() {
  const count = useStore((state) => state.count);
  const increment = useStore((state) => state.increment);
  const decrement = useStore((state) => state.decrement);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
    </div>
  );
}

// No Provider needed!
function App() {
  return <Counter />;
}
```

### Zustand with Async Actions

```javascript
import create from 'zustand';

const useStore = create((set, get) => ({
  todos: [],
  loading: false,
  error: null,
  
  fetchTodos: async () => {
    set({ loading: true, error: null });
    
    try {
      const response = await fetch('/api/todos');
      const todos = await response.json();
      set({ todos, loading: false });
    } catch (error) {
      set({ error: error.message, loading: false });
    }
  },
  
  addTodo: (text) => {
    const newTodo = { id: Date.now(), text, completed: false };
    set((state) => ({ todos: [...state.todos, newTodo] }));
  },
  
  toggleTodo: (id) => {
    set((state) => ({
      todos: state.todos.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    }));
  },
  
  deleteTodo: (id) => {
    set((state) => ({
      todos: state.todos.filter(todo => todo.id !== id)
    }));
  }
}));

// Component
function TodoList() {
  const { todos, loading, fetchTodos, addTodo, toggleTodo, deleteTodo } = useStore();
  
  useEffect(() => {
    fetchTodos();
  }, [fetchTodos]);
  
  if (loading) return <div>Loading...</div>;
  
  return (
    <div>
      {todos.map(todo => (
        <div key={todo.id}>
          <input 
            type="checkbox"
            checked={todo.completed}
            onChange={() => toggleTodo(todo.id)}
          />
          {todo.text}
          <button onClick={() => deleteTodo(todo.id)}>Delete</button>
        </div>
      ))}
    </div>
  );
}
```

### Zustand Middleware

```javascript
import create from 'zustand';
import { persist } from 'zustand/middleware';

// Persist to localStorage
const useStore = create(
  persist(
    (set) => ({
      count: 0,
      increment: () => set((state) => ({ count: state.count + 1 }))
    }),
    {
      name: 'counter-storage' // localStorage key
    }
  )
);

// Immer middleware (for easier updates)
import { immer } from 'zustand/middleware/immer';

const useStore = create(
  immer((set) => ({
    todos: [],
    addTodo: (text) => set((state) => {
      state.todos.push({ id: Date.now(), text }); // Direct mutation with Immer
    })
  }))
);
```

### Zustand Selectors (Performance)

```javascript
// ❌ Component re-renders even if only using count
function Component() {
  const store = useStore(); // Gets entire store
  return <div>{store.count}</div>;
}

// ✅ Component only re-renders when count changes
function Component() {
  const count = useStore((state) => state.count); // Selector
  return <div>{count}</div>;
}

// ✅ Multiple selectors
function Component() {
  const count = useStore((state) => state.count);
  const increment = useStore((state) => state.increment);
  
  return (
    <div>
      {count}
      <button onClick={increment}>+</button>
    </div>
  );
}
```

---

## 8.5 Recoil

### What is Recoil?

**Recoil** is a state management library by Facebook designed for React.

**Key Concepts:**
- **Atoms**: Units of state
- **Selectors**: Derived state
- **Atom families**: Dynamic atoms

### Basic Recoil Setup

```javascript
import { RecoilRoot, atom, useRecoilState, useRecoilValue, useSetRecoilState } from 'recoil';

// 1. Create atoms
const countState = atom({
  key: 'countState', // Unique ID
  default: 0
});

// 2. Wrap app in RecoilRoot
function App() {
  return (
    <RecoilRoot>
      <Counter />
    </RecoilRoot>
  );
}

// 3. Use atoms in components
function Counter() {
  const [count, setCount] = useRecoilState(countState);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
      <button onClick={() => setCount(count - 1)}>-</button>
    </div>
  );
}
```

### Recoil Selectors (Derived State)

```javascript
import { selector } from 'recoil';

const todosState = atom({
  key: 'todosState',
  default: []
});

const filterState = atom({
  key: 'filterState',
  default: 'all'
});

// Selector: Derived state
const filteredTodosState = selector({
  key: 'filteredTodosState',
  get: ({ get }) => {
    const todos = get(todosState);
    const filter = get(filterState);
    
    switch (filter) {
      case 'completed':
        return todos.filter(t => t.completed);
      case 'active':
        return todos.filter(t => !t.completed);
      default:
        return todos;
    }
  }
});

// Component
function TodoList() {
  const todos = useRecoilValue(filteredTodosState);
  
  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}
```

### Recoil Async Selectors

```javascript
const userState = selector({
  key: 'userState',
  get: async ({ get }) => {
    const userId = get(userIdState);
    const response = await fetch(`/api/users/${userId}`);
    return response.json();
  }
});

function UserProfile() {
  const user = useRecoilValue(userState);
  
  return <div>{user.name}</div>;
}

// With Suspense
function App() {
  return (
    <RecoilRoot>
      <Suspense fallback={<div>Loading...</div>}>
        <UserProfile />
      </Suspense>
    </RecoilRoot>
  );
}
```

---

## 8.6 Jotai

### What is Jotai?

**Jotai** is a primitive and flexible atomic state management library.

**Features:**
- Simpler than Recoil
- Bottom-up approach
- TypeScript-first
- Minimal boilerplate

### Basic Jotai Setup

```javascript
import { atom, useAtom } from 'jotai';

// Create atom
const countAtom = atom(0);

// Use in component (no provider needed!)
function Counter() {
  const [count, setCount] = useAtom(countAtom);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>+</button>
    </div>
  );
}
```

### Jotai Derived Atoms

```javascript
import { atom } from 'jotai';

const todosAtom = atom([]);
const filterAtom = atom('all');

// Derived atom
const filteredTodosAtom = atom((get) => {
  const todos = get(todosAtom);
  const filter = get(filterAtom);
  
  if (filter === 'completed') return todos.filter(t => t.completed);
  if (filter === 'active') return todos.filter(t => !t.completed);
  return todos;
});

function TodoList() {
  const [filteredTodos] = useAtom(filteredTodosAtom);
  
  return (
    <ul>
      {filteredTodos.map(todo => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}
```

---

## 8.7 State Management Decision Tree

### Decision Framework

```
Question 1: Is state local to one component?
  YES → useState or useReducer
  NO  → Continue

Question 2: Do few components need this state?
  YES → Lift state up to common parent
  NO  → Continue

Question 3: Is this server data (from API)?
  YES → React Query or SWR
  NO  → Continue

Question 4: Do many distant components need this?
  YES → Need global state solution
        ↓
        Small app (<10 components)? → Context API
        Medium app? → Zustand or Jotai
        Large app? → Redux Toolkit
        Need time-travel debugging? → Redux Toolkit
        Facebook-style apps? → Recoil
```

### Comparison Table

| Solution | Boilerplate | Learning Curve | Bundle Size | DevTools | Best For |
|----------|-------------|----------------|-------------|----------|----------|
| useState | None | Easy | 0 KB | ✅ | Local state |
| Context | Low | Easy | 0 KB | ❌ | Simple global state |
| Redux Toolkit | Medium | Moderate | ~12 KB | ✅ | Large apps, time-travel |
| Zustand | Very Low | Easy | ~1 KB | ❌ | Most apps |
| Recoil | Medium | Moderate | ~21 KB | ❌ | Facebook-style apps |
| Jotai | Very Low | Easy | ~3 KB | ❌ | Atomic state |

### When to Use What

**useState/useReducer:**
```javascript
// ✅ Use when: State only needed in one component
function Component() {
  const [count, setCount] = useState(0);
  // Perfect for local state
}
```

**Context API:**
```javascript
// ✅ Use when: Theme, auth, language (infrequent updates)
// ❌ Avoid when: State updates frequently (performance issues)
const { theme } = useTheme(); // Updates rarely, perfect for Context
```

**Redux Toolkit:**
```javascript
// ✅ Use when:
// - Large app with complex state
// - Need time-travel debugging
// - Team familiar with Redux
// - Need middleware ecosystem

// Examples: E-commerce cart, complex dashboards
```

**Zustand:**
```javascript
// ✅ Use when:
// - Want simplicity
// - Don't need Redux complexity
// - Medium-sized apps

// My recommendation for most apps!
const useStore = create((set) => ({
  // Simple and powerful
}));
```

**React Query / SWR:**
```javascript
// ✅ Use when: Managing server state
const { data, isLoading } = useQuery('todos', fetchTodos);
// Perfect for API data
```

---

## Summary of Chapter 8

**State Management Hierarchy:**

```
1. Local State (useState/useReducer)
   ↓ when multiple components need it
2. Lifted State (common parent)
   ↓ when many distant components need it
3. Context API (simple global state)
   ↓ or
4. External Library:
   - Zustand (simple, recommended)
   - Redux Toolkit (large apps, time-travel)
   - Recoil (Facebook-style)
   - Jotai (atomic state)
```

**Quick Decision Guide:**

| Scenario | Solution |
|----------|----------|
| Button click counter | useState |
| Form data | useState/useReducer |
| Theme, auth, language | Context API |
| API data | React Query/SWR |
| Shopping cart | Zustand or Redux |
| Complex dashboard | Redux Toolkit |
| Simple todo app | Zustand |
| Large e-commerce | Redux Toolkit |

**Modern Recommendations:**

1. **Default**: useState + Context for simple needs
2. **Server State**: Always use React Query or SWR
3. **Client State**: Zustand for most apps
4. **Large Apps**: Redux Toolkit if needed

**Key Principles:**

- Start simple (useState)
- Only add complexity when needed
- Keep state as local as possible
- Separate server state from client state
- Choose based on team experience and app size