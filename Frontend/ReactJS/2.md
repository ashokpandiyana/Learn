# Chapter 2: Props and State - In-Depth Explanation

## 2.1 Props (Properties)

### What are Props?

Props (short for "properties") are **arguments passed to React components**. They work like function parameters and allow you to pass data from parent to child components.

**Think of props like this:**
```
HTML attributes:  <img src="photo.jpg" alt="My Photo" />
React props:      <UserCard name="John" age={25} isActive={true} />
```

### The Fundamental Concept

```javascript
// Props flow DOWN (parent to child)
function Parent() {
  return <Child message="Hello from parent" />;
}

// Child receives props as an object
function Child(props) {
  return <h1>{props.message}</h1>;
}

// Output: <h1>Hello from parent</h1>
```

**Visualizing Data Flow:**
```
┌─────────────────┐
│   Parent        │
│  data = "Hi"    │
└────────┬────────┘
         │ props={data}
         ▼
┌─────────────────┐
│   Child         │
│  receives "Hi"  │
└─────────────────┘
```

### Passing Props: Complete Guide

**1. String Props**
```javascript
// No curly braces needed for strings
<Button text="Click me" />
<Button text='Click me' />

// With curly braces (also valid but unnecessary)
<Button text={"Click me"} />
```

**2. Number Props**
```javascript
// Must use curly braces
<ProductCard price={99.99} quantity={5} />

// ❌ Wrong: This passes STRING "99.99"
<ProductCard price="99.99" />
```

**3. Boolean Props**
```javascript
// Explicit true
<Button disabled={true} />

// Shorthand (recommended)
<Button disabled />  // Same as disabled={true}

// Explicit false
<Button disabled={false} />
```

**4. Object Props**
```javascript
const user = {
  name: 'John',
  age: 25,
  email: 'john@example.com'
};

// Passing entire object
<UserProfile user={user} />

// Spreading object properties
<UserProfile {...user} />
// Same as: <UserProfile name="John" age={25} email="john@example.com" />
```

**5. Array Props**
```javascript
const colors = ['red', 'green', 'blue'];
const numbers = [1, 2, 3, 4, 5];

<ColorPicker colors={colors} />
<NumberList items={numbers} />
```

**6. Function Props (Callbacks)**
```javascript
function Parent() {
  const handleClick = () => {
    console.log('Button clicked!');
  };
  
  return <Button onClick={handleClick} />;
}

function Button({ onClick }) {
  return <button onClick={onClick}>Click me</button>;
}
```

**7. Component Props**
```javascript
// Passing components as props
<Layout 
  header={<Header />}
  sidebar={<Sidebar />}
  content={<MainContent />}
/>

function Layout({ header, sidebar, content }) {
  return (
    <div>
      <div className="header">{header}</div>
      <div className="sidebar">{sidebar}</div>
      <div className="content">{content}</div>
    </div>
  );
}
```

### Props Destructuring

Props destructuring makes code cleaner and more readable.

**Without Destructuring:**
```javascript
function Welcome(props) {
  return (
    <div>
      <h1>Hello, {props.name}!</h1>
      <p>You are {props.age} years old.</p>
      <p>Email: {props.email}</p>
    </div>
  );
}
```

**With Destructuring (Recommended):**
```javascript
// Method 1: In parameter
function Welcome({ name, age, email }) {
  return (
    <div>
      <h1>Hello, {name}!</h1>
      <p>You are {age} years old.</p>
      <p>Email: {email}</p>
    </div>
  );
}

// Method 2: In function body
function Welcome(props) {
  const { name, age, email } = props;
  
  return (
    <div>
      <h1>Hello, {name}!</h1>
      <p>You are {age} years old.</p>
      <p>Email: {email}</p>
    </div>
  );
}
```

**Advanced Destructuring:**
```javascript
// With default values
function Button({ text = "Click me", type = "primary", disabled = false }) {
  return <button className={type} disabled={disabled}>{text}</button>;
}

// With rest operator (collect remaining props)
function Button({ text, ...otherProps }) {
  return <button {...otherProps}>{text}</button>;
}
// Usage: <Button text="Submit" className="btn" id="submit-btn" />
// otherProps will be: { className: "btn", id: "submit-btn" }

// Nested destructuring
function UserCard({ user: { name, age, address: { city } } }) {
  return (
    <div>
      <h2>{name}, {age}</h2>
      <p>Lives in {city}</p>
    </div>
  );
}
```

### Children Prop

The `children` prop is a **special prop** that represents the content between component tags.

**Basic Example:**
```javascript
function Card({ children }) {
  return (
    <div className="card">
      {children}
    </div>
  );
}

// Usage
<Card>
  <h2>Title</h2>
  <p>This is the content</p>
</Card>

// children will be:
// <>
//   <h2>Title</h2>
//   <p>This is the content</p>
// </>
```

**Practical Examples:**

**1. Layout Components:**
```javascript
function Container({ children }) {
  return <div className="container max-w-6xl mx-auto px-4">{children}</div>;
}

function Section({ title, children }) {
  return (
    <section>
      <h2>{title}</h2>
      <div className="content">{children}</div>
    </section>
  );
}

// Usage
<Container>
  <Section title="About">
    <p>This is the about section.</p>
  </Section>
  <Section title="Contact">
    <p>Contact information here.</p>
  </Section>
</Container>
```

**2. Button Wrapper:**
```javascript
function Button({ variant = 'primary', children, ...props }) {
  const styles = {
    primary: 'bg-blue-500 text-white',
    secondary: 'bg-gray-500 text-white',
    danger: 'bg-red-500 text-white'
  };
  
  return (
    <button className={`px-4 py-2 rounded ${styles[variant]}`} {...props}>
      {children}
    </button>
  );
}

// Usage - children can be text, elements, or both
<Button variant="primary">Submit</Button>
<Button variant="danger">
  <TrashIcon /> Delete
</Button>
```

**3. Modal/Dialog:**
```javascript
function Modal({ isOpen, onClose, children }) {
  if (!isOpen) return null;
  
  return (
    <div className="modal-overlay">
      <div className="modal-content">
        {children}
        <button onClick={onClose}>Close</button>
      </div>
    </div>
  );
}

// Usage
<Modal isOpen={showModal} onClose={handleClose}>
  <h2>Confirm Action</h2>
  <p>Are you sure you want to continue?</p>
  <Button>Confirm</Button>
</Modal>
```

### Prop Types and Validation

PropTypes help catch bugs by validating props during development.

**Installation:**
```bash
npm install prop-types
```

**Basic Usage:**
```javascript
import PropTypes from 'prop-types';

function UserProfile({ name, age, email, isActive }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>Age: {age}</p>
      <p>Email: {email}</p>
      <p>Status: {isActive ? 'Active' : 'Inactive'}</p>
    </div>
  );
}

// Define prop types
UserProfile.propTypes = {
  name: PropTypes.string.isRequired,    // Required string
  age: PropTypes.number.isRequired,     // Required number
  email: PropTypes.string,              // Optional string
  isActive: PropTypes.bool              // Optional boolean
};
```

**All PropTypes:**
```javascript
Component.propTypes = {
  // Basic types
  stringProp: PropTypes.string,
  numberProp: PropTypes.number,
  boolProp: PropTypes.bool,
  functionProp: PropTypes.func,
  arrayProp: PropTypes.array,
  objectProp: PropTypes.object,
  symbolProp: PropTypes.symbol,
  
  // Anything renderable
  nodeProp: PropTypes.node,  // numbers, strings, elements, array
  elementProp: PropTypes.element,  // React element
  
  // Instance of a class
  instanceProp: PropTypes.instanceOf(Date),
  
  // Enum (one of specific values)
  enumProp: PropTypes.oneOf(['News', 'Photos', 'Videos']),
  
  // Union type
  unionProp: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.number,
    PropTypes.instanceOf(Message)
  ]),
  
  // Array of specific type
  arrayOfProp: PropTypes.arrayOf(PropTypes.number),
  
  // Object with specific shape
  objectOfProp: PropTypes.objectOf(PropTypes.number),
  
  // Object with exact shape
  shapeProp: PropTypes.shape({
    name: PropTypes.string,
    age: PropTypes.number
  }),
  
  // Exact shape (no extra properties)
  exactProp: PropTypes.exact({
    name: PropTypes.string,
    age: PropTypes.number
  }),
  
  // Required
  requiredProp: PropTypes.string.isRequired,
  
  // Custom validator
  customProp: function(props, propName, componentName) {
    if (!/^[A-Z]/.test(props[propName])) {
      return new Error(
        `Invalid prop '${propName}' in '${componentName}'. Must start with capital letter.`
      );
    }
  }
};
```

**Practical Example:**
```javascript
function ProductCard({ product, onAddToCart, featured }) {
  return (
    <div className={featured ? 'featured' : ''}>
      <h3>{product.name}</h3>
      <p>${product.price}</p>
      <button onClick={() => onAddToCart(product.id)}>Add to Cart</button>
    </div>
  );
}

ProductCard.propTypes = {
  product: PropTypes.shape({
    id: PropTypes.number.isRequired,
    name: PropTypes.string.isRequired,
    price: PropTypes.number.isRequired,
    description: PropTypes.string,
    imageUrl: PropTypes.string
  }).isRequired,
  onAddToCart: PropTypes.func.isRequired,
  featured: PropTypes.bool
};
```

**Note:** PropTypes only run in development mode. In production builds, they are removed for performance.

### Default Props

Default props provide fallback values when props aren't passed.

**Method 1: Default Parameters (Modern Approach)**
```javascript
function Button({ 
  text = "Click me", 
  variant = "primary", 
  disabled = false 
}) {
  return (
    <button className={variant} disabled={disabled}>
      {text}
    </button>
  );
}

// Usage - all these work:
<Button />  // Uses all defaults
<Button text="Submit" />  // Uses variant and disabled defaults
<Button text="Delete" variant="danger" />  // Uses disabled default
```

**Method 2: defaultProps (Legacy but still valid)**
```javascript
function Button({ text, variant, disabled }) {
  return (
    <button className={variant} disabled={disabled}>
      {text}
    </button>
  );
}

Button.defaultProps = {
  text: "Click me",
  variant: "primary",
  disabled: false
};
```

**Complex Default Props:**
```javascript
function UserList({ 
  users = [], 
  itemsPerPage = 10,
  sortBy = 'name',
  filter = { active: true }
}) {
  return (
    <div>
      {/* List implementation */}
    </div>
  );
}
```

### Props are Read-Only (Immutable)

**Critical Rule:** You must NEVER modify props.

```javascript
// ❌ WRONG: Mutating props
function WrongComponent({ user }) {
  user.name = "Modified";  // ❌ DON'T DO THIS!
  user.age++;              // ❌ DON'T DO THIS!
  
  return <div>{user.name}</div>;
}

// ✅ CORRECT: Use props as-is
function CorrectComponent({ user }) {
  return <div>{user.name}</div>;
}

// ✅ CORRECT: Create new values based on props
function CorrectComponent({ user }) {
  const displayName = user.name.toUpperCase();  // Create new value
  const nextAge = user.age + 1;                 // Create new value
  
  return (
    <div>
      <p>{displayName}</p>
      <p>Next year: {nextAge}</p>
    </div>
  );
}
```

**Why Props are Immutable:**
1. **Predictability**: Parent controls data
2. **Debugging**: Easier to track data changes
3. **Performance**: React can optimize re-renders
4. **Unidirectional data flow**: Clear data direction

### Unidirectional Data Flow

Data flows in ONE direction: **Parent → Child**

```javascript
// Data flows DOWN
function App() {
  const userData = { name: "John", age: 25 };
  
  return (
    <div>
      {/* Data flows from App to UserProfile */}
      <UserProfile user={userData} />
    </div>
  );
}

function UserProfile({ user }) {
  return (
    <div>
      {/* Data flows from UserProfile to Avatar */}
      <Avatar name={user.name} />
      <UserInfo age={user.age} />
    </div>
  );
}
```

**Visual Representation:**
```
         App (data source)
          │
          ├─ userData
          ↓
      UserProfile
      ↓           ↓
   Avatar      UserInfo
   (name)      (age)
```

**Child-to-Parent Communication (via callbacks):**
```javascript
// Parent defines the handler
function Parent() {
  const [message, setMessage] = useState('');
  
  const handleMessageFromChild = (msg) => {
    setMessage(msg);
  };
  
  return (
    <div>
      <p>Message from child: {message}</p>
      {/* Pass function DOWN as prop */}
      <Child onSendMessage={handleMessageFromChild} />
    </div>
  );
}

// Child calls the function
function Child({ onSendMessage }) {
  return (
    <button onClick={() => onSendMessage('Hello Parent!')}>
      Send Message
    </button>
  );
}
```

**Important:** Even though child "sends data up", the mechanism (the function) flows down. This maintains unidirectional data flow.

---

## 2.2 State

### What is State?

State is **data that changes over time** within a component. Unlike props (which come from parent), state is **owned and managed by the component itself**.

**Props vs State:**
```
Props:
- Passed from parent
- Read-only
- External to component

State:
- Created inside component
- Can be changed
- Internal to component
```

### useState Hook

The `useState` hook is how you add state to functional components.

**Basic Syntax:**
```javascript
import { useState } from 'react';

function Counter() {
  // [stateVariable, setterFunction] = useState(initialValue)
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

**How it Works:**
```
1. First Render:
   useState(0) → returns [0, setCount]
   count = 0

2. User clicks button:
   setCount(count + 1) → setCount(1)

3. React re-renders:
   useState(0) → returns [1, setCount]  // Remembers previous value!
   count = 1

4. Component renders with new count
```

### useState Examples

**1. Different Data Types:**
```javascript
function Component() {
  // String
  const [name, setName] = useState('John');
  
  // Number
  const [age, setAge] = useState(25);
  
  // Boolean
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  
  // Array
  const [items, setItems] = useState([]);
  
  // Object
  const [user, setUser] = useState({
    name: 'John',
    email: 'john@example.com'
  });
  
  // Null
  const [data, setData] = useState(null);
  
  return <div>Component content</div>;
}
```

**2. Toggle Boolean:**
```javascript
function ToggleButton() {
  const [isOn, setIsOn] = useState(false);
  
  // Method 1: Set to opposite
  const toggle = () => setIsOn(!isOn);
  
  // Method 2: Functional update (better)
  const toggle2 = () => setIsOn(prev => !prev);
  
  return (
    <button onClick={toggle}>
      {isOn ? 'ON' : 'OFF'}
    </button>
  );
}
```

**3. Form Input:**
```javascript
function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Login:', { email, password });
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input 
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
      />
      <input 
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
      />
      <button type="submit">Login</button>
    </form>
  );
}
```

### Lazy Initialization

When initial state requires expensive computation, use lazy initialization.

```javascript
// ❌ Expensive calculation runs every render
function Component() {
  const [data, setData] = useState(expensiveCalculation());
  // expensiveCalculation() runs EVERY RENDER!
}

// ✅ Calculation only runs once
function Component() {
  const [data, setData] = useState(() => expensiveCalculation());
  // expensiveCalculation() runs ONLY ON FIRST RENDER
}

// Example
function ExpensiveComponent() {
  const [items, setItems] = useState(() => {
    console.log('Computing initial state...');
    const stored = localStorage.getItem('items');
    return stored ? JSON.parse(stored) : [];
  });
  
  return <div>{items.length} items</div>;
}
```

### State Immutability

**Critical Rule:** NEVER mutate state directly. Always create a new value.

**Why Immutability Matters:**
```javascript
// Example of mutation problem
const [user, setUser] = useState({ name: 'John', age: 25 });

// ❌ WRONG: Direct mutation
user.age = 26;
setUser(user);  // React won't detect the change! No re-render!

// ✅ CORRECT: Create new object
setUser({ ...user, age: 26 });  // React detects new object, re-renders
```

**Updating Objects:**
```javascript
const [user, setUser] = useState({
  name: 'John',
  age: 25,
  address: {
    city: 'New York',
    zip: '10001'
  }
});

// ❌ WRONG: Mutation
user.age = 26;
setUser(user);

// ✅ CORRECT: Shallow update
setUser({ ...user, age: 26 });

// ✅ CORRECT: Nested update
setUser({
  ...user,
  address: {
    ...user.address,
    city: 'Los Angeles'
  }
});

// ✅ CORRECT: Multiple properties
setUser({
  ...user,
  age: 26,
  name: 'John Doe'
});
```

**Updating Arrays:**
```javascript
const [items, setItems] = useState([1, 2, 3]);

// ❌ WRONG: These mutate the array
items.push(4);
items.pop();
items[0] = 10;
items.sort();
items.reverse();

// ✅ CORRECT: Create new array

// Add item
setItems([...items, 4]);
setItems([4, ...items]);  // Add to beginning

// Remove item (by index)
setItems(items.filter((_, index) => index !== 0));

// Remove item (by value)
setItems(items.filter(item => item !== 2));

// Update item
setItems(items.map((item, index) => 
  index === 0 ? 10 : item
));

// Sort (create new sorted array)
setItems([...items].sort((a, b) => a - b));

// Reverse
setItems([...items].reverse());

// Replace entire array
setItems([10, 20, 30]);
```

**Complex Example:**
```javascript
const [todos, setTodos] = useState([
  { id: 1, text: 'Learn React', done: false },
  { id: 2, text: 'Build Project', done: false }
]);

// Add todo
const addTodo = (text) => {
  const newTodo = {
    id: Date.now(),
    text,
    done: false
  };
  setTodos([...todos, newTodo]);
};

// Toggle todo
const toggleTodo = (id) => {
  setTodos(todos.map(todo =>
    todo.id === id ? { ...todo, done: !todo.done } : todo
  ));
};

// Delete todo
const deleteTodo = (id) => {
  setTodos(todos.filter(todo => todo.id !== id));
};

// Update todo text
const updateTodo = (id, newText) => {
  setTodos(todos.map(todo =>
    todo.id === id ? { ...todo, text: newText } : todo
  ));
};
```

### State Updates are Asynchronous

State updates don't happen immediately – they're batched for performance.

```javascript
function Counter() {
  const [count, setCount] = useState(0);
  
  const handleClick = () => {
    console.log('Before:', count);  // 0
    setCount(count + 1);
    console.log('After:', count);   // Still 0! (not 1)
    // State hasn't updated yet!
  };
  
  // Next render:
  console.log('Render:', count);  // 1
  
  return (
    <div>
      <p>{count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}
```

**Batching (React 18+):**
```javascript
function handleClick() {
  setCount(count + 1);  // 0 + 1 = 1
  setCount(count + 1);  // 0 + 1 = 1 (still uses 0!)
  setCount(count + 1);  // 0 + 1 = 1 (still uses 0!)
  // Final count: 1 (not 3!)
}
```

### Functional Updates

**Use functional updates when new state depends on previous state.**

```javascript
const [count, setCount] = useState(0);

// ❌ WRONG: Can give wrong result due to batching
const increment = () => {
  setCount(count + 1);
  setCount(count + 1);  // Uses stale count
  setCount(count + 1);  // Uses stale count
  // Result: count + 1 (not count + 3)
};

// ✅ CORRECT: Functional update
const increment = () => {
  setCount(prev => prev + 1);  // prev is always current
  setCount(prev => prev + 1);  // prev is previous call's result
  setCount(prev => prev + 1);  // prev is previous call's result
  // Result: count + 3 ✓
};
```

**More Examples:**
```javascript
// Toggle
setIsOpen(prev => !prev);

// Increment by value
const incrementBy = (value) => {
  setCount(prev => prev + value);
};

// Array operations
setItems(prev => [...prev, newItem]);
setItems(prev => prev.filter(item => item.id !== id));
setItems(prev => prev.map(item => 
  item.id === id ? { ...item, done: !item.done } : item
));

// Object updates
setUser(prev => ({ ...prev, age: prev.age + 1 }));
```

**When to Use Functional Updates:**
- State update depends on previous state
- Inside event handlers that might be called multiple times
- In async functions or timeouts
- When working with closures

**Example Problem:**
```javascript
function Timer() {
  const [seconds, setSeconds] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      // ❌ WRONG: Closure captures initial seconds (0)
      setSeconds(seconds + 1);
      // Always sets to 1!
      
      // ✅ CORRECT: Uses current value
      setSeconds(prev => prev + 1);
    }, 1000);
    
    return () => clearInterval(interval);
  }, []);  // Empty deps - runs once
  
  return <div>{seconds}</div>;
}
```

---

## 2.3 Conditional Rendering

### If/Else Statements

Use if/else **outside JSX** for complex logic.

```javascript
function Greeting({ isLoggedIn }) {
  // Method 1: Before return
  if (isLoggedIn) {
    return <h1>Welcome back!</h1>;
  }
  return <h1>Please sign up.</h1>;
  
  // Method 2: Variable
  let message;
  if (isLoggedIn) {
    message = <h1>Welcome back!</h1>;
  } else {
    message = <h1>Please sign up.</h1>;
  }
  return <div>{message}</div>;
}
```

**Multiple Conditions:**
```javascript
function UserStatus({ user }) {
  if (!user) {
    return <div>Loading...</div>;
  }
  
  if (user.banned) {
    return <div>Account suspended</div>;
  }
  
  if (!user.verified) {
    return <div>Please verify your email</div>;
  }
  
  return <div>Welcome, {user.name}!</div>;
}
```

### Ternary Operators

For **if-else** logic **inside JSX**.

```javascript
function Message({ isSuccess }) {
  return (
    <div>
      {isSuccess ? (
        <span className="success">✓ Success!</span>
      ) : (
        <span className="error">✗ Failed</span>
      )}
    </div>
  );
}

// Nested ternary (use sparingly!)
function Status({ status }) {
  return (
    <div>
      {status === 'loading' ? (
        <Spinner />
      ) : status === 'success' ? (
        <SuccessMessage />
      ) : (
        <ErrorMessage />
      )}
    </div>
  );
}
```

### Logical AND (&&) Operator

For **if-only** (no else) logic inside JSX.

```javascript
function Notifications({ count }) {
  return (
    <div>
      {count > 0 && (
        <span className="badge">{count} new messages</span>
      )}
    </div>
  );
}

// Multiple conditions
function Profile({ user }) {
  return (
    <div>
      {user && user.isVerified && (
        <span className="verified">✓ Verified</span>
      )}
    </div>
  );
}
```

**IMPORTANT GOTCHA:**
```javascript
function Component({ count }) {
  // ❌ Problem: When count = 0, renders "0"
  return (
    <div>
      {count && <div>{count} items</div>}
    </div>
  );
  // When count = 0: renders "0"
  // When count = 5: renders "5 items"
  
  // ✅ Solution: Use explicit comparison
  return (
    <div>
      {count > 0 && <div>{count} items</div>}
    </div>
  );
  // When count = 0: renders nothing
  // When count = 5: renders "5 items"
}
```

**Why This Happens:**
- `0 && <div>...</div>` evaluates to `0` (falsy, but React renders it)
- `false && <div>...</div>` evaluates to `false` (React doesn't render)
- `null && <div>...</div>` evaluates to `null` (React doesn't render)

**Falsy Values in React:**
```javascript
function FalsyDemo() {
  return (
    <div>
      {false}      {/* Renders nothing */}
      {null}       {/* Renders nothing */}
      {undefined}  {/* Renders nothing */}
      {true}       {/* Renders nothing */}
      {0}          {/* Renders "0" ⚠️ */}
      {''}         {/* Renders nothing */}
      {NaN}        {/* Renders "NaN" ⚠️ */}
    </div>
  );
}
```

### Switch Statements

For **multiple conditions** with same value.

```javascript
function StatusIcon({ status }) {
  // Method 1: Switch with early return
  switch (status) {
    case 'loading':
      return <LoadingSpinner />;
    case 'success':
      return <SuccessIcon />;
    case 'error':
      return <ErrorIcon />;
    case 'warning':
      return <WarningIcon />;
    default:
      return <DefaultIcon />;
  }
}

// Method 2: Object mapping (cleaner)
function StatusIcon({ status }) {
  const icons = {
    loading: <LoadingSpinner />,
    success: <SuccessIcon />,
    error: <ErrorIcon />,
    warning: <WarningIcon />
  };
  
  return icons[status] || <DefaultIcon />;
}

// Method 3: Component mapping
function StatusIcon({ status }) {
  const IconComponent = {
    loading: LoadingSpinner,
    success: SuccessIcon,
    error: ErrorIcon,
    warning: WarningIcon
  }[status] || DefaultIcon;
  
  return <IconComponent />;
}
```

---

## 2.4 Lists and Keys

### Rendering Lists with map()

The `map()` method transforms arrays into JSX elements.

**Basic Example:**
```javascript
function NumberList() {
  const numbers = [1, 2, 3, 4, 5];
  
  return (
    <ul>
      {numbers.map(number => (
        <li key={number}>{number}</li>
      ))}
    </ul>
  );
}
```

**With Complex Data:**
```javascript
function UserList() {
  const users = [
    { id: 1, name: 'Alice', email: 'alice@example.com' },
    { id: 2, name: 'Bob', email: 'bob@example.com' },
    { id: 3, name: 'Carol', email: 'carol@example.com' }
  ];
  
  return (
    <div>
      {users.map(user => (
        <div key={user.id} className="user-card">
          <h3>{user.name}</h3>
          <p>{user.email}</p>
        </div>
      ))}
    </div>
  );
}
```

**With Component:**
```javascript
function TodoItem({ todo }) {
  return (
    <div className="todo">
      <input type="checkbox" checked={todo.done} />
      <span>{todo.text}</span>
    </div>
  );
}

function TodoList() {
  const todos = [
    { id: 1, text: 'Learn React', done: false },
    { id: 2, text: 'Build Project', done: true }
  ];
  
  return (
    <div>
      {todos.map(todo => (
        <TodoItem key={todo.id} todo={todo} />
      ))}
    </div>
  );
}
```

### Key Prop Importance

**Keys help React identify which items changed, were added, or removed.**

**Without Keys (DON'T DO THIS):**
```javascript
// ❌ Warning: Each child should have a unique "key" prop
<ul>
  {items.map(item => (
    <li>{item}</li>
  ))}
</ul>
```

**What Happens Without Keys:**
```
Initial:
[<li>A</li>, <li>B</li>, <li>C</li>]

Add item at beginning:
[<li>NEW</li>, <li>A</li>, <li>B</li>, <li>C</li>]

Without keys, React thinks:
- First <li> changed from "A" to "NEW"
- Second <li> changed from "B" to "A"
- Third <li> changed from "C" to "B"
- Fourth <li> was added with "C"

Result: Inefficient - updates ALL items instead of just inserting one!
```

**With Keys (CORRECT):**
```javascript
// ✅ With keys
<ul>
  {items.map(item => (
    <li key={item.id}>{item.text}</li>
  ))}
</ul>
```

**What Happens With Keys:**
```
Initial:
[<li key="1">A</li>, <li key="2">B</li>, <li key="3">C</li>]

Add item at beginning:
[<li key="4">NEW</li>, <li key="1">A</li>, <li key="2">B</li>, <li key="3">C</li>]

With keys, React knows:
- Item key="4" is NEW → Insert at beginning
- Items key="1", "2", "3" didn't change → Reuse existing DOM

Result: Efficient - only inserts one new item!
```

### Key Requirements

**Keys must be:**

1. **Unique** among siblings
```javascript
// ✅ Unique IDs
{users.map(user => <div key={user.id}>{user.name}</div>)}

// ❌ Duplicate keys
{users.map(user => <div key="same">{user.name}</div>)}
```

2. **Stable** (don't change between renders)
```javascript
// ❌ Random keys change every render
{items.map(item => <div key={Math.random()}>{item}</div>)}

// ✅ Stable ID
{items.map(item => <div key={item.id}>{item}</div>)}
```

3. **Predictable** (same item = same key)
```javascript
// ✅ Based on data
{items.map(item => <div key={item.id}>{item}</div>)}

// ❌ Based on render count (unpredictable)
{items.map((item, i) => <div key={renderCount++}>{item}</div>)}
```

### Index as Key (When and Why to Avoid)

**When Index is OK:**
- List never reorders
- List never filters
- List never adds/removes items
- Items have no IDs
- List is static

```javascript
// ✅ OK: Static list
const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May'];
{months.map((month, index) => (
  <option key={index} value={index}>{month}</option>
))}
```

**When Index is BAD:**
- List can reorder
- Items can be added/removed
- Items have state or form inputs

```javascript
// ❌ BAD: Dynamic todo list
function TodoList() {
  const [todos, setTodos] = useState([
    { text: 'Task 1' },
    { text: 'Task 2' }
  ]);
  
  // Problem: If user removes first item, indices shift!
  return (
    <div>
      {todos.map((todo, index) => (
        <TodoItem key={index} todo={todo} />
      ))}
    </div>
  );
}
```

**Why Index Keys Cause Problems:**
```
Initial state (with index keys):
[
  <input key={0} value="Task 1" />,
  <input key={1} value="Task 2" />,
  <input key={2} value="Task 3" />
]

User types in second input: "Task 2 - UPDATED"

Then removes first item:
[
  <input key={0} value="Task 2 - UPDATED" />,  // This was key={1}!
  <input key={1} value="Task 3" />              // This was key={2}!
]

React sees:
- key={0} still exists → REUSE existing DOM node
- But that DOM node has "Task 1" value!
- Result: Wrong input gets the value!
```

**Solution: Use Stable IDs:**
```javascript
// ✅ GOOD: Unique IDs
const [todos, setTodos] = useState([
  { id: 1, text: 'Task 1' },
  { id: 2, text: 'Task 2' },
  { id: 3, text: 'Task 3' }
]);

return (
  <div>
    {todos.map(todo => (
      <TodoItem key={todo.id} todo={todo} />
    ))}
  </div>
);
```

**Generating IDs:**
```javascript
// Method 1: UUID library
import { v4 as uuidv4 } from 'uuid';
const id = uuidv4();

// Method 2: Date.now() (good for single-threaded)
const id = Date.now();

// Method 3: Incremental counter
let nextId = 1;
const id = nextId++;

// Method 4: Database ID (best for persisted data)
const id = item.id;  // From API
```

### Complete List Example

```javascript
function ShoppingList() {
  const [items, setItems] = useState([
    { id: 1, name: 'Apples', quantity: 5, purchased: false },
    { id: 2, name: 'Bread', quantity: 2, purchased: false },
    { id: 3, name: 'Milk', quantity: 1, purchased: true }
  ]);
  
  const [nextId, setNextId] = useState(4);
  
  // Add item
  const addItem = (name, quantity) => {
    const newItem = {
      id: nextId,
      name,
      quantity,
      purchased: false
    };
    setItems([...items, newItem]);
    setNextId(nextId + 1);
  };
  
  // Toggle purchased
  const togglePurchased = (id) => {
    setItems(items.map(item =>
      item.id === id ? { ...item, purchased: !item.purchased } : item
    ));
  };
  
  // Delete item
  const deleteItem = (id) => {
    setItems(items.filter(item => item.id !== id));
  };
  
  // Update quantity
  const updateQuantity = (id, newQuantity) => {
    setItems(items.map(item =>
      item.id === id ? { ...item, quantity: newQuantity } : item
    ));
  };
  
  return (
    <div className="shopping-list">
      <h2>Shopping List</h2>
      
      {/* List */}
      <ul>
        {items.map(item => (
          <li key={item.id} className={item.purchased ? 'purchased' : ''}>
            <input 
              type="checkbox"
              checked={item.purchased}
              onChange={() => togglePurchased(item.id)}
            />
            <span>{item.name}</span>
            <input 
              type="number"
              value={item.quantity}
              onChange={(e) => updateQuantity(item.id, parseInt(e.target.value))}
            />
            <button onClick={() => deleteItem(item.id)}>Delete</button>
          </li>
        ))}
      </ul>
      
      {/* Conditional: Empty state */}
      {items.length === 0 && (
        <p className="empty">No items in list. Add some!</p>
      )}
      
      {/* Summary */}
      <div className="summary">
        <p>Total items: {items.length}</p>
        <p>Purchased: {items.filter(i => i.purchased).length}</p>
        <p>Remaining: {items.filter(i => !i.purchased).length}</p>
      </div>
    </div>
  );
}
```

---

## Summary of Chapter 2

**Key Takeaways:**

1. **Props**: Read-only data passed from parent to child
2. **Children Prop**: Special prop for content between tags
3. **Props are Immutable**: Never modify props directly
4. **Unidirectional Data Flow**: Data flows parent → child
5. **State**: Component's own changeable data
6. **useState**: Hook for adding state to functional components
7. **State Immutability**: Always create new values, never mutate
8. **Functional Updates**: Use when new state depends on old state
9. **Conditional Rendering**: Ternary, &&, if/else, switch
10. **Lists**: Use map() with unique keys
11. **Keys**: Stable, unique, predictable - avoid index when possible

**Common Mistakes:**
- ❌ Mutating props
- ❌ Mutating state directly
- ❌ Using index as key for dynamic lists
- ❌ Not using functional updates when needed
- ❌ Forgetting keys in lists
- ❌ Using `count &&` instead of `count > 0 &&`

**Practice Exercises:**

Build these to master Chapter 2:
1. User profile card with editable fields (state + forms)
2. Todo list with add/remove/toggle (lists + keys + state)
3. Shopping cart with quantities (complex state)
4. Filterable product list (conditional rendering + lists)
5. Multi-step form (state management)