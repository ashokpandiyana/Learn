# Chapter 23: Common Interview Questions

This chapter covers the most frequently asked React interview questions with in-depth explanations and practical examples.

---

## 23.1 Conceptual Questions

### Q1: Explain the Virtual DOM and how it works

**Answer:**

The Virtual DOM is a lightweight JavaScript representation of the actual DOM. It's a programming concept where a "virtual" representation of the UI is kept in memory and synced with the real DOM through a process called reconciliation.

**How it Works:**

1. **Initial Render:**
   - React creates a virtual DOM tree
   - Converts it to real DOM
   - Displays on screen

2. **Update Process:**
   - State or props change
   - React creates a new virtual DOM tree
   - Compares new tree with previous tree (diffing)
   - Calculates minimal changes needed
   - Updates only changed parts in real DOM

**Example:**

```javascript
// Initial state
<div>
  <h1>Hello</h1>
  <p>Count: 0</p>
</div>

// After state update (count becomes 1)
<div>
  <h1>Hello</h1>
  <p>Count: 1</p>  {/* Only this changes */}
</div>

// React only updates the text content of <p>,
// not the entire div or h1
```

**Visual Representation:**

```
State Change → New Virtual DOM → Diffing Algorithm
                                       ↓
                              Find Differences
                                       ↓
                           Update Real DOM (minimal changes)
```

**Why Virtual DOM?**

```javascript
// Without Virtual DOM (jQuery style)
// Every change touches real DOM - SLOW
$('#count').text(newCount);
$('#list').append('<li>item</li>');
$('#title').css('color', 'red');

// With Virtual DOM (React)
// Batches changes, updates once - FAST
setState({ count: newCount });
// React batches multiple setState calls
// Updates real DOM in one efficient operation
```

**Key Benefits:**
- ✅ Faster updates (batch processing)
- ✅ Minimal DOM manipulation
- ✅ Better performance for complex UIs
- ✅ Cross-platform (React Native uses same concept)

---

### Q2: What is Reconciliation and the Diffing Algorithm?

**Answer:**

Reconciliation is the process React uses to update the DOM efficiently. The diffing algorithm compares two virtual DOM trees to find the minimum number of operations needed to transform one tree into another.

**The Diffing Algorithm Rules:**

**Rule 1: Different Element Types**
```javascript
// Before
<div>
  <Counter />
</div>

// After
<span>
  <Counter />
</span>

// React tears down the entire old tree and builds new one
// Counter component is unmounted and remounted
// State is lost!
```

**Rule 2: Same Element Type, Different Props**
```javascript
// Before
<div className="before" title="old" />

// After
<div className="after" title="new" />

// React keeps same DOM node
// Only updates changed attributes
// Component instance stays the same
// State is preserved
```

**Rule 3: Recursing on Children**
```javascript
// Inefficient - adds element at beginning
<ul>
  <li>Duke</li>
  <li>Villanova</li>
</ul>

// After adding Connecticut at the start
<ul>
  <li>Connecticut</li>  {/* React recreates ALL items */}
  <li>Duke</li>
  <li>Villanova</li>
</ul>

// This is why keys are important!
```

**Keys Make Reconciliation Efficient:**

```javascript
// With keys - efficient
<ul>
  <li key="duke">Duke</li>
  <li key="villanova">Villanova</li>
</ul>

// After
<ul>
  <li key="connecticut">Connecticut</li>  {/* React inserts only this */}
  <li key="duke">Duke</li>                {/* Reuses existing */}
  <li key="villanova">Villanova</li>      {/* Reuses existing */}
</ul>

// React knows duke and villanova haven't changed
// Only inserts connecticut
```

**Time Complexity:**
- Traditional diff algorithms: O(n³)
- React's diff algorithm: O(n)
- React achieves this through heuristics

**Example with Performance Impact:**

```javascript
// ❌ Bad - No keys
function BadList({ items }) {
  return (
    <ul>
      {items.map(item => (
        <li>
          <input type="checkbox" />
          {item.name}
        </li>
      ))}
    </ul>
  );
}

// If items reorder, checkbox states get mixed up!

// ✅ Good - With keys
function GoodList({ items }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>
          <input type="checkbox" />
          {item.name}
        </li>
      ))}
    </ul>
  );
}
```

---

### Q3: Explain React Fiber Architecture

**Answer:**

Fiber is React's reconciliation engine, introduced in React 16. It's a complete rewrite of React's core algorithm that enables incremental rendering.

**Problems Fiber Solves:**

**Before Fiber (Stack Reconciliation):**
```javascript
// Synchronous, blocking
function updateComponent() {
  // Start update
  reconcile(tree);  // Can't interrupt!
  // Update complete (blocks for milliseconds)
}

// Long updates block the main thread
// UI becomes unresponsive
// Animations drop frames
```

**With Fiber (Incremental Reconciliation):**
```javascript
// Asynchronous, interruptible
function updateComponent() {
  // Break work into units
  while (hasWorkRemaining && !shouldYield()) {
    performUnitOfWork();
  }
  
  // Yield to browser if needed
  if (shouldYield()) {
    scheduleCallback(continueWork);
  }
}
```

**Key Fiber Concepts:**

1. **Work Units**: Each component is a unit of work
2. **Priority Levels**: Different updates have different priorities
3. **Scheduling**: Can pause, resume, or abort work
4. **Time Slicing**: Spreads work across multiple frames

**Fiber Structure:**

```javascript
// Simplified fiber node structure
{
  type: 'div',           // Component type
  key: 'unique-key',     // Unique identifier
  props: { ... },        // Component props
  state: { ... },        // Component state
  
  // Tree structure
  child: fiberNode,      // First child
  sibling: fiberNode,    // Next sibling
  return: fiberNode,     // Parent
  
  // Effects
  effectTag: 'UPDATE',   // What needs to happen
  
  // Work tracking
  alternate: fiberNode,  // Previous fiber (for diffing)
  pendingProps: { ... }, // Incoming props
  memoizedProps: { ... },// Previous props
  memoizedState: { ... } // Previous state
}
```

**Priority Levels:**

```javascript
// React's priority levels (simplified)
const priorities = {
  Immediate: 0,        // Discrete events (click, input)
  UserBlocking: 1,     // User interactions
  Normal: 2,           // Network responses
  Low: 3,              // Data fetching
  Idle: 4              // Analytics, logging
};

// Example
onClick={() => {
  // Immediate priority
  setInputValue(e.target.value);
}}

useEffect(() => {
  // Low priority
  logAnalytics();
}, []);
```

**Practical Impact:**

```javascript
// With Fiber, this won't block UI
function HeavyComponent() {
  const [items] = useState(Array.from({ length: 10000 }));
  
  return (
    <div>
      {/* React can pause rendering if needed */}
      {items.map((_, i) => (
        <div key={i}>
          <ExpensiveComponent />
        </div>
      ))}
    </div>
  );
}

// Meanwhile, user interactions remain responsive
```

**Benefits:**
- ✅ Smooth animations
- ✅ Responsive UI during updates
- ✅ Better perceived performance
- ✅ Enables Concurrent Mode (React 18)
- ✅ Enables Suspense
- ✅ Better error handling

---

## 23.2 Hooks Rules

### Q: Why do Hooks have rules and what are they?

**Answer:**

Hooks have strict rules to ensure they work correctly. Breaking these rules can cause bugs that are hard to debug.

### The Two Golden Rules

**Rule 1: Only Call Hooks at the Top Level**

```javascript
// ❌ Wrong - Inside condition
function Component({ condition }) {
  if (condition) {
    const [state, setState] = useState(0);  // DON'T DO THIS
  }
  
  return <div>{state}</div>;
}

// Why is this bad?
// React relies on hook call order to match state
// If condition changes, hook order changes
// React gets confused about which state belongs to which hook

// ✅ Correct
function Component({ condition }) {
  const [state, setState] = useState(0);
  
  if (condition) {
    // Use the state here instead
    return <div>{state}</div>;
  }
  
  return null;
}
```

**More Examples of Rule 1 Violations:**

```javascript
// ❌ Wrong - Inside loop
for (let i = 0; i < 3; i++) {
  const [count, setCount] = useState(0);  // DON'T
}

// ❌ Wrong - Inside nested function
function Component() {
  const handleClick = () => {
    const [count, setCount] = useState(0);  // DON'T
  };
}

// ❌ Wrong - After early return
function Component({ isReady }) {
  if (!isReady) {
    return <Loading />;
  }
  
  const [data, setData] = useState(null);  // DON'T - after return
}

// ✅ Correct - hooks before any returns
function Component({ isReady }) {
  const [data, setData] = useState(null);
  
  if (!isReady) {
    return <Loading />;
  }
  
  return <div>{data}</div>;
}
```

**Why This Rule Exists:**

```javascript
// React internally maintains a list of hooks
// First render:
[
  useState(0),      // Hook 1
  useEffect(...),   // Hook 2
  useState(''),     // Hook 3
]

// If you conditionally call hooks:
// Second render (condition = false):
[
  // useState(0) - SKIPPED!
  useEffect(...),   // React thinks this is Hook 1 now!
  useState(''),     // React thinks this is Hook 2 now!
]

// State gets matched to wrong hooks = BUGS!
```

**Rule 2: Only Call Hooks from React Functions**

```javascript
// ❌ Wrong - Regular JavaScript function
function regularFunction() {
  const [state, setState] = useState(0);  // DON'T
}

// ❌ Wrong - Class method
class MyClass {
  method() {
    const [state, setState] = useState(0);  // DON'T
  }
}

// ✅ Correct - React component
function MyComponent() {
  const [state, setState] = useState(0);  // DO
}

// ✅ Correct - Custom hook
function useMyHook() {
  const [state, setState] = useState(0);  // DO
}
```

### ESLint Plugin

React provides an ESLint plugin to enforce these rules:

```bash
npm install eslint-plugin-react-hooks --save-dev
```

**.eslintrc.json:**
```json
{
  "plugins": ["react-hooks"],
  "rules": {
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn"
  }
}
```

### Common Violations and Fixes

**Problem: Conditional Hook Call**
```javascript
// ❌ Problem
function Component({ showModal }) {
  if (showModal) {
    const [modalData, setModalData] = useState(null);
  }
}

// ✅ Solution 1: Always call hook
function Component({ showModal }) {
  const [modalData, setModalData] = useState(null);
  
  if (showModal) {
    // Use the state
  }
}

// ✅ Solution 2: Separate component
function Component({ showModal }) {
  return showModal ? <ModalComponent /> : null;
}

function ModalComponent() {
  const [modalData, setModalData] = useState(null);
  // ...
}
```

**Problem: Hook in Callback**
```javascript
// ❌ Problem
function Component() {
  const handleClick = () => {
    const [clicked, setClicked] = useState(false);
  };
}

// ✅ Solution
function Component() {
  const [clicked, setClicked] = useState(false);
  
  const handleClick = () => {
    setClicked(true);
  };
}
```

**Problem: Hook After Early Return**
```javascript
// ❌ Problem
function Component({ error }) {
  if (error) {
    return <Error />;
  }
  
  const [data, setData] = useState(null);  // After return!
}

// ✅ Solution
function Component({ error }) {
  const [data, setData] = useState(null);  // Before returns
  
  if (error) {
    return <Error />;
  }
  
  return <div>{data}</div>;
}
```

### Dependency Array Rules

```javascript
// ❌ Wrong - Missing dependency
function Component({ userId }) {
  useEffect(() => {
    fetchUser(userId);  // userId is used but not in deps
  }, []);  // ESLint will warn
}

// ✅ Correct - Include all dependencies
function Component({ userId }) {
  useEffect(() => {
    fetchUser(userId);
  }, [userId]);
}

// ❌ Wrong - Unnecessary dependency
function Component() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    console.log('Effect ran');
  }, [setCount]);  // setCount never changes, unnecessary
}

// ✅ Correct - Only necessary dependencies
function Component() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    console.log('Count:', count);
  }, [count]);  // Only include what you use
}
```

### Why These Rules Matter

**Without Rules:**
```javascript
// This code looks fine but is broken
function BrokenComponent({ isLoggedIn }) {
  if (isLoggedIn) {
    const [user, setUser] = useState(null);
    useEffect(() => {
      fetchUser().then(setUser);
    }, []);
  }
  
  // When isLoggedIn changes from false to true:
  // - React tries to initialize new hooks
  // - But its internal hook index is already wrong
  // - State gets corrupted
  // - App crashes or behaves unexpectedly
}
```

**With Rules:**
```javascript
// Correctly structured
function WorkingComponent({ isLoggedIn }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    if (isLoggedIn) {
      fetchUser().then(setUser);
    }
  }, [isLoggedIn]);
  
  // Hooks always called in same order
  // React can correctly track state
  // App works reliably
}
```

---

## 23.3 Performance Questions

### Q: How do you identify and fix performance bottlenecks in React?

**Answer:**

**Step 1: Measure First**

```javascript
// Use React DevTools Profiler
// 1. Open React DevTools
// 2. Go to Profiler tab
// 3. Start recording
// 4. Perform slow action
// 5. Stop recording
// 6. Analyze flame graph

// Programmatic profiling
import { Profiler } from 'react';

function onRenderCallback(
  id,                  // component name
  phase,               // "mount" or "update"
  actualDuration,      // time spent rendering
  baseDuration,        // estimated time without memoization
  startTime,           // when React began rendering
  commitTime,          // when React committed update
  interactions         // Set of interactions
) {
  console.log(`${id} took ${actualDuration}ms to render`);
  
  // Send to analytics
  if (actualDuration > 16) {  // More than one frame
    sendToAnalytics({
      component: id,
      duration: actualDuration,
      phase
    });
  }
}

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <SlowComponent />
    </Profiler>
  );
}
```

**Step 2: Identify Issues**

Common performance problems:

1. **Unnecessary Re-renders**
2. **Large Lists Without Virtualization**
3. **Heavy Computations in Render**
4. **Large Bundle Size**
5. **Unoptimized Images**

**Step 3: Fix Unnecessary Re-renders**

```javascript
// Problem: Child re-renders even when props haven't changed
function Parent() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');
  
  // Creates new object every render
  const config = { theme: 'dark' };
  
  // Creates new function every render
  const handleClick = () => console.log('clicked');
  
  return (
    <div>
      <input value={text} onChange={e => setText(e.target.value)} />
      <Child config={config} onClick={handleClick} />
    </div>
  );
}

function Child({ config, onClick }) {
  console.log('Child rendered');
  return <button onClick={onClick}>Click</button>;
}

// Every keystroke in input re-renders Child unnecessarily!

// Solution 1: React.memo
const Child = React.memo(function Child({ config, onClick }) {
  console.log('Child rendered');
  return <button onClick={onClick}>Click</button>;
});

// Solution 2: useMemo for objects
function Parent() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');
  
  const config = useMemo(() => ({ theme: 'dark' }), []);
  const handleClick = useCallback(() => console.log('clicked'), []);
  
  return (
    <div>
      <input value={text} onChange={e => setText(e.target.value)} />
      <Child config={config} onClick={handleClick} />
    </div>
  );
}

const Child = React.memo(function Child({ config, onClick }) {
  console.log('Child rendered');
  return <button onClick={onClick}>Click</button>;
});

// Now Child only re-renders when config or onClick actually change
```

**Step 4: Optimize Lists**

```javascript
// Problem: Rendering 10,000 items
function SlowList({ items }) {
  return (
    <div>
      {items.map(item => (
        <div key={item.id}>
          <ExpensiveItem item={item} />
        </div>
      ))}
    </div>
  );
}

// Solution: Use virtualization
import { FixedSizeList } from 'react-window';

function FastList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      <ExpensiveItem item={items[index]} />
    </div>
  );
  
  return (
    <FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}

// Only renders visible items + buffer
// Handles 100,000+ items smoothly
```

**Step 5: Memoize Expensive Computations**

```javascript
// Problem: Heavy calculation on every render
function Component({ data }) {
  // Runs on EVERY render, even if data hasn't changed
  const processedData = expensiveProcessing(data);
  
  return <div>{processedData}</div>;
}

// Solution: useMemo
function Component({ data }) {
  const processedData = useMemo(() => {
    console.log('Processing data...');
    return expensiveProcessing(data);
  }, [data]);  // Only recalculates when data changes
  
  return <div>{processedData}</div>;
}

// Real example
function SearchResults({ items, query }) {
  // Filter only when items or query changes
  const filteredItems = useMemo(() => {
    return items.filter(item => 
      item.name.toLowerCase().includes(query.toLowerCase())
    );
  }, [items, query]);
  
  return (
    <ul>
      {filteredItems.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
```

**Step 6: Code Splitting**

```javascript
// Problem: Large bundle loads everything upfront
import Dashboard from './Dashboard';
import Admin from './Admin';
import Reports from './Reports';

// Solution: Lazy load routes
import { lazy, Suspense } from 'react';

const Dashboard = lazy(() => import('./Dashboard'));
const Admin = lazy(() => import('./Admin'));
const Reports = lazy(() => import('./Reports'));

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <Routes>
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/admin" element={<Admin />} />
        <Route path="/reports" element={<Reports />} />
      </Routes>
    </Suspense>
  );
}
```

**Step 7: Debounce/Throttle Expensive Operations**

```javascript
// Problem: API call on every keystroke
function Search() {
  const [query, setQuery] = useState('');
  
  useEffect(() => {
    // Calls API on every keystroke!
    fetchResults(query);
  }, [query]);
  
  return <input value={query} onChange={e => setQuery(e.target.value)} />;
}

// Solution: Debounce
function Search() {
  const [query, setQuery] = useState('');
  const [debouncedQuery, setDebouncedQuery] = useState('');
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedQuery(query);
    }, 500);  // Wait 500ms after user stops typing
    
    return () => clearTimeout(timer);
  }, [query]);
  
  useEffect(() => {
    if (debouncedQuery) {
      fetchResults(debouncedQuery);  // Only calls after user stops typing
    }
  }, [debouncedQuery]);
  
  return <input value={query} onChange={e => setQuery(e.target.value)} />;
}

// Or use custom hook
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const handler = setTimeout(() => setDebouncedValue(value), delay);
    return () => clearTimeout(handler);
  }, [value, delay]);
  
  return debouncedValue;
}

function Search() {
  const [query, setQuery] = useState('');
  const debouncedQuery = useDebounce(query, 500);
  
  useEffect(() => {
    if (debouncedQuery) {
      fetchResults(debouncedQuery);
    }
  }, [debouncedQuery]);
  
  return <input value={query} onChange={e => setQuery(e.target.value)} />;
}
```

### Performance Checklist

- ✅ Profile before optimizing
- ✅ Use React.memo for expensive components
- ✅ Use useMemo for expensive calculations
- ✅ Use useCallback for functions passed as props
- ✅ Virtualize long lists
- ✅ Code split routes and heavy components
- ✅ Optimize images (lazy loading, responsive)
- ✅ Debounce user input
- ✅ Keep component trees shallow
- ✅ Avoid inline object/array creation in JSX

---

## 23.4 State Management

### Q: When should you lift state up vs use Context vs use Redux?

**Answer:**

**Decision Tree:**

```
Need to share state?
    ├─ No → Keep it local
    │
    ├─ Between 2-3 nearby components?
    │  └─ Lift state up
    │
    ├─ Between distant components (5+ levels)?
    │  └─ Use Context
    │
    └─ Complex state with many features?
       └─ Use Redux/Zustand
```

**1. Local State**

```javascript
// When: State used only in one component
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

// ✅ Perfect use case
// ❌ Don't lift this to parent if parent doesn't need it
```

**2. Lifting State Up**

```javascript
// When: 2-3 siblings need same state
function Parent() {
  const [filter, setFilter] = useState('all');
  
  return (
    <div>
      <FilterButtons filter={filter} setFilter={setFilter} />
      <ItemList filter={filter} />
    </div>
  );
}

function FilterButtons({ filter, setFilter }) {
  return (
    <div>
      <button onClick={() => setFilter('all')}>All</button>
      <button onClick={() => setFilter('active')}>Active</button>
      <button onClick={() => setFilter('completed')}>Completed</button>
    </div>
  );
}

function ItemList({ filter }) {
  // Use filter to show items
}

// ✅ Good: State is close to where it's used
// ❌ Don't lift further than necessary
```

**3. Context API**

```javascript
// When: Many components at different levels need same data
// Example: Theme, User, Language

// Bad without Context: Prop drilling
function App() {
  const [user, setUser] = useState(null);
  
  return <Layout user={user} setUser={setUser} />;
}

function Layout({ user, setUser }) {
  return <Sidebar user={user} setUser={setUser} />;
}

function Sidebar({ user, setUser }) {
  return <UserMenu user={user} setUser={setUser} />;
}

function UserMenu({ user, setUser }) {
  // Finally use it here!
}

// Good with Context
const UserContext = createContext();

function App() {
  const [user, setUser] = useState(null);
  
  return (
    <UserContext.Provider value={{ user, setUser }}>
      <Layout />
    </UserContext.Provider>
  );
}

function Layout() {
  return <Sidebar />;  // No props!
}

function Sidebar() {
  return <UserMenu />;  // No props!
}

function UserMenu() {
  const { user, setUser } = useContext(UserContext);
  // Direct access!
}

// ✅ Good: Eliminates prop drilling
// ⚠️ Warning: Every context update re-renders all consumers
```

**4. Redux/Zustand**

```javascript
// When: Complex state logic, many features, time-travel debugging

// Redux example
// store.js
import { configureStore, createSlice } from '@reduxjs/toolkit';

const cartSlice = createSlice({
  name: 'cart',
  initialState: { items: [], total: 0 },
  reducers: {
    addItem: (state, action) => {
      state.items.push(action.payload);
      state.total += action.payload.price;
    },
    removeItem: (state, action) => {
      const index = state.items.findIndex(i => i.id === action.payload);
      if (index >= 0) {
        state.total -= state.items[index].price;
        state.items.splice(index, 1);
      }
    }
  }
});

const store = configureStore({
  reducer: {
    cart: cartSlice.reducer
  }
});

// In components
import { useDispatch, useSelector } from 'react-redux';

function CartIcon() {
  const itemCount = useSelector(state => state.cart.items.length);
  return <div>Cart ({itemCount})</div>;
}

function ProductCard({ product }) {
  const dispatch = useDispatch();
  
  return (
    <button onClick={() => dispatch(cartSlice.actions.addItem(product))}>
      Add to Cart
    </button>
  );
}

// ✅ Good for: E-commerce, dashboards, complex apps
// ❌ Overkill for: Simple apps, prototypes
```

**Comparison Table:**

| Solution | Use When | Pros | Cons |
|----------|----------|------|------|
| Local State | Single component | Simple, fast | Can't share |
| Lifted State | 2-3 siblings | Simple, explicit | Prop drilling |
| Context | Many levels deep | No prop drilling | Performance issues if overused |
| Redux | Complex apps | DevTools, middleware, predictable | Boilerplate, learning curve |
| Zustand | Medium complexity | Simple API, good performance | Less tooling than Redux |

**Best Practices:**

```javascript
// ✅ Start with local state
function Component() {
  const [isOpen, setIsOpen] = useState(false);
}

// ✅ Lift when needed
function Parent() {
  const [sharedState, setSharedState] = useState();
  return (
    <>
      <Child1 state={sharedState} />
      <Child2 state={sharedState} />
    </>
  );
}

// ✅ Use Context for true global state
<ThemeContext.Provider>
  <UserContext.Provider>
    <App />
  </UserContext.Provider>
</ThemeContext.Provider>

// ✅ Use Redux for complex apps
// - Multiple features
// - Async operations
// - Need time-travel debugging
// - Large team
```

---

## Quick Reference: Most Asked Questions

### Top 10 React Interview Questions

1. **What is Virtual DOM?** 
   - Lightweight JS representation of real DOM
   - Enables efficient updates through diffing

2. **useState vs useReducer**
   - useState: Simple state
   - useReducer: Complex state with multiple sub-values

3. **useEffect dependency array**
   - []: Run once on mount
   - [dep]: Run when dep changes
   - No array: Run on every render

4. **Keys in lists**
   - Help React identify which items changed
   - Must be stable and unique
   - Don't use index for dynamic lists

5. **Controlled vs Uncontrolled components**
   - Controlled: React controls form state
   - Uncontrolled: DOM controls form state

6. **React.memo vs useMemo**
   - React.memo: Memoizes component
   - useMemo: Memoizes value

7. **Lifting state up**
   - Move state to common ancestor
   - Share state between siblings

8. **Custom hooks**
   - Extract reusable logic
   - Must start with 'use'
   - Can use other hooks

9. **Error boundaries**
   - Catch JavaScript errors in component tree
   - Class component with componentDidCatch
   - Don't catch async errors

10. **Code splitting**
    - React.lazy + Suspense
    - Split by routes
    - Reduce initial bundle size

---

## Interview Tips

### How to Answer Technical Questions

1. **Start with the concept**
   - "The Virtual DOM is..."
   
2. **Explain why it exists**
   - "It solves the problem of..."
   
3. **Give an example**
   - "For instance, when you..."
   
4. **Mention trade-offs**
   - "The benefit is X, but the cost is Y"

5. **Show you've used it**
   - "In my last project, I used this to..."

### Red Flags to Avoid

❌ "I always use Redux"
✅ "I choose state management based on complexity"

❌ "Performance isn't important until it is"
✅ "I profile first, then optimize specific bottlenecks"

❌ "I memorize everything"
✅ "I understand the concepts and can look up syntax"

❌ "React is the best"
✅ "React is great for X, but Y might be better for Z"

This completes Chapter 23 on Common Interview Questions!