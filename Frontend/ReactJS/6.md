# Chapter 6: Custom Hooks - In-Depth Explanation

## 6.1 What are Custom Hooks?

Custom hooks are **JavaScript functions that use React hooks** to encapsulate reusable stateful logic. They let you extract component logic into reusable functions.

**Key Characteristics:**
- Function name must start with "use" (e.g., `useCustomHook`)
- Can call other hooks (useState, useEffect, other custom hooks)
- Can return anything (values, functions, objects)
- Follow the same rules as built-in hooks

**Visual Concept:**
```
Component 1 â”€â”
Component 2 â”€â”¼â”€â†’ Custom Hook (useLocalStorage) â”€â†’ Shared Logic
Component 3 â”€â”˜
```

### Why Create Custom Hooks?

**Benefits:**
1. **Reusability** - Share logic across components
2. **Separation of Concerns** - Separate stateful logic from UI
3. **Testability** - Test logic independently
4. **Readability** - Cleaner component code
5. **Composition** - Combine multiple hooks

**Before Custom Hooks (Duplicate Logic):**
```javascript
function UserProfile() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    setLoading(true);
    fetch('/api/user')
      .then(res => res.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err);
        setLoading(false);
      });
  }, []);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  return <div>{user.name}</div>;
}

function PostList() {
  const [posts, setPosts] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    setLoading(true);
    fetch('/api/posts')
      .then(res => res.json())
      .then(data => {
        setPosts(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err);
        setLoading(false);
      });
  }, []);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  return <ul>{posts.map(post => <li key={post.id}>{post.title}</li>)}</ul>;
}
// Duplicate fetching logic! ðŸ˜“
```

**After Custom Hooks (Reusable Logic):**
```javascript
// Custom hook
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    setLoading(true);
    fetch(url)
      .then(res => res.json())
      .then(data => {
        setData(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err);
        setLoading(false);
      });
  }, [url]);
  
  return { data, loading, error };
}

// Clean components
function UserProfile() {
  const { data: user, loading, error } = useFetch('/api/user');
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  return <div>{user.name}</div>;
}

function PostList() {
  const { data: posts, loading, error } = useFetch('/api/posts');
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  return <ul>{posts.map(post => <li key={post.id}>{post.title}</li>)}</ul>;
}
// Clean and reusable! ðŸŽ‰
```

---

## 6.2 Creating Custom Hooks

### Basic Structure

```javascript
function useCustomHook(initialValue) {
  // 1. Use built-in hooks
  const [state, setState] = useState(initialValue);
  
  // 2. Define logic
  const doSomething = () => {
    setState(newValue);
  };
  
  // 3. Return values/functions
  return [state, doSomething];
  // or return { state, doSomething };
}
```

### Simple Example: useToggle

```javascript
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);
  
  const toggle = useCallback(() => {
    setValue(v => !v);
  }, []);
  
  const setTrue = useCallback(() => {
    setValue(true);
  }, []);
  
  const setFalse = useCallback(() => {
    setValue(false);
  }, []);
  
  return [value, toggle, setTrue, setFalse];
}

// Usage
function Component() {
  const [isOpen, toggle, open, close] = useToggle(false);
  
  return (
    <div>
      <p>Modal is {isOpen ? 'open' : 'closed'}</p>
      <button onClick={toggle}>Toggle</button>
      <button onClick={open}>Open</button>
      <button onClick={close}>Close</button>
    </div>
  );
}
```

### Naming Conventions

```javascript
// âœ… Correct - starts with "use"
function useAuth() { }
function useLocalStorage() { }
function useFetch() { }

// âŒ Wrong - doesn't start with "use"
function getAuth() { }        // Regular function
function localStorageHook() { } // Regular function
function fetchData() { }       // Regular function
```

**Why "use" prefix is required:**
- React's linter enforces Rules of Hooks only for functions starting with "use"
- Makes it clear that the function uses hooks
- Convention adopted by React community

---

## 6.3 Common Custom Hook Patterns

### Pattern 1: State Management Hooks

#### useCounter
```javascript
function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);
  
  const increment = useCallback(() => setCount(c => c + 1), []);
  const decrement = useCallback(() => setCount(c => c - 1), []);
  const reset = useCallback(() => setCount(initialValue), [initialValue]);
  const set = useCallback((value) => setCount(value), []);
  
  return {
    count,
    increment,
    decrement,
    reset,
    set
  };
}

// Usage
function Counter() {
  const { count, increment, decrement, reset } = useCounter(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

#### useArray
```javascript
function useArray(initialArray = []) {
  const [array, setArray] = useState(initialArray);
  
  const push = useCallback((element) => {
    setArray(arr => [...arr, element]);
  }, []);
  
  const filter = useCallback((callback) => {
    setArray(arr => arr.filter(callback));
  }, []);
  
  const update = useCallback((index, newElement) => {
    setArray(arr => [
      ...arr.slice(0, index),
      newElement,
      ...arr.slice(index + 1)
    ]);
  }, []);
  
  const remove = useCallback((index) => {
    setArray(arr => [
      ...arr.slice(0, index),
      ...arr.slice(index + 1)
    ]);
  }, []);
  
  const clear = useCallback(() => {
    setArray([]);
  }, []);
  
  return { array, set: setArray, push, filter, update, remove, clear };
}

// Usage
function TodoList() {
  const { array: todos, push, remove, clear } = useArray([]);
  const [input, setInput] = useState('');
  
  const addTodo = () => {
    if (input.trim()) {
      push({ id: Date.now(), text: input, done: false });
      setInput('');
    }
  };
  
  return (
    <div>
      <input value={input} onChange={e => setInput(e.target.value)} />
      <button onClick={addTodo}>Add</button>
      <button onClick={clear}>Clear All</button>
      <ul>
        {todos.map((todo, index) => (
          <li key={todo.id}>
            {todo.text}
            <button onClick={() => remove(index)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### Pattern 2: Side Effect Hooks

#### useDebounce
```javascript
function useDebounce(value, delay = 500) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);
  
  return debouncedValue;
}

// Usage
function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);
  
  useEffect(() => {
    if (debouncedSearchTerm) {
      // Make API call
      console.log('Searching for:', debouncedSearchTerm);
    }
  }, [debouncedSearchTerm]);
  
  return (
    <input 
      value={searchTerm}
      onChange={e => setSearchTerm(e.target.value)}
      placeholder="Search..."
    />
  );
}
```

#### useInterval
```javascript
function useInterval(callback, delay) {
  const savedCallback = useRef();
  
  // Remember latest callback
  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);
  
  // Set up interval
  useEffect(() => {
    if (delay !== null) {
      const id = setInterval(() => {
        savedCallback.current();
      }, delay);
      
      return () => clearInterval(id);
    }
  }, [delay]);
}

// Usage
function Timer() {
  const [seconds, setSeconds] = useState(0);
  const [isRunning, setIsRunning] = useState(true);
  
  useInterval(() => {
    setSeconds(s => s + 1);
  }, isRunning ? 1000 : null);  // Pass null to pause
  
  return (
    <div>
      <p>Seconds: {seconds}</p>
      <button onClick={() => setIsRunning(!isRunning)}>
        {isRunning ? 'Pause' : 'Resume'}
      </button>
    </div>
  );
}
```

#### useEventListener
```javascript
function useEventListener(eventName, handler, element = window) {
  const savedHandler = useRef();
  
  // Update ref when handler changes
  useEffect(() => {
    savedHandler.current = handler;
  }, [handler]);
  
  useEffect(() => {
    // Make sure element supports addEventListener
    const isSupported = element && element.addEventListener;
    if (!isSupported) return;
    
    // Create event listener that calls handler from ref
    const eventListener = (event) => savedHandler.current(event);
    
    element.addEventListener(eventName, eventListener);
    
    return () => {
      element.removeEventListener(eventName, eventListener);
    };
  }, [eventName, element]);
}

// Usage
function Component() {
  const [key, setKey] = useState('');
  
  useEventListener('keydown', (e) => {
    setKey(e.key);
  });
  
  return <div>Last key pressed: {key}</div>;
}
```

### Pattern 3: Browser API Hooks

#### useLocalStorage
```javascript
function useLocalStorage(key, initialValue) {
  // State to store our value
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });
  
  // Return a wrapped version of useState's setter that persists to localStorage
  const setValue = useCallback((value) => {
    try {
      // Allow value to be a function
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  }, [key, storedValue]);
  
  return [storedValue, setValue];
}

// Usage
function Settings() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  const [language, setLanguage] = useLocalStorage('language', 'en');
  
  return (
    <div>
      <select value={theme} onChange={e => setTheme(e.target.value)}>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
      </select>
      
      <select value={language} onChange={e => setLanguage(e.target.value)}>
        <option value="en">English</option>
        <option value="es">Spanish</option>
      </select>
    </div>
  );
}
```

#### useWindowSize
```javascript
function useWindowSize() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  
  useEffect(() => {
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    }
    
    window.addEventListener('resize', handleResize);
    
    // Call handler immediately to get initial size
    handleResize();
    
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  return windowSize;
}

// Usage
function ResponsiveComponent() {
  const { width, height } = useWindowSize();
  
  return (
    <div>
      <p>Window size: {width} x {height}</p>
      {width < 768 ? (
        <MobileLayout />
      ) : (
        <DesktopLayout />
      )}
    </div>
  );
}
```

#### useMediaQuery
```javascript
function useMediaQuery(query) {
  const [matches, setMatches] = useState(() => {
    return window.matchMedia(query).matches;
  });
  
  useEffect(() => {
    const mediaQuery = window.matchMedia(query);
    
    const handleChange = (e) => {
      setMatches(e.matches);
    };
    
    // Modern browsers
    if (mediaQuery.addEventListener) {
      mediaQuery.addEventListener('change', handleChange);
      return () => mediaQuery.removeEventListener('change', handleChange);
    } else {
      // Fallback for older browsers
      mediaQuery.addListener(handleChange);
      return () => mediaQuery.removeListener(handleChange);
    }
  }, [query]);
  
  return matches;
}

// Usage
function ResponsiveMenu() {
  const isMobile = useMediaQuery('(max-width: 768px)');
  const isTablet = useMediaQuery('(min-width: 769px) and (max-width: 1024px)');
  const isDesktop = useMediaQuery('(min-width: 1025px)');
  
  return (
    <nav>
      {isMobile && <MobileMenu />}
      {isTablet && <TabletMenu />}
      {isDesktop && <DesktopMenu />}
    </nav>
  );
}
```

### Pattern 4: Data Fetching Hooks

#### useFetch (Basic)
```javascript
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const abortController = new AbortController();
    
    setLoading(true);
    
    fetch(url, { signal: abortController.signal })
      .then(res => {
        if (!res.ok) throw new Error('Network response was not ok');
        return res.json();
      })
      .then(data => {
        setData(data);
        setLoading(false);
      })
      .catch(err => {
        if (err.name !== 'AbortError') {
          setError(err);
          setLoading(false);
        }
      });
    
    return () => {
      abortController.abort();
    };
  }, [url]);
  
  return { data, loading, error };
}

// Usage
function UserProfile({ userId }) {
  const { data: user, loading, error } = useFetch(`/api/users/${userId}`);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}
```

#### useFetch (Advanced with Options)
```javascript
function useFetch(url, options = {}) {
  const [state, setState] = useState({
    data: null,
    loading: true,
    error: null
  });
  
  // Memoize options to prevent unnecessary refetches
  const optionsString = JSON.stringify(options);
  
  useEffect(() => {
    const abortController = new AbortController();
    
    setState({ data: null, loading: true, error: null });
    
    fetch(url, {
      ...JSON.parse(optionsString),
      signal: abortController.signal
    })
      .then(res => {
        if (!res.ok) {
          throw new Error(`HTTP error! status: ${res.status}`);
        }
        return res.json();
      })
      .then(data => {
        setState({ data, loading: false, error: null });
      })
      .catch(err => {
        if (err.name !== 'AbortError') {
          setState({ data: null, loading: false, error: err });
        }
      });
    
    return () => {
      abortController.abort();
    };
  }, [url, optionsString]);
  
  return state;
}

// Usage
function PostList() {
  const { data: posts, loading, error } = useFetch('/api/posts', {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer token'
    }
  });
  
  if (loading) return <Spinner />;
  if (error) return <ErrorMessage error={error} />;
  
  return (
    <ul>
      {posts.map(post => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

### Pattern 5: Form Hooks

#### useForm
```javascript
function useForm(initialValues = {}, validate) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleChange = useCallback((e) => {
    const { name, value } = e.target;
    setValues(prev => ({ ...prev, [name]: value }));
  }, []);
  
  const handleBlur = useCallback((e) => {
    const { name } = e.target;
    setTouched(prev => ({ ...prev, [name]: true }));
    
    if (validate) {
      const validationErrors = validate(values);
      setErrors(validationErrors);
    }
  }, [values, validate]);
  
  const handleSubmit = useCallback((onSubmit) => {
    return async (e) => {
      e.preventDefault();
      
      // Mark all fields as touched
      const allTouched = Object.keys(values).reduce((acc, key) => {
        acc[key] = true;
        return acc;
      }, {});
      setTouched(allTouched);
      
      // Validate
      if (validate) {
        const validationErrors = validate(values);
        setErrors(validationErrors);
        
        if (Object.keys(validationErrors).length > 0) {
          return;
        }
      }
      
      // Submit
      setIsSubmitting(true);
      try {
        await onSubmit(values);
      } finally {
        setIsSubmitting(false);
      }
    };
  }, [values, validate]);
  
  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
  }, [initialValues]);
  
  return {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit,
    reset
  };
}

// Usage
function LoginForm() {
  const validate = (values) => {
    const errors = {};
    
    if (!values.email) {
      errors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(values.email)) {
      errors.email = 'Email is invalid';
    }
    
    if (!values.password) {
      errors.password = 'Password is required';
    } else if (values.password.length < 6) {
      errors.password = 'Password must be at least 6 characters';
    }
    
    return errors;
  };
  
  const {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit
  } = useForm({ email: '', password: '' }, validate);
  
  const onSubmit = async (values) => {
    await fetch('/api/login', {
      method: 'POST',
      body: JSON.stringify(values)
    });
  };
  
  return (
    <div onSubmit={handleSubmit(onSubmit)}>
      <div>
        <input 
          name="email"
          value={values.email}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {touched.email && errors.email && (
          <span>{errors.email}</span>
        )}
      </div>
      
      <div>
        <input 
          name="password"
          type="password"
          value={values.password}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {touched.password && errors.password && (
          <span>{errors.password}</span>
        )}
      </div>
      
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Logging in...' : 'Login'}
      </button>
    </div>
  );
}
```

### Pattern 6: UI Interaction Hooks

#### useOnClickOutside
```javascript
function useOnClickOutside(ref, handler) {
  useEffect(() => {
    const listener = (event) => {
      // Do nothing if clicking ref's element or descendent elements
      if (!ref.current || ref.current.contains(event.target)) {
        return;
      }
      
      handler(event);
    };
    
    document.addEventListener('mousedown', listener);
    document.addEventListener('touchstart', listener);
    
    return () => {
      document.removeEventListener('mousedown', listener);
      document.removeEventListener('touchstart', listener);
    };
  }, [ref, handler]);
}

// Usage
function Dropdown() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef();
  
  useOnClickOutside(dropdownRef, () => {
    setIsOpen(false);
  });
  
  return (
    <div ref={dropdownRef}>
      <button onClick={() => setIsOpen(!isOpen)}>
        Toggle Dropdown
      </button>
      
      {isOpen && (
        <div className="dropdown-menu">
          <a href="#">Option 1</a>
          <a href="#">Option 2</a>
          <a href="#">Option 3</a>
        </div>
      )}
    </div>
  );
}
```

#### useHover
```javascript
function useHover() {
  const [isHovered, setIsHovered] = useState(false);
  const ref = useRef(null);
  
  const handleMouseEnter = useCallback(() => setIsHovered(true), []);
  const handleMouseLeave = useCallback(() => setIsHovered(false), []);
  
  useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener('mouseenter', handleMouseEnter);
      node.addEventListener('mouseleave', handleMouseLeave);
      
      return () => {
        node.removeEventListener('mouseenter', handleMouseEnter);
        node.removeEventListener('mouseleave', handleMouseLeave);
      };
    }
  }, [handleMouseEnter, handleMouseLeave]);
  
  return [ref, isHovered];
}

// Usage
function HoverCard() {
  const [hoverRef, isHovered] = useHover();
  
  return (
    <div ref={hoverRef} className={isHovered ? 'card-hovered' : 'card'}>
      <h3>Hover over me!</h3>
      <p>{isHovered ? 'Thanks! ðŸ˜Š' : 'Hover to see magic âœ¨'}</p>
    </div>
  );
}
```

### Pattern 7: Utility Hooks

#### usePrevious
```javascript
function usePrevious(value) {
  const ref = useRef();
  
  useEffect(() => {
    ref.current = value;
  }, [value]);
  
  return ref.current;
}

// Usage
function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);
  
  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {prevCount}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

#### useUpdateEffect
```javascript
function useUpdateEffect(effect, deps) {
  const isFirstMount = useRef(true);
  
  useEffect(() => {
    if (isFirstMount.current) {
      isFirstMount.current = false;
      return;
    }
    
    return effect();
  }, deps);
}

// Usage
function Component({ userId }) {
  const [data, setData] = useState(null);
  
  // Runs on updates, but not on mount
  useUpdateEffect(() => {
    console.log('User changed, fetching new data...');
    fetchData(userId).then(setData);
  }, [userId]);
  
  return <div>{data?.name}</div>;
}
```

#### useAsync
```javascript
function useAsync(asyncFunction, immediate = true) {
  const [status, setStatus] = useState('idle');
  const [value, setValue] = useState(null);
  const [error, setError] = useState(null);
  
  const execute = useCallback((...args) => {
    setStatus('pending');
    setValue(null);
    setError(null);
    
    return asyncFunction(...args)
      .then(response => {
        setValue(response);
        setStatus('success');
      })
      .catch(error => {
        setError(error);
        setStatus('error');
      });
  }, [asyncFunction]);
  
  useEffect(() => {
    if (immediate) {
      execute();
    }
  }, [execute, immediate]);
  
  return { execute, status, value, error };
}

// Usage
function UserProfile({ userId }) {
  const { status, value: user, error } = useAsync(
    () => fetch(`/api/users/${userId}`).then(r => r.json()),
    true
  );
  
  if (status === 'idle' || status === 'pending') return <div>Loading...</div>;
  if (status === 'error') return <div>Error: {error.message}</div>;
  
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}
```

---

## 6.4 Hook Composition

Custom hooks can call other custom hooks:

```javascript
// Composing multiple hooks
function useAuth() {
  const [user, setUser] = useLocalStorage('user', null);
  const [token, setToken] = useLocalStorage('token', null);
  
  const login = useCallback(async (credentials) => {
    const response = await fetch('/api/login', {
      method: 'POST',
      body: JSON.stringify(credentials)
    });
    const data = await response.json();
    
    setUser(data.user);
    setToken(data.token);
  }, [setUser, setToken]);
  
  const logout = useCallback(() => {
    setUser(null);
    setToken(null);
  }, [setUser, setToken]);
  
  return { user, token, login, logout };
}

// Using composed hook
function App() {
  const { user, login, logout } = useAuth();
  
  return (
    <div>
      {user ? (
        <>
          <p>Welcome, {user.name}!</p>
          <button onClick={logout}>Logout</button>
        </>
      ) : (
        <LoginForm onSubmit={login} />
      )}
    </div>
  );
}
```

---

## 6.5 Best Practices

### 1. One Responsibility Per Hook

```javascript
// âŒ Bad: Hook does too many things
function useEverything(userId) {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState([]);
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  const windowSize = useWindowSize();
  
  // Too much logic...
  
  return { user, posts, theme, setTheme, windowSize };
}

// âœ… Good: Separate hooks for separate concerns
function useUser(userId) {
  const [user, setUser] = useState(null);
  // User logic only
  return user;
}

function usePosts(userId) {
  const [posts, setPosts] = useState([]);
  // Posts logic only
  return posts;
}

function useTheme() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  // Theme logic only
  return [theme, setTheme];
}
```

### 2. Return Consistent API

```javascript
// âœ… Good: Array destructuring (like useState)
function useToggle(initialValue) {
  // ...
  return [value, toggle];
}
const [isOpen, toggleOpen] = useToggle(false);

// âœ… Good: Object destructuring (for many values)
function useFetch(url) {
  // ...
  return { data, loading, error, refetch };
}
const { data, loading } = useFetch('/api/data');

// âŒ Bad: Inconsistent returns
function useBadHook(flag) {
  if (flag) return [value, setValue];
  return { value, setValue };
}
```

### 3. Handle Cleanup Properly

```javascript
// âœ… Good: Always cleanup
function useWebSocket(url) {
  const [message, setMessage] = useState(null);
  
  useEffect(() => {
    const ws = new WebSocket(url);
    
    ws.onmessage = (event) => {
      setMessage(event.data);
    };
    
    // Cleanup
    return () => {
      ws.close();
    };
  }, [url]);
  
  return message;
}
```

### 4. Use Meaningful Names

```javascript
// âŒ Bad names
function useData(x) { }
function useStuff() { }
function useHook1() { }

// âœ… Good names
function useUserData(userId) { }
function useAuthState() { }
function useProductSearch(query) { }
```

### 5. Document Your Hooks

```javascript
/**
 * Custom hook for debouncing a value
 * @param {*} value - The value to debounce
 * @param {number} delay - Delay in milliseconds
 * @returns {*} The debounced value
 * 
 * @example
 * const debouncedSearch = useDebounce(searchTerm, 500);
 */
function useDebounce(value, delay) {
  // Implementation
}
```

---

## 6.6 Testing Custom Hooks

### Using @testing-library/react-hooks

```javascript
import { renderHook, act } from '@testing-library/react-hooks';
import { useCounter } from './useCounter';

describe('useCounter', () => {
  it('should initialize with default value', () => {
    const { result } = renderHook(() => useCounter());
    expect(result.current.count).toBe(0);
  });
  
  it('should increment counter', () => {
    const { result } = renderHook(() => useCounter());
    
    act(() => {
      result.current.increment();
    });
    
    expect(result.current.count).toBe(1);
  });
  
  it('should decrement counter', () => {
    const { result } = renderHook(() => useCounter(5));
    
    act(() => {
      result.current.decrement();
    });
    
    expect(result.current.count).toBe(4);
  });
  
  it('should reset counter', () => {
    const { result } = renderHook(() => useCounter(5));
    
    act(() => {
      result.current.increment();
      result.current.increment();
    });
    
    expect(result.current.count).toBe(7);
    
    act(() => {
      result.current.reset();
    });
    
    expect(result.current.count).toBe(5);
  });
});
```

---

## Summary of Chapter 6

**Key Takeaways:**

1. **Custom Hooks** - Reusable stateful logic extracted into functions
2. **Naming** - Must start with "use" prefix
3. **Composition** - Can call other hooks (built-in or custom)
4. **Return Values** - Array or object, be consistent
5. **One Responsibility** - Each hook should do one thing well
6. **Cleanup** - Always clean up subscriptions, timers, listeners
7. **Testing** - Test hooks independently from components

**Common Custom Hook Categories:**
- State management (useToggle, useCounter, useArray)
- Side effects (useDebounce, useInterval, useEventListener)
- Browser APIs (useLocalStorage, useWindowSize, useMediaQuery)
- Data fetching (useFetch, useAsync)
- Form handling (useForm, useInput)
- UI interactions (useOnClickOutside, useHover)
- Utilities (usePrevious, useUpdateEffect)

**Best Practices:**
âœ… Start with "use" prefix
âœ… One responsibility per hook
âœ… Consistent return API
âœ… Proper cleanup
âœ… Meaningful names
âœ… Good documentation
âœ… Thorough testing

**Practice Exercises:**

1. Create useToggle with additional methods
2. Build useLocalStorage with sync across tabs
3. Implement useDebounce and useThrottle
4. Create useFetch with cancel and retry
5. Build useForm with validation
6. Make useOnClickOutside for modals
7. Create usePrevious for comparison
8. Build useAsync with status tracking