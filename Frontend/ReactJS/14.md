# Chapter 14: Testing - In-Depth Explanation

## Why Test React Components?

**Testing ensures:**
- ✅ Components work as expected
- ✅ Bugs are caught before production
- ✅ Refactoring doesn't break functionality
- ✅ Documentation of component behavior
- ✅ Confidence in deployments

**Types of Tests:**
```
Unit Tests        → Test individual components/functions
Integration Tests → Test components working together
E2E Tests        → Test entire user flows
```

---

## 14.1 React Testing Library

### Philosophy: Test How Users Interact

**React Testing Library** encourages testing from the user's perspective, not implementation details.

**Key Principles:**
```
❌ Don't test:
- Component state
- Component methods
- Implementation details

✅ Do test:
- What user sees
- What user can do
- User interactions
- Accessibility
```

**Installation:**
```bash
# Usually included with Create React App
npm install --save-dev @testing-library/react @testing-library/jest-dom

# For user event simulation
npm install --save-dev @testing-library/user-event
```

### Basic Test Structure

```javascript
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import Counter from './Counter';

describe('Counter Component', () => {
  test('renders initial count', () => {
    // 1. ARRANGE - Render component
    render(<Counter />);
    
    // 2. ACT - (none in this test)
    
    // 3. ASSERT - Check what's displayed
    expect(screen.getByText('Count: 0')).toBeInTheDocument();
  });
  
  test('increments counter on button click', () => {
    // 1. ARRANGE
    render(<Counter />);
    
    // 2. ACT - Find button and click
    const button = screen.getByRole('button', { name: /increment/i });
    fireEvent.click(button);
    
    // 3. ASSERT
    expect(screen.getByText('Count: 1')).toBeInTheDocument();
  });
});
```

---

## 14.2 Queries (Finding Elements)

### Query Priority

React Testing Library has a **priority order** for queries:

**1. Accessible to Everyone (Prefer These):**

```javascript
// getByRole - Best choice (tests accessibility)
screen.getByRole('button', { name: /submit/i });
screen.getByRole('textbox', { name: /email/i });
screen.getByRole('heading', { name: /welcome/i });

// getByLabelText - For form inputs
screen.getByLabelText(/username/i);
screen.getByLabelText('Email Address');

// getByPlaceholderText
screen.getByPlaceholderText(/enter email/i);

// getByText - For non-interactive elements
screen.getByText(/hello world/i);
screen.getByText('Welcome back!');
```

**2. Semantic Queries:**

```javascript
// getByAltText - For images
screen.getByAltText(/profile picture/i);

// getByTitle
screen.getByTitle(/close/i);

// getByDisplayValue - For inputs with values
screen.getByDisplayValue('John Doe');
```

**3. Test IDs (Last Resort):**

```javascript
// Only when you can't use above methods
screen.getByTestId('custom-element');

// In component:
<div data-testid="custom-element">Content</div>
```

### Query Variants

```javascript
// Single element
getByRole      // Throws error if not found
queryByRole    // Returns null if not found
findByRole     // Returns promise, waits for element

// Multiple elements
getAllByRole   // Throws error if none found
queryAllByRole // Returns empty array if none found
findAllByRole  // Returns promise, waits for elements

// Examples:
const button = screen.getByRole('button');  // Must exist
const button = screen.queryByRole('button'); // May not exist
const button = await screen.findByRole('button'); // Wait for it to appear
```

**When to Use Each:**

```javascript
// Use getBy when element MUST exist
test('button exists', () => {
  render(<Component />);
  expect(screen.getByRole('button')).toBeInTheDocument();
});

// Use queryBy to assert element DOESN'T exist
test('error message not shown initially', () => {
  render(<Component />);
  expect(screen.queryByText(/error/i)).not.toBeInTheDocument();
});

// Use findBy for async elements
test('loads and displays user', async () => {
  render(<UserProfile />);
  expect(await screen.findByText(/john doe/i)).toBeInTheDocument();
});
```

---

## 14.3 User Interactions

### fireEvent vs userEvent

**fireEvent** - Low-level DOM event dispatch:
```javascript
import { fireEvent } from '@testing-library/react';

fireEvent.click(button);
fireEvent.change(input, { target: { value: 'Hello' } });
fireEvent.submit(form);
```

**userEvent** - More realistic user interactions (Recommended):
```javascript
import userEvent from '@testing-library/user-event';

// Setup user event
const user = userEvent.setup();

// Click
await user.click(button);

// Type
await user.type(input, 'Hello World');

// Clear and type
await user.clear(input);
await user.type(input, 'New Value');

// Tab navigation
await user.tab();

// Keyboard shortcuts
await user.keyboard('{Control>}a{/Control}'); // Ctrl+A
```

**Comparison:**
```javascript
// fireEvent - Instant, synchronous
fireEvent.click(button);
expect(screen.getByText('Clicked')).toBeInTheDocument();

// userEvent - Realistic, asynchronous
await user.click(button);
expect(screen.getByText('Clicked')).toBeInTheDocument();

// userEvent triggers:
// - mousedown, mouseup, click events
// - focus/blur events
// - More realistic event sequence
```

### Testing Different Interactions

**Clicking:**
```javascript
test('clicking button shows message', async () => {
  const user = userEvent.setup();
  render(<Component />);
  
  const button = screen.getByRole('button', { name: /click me/i });
  await user.click(button);
  
  expect(screen.getByText(/you clicked/i)).toBeInTheDocument();
});
```

**Typing:**
```javascript
test('typing updates input', async () => {
  const user = userEvent.setup();
  render(<Component />);
  
  const input = screen.getByRole('textbox', { name: /username/i });
  await user.type(input, 'johndoe');
  
  expect(input).toHaveValue('johndoe');
});
```

**Selecting:**
```javascript
test('selecting option', async () => {
  const user = userEvent.setup();
  render(<Component />);
  
  const select = screen.getByRole('combobox');
  await user.selectOptions(select, 'option1');
  
  expect(screen.getByRole('option', { name: /option 1/i }).selected).toBe(true);
});
```

**Checkboxes:**
```javascript
test('checking checkbox', async () => {
  const user = userEvent.setup();
  render(<Component />);
  
  const checkbox = screen.getByRole('checkbox', { name: /agree/i });
  await user.click(checkbox);
  
  expect(checkbox).toBeChecked();
});
```

---

## 14.4 Testing Components

### Simple Component Test

```javascript
// Component
function Greeting({ name }) {
  return <h1>Hello, {name}!</h1>;
}

// Test
test('renders greeting with name', () => {
  render(<Greeting name="John" />);
  expect(screen.getByText('Hello, John!')).toBeInTheDocument();
});
```

### Testing State Changes

```javascript
// Component
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
    </div>
  );
}

// Test
test('increments and decrements counter', async () => {
  const user = userEvent.setup();
  render(<Counter />);
  
  const increment = screen.getByRole('button', { name: /increment/i });
  const decrement = screen.getByRole('button', { name: /decrement/i });
  
  // Initial state
  expect(screen.getByText('Count: 0')).toBeInTheDocument();
  
  // Increment
  await user.click(increment);
  expect(screen.getByText('Count: 1')).toBeInTheDocument();
  
  // Increment again
  await user.click(increment);
  expect(screen.getByText('Count: 2')).toBeInTheDocument();
  
  // Decrement
  await user.click(decrement);
  expect(screen.getByText('Count: 1')).toBeInTheDocument();
});
```

### Testing Forms

```javascript
// Component
function LoginForm({ onSubmit }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    onSubmit({ email, password });
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <label htmlFor="email">Email</label>
      <input 
        id="email"
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      
      <label htmlFor="password">Password</label>
      <input 
        id="password"
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      
      <button type="submit">Login</button>
    </form>
  );
}

// Test
test('submits form with email and password', async () => {
  const user = userEvent.setup();
  const handleSubmit = jest.fn();
  
  render(<LoginForm onSubmit={handleSubmit} />);
  
  // Fill in email
  const emailInput = screen.getByLabelText(/email/i);
  await user.type(emailInput, 'test@example.com');
  
  // Fill in password
  const passwordInput = screen.getByLabelText(/password/i);
  await user.type(passwordInput, 'password123');
  
  // Submit form
  const submitButton = screen.getByRole('button', { name: /login/i });
  await user.click(submitButton);
  
  // Assert callback was called with correct data
  expect(handleSubmit).toHaveBeenCalledWith({
    email: 'test@example.com',
    password: 'password123'
  });
});
```

### Testing Conditional Rendering

```javascript
// Component
function UserStatus({ isLoggedIn }) {
  return (
    <div>
      {isLoggedIn ? (
        <button>Logout</button>
      ) : (
        <button>Login</button>
      )}
    </div>
  );
}

// Tests
test('shows login button when logged out', () => {
  render(<UserStatus isLoggedIn={false} />);
  expect(screen.getByRole('button', { name: /login/i })).toBeInTheDocument();
  expect(screen.queryByRole('button', { name: /logout/i })).not.toBeInTheDocument();
});

test('shows logout button when logged in', () => {
  render(<UserStatus isLoggedIn={true} />);
  expect(screen.getByRole('button', { name: /logout/i })).toBeInTheDocument();
  expect(screen.queryByRole('button', { name: /login/i })).not.toBeInTheDocument();
});
```

---

## 14.5 Testing Async Code

### Testing API Calls

```javascript
// Component
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      });
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}

// Test with Mock
test('loads and displays user', async () => {
  // Mock fetch
  global.fetch = jest.fn(() =>
    Promise.resolve({
      json: () => Promise.resolve({ 
        name: 'John Doe', 
        email: 'john@example.com' 
      })
    })
  );
  
  render(<UserProfile userId={1} />);
  
  // Check loading state
  expect(screen.getByText(/loading/i)).toBeInTheDocument();
  
  // Wait for user to load
  expect(await screen.findByText('John Doe')).toBeInTheDocument();
  expect(screen.getByText('john@example.com')).toBeInTheDocument();
  
  // Verify fetch was called
  expect(global.fetch).toHaveBeenCalledWith('/api/users/1');
  
  // Cleanup
  global.fetch.mockRestore();
});
```

### waitFor - Wait for Assertions

```javascript
import { waitFor } from '@testing-library/react';

test('updates data after delay', async () => {
  render(<Component />);
  
  const button = screen.getByRole('button');
  fireEvent.click(button);
  
  // Wait for element to appear
  await waitFor(() => {
    expect(screen.getByText(/updated/i)).toBeInTheDocument();
  });
  
  // Or with timeout
  await waitFor(
    () => {
      expect(screen.getByText(/updated/i)).toBeInTheDocument();
    },
    { timeout: 3000 }
  );
});
```

### findBy Queries (Async)

```javascript
// findBy = getBy + waitFor
test('loads user data', async () => {
  render(<UserProfile userId={1} />);
  
  // Automatically waits up to 1000ms
  const heading = await screen.findByRole('heading', { name: /john doe/i });
  expect(heading).toBeInTheDocument();
  
  // Equivalent to:
  await waitFor(() => {
    expect(screen.getByRole('heading', { name: /john doe/i })).toBeInTheDocument();
  });
});
```

---

## 14.6 Mocking

### Mock Functions (jest.fn)

```javascript
test('calls onClick prop when clicked', async () => {
  const user = userEvent.setup();
  const handleClick = jest.fn();
  
  render(<Button onClick={handleClick}>Click me</Button>);
  
  const button = screen.getByRole('button');
  await user.click(button);
  
  // Assert function was called
  expect(handleClick).toHaveBeenCalledTimes(1);
  
  await user.click(button);
  expect(handleClick).toHaveBeenCalledTimes(2);
});
```

### Mock API Calls (MSW - Mock Service Worker)

**Installation:**
```bash
npm install --save-dev msw
```

**Setup:**
```javascript
// src/mocks/handlers.js
import { rest } from 'msw';

export const handlers = [
  rest.get('/api/users', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json([
        { id: 1, name: 'John Doe', email: 'john@example.com' },
        { id: 2, name: 'Jane Doe', email: 'jane@example.com' }
      ])
    );
  }),
  
  rest.post('/api/users', (req, res, ctx) => {
    return res(
      ctx.status(201),
      ctx.json({ id: 3, ...req.body })
    );
  }),
  
  rest.get('/api/users/:id', (req, res, ctx) => {
    const { id } = req.params;
    
    return res(
      ctx.status(200),
      ctx.json({ id: parseInt(id), name: `User ${id}` })
    );
  })
];

// src/mocks/server.js
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

export const server = setupServer(...handlers);

// src/setupTests.js
import { server } from './mocks/server';

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

**Using in Tests:**
```javascript
import { server } from './mocks/server';
import { rest } from 'msw';

test('loads and displays users', async () => {
  render(<UserList />);
  
  // Data comes from MSW mock
  expect(await screen.findByText('John Doe')).toBeInTheDocument();
  expect(screen.getByText('Jane Doe')).toBeInTheDocument();
});

test('handles server error', async () => {
  // Override handler for this test
  server.use(
    rest.get('/api/users', (req, res, ctx) => {
      return res(ctx.status(500));
    })
  );
  
  render(<UserList />);
  
  expect(await screen.findByText(/error/i)).toBeInTheDocument();
});
```

---

## 14.7 Testing Hooks

### renderHook

```javascript
import { renderHook, act } from '@testing-library/react';

// Custom hook
function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);
  
  const increment = () => setCount(c => c + 1);
  const decrement = () => setCount(c => c - 1);
  const reset = () => setCount(initialValue);
  
  return { count, increment, decrement, reset };
}

// Tests
describe('useCounter', () => {
  test('initializes with default value', () => {
    const { result } = renderHook(() => useCounter());
    
    expect(result.current.count).toBe(0);
  });
  
  test('initializes with custom value', () => {
    const { result } = renderHook(() => useCounter(10));
    
    expect(result.current.count).toBe(10);
  });
  
  test('increments counter', () => {
    const { result } = renderHook(() => useCounter());
    
    act(() => {
      result.current.increment();
    });
    
    expect(result.current.count).toBe(1);
  });
  
  test('decrements counter', () => {
    const { result } = renderHook(() => useCounter(5));
    
    act(() => {
      result.current.decrement();
    });
    
    expect(result.current.count).toBe(4);
  });
  
  test('resets to initial value', () => {
    const { result } = renderHook(() => useCounter(10));
    
    act(() => {
      result.current.increment();
      result.current.increment();
    });
    
    expect(result.current.count).toBe(12);
    
    act(() => {
      result.current.reset();
    });
    
    expect(result.current.count).toBe(10);
  });
});
```

### Testing Hooks with Dependencies

```javascript
// Hook with dependency
function useFetch(url) {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(setData);
  }, [url]);
  
  return data;
}

// Test
test('fetches data when url changes', async () => {
  const { result, rerender } = renderHook(
    ({ url }) => useFetch(url),
    { initialProps: { url: '/api/users/1' } }
  );
  
  // Wait for first fetch
  await waitFor(() => {
    expect(result.current).toEqual({ id: 1, name: 'User 1' });
  });
  
  // Change URL
  rerender({ url: '/api/users/2' });
  
  // Wait for second fetch
  await waitFor(() => {
    expect(result.current).toEqual({ id: 2, name: 'User 2' });
  });
});
```

---

## 14.8 Testing Context

```javascript
// Context
const ThemeContext = createContext();

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  return useContext(ThemeContext);
}

// Component
function ThemedButton() {
  const { theme, setTheme } = useTheme();
  
  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      Current theme: {theme}
    </button>
  );
}

// Test
test('toggles theme', async () => {
  const user = userEvent.setup();
  
  render(
    <ThemeProvider>
      <ThemedButton />
    </ThemeProvider>
  );
  
  const button = screen.getByRole('button');
  
  expect(button).toHaveTextContent('Current theme: light');
  
  await user.click(button);
  
  expect(button).toHaveTextContent('Current theme: dark');
});
```

---

## 14.9 Common Matchers

### jest-dom Matchers

```javascript
// Presence
expect(element).toBeInTheDocument();
expect(element).not.toBeInTheDocument();

// Visibility
expect(element).toBeVisible();
expect(element).not.toBeVisible();

// Disabled/Enabled
expect(button).toBeDisabled();
expect(button).toBeEnabled();

// Text content
expect(element).toHaveTextContent('Hello');
expect(element).toHaveTextContent(/hello/i);

// Form elements
expect(input).toHaveValue('John');
expect(checkbox).toBeChecked();
expect(radio).toBeChecked();

// Attributes
expect(element).toHaveAttribute('href', '/home');
expect(element).toHaveClass('active');

// Style
expect(element).toHaveStyle({ color: 'red' });

// Focus
expect(input).toHaveFocus();
```

### Regular Jest Matchers

```javascript
// Equality
expect(value).toBe(5);
expect(object).toEqual({ name: 'John' });

// Truthiness
expect(value).toBeTruthy();
expect(value).toBeFalsy();
expect(value).toBeNull();
expect(value).toBeUndefined();

// Numbers
expect(count).toBeGreaterThan(5);
expect(count).toBeLessThan(10);
expect(count).toBeCloseTo(5.5);

// Strings
expect(string).toMatch(/pattern/);
expect(string).toContain('substring');

// Arrays
expect(array).toContain(item);
expect(array).toHaveLength(5);

// Functions
expect(fn).toHaveBeenCalled();
expect(fn).toHaveBeenCalledTimes(2);
expect(fn).toHaveBeenCalledWith(arg1, arg2);

// Promises
await expect(promise).resolves.toBe(value);
await expect(promise).rejects.toThrow();
```

---

## 14.10 Integration Testing

### Testing Components Together

```javascript
// Components
function TodoList() {
  const [todos, setTodos] = useState([]);
  const [input, setInput] = useState('');
  
  const addTodo = () => {
    if (input.trim()) {
      setTodos([...todos, { id: Date.now(), text: input, done: false }]);
      setInput('');
    }
  };
  
  const toggleTodo = (id) => {
    setTodos(todos.map(t => 
      t.id === id ? { ...t, done: !t.done } : t
    ));
  };
  
  return (
    <div>
      <input 
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Add todo"
      />
      <button onClick={addTodo}>Add</button>
      
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input 
              type="checkbox"
              checked={todo.done}
              onChange={() => toggleTodo(todo.id)}
              aria-label={`Toggle ${todo.text}`}
            />
            {todo.text}
          </li>
        ))}
      </ul>
    </div>
  );
}

// Integration test
test('complete todo workflow', async () => {
  const user = userEvent.setup();
  render(<TodoList />);
  
  // Add first todo
  const input = screen.getByPlaceholderText(/add todo/i);
  await user.type(input, 'Buy milk');
  
  const addButton = screen.getByRole('button', { name: /add/i });
  await user.click(addButton);
  
  // Verify todo appears
  expect(screen.getByText('Buy milk')).toBeInTheDocument();
  expect(input).toHaveValue(''); // Input cleared
  
  // Add second todo
  await user.type(input, 'Walk dog');
  await user.click(addButton);
  
  expect(screen.getByText('Walk dog')).toBeInTheDocument();
  
  // Toggle first todo
  const checkbox = screen.getByLabelText(/toggle buy milk/i);
  await user.click(checkbox);
  
  expect(checkbox).toBeChecked();
  
  // Verify both todos exist
  expect(screen.getAllByRole('listitem')).toHaveLength(2);
});
```

---

## 14.11 Testing Best Practices

### 1. AAA Pattern (Arrange, Act, Assert)

```javascript
test('increments counter', async () => {
  // ARRANGE - Set up test
  const user = userEvent.setup();
  render(<Counter />);
  const button = screen.getByRole('button', { name: /increment/i });
  
  // ACT - Perform action
  await user.click(button);
  
  // ASSERT - Verify result
  expect(screen.getByText('Count: 1')).toBeInTheDocument();
});
```

### 2. Test IDs - Use Sparingly

```javascript
// ❌ Bad - testing implementation
test('state updates on click', () => {
  const { container } = render(<Component />);
  const element = container.querySelector('.my-class');
  // Testing CSS classes
});

// ✅ Good - testing user behavior
test('shows message on click', async () => {
  const user = userEvent.setup();
  render(<Component />);
  
  await user.click(screen.getByRole('button'));
  expect(screen.getByText(/message/i)).toBeInTheDocument();
});

// ⚠️ OK - when no better option
test('renders custom component', () => {
  render(<CustomWidget />);
  expect(screen.getByTestId('widget')).toBeInTheDocument();
});
```

### 3. Cleanup (Automatic)

```javascript
// Cleanup is automatic after each test
afterEach(() => {
  cleanup(); // Called automatically
});

// But you can add custom cleanup
afterEach(() => {
  localStorage.clear();
  jest.clearAllMocks();
});
```

### 4. Custom Render with Providers

```javascript
// Test utilities
function renderWithProviders(ui, options = {}) {
  const Wrapper = ({ children }) => {
    return (
      <ThemeProvider>
        <AuthProvider>
          <QueryClientProvider client={queryClient}>
            {children}
          </QueryClientProvider>
        </AuthProvider>
      </ThemeProvider>
    );
  };
  
  return render(ui, { wrapper: Wrapper, ...options });
}

// Usage
test('renders with all providers', () => {
  renderWithProviders(<MyComponent />);
  // Component has access to all contexts
});
```

---

## 14.12 Snapshot Testing

### What are Snapshots?

Snapshots save component output and compare against future renders.

```javascript
test('matches snapshot', () => {
  const { container } = render(<UserCard user={mockUser} />);
  
  expect(container).toMatchSnapshot();
  // Creates __snapshots__/UserCard.test.js.snap
});

// First run: Creates snapshot
// Future runs: Compares against snapshot
// If different: Test fails (update snapshot if intentional)
```

**Update Snapshots:**
```bash
# Update all snapshots
npm test -- -u

# Update specific snapshot
npm test -- -u UserCard.test.js
```

**When to Use Snapshots:**
```javascript
// ✅ Good for:
// - Static components
// - Styled components
// - Component structure

// ❌ Avoid for:
// - Dynamic content
// - Dates, timestamps
// - Random data
// - Components with lots of logic
```

---

## 14.13 E2E Testing

### Cypress

**Installation:**
```bash
npm install --save-dev cypress
```

**Basic Test:**
```javascript
// cypress/e2e/login.cy.js
describe('Login Flow', () => {
  beforeEach(() => {
    cy.visit('http://localhost:3000');
  });
  
  it('logs in successfully', () => {
    // Find and interact with elements
    cy.get('input[name="email"]').type('user@example.com');
    cy.get('input[name="password"]').type('password123');
    cy.get('button[type="submit"]').click();
    
    // Assert navigation happened
    cy.url().should('include', '/dashboard');
    
    // Assert content
    cy.contains('Welcome back').should('be.visible');
  });
  
  it('shows error for invalid credentials', () => {
    cy.get('input[name="email"]').type('wrong@example.com');
    cy.get('input[name="password"]').type('wrongpass');
    cy.get('button[type="submit"]').click();
    
    cy.contains('Invalid credentials').should('be.visible');
  });
});
```

### Playwright (Modern Alternative)

**Installation:**
```bash
npm install --save-dev @playwright/test
```

**Basic Test:**
```javascript
import { test, expect } from '@playwright/test';

test('homepage has title', async ({ page }) => {
  await page.goto('http://localhost:3000');
  
  await expect(page).toHaveTitle(/React App/);
});

test('user can login', async ({ page }) => {
  await page.goto('http://localhost:3000/login');
  
  await page.fill('input[name="email"]', 'user@example.com');
  await page.fill('input[name="password"]', 'password123');
  await page.click('button[type="submit"]');
  
  await expect(page).toHaveURL(/dashboard/);
  await expect(page.locator('text=Welcome')).toBeVisible();
});
```

---

## 14.14 Testing Patterns

### Testing Todo App (Complete Example)

```javascript
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import TodoApp from './TodoApp';

describe('TodoApp', () => {
  test('adds new todo', async () => {
    const user = userEvent.setup();
    render(<TodoApp />);
    
    const input = screen.getByPlaceholderText(/add todo/i);
    const button = screen.getByRole('button', { name: /add/i });
    
    await user.type(input, 'Buy milk');
    await user.click(button);
    
    expect(screen.getByText('Buy milk')).toBeInTheDocument();
    expect(input).toHaveValue('');
  });
  
  test('toggles todo completion', async () => {
    const user = userEvent.setup();
    render(<TodoApp />);
    
    // Add todo first
    const input = screen.getByPlaceholderText(/add todo/i);
    await user.type(input, 'Task 1');
    await user.click(screen.getByRole('button', { name: /add/i }));
    
    // Toggle completion
    const checkbox = screen.getByRole('checkbox');
    await user.click(checkbox);
    
    expect(checkbox).toBeChecked();
  });
  
  test('deletes todo', async () => {
    const user = userEvent.setup();
    render(<TodoApp />);
    
    // Add todo
    const input = screen.getByPlaceholderText(/add todo/i);
    await user.type(input, 'Task to delete');
    await user.click(screen.getByRole('button', { name: /add/i }));
    
    // Delete todo
    const deleteButton = screen.getByRole('button', { name: /delete/i });
    await user.click(deleteButton);
    
    expect(screen.queryByText('Task to delete')).not.toBeInTheDocument();
  });
  
  test('filters todos', async () => {
    const user = userEvent.setup();
    render(<TodoApp />);
    
    // Add completed and active todos
    const input = screen.getByPlaceholderText(/add todo/i);
    
    await user.type(input, 'Completed task');
    await user.click(screen.getByRole('button', { name: /add/i }));
    await user.click(screen.getByRole('checkbox'));
    
    await user.type(input, 'Active task');
    await user.click(screen.getByRole('button', { name: /add/i }));
    
    // Filter to active
    await user.click(screen.getByRole('button', { name: /active/i }));
    
    expect(screen.getByText('Active task')).toBeInTheDocument();
    expect(screen.queryByText('Completed task')).not.toBeInTheDocument();
    
    // Filter to completed
    await user.click(screen.getByRole('button', { name: /completed/i }));
    
    expect(screen.getByText('Completed task')).toBeInTheDocument();
    expect(screen.queryByText('Active task')).not.toBeInTheDocument();
  });
});
```

---

## Summary of Chapter 14

**Key Concepts:**

1. **React Testing Library** - Test user behavior, not implementation
2. **Query Priority** - getByRole > getByLabelText > getByText > getByTestId
3. **User Interaction** - userEvent (realistic) > fireEvent (low-level)
4. **Async Testing** - findBy, waitFor for async operations
5. **Mocking** - jest.fn for functions, MSW for API calls
6. **Testing Hooks** - renderHook, act for custom hooks
7. **Integration Tests** - Test components working together
8. **E2E Tests** - Cypress or Playwright for full flows

**Test Types Pyramid:**
```
        /\
       /E2E\      ← Few (slow, expensive)
      /------\
     /Integra-\   ← Some (medium speed)
    /----------\
   /Unit Tests \  ← Many (fast, cheap)
  /--------------\
```

**What to Test:**

```javascript
// ✅ Test these:
- User interactions (clicks, typing, selecting)
- Conditional rendering
- Form submissions
- Error handling
- Loading states
- Accessibility (roles, labels)

// ❌ Don't test these:
- Implementation details (state, methods)
- Third-party libraries
- Styling (unless critical)
- Coverage for coverage's sake
```

**Query Cheat Sheet:**

| Query | When to Use | Returns |
|-------|------------|---------|
| getBy | Element must exist | Element or throw |
| queryBy | Element may not exist | Element or null |
| findBy | Element appears async | Promise |
| getAllBy | Multiple elements must exist | Array or throw |
| queryAllBy | Multiple may not exist | Array (empty if none) |
| findAllBy | Multiple appear async | Promise<Array> |

**Best Practices:**

```javascript
// 1. Test user behavior
test('user can add todo', async () => {
  // Simulate what user does
});

// 2. Use accessible queries
screen.getByRole('button', { name: /submit/i });

// 3. Use userEvent (not fireEvent)
await user.click(button);

// 4. Wait for async changes
const element = await screen.findByText(/loaded/i);

// 5. Mock API calls
// Use MSW for realistic mocking

// 6. Test one thing per test
test('adds todo', () => { /* ... */ });
test('deletes todo', () => { /* ... */ });
// Not: test('adds and deletes todo', () => {})
```

**Interview Focus:**
- Write basic component tests
- Use proper queries (getByRole)
- Handle async operations
- Mock API calls
- Test user interactions