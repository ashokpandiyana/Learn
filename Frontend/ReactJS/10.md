# Chapter 10: TypeScript with React - In-Depth Explanation

## Why TypeScript with React?

**TypeScript** adds static typing to JavaScript, catching errors before runtime.

**Benefits:**
- ✅ Catch errors during development
- ✅ Better IDE autocomplete
- ✅ Self-documenting code
- ✅ Easier refactoring
- ✅ Better team collaboration

**Industry Standard:** ~80% of React jobs require TypeScript

---

## 10.1 TypeScript Basics for React

### Setup

```bash
# Create React app with TypeScript
npx create-react-app my-app --template typescript

# Or with Vite
npm create vite@latest my-app -- --template react-ts

# Add to existing project
npm install --save-dev typescript @types/react @types/react-dom
```

### Basic Component Types

**Function Component:**
```typescript
// Simple component
function Greeting(): JSX.Element {
  return <h1>Hello!</h1>;
}

// With props
interface GreetingProps {
  name: string;
  age: number;
}

function Greeting({ name, age }: GreetingProps): JSX.Element {
  return <h1>Hello {name}, you are {age} years old!</h1>;
}

// Or using type
type GreetingProps = {
  name: string;
  age: number;
};

// React.FC (FunctionComponent) - optional
const Greeting: React.FC<GreetingProps> = ({ name, age }) => {
  return <h1>Hello {name}!</h1>;
};
```

### Props Typing

**Basic Props:**
```typescript
interface ButtonProps {
  text: string;
  onClick: () => void;
  disabled?: boolean;  // Optional with ?
  variant?: 'primary' | 'secondary';  // Union type
}

function Button({ text, onClick, disabled = false, variant = 'primary' }: ButtonProps) {
  return (
    <button onClick={onClick} disabled={disabled} className={variant}>
      {text}
    </button>
  );
}

// Usage
<Button text="Click me" onClick={() => console.log('clicked')} />
```

**Children Props:**
```typescript
interface CardProps {
  title: string;
  children: React.ReactNode;  // Can be any renderable content
}

function Card({ title, children }: CardProps) {
  return (
    <div>
      <h2>{title}</h2>
      <div>{children}</div>
    </div>
  );
}

// Types for children:
type ChildrenTypes = {
  children: React.ReactNode;      // Anything renderable
  children: React.ReactElement;   // Single React element
  children: JSX.Element;          // JSX element
  children: JSX.Element[];        // Array of JSX elements
  children: string;               // String only
  children: (data: T) => JSX.Element;  // Render function
};
```

**Event Props:**
```typescript
interface InputProps {
  value: string;
  onChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
  onFocus?: (event: React.FocusEvent<HTMLInputElement>) => void;
  onKeyPress?: (event: React.KeyboardEvent<HTMLInputElement>) => void;
}

function Input({ value, onChange, onFocus, onKeyPress }: InputProps) {
  return (
    <input 
      value={value}
      onChange={onChange}
      onFocus={onFocus}
      onKeyPress={onKeyPress}
    />
  );
}

// Common event types:
type EventTypes = {
  onClick: React.MouseEvent<HTMLButtonElement>;
  onChange: React.ChangeEvent<HTMLInputElement>;
  onSubmit: React.FormEvent<HTMLFormElement>;
  onFocus: React.FocusEvent<HTMLInputElement>;
  onBlur: React.FocusEvent<HTMLInputElement>;
  onKeyDown: React.KeyboardEvent<HTMLInputElement>;
  onMouseEnter: React.MouseEvent<HTMLDivElement>;
};
```

### State Typing

**useState:**
```typescript
// Type inference (TypeScript infers type)
const [count, setCount] = useState(0);  // number
const [name, setName] = useState('');   // string
const [isOpen, setIsOpen] = useState(false);  // boolean

// Explicit type
const [count, setCount] = useState<number>(0);

// Union types
const [status, setStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');

// Objects
interface User {
  id: number;
  name: string;
  email: string;
}

const [user, setUser] = useState<User | null>(null);

// Arrays
const [items, setItems] = useState<string[]>([]);
const [users, setUsers] = useState<User[]>([]);
```

**useReducer:**
```typescript
interface State {
  count: number;
  error: string | null;
}

type Action = 
  | { type: 'INCREMENT' }
  | { type: 'DECREMENT' }
  | { type: 'SET_ERROR'; payload: string }
  | { type: 'RESET' };

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    case 'SET_ERROR':
      return { ...state, error: action.payload };
    case 'RESET':
      return { count: 0, error: null };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0, error: null });
  
  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
    </div>
  );
}
```

**useRef:**
```typescript
// DOM ref
const inputRef = useRef<HTMLInputElement>(null);

// Mutable value
const countRef = useRef<number>(0);

// Usage
function Component() {
  const inputRef = useRef<HTMLInputElement>(null);
  
  const focusInput = () => {
    inputRef.current?.focus();  // Optional chaining
  };
  
  return <input ref={inputRef} />;
}
```

### Context Typing

```typescript
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  const value: ThemeContextType = {
    theme,
    toggleTheme
  };
  
  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme(): ThemeContextType {
  const context = useContext(ThemeContext);
  
  if (context === undefined) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  
  return context;
}
```

---

## 10.2 Advanced Types

### Generics in Components

```typescript
// Generic component
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
}

function List<T>({ items, renderItem }: ListProps<T>) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{renderItem(item)}</li>
      ))}
    </ul>
  );
}

// Usage with different types
interface User {
  id: number;
  name: string;
}

interface Product {
  id: number;
  title: string;
  price: number;
}

function App() {
  const users: User[] = [{ id: 1, name: 'John' }];
  const products: Product[] = [{ id: 1, title: 'Book', price: 10 }];
  
  return (
    <div>
      <List 
        items={users}
        renderItem={(user) => <span>{user.name}</span>}
      />
      
      <List 
        items={products}
        renderItem={(product) => <span>{product.title}</span>}
      />
    </div>
  );
}
```

### Utility Types

**Partial - Make all properties optional:**
```typescript
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}

// Update function accepts partial user
function updateUser(id: number, updates: Partial<User>) {
  // updates can have any combination of User properties
}

updateUser(1, { name: 'John' });  // ✅
updateUser(1, { age: 25, email: 'john@example.com' });  // ✅
```

**Pick - Select specific properties:**
```typescript
interface User {
  id: number;
  name: string;
  email: string;
  password: string;
}

// Only pick name and email
type UserPreview = Pick<User, 'name' | 'email'>;

const preview: UserPreview = {
  name: 'John',
  email: 'john@example.com'
  // password not needed
};
```

**Omit - Exclude specific properties:**
```typescript
interface User {
  id: number;
  name: string;
  email: string;
  password: string;
}

// Omit password
type SafeUser = Omit<User, 'password'>;

const safeUser: SafeUser = {
  id: 1,
  name: 'John',
  email: 'john@example.com'
  // No password
};
```

**Record - Create object type:**
```typescript
// Object with string keys and User values
type UserMap = Record<string, User>;

const users: UserMap = {
  'user1': { id: 1, name: 'John', email: 'john@example.com' },
  'user2': { id: 2, name: 'Jane', email: 'jane@example.com' }
};

// Record with specific keys
type Theme = Record<'primary' | 'secondary' | 'danger', string>;

const colors: Theme = {
  primary: '#007bff',
  secondary: '#6c757d',
  danger: '#dc3545'
};
```

**Readonly - Make properties readonly:**
```typescript
interface Config {
  apiUrl: string;
  timeout: number;
}

const config: Readonly<Config> = {
  apiUrl: 'https://api.example.com',
  timeout: 5000
};

// config.apiUrl = 'new url';  // ❌ Error: Cannot assign to readonly property
```

### Union and Intersection Types

**Union (OR):**
```typescript
type Status = 'idle' | 'loading' | 'success' | 'error';

interface IdleState {
  status: 'idle';
}

interface LoadingState {
  status: 'loading';
}

interface SuccessState {
  status: 'success';
  data: any;
}

interface ErrorState {
  status: 'error';
  error: string;
}

type State = IdleState | LoadingState | SuccessState | ErrorState;

function Component({ state }: { state: State }) {
  // TypeScript knows which properties are available
  if (state.status === 'success') {
    return <div>{state.data}</div>;  // data available here
  }
  
  if (state.status === 'error') {
    return <div>{state.error}</div>;  // error available here
  }
  
  return <div>Loading...</div>;
}
```

**Intersection (AND):**
```typescript
interface WithId {
  id: number;
}

interface WithTimestamps {
  createdAt: Date;
  updatedAt: Date;
}

interface User {
  name: string;
  email: string;
}

// Combine multiple types
type FullUser = User & WithId & WithTimestamps;

const user: FullUser = {
  id: 1,
  name: 'John',
  email: 'john@example.com',
  createdAt: new Date(),
  updatedAt: new Date()
};
```

---

## 10.3 Hooks with TypeScript

### useState

```typescript
// Type inference
const [count, setCount] = useState(0);  // number
const [name, setName] = useState('');   // string

// Explicit type
const [count, setCount] = useState<number>(0);

// Union type
const [status, setStatus] = useState<'idle' | 'loading' | 'success'>('idle');

// Nullable
const [user, setUser] = useState<User | null>(null);

// Array
const [items, setItems] = useState<string[]>([]);
const [users, setUsers] = useState<User[]>([]);

// Object
interface FormData {
  email: string;
  password: string;
}

const [formData, setFormData] = useState<FormData>({
  email: '',
  password: ''
});
```

### useEffect

```typescript
// No special typing needed for useEffect
useEffect(() => {
  // Effect code
  
  return () => {
    // Cleanup
  };
}, [dependencies]);

// Async in useEffect
useEffect(() => {
  async function fetchData() {
    const response = await fetch('/api/data');
    const data: User[] = await response.json();
    setUsers(data);
  }
  
  fetchData();
}, []);
```

### useRef

```typescript
// DOM element ref
const inputRef = useRef<HTMLInputElement>(null);
const divRef = useRef<HTMLDivElement>(null);
const buttonRef = useRef<HTMLButtonElement>(null);

// Mutable value ref
const countRef = useRef<number>(0);
const timerRef = useRef<NodeJS.Timeout | null>(null);

function Component() {
  const inputRef = useRef<HTMLInputElement>(null);
  
  const focusInput = () => {
    // Use optional chaining for null safety
    inputRef.current?.focus();
  };
  
  return <input ref={inputRef} />;
}
```

### useReducer

```typescript
interface State {
  count: number;
  error: string | null;
}

type Action =
  | { type: 'INCREMENT' }
  | { type: 'DECREMENT' }
  | { type: 'SET_ERROR'; payload: string }
  | { type: 'RESET' };

const initialState: State = {
  count: 0,
  error: null
};

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    case 'SET_ERROR':
      return { ...state, error: action.payload };
    case 'RESET':
      return initialState;
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  
  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
    </div>
  );
}
```

### useContext

```typescript
interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  isAuthenticated: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  
  const login = async (email: string, password: string): Promise<void> => {
    const response = await fetch('/api/login', {
      method: 'POST',
      body: JSON.stringify({ email, password })
    });
    const data = await response.json();
    setUser(data.user);
  };
  
  const logout = () => {
    setUser(null);
  };
  
  const value: AuthContextType = {
    user,
    login,
    logout,
    isAuthenticated: !!user
  };
  
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth(): AuthContextType {
  const context = useContext(AuthContext);
  
  if (context === undefined) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  
  return context;
}
```

### Custom Hooks

```typescript
// Return array (like useState)
function useToggle(initialValue: boolean = false): [boolean, () => void] {
  const [value, setValue] = useState(initialValue);
  
  const toggle = useCallback(() => {
    setValue(v => !v);
  }, []);
  
  return [value, toggle];
}

// Return object
interface UseCounterReturn {
  count: number;
  increment: () => void;
  decrement: () => void;
  reset: () => void;
}

function useCounter(initialValue: number = 0): UseCounterReturn {
  const [count, setCount] = useState(initialValue);
  
  const increment = useCallback(() => setCount(c => c + 1), []);
  const decrement = useCallback(() => setCount(c => c - 1), []);
  const reset = useCallback(() => setCount(initialValue), [initialValue]);
  
  return { count, increment, decrement, reset };
}

// Generic custom hook
function useFetch<T>(url: string): {
  data: T | null;
  loading: boolean;
  error: Error | null;
} {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  
  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then((data: T) => {
        setData(data);
        setLoading(false);
      })
      .catch((err: Error) => {
        setError(err);
        setLoading(false);
      });
  }, [url]);
  
  return { data, loading, error };
}

// Usage
interface User {
  id: number;
  name: string;
}

function UserProfile() {
  const { data: user, loading, error } = useFetch<User>('/api/user');
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error</div>;
  
  return <div>{user?.name}</div>;
}
```

---

## Summary of Chapter 10

**Key TypeScript Concepts for React:**

1. **Props Typing** - Interface or type for component props
2. **State Typing** - Type useState, useReducer state
3. **Event Typing** - React.MouseEvent, React.ChangeEvent, etc.
4. **Ref Typing** - HTMLInputElement, HTMLDivElement, etc.
5. **Generic Components** - Reusable with different types
6. **Utility Types** - Partial, Pick, Omit, Record

**Common Patterns:**

```typescript
// Props
interface Props {
  name: string;
  age?: number;
  onClick: () => void;
  children: React.ReactNode;
}

// State
const [user, setUser] = useState<User | null>(null);

// Events
const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {};

// Refs
const ref = useRef<HTMLInputElement>(null);

// Context
const value = useContext<ContextType>(MyContext);
```

**Best Practices:**

- Use `interface` for objects, `type` for unions
- Make optional props explicit with `?`
- Use generics for reusable components
- Leverage utility types
- Type custom hooks properly