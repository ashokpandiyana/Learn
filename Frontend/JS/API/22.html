<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 22: Performance Observer</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #0c1821 0%, #1b2838 100%); color: #e4e4e4; line-height: 1.7; padding: 40px 20px; min-height: 100vh; }
    .container { max-width: 900px; margin: 0 auto; }
    h1 { font-size: 2.5rem; background: linear-gradient(90deg, #4ade80, #22d3ee); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 10px; }
    .subtitle { color: #888; font-size: 1.1rem; margin-bottom: 40px; }
    h2 { color: #4ade80; font-size: 1.6rem; margin: 40px 0 20px; padding-bottom: 10px; border-bottom: 2px solid #22d3ee33; }
    h3 { color: #22d3ee; font-size: 1.2rem; margin: 25px 0 15px; }
    p { margin-bottom: 16px; color: #ccc; }
    .concept-box { background: linear-gradient(135deg, #1a3a2a 0%, #1b2838 100%); border-radius: 16px; padding: 25px; margin: 25px 0; border-left: 4px solid #4ade80; }
    .warning { background: linear-gradient(135deg, #4a2c2c 0%, #3d1f1f 100%); border-left-color: #ff6b6b; }
    .tip { background: linear-gradient(135deg, #1f4a2c 0%, #1f3d2a 100%); border-left-color: #4ade80; }
    .info { background: linear-gradient(135deg, #1a2f4a 0%, #1b2838 100%); border-left-color: #22d3ee; }
    code { background: #0d1117; padding: 3px 8px; border-radius: 4px; font-family: 'Fira Code', monospace; font-size: 0.9em; color: #4ade80; }
    pre { background: #0d1117; border-radius: 12px; padding: 20px; overflow-x: auto; margin: 20px 0; border: 1px solid #ffffff15; }
    pre code { padding: 0; background: none; }
    .keyword { color: #c792ea; }
    .function { color: #82aaff; }
    .string { color: #c3e88d; }
    .comment { color: #676e95; }
    .number { color: #f78c6c; }
    table { width: 100%; border-collapse: collapse; margin: 20px 0; }
    th, td { padding: 12px 15px; text-align: left; border-bottom: 1px solid #ffffff15; }
    th { background: #4ade8033; color: #4ade80; }
    tr:hover { background: #ffffff08; }
    .entry-types { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
    .entry-card { background: linear-gradient(135deg, #1b2838 0%, #0c1821 100%); padding: 20px; border-radius: 12px; border: 1px solid #22d3ee33; transition: transform 0.2s, box-shadow 0.2s; }
    .entry-card:hover { transform: translateY(-3px); box-shadow: 0 10px 30px rgba(34, 211, 238, 0.1); }
    .entry-card h4 { color: #22d3ee; margin-bottom: 8px; font-size: 1rem; }
    .entry-card p { font-size: 0.9rem; margin: 0; color: #aaa; }
    .timeline { position: relative; margin: 30px 0; padding: 20px 0; }
    .timeline::before { content: ''; position: absolute; left: 50%; top: 0; bottom: 0; width: 3px; background: linear-gradient(to bottom, #4ade80, #22d3ee); border-radius: 3px; }
    .timeline-item { display: flex; justify-content: center; margin: 20px 0; position: relative; }
    .timeline-content { background: #1b2838; padding: 15px 20px; border-radius: 10px; max-width: 300px; border: 1px solid #4ade8044; }
    .timeline-content h4 { color: #4ade80; margin-bottom: 5px; }
    .timeline-content p { font-size: 0.85rem; margin: 0; color: #aaa; }
    .vitals-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 30px 0; }
    .vital-card { background: linear-gradient(135deg, #1b2838, #0c1821); border-radius: 16px; padding: 25px; text-align: center; border: 2px solid; }
    .vital-card.lcp { border-color: #4ade80; }
    .vital-card.fid { border-color: #22d3ee; }
    .vital-card.cls { border-color: #f472b6; }
    .vital-value { font-size: 2.5rem; font-weight: bold; margin: 10px 0; }
    .vital-card.lcp .vital-value { color: #4ade80; }
    .vital-card.fid .vital-value { color: #22d3ee; }
    .vital-card.cls .vital-value { color: #f472b6; }
    .vital-label { font-size: 0.9rem; color: #888; }
    .vital-target { font-size: 0.8rem; margin-top: 10px; padding: 5px 10px; background: #ffffff10; border-radius: 20px; display: inline-block; }
    .interactive-demo { background: #0d1117; border-radius: 16px; padding: 25px; margin: 30px 0; border: 1px solid #4ade8044; }
    button { background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%); color: #0c1821; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 0.95rem; font-weight: 600; transition: all 0.2s; margin: 5px; }
    button:hover { transform: translateY(-2px); box-shadow: 0 5px 20px #4ade8055; }
    button.secondary { background: linear-gradient(135deg, #22d3ee, #06b6d4); }
    .metrics-display { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 20px 0; }
    .metric { background: #1b2838; padding: 15px; border-radius: 10px; text-align: center; }
    .metric-value { font-size: 1.5rem; font-weight: bold; color: #4ade80; font-family: monospace; }
    .metric-label { font-size: 0.8rem; color: #888; margin-top: 5px; }
    .log-output { background: #0a0a15; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 0.85rem; max-height: 200px; overflow-y: auto; margin-top: 15px; }
    .log-entry { padding: 5px 0; border-bottom: 1px solid #ffffff10; }
    .log-entry.mark { color: #4ade80; }
    .log-entry.measure { color: #22d3ee; }
    .log-entry.resource { color: #f472b6; }
    ul { margin-left: 25px; margin-bottom: 15px; }
    li { margin-bottom: 8px; color: #ccc; }
    .diagram { background: #0d1117; border-radius: 16px; padding: 30px; margin: 30px 0; text-align: center; }
    @media (max-width: 600px) {
      .vitals-grid { grid-template-columns: 1fr; }
      .timeline::before { left: 20px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>‚ö° Chapter 22: Performance Observer</h1>
    <p class="subtitle">Measuring and Monitoring Web Performance Metrics</p>

    <h2>üéØ What is Performance Observer?</h2>
    <p>The <strong>Performance Observer API</strong> provides a way to subscribe to performance-related events and be notified of new performance entries as they're recorded. It's the modern way to measure everything from page load times to custom application metrics.</p>

    <div class="concept-box">
      <h3>üí° Why Use Performance Observer?</h3>
      <p>Instead of polling <code>performance.getEntries()</code> repeatedly, Performance Observer uses a callback pattern‚Äîyou're notified exactly when new metrics become available. This is more efficient and ensures you don't miss any entries.</p>
    </div>

    <h2>üìä Entry Types</h2>
    <p>Performance Observer can monitor various types of performance entries:</p>

    <div class="entry-types">
      <div class="entry-card">
        <h4>navigation</h4>
        <p>Page load timing information</p>
      </div>
      <div class="entry-card">
        <h4>resource</h4>
        <p>Resource loading times (scripts, images, CSS)</p>
      </div>
      <div class="entry-card">
        <h4>mark</h4>
        <p>Custom timestamp markers</p>
      </div>
      <div class="entry-card">
        <h4>measure</h4>
        <p>Custom duration measurements</p>
      </div>
      <div class="entry-card">
        <h4>paint</h4>
        <p>First Paint & First Contentful Paint</p>
      </div>
      <div class="entry-card">
        <h4>largest-contentful-paint</h4>
        <p>LCP - Core Web Vital</p>
      </div>
      <div class="entry-card">
        <h4>first-input</h4>
        <p>FID - First Input Delay</p>
      </div>
      <div class="entry-card">
        <h4>layout-shift</h4>
        <p>CLS - Layout Shift detection</p>
      </div>
      <div class="entry-card">
        <h4>longtask</h4>
        <p>Tasks blocking main thread &gt;50ms</p>
      </div>
      <div class="entry-card">
        <h4>element</h4>
        <p>Element render timing</p>
      </div>
    </div>

    <h2>üìù Basic Usage</h2>
    <pre><code><span class="comment">// Create a Performance Observer</span>
<span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="function">PerformanceObserver</span>((list, observer) => {
    <span class="comment">// list is a PerformanceObserverEntryList</span>
    <span class="keyword">const</span> entries = list.<span class="function">getEntries</span>();
    
    entries.<span class="function">forEach</span>(entry => {
        console.<span class="function">log</span>(entry.name, entry.duration);
    });
});

<span class="comment">// Start observing specific entry types</span>
observer.<span class="function">observe</span>({ 
    type: <span class="string">'measure'</span>,
    buffered: <span class="keyword">true</span>  <span class="comment">// Include entries from before observe()</span>
});

<span class="comment">// Or observe multiple types</span>
observer.<span class="function">observe</span>({ 
    entryTypes: [<span class="string">'mark'</span>, <span class="string">'measure'</span>, <span class="string">'resource'</span>] 
});</code></pre>

    <div class="concept-box info">
      <h3>üìå buffered: true</h3>
      <p>When <code>buffered: true</code> is set, the observer will receive entries that were recorded before <code>observe()</code> was called. This is crucial for metrics like LCP that might occur before your JavaScript runs.</p>
    </div>

    <h2>üîß Custom Marks & Measures</h2>
    <p>Create your own performance measurements using the Performance Timeline API:</p>

    <pre><code><span class="comment">// Create a timestamp marker</span>
performance.<span class="function">mark</span>(<span class="string">'api-call-start'</span>);

<span class="comment">// ... do some work (e.g., fetch data) ...</span>
<span class="keyword">await</span> <span class="function">fetchData</span>();

<span class="comment">// Create another marker</span>
performance.<span class="function">mark</span>(<span class="string">'api-call-end'</span>);

<span class="comment">// Measure the duration between two marks</span>
performance.<span class="function">measure</span>(
    <span class="string">'api-call-duration'</span>,    <span class="comment">// Name of the measure</span>
    <span class="string">'api-call-start'</span>,       <span class="comment">// Start mark</span>
    <span class="string">'api-call-end'</span>          <span class="comment">// End mark</span>
);

<span class="comment">// Get the measure</span>
<span class="keyword">const</span> measures = performance.<span class="function">getEntriesByName</span>(<span class="string">'api-call-duration'</span>);
console.<span class="function">log</span>(<span class="string">`API call took ${measures[0].duration}ms`</span>);

<span class="comment">// Clean up</span>
performance.<span class="function">clearMarks</span>();
performance.<span class="function">clearMeasures</span>();</code></pre>

    <h2>üéÆ Interactive Demo</h2>
    <div class="interactive-demo">
      <p>Click the buttons to create performance marks and measures:</p>
      <div style="margin: 15px 0;">
        <button onclick="createMark()">Create Mark</button>
        <button onclick="createMeasure()" class="secondary">Create Measure</button>
        <button onclick="simulateWork()">Simulate Work</button>
        <button onclick="clearAll()" style="background: #ef4444;">Clear All</button>
      </div>
      <div class="metrics-display">
        <div class="metric">
          <div class="metric-value" id="mark-count">0</div>
          <div class="metric-label">Marks</div>
        </div>
        <div class="metric">
          <div class="metric-value" id="measure-count">0</div>
          <div class="metric-label">Measures</div>
        </div>
        <div class="metric">
          <div class="metric-value" id="last-duration">-</div>
          <div class="metric-label">Last Duration</div>
        </div>
      </div>
      <div class="log-output" id="perf-log"></div>
    </div>

    <h2>üìà Core Web Vitals</h2>
    <p>Performance Observer is essential for measuring Google's Core Web Vitals‚Äîthe key metrics for user experience:</p>

    <div class="vitals-grid">
      <div class="vital-card lcp">
        <h4>LCP</h4>
        <div class="vital-value">2.5s</div>
        <div class="vital-label">Largest Contentful Paint</div>
        <div class="vital-target">Target: &lt; 2.5s</div>
      </div>
      <div class="vital-card fid">
        <h4>FID</h4>
        <div class="vital-value">100ms</div>
        <div class="vital-label">First Input Delay</div>
        <div class="vital-target">Target: &lt; 100ms</div>
      </div>
      <div class="vital-card cls">
        <h4>CLS</h4>
        <div class="vital-value">0.1</div>
        <div class="vital-label">Cumulative Layout Shift</div>
        <div class="vital-target">Target: &lt; 0.1</div>
      </div>
    </div>

    <h3>Measuring LCP (Largest Contentful Paint)</h3>
    <pre><code><span class="keyword">new</span> <span class="function">PerformanceObserver</span>((list) => {
    <span class="keyword">const</span> entries = list.<span class="function">getEntries</span>();
    <span class="comment">// LCP is the last entry (it can change as page loads)</span>
    <span class="keyword">const</span> lcp = entries[entries.length - <span class="number">1</span>];
    
    console.<span class="function">log</span>(<span class="string">'LCP:'</span>, lcp.startTime, <span class="string">'ms'</span>);
    console.<span class="function">log</span>(<span class="string">'Element:'</span>, lcp.element);  <span class="comment">// The LCP element</span>
    console.<span class="function">log</span>(<span class="string">'Size:'</span>, lcp.size);
}).<span class="function">observe</span>({ type: <span class="string">'largest-contentful-paint'</span>, buffered: <span class="keyword">true</span> });</code></pre>

    <h3>Measuring FID (First Input Delay)</h3>
    <pre><code><span class="keyword">new</span> <span class="function">PerformanceObserver</span>((list) => {
    <span class="keyword">const</span> entry = list.<span class="function">getEntries</span>()[<span class="number">0</span>];
    
    <span class="comment">// FID = time from user input to when browser could respond</span>
    <span class="keyword">const</span> fid = entry.processingStart - entry.startTime;
    
    console.<span class="function">log</span>(<span class="string">'FID:'</span>, fid, <span class="string">'ms'</span>);
    console.<span class="function">log</span>(<span class="string">'Input type:'</span>, entry.name);  <span class="comment">// 'click', 'keydown', etc.</span>
}).<span class="function">observe</span>({ type: <span class="string">'first-input'</span>, buffered: <span class="keyword">true</span> });</code></pre>

    <h3>Measuring CLS (Cumulative Layout Shift)</h3>
    <pre><code><span class="keyword">let</span> clsValue = <span class="number">0</span>;

<span class="keyword">new</span> <span class="function">PerformanceObserver</span>((list) => {
    <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> list.<span class="function">getEntries</span>()) {
        <span class="comment">// Only count shifts without recent user input</span>
        <span class="keyword">if</span> (!entry.hadRecentInput) {
            clsValue += entry.value;
        }
    }
    console.<span class="function">log</span>(<span class="string">'Current CLS:'</span>, clsValue);
}).<span class="function">observe</span>({ type: <span class="string">'layout-shift'</span>, buffered: <span class="keyword">true</span> });</code></pre>

    <h2>üåê Resource Timing</h2>
    <p>Monitor how long resources take to load:</p>

    <pre><code><span class="keyword">new</span> <span class="function">PerformanceObserver</span>((list) => {
    list.<span class="function">getEntries</span>().<span class="function">forEach</span>(entry => {
        console.<span class="function">log</span>(<span class="string">`Resource: ${entry.name}`</span>);
        console.<span class="function">log</span>(<span class="string">`  Type: ${entry.initiatorType}`</span>);  <span class="comment">// script, css, img, fetch</span>
        console.<span class="function">log</span>(<span class="string">`  Duration: ${entry.duration}ms`</span>);
        console.<span class="function">log</span>(<span class="string">`  Transfer size: ${entry.transferSize} bytes`</span>);
        
        <span class="comment">// Detailed timing breakdown</span>
        console.<span class="function">log</span>(<span class="string">`  DNS: ${entry.domainLookupEnd - entry.domainLookupStart}ms`</span>);
        console.<span class="function">log</span>(<span class="string">`  Connect: ${entry.connectEnd - entry.connectStart}ms`</span>);
        console.<span class="function">log</span>(<span class="string">`  TTFB: ${entry.responseStart - entry.requestStart}ms`</span>);
        console.<span class="function">log</span>(<span class="string">`  Download: ${entry.responseEnd - entry.responseStart}ms`</span>);
    });
}).<span class="function">observe</span>({ type: <span class="string">'resource'</span>, buffered: <span class="keyword">true</span> });</code></pre>

    <h2>‚è±Ô∏è Long Tasks</h2>
    <p>Detect tasks that block the main thread for more than 50ms:</p>

    <pre><code><span class="keyword">new</span> <span class="function">PerformanceObserver</span>((list) => {
    list.<span class="function">getEntries</span>().<span class="function">forEach</span>(entry => {
        console.<span class="function">warn</span>(<span class="string">`‚ö†Ô∏è Long task detected!`</span>);
        console.<span class="function">log</span>(<span class="string">`  Duration: ${entry.duration}ms`</span>);
        console.<span class="function">log</span>(<span class="string">`  Start time: ${entry.startTime}ms`</span>);
        
        <span class="comment">// Attribution helps identify the source</span>
        entry.attribution.<span class="function">forEach</span>(attr => {
            console.<span class="function">log</span>(<span class="string">`  Container: ${attr.containerType}`</span>);
            console.<span class="function">log</span>(<span class="string">`  Name: ${attr.containerName}`</span>);
        });
    });
}).<span class="function">observe</span>({ type: <span class="string">'longtask'</span> });</code></pre>

    <h2>üìã Navigation Timing</h2>
    <p>Get comprehensive page load metrics:</p>

    <pre><code><span class="keyword">new</span> <span class="function">PerformanceObserver</span>((list) => {
    <span class="keyword">const</span> nav = list.<span class="function">getEntries</span>()[<span class="number">0</span>];
    
    <span class="comment">// Key metrics</span>
    <span class="keyword">const</span> dns = nav.domainLookupEnd - nav.domainLookupStart;
    <span class="keyword">const</span> tcp = nav.connectEnd - nav.connectStart;
    <span class="keyword">const</span> ttfb = nav.responseStart - nav.requestStart;
    <span class="keyword">const</span> domParsing = nav.domInteractive - nav.responseEnd;
    <span class="keyword">const</span> domContentLoaded = nav.domContentLoadedEventEnd - nav.startTime;
    <span class="keyword">const</span> loadComplete = nav.loadEventEnd - nav.startTime;
    
    console.<span class="function">log</span>(<span class="string">'DNS lookup:'</span>, dns);
    console.<span class="function">log</span>(<span class="string">'TCP connection:'</span>, tcp);
    console.<span class="function">log</span>(<span class="string">'Time to First Byte:'</span>, ttfb);
    console.<span class="function">log</span>(<span class="string">'DOM parsing:'</span>, domParsing);
    console.<span class="function">log</span>(<span class="string">'DOMContentLoaded:'</span>, domContentLoaded);
    console.<span class="function">log</span>(<span class="string">'Load complete:'</span>, loadComplete);
}).<span class="function">observe</span>({ type: <span class="string">'navigation'</span>, buffered: <span class="keyword">true</span> });</code></pre>

    <h2>üõ†Ô∏è Real-World Analytics Example</h2>
    <pre><code><span class="keyword">class</span> <span class="function">PerformanceTracker</span> {
    <span class="function">constructor</span>() {
        <span class="keyword">this</span>.metrics = {};
        <span class="keyword">this</span>.<span class="function">initObservers</span>();
    }
    
    <span class="function">initObservers</span>() {
        <span class="comment">// Track Core Web Vitals</span>
        <span class="keyword">this</span>.<span class="function">observeLCP</span>();
        <span class="keyword">this</span>.<span class="function">observeFID</span>();
        <span class="keyword">this</span>.<span class="function">observeCLS</span>();
        
        <span class="comment">// Send metrics when page is about to unload</span>
        addEventListener(<span class="string">'visibilitychange'</span>, () => {
            <span class="keyword">if</span> (document.visibilityState === <span class="string">'hidden'</span>) {
                <span class="keyword">this</span>.<span class="function">sendMetrics</span>();
            }
        });
    }
    
    <span class="function">observeLCP</span>() {
        <span class="keyword">new</span> <span class="function">PerformanceObserver</span>((list) => {
            <span class="keyword">const</span> entries = list.<span class="function">getEntries</span>();
            <span class="keyword">this</span>.metrics.lcp = entries[entries.length - <span class="number">1</span>].startTime;
        }).<span class="function">observe</span>({ type: <span class="string">'largest-contentful-paint'</span>, buffered: <span class="keyword">true</span> });
    }
    
    <span class="function">observeFID</span>() {
        <span class="keyword">new</span> <span class="function">PerformanceObserver</span>((list) => {
            <span class="keyword">const</span> entry = list.<span class="function">getEntries</span>()[<span class="number">0</span>];
            <span class="keyword">this</span>.metrics.fid = entry.processingStart - entry.startTime;
        }).<span class="function">observe</span>({ type: <span class="string">'first-input'</span>, buffered: <span class="keyword">true</span> });
    }
    
    <span class="function">observeCLS</span>() {
        <span class="keyword">this</span>.metrics.cls = <span class="number">0</span>;
        <span class="keyword">new</span> <span class="function">PerformanceObserver</span>((list) => {
            <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> list.<span class="function">getEntries</span>()) {
                <span class="keyword">if</span> (!entry.hadRecentInput) {
                    <span class="keyword">this</span>.metrics.cls += entry.value;
                }
            }
        }).<span class="function">observe</span>({ type: <span class="string">'layout-shift'</span>, buffered: <span class="keyword">true</span> });
    }
    
    <span class="function">sendMetrics</span>() {
        navigator.<span class="function">sendBeacon</span>(<span class="string">'/analytics'</span>, JSON.<span class="function">stringify</span>(<span class="keyword">this</span>.metrics));
    }
}

<span class="keyword">const</span> tracker = <span class="keyword">new</span> <span class="function">PerformanceTracker</span>();</code></pre>

    <div class="concept-box tip">
      <h3>‚úÖ Best Practices</h3>
      <ul style="margin-left: 20px; margin-top: 10px;">
        <li>Always use <code>buffered: true</code> for metrics that occur early (LCP, FID)</li>
        <li>Send metrics on <code>visibilitychange</code> to capture users who close the tab</li>
        <li>Use <code>sendBeacon()</code> for reliable delivery on page unload</li>
        <li>For CLS, only count shifts without recent user input</li>
        <li>LCP can change‚Äîalways use the last entry</li>
      </ul>
    </div>

    <div class="concept-box warning">
      <h3>‚ö†Ô∏è Browser Support Note</h3>
      <p>Not all entry types are supported in all browsers. Always check for support:</p>
      <pre style="margin-top:10px;"><code><span class="keyword">if</span> (PerformanceObserver.<span class="function">supportedEntryTypes</span>.<span class="function">includes</span>(<span class="string">'largest-contentful-paint'</span>)) {
    <span class="comment">// Safe to observe LCP</span>
}</code></pre>
    </div>
  </div>

  <script>
    let markCount = 0;
    const log = document.getElementById('perf-log');
    
    // Performance Observer for our demo
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach(entry => {
        const div = document.createElement('div');
        div.className = `log-entry ${entry.entryType}`;
        
        if (entry.entryType === 'mark') {
          div.textContent = `üìç Mark: "${entry.name}" at ${entry.startTime.toFixed(2)}ms`;
        } else if (entry.entryType === 'measure') {
          div.textContent = `üìè Measure: "${entry.name}" = ${entry.duration.toFixed(2)}ms`;
          document.getElementById('last-duration').textContent = entry.duration.toFixed(1) + 'ms';
        }
        
        log.prepend(div);
      });
      
      updateCounts();
    });
    
    observer.observe({ entryTypes: ['mark', 'measure'] });
    
    function createMark() {
      markCount++;
      performance.mark(`mark-${markCount}`);
      document.getElementById('mark-count').textContent = markCount;
    }
    
    function createMeasure() {
      if (markCount < 2) {
        alert('Create at least 2 marks first!');
        return;
      }
      performance.measure(
        `measure-${markCount-1}-to-${markCount}`,
        `mark-${markCount-1}`,
        `mark-${markCount}`
      );
      updateCounts();
    }
    
    function simulateWork() {
      performance.mark('work-start');
      
      // Simulate heavy computation
      let result = 0;
      for (let i = 0; i < 10000000; i++) {
        result += Math.sqrt(i);
      }
      
      performance.mark('work-end');
      performance.measure('simulated-work', 'work-start', 'work-end');
      markCount += 2;
      updateCounts();
    }
    
    function clearAll() {
      performance.clearMarks();
      performance.clearMeasures();
      markCount = 0;
      log.innerHTML = '';
      document.getElementById('mark-count').textContent = '0';
      document.getElementById('measure-count').textContent = '0';
      document.getElementById('last-duration').textContent = '-';
    }
    
    function updateCounts() {
      document.getElementById('mark-count').textContent = performance.getEntriesByType('mark').length;
      document.getElementById('measure-count').textContent = performance.getEntriesByType('measure').length;
    }
  </script>
</body>
</html>
