<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 1: GraphQL Core Concepts</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #e4e4e7;
      line-height: 1.7;
      padding: 40px 20px;
      min-height: 100vh;
    }
    .container { max-width: 900px; margin: 0 auto; }
    h1 {
      font-size: 2.5rem;
      background: linear-gradient(90deg, #e879f9, #818cf8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 10px;
    }
    .subtitle { color: #a1a1aa; font-size: 1.1rem; margin-bottom: 40px; }
    h2 {
      color: #c084fc;
      font-size: 1.6rem;
      margin: 40px 0 20px;
      padding-bottom: 10px;
      border-bottom: 2px solid #3f3f46;
    }
    h3 { color: #a78bfa; font-size: 1.2rem; margin: 25px 0 15px; }
    p { margin-bottom: 15px; color: #d4d4d8; }
    .highlight-box {
      background: linear-gradient(135deg, #312e81 0%, #1e1b4b 100%);
      border-left: 4px solid #818cf8;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .warning-box {
      background: linear-gradient(135deg, #78350f 0%, #451a03 100%);
      border-left: 4px solid #f59e0b;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .warning-box::before { content: "‚ö†Ô∏è INTERVIEW HIGHLIGHT: "; font-weight: bold; color: #fbbf24; }
    .tip-box {
      background: linear-gradient(135deg, #064e3b 0%, #022c22 100%);
      border-left: 4px solid #10b981;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .tip-box::before { content: "üìù KEY CONCEPT: "; font-weight: bold; color: #34d399; }
    pre {
      background: #0f0f23;
      border: 1px solid #3f3f46;
      border-radius: 12px;
      padding: 20px;
      overflow-x: auto;
      margin: 15px 0;
    }
    code {
      font-family: 'Fira Code', 'Consolas', monospace;
      font-size: 0.9rem;
    }
    .inline-code {
      background: #3f3f46;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.85rem;
    }
    .keyword { color: #c084fc; }
    .type { color: #38bdf8; }
    .string { color: #4ade80; }
    .comment { color: #6b7280; font-style: italic; }
    .field { color: #fbbf24; }
    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      background: #1f1f3a;
      border-radius: 12px;
      overflow: hidden;
    }
    .comparison-table th {
      background: linear-gradient(90deg, #4c1d95, #312e81);
      padding: 15px;
      text-align: left;
      font-weight: 600;
    }
    .comparison-table td {
      padding: 12px 15px;
      border-bottom: 1px solid #3f3f46;
    }
    .comparison-table tr:last-child td { border-bottom: none; }
    .diagram {
      background: #0f0f23;
      border-radius: 12px;
      padding: 30px;
      margin: 20px 0;
      text-align: center;
    }
    .diagram svg { max-width: 100%; height: auto; }
    .type-card {
      background: linear-gradient(135deg, #1e1b4b 0%, #0f0f23 100%);
      border: 1px solid #4c1d95;
      border-radius: 12px;
      padding: 20px;
      margin: 15px 0;
    }
    .type-card h4 {
      color: #c084fc;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 600;
    }
    .badge-scalar { background: #065f46; color: #6ee7b7; }
    .badge-object { background: #1e40af; color: #93c5fd; }
    .badge-special { background: #7c2d12; color: #fdba74; }
    ul { margin: 15px 0 15px 25px; }
    li { margin: 8px 0; color: #d4d4d8; }
    .chapter-nav {
      display: flex;
      justify-content: space-between;
      margin-top: 50px;
      padding-top: 30px;
      border-top: 1px solid #3f3f46;
    }
    .nav-btn {
      padding: 12px 24px;
      background: linear-gradient(90deg, #4c1d95, #6d28d9);
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Chapter 1</h1>
    <p class="subtitle">GraphQL Core Concepts ‚Äî The Foundation of Modern API Communication</p>

    <!-- Section 1.1 -->
    <h2>1.1 What is GraphQL?</h2>
    
    <p>GraphQL is a <strong>query language for APIs</strong> and a <strong>runtime for executing those queries</strong> against your data. It was developed internally by Facebook in 2012 to address the challenges they faced with mobile app performance and was open-sourced in 2015.</p>

    <div class="highlight-box">
      <strong>Key Understanding:</strong> GraphQL is NOT a database. It's a specification that sits between your client and your data sources (databases, REST APIs, microservices, etc.). Think of it as a smart translator that lets clients ask for exactly what they need.
    </div>

    <h3>The Problem GraphQL Solves</h3>
    
    <div class="diagram">
      <svg viewBox="0 0 700 300" xmlns="http://www.w3.org/2000/svg">
        <!-- REST Side -->
        <text x="120" y="30" fill="#ef4444" font-size="16" font-weight="bold">REST Approach</text>
        <rect x="20" y="50" width="80" height="40" rx="5" fill="#1e40af"/>
        <text x="60" y="75" fill="white" font-size="11" text-anchor="middle">Client</text>
        
        <!-- Multiple arrows for REST -->
        <line x1="100" y1="60" x2="180" y2="60" stroke="#ef4444" stroke-width="2" marker-end="url(#arrow)"/>
        <line x1="100" y1="70" x2="180" y2="90" stroke="#ef4444" stroke-width="2"/>
        <line x1="100" y1="80" x2="180" y2="120" stroke="#ef4444" stroke-width="2"/>
        
        <rect x="180" y="45" width="100" height="30" rx="5" fill="#374151"/>
        <text x="230" y="65" fill="#9ca3af" font-size="10" text-anchor="middle">/api/users/1</text>
        
        <rect x="180" y="80" width="100" height="30" rx="5" fill="#374151"/>
        <text x="230" y="100" fill="#9ca3af" font-size="10" text-anchor="middle">/api/users/1/posts</text>
        
        <rect x="180" y="115" width="100" height="30" rx="5" fill="#374151"/>
        <text x="230" y="135" fill="#9ca3af" font-size="10" text-anchor="middle">/api/posts/1/comments</text>
        
        <text x="120" y="180" fill="#ef4444" font-size="12">‚ùå 3 requests needed</text>
        <text x="120" y="200" fill="#ef4444" font-size="12">‚ùå Over-fetching data</text>
        
        <!-- Divider -->
        <line x1="350" y1="20" x2="350" y2="280" stroke="#3f3f46" stroke-width="2" stroke-dasharray="5,5"/>
        
        <!-- GraphQL Side -->
        <text x="520" y="30" fill="#10b981" font-size="16" font-weight="bold">GraphQL Approach</text>
        <rect x="400" y="70" width="80" height="40" rx="5" fill="#1e40af"/>
        <text x="440" y="95" fill="white" font-size="11" text-anchor="middle">Client</text>
        
        <!-- Single arrow for GraphQL -->
        <line x1="480" y1="90" x2="560" y2="90" stroke="#10b981" stroke-width="3" marker-end="url(#arrow2)"/>
        
        <rect x="560" y="60" width="120" height="60" rx="5" fill="#374151"/>
        <text x="620" y="85" fill="#9ca3af" font-size="10" text-anchor="middle">/graphql</text>
        <text x="620" y="105" fill="#10b981" font-size="10" text-anchor="middle">Single Endpoint</text>
        
        <text x="520" y="180" fill="#10b981" font-size="12">‚úì 1 request</text>
        <text x="520" y="200" fill="#10b981" font-size="12">‚úì Exact data needed</text>
        
        <defs>
          <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
            <path d="M0,0 L0,6 L9,3 z" fill="#ef4444"/>
          </marker>
          <marker id="arrow2" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
            <path d="M0,0 L0,6 L9,3 z" fill="#10b981"/>
          </marker>
        </defs>
      </svg>
    </div>

    <!-- Section 1.2 -->
    <h2>1.2 GraphQL vs REST ‚Äî Deep Comparison</h2>

    <table class="comparison-table">
      <tr>
        <th>Aspect</th>
        <th>GraphQL</th>
        <th>REST</th>
      </tr>
      <tr>
        <td><strong>Endpoints</strong></td>
        <td>Single endpoint (<code class="inline-code">/graphql</code>)</td>
        <td>Multiple endpoints (<code class="inline-code">/users</code>, <code class="inline-code">/posts</code>)</td>
      </tr>
      <tr>
        <td><strong>Data Fetching</strong></td>
        <td>Client specifies exact fields needed</td>
        <td>Server decides response structure</td>
      </tr>
      <tr>
        <td><strong>Over-fetching</strong></td>
        <td>‚ùå Never ‚Äî get only what you ask</td>
        <td>‚úì Common ‚Äî fixed response shapes</td>
      </tr>
      <tr>
        <td><strong>Under-fetching</strong></td>
        <td>‚ùå Never ‚Äî nested queries in one request</td>
        <td>‚úì Common ‚Äî multiple round trips</td>
      </tr>
      <tr>
        <td><strong>Versioning</strong></td>
        <td>No versioning needed (evolve schema)</td>
        <td>v1, v2, v3 endpoints required</td>
      </tr>
      <tr>
        <td><strong>Type System</strong></td>
        <td>Strongly typed schema (SDL)</td>
        <td>No built-in type system</td>
      </tr>
      <tr>
        <td><strong>Documentation</strong></td>
        <td>Auto-generated via introspection</td>
        <td>Manual (Swagger/OpenAPI)</td>
      </tr>
      <tr>
        <td><strong>Real-time</strong></td>
        <td>Built-in Subscriptions</td>
        <td>Requires separate WebSocket setup</td>
      </tr>
      <tr>
        <td><strong>Caching</strong></td>
        <td>Complex (needs client library)</td>
        <td>Simple (HTTP caching)</td>
      </tr>
    </table>

    <div class="warning-box">
      GraphQL solves <strong>over-fetching</strong> (getting too much data) and <strong>under-fetching</strong> (needing multiple requests) problems. In a single query, you request exactly what you need, even across related entities.
    </div>

    <h3>Practical Example: Over-fetching vs Exact Fetching</h3>

    <pre><code><span class="comment">// REST: Get user - returns EVERYTHING</span>
<span class="comment">// GET /api/users/1</span>
{
  <span class="field">"id"</span>: <span class="string">"1"</span>,
  <span class="field">"name"</span>: <span class="string">"John Doe"</span>,
  <span class="field">"email"</span>: <span class="string">"john@example.com"</span>,
  <span class="field">"phone"</span>: <span class="string">"+1234567890"</span>,        <span class="comment">// ‚ùå Don't need this</span>
  <span class="field">"address"</span>: { ... },               <span class="comment">// ‚ùå Don't need this</span>
  <span class="field">"preferences"</span>: { ... },           <span class="comment">// ‚ùå Don't need this</span>
  <span class="field">"createdAt"</span>: <span class="string">"2024-01-01"</span>,        <span class="comment">// ‚ùå Don't need this</span>
  <span class="field">"updatedAt"</span>: <span class="string">"2024-06-15"</span>         <span class="comment">// ‚ùå Don't need this</span>
}

<span class="comment">// GraphQL: Get user - returns ONLY what you ask</span>
<span class="keyword">query</span> {
  <span class="field">user</span>(id: <span class="string">"1"</span>) {
    <span class="field">name</span>    <span class="comment">// ‚úì Only this</span>
    <span class="field">email</span>   <span class="comment">// ‚úì And this</span>
  }
}

<span class="comment">// Response:</span>
{
  <span class="field">"data"</span>: {
    <span class="field">"user"</span>: {
      <span class="field">"name"</span>: <span class="string">"John Doe"</span>,
      <span class="field">"email"</span>: <span class="string">"john@example.com"</span>
    }
  }
}</code></pre>

    <!-- Section 1.3 -->
    <h2>1.3 GraphQL Type System ‚Äî The Heart of GraphQL</h2>

    <p>GraphQL is <strong>strongly typed</strong>. Every piece of data has a defined type, and the schema acts as a contract between client and server. This enables powerful tooling, auto-completion, and compile-time error checking.</p>

    <h3>Scalar Types (Primitives)</h3>
    
    <div class="type-card">
      <h4><span class="badge badge-scalar">SCALAR</span> Built-in Scalar Types</h4>
      <p>These are the leaf values in GraphQL ‚Äî they resolve to concrete data.</p>
      <pre><code><span class="type">Int</span>      <span class="comment">‚Üí 32-bit signed integer (e.g., 42, -17)</span>
<span class="type">Float</span>    <span class="comment">‚Üí Double-precision floating-point (e.g., 3.14, -0.5)</span>
<span class="type">String</span>   <span class="comment">‚Üí UTF-8 character sequence (e.g., "Hello")</span>
<span class="type">Boolean</span>  <span class="comment">‚Üí true or false</span>
<span class="type">ID</span>       <span class="comment">‚Üí Unique identifier (serialized as String)</span></code></pre>
    </div>

    <div class="tip-box">
      The <code class="inline-code">ID</code> type is special ‚Äî it's always serialized as a String but semantically represents a unique identifier. Apollo Client uses this for cache normalization!
    </div>

    <h3>Object Types (Custom Types)</h3>

    <div class="type-card">
      <h4><span class="badge badge-object">OBJECT</span> Defining Custom Types</h4>
      <p>Object types are the building blocks of your schema. They define the shape of your data.</p>
      <pre><code><span class="keyword">type</span> <span class="type">User</span> {
  <span class="field">id</span>: <span class="type">ID!</span>              <span class="comment"># Non-nullable ID</span>
  <span class="field">name</span>: <span class="type">String!</span>        <span class="comment"># Non-nullable String</span>
  <span class="field">email</span>: <span class="type">String</span>         <span class="comment"># Nullable String (can be null)</span>
  <span class="field">age</span>: <span class="type">Int</span>             <span class="comment"># Nullable Int</span>
  <span class="field">isActive</span>: <span class="type">Boolean!</span>   <span class="comment"># Non-nullable Boolean</span>
  <span class="field">posts</span>: [<span class="type">Post!</span>]!       <span class="comment"># Non-nullable array of non-nullable Posts</span>
  <span class="field">friends</span>: [<span class="type">User!</span>]      <span class="comment"># Nullable array of non-nullable Users</span>
}

<span class="keyword">type</span> <span class="type">Post</span> {
  <span class="field">id</span>: <span class="type">ID!</span>
  <span class="field">title</span>: <span class="type">String!</span>
  <span class="field">content</span>: <span class="type">String!</span>
  <span class="field">author</span>: <span class="type">User!</span>        <span class="comment"># Relationship to User</span>
  <span class="field">publishedAt</span>: <span class="type">String</span>
}</code></pre>
    </div>

    <h3>Understanding Nullability ‚Äî The "!" Symbol</h3>

    <div class="diagram">
      <svg viewBox="0 0 700 200" xmlns="http://www.w3.org/2000/svg">
        <text x="350" y="25" fill="#c084fc" font-size="16" font-weight="bold" text-anchor="middle">Nullability Cheat Sheet</text>
        
        <!-- Row 1 -->
        <rect x="20" y="50" width="150" height="50" rx="8" fill="#1e40af"/>
        <text x="95" y="80" fill="white" font-size="14" text-anchor="middle">String</text>
        <text x="200" y="80" fill="#9ca3af" font-size="12">‚Üí Can be null or a string</text>
        
        <!-- Row 2 -->
        <rect x="20" y="110" width="150" height="50" rx="8" fill="#065f46"/>
        <text x="95" y="140" fill="white" font-size="14" text-anchor="middle">String!</text>
        <text x="200" y="140" fill="#9ca3af" font-size="12">‚Üí Must be a string (never null)</text>
        
        <!-- Row 3 -->
        <rect x="380" y="50" width="150" height="50" rx="8" fill="#7c2d12"/>
        <text x="455" y="80" fill="white" font-size="14" text-anchor="middle">[String]</text>
        <text x="560" y="80" fill="#9ca3af" font-size="12">‚Üí Nullable array, nullable items</text>
        
        <!-- Row 4 -->
        <rect x="380" y="110" width="150" height="50" rx="8" fill="#4c1d95"/>
        <text x="455" y="140" fill="white" font-size="14" text-anchor="middle">[String!]!</text>
        <text x="560" y="140" fill="#9ca3af" font-size="12">‚Üí Non-null array, non-null items</text>
      </svg>
    </div>

    <div class="warning-box">
      Understanding nullability is crucial! <code class="inline-code">[Post!]!</code> means: the array itself cannot be null AND each item in the array cannot be null. This is the safest pattern for lists.
    </div>

    <h3>Enum Types</h3>

    <div class="type-card">
      <h4><span class="badge badge-special">ENUM</span> Predefined Value Sets</h4>
      <pre><code><span class="keyword">enum</span> <span class="type">UserRole</span> {
  <span class="field">ADMIN</span>
  <span class="field">MODERATOR</span>
  <span class="field">USER</span>
  <span class="field">GUEST</span>
}

<span class="keyword">enum</span> <span class="type">PostStatus</span> {
  <span class="field">DRAFT</span>
  <span class="field">PUBLISHED</span>
  <span class="field">ARCHIVED</span>
}

<span class="keyword">type</span> <span class="type">User</span> {
  <span class="field">id</span>: <span class="type">ID!</span>
  <span class="field">role</span>: <span class="type">UserRole!</span>  <span class="comment"># Must be one of the enum values</span>
}</code></pre>
    </div>

    <h3>Input Types</h3>

    <div class="type-card">
      <h4><span class="badge badge-special">INPUT</span> Types for Mutation Arguments</h4>
      <p>Input types are used specifically for passing complex objects as arguments to queries/mutations.</p>
      <pre><code><span class="keyword">input</span> <span class="type">CreateUserInput</span> {
  <span class="field">name</span>: <span class="type">String!</span>
  <span class="field">email</span>: <span class="type">String!</span>
  <span class="field">password</span>: <span class="type">String!</span>
  <span class="field">role</span>: <span class="type">UserRole</span> = <span class="field">USER</span>  <span class="comment"># Default value</span>
}

<span class="keyword">input</span> <span class="type">UpdateUserInput</span> {
  <span class="field">name</span>: <span class="type">String</span>
  <span class="field">email</span>: <span class="type">String</span>
  <span class="field">avatar</span>: <span class="type">String</span>
}

<span class="keyword">type</span> <span class="type">Mutation</span> {
  <span class="field">createUser</span>(input: <span class="type">CreateUserInput!</span>): <span class="type">User!</span>
  <span class="field">updateUser</span>(id: <span class="type">ID!</span>, input: <span class="type">UpdateUserInput!</span>): <span class="type">User</span>
}</code></pre>
    </div>

    <h3>Interface & Union Types</h3>

    <div class="type-card">
      <h4><span class="badge badge-special">INTERFACE</span> Abstract Types for Polymorphism</h4>
      <pre><code><span class="keyword">interface</span> <span class="type">Node</span> {
  <span class="field">id</span>: <span class="type">ID!</span>
}

<span class="keyword">interface</span> <span class="type">Timestamped</span> {
  <span class="field">createdAt</span>: <span class="type">String!</span>
  <span class="field">updatedAt</span>: <span class="type">String!</span>
}

<span class="comment"># Types implementing interfaces must include all interface fields</span>
<span class="keyword">type</span> <span class="type">User</span> <span class="keyword">implements</span> <span class="type">Node</span> & <span class="type">Timestamped</span> {
  <span class="field">id</span>: <span class="type">ID!</span>
  <span class="field">createdAt</span>: <span class="type">String!</span>
  <span class="field">updatedAt</span>: <span class="type">String!</span>
  <span class="field">name</span>: <span class="type">String!</span>
  <span class="field">email</span>: <span class="type">String!</span>
}</code></pre>
    </div>

    <div class="type-card">
      <h4><span class="badge badge-special">UNION</span> Return One of Several Types</h4>
      <pre><code><span class="keyword">union</span> <span class="type">SearchResult</span> = <span class="type">User</span> | <span class="type">Post</span> | <span class="type">Comment</span>

<span class="keyword">type</span> <span class="type">Query</span> {
  <span class="field">search</span>(term: <span class="type">String!</span>): [<span class="type">SearchResult!</span>]!
}

<span class="comment"># Querying a union type requires inline fragments</span>
<span class="keyword">query</span> {
  <span class="field">search</span>(term: <span class="string">"graphql"</span>) {
    <span class="keyword">... on</span> <span class="type">User</span> {
      <span class="field">name</span>
      <span class="field">email</span>
    }
    <span class="keyword">... on</span> <span class="type">Post</span> {
      <span class="field">title</span>
      <span class="field">content</span>
    }
    <span class="keyword">... on</span> <span class="type">Comment</span> {
      <span class="field">text</span>
    }
  }
}</code></pre>
    </div>

    <!-- Section 1.4 -->
    <h2>1.4 Schema Definition Language (SDL)</h2>

    <p>SDL is the syntax used to define your GraphQL schema. It's human-readable and serves as the single source of truth for your API.</p>

    <pre><code><span class="comment"># Complete Schema Example</span>

<span class="comment"># Custom scalar for dates</span>
<span class="keyword">scalar</span> <span class="type">DateTime</span>

<span class="comment"># Enums</span>
<span class="keyword">enum</span> <span class="type">PostStatus</span> {
  <span class="field">DRAFT</span>
  <span class="field">PUBLISHED</span>
  <span class="field">ARCHIVED</span>
}

<span class="comment"># Object Types</span>
<span class="keyword">type</span> <span class="type">User</span> {
  <span class="field">id</span>: <span class="type">ID!</span>
  <span class="field">name</span>: <span class="type">String!</span>
  <span class="field">email</span>: <span class="type">String!</span>
  <span class="field">posts</span>: [<span class="type">Post!</span>]!
  <span class="field">createdAt</span>: <span class="type">DateTime!</span>
}

<span class="keyword">type</span> <span class="type">Post</span> {
  <span class="field">id</span>: <span class="type">ID!</span>
  <span class="field">title</span>: <span class="type">String!</span>
  <span class="field">content</span>: <span class="type">String!</span>
  <span class="field">status</span>: <span class="type">PostStatus!</span>
  <span class="field">author</span>: <span class="type">User!</span>
  <span class="field">comments</span>: [<span class="type">Comment!</span>]!
}

<span class="keyword">type</span> <span class="type">Comment</span> {
  <span class="field">id</span>: <span class="type">ID!</span>
  <span class="field">text</span>: <span class="type">String!</span>
  <span class="field">author</span>: <span class="type">User!</span>
  <span class="field">post</span>: <span class="type">Post!</span>
}

<span class="comment"># Input Types</span>
<span class="keyword">input</span> <span class="type">CreatePostInput</span> {
  <span class="field">title</span>: <span class="type">String!</span>
  <span class="field">content</span>: <span class="type">String!</span>
  <span class="field">status</span>: <span class="type">PostStatus</span> = <span class="field">DRAFT</span>
}

<span class="comment"># Root Query Type (READ operations)</span>
<span class="keyword">type</span> <span class="type">Query</span> {
  <span class="field">user</span>(id: <span class="type">ID!</span>): <span class="type">User</span>
  <span class="field">users</span>: [<span class="type">User!</span>]!
  <span class="field">post</span>(id: <span class="type">ID!</span>): <span class="type">Post</span>
  <span class="field">posts</span>(status: <span class="type">PostStatus</span>): [<span class="type">Post!</span>]!
}

<span class="comment"># Root Mutation Type (WRITE operations)</span>
<span class="keyword">type</span> <span class="type">Mutation</span> {
  <span class="field">createUser</span>(name: <span class="type">String!</span>, email: <span class="type">String!</span>): <span class="type">User!</span>
  <span class="field">createPost</span>(input: <span class="type">CreatePostInput!</span>): <span class="type">Post!</span>
  <span class="field">deletePost</span>(id: <span class="type">ID!</span>): <span class="type">Boolean!</span>
}

<span class="comment"># Root Subscription Type (REAL-TIME)</span>
<span class="keyword">type</span> <span class="type">Subscription</span> {
  <span class="field">postCreated</span>: <span class="type">Post!</span>
  <span class="field">commentAdded</span>(postId: <span class="type">ID!</span>): <span class="type">Comment!</span>
}</code></pre>

    <!-- Section 1.5 -->
    <h2>1.5 Operations ‚Äî Query, Mutation, Subscription</h2>

    <h3>Query ‚Äî Reading Data</h3>
    <pre><code><span class="comment"># Simple query</span>
<span class="keyword">query</span> {
  <span class="field">users</span> {
    <span class="field">id</span>
    <span class="field">name</span>
  }
}

<span class="comment"># Named query with variables</span>
<span class="keyword">query</span> <span class="type">GetUserWithPosts</span>($userId: <span class="type">ID!</span>) {
  <span class="field">user</span>(id: $userId) {
    <span class="field">id</span>
    <span class="field">name</span>
    <span class="field">posts</span> {
      <span class="field">id</span>
      <span class="field">title</span>
    }
  }
}

<span class="comment"># Variables (sent as JSON):</span>
{ <span class="field">"userId"</span>: <span class="string">"123"</span> }</code></pre>

    <h3>Mutation ‚Äî Writing Data</h3>
    <pre><code><span class="keyword">mutation</span> <span class="type">CreateNewPost</span>($input: <span class="type">CreatePostInput!</span>) {
  <span class="field">createPost</span>(input: $input) {
    <span class="field">id</span>
    <span class="field">title</span>
    <span class="field">status</span>
    <span class="field">author</span> {
      <span class="field">id</span>
      <span class="field">name</span>
    }
  }
}

<span class="comment"># Variables:</span>
{
  <span class="field">"input"</span>: {
    <span class="field">"title"</span>: <span class="string">"Introduction to GraphQL"</span>,
    <span class="field">"content"</span>: <span class="string">"GraphQL is a query language..."</span>,
    <span class="field">"status"</span>: <span class="string">"PUBLISHED"</span>
  }
}</code></pre>

    <h3>Subscription ‚Äî Real-time Updates</h3>
    <pre><code><span class="keyword">subscription</span> <span class="type">OnNewComment</span>($postId: <span class="type">ID!</span>) {
  <span class="field">commentAdded</span>(postId: $postId) {
    <span class="field">id</span>
    <span class="field">text</span>
    <span class="field">author</span> {
      <span class="field">name</span>
    }
  }
}

<span class="comment"># This opens a WebSocket connection</span>
<span class="comment"># Server pushes data whenever a new comment is added</span></code></pre>

    <div class="warning-box">
      Know the three operation types cold: <strong>Query</strong> = GET (read), <strong>Mutation</strong> = POST/PUT/DELETE (write), <strong>Subscription</strong> = WebSocket (real-time). Interviewers often ask when to use each.
    </div>

    <div class="chapter-nav">
      <span></span>
      <button class="nav-btn">Next: Chapter 2 ‚Äî Apollo Client Setup ‚Üí</button>
    </div>
  </div>
</body>
</html>
