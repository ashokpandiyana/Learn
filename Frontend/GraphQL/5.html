<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 5: Mutations with useMutation</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, #0c1222 0%, #1a0a2e 100%);
      color: #e4e4e7;
      line-height: 1.7;
      padding: 40px 20px;
      min-height: 100vh;
    }
    .container { max-width: 950px; margin: 0 auto; }
    h1 {
      font-size: 2.5rem;
      background: linear-gradient(90deg, #f59e0b, #ef4444);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 10px;
    }
    .subtitle { color: #a1a1aa; font-size: 1.1rem; margin-bottom: 40px; }
    h2 {
      color: #f59e0b;
      font-size: 1.6rem;
      margin: 40px 0 20px;
      padding-bottom: 10px;
      border-bottom: 2px solid #3f3f46;
    }
    h3 { color: #fbbf24; font-size: 1.2rem; margin: 25px 0 15px; }
    h4 { color: #fcd34d; font-size: 1rem; margin: 20px 0 10px; }
    p { margin-bottom: 15px; color: #d4d4d8; }
    .highlight-box {
      background: linear-gradient(135deg, #78350f 0%, #451a03 100%);
      border-left: 4px solid #f59e0b;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .warning-box {
      background: linear-gradient(135deg, #7f1d1d 0%, #450a0a 100%);
      border-left: 4px solid #ef4444;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .warning-box::before { content: "‚ö†Ô∏è INTERVIEW HIGHLIGHT: "; font-weight: bold; color: #f87171; }
    .tip-box {
      background: linear-gradient(135deg, #064e3b 0%, #022c22 100%);
      border-left: 4px solid #10b981;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .tip-box::before { content: "üìù PRODUCTION TIP: "; font-weight: bold; color: #34d399; }
    .concept-box {
      background: linear-gradient(135deg, #4c1d95 0%, #2e1065 100%);
      border-left: 4px solid #a78bfa;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .concept-box::before { content: "üí° KEY CONCEPT: "; font-weight: bold; color: #c4b5fd; }
    pre {
      background: #0a0a15;
      border: 1px solid #3f3f46;
      border-radius: 12px;
      padding: 20px;
      overflow-x: auto;
      margin: 15px 0;
      font-size: 0.88rem;
    }
    code { font-family: 'Fira Code', 'Consolas', monospace; }
    .inline-code {
      background: #3f3f46;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.85rem;
    }
    .keyword { color: #c084fc; }
    .type { color: #38bdf8; }
    .string { color: #4ade80; }
    .comment { color: #6b7280; font-style: italic; }
    .field { color: #fbbf24; }
    .function { color: #f472b6; }
    .const { color: #fb923c; }
    .param { color: #67e8f9; }
    .diagram {
      background: #0a0a15;
      border-radius: 12px;
      padding: 30px;
      margin: 20px 0;
      text-align: center;
      overflow-x: auto;
    }
    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      background: #1e293b;
      border-radius: 12px;
      overflow: hidden;
      font-size: 0.9rem;
    }
    .comparison-table th {
      background: linear-gradient(90deg, #b45309, #dc2626);
      padding: 14px;
      text-align: left;
      font-weight: 600;
    }
    .comparison-table td {
      padding: 12px 14px;
      border-bottom: 1px solid #334155;
    }
    .comparison-table tr:last-child td { border-bottom: none; }
    .comparison-table code { background: #374151; padding: 2px 6px; border-radius: 4px; font-size: 0.8rem; }
    ul, ol { margin: 15px 0 15px 25px; }
    li { margin: 8px 0; color: #d4d4d8; }
    .strategy-card {
      background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
      border: 1px solid #374151;
      border-radius: 12px;
      padding: 20px;
      margin: 15px 0;
    }
    .strategy-card h4 {
      color: #f59e0b;
      margin: 0 0 10px 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .strategy-card p { margin: 0; font-size: 0.9rem; color: #9ca3af; }
    .badge {
      display: inline-block;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 0.7rem;
      font-weight: 600;
    }
    .badge-simple { background: #059669; color: white; }
    .badge-recommended { background: #2563eb; color: white; }
    .badge-advanced { background: #dc2626; color: white; }
    .chapter-nav {
      display: flex;
      justify-content: space-between;
      margin-top: 50px;
      padding-top: 30px;
      border-top: 1px solid #3f3f46;
    }
    .nav-btn {
      padding: 12px 24px;
      background: linear-gradient(90deg, #b45309, #dc2626);
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }
    .flow-step {
      display: flex;
      align-items: flex-start;
      gap: 15px;
      margin: 15px 0;
      padding: 15px;
      background: #1f2937;
      border-radius: 10px;
    }
    .step-num {
      width: 30px;
      height: 30px;
      background: linear-gradient(135deg, #f59e0b, #ef4444);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      flex-shrink: 0;
    }
    .step-content h5 { color: #fbbf24; margin: 0 0 5px 0; }
    .step-content p { margin: 0; font-size: 0.9rem; color: #9ca3af; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Chapter 5</h1>
    <p class="subtitle">Mutations with useMutation ‚Äî Writing Data to Your GraphQL API</p>

    <!-- Section 5.1 -->
    <h2>5.1 Introduction to useMutation</h2>
    
    <p>While <code class="inline-code">useQuery</code> is for reading data, <code class="inline-code">useMutation</code> is for writing data ‚Äî creating, updating, and deleting records. Unlike queries, mutations don't execute automatically; you trigger them manually.</p>

    <div class="highlight-box">
      <strong>Key Differences from useQuery:</strong>
      <ul style="margin-top: 10px;">
        <li><strong>Manual execution:</strong> Mutations must be explicitly triggered</li>
        <li><strong>Returns a tuple:</strong> [mutateFunction, resultObject]</li>
        <li><strong>Side effects:</strong> Mutations change data on the server</li>
        <li><strong>Cache updates:</strong> You often need to update the cache manually</li>
      </ul>
    </div>

    <h3>Basic Syntax</h3>

    <pre><code><span class="keyword">import</span> { <span class="type">useMutation</span>, <span class="type">gql</span> } <span class="keyword">from</span> <span class="string">'@apollo/client'</span>;

<span class="comment">// Define mutation</span>
<span class="keyword">const</span> <span class="const">CREATE_USER</span> = <span class="function">gql</span><span class="string">`
  mutation CreateUser($input: CreateUserInput!) {
    createUser(input: $input) {
      id
      name
      email
      createdAt
    }
  }
`</span>;

<span class="keyword">function</span> <span class="function">CreateUserForm</span>() {
  <span class="comment">// useMutation returns [mutateFunction, result]</span>
  <span class="keyword">const</span> [<span class="function">createUser</span>, { data, loading, error }] = <span class="function">useMutation</span>(<span class="const">CREATE_USER</span>);

  <span class="keyword">const</span> <span class="function">handleSubmit</span> = <span class="keyword">async</span> (formData) => {
    <span class="keyword">try</span> {
      <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="function">createUser</span>({
        <span class="field">variables</span>: {
          <span class="field">input</span>: {
            <span class="field">name</span>: formData.name,
            <span class="field">email</span>: formData.email,
          },
        },
      });
      console.<span class="function">log</span>(<span class="string">'Created user:'</span>, result.data.createUser);
    } <span class="keyword">catch</span> (err) {
      console.<span class="function">error</span>(<span class="string">'Failed to create user'</span>, err);
    }
  };

  <span class="keyword">return</span> (
    <span class="keyword">&lt;</span>form <span class="field">onSubmit</span>={handleSubmit}<span class="keyword">&gt;</span>
      {error && <span class="keyword">&lt;</span>ErrorBanner message={error.message} <span class="keyword">/&gt;</span>}
      <span class="comment">{/* form fields */}</span>
      <span class="keyword">&lt;</span>button <span class="field">type</span>=<span class="string">"submit"</span> <span class="field">disabled</span>={loading}<span class="keyword">&gt;</span>
        {loading ? <span class="string">'Creating...'</span> : <span class="string">'Create User'</span>}
      <span class="keyword">&lt;/</span>button<span class="keyword">&gt;</span>
    <span class="keyword">&lt;/</span>form<span class="keyword">&gt;</span>
  );
}</code></pre>

    <!-- Section 5.2 -->
    <h2>5.2 useMutation Return Values</h2>

    <p>The hook returns a tuple with two elements:</p>

    <pre><code><span class="keyword">const</span> [
  <span class="function">mutateFunction</span>,  <span class="comment">// Function to trigger the mutation</span>
  {
    <span class="field">data</span>,           <span class="comment">// Mutation result</span>
    <span class="field">loading</span>,        <span class="comment">// True while mutation is in flight</span>
    <span class="field">error</span>,          <span class="comment">// Error object if mutation failed</span>
    <span class="field">called</span>,         <span class="comment">// True if mutation has been called</span>
    <span class="field">reset</span>,          <span class="comment">// Function to reset state</span>
    <span class="field">client</span>,         <span class="comment">// Apollo Client instance</span>
  }
] = <span class="function">useMutation</span>(<span class="const">MUTATION</span>);</code></pre>

    <table class="comparison-table">
      <tr>
        <th>Property</th>
        <th>Type</th>
        <th>Description</th>
      </tr>
      <tr>
        <td><code>mutateFunction</code></td>
        <td>Function</td>
        <td>Call this to execute the mutation. Returns a Promise.</td>
      </tr>
      <tr>
        <td><code>data</code></td>
        <td>Object | undefined</td>
        <td>Mutation result data</td>
      </tr>
      <tr>
        <td><code>loading</code></td>
        <td>boolean</td>
        <td>True while mutation is executing</td>
      </tr>
      <tr>
        <td><code>error</code></td>
        <td>ApolloError | undefined</td>
        <td>Error if mutation failed</td>
      </tr>
      <tr>
        <td><code>called</code></td>
        <td>boolean</td>
        <td>Whether mutation has been called at least once</td>
      </tr>
      <tr>
        <td><code>reset</code></td>
        <td>Function</td>
        <td>Reset data, error, and called to initial state</td>
      </tr>
    </table>

    <!-- Section 5.3 -->
    <h2>5.3 Mutation Execution Patterns</h2>

    <h3>Pattern 1: Async/Await (Recommended)</h3>

    <pre><code><span class="keyword">const</span> [createPost] = <span class="function">useMutation</span>(<span class="const">CREATE_POST</span>);

<span class="keyword">const</span> <span class="function">handleCreate</span> = <span class="keyword">async</span> () => {
  <span class="keyword">try</span> {
    <span class="keyword">const</span> { data } = <span class="keyword">await</span> <span class="function">createPost</span>({
      <span class="field">variables</span>: { <span class="field">title</span>: <span class="string">'Hello'</span>, <span class="field">content</span>: <span class="string">'World'</span> },
    });
    
    <span class="comment">// Success! Navigate or show toast</span>
    <span class="function">navigate</span>(<span class="string">`/posts/</span>${data.createPost.id}<span class="string">`</span>);
    <span class="function">toast.success</span>(<span class="string">'Post created!'</span>);
    
  } <span class="keyword">catch</span> (error) {
    <span class="comment">// Handle error</span>
    <span class="function">toast.error</span>(error.message);
  }
};</code></pre>

    <h3>Pattern 2: Using Callbacks</h3>

    <pre><code><span class="keyword">const</span> [createPost, { loading }] = <span class="function">useMutation</span>(<span class="const">CREATE_POST</span>, {
  <span class="function">onCompleted</span>: (data) => {
    <span class="function">toast.success</span>(<span class="string">'Post created!'</span>);
    <span class="function">navigate</span>(<span class="string">`/posts/</span>${data.createPost.id}<span class="string">`</span>);
  },
  <span class="function">onError</span>: (error) => {
    <span class="function">toast.error</span>(error.message);
    <span class="function">logToSentry</span>(error);
  },
});

<span class="keyword">const</span> <span class="function">handleCreate</span> = () => {
  <span class="function">createPost</span>({
    <span class="field">variables</span>: { <span class="field">title</span>: <span class="string">'Hello'</span>, <span class="field">content</span>: <span class="string">'World'</span> },
  });
};</code></pre>

    <h3>Pattern 3: Using Result Object</h3>

    <pre><code><span class="keyword">const</span> [createPost, { data, loading, error }] = <span class="function">useMutation</span>(<span class="const">CREATE_POST</span>);

<span class="comment">// React to state changes</span>
<span class="function">useEffect</span>(() => {
  <span class="keyword">if</span> (data) {
    <span class="function">toast.success</span>(<span class="string">'Post created!'</span>);
  }
}, [data]);

<span class="function">useEffect</span>(() => {
  <span class="keyword">if</span> (error) {
    <span class="function">toast.error</span>(error.message);
  }
}, [error]);</code></pre>

    <!-- Section 5.4 -->
    <h2>5.4 Cache Update Strategies ‚Äî The Most Important Section!</h2>

    <p>After a mutation, you need to update your cache so the UI reflects the changes. This is where most developers struggle.</p>

    <div class="diagram">
      <svg viewBox="0 0 800 200" xmlns="http://www.w3.org/2000/svg">
        <text x="400" y="25" fill="#e4e4e7" font-size="16" font-weight="bold" text-anchor="middle">Cache Update Strategies</text>
        
        <!-- Strategy 1 -->
        <rect x="20" y="50" width="240" height="130" rx="10" fill="#1e3a8a" stroke="#3b82f6" stroke-width="2"/>
        <text x="140" y="75" fill="#60a5fa" font-size="12" font-weight="bold" text-anchor="middle">1. refetchQueries</text>
        <text x="140" y="100" fill="#94a3b8" font-size="10" text-anchor="middle">Re-fetch queries after mutation</text>
        <text x="140" y="120" fill="#4ade80" font-size="10" text-anchor="middle">‚úì Simple, always correct</text>
        <text x="140" y="140" fill="#f87171" font-size="10" text-anchor="middle">‚úó Extra network request</text>
        <text x="140" y="165" fill="#fbbf24" font-size="10" text-anchor="middle" font-weight="bold">Best for: Simple apps</text>
        
        <!-- Strategy 2 -->
        <rect x="280" y="50" width="240" height="130" rx="10" fill="#065f46" stroke="#10b981" stroke-width="2"/>
        <text x="400" y="75" fill="#34d399" font-size="12" font-weight="bold" text-anchor="middle">2. update function</text>
        <text x="400" y="100" fill="#94a3b8" font-size="10" text-anchor="middle">Manually update cache</text>
        <text x="400" y="120" fill="#4ade80" font-size="10" text-anchor="middle">‚úì No extra requests</text>
        <text x="400" y="140" fill="#f87171" font-size="10" text-anchor="middle">‚úó More complex</text>
        <text x="400" y="165" fill="#fbbf24" font-size="10" text-anchor="middle" font-weight="bold">Best for: Production apps</text>
        
        <!-- Strategy 3 -->
        <rect x="540" y="50" width="240" height="130" rx="10" fill="#7c2d12" stroke="#f97316" stroke-width="2"/>
        <text x="660" y="75" fill="#fb923c" font-size="12" font-weight="bold" text-anchor="middle">3. optimisticResponse</text>
        <text x="660" y="100" fill="#94a3b8" font-size="10" text-anchor="middle">Update UI immediately</text>
        <text x="660" y="120" fill="#4ade80" font-size="10" text-anchor="middle">‚úì Instant feedback</text>
        <text x="660" y="140" fill="#f87171" font-size="10" text-anchor="middle">‚úó Rollback on failure</text>
        <text x="660" y="165" fill="#fbbf24" font-size="10" text-anchor="middle" font-weight="bold">Best for: Best UX</text>
      </svg>
    </div>

    <h3>Strategy 1: refetchQueries (Simplest)</h3>

    <div class="strategy-card">
      <h4><span class="badge badge-simple">SIMPLE</span> Automatic Refetch</h4>
      <p>After mutation completes, re-fetch specified queries to get fresh data.</p>
    </div>

    <pre><code><span class="keyword">const</span> [createPost] = <span class="function">useMutation</span>(<span class="const">CREATE_POST</span>, {
  <span class="comment">// Refetch these queries after mutation</span>
  <span class="field">refetchQueries</span>: [
    { <span class="field">query</span>: <span class="const">GET_POSTS</span> },                        <span class="comment">// By query document</span>
    { <span class="field">query</span>: <span class="const">GET_USER_POSTS</span>, <span class="field">variables</span>: { <span class="field">userId</span> } }, <span class="comment">// With variables</span>
    <span class="string">'GetPosts'</span>,                                  <span class="comment">// By operation name</span>
  ],
  
  <span class="comment">// Wait for refetch before resolving mutation promise</span>
  <span class="field">awaitRefetchQueries</span>: <span class="keyword">true</span>,
});

<span class="comment">// Dynamic refetch based on result</span>
<span class="keyword">const</span> [createPost] = <span class="function">useMutation</span>(<span class="const">CREATE_POST</span>, {
  <span class="function">refetchQueries</span>: (result) => {
    <span class="keyword">return</span> [
      { 
        <span class="field">query</span>: <span class="const">GET_USER_POSTS</span>, 
        <span class="field">variables</span>: { <span class="field">userId</span>: result.data.createPost.author.id } 
      },
    ];
  },
});</code></pre>

    <h3>Strategy 2: update Function (Recommended)</h3>

    <div class="strategy-card">
      <h4><span class="badge badge-recommended">RECOMMENDED</span> Manual Cache Update</h4>
      <p>Directly modify the cache after mutation. No extra network request!</p>
    </div>

    <pre><code><span class="keyword">const</span> [createPost] = <span class="function">useMutation</span>(<span class="const">CREATE_POST</span>, {
  <span class="function">update</span>(cache, { data: { createPost: newPost } }) {
    <span class="comment">// Read current cache data</span>
    <span class="keyword">const</span> existingPosts = cache.<span class="function">readQuery</span>({ 
      <span class="field">query</span>: <span class="const">GET_POSTS</span> 
    });
    
    <span class="keyword">if</span> (existingPosts) {
      <span class="comment">// Write updated data to cache</span>
      cache.<span class="function">writeQuery</span>({
        <span class="field">query</span>: <span class="const">GET_POSTS</span>,
        <span class="field">data</span>: {
          <span class="field">posts</span>: [newPost, ...existingPosts.posts],
        },
      });
    }
  },
});</code></pre>

    <h4>Using cache.modify (Most Performant)</h4>

    <pre><code><span class="keyword">const</span> [createPost] = <span class="function">useMutation</span>(<span class="const">CREATE_POST</span>, {
  <span class="function">update</span>(cache, { data: { createPost: newPost } }) {
    cache.<span class="function">modify</span>({
      <span class="field">fields</span>: {
        <span class="function">posts</span>(existingPosts = []) {
          <span class="keyword">const</span> newPostRef = cache.<span class="function">writeFragment</span>({
            <span class="field">data</span>: newPost,
            <span class="field">fragment</span>: <span class="function">gql</span><span class="string">`
              fragment NewPost on Post {
                id
                title
                content
                author { id name }
                createdAt
              }
            `</span>,
          });
          <span class="keyword">return</span> [newPostRef, ...existingPosts];
        },
      },
    });
  },
});</code></pre>

    <div class="warning-box">
      <strong>cache.modify vs writeQuery:</strong> <code class="inline-code">cache.modify</code> is more performant because it only updates specific fields without reading the entire query first. Use it for production apps!
    </div>

    <h3>Strategy 3: Optimistic Response (Best UX)</h3>

    <div class="strategy-card">
      <h4><span class="badge badge-advanced">ADVANCED</span> Instant UI Updates</h4>
      <p>Show the expected result immediately. If mutation fails, Apollo rolls back automatically.</p>
    </div>

    <pre><code><span class="keyword">const</span> [createPost] = <span class="function">useMutation</span>(<span class="const">CREATE_POST</span>, {
  <span class="comment">// Predict the server response</span>
  <span class="field">optimisticResponse</span>: {
    <span class="field">createPost</span>: {
      <span class="field">__typename</span>: <span class="string">'Post'</span>,          <span class="comment">// Required!</span>
      <span class="field">id</span>: <span class="string">`temp-</span>${Date.<span class="function">now</span>()}<span class="string">`</span>,     <span class="comment">// Temporary ID</span>
      <span class="field">title</span>: variables.title,
      <span class="field">content</span>: variables.content,
      <span class="field">createdAt</span>: <span class="keyword">new</span> <span class="type">Date</span>().<span class="function">toISOString</span>(),
      <span class="field">author</span>: {
        <span class="field">__typename</span>: <span class="string">'User'</span>,
        <span class="field">id</span>: currentUser.id,
        <span class="field">name</span>: currentUser.name,
      },
    },
  },
  
  <span class="comment">// Update cache with optimistic data first, then real data</span>
  <span class="function">update</span>(cache, { data: { createPost } }) {
    cache.<span class="function">modify</span>({
      <span class="field">fields</span>: {
        <span class="function">posts</span>(existing = []) {
          <span class="keyword">const</span> newRef = cache.<span class="function">writeFragment</span>({
            <span class="field">data</span>: createPost,
            <span class="field">fragment</span>: <span class="const">POST_FRAGMENT</span>,
          });
          <span class="keyword">return</span> [newRef, ...existing];
        },
      },
    });
  },
});</code></pre>

    <h4>Dynamic Optimistic Response</h4>

    <pre><code><span class="keyword">const</span> [createPost] = <span class="function">useMutation</span>(<span class="const">CREATE_POST</span>, {
  <span class="comment">// Function form for dynamic values</span>
  <span class="function">optimisticResponse</span>: (variables) => ({
    <span class="field">createPost</span>: {
      <span class="field">__typename</span>: <span class="string">'Post'</span>,
      <span class="field">id</span>: <span class="string">`temp-</span>${Date.<span class="function">now</span>()}<span class="string">`</span>,
      <span class="field">title</span>: variables.input.title,
      <span class="field">content</span>: variables.input.content,
      <span class="field">createdAt</span>: <span class="keyword">new</span> <span class="type">Date</span>().<span class="function">toISOString</span>(),
    },
  }),
});</code></pre>

    <div class="concept-box">
      <strong>How Optimistic UI Works:</strong><br><br>
      1. User clicks "Create Post"<br>
      2. Optimistic data is immediately written to cache<br>
      3. UI updates instantly (shows new post)<br>
      4. Mutation executes in background<br>
      5a. <span style="color: #4ade80;">Success:</span> Optimistic data replaced with real data<br>
      5b. <span style="color: #f87171;">Failure:</span> Apollo rolls back to previous cache state
    </div>

    <!-- Section 5.5 -->
    <h2>5.5 Delete Mutations with Cache Eviction</h2>

    <pre><code><span class="keyword">const</span> <span class="const">DELETE_POST</span> = <span class="function">gql</span><span class="string">`
  mutation DeletePost($id: ID!) {
    deletePost(id: $id) {
      id
      success
    }
  }
`</span>;

<span class="keyword">const</span> [deletePost] = <span class="function">useMutation</span>(<span class="const">DELETE_POST</span>, {
  <span class="function">update</span>(cache, { data: { deletePost } }) {
    <span class="comment">// Method 1: Evict the object from cache</span>
    cache.<span class="function">evict</span>({ 
      <span class="field">id</span>: cache.<span class="function">identify</span>({ 
        <span class="field">__typename</span>: <span class="string">'Post'</span>, 
        <span class="field">id</span>: deletePost.id 
      }) 
    });
    
    <span class="comment">// Clean up orphaned references</span>
    cache.<span class="function">gc</span>();
  },
  
  <span class="comment">// Optimistic delete</span>
  <span class="function">optimisticResponse</span>: (variables) => ({
    <span class="field">deletePost</span>: {
      <span class="field">__typename</span>: <span class="string">'DeletePostResponse'</span>,
      <span class="field">id</span>: variables.id,
      <span class="field">success</span>: <span class="keyword">true</span>,
    },
  }),
});

<span class="comment">// Usage</span>
<span class="keyword">const</span> <span class="function">handleDelete</span> = <span class="keyword">async</span> (postId) => {
  <span class="keyword">if</span> (<span class="function">confirm</span>(<span class="string">'Delete this post?'</span>)) {
    <span class="keyword">await</span> <span class="function">deletePost</span>({ <span class="field">variables</span>: { <span class="field">id</span>: postId } });
    <span class="function">toast.success</span>(<span class="string">'Post deleted'</span>);
  }
};</code></pre>

    <div class="tip-box">
      Always call <code class="inline-code">cache.gc()</code> after <code class="inline-code">cache.evict()</code> to garbage collect any orphaned references. This prevents memory leaks and stale data issues.
    </div>

    <!-- Section 5.6 -->
    <h2>5.6 Update Mutations</h2>

    <pre><code><span class="keyword">const</span> <span class="const">UPDATE_POST</span> = <span class="function">gql</span><span class="string">`
  mutation UpdatePost($id: ID!, $input: UpdatePostInput!) {
    updatePost(id: $id, input: $input) {
      id
      title
      content
      updatedAt
    }
  }
`</span>;

<span class="keyword">const</span> [updatePost] = <span class="function">useMutation</span>(<span class="const">UPDATE_POST</span>, {
  <span class="comment">// For updates, Apollo automatically merges by ID!</span>
  <span class="comment">// If your mutation returns the updated object,</span>
  <span class="comment">// the cache updates automatically - no update function needed!</span>
  
  <span class="comment">// But for optimistic UI:</span>
  <span class="function">optimisticResponse</span>: (variables) => ({
    <span class="field">updatePost</span>: {
      <span class="field">__typename</span>: <span class="string">'Post'</span>,
      <span class="field">id</span>: variables.id,
      <span class="field">title</span>: variables.input.title,
      <span class="field">content</span>: variables.input.content,
      <span class="field">updatedAt</span>: <span class="keyword">new</span> <span class="type">Date</span>().<span class="function">toISOString</span>(),
    },
  }),
});</code></pre>

    <div class="warning-box">
      For UPDATE mutations, if your mutation returns the full updated object with the same <code class="inline-code">id</code>, Apollo <strong>automatically updates the cache</strong>! You often don't need an update function. This is the power of normalized caching.
    </div>

    <!-- Section 5.7 -->
    <h2>5.7 Error Handling in Mutations</h2>

    <pre><code><span class="keyword">const</span> [createUser, { error, reset }] = <span class="function">useMutation</span>(<span class="const">CREATE_USER</span>, {
  <span class="field">errorPolicy</span>: <span class="string">'all'</span>,  <span class="comment">// Get partial data + errors</span>
  
  <span class="function">onError</span>(error) {
    <span class="comment">// Handle specific error types</span>
    <span class="keyword">if</span> (error.graphQLErrors) {
      error.graphQLErrors.<span class="function">forEach</span>(({ message, extensions }) => {
        <span class="keyword">switch</span> (extensions?.code) {
          <span class="keyword">case</span> <span class="string">'DUPLICATE_EMAIL'</span>:
            <span class="function">setFieldError</span>(<span class="string">'email'</span>, <span class="string">'Email already exists'</span>);
            <span class="keyword">break</span>;
          <span class="keyword">case</span> <span class="string">'VALIDATION_ERROR'</span>:
            <span class="function">handleValidationErrors</span>(extensions.validationErrors);
            <span class="keyword">break</span>;
          <span class="keyword">default</span>:
            <span class="function">toast.error</span>(message);
        }
      });
    }
    
    <span class="keyword">if</span> (error.networkError) {
      <span class="function">toast.error</span>(<span class="string">'Network error. Please try again.'</span>);
    }
  },
});

<span class="comment">// Reset error state when user starts typing again</span>
<span class="keyword">const</span> <span class="function">handleInputChange</span> = () => {
  <span class="keyword">if</span> (error) {
    <span class="function">reset</span>();  <span class="comment">// Clear error, data, and called state</span>
  }
};</code></pre>

    <!-- Section 5.8 -->
    <h2>5.8 Complete Mutation Example ‚Äî Todo App</h2>

    <pre><code><span class="keyword">import</span> { <span class="type">useMutation</span>, <span class="type">gql</span> } <span class="keyword">from</span> <span class="string">'@apollo/client'</span>;

<span class="keyword">const</span> <span class="const">ADD_TODO</span> = <span class="function">gql</span><span class="string">`
  mutation AddTodo($text: String!) {
    addTodo(text: $text) {
      id
      text
      completed
    }
  }
`</span>;

<span class="keyword">const</span> <span class="const">TOGGLE_TODO</span> = <span class="function">gql</span><span class="string">`
  mutation ToggleTodo($id: ID!) {
    toggleTodo(id: $id) {
      id
      completed
    }
  }
`</span>;

<span class="keyword">const</span> <span class="const">DELETE_TODO</span> = <span class="function">gql</span><span class="string">`
  mutation DeleteTodo($id: ID!) {
    deleteTodo(id: $id) {
      id
    }
  }
`</span>;

<span class="keyword">function</span> <span class="function">TodoApp</span>() {
  <span class="keyword">const</span> [text, setText] = <span class="function">useState</span>(<span class="string">''</span>);
  
  <span class="comment">// ADD TODO - with optimistic UI</span>
  <span class="keyword">const</span> [addTodo] = <span class="function">useMutation</span>(<span class="const">ADD_TODO</span>, {
    <span class="function">optimisticResponse</span>: (vars) => ({
      <span class="field">addTodo</span>: {
        <span class="field">__typename</span>: <span class="string">'Todo'</span>,
        <span class="field">id</span>: <span class="string">`temp-</span>${Date.<span class="function">now</span>()}<span class="string">`</span>,
        <span class="field">text</span>: vars.text,
        <span class="field">completed</span>: <span class="keyword">false</span>,
      },
    }),
    <span class="function">update</span>(cache, { data }) {
      cache.<span class="function">modify</span>({
        <span class="field">fields</span>: {
          <span class="function">todos</span>(existing = []) {
            <span class="keyword">const</span> newRef = cache.<span class="function">writeFragment</span>({
              <span class="field">data</span>: data.addTodo,
              <span class="field">fragment</span>: <span class="function">gql</span><span class="string">`fragment NewTodo on Todo { id text completed }`</span>,
            });
            <span class="keyword">return</span> [...existing, newRef];
          },
        },
      });
    },
  });

  <span class="comment">// TOGGLE TODO - auto-updates due to ID match</span>
  <span class="keyword">const</span> [toggleTodo] = <span class="function">useMutation</span>(<span class="const">TOGGLE_TODO</span>, {
    <span class="function">optimisticResponse</span>: (vars) => ({
      <span class="field">toggleTodo</span>: {
        <span class="field">__typename</span>: <span class="string">'Todo'</span>,
        <span class="field">id</span>: vars.id,
        <span class="field">completed</span>: !<span class="function">getCurrentTodoStatus</span>(vars.id),
      },
    }),
  });

  <span class="comment">// DELETE TODO - evict from cache</span>
  <span class="keyword">const</span> [deleteTodo] = <span class="function">useMutation</span>(<span class="const">DELETE_TODO</span>, {
    <span class="function">update</span>(cache, { data }) {
      cache.<span class="function">evict</span>({ <span class="field">id</span>: <span class="string">`Todo:</span>${data.deleteTodo.id}<span class="string">`</span> });
      cache.<span class="function">gc</span>();
    },
    <span class="function">optimisticResponse</span>: (vars) => ({
      <span class="field">deleteTodo</span>: { <span class="field">__typename</span>: <span class="string">'Todo'</span>, <span class="field">id</span>: vars.id },
    }),
  });

  <span class="keyword">return</span> (
    <span class="keyword">&lt;</span>div<span class="keyword">&gt;</span>
      <span class="keyword">&lt;</span>input <span class="field">value</span>={text} <span class="field">onChange</span>={(e) => <span class="function">setText</span>(e.target.value)} <span class="keyword">/&gt;</span>
      <span class="keyword">&lt;</span>button <span class="field">onClick</span>={() => {
        <span class="function">addTodo</span>({ <span class="field">variables</span>: { <span class="field">text</span> } });
        <span class="function">setText</span>(<span class="string">''</span>);
      }}<span class="keyword">&gt;</span>Add<span class="keyword">&lt;/</span>button<span class="keyword">&gt;</span>
      
      {<span class="comment">/* Todo list rendering... */</span>}
    <span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>
  );
}</code></pre>

    <!-- Section 5.9 -->
    <h2>5.9 Complete useMutation Options Reference</h2>

    <pre><code><span class="keyword">const</span> [mutate, result] = <span class="function">useMutation</span>(<span class="const">MUTATION</span>, {
  <span class="comment">// === VARIABLES ===</span>
  <span class="field">variables</span>: { <span class="field">id</span>: <span class="string">'123'</span> },
  
  <span class="comment">// === CACHE UPDATES ===</span>
  <span class="function">update</span>(cache, { data }) {
    <span class="comment">// Modify cache after mutation</span>
  },
  <span class="field">refetchQueries</span>: [{ <span class="field">query</span>: <span class="const">GET_DATA</span> }],
  <span class="field">awaitRefetchQueries</span>: <span class="keyword">true</span>,
  
  <span class="comment">// === OPTIMISTIC UI ===</span>
  <span class="field">optimisticResponse</span>: {
    <span class="field">mutationName</span>: { <span class="field">__typename</span>: <span class="string">'Type'</span>, ... },
  },
  
  <span class="comment">// === CALLBACKS ===</span>
  <span class="function">onCompleted</span>(data) { },
  <span class="function">onError</span>(error) { },
  
  <span class="comment">// === ERROR HANDLING ===</span>
  <span class="field">errorPolicy</span>: <span class="string">'all'</span>,  <span class="comment">// 'none' | 'ignore' | 'all'</span>
  
  <span class="comment">// === CONTEXT ===</span>
  <span class="field">context</span>: {
    <span class="field">headers</span>: { <span class="string">'X-Custom'</span>: <span class="string">'value'</span> },
  },
  
  <span class="comment">// === FETCH POLICY ===</span>
  <span class="field">fetchPolicy</span>: <span class="string">'no-cache'</span>,  <span class="comment">// Usually default is fine</span>
  
  <span class="comment">// === IGNORE RESULTS (fire-and-forget) ===</span>
  <span class="field">ignoreResults</span>: <span class="keyword">true</span>,  <span class="comment">// Don't store result in state</span>
});</code></pre>

    <div class="chapter-nav">
      <button class="nav-btn">‚Üê Chapter 4: useQuery</button>
      <button class="nav-btn">Next: Chapter 6 ‚Äî Fragments ‚Üí</button>
    </div>
  </div>
</body>
</html>
