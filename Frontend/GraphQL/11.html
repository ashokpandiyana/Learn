<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 11: Performance Optimization</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
      color: #e4e4e7;
      line-height: 1.7;
      padding: 40px 20px;
      min-height: 100vh;
    }
    .container { max-width: 950px; margin: 0 auto; }
    h1 {
      font-size: 2.5rem;
      background: linear-gradient(90deg, #06b6d4, #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 10px;
    }
    .subtitle { color: #a1a1aa; font-size: 1.1rem; margin-bottom: 40px; }
    h2 {
      color: #06b6d4;
      font-size: 1.6rem;
      margin: 40px 0 20px;
      padding-bottom: 10px;
      border-bottom: 2px solid #3f3f46;
    }
    h3 { color: #22d3ee; font-size: 1.2rem; margin: 25px 0 15px; }
    h4 { color: #67e8f9; font-size: 1rem; margin: 20px 0 10px; }
    p { margin-bottom: 15px; color: #d4d4d8; }
    .highlight-box {
      background: linear-gradient(135deg, #164e63 0%, #0c4a6e 100%);
      border-left: 4px solid #06b6d4;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .warning-box {
      background: linear-gradient(135deg, #78350f 0%, #451a03 100%);
      border-left: 4px solid #f59e0b;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .warning-box::before { content: "‚ö†Ô∏è INTERVIEW HIGHLIGHT: "; font-weight: bold; color: #fbbf24; }
    .tip-box {
      background: linear-gradient(135deg, #064e3b 0%, #022c22 100%);
      border-left: 4px solid #10b981;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .tip-box::before { content: "üìù PRODUCTION TIP: "; font-weight: bold; color: #34d399; }
    .perf-box {
      background: linear-gradient(135deg, #4c1d95 0%, #2e1065 100%);
      border-left: 4px solid #a855f7;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .perf-box::before { content: "‚ö° PERFORMANCE: "; font-weight: bold; color: #c084fc; }
    pre {
      background: #0a0a15;
      border: 1px solid #3f3f46;
      border-radius: 12px;
      padding: 20px;
      overflow-x: auto;
      margin: 15px 0;
      font-size: 0.85rem;
    }
    code { font-family: 'Fira Code', 'Consolas', monospace; }
    .inline-code {
      background: #3f3f46;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.85rem;
    }
    .keyword { color: #c084fc; }
    .type { color: #38bdf8; }
    .string { color: #4ade80; }
    .comment { color: #6b7280; font-style: italic; }
    .field { color: #fbbf24; }
    .function { color: #f472b6; }
    .const { color: #fb923c; }
    .diagram {
      background: #0a0a15;
      border-radius: 12px;
      padding: 30px;
      margin: 20px 0;
      text-align: center;
      overflow-x: auto;
    }
    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      background: #1e293b;
      border-radius: 12px;
      overflow: hidden;
      font-size: 0.9rem;
    }
    .comparison-table th {
      background: linear-gradient(90deg, #0e7490, #7c3aed);
      padding: 14px;
      text-align: left;
      font-weight: 600;
    }
    .comparison-table td {
      padding: 12px 14px;
      border-bottom: 1px solid #334155;
    }
    .comparison-table tr:last-child td { border-bottom: none; }
    ul, ol { margin: 15px 0 15px 25px; }
    li { margin: 8px 0; color: #d4d4d8; }
    .chapter-nav {
      display: flex;
      justify-content: space-between;
      margin-top: 50px;
      padding-top: 30px;
      border-top: 1px solid #3f3f46;
    }
    .nav-btn {
      padding: 12px 24px;
      background: linear-gradient(90deg, #0e7490, #7c3aed);
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }
    .technique-card {
      background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
      border: 1px solid #374151;
      border-radius: 12px;
      padding: 20px;
      margin: 15px 0;
    }
    .technique-card h4 { color: #22d3ee; margin-bottom: 10px; }
    .badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 15px;
      font-size: 0.75rem;
      font-weight: 600;
      margin-left: 10px;
    }
    .badge-impact { background: #dc2626; color: white; }
    .badge-easy { background: #10b981; color: white; }
    .badge-advanced { background: #8b5cf6; color: white; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Chapter 11</h1>
    <p class="subtitle">Performance Optimization ‚Äî Making GraphQL Apps Lightning Fast</p>

    <!-- Section 11.1 -->
    <h2>11.1 Performance Optimization Overview</h2>
    
    <p>GraphQL performance optimization happens at multiple levels: network, cache, and render. Understanding where bottlenecks occur is key to effective optimization.</p>

    <div class="diagram">
      <svg viewBox="0 0 800 200" xmlns="http://www.w3.org/2000/svg">
        <text x="400" y="25" fill="#e4e4e7" font-size="16" font-weight="bold" text-anchor="middle">Performance Optimization Layers</text>
        
        <!-- Network -->
        <rect x="50" y="50" width="200" height="130" rx="10" fill="#0e7490" fill-opacity="0.3" stroke="#06b6d4" stroke-width="2"/>
        <text x="150" y="80" fill="#22d3ee" font-size="13" font-weight="bold" text-anchor="middle">üåê Network</text>
        <text x="70" y="105" fill="#94a3b8" font-size="10">‚Ä¢ Query batching</text>
        <text x="70" y="123" fill="#94a3b8" font-size="10">‚Ä¢ Persisted queries</text>
        <text x="70" y="141" fill="#94a3b8" font-size="10">‚Ä¢ Request deduplication</text>
        <text x="70" y="159" fill="#94a3b8" font-size="10">‚Ä¢ Compression</text>
        
        <!-- Cache -->
        <rect x="300" y="50" width="200" height="130" rx="10" fill="#7c3aed" fill-opacity="0.3" stroke="#a855f7" stroke-width="2"/>
        <text x="400" y="80" fill="#c084fc" font-size="13" font-weight="bold" text-anchor="middle">üíæ Cache</text>
        <text x="320" y="105" fill="#94a3b8" font-size="10">‚Ä¢ Normalized caching</text>
        <text x="320" y="123" fill="#94a3b8" font-size="10">‚Ä¢ Fetch policies</text>
        <text x="320" y="141" fill="#94a3b8" font-size="10">‚Ä¢ Cache reads</text>
        <text x="320" y="159" fill="#94a3b8" font-size="10">‚Ä¢ Prefetching</text>
        
        <!-- Render -->
        <rect x="550" y="50" width="200" height="130" rx="10" fill="#059669" fill-opacity="0.3" stroke="#10b981" stroke-width="2"/>
        <text x="650" y="80" fill="#34d399" font-size="13" font-weight="bold" text-anchor="middle">‚öõÔ∏è Render</text>
        <text x="570" y="105" fill="#94a3b8" font-size="10">‚Ä¢ Selective re-renders</text>
        <text x="570" y="123" fill="#94a3b8" font-size="10">‚Ä¢ useFragment hook</text>
        <text x="570" y="141" fill="#94a3b8" font-size="10">‚Ä¢ Memoization</text>
        <text x="570" y="159" fill="#94a3b8" font-size="10">‚Ä¢ List virtualization</text>
      </svg>
    </div>

    <!-- Section 11.2 -->
    <h2>11.2 Query Optimization</h2>

    <h3>Avoid Over-fetching</h3>
    <pre><code><span class="comment">// ‚ùå BAD: Fetching unnecessary fields</span>
<span class="keyword">const</span> <span class="const">GET_USER_BAD</span> = <span class="function">gql</span><span class="string">`
  query GetUser($id: ID!) {
    user(id: $id) {
      id
      name
      email
      avatar
      bio
      createdAt
      updatedAt
      posts { id title content comments { id text } }
      followers { id name avatar }
      following { id name avatar }
      settings { theme notifications privacy }
    }
  }
`</span>;

<span class="comment">// ‚úÖ GOOD: Fetch only what you need</span>
<span class="keyword">const</span> <span class="const">GET_USER_CARD</span> = <span class="function">gql</span><span class="string">`
  query GetUserCard($id: ID!) {
    user(id: $id) {
      id
      name
      avatar
    }
  }
`</span>;</code></pre>

    <h3>Use Fragments for Consistent Data Requirements</h3>
    <pre><code><span class="comment">// Define what each component needs</span>
<span class="keyword">const</span> <span class="const">USER_AVATAR_FRAGMENT</span> = <span class="function">gql</span><span class="string">`
  fragment UserAvatar on User {
    id
    avatar
    name
  }
`</span>;

<span class="comment">// Reuse across queries - prevents over/under-fetching</span>
<span class="keyword">const</span> <span class="const">GET_POST_WITH_AUTHOR</span> = <span class="function">gql</span><span class="string">`
  </span>${<span class="const">USER_AVATAR_FRAGMENT</span>}<span class="string">
  query GetPost($id: ID!) {
    post(id: $id) {
      id
      title
      author {
        ...UserAvatar
      }
    }
  }
`</span>;</code></pre>

    <!-- Section 11.3 -->
    <h2>11.3 Preventing Unnecessary Re-renders</h2>

    <h3>Using useMemo for Derived Data</h3>
    <pre><code><span class="keyword">function</span> <span class="function">UserList</span>() {
  <span class="keyword">const</span> { data } = <span class="function">useQuery</span>(<span class="const">GET_USERS</span>);
  
  <span class="comment">// ‚ùå BAD: Creates new array every render</span>
  <span class="keyword">const</span> activeUsersBad = data?.users?.<span class="function">filter</span>(u => u.isActive);
  
  <span class="comment">// ‚úÖ GOOD: Memoize derived data</span>
  <span class="keyword">const</span> activeUsers = <span class="function">useMemo</span>(
    () => data?.users?.<span class="function">filter</span>(u => u.isActive) ?? [],
    [data?.users]
  );

  <span class="comment">// ‚úÖ GOOD: Memoize expensive computations</span>
  <span class="keyword">const</span> userStats = <span class="function">useMemo</span>(() => {
    <span class="keyword">if</span> (!data?.users) <span class="keyword">return</span> <span class="keyword">null</span>;
    <span class="keyword">return</span> {
      <span class="field">total</span>: data.users.length,
      <span class="field">active</span>: data.users.<span class="function">filter</span>(u => u.isActive).length,
      <span class="field">avgPosts</span>: data.users.<span class="function">reduce</span>((sum, u) => sum + u.postsCount, 0) / data.users.length,
    };
  }, [data?.users]);

  <span class="keyword">return</span> <span class="keyword">&lt;</span>UserGrid users={activeUsers} stats={userStats} <span class="keyword">/&gt;</span>;
}</code></pre>

    <h3>useFragment for Selective Updates</h3>
    <pre><code><span class="keyword">import</span> { <span class="type">useFragment</span> } <span class="keyword">from</span> <span class="string">'@apollo/client'</span>;

<span class="comment">// Parent component fetches the list</span>
<span class="keyword">function</span> <span class="function">UserList</span>() {
  <span class="keyword">const</span> { data } = <span class="function">useQuery</span>(<span class="const">GET_USERS</span>);
  
  <span class="keyword">return</span> (
    <span class="keyword">&lt;</span>div<span class="keyword">&gt;</span>
      {data?.users.<span class="function">map</span>(user => (
        <span class="comment">// Each card manages its own data subscription</span>
        <span class="keyword">&lt;</span>UserCard <span class="field">key</span>={user.id} <span class="field">userId</span>={user.id} <span class="keyword">/&gt;</span>
      ))}
    <span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>
  );
}

<span class="comment">// Child component reads ONLY its fragment from cache</span>
<span class="keyword">function</span> <span class="function">UserCard</span>({ <span class="param">userId</span> }) {
  <span class="keyword">const</span> { data, complete } = <span class="function">useFragment</span>({
    <span class="field">fragment</span>: <span class="const">USER_CARD_FRAGMENT</span>,
    <span class="field">from</span>: {
      <span class="field">__typename</span>: <span class="string">'User'</span>,
      <span class="field">id</span>: userId,
    },
  });

  <span class="comment">// This component ONLY re-renders when THIS user's data changes</span>
  <span class="comment">// Other users changing won't affect this component!</span>
  
  <span class="keyword">if</span> (!complete) <span class="keyword">return</span> <span class="keyword">&lt;</span>Skeleton <span class="keyword">/&gt;</span>;
  
  <span class="keyword">return</span> (
    <span class="keyword">&lt;</span>div<span class="keyword">&gt;</span>
      <span class="keyword">&lt;</span>img <span class="field">src</span>={data.avatar} <span class="keyword">/&gt;</span>
      <span class="keyword">&lt;</span>span<span class="keyword">&gt;</span>{data.name}<span class="keyword">&lt;/</span>span<span class="keyword">&gt;</span>
    <span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>
  );
}</code></pre>

    <div class="warning-box">
      <code class="inline-code">useFragment</code> provides <strong>fine-grained reactivity</strong>. Unlike useQuery which re-renders for any cache change to the query, useFragment only triggers re-renders when the specific fragment data changes.
    </div>

    <!-- Section 11.4 -->
    <h2>11.4 Prefetching Data</h2>

    <div class="technique-card">
      <h4>Hover Prefetching <span class="badge badge-easy">EASY WIN</span></h4>
      <p>Load data before user clicks - creates instant perceived performance.</p>
    </div>

    <pre><code><span class="keyword">function</span> <span class="function">UserListItem</span>({ <span class="param">user</span> }) {
  <span class="keyword">const</span> client = <span class="function">useApolloClient</span>();

  <span class="keyword">const</span> <span class="function">prefetchUserProfile</span> = () => {
    <span class="comment">// Prefetch on hover - data ready when user clicks</span>
    client.<span class="function">query</span>({
      <span class="field">query</span>: <span class="const">GET_USER_PROFILE</span>,
      <span class="field">variables</span>: { <span class="field">id</span>: user.id },
    });
  };

  <span class="keyword">return</span> (
    <span class="keyword">&lt;</span>Link
      <span class="field">to</span>={<span class="string">`/users/</span>${user.id}<span class="string">`</span>}
      <span class="field">onMouseEnter</span>={prefetchUserProfile}
      <span class="field">onFocus</span>={prefetchUserProfile}
    <span class="keyword">&gt;</span>
      {user.name}
    <span class="keyword">&lt;/</span>Link<span class="keyword">&gt;</span>
  );
}

<span class="comment">// Route-level prefetching</span>
<span class="keyword">function</span> <span class="function">AppRoutes</span>() {
  <span class="keyword">const</span> client = <span class="function">useApolloClient</span>();
  <span class="keyword">const</span> location = <span class="function">useLocation</span>();

  <span class="function">useEffect</span>(() => {
    <span class="comment">// Prefetch data for likely next routes</span>
    <span class="keyword">if</span> (location.pathname === <span class="string">'/dashboard'</span>) {
      <span class="comment">// User likely to visit profile or settings next</span>
      client.<span class="function">query</span>({ <span class="field">query</span>: <span class="const">GET_USER_SETTINGS</span> });
      client.<span class="function">query</span>({ <span class="field">query</span>: <span class="const">GET_NOTIFICATIONS</span> });
    }
  }, [location.pathname, client]);

  <span class="keyword">return</span> <span class="keyword">&lt;</span>Routes<span class="keyword">&gt;</span>...<span class="keyword">&lt;/</span>Routes<span class="keyword">&gt;</span>;
}</code></pre>

    <!-- Section 11.5 -->
    <h2>11.5 Persisted Queries (APQ)</h2>

    <div class="technique-card">
      <h4>Automatic Persisted Queries <span class="badge badge-impact">HIGH IMPACT</span></h4>
      <p>Send query hashes instead of full query strings. Reduces payload size by 90%+.</p>
    </div>

    <pre><code><span class="keyword">import</span> { <span class="type">createPersistedQueryLink</span> } <span class="keyword">from</span> <span class="string">'@apollo/client/link/persisted-queries'</span>;
<span class="keyword">import</span> { sha256 } <span class="keyword">from</span> <span class="string">'crypto-hash'</span>;

<span class="keyword">const</span> <span class="const">persistedQueriesLink</span> = <span class="function">createPersistedQueryLink</span>({
  sha256,
  <span class="field">useGETForHashedQueries</span>: <span class="keyword">true</span>,  <span class="comment">// Use GET for cache-friendly requests</span>
});

<span class="keyword">const</span> <span class="const">client</span> = <span class="keyword">new</span> <span class="function">ApolloClient</span>({
  <span class="field">link</span>: <span class="function">from</span>([persistedQueriesLink, httpLink]),
  <span class="field">cache</span>: <span class="keyword">new</span> <span class="function">InMemoryCache</span>(),
});

<span class="comment">// How it works:</span>
<span class="comment">// 1st request: Sends hash ‚Üí Server: "Don't have it"</span>
<span class="comment">// 1st request retry: Sends hash + full query ‚Üí Server caches it</span>
<span class="comment">// 2nd+ requests: Sends only hash ‚Üí Server uses cached query</span></code></pre>

    <div class="diagram">
      <svg viewBox="0 0 750 180" xmlns="http://www.w3.org/2000/svg">
        <text x="375" y="25" fill="#e4e4e7" font-size="14" font-weight="bold" text-anchor="middle">APQ Flow</text>
        
        <!-- First request -->
        <text x="50" y="55" fill="#94a3b8" font-size="11">1st Request:</text>
        <rect x="50" y="65" width="150" height="35" rx="5" fill="#1e40af"/>
        <text x="125" y="87" fill="white" font-size="9" text-anchor="middle">Hash: abc123</text>
        
        <line x1="200" y1="82" x2="280" y2="82" stroke="#ef4444" stroke-width="2" marker-end="url(#redArr)"/>
        <text x="240" y="75" fill="#ef4444" font-size="8" text-anchor="middle">Not found</text>
        
        <rect x="280" y="65" width="200" height="35" rx="5" fill="#1e40af"/>
        <text x="380" y="87" fill="white" font-size="9" text-anchor="middle">Hash: abc123 + Full Query</text>
        
        <line x1="480" y1="82" x2="560" y2="82" stroke="#10b981" stroke-width="2" marker-end="url(#greenArr)"/>
        
        <rect x="560" y="65" width="130" height="35" rx="5" fill="#059669"/>
        <text x="625" y="87" fill="white" font-size="9" text-anchor="middle">Server caches</text>
        
        <!-- Subsequent requests -->
        <text x="50" y="130" fill="#94a3b8" font-size="11">Next Requests:</text>
        <rect x="50" y="140" width="150" height="35" rx="5" fill="#1e40af"/>
        <text x="125" y="162" fill="white" font-size="9" text-anchor="middle">Hash: abc123</text>
        
        <line x1="200" y1="157" x2="560" y2="157" stroke="#10b981" stroke-width="2" marker-end="url(#greenArr)"/>
        <text x="380" y="150" fill="#10b981" font-size="9" text-anchor="middle">Direct hit! (90% smaller payload)</text>
        
        <rect x="560" y="140" width="130" height="35" rx="5" fill="#059669"/>
        <text x="625" y="162" fill="white" font-size="9" text-anchor="middle">Uses cached query</text>
        
        <defs>
          <marker id="redArr" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#ef4444"/>
          </marker>
          <marker id="greenArr" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#10b981"/>
          </marker>
        </defs>
      </svg>
    </div>

    <!-- Section 11.6 -->
    <h2>11.6 Query Batching</h2>

    <pre><code><span class="keyword">import</span> { <span class="type">BatchHttpLink</span> } <span class="keyword">from</span> <span class="string">'@apollo/client/link/batch-http'</span>;

<span class="keyword">const</span> <span class="const">batchLink</span> = <span class="keyword">new</span> <span class="function">BatchHttpLink</span>({
  <span class="field">uri</span>: <span class="string">'/graphql'</span>,
  <span class="field">batchMax</span>: 10,       <span class="comment">// Max operations per batch</span>
  <span class="field">batchInterval</span>: 20,  <span class="comment">// Wait 20ms to collect operations</span>
});

<span class="comment">// Without batching: 5 queries = 5 HTTP requests</span>
<span class="comment">// With batching: 5 queries within 20ms = 1 HTTP request</span>

<span class="comment">// Example: Dashboard with multiple queries</span>
<span class="keyword">function</span> <span class="function">Dashboard</span>() {
  <span class="comment">// These 4 queries are automatically batched into 1 request!</span>
  <span class="keyword">const</span> { data: userData } = <span class="function">useQuery</span>(<span class="const">GET_USER</span>);
  <span class="keyword">const</span> { data: statsData } = <span class="function">useQuery</span>(<span class="const">GET_STATS</span>);
  <span class="keyword">const</span> { data: notifData } = <span class="function">useQuery</span>(<span class="const">GET_NOTIFICATIONS</span>);
  <span class="keyword">const</span> { data: recentData } = <span class="function">useQuery</span>(<span class="const">GET_RECENT_ACTIVITY</span>);
  
  <span class="comment">// ...</span>
}</code></pre>

    <div class="perf-box">
      Batching is especially effective when multiple components mount simultaneously. Instead of 10 parallel HTTP requests, you get 1 batched request with all operations.
    </div>

    <!-- Section 11.7 -->
    <h2>11.7 @defer and @stream (Experimental)</h2>

    <pre><code><span class="comment">// @defer: Load part of the response later</span>
<span class="keyword">const</span> <span class="const">GET_USER_WITH_POSTS</span> = <span class="function">gql</span><span class="string">`
  query GetUser($id: ID!) {
    user(id: $id) {
      id
      name
      avatar
      
      # Defer expensive nested data
      ... @defer {
        posts {
          id
          title
          comments {
            id
            text
          }
        }
        analyticsData {
          views
          engagement
        }
      }
    }
  }
`</span>;

<span class="comment">// Result comes in 2 parts:</span>
<span class="comment">// 1. Initial: { user: { id, name, avatar } }</span>
<span class="comment">// 2. Deferred: { user: { posts: [...], analyticsData: {...} } }</span>

<span class="comment">// @stream: Stream list items one by one</span>
<span class="keyword">const</span> <span class="const">GET_FEED</span> = <span class="function">gql</span><span class="string">`
  query GetFeed {
    feed @stream(initialCount: 5) {
      id
      title
      content
    }
  }
`</span>;

<span class="comment">// First 5 items arrive immediately, rest stream in</span></code></pre>

    <!-- Section 11.8 -->
    <h2>11.8 List Virtualization</h2>

    <pre><code><span class="keyword">import</span> { <span class="type">FixedSizeList</span> } <span class="keyword">from</span> <span class="string">'react-window'</span>;

<span class="keyword">function</span> <span class="function">VirtualizedUserList</span>() {
  <span class="keyword">const</span> { data } = <span class="function">useQuery</span>(<span class="const">GET_ALL_USERS</span>);
  
  <span class="keyword">const</span> <span class="function">Row</span> = ({ <span class="param">index</span>, <span class="param">style</span> }) => {
    <span class="keyword">const</span> user = data.users[index];
    <span class="keyword">return</span> (
      <span class="keyword">&lt;</span>div <span class="field">style</span>={style}<span class="keyword">&gt;</span>
        <span class="keyword">&lt;</span>UserCard user={user} <span class="keyword">/&gt;</span>
      <span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>
    );
  };

  <span class="comment">// Only renders visible items + buffer</span>
  <span class="comment">// 10,000 items? Only ~20 DOM nodes!</span>
  <span class="keyword">return</span> (
    <span class="keyword">&lt;</span><span class="type">FixedSizeList</span>
      <span class="field">height</span>={600}
      <span class="field">width</span>={400}
      <span class="field">itemCount</span>={data?.users?.length || 0}
      <span class="field">itemSize</span>={80}
    <span class="keyword">&gt;</span>
      {Row}
    <span class="keyword">&lt;/</span><span class="type">FixedSizeList</span><span class="keyword">&gt;</span>
  );
}</code></pre>

    <!-- Section 11.9 -->
    <h2>11.9 Performance Monitoring</h2>

    <pre><code><span class="keyword">import</span> { <span class="type">ApolloLink</span> } <span class="keyword">from</span> <span class="string">'@apollo/client'</span>;

<span class="keyword">const</span> <span class="const">performanceLink</span> = <span class="keyword">new</span> <span class="function">ApolloLink</span>((operation, forward) => {
  <span class="keyword">const</span> startTime = performance.<span class="function">now</span>();
  <span class="keyword">const</span> operationName = operation.operationName;

  <span class="keyword">return</span> <span class="function">forward</span>(operation).<span class="function">map</span>(response => {
    <span class="keyword">const</span> duration = performance.<span class="function">now</span>() - startTime;
    
    <span class="comment">// Log to analytics</span>
    analytics.<span class="function">track</span>(<span class="string">'graphql_operation'</span>, {
      <span class="field">operationName</span>,
      <span class="field">operationType</span>: operation.query.definitions[0]?.operation,
      <span class="field">duration</span>,
      <span class="field">cacheHit</span>: response.data && !response.errors,
    });

    <span class="comment">// Warn on slow queries</span>
    <span class="keyword">if</span> (duration > 2000) {
      console.<span class="function">warn</span>(<span class="string">`‚ö†Ô∏è Slow operation: </span>${operationName}<span class="string"> (</span>${duration.<span class="function">toFixed</span>(0)}<span class="string">ms)`</span>);
      
      <span class="comment">// Send to error tracking</span>
      Sentry.<span class="function">captureMessage</span>(<span class="string">`Slow GraphQL: </span>${operationName}<span class="string">`</span>, {
        <span class="field">level</span>: <span class="string">'warning'</span>,
        <span class="field">extra</span>: { <span class="field">duration</span>, <span class="field">variables</span>: operation.variables },
      });
    }

    <span class="keyword">return</span> response;
  });
});</code></pre>

    <!-- Section 11.10 -->
    <h2>11.10 Performance Checklist</h2>

    <table class="comparison-table">
      <tr>
        <th>Technique</th>
        <th>Impact</th>
        <th>Effort</th>
        <th>When to Use</th>
      </tr>
      <tr>
        <td>Fetch only needed fields</td>
        <td>üî•üî•üî•</td>
        <td>Low</td>
        <td>Always</td>
      </tr>
      <tr>
        <td>Use fragments</td>
        <td>üî•üî•</td>
        <td>Low</td>
        <td>Always</td>
      </tr>
      <tr>
        <td>cache-and-network policy</td>
        <td>üî•üî•üî•</td>
        <td>Low</td>
        <td>Most queries</td>
      </tr>
      <tr>
        <td>Prefetching on hover</td>
        <td>üî•üî•</td>
        <td>Low</td>
        <td>Navigation links</td>
      </tr>
      <tr>
        <td>Persisted queries</td>
        <td>üî•üî•üî•</td>
        <td>Medium</td>
        <td>Production apps</td>
      </tr>
      <tr>
        <td>Query batching</td>
        <td>üî•üî•</td>
        <td>Low</td>
        <td>Many concurrent queries</td>
      </tr>
      <tr>
        <td>useFragment hook</td>
        <td>üî•üî•üî•</td>
        <td>Medium</td>
        <td>Large lists, frequent updates</td>
      </tr>
      <tr>
        <td>List virtualization</td>
        <td>üî•üî•üî•</td>
        <td>Medium</td>
        <td>Long lists (100+ items)</td>
      </tr>
      <tr>
        <td>@defer/@stream</td>
        <td>üî•üî•</td>
        <td>High</td>
        <td>Complex nested data</td>
      </tr>
    </table>

    <div class="tip-box">
      Start with the low-effort, high-impact optimizations: proper field selection, fragments, and fetch policies. These alone can dramatically improve performance without code complexity.
    </div>

    <div class="chapter-nav">
      <button class="nav-btn">‚Üê Chapter 10: Error Handling</button>
      <button class="nav-btn">Next: Chapter 12 ‚Äî Architecture ‚Üí</button>
    </div>
  </div>
</body>
</html>
