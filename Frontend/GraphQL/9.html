<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 9: Pagination</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #064e3b 100%);
      color: #e4e4e7;
      line-height: 1.7;
      padding: 40px 20px;
      min-height: 100vh;
    }
    .container { max-width: 950px; margin: 0 auto; }
    h1 {
      font-size: 2.5rem;
      background: linear-gradient(90deg, #10b981, #06b6d4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 10px;
    }
    .subtitle { color: #a1a1aa; font-size: 1.1rem; margin-bottom: 40px; }
    h2 {
      color: #10b981;
      font-size: 1.6rem;
      margin: 40px 0 20px;
      padding-bottom: 10px;
      border-bottom: 2px solid #3f3f46;
    }
    h3 { color: #34d399; font-size: 1.2rem; margin: 25px 0 15px; }
    h4 { color: #6ee7b7; font-size: 1rem; margin: 20px 0 10px; }
    p { margin-bottom: 15px; color: #d4d4d8; }
    .highlight-box {
      background: linear-gradient(135deg, #064e3b 0%, #022c22 100%);
      border-left: 4px solid #10b981;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .warning-box {
      background: linear-gradient(135deg, #78350f 0%, #451a03 100%);
      border-left: 4px solid #f59e0b;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .warning-box::before { content: "‚ö†Ô∏è INTERVIEW HIGHLIGHT: "; font-weight: bold; color: #fbbf24; }
    .tip-box {
      background: linear-gradient(135deg, #1e3a8a 0%, #1e1b4b 100%);
      border-left: 4px solid #3b82f6;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .tip-box::before { content: "üìù PRODUCTION TIP: "; font-weight: bold; color: #60a5fa; }
    .concept-box {
      background: linear-gradient(135deg, #7c2d12 0%, #431407 100%);
      border-left: 4px solid #f97316;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .concept-box::before { content: "üí° KEY CONCEPT: "; font-weight: bold; color: #fb923c; }
    pre {
      background: #0a0a15;
      border: 1px solid #3f3f46;
      border-radius: 12px;
      padding: 20px;
      overflow-x: auto;
      margin: 15px 0;
      font-size: 0.85rem;
    }
    code { font-family: 'Fira Code', 'Consolas', monospace; }
    .inline-code {
      background: #3f3f46;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.85rem;
    }
    .keyword { color: #c084fc; }
    .type { color: #38bdf8; }
    .string { color: #4ade80; }
    .comment { color: #6b7280; font-style: italic; }
    .field { color: #fbbf24; }
    .function { color: #f472b6; }
    .const { color: #fb923c; }
    .diagram {
      background: #0a0a15;
      border-radius: 12px;
      padding: 30px;
      margin: 20px 0;
      text-align: center;
      overflow-x: auto;
    }
    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      background: #1e293b;
      border-radius: 12px;
      overflow: hidden;
      font-size: 0.9rem;
    }
    .comparison-table th {
      background: linear-gradient(90deg, #047857, #0e7490);
      padding: 14px;
      text-align: left;
      font-weight: 600;
    }
    .comparison-table td {
      padding: 12px 14px;
      border-bottom: 1px solid #334155;
    }
    .comparison-table tr:last-child td { border-bottom: none; }
    ul, ol { margin: 15px 0 15px 25px; }
    li { margin: 8px 0; color: #d4d4d8; }
    .chapter-nav {
      display: flex;
      justify-content: space-between;
      margin-top: 50px;
      padding-top: 30px;
      border-top: 1px solid #3f3f46;
    }
    .nav-btn {
      padding: 12px 24px;
      background: linear-gradient(90deg, #047857, #0e7490);
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }
    .pattern-card {
      background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
      border: 1px solid #374151;
      border-radius: 12px;
      padding: 20px;
      margin: 15px 0;
    }
    .pattern-card h4 {
      color: #10b981;
      margin-bottom: 10px;
    }
    .badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 15px;
      font-size: 0.75rem;
      font-weight: 600;
      margin-left: 10px;
    }
    .badge-simple { background: #3b82f6; color: white; }
    .badge-recommended { background: #10b981; color: white; }
    .badge-advanced { background: #8b5cf6; color: white; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Chapter 9</h1>
    <p class="subtitle">Pagination ‚Äî Loading Data in Chunks</p>

    <!-- Section 9.1 -->
    <h2>9.1 Why Pagination Matters</h2>
    
    <p>Loading thousands of items at once is terrible for performance and UX. Pagination lets you load data in manageable chunks, improving load times, reducing memory usage, and providing a better user experience.</p>

    <div class="highlight-box">
      <strong>Pagination Strategies:</strong>
      <ul style="margin-top: 10px;">
        <li><strong>Offset-based:</strong> Use offset and limit (page numbers)</li>
        <li><strong>Cursor-based:</strong> Use cursors to mark positions</li>
        <li><strong>Relay-style:</strong> Standardized cursor pagination with connections</li>
      </ul>
    </div>

    <table class="comparison-table">
      <tr>
        <th>Strategy</th>
        <th>Pros</th>
        <th>Cons</th>
        <th>Best For</th>
      </tr>
      <tr>
        <td><strong>Offset-based</strong></td>
        <td>Simple, supports jumping to pages</td>
        <td>Inconsistent with changing data</td>
        <td>Static content, admin panels</td>
      </tr>
      <tr>
        <td><strong>Cursor-based</strong></td>
        <td>Consistent, handles real-time data</td>
        <td>Can't jump to arbitrary pages</td>
        <td>Feeds, infinite scroll</td>
      </tr>
      <tr>
        <td><strong>Relay-style</strong></td>
        <td>Standardized, full-featured</td>
        <td>More complex structure</td>
        <td>Production apps, complex UIs</td>
      </tr>
    </table>

    <!-- Section 9.2 -->
    <h2>9.2 Offset-Based Pagination</h2>

    <div class="pattern-card">
      <h4>Page Numbers Pattern <span class="badge badge-simple">SIMPLE</span></h4>
      <p>Uses <code class="inline-code">offset</code> (skip) and <code class="inline-code">limit</code> (take) to slice data.</p>
    </div>

    <pre><code><span class="keyword">const</span> <span class="const">GET_POSTS</span> = <span class="function">gql</span><span class="string">`
  query GetPosts($offset: Int!, $limit: Int!) {
    posts(offset: $offset, limit: $limit) {
      id
      title
      excerpt
      author {
        name
      }
    }
    postsCount  # Total count for page calculation
  }
`</span>;

<span class="keyword">function</span> <span class="function">PostList</span>() {
  <span class="keyword">const</span> [page, setPage] = <span class="function">useState</span>(1);
  <span class="keyword">const</span> <span class="const">ITEMS_PER_PAGE</span> = 10;
  
  <span class="keyword">const</span> { data, loading } = <span class="function">useQuery</span>(<span class="const">GET_POSTS</span>, {
    <span class="field">variables</span>: {
      <span class="field">offset</span>: (page - 1) * <span class="const">ITEMS_PER_PAGE</span>,
      <span class="field">limit</span>: <span class="const">ITEMS_PER_PAGE</span>,
    },
  });

  <span class="keyword">const</span> totalPages = Math.<span class="function">ceil</span>((data?.postsCount || 0) / <span class="const">ITEMS_PER_PAGE</span>);

  <span class="keyword">return</span> (
    <span class="keyword">&lt;</span>div<span class="keyword">&gt;</span>
      {loading ? <span class="keyword">&lt;</span>Skeleton <span class="keyword">/&gt;</span> : (
        <span class="keyword">&lt;</span>PostGrid posts={data.posts} <span class="keyword">/&gt;</span>
      )}
      
      <span class="keyword">&lt;</span>Pagination
        <span class="field">currentPage</span>={page}
        <span class="field">totalPages</span>={totalPages}
        <span class="field">onPageChange</span>={setPage}
      <span class="keyword">/&gt;</span>
    <span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>
  );
}</code></pre>

    <div class="diagram">
      <svg viewBox="0 0 700 150" xmlns="http://www.w3.org/2000/svg">
        <text x="350" y="25" fill="#e4e4e7" font-size="14" font-weight="bold" text-anchor="middle">Offset-Based: The Problem</text>
        
        <!-- Initial state -->
        <text x="50" y="55" fill="#94a3b8" font-size="10">Initial Data:</text>
        <rect x="50" y="65" width="40" height="30" fill="#3b82f6" rx="4"/>
        <text x="70" y="85" fill="white" font-size="10" text-anchor="middle">A</text>
        <rect x="95" y="65" width="40" height="30" fill="#3b82f6" rx="4"/>
        <text x="115" y="85" fill="white" font-size="10" text-anchor="middle">B</text>
        <rect x="140" y="65" width="40" height="30" fill="#10b981" rx="4"/>
        <text x="160" y="85" fill="white" font-size="10" text-anchor="middle">C</text>
        <rect x="185" y="65" width="40" height="30" fill="#10b981" rx="4"/>
        <text x="205" y="85" fill="white" font-size="10" text-anchor="middle">D</text>
        <rect x="230" y="65" width="40" height="30" fill="#6b7280" rx="4"/>
        <text x="250" y="85" fill="white" font-size="10" text-anchor="middle">E</text>
        
        <text x="70" y="115" fill="#3b82f6" font-size="9" text-anchor="middle">Page 1</text>
        <text x="183" y="115" fill="#10b981" font-size="9" text-anchor="middle">Page 2</text>
        
        <!-- After deletion -->
        <text x="400" y="55" fill="#94a3b8" font-size="10">After "A" deleted, request Page 2:</text>
        <rect x="400" y="65" width="40" height="30" fill="#3b82f6" rx="4"/>
        <text x="420" y="85" fill="white" font-size="10" text-anchor="middle">B</text>
        <rect x="445" y="65" width="40" height="30" fill="#3b82f6" rx="4"/>
        <text x="465" y="85" fill="white" font-size="10" text-anchor="middle">C</text>
        <rect x="490" y="65" width="40" height="30" fill="#f87171" rx="4" stroke="#ef4444" stroke-width="2"/>
        <text x="510" y="85" fill="white" font-size="10" text-anchor="middle">E</text>
        <rect x="535" y="65" width="40" height="30" fill="#f87171" rx="4"/>
        <text x="555" y="85" fill="white" font-size="10" text-anchor="middle">F</text>
        
        <text x="423" y="115" fill="#3b82f6" font-size="9" text-anchor="middle">Page 1</text>
        <text x="513" y="115" fill="#f87171" font-size="9" text-anchor="middle">Page 2</text>
        <text x="555" y="130" fill="#f87171" font-size="8" text-anchor="middle">D skipped!</text>
      </svg>
    </div>

    <div class="warning-box">
      Offset pagination has a fundamental flaw: if data changes between requests (items added/deleted), you may skip or duplicate items. This is why <strong>cursor-based pagination is preferred</strong> for real-time feeds.
    </div>

    <!-- Section 9.3 -->
    <h2>9.3 Infinite Scroll with fetchMore</h2>

    <pre><code><span class="keyword">const</span> <span class="const">GET_POSTS</span> = <span class="function">gql</span><span class="string">`
  query GetPosts($offset: Int!, $limit: Int!) {
    posts(offset: $offset, limit: $limit) {
      id
      title
      excerpt
    }
  }
`</span>;

<span class="keyword">function</span> <span class="function">InfinitePostList</span>() {
  <span class="keyword">const</span> { data, loading, fetchMore } = <span class="function">useQuery</span>(<span class="const">GET_POSTS</span>, {
    <span class="field">variables</span>: { <span class="field">offset</span>: 0, <span class="field">limit</span>: 10 },
  });
  
  <span class="comment">// Intersection Observer for infinite scroll</span>
  <span class="keyword">const</span> observerRef = <span class="function">useRef</span>(<span class="keyword">null</span>);
  <span class="keyword">const</span> [hasMore, setHasMore] = <span class="function">useState</span>(<span class="keyword">true</span>);
  
  <span class="keyword">const</span> <span class="function">loadMore</span> = <span class="function">useCallback</span>(<span class="keyword">async</span> () => {
    <span class="keyword">if</span> (!hasMore || loading) <span class="keyword">return</span>;
    
    <span class="keyword">const</span> { data: newData } = <span class="keyword">await</span> <span class="function">fetchMore</span>({
      <span class="field">variables</span>: {
        <span class="field">offset</span>: data.posts.length,
        <span class="field">limit</span>: 10,
      },
    });
    
    <span class="keyword">if</span> (newData.posts.length < 10) {
      <span class="function">setHasMore</span>(<span class="keyword">false</span>);
    }
  }, [data?.posts?.length, fetchMore, hasMore, loading]);
  
  <span class="comment">// Set up intersection observer</span>
  <span class="function">useEffect</span>(() => {
    <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="type">IntersectionObserver</span>(
      entries => {
        <span class="keyword">if</span> (entries[0].isIntersecting) {
          <span class="function">loadMore</span>();
        }
      },
      { <span class="field">threshold</span>: 0.1 }
    );
    
    <span class="keyword">if</span> (observerRef.current) {
      observer.<span class="function">observe</span>(observerRef.current);
    }
    
    <span class="keyword">return</span> () => observer.<span class="function">disconnect</span>();
  }, [loadMore]);

  <span class="keyword">return</span> (
    <span class="keyword">&lt;</span>div<span class="keyword">&gt;</span>
      {data?.posts.<span class="function">map</span>(post => (
        <span class="keyword">&lt;</span>PostCard <span class="field">key</span>={post.id} <span class="field">post</span>={post} <span class="keyword">/&gt;</span>
      ))}
      
      {hasMore && (
        <span class="keyword">&lt;</span>div <span class="field">ref</span>={observerRef} className=<span class="string">"loading-trigger"</span><span class="keyword">&gt;</span>
          {loading && <span class="keyword">&lt;</span>Spinner <span class="keyword">/&gt;</span>}
        <span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>
      )}
    <span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>
  );
}</code></pre>

    <h3>Cache Configuration for Offset Pagination</h3>

    <pre><code><span class="keyword">const</span> <span class="const">cache</span> = <span class="keyword">new</span> <span class="function">InMemoryCache</span>({
  <span class="field">typePolicies</span>: {
    <span class="field">Query</span>: {
      <span class="field">fields</span>: {
        <span class="field">posts</span>: {
          <span class="comment">// Don't cache separately for offset/limit</span>
          <span class="field">keyArgs</span>: <span class="keyword">false</span>,
          
          <span class="function">merge</span>(existing = [], incoming, { args }) {
            <span class="comment">// If offset is 0, replace entirely (new search)</span>
            <span class="keyword">if</span> (args?.offset === 0) {
              <span class="keyword">return</span> incoming;
            }
            
            <span class="comment">// Otherwise, merge at the correct position</span>
            <span class="keyword">const</span> merged = existing.<span class="function">slice</span>(0);
            <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < incoming.length; i++) {
              merged[args.offset + i] = incoming[i];
            }
            <span class="keyword">return</span> merged;
          },
        },
      },
    },
  },
});</code></pre>

    <!-- Section 9.4 -->
    <h2>9.4 Cursor-Based Pagination</h2>

    <div class="pattern-card">
      <h4>Cursor Pattern <span class="badge badge-recommended">RECOMMENDED</span></h4>
      <p>Uses opaque cursors to mark positions. Immune to data changes between requests.</p>
    </div>

    <pre><code><span class="keyword">const</span> <span class="const">GET_POSTS</span> = <span class="function">gql</span><span class="string">`
  query GetPosts($first: Int!, $after: String) {
    posts(first: $first, after: $after) {
      edges {
        cursor
        node {
          id
          title
          excerpt
        }
      }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
`</span>;

<span class="keyword">function</span> <span class="function">CursorPaginatedList</span>() {
  <span class="keyword">const</span> { data, loading, fetchMore } = <span class="function">useQuery</span>(<span class="const">GET_POSTS</span>, {
    <span class="field">variables</span>: { <span class="field">first</span>: 10 },
  });
  
  <span class="keyword">const</span> <span class="function">loadMore</span> = () => {
    <span class="keyword">if</span> (!data?.posts.pageInfo.hasNextPage) <span class="keyword">return</span>;
    
    <span class="function">fetchMore</span>({
      <span class="field">variables</span>: {
        <span class="field">after</span>: data.posts.pageInfo.endCursor,
      },
    });
  };

  <span class="keyword">return</span> (
    <span class="keyword">&lt;</span>div<span class="keyword">&gt;</span>
      {data?.posts.edges.<span class="function">map</span>(({ node }) => (
        <span class="keyword">&lt;</span>PostCard <span class="field">key</span>={node.id} <span class="field">post</span>={node} <span class="keyword">/&gt;</span>
      ))}
      
      {data?.posts.pageInfo.hasNextPage && (
        <span class="keyword">&lt;</span>button <span class="field">onClick</span>={loadMore} <span class="field">disabled</span>={loading}<span class="keyword">&gt;</span>
          {loading ? <span class="string">'Loading...'</span> : <span class="string">'Load More'</span>}
        <span class="keyword">&lt;/</span>button<span class="keyword">&gt;</span>
      )}
    <span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>
  );
}</code></pre>

    <div class="concept-box">
      <strong>What is a Cursor?</strong><br><br>
      A cursor is an opaque string that marks a specific position in the dataset. It's typically a base64-encoded identifier or timestamp. The server knows how to decode it and fetch items after that position.
    </div>

    <!-- Section 9.5 -->
    <h2>9.5 Relay-Style Pagination</h2>

    <div class="pattern-card">
      <h4>Relay Connection Specification <span class="badge badge-advanced">INDUSTRY STANDARD</span></h4>
      <p>A standardized cursor-based pagination format with edges, nodes, and pageInfo.</p>
    </div>

    <pre><code><span class="comment">// Relay Connection Schema Pattern</span>
<span class="keyword">type</span> <span class="type">Query</span> {
  <span class="field">posts</span>(
    first: <span class="type">Int</span>
    after: <span class="type">String</span>
    last: <span class="type">Int</span>
    before: <span class="type">String</span>
  ): <span class="type">PostConnection!</span>
}

<span class="keyword">type</span> <span class="type">PostConnection</span> {
  <span class="field">edges</span>: [<span class="type">PostEdge!</span>]!
  <span class="field">pageInfo</span>: <span class="type">PageInfo!</span>
  <span class="field">totalCount</span>: <span class="type">Int</span>
}

<span class="keyword">type</span> <span class="type">PostEdge</span> {
  <span class="field">cursor</span>: <span class="type">String!</span>
  <span class="field">node</span>: <span class="type">Post!</span>
}

<span class="keyword">type</span> <span class="type">PageInfo</span> {
  <span class="field">hasNextPage</span>: <span class="type">Boolean!</span>
  <span class="field">hasPreviousPage</span>: <span class="type">Boolean!</span>
  <span class="field">startCursor</span>: <span class="type">String</span>
  <span class="field">endCursor</span>: <span class="type">String</span>
}</code></pre>

    <h3>Apollo's relayStylePagination Helper</h3>

    <pre><code><span class="keyword">import</span> { <span class="type">InMemoryCache</span> } <span class="keyword">from</span> <span class="string">'@apollo/client'</span>;
<span class="keyword">import</span> { <span class="type">relayStylePagination</span> } <span class="keyword">from</span> <span class="string">'@apollo/client/utilities'</span>;

<span class="keyword">const</span> <span class="const">cache</span> = <span class="keyword">new</span> <span class="function">InMemoryCache</span>({
  <span class="field">typePolicies</span>: {
    <span class="field">Query</span>: {
      <span class="field">fields</span>: {
        <span class="comment">// Simple usage - handles all the merge logic</span>
        <span class="field">posts</span>: <span class="function">relayStylePagination</span>(),
        
        <span class="comment">// With key args (separate cache by filter)</span>
        <span class="field">searchResults</span>: <span class="function">relayStylePagination</span>([<span class="string">"query"</span>, <span class="string">"category"</span>]),
        
        <span class="comment">// Custom key args function</span>
        <span class="field">userPosts</span>: <span class="function">relayStylePagination</span>((args) => {
          <span class="keyword">return</span> [<span class="string">"userId"</span>, args?.filter];
        }),
      },
    },
  },
});</code></pre>

    <h3>Complete Relay Pagination Component</h3>

    <pre><code><span class="keyword">const</span> <span class="const">GET_POSTS_CONNECTION</span> = <span class="function">gql</span><span class="string">`
  query GetPostsConnection(
    $first: Int
    $after: String
    $last: Int
    $before: String
  ) {
    postsConnection(
      first: $first
      after: $after
      last: $last
      before: $before
    ) {
      edges {
        cursor
        node {
          id
          title
          excerpt
          createdAt
          author {
            id
            name
            avatar
          }
        }
      }
      pageInfo {
        hasNextPage
        hasPreviousPage
        startCursor
        endCursor
      }
      totalCount
    }
  }
`</span>;

<span class="keyword">function</span> <span class="function">RelayPaginatedPosts</span>() {
  <span class="keyword">const</span> { data, loading, error, fetchMore } = <span class="function">useQuery</span>(<span class="const">GET_POSTS_CONNECTION</span>, {
    <span class="field">variables</span>: { <span class="field">first</span>: 10 },
    <span class="field">notifyOnNetworkStatusChange</span>: <span class="keyword">true</span>,
  });

  <span class="keyword">const</span> <span class="function">loadNextPage</span> = () => {
    <span class="keyword">if</span> (!data?.postsConnection.pageInfo.hasNextPage) <span class="keyword">return</span>;
    
    <span class="function">fetchMore</span>({
      <span class="field">variables</span>: {
        <span class="field">first</span>: 10,
        <span class="field">after</span>: data.postsConnection.pageInfo.endCursor,
      },
    });
  };

  <span class="keyword">const</span> <span class="function">loadPreviousPage</span> = () => {
    <span class="keyword">if</span> (!data?.postsConnection.pageInfo.hasPreviousPage) <span class="keyword">return</span>;
    
    <span class="function">fetchMore</span>({
      <span class="field">variables</span>: {
        <span class="field">last</span>: 10,
        <span class="field">before</span>: data.postsConnection.pageInfo.startCursor,
      },
    });
  };

  <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="keyword">&lt;</span>Error message={error.message} <span class="keyword">/&gt;</span>;
  <span class="keyword">if</span> (!data && loading) <span class="keyword">return</span> <span class="keyword">&lt;</span>Skeleton <span class="keyword">/&gt;</span>;

  <span class="keyword">const</span> { edges, pageInfo, totalCount } = data.postsConnection;

  <span class="keyword">return</span> (
    <span class="keyword">&lt;</span>div<span class="keyword">&gt;</span>
      <span class="keyword">&lt;</span>p<span class="keyword">&gt;</span>Showing {edges.length} of {totalCount} posts<span class="keyword">&lt;/</span>p<span class="keyword">&gt;</span>
      
      {edges.<span class="function">map</span>(({ node, cursor }) => (
        <span class="keyword">&lt;</span>PostCard <span class="field">key</span>={cursor} <span class="field">post</span>={node} <span class="keyword">/&gt;</span>
      ))}
      
      <span class="keyword">&lt;</span>div className=<span class="string">"pagination-controls"</span><span class="keyword">&gt;</span>
        <span class="keyword">&lt;</span>button
          <span class="field">onClick</span>={loadPreviousPage}
          <span class="field">disabled</span>={!pageInfo.hasPreviousPage || loading}
        <span class="keyword">&gt;</span>
          ‚Üê Previous
        <span class="keyword">&lt;/</span>button<span class="keyword">&gt;</span>
        
        <span class="keyword">&lt;</span>button
          <span class="field">onClick</span>={loadNextPage}
          <span class="field">disabled</span>={!pageInfo.hasNextPage || loading}
        <span class="keyword">&gt;</span>
          Next ‚Üí
        <span class="keyword">&lt;/</span>button<span class="keyword">&gt;</span>
      <span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>
      
      {loading && <span class="keyword">&lt;</span>LoadingOverlay <span class="keyword">/&gt;</span>}
    <span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>
  );
}</code></pre>

    <div class="warning-box">
      <strong>Relay-style pagination</strong> is the industry standard for production GraphQL apps. Know the structure: <code class="inline-code">edges</code> ‚Üí <code class="inline-code">cursor</code> + <code class="inline-code">node</code>, plus <code class="inline-code">pageInfo</code> for navigation state.
    </div>

    <!-- Section 9.6 -->
    <h2>9.6 Bidirectional Pagination</h2>

    <pre><code><span class="keyword">function</span> <span class="function">BidirectionalChat</span>({ <span class="param">channelId</span> }) {
  <span class="keyword">const</span> { data, fetchMore } = <span class="function">useQuery</span>(<span class="const">GET_MESSAGES</span>, {
    <span class="field">variables</span>: { <span class="field">channelId</span>, <span class="field">last</span>: 20 },  <span class="comment">// Start with newest</span>
  });

  <span class="comment">// Load older messages (scroll up)</span>
  <span class="keyword">const</span> <span class="function">loadOlder</span> = () => {
    <span class="function">fetchMore</span>({
      <span class="field">variables</span>: {
        <span class="field">last</span>: 20,
        <span class="field">before</span>: data.messages.pageInfo.startCursor,
      },
    });
  };

  <span class="comment">// Load newer messages (new messages)</span>
  <span class="keyword">const</span> <span class="function">loadNewer</span> = () => {
    <span class="function">fetchMore</span>({
      <span class="field">variables</span>: {
        <span class="field">first</span>: 20,
        <span class="field">after</span>: data.messages.pageInfo.endCursor,
      },
    });
  };

  <span class="keyword">return</span> (
    <span class="keyword">&lt;</span>div<span class="keyword">&gt;</span>
      {data.messages.pageInfo.hasPreviousPage && (
        <span class="keyword">&lt;</span>button <span class="field">onClick</span>={loadOlder}<span class="keyword">&gt;</span>Load older<span class="keyword">&lt;/</span>button<span class="keyword">&gt;</span>
      )}
      
      <span class="keyword">&lt;</span>MessageList messages={data.messages.edges} <span class="keyword">/&gt;</span>
      
      {data.messages.pageInfo.hasNextPage && (
        <span class="keyword">&lt;</span>button <span class="field">onClick</span>={loadNewer}<span class="keyword">&gt;</span>Load newer<span class="keyword">&lt;/</span>button<span class="keyword">&gt;</span>
      )}
    <span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>
  );
}</code></pre>

    <!-- Section 9.7 -->
    <h2>9.7 Custom Merge Functions</h2>

    <pre><code><span class="keyword">const</span> <span class="const">cache</span> = <span class="keyword">new</span> <span class="function">InMemoryCache</span>({
  <span class="field">typePolicies</span>: {
    <span class="field">Query</span>: {
      <span class="field">fields</span>: {
        <span class="comment">// Custom pagination with filters</span>
        <span class="field">products</span>: {
          <span class="comment">// Cache separately by category and sortBy</span>
          <span class="field">keyArgs</span>: [<span class="string">"category"</span>, <span class="string">"sortBy"</span>],
          
          <span class="function">merge</span>(existing, incoming, { args, readField }) {
            <span class="keyword">const</span> merged = existing ? { ...existing } : {
              <span class="field">edges</span>: [],
              <span class="field">pageInfo</span>: incoming.pageInfo,
            };
            
            <span class="comment">// Determine direction based on args</span>
            <span class="keyword">if</span> (args?.after) {
              <span class="comment">// Forward pagination - append</span>
              merged.edges = [...merged.edges, ...incoming.edges];
            } <span class="keyword">else if</span> (args?.before) {
              <span class="comment">// Backward pagination - prepend</span>
              merged.edges = [...incoming.edges, ...merged.edges];
            } <span class="keyword">else</span> {
              <span class="comment">// Initial load or reset</span>
              merged.edges = incoming.edges;
            }
            
            <span class="comment">// Update pageInfo based on direction</span>
            merged.pageInfo = {
              ...merged.pageInfo,
              ...incoming.pageInfo,
            };
            
            <span class="keyword">return</span> merged;
          },
          
          <span class="function">read</span>(existing, { args }) {
            <span class="keyword">if</span> (!existing) <span class="keyword">return</span> <span class="keyword">undefined</span>;
            
            <span class="comment">// Return all cached items</span>
            <span class="keyword">return</span> existing;
          },
        },
      },
    },
  },
});</code></pre>

    <div class="tip-box">
      Always test pagination with changing data. Add/delete items while paginating to ensure your implementation handles edge cases correctly.
    </div>

    <div class="chapter-nav">
      <button class="nav-btn">‚Üê Chapter 8: Caching</button>
      <button class="nav-btn">Next: Chapter 10 ‚Äî Error Handling ‚Üí</button>
    </div>
  </div>
</body>
</html>
