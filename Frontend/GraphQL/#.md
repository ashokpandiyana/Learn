# GraphQL Frontend with React: Complete Mastery Guide
## From Beginner to Production-Ready (Interview Edition)

---

# PART I: FOUNDATIONS

---

## Chapter 1: GraphQL Core Concepts

### 1.1 What is GraphQL?
- Query language for APIs (not a database)
- Runtime for executing queries
- Created by Facebook (2012), open-sourced (2015)

### 1.2 GraphQL vs REST
| Aspect | GraphQL | REST |
|--------|---------|------|
| Data Fetching | Single endpoint, get exactly what you need | Multiple endpoints, over/under-fetching |
| Versioning | No versioning needed (evolve schema) | v1, v2, v3 endpoints |
| Type System | Strongly typed schema | No built-in type system |
| Real-time | Subscriptions built-in | Requires WebSockets setup |

> **‚ö†Ô∏è INTERVIEW HIGHLIGHT:** "GraphQL solves over-fetching and under-fetching problems. You request exactly what you need in a single query."

### 1.3 GraphQL Type System
- **Scalar Types:** `Int`, `Float`, `String`, `Boolean`, `ID`
- **Object Types:** Custom types with fields
- **Enum Types:** Predefined set of values
- **Input Types:** For mutation arguments
- **Interface Types:** Abstract types for polymorphism
- **Union Types:** Return one of several object types

### 1.4 Schema Definition Language (SDL)
```graphql
type User {
  id: ID!
  name: String!
  email: String
  posts: [Post!]!
}

type Query {
  user(id: ID!): User
  users: [User!]!
}

type Mutation {
  createUser(input: CreateUserInput!): User!
}
```

> **üìù IMPORTANT:** `!` means non-nullable. `[Type!]!` means non-nullable array with non-nullable items.

### 1.5 Operations
- **Query:** Read data (GET equivalent)
- **Mutation:** Write/modify data (POST/PUT/DELETE equivalent)
- **Subscription:** Real-time updates via WebSocket

---

## Chapter 2: Apollo Client Setup & Architecture

### 2.1 Why Apollo Client?
- Most popular GraphQL client for React
- Powerful caching out of the box
- Excellent developer tools
- Active community and documentation

### 2.2 Installation
```bash
npm install @apollo/client graphql
```

### 2.3 Basic Setup
```jsx
import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client';

const client = new ApolloClient({
  uri: 'https://your-graphql-endpoint.com/graphql',
  cache: new InMemoryCache(),
});

function App() {
  return (
    <ApolloProvider client={client}>
      <YourApp />
    </ApolloProvider>
  );
}
```

### 2.4 Apollo Client Architecture
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              React Components               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ         Apollo Client Hooks Layer           ‚îÇ
‚îÇ   (useQuery, useMutation, useSubscription)  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ              Apollo Link Chain              ‚îÇ
‚îÇ  (HTTP, Error, Auth, Retry, WebSocket)      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ         Normalized Cache (InMemoryCache)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

> **‚ö†Ô∏è INTERVIEW HIGHLIGHT:** Apollo Client uses a normalized cache where each object is stored by its `__typename` and `id`. This enables automatic UI updates when data changes.

### 2.5 Apollo DevTools
- Chrome/Firefox extension
- Inspect cache contents
- View active queries
- Test queries in GraphiQL

---

## Chapter 3: Apollo Link Chain (Advanced Setup)

### 3.1 Understanding Links
Links are middleware for your GraphQL operations.

```jsx
import { ApolloClient, InMemoryCache, HttpLink, from } from '@apollo/client';
import { onError } from '@apollo/client/link/error';
import { RetryLink } from '@apollo/client/link/retry';

const httpLink = new HttpLink({
  uri: '/graphql',
});

const errorLink = onError(({ graphQLErrors, networkError }) => {
  if (graphQLErrors) {
    graphQLErrors.forEach(({ message, locations, path }) => {
      console.error(`[GraphQL error]: ${message}`);
    });
  }
  if (networkError) {
    console.error(`[Network error]: ${networkError}`);
  }
});

const retryLink = new RetryLink({
  delay: { initial: 300, max: 3000, jitter: true },
  attempts: { max: 3, retryIf: (error) => !!error },
});

const client = new ApolloClient({
  link: from([errorLink, retryLink, httpLink]),
  cache: new InMemoryCache(),
});
```

### 3.2 Common Link Types
| Link | Purpose |
|------|---------|
| `HttpLink` | Send queries over HTTP |
| `ErrorLink` | Global error handling |
| `RetryLink` | Retry failed requests |
| `AuthLink` | Add authentication headers |
| `WebSocketLink` | Real-time subscriptions |
| `BatchHttpLink` | Batch multiple operations |
| `PersistedQueryLink` | APQ support |

### 3.3 Authentication Link
```jsx
import { setContext } from '@apollo/client/link/context';

const authLink = setContext((_, { headers }) => {
  const token = localStorage.getItem('token');
  return {
    headers: {
      ...headers,
      authorization: token ? `Bearer ${token}` : '',
    },
  };
});

const client = new ApolloClient({
  link: from([authLink, errorLink, httpLink]),
  cache: new InMemoryCache(),
});
```

> **üìù PRODUCTION TIP:** Always place `authLink` before `httpLink` in the chain. Order matters!

---

# PART II: CORE OPERATIONS

---

## Chapter 4: Queries with useQuery

### 4.1 Basic Query
```jsx
import { useQuery, gql } from '@apollo/client';

const GET_USERS = gql`
  query GetUsers {
    users {
      id
      name
      email
    }
  }
`;

function UserList() {
  const { loading, error, data } = useQuery(GET_USERS);

  if (loading) return <Spinner />;
  if (error) return <Error message={error.message} />;

  return (
    <ul>
      {data.users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

### 4.2 Query with Variables
```jsx
const GET_USER = gql`
  query GetUser($id: ID!) {
    user(id: $id) {
      id
      name
      email
      posts {
        id
        title
      }
    }
  }
`;

function UserProfile({ userId }) {
  const { loading, error, data } = useQuery(GET_USER, {
    variables: { id: userId },
  });
  // ...
}
```

### 4.3 useQuery Options (Complete Reference)
```jsx
const { loading, error, data, refetch, fetchMore, networkStatus } = useQuery(QUERY, {
  variables: { id: '1' },
  
  // Fetch Policies
  fetchPolicy: 'cache-first', // default
  nextFetchPolicy: 'cache-only',
  
  // Polling
  pollInterval: 5000, // ms
  
  // Skip query conditionally
  skip: !userId,
  
  // Error handling
  errorPolicy: 'all', // 'none' | 'ignore' | 'all'
  
  // Callbacks
  onCompleted: (data) => console.log(data),
  onError: (error) => console.error(error),
  
  // Context
  context: { headers: { 'X-Custom': 'value' } },
  
  // Network status updates
  notifyOnNetworkStatusChange: true,
  
  // SSR
  ssr: true,
});
```

### 4.4 Fetch Policies

| Policy | Behavior |
|--------|----------|
| `cache-first` | Read cache ‚Üí if miss, fetch network (DEFAULT) |
| `cache-only` | Read cache only, never fetch |
| `cache-and-network` | Read cache immediately, then fetch and update |
| `network-only` | Always fetch, update cache |
| `no-cache` | Always fetch, don't cache |
| `standby` | Like cache-first but doesn't auto-update |

> **‚ö†Ô∏è INTERVIEW HIGHLIGHT:** "cache-and-network is ideal for showing stale data instantly while fetching fresh data. Great for UX!"

### 4.5 Network Status Values
```jsx
import { NetworkStatus } from '@apollo/client';

// NetworkStatus values:
// 1 = loading
// 2 = setVariables
// 3 = fetchMore
// 4 = refetch
// 6 = poll
// 7 = ready
// 8 = error
```

### 4.6 Lazy Queries
```jsx
import { useLazyQuery } from '@apollo/client';

function SearchUsers() {
  const [searchUsers, { loading, data }] = useLazyQuery(SEARCH_USERS);

  return (
    <button onClick={() => searchUsers({ variables: { term: 'john' } })}>
      Search
    </button>
  );
}
```

> **üìù IMPORTANT:** `useLazyQuery` doesn't execute on mount. Perfect for user-triggered searches.

---

## Chapter 5: Mutations with useMutation

### 5.1 Basic Mutation
```jsx
import { useMutation, gql } from '@apollo/client';

const CREATE_USER = gql`
  mutation CreateUser($input: CreateUserInput!) {
    createUser(input: $input) {
      id
      name
      email
    }
  }
`;

function CreateUserForm() {
  const [createUser, { loading, error, data }] = useMutation(CREATE_USER);

  const handleSubmit = async (formData) => {
    try {
      const result = await createUser({
        variables: { input: formData },
      });
      console.log('Created:', result.data.createUser);
    } catch (err) {
      console.error(err);
    }
  };

  return <form onSubmit={handleSubmit}>...</form>;
}
```

### 5.2 useMutation Options (Complete Reference)
```jsx
const [mutate, { loading, error, data, reset, called }] = useMutation(MUTATION, {
  variables: { input: data },
  
  // Optimistic UI
  optimisticResponse: {
    __typename: 'Mutation',
    createUser: {
      __typename: 'User',
      id: 'temp-id',
      name: 'John',
    },
  },
  
  // Cache Updates
  update: (cache, { data }) => {
    // Manual cache manipulation
  },
  
  // Refetch queries after mutation
  refetchQueries: [{ query: GET_USERS }, 'GetPosts'],
  awaitRefetchQueries: true,
  
  // Callbacks
  onCompleted: (data) => {},
  onError: (error) => {},
  
  // Error handling
  errorPolicy: 'all',
  
  // Context
  context: { headers: {} },
});
```

### 5.3 Cache Update Strategies

#### Strategy 1: Refetch Queries
```jsx
const [createUser] = useMutation(CREATE_USER, {
  refetchQueries: [
    { query: GET_USERS },
    'GetUserCount', // by operation name
  ],
});
```

#### Strategy 2: Manual Cache Update
```jsx
const [createUser] = useMutation(CREATE_USER, {
  update(cache, { data: { createUser } }) {
    cache.modify({
      fields: {
        users(existingUsers = []) {
          const newUserRef = cache.writeFragment({
            data: createUser,
            fragment: gql`
              fragment NewUser on User {
                id
                name
                email
              }
            `,
          });
          return [...existingUsers, newUserRef];
        },
      },
    });
  },
});
```

#### Strategy 3: Optimistic Response
```jsx
const [createUser] = useMutation(CREATE_USER, {
  optimisticResponse: {
    createUser: {
      __typename: 'User',
      id: `temp-${Date.now()}`,
      name: variables.input.name,
      email: variables.input.email,
    },
  },
  update(cache, { data }) {
    // Same update logic
  },
});
```

> **‚ö†Ô∏è INTERVIEW HIGHLIGHT:** "Optimistic UI shows the expected result immediately while the mutation runs. If it fails, Apollo automatically rolls back."

### 5.4 Delete Mutation with Cache Eviction
```jsx
const [deleteUser] = useMutation(DELETE_USER, {
  update(cache, { data: { deleteUser } }) {
    cache.evict({ id: cache.identify(deleteUser) });
    cache.gc(); // Garbage collect orphaned references
  },
});
```

---

## Chapter 6: Fragments

### 6.1 What are Fragments?
Reusable pieces of query logic.

```jsx
const USER_FRAGMENT = gql`
  fragment UserFields on User {
    id
    name
    email
    avatar
  }
`;

const GET_USERS = gql`
  ${USER_FRAGMENT}
  query GetUsers {
    users {
      ...UserFields
      posts {
        id
        title
      }
    }
  }
`;
```

### 6.2 Colocated Fragments Pattern
```jsx
// UserCard.jsx
export const USER_CARD_FRAGMENT = gql`
  fragment UserCard_user on User {
    id
    name
    avatar
  }
`;

export function UserCard({ user }) {
  return (
    <div>
      <img src={user.avatar} />
      <span>{user.name}</span>
    </div>
  );
}

// UserList.jsx
import { USER_CARD_FRAGMENT, UserCard } from './UserCard';

const GET_USERS = gql`
  ${USER_CARD_FRAGMENT}
  query GetUsers {
    users {
      ...UserCard_user
    }
  }
`;
```

> **üìù PRODUCTION TIP:** Colocated fragments ensure components declare their own data requirements. This prevents over-fetching and makes refactoring safer.

### 6.3 Fragment Masking (Relay-style)
With tools like GraphQL Code Generator, you can enforce that components only access data they explicitly request.

---

## Chapter 7: Subscriptions (Real-time Data)

### 7.1 WebSocket Setup
```jsx
import { GraphQLWsLink } from '@apollo/client/link/subscriptions';
import { createClient } from 'graphql-ws';
import { split, HttpLink } from '@apollo/client';
import { getMainDefinition } from '@apollo/client/utilities';

const httpLink = new HttpLink({ uri: '/graphql' });

const wsLink = new GraphQLWsLink(
  createClient({
    url: 'ws://localhost:4000/graphql',
    connectionParams: {
      authToken: localStorage.getItem('token'),
    },
  })
);

const splitLink = split(
  ({ query }) => {
    const definition = getMainDefinition(query);
    return (
      definition.kind === 'OperationDefinition' &&
      definition.operation === 'subscription'
    );
  },
  wsLink,
  httpLink
);

const client = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache(),
});
```

### 7.2 useSubscription Hook
```jsx
import { useSubscription, gql } from '@apollo/client';

const MESSAGE_SUBSCRIPTION = gql`
  subscription OnMessageAdded($channelId: ID!) {
    messageAdded(channelId: $channelId) {
      id
      content
      user {
        id
        name
      }
    }
  }
`;

function ChatRoom({ channelId }) {
  const { data, loading, error } = useSubscription(MESSAGE_SUBSCRIPTION, {
    variables: { channelId },
    onData: ({ data }) => {
      console.log('New message:', data);
    },
  });

  // ...
}
```

### 7.3 subscribeToMore Pattern
```jsx
function ChatRoom({ channelId }) {
  const { data, loading, subscribeToMore } = useQuery(GET_MESSAGES, {
    variables: { channelId },
  });

  useEffect(() => {
    const unsubscribe = subscribeToMore({
      document: MESSAGE_SUBSCRIPTION,
      variables: { channelId },
      updateQuery: (prev, { subscriptionData }) => {
        if (!subscriptionData.data) return prev;
        const newMessage = subscriptionData.data.messageAdded;
        return {
          ...prev,
          messages: [...prev.messages, newMessage],
        };
      },
    });

    return () => unsubscribe();
  }, [channelId, subscribeToMore]);

  // ...
}
```

> **‚ö†Ô∏è INTERVIEW HIGHLIGHT:** `subscribeToMore` is preferred for adding real-time updates to existing query data. It handles cache updates automatically.

---

# PART III: CACHING DEEP DIVE

---

## Chapter 8: InMemoryCache Architecture

### 8.1 Normalized Cache Structure
```jsx
// How Apollo stores data internally
{
  "ROOT_QUERY": {
    "__typename": "Query",
    "users": [
      { "__ref": "User:1" },
      { "__ref": "User:2" }
    ]
  },
  "User:1": {
    "__typename": "User",
    "id": "1",
    "name": "John",
    "email": "john@example.com"
  },
  "User:2": {
    "__typename": "User",
    "id": "2",
    "name": "Jane",
    "email": "jane@example.com"
  }
}
```

> **‚ö†Ô∏è INTERVIEW HIGHLIGHT:** "Apollo normalizes data by `__typename:id`. When any mutation updates User:1, ALL components displaying that user automatically re-render."

### 8.2 Cache Configuration
```jsx
const cache = new InMemoryCache({
  typePolicies: {
    User: {
      keyFields: ['id'], // default
    },
    
    // For types without id
    Address: {
      keyFields: ['street', 'city', 'country'],
    },
    
    // Singleton types
    CurrentUser: {
      keyFields: [], // stored at root
    },
    
    // Custom merge behavior
    Query: {
      fields: {
        users: {
          merge(existing = [], incoming) {
            return [...existing, ...incoming];
          },
        },
      },
    },
  },
});
```

### 8.3 Field Policies
```jsx
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        // Read-only computed field
        userCount: {
          read(_, { readField }) {
            const users = readField('users') || [];
            return users.length;
          },
        },
        
        // Pagination
        feed: {
          keyArgs: ['type'], // cache separately by 'type' arg
          merge(existing = [], incoming, { args }) {
            const merged = existing.slice(0);
            const offset = args?.offset ?? 0;
            for (let i = 0; i < incoming.length; i++) {
              merged[offset + i] = incoming[i];
            }
            return merged;
          },
        },
      },
    },
    
    User: {
      fields: {
        // Format field on read
        fullName: {
          read(_, { readField }) {
            return `${readField('firstName')} ${readField('lastName')}`;
          },
        },
      },
    },
  },
});
```

### 8.4 Cache Direct Manipulation

#### Reading from Cache
```jsx
// Read a query
const data = client.readQuery({
  query: GET_USERS,
  variables: { status: 'active' },
});

// Read a fragment
const user = client.readFragment({
  id: 'User:1',
  fragment: USER_FRAGMENT,
});
```

#### Writing to Cache
```jsx
// Write a query
client.writeQuery({
  query: GET_USERS,
  data: { users: [...] },
});

// Write a fragment
client.writeFragment({
  id: 'User:1',
  fragment: USER_FRAGMENT,
  data: { name: 'Updated Name' },
});
```

#### Cache Modify (Most Performant)
```jsx
cache.modify({
  id: cache.identify(user),
  fields: {
    name: () => 'New Name',
    posts: (existing, { readField }) => {
      return existing.filter(ref => readField('id', ref) !== deletedId);
    },
  },
});
```

### 8.5 Cache Eviction
```jsx
// Evict specific object
cache.evict({ id: 'User:1' });

// Evict specific field
cache.evict({ id: 'User:1', fieldName: 'posts' });

// Garbage collect unreachable objects
cache.gc();

// Reset entire cache
client.resetStore(); // refetches active queries
client.clearStore(); // doesn't refetch
```

> **üìù PRODUCTION TIP:** Always call `cache.gc()` after eviction to clean up orphaned references.

---

## Chapter 9: Pagination

### 9.1 Offset-based Pagination
```jsx
const GET_POSTS = gql`
  query GetPosts($offset: Int!, $limit: Int!) {
    posts(offset: $offset, limit: $limit) {
      id
      title
    }
  }
`;

function PostList() {
  const { data, loading, fetchMore } = useQuery(GET_POSTS, {
    variables: { offset: 0, limit: 10 },
  });

  const loadMore = () => {
    fetchMore({
      variables: { offset: data.posts.length },
    });
  };

  return (
    <>
      {data?.posts.map(post => <PostCard key={post.id} post={post} />)}
      <button onClick={loadMore}>Load More</button>
    </>
  );
}
```

### 9.2 Cursor-based Pagination (Relay Style)
```jsx
const GET_POSTS = gql`
  query GetPosts($first: Int!, $after: String) {
    postsConnection(first: $first, after: $after) {
      edges {
        cursor
        node {
          id
          title
        }
      }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
`;

// Cache configuration for Relay-style
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        postsConnection: relayStylePagination(),
      },
    },
  },
});
```

### 9.3 Custom Merge for Pagination
```jsx
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        posts: {
          keyArgs: ['category'], // separate cache by category
          merge(existing = [], incoming, { args }) {
            if (args?.offset === 0) {
              return incoming; // Reset on first page
            }
            return [...existing, ...incoming];
          },
        },
      },
    },
  },
});
```

> **‚ö†Ô∏è INTERVIEW HIGHLIGHT:** "Cursor-based pagination is more reliable than offset-based when data changes frequently. Use `relayStylePagination()` helper for standard Relay connections."

---

# PART IV: ADVANCED PATTERNS

---

## Chapter 10: Error Handling Strategies

### 10.1 Error Types in GraphQL
```
1. Network Errors - No connection, 500 errors
2. GraphQL Errors - Validation, resolver errors
3. Partial Data - Some fields succeed, some fail
```

### 10.2 Error Policies
```jsx
const { data, error } = useQuery(QUERY, {
  errorPolicy: 'all', // 'none' | 'ignore' | 'all'
});

// errorPolicy: 'none' (default)
//   - data = undefined on any error
//   - error contains first error

// errorPolicy: 'ignore'
//   - data = partial data
//   - error = undefined (errors ignored)

// errorPolicy: 'all'
//   - data = partial data
//   - error = all errors
```

### 10.3 Global Error Handling
```jsx
import { onError } from '@apollo/client/link/error';

const errorLink = onError(({ graphQLErrors, networkError, operation, forward }) => {
  if (graphQLErrors) {
    for (const err of graphQLErrors) {
      switch (err.extensions?.code) {
        case 'UNAUTHENTICATED':
          // Refresh token and retry
          return fromPromise(refreshToken()).flatMap(() => forward(operation));
        case 'FORBIDDEN':
          redirectToLogin();
          break;
        default:
          logError(err);
      }
    }
  }

  if (networkError) {
    if (networkError.statusCode === 503) {
      showMaintenanceMessage();
    }
  }
});
```

### 10.4 Component-Level Error Boundaries
```jsx
import { useQuery } from '@apollo/client';

function UserProfile({ id }) {
  const { data, error, loading } = useQuery(GET_USER, {
    variables: { id },
    errorPolicy: 'all',
  });

  if (error?.graphQLErrors?.some(e => e.extensions?.code === 'NOT_FOUND')) {
    return <UserNotFound />;
  }

  if (error?.networkError) {
    return <NetworkError retry={() => refetch()} />;
  }

  // Render with partial data
  return <Profile user={data?.user} errors={error?.graphQLErrors} />;
}
```

### 10.5 Retry Logic
```jsx
import { RetryLink } from '@apollo/client/link/retry';

const retryLink = new RetryLink({
  delay: {
    initial: 300,
    max: 3000,
    jitter: true,
  },
  attempts: {
    max: 5,
    retryIf: (error, operation) => {
      // Don't retry mutations
      const isMutation = operation.query.definitions.some(
        d => d.kind === 'OperationDefinition' && d.operation === 'mutation'
      );
      return !!error && !isMutation;
    },
  },
});
```

---

## Chapter 11: Performance Optimization

### 11.1 Query Optimization Techniques

#### Avoid Re-renders with useMemo
```jsx
function UserList() {
  const { data } = useQuery(GET_USERS);
  
  // Memoize filtered results
  const activeUsers = useMemo(
    () => data?.users?.filter(u => u.isActive) ?? [],
    [data?.users]
  );

  return activeUsers.map(u => <UserCard key={u.id} user={u} />);
}
```

#### Selective Re-rendering with useFragment
```jsx
import { useFragment } from '@apollo/client';

function UserAvatar({ userId }) {
  const { data } = useFragment({
    fragment: gql`
      fragment UserAvatar on User {
        id
        avatar
      }
    `,
    from: { __typename: 'User', id: userId },
  });

  return <img src={data.avatar} />;
}
```

### 11.2 Persisted Queries (APQ)
```jsx
import { createPersistedQueryLink } from '@apollo/client/link/persisted-queries';
import { sha256 } from 'crypto-hash';

const persistedQueriesLink = createPersistedQueryLink({
  sha256,
  useGETForHashedQueries: true,
});

const client = new ApolloClient({
  link: from([persistedQueriesLink, httpLink]),
  cache: new InMemoryCache(),
});
```

> **üìù PRODUCTION TIP:** APQ reduces bandwidth by sending query hashes instead of full query strings. First request sends both, subsequent requests only send hash.

### 11.3 @defer and @stream (Experimental)
```graphql
query GetUser($id: ID!) {
  user(id: $id) {
    id
    name
    # Defer expensive fields
    ... @defer {
      posts {
        id
        title
        comments {
          id
          content
        }
      }
    }
  }
}
```

### 11.4 Batch Requests
```jsx
import { BatchHttpLink } from '@apollo/client/link/batch-http';

const batchLink = new BatchHttpLink({
  uri: '/graphql',
  batchMax: 10, // Max operations per batch
  batchInterval: 20, // Wait time in ms
});
```

### 11.5 Prefetching
```jsx
function UserListItem({ user }) {
  const client = useApolloClient();

  const prefetchUser = () => {
    client.query({
      query: GET_USER_DETAILS,
      variables: { id: user.id },
    });
  };

  return (
    <Link 
      to={`/users/${user.id}`}
      onMouseEnter={prefetchUser}
    >
      {user.name}
    </Link>
  );
}
```

---

## Chapter 12: Code Organization & Architecture

### 12.1 Folder Structure
```
src/
‚îú‚îÄ‚îÄ graphql/
‚îÇ   ‚îú‚îÄ‚îÄ client.ts           # Apollo Client setup
‚îÇ   ‚îú‚îÄ‚îÄ fragments/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ post.ts
‚îÇ   ‚îú‚îÄ‚îÄ queries/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ post.ts
‚îÇ   ‚îú‚îÄ‚îÄ mutations/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ post.ts
‚îÇ   ‚îú‚îÄ‚îÄ subscriptions/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ messages.ts
‚îÇ   ‚îî‚îÄ‚îÄ types/              # Generated types
‚îÇ       ‚îî‚îÄ‚îÄ graphql.ts
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îú‚îÄ‚îÄ useUser.ts          # Custom hooks wrapping queries
‚îÇ   ‚îî‚îÄ‚îÄ useCreatePost.ts
‚îî‚îÄ‚îÄ components/
    ‚îî‚îÄ‚îÄ UserCard/
        ‚îú‚îÄ‚îÄ UserCard.tsx
        ‚îú‚îÄ‚îÄ UserCard.fragment.ts  # Colocated fragment
        ‚îî‚îÄ‚îÄ index.ts
```

### 12.2 Custom Hooks Pattern
```jsx
// hooks/useUser.ts
export function useUser(id: string) {
  const { data, loading, error, refetch } = useQuery(GET_USER, {
    variables: { id },
    skip: !id,
  });

  return {
    user: data?.user ?? null,
    loading,
    error,
    refetch,
    isFound: !!data?.user,
  };
}

// hooks/useCreateUser.ts
export function useCreateUser() {
  const [createUser, { loading, error }] = useMutation(CREATE_USER, {
    refetchQueries: [{ query: GET_USERS }],
  });

  const create = async (input: CreateUserInput) => {
    const result = await createUser({ variables: { input } });
    return result.data?.createUser;
  };

  return { create, loading, error };
}
```

### 12.3 GraphQL Code Generator Setup
```yaml
# codegen.yml
schema: 'http://localhost:4000/graphql'
documents: 'src/**/*.{ts,tsx}'
generates:
  src/graphql/types/graphql.ts:
    plugins:
      - typescript
      - typescript-operations
      - typescript-react-apollo
    config:
      withHooks: true
      withComponent: false
      withHOC: false
```

```bash
npm install -D @graphql-codegen/cli @graphql-codegen/typescript \
  @graphql-codegen/typescript-operations @graphql-codegen/typescript-react-apollo
```

> **‚ö†Ô∏è INTERVIEW HIGHLIGHT:** "GraphQL Code Generator provides end-to-end type safety. Types are generated from your schema, and hooks are typed to match your queries."

---

## Chapter 13: Testing GraphQL React Apps

### 13.1 MockedProvider
```jsx
import { MockedProvider } from '@apollo/client/testing';
import { render, screen, waitFor } from '@testing-library/react';

const mocks = [
  {
    request: {
      query: GET_USER,
      variables: { id: '1' },
    },
    result: {
      data: {
        user: {
          id: '1',
          name: 'John Doe',
          email: 'john@example.com',
        },
      },
    },
  },
];

test('renders user profile', async () => {
  render(
    <MockedProvider mocks={mocks} addTypename={false}>
      <UserProfile userId="1" />
    </MockedProvider>
  );

  expect(screen.getByText('Loading...')).toBeInTheDocument();

  await waitFor(() => {
    expect(screen.getByText('John Doe')).toBeInTheDocument();
  });
});
```

### 13.2 Testing Mutations
```jsx
const createUserMock = {
  request: {
    query: CREATE_USER,
    variables: { input: { name: 'Jane', email: 'jane@test.com' } },
  },
  result: {
    data: {
      createUser: {
        id: '2',
        name: 'Jane',
        email: 'jane@test.com',
      },
    },
  },
};

test('creates a user', async () => {
  const { user } = render(
    <MockedProvider mocks={[createUserMock]}>
      <CreateUserForm />
    </MockedProvider>
  );

  await user.type(screen.getByLabelText('Name'), 'Jane');
  await user.type(screen.getByLabelText('Email'), 'jane@test.com');
  await user.click(screen.getByRole('button', { name: 'Submit' }));

  await waitFor(() => {
    expect(screen.getByText('User created!')).toBeInTheDocument();
  });
});
```

### 13.3 Testing Error States
```jsx
const errorMock = {
  request: { query: GET_USER, variables: { id: '1' } },
  error: new Error('Network error'),
};

const graphqlErrorMock = {
  request: { query: GET_USER, variables: { id: '999' } },
  result: {
    errors: [{ message: 'User not found' }],
  },
};

test('handles network error', async () => {
  render(
    <MockedProvider mocks={[errorMock]}>
      <UserProfile userId="1" />
    </MockedProvider>
  );

  await waitFor(() => {
    expect(screen.getByText('Something went wrong')).toBeInTheDocument();
  });
});
```

### 13.4 Testing with Cache
```jsx
const cache = new InMemoryCache();

cache.writeQuery({
  query: GET_USERS,
  data: { users: [{ id: '1', name: 'Cached User' }] },
});

render(
  <MockedProvider cache={cache}>
    <UserList />
  </MockedProvider>
);

// Will render cached data immediately
expect(screen.getByText('Cached User')).toBeInTheDocument();
```

---

# PART V: PRODUCTION CONSIDERATIONS

---

## Chapter 14: Security Best Practices

### 14.1 Query Complexity & Depth Limiting
Configure on server, but understand from frontend:
```graphql
# This deeply nested query should be rejected
query DangerousQuery {
  users {
    posts {
      comments {
        author {
          posts {
            comments {
              # ... infinite nesting
            }
          }
        }
      }
    }
  }
}
```

### 14.2 Sensitive Data Handling
```jsx
// Never log full queries in production
const errorLink = onError(({ graphQLErrors, operation }) => {
  if (process.env.NODE_ENV === 'production') {
    // Only log operation name, not variables
    logError({
      operation: operation.operationName,
      // Never log: operation.variables (may contain passwords)
    });
  }
});
```

### 14.3 Token Refresh Flow
```jsx
import { fromPromise } from '@apollo/client';

let isRefreshing = false;
let pendingRequests: (() => void)[] = [];

const errorLink = onError(({ graphQLErrors, operation, forward }) => {
  if (graphQLErrors?.some(e => e.extensions?.code === 'UNAUTHENTICATED')) {
    if (!isRefreshing) {
      isRefreshing = true;
      
      return fromPromise(
        refreshToken()
          .then(newToken => {
            localStorage.setItem('token', newToken);
            pendingRequests.forEach(cb => cb());
            pendingRequests = [];
            return newToken;
          })
          .finally(() => {
            isRefreshing = false;
          })
      ).flatMap(() => forward(operation));
    }
    
    return fromPromise(
      new Promise(resolve => {
        pendingRequests.push(() => resolve(undefined));
      })
    ).flatMap(() => forward(operation));
  }
});
```

---

## Chapter 15: Server-Side Rendering (SSR)

### 15.1 Next.js with Apollo
```jsx
// lib/apollo-client.ts
import { ApolloClient, InMemoryCache, HttpLink } from '@apollo/client';

export function createApolloClient() {
  return new ApolloClient({
    ssrMode: typeof window === 'undefined',
    link: new HttpLink({
      uri: process.env.GRAPHQL_URL,
      credentials: 'same-origin',
    }),
    cache: new InMemoryCache(),
  });
}
```

### 15.2 getServerSideProps Pattern
```jsx
// pages/users/[id].tsx
export async function getServerSideProps(context) {
  const client = createApolloClient();

  const { data } = await client.query({
    query: GET_USER,
    variables: { id: context.params.id },
  });

  return {
    props: {
      initialApolloState: client.cache.extract(),
      user: data.user,
    },
  };
}

function UserPage({ user }) {
  return <UserProfile user={user} />;
}
```

### 15.3 App Router (Next.js 13+) with RSC
```jsx
// app/users/[id]/page.tsx
import { getClient } from '@/lib/apollo-rsc-client';

export default async function UserPage({ params }) {
  const client = getClient();
  
  const { data } = await client.query({
    query: GET_USER,
    variables: { id: params.id },
  });

  return <UserProfile user={data.user} />;
}
```

---

## Chapter 16: Monitoring & Observability

### 16.1 Apollo Studio Integration
```jsx
import { ApolloClient, InMemoryCache } from '@apollo/client';

const client = new ApolloClient({
  uri: 'https://api.example.com/graphql',
  cache: new InMemoryCache(),
  connectToDevTools: process.env.NODE_ENV === 'development',
});
```

### 16.2 Custom Performance Tracking
```jsx
import { ApolloLink } from '@apollo/client';

const performanceLink = new ApolloLink((operation, forward) => {
  const startTime = performance.now();
  
  return forward(operation).map(response => {
    const duration = performance.now() - startTime;
    
    // Send to analytics
    analytics.track('graphql_query', {
      operationName: operation.operationName,
      duration,
      variables: operation.variables,
    });
    
    return response;
  });
});
```

### 16.3 Error Tracking Integration
```jsx
const errorLink = onError(({ graphQLErrors, networkError, operation }) => {
  if (graphQLErrors) {
    graphQLErrors.forEach(error => {
      Sentry.captureException(error, {
        extra: {
          operationName: operation.operationName,
          variables: operation.variables,
        },
      });
    });
  }

  if (networkError) {
    Sentry.captureException(networkError);
  }
});
```

---

# PART VI: INTERVIEW PREPARATION

---

## Chapter 17: Common Interview Questions

### 17.1 Conceptual Questions

**Q: What is the difference between REST and GraphQL?**
> GraphQL provides a single endpoint, strongly-typed schema, exact data fetching (no over/under-fetching), and built-in introspection. REST has multiple endpoints, no built-in type system, and often requires multiple requests.

**Q: Explain Apollo Client's caching mechanism.**
> Apollo uses a normalized cache storing objects by `__typename:id`. When data changes, all components using that data re-render automatically. This enables optimistic UI and efficient updates.

**Q: What are the different fetch policies and when would you use each?**
> - `cache-first`: Default, good for mostly static data
> - `cache-and-network`: Show cached data instantly while fetching fresh data
> - `network-only`: Always fresh data, still caches
> - `no-cache`: Real-time data that shouldn't be cached
> - `cache-only`: Offline mode

**Q: How do you handle authentication in Apollo Client?**
> Use an auth link in the link chain that adds Bearer token to headers. For token refresh, use error link to catch UNAUTHENTICATED errors and retry with new token.

**Q: Explain optimistic UI and its benefits.**
> Show expected result immediately while mutation runs. Improves perceived performance. Apollo auto-rollback if mutation fails.

### 17.2 Code Challenge Topics

1. **Implement infinite scroll with fetchMore**
2. **Build a real-time chat with subscriptions**
3. **Create optimistic UI for a todo list**
4. **Implement search with debounce and lazy query**
5. **Handle token refresh with retry logic**
6. **Configure pagination with custom merge**

### 17.3 System Design Questions

**Q: Design a real-time collaborative document editor with GraphQL.**
> - Use subscriptions for real-time updates
> - Implement optimistic UI for instant feedback
> - Use cursor-based pagination for document history
> - Handle conflicts with operational transforms
> - Cache document fragments for performance

**Q: How would you optimize a slow dashboard loading many queries?**
> - Batch queries where possible
> - Use fragments for shared data
> - Implement `@defer` for non-critical data
> - Prefetch on hover/route transition
> - Use `cache-and-network` for instant perceived load

---

## Chapter 18: Quick Reference Cheat Sheet

### Hooks
```
useQuery       - Fetch data on mount
useLazyQuery   - Fetch data on trigger
useMutation    - Modify data
useSubscription - Real-time updates
useApolloClient - Access client directly
useFragment    - Read fragment from cache
```

### Fetch Policies
```
cache-first        - Cache ‚Üí Network (default)
cache-only         - Cache only
cache-and-network  - Cache + Network
network-only       - Network, cache result
no-cache           - Network, no cache
```

### Error Policies
```
none   - Return undefined data on error (default)
ignore - Return partial data, ignore errors
all    - Return partial data + all errors
```

### Cache Methods
```
readQuery    - Read query from cache
writeQuery   - Write query to cache
readFragment - Read fragment from cache
writeFragment- Write fragment to cache
modify       - Modify cached fields
evict        - Remove from cache
gc           - Garbage collect
```

### Common Link Chain Order
```
errorLink ‚Üí authLink ‚Üí retryLink ‚Üí batchLink ‚Üí httpLink
                                              ‚Ü≥ wsLink (via split)
```

---

## Final Notes

> **üéØ KEY INTERVIEW TIPS:**
> 1. Always explain the "why" behind your choices
> 2. Discuss trade-offs (e.g., refetchQueries vs cache.modify)
> 3. Mention production concerns (error handling, monitoring)
> 4. Know the difference between cache-first and cache-and-network
> 5. Understand normalized caching deeply
> 6. Be ready to whiteboard optimistic UI flow
> 7. Discuss type safety with GraphQL Code Generator

> **üìö RESOURCES:**
> - Apollo Client Documentation: https://apollographql.com/docs/react/
> - GraphQL Specification: https://spec.graphql.org/
> - GraphQL Code Generator: https://graphql-code-generator.com/
> - Apollo Studio: https://studio.apollographql.com/
