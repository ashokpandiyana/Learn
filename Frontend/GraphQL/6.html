<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 6: Fragments</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #134e4a 100%);
      color: #e4e4e7;
      line-height: 1.7;
      padding: 40px 20px;
      min-height: 100vh;
    }
    .container { max-width: 950px; margin: 0 auto; }
    h1 {
      font-size: 2.5rem;
      background: linear-gradient(90deg, #14b8a6, #22d3ee);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 10px;
    }
    .subtitle { color: #a1a1aa; font-size: 1.1rem; margin-bottom: 40px; }
    h2 {
      color: #14b8a6;
      font-size: 1.6rem;
      margin: 40px 0 20px;
      padding-bottom: 10px;
      border-bottom: 2px solid #3f3f46;
    }
    h3 { color: #2dd4bf; font-size: 1.2rem; margin: 25px 0 15px; }
    h4 { color: #5eead4; font-size: 1rem; margin: 20px 0 10px; }
    p { margin-bottom: 15px; color: #d4d4d8; }
    .highlight-box {
      background: linear-gradient(135deg, #134e4a 0%, #0f2e2c 100%);
      border-left: 4px solid #14b8a6;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .warning-box {
      background: linear-gradient(135deg, #78350f 0%, #451a03 100%);
      border-left: 4px solid #f59e0b;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .warning-box::before { content: "âš ï¸ INTERVIEW HIGHLIGHT: "; font-weight: bold; color: #fbbf24; }
    .tip-box {
      background: linear-gradient(135deg, #1e3a8a 0%, #1e1b4b 100%);
      border-left: 4px solid #3b82f6;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .tip-box::before { content: "ğŸ“ PRODUCTION TIP: "; font-weight: bold; color: #60a5fa; }
    .concept-box {
      background: linear-gradient(135deg, #4c1d95 0%, #2e1065 100%);
      border-left: 4px solid #a78bfa;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .concept-box::before { content: "ğŸ’¡ KEY CONCEPT: "; font-weight: bold; color: #c4b5fd; }
    .best-practice {
      background: linear-gradient(135deg, #065f46 0%, #022c22 100%);
      border-left: 4px solid #10b981;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .best-practice::before { content: "âœ… BEST PRACTICE: "; font-weight: bold; color: #34d399; }
    pre {
      background: #0a0a15;
      border: 1px solid #3f3f46;
      border-radius: 12px;
      padding: 20px;
      overflow-x: auto;
      margin: 15px 0;
      font-size: 0.88rem;
    }
    code { font-family: 'Fira Code', 'Consolas', monospace; }
    .inline-code {
      background: #3f3f46;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.85rem;
    }
    .keyword { color: #c084fc; }
    .type { color: #38bdf8; }
    .string { color: #4ade80; }
    .comment { color: #6b7280; font-style: italic; }
    .field { color: #fbbf24; }
    .function { color: #f472b6; }
    .const { color: #fb923c; }
    .param { color: #67e8f9; }
    .fragment { color: #2dd4bf; }
    .diagram {
      background: #0a0a15;
      border-radius: 12px;
      padding: 30px;
      margin: 20px 0;
      text-align: center;
      overflow-x: auto;
    }
    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      background: #1e293b;
      border-radius: 12px;
      overflow: hidden;
      font-size: 0.9rem;
    }
    .comparison-table th {
      background: linear-gradient(90deg, #0f766e, #0891b2);
      padding: 14px;
      text-align: left;
      font-weight: 600;
    }
    .comparison-table td {
      padding: 12px 14px;
      border-bottom: 1px solid #334155;
    }
    .comparison-table tr:last-child td { border-bottom: none; }
    .comparison-table code { background: #374151; padding: 2px 6px; border-radius: 4px; font-size: 0.8rem; }
    ul, ol { margin: 15px 0 15px 25px; }
    li { margin: 8px 0; color: #d4d4d8; }
    .chapter-nav {
      display: flex;
      justify-content: space-between;
      margin-top: 50px;
      padding-top: 30px;
      border-top: 1px solid #3f3f46;
    }
    .nav-btn {
      padding: 12px 24px;
      background: linear-gradient(90deg, #0f766e, #0891b2);
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }
    .file-structure {
      background: #1f2937;
      border-radius: 10px;
      padding: 20px;
      margin: 15px 0;
      font-family: monospace;
      font-size: 0.9rem;
    }
    .file-structure .folder { color: #fbbf24; }
    .file-structure .file { color: #94a3b8; }
    .file-structure .highlight { color: #2dd4bf; }
    .pattern-card {
      background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
      border: 1px solid #374151;
      border-radius: 12px;
      padding: 20px;
      margin: 15px 0;
    }
    .pattern-card h4 {
      color: #14b8a6;
      margin: 0 0 10px 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .badge {
      display: inline-block;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 0.7rem;
      font-weight: 600;
    }
    .badge-essential { background: #dc2626; color: white; }
    .badge-recommended { background: #059669; color: white; }
    .badge-advanced { background: #7c3aed; color: white; }
    .vs-container {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 15px;
      align-items: start;
      margin: 20px 0;
    }
    .vs-box {
      background: #1f2937;
      border-radius: 10px;
      padding: 15px;
    }
    .vs-divider {
      display: flex;
      align-items: center;
      font-size: 1.5rem;
      color: #6b7280;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Chapter 6</h1>
    <p class="subtitle">Fragments â€” Reusable Pieces of GraphQL Queries</p>

    <!-- Section 6.1 -->
    <h2>6.1 What Are Fragments?</h2>
    
    <p>Fragments are reusable units of GraphQL query logic. They let you define a set of fields once and include them in multiple queries, mutations, or other fragments.</p>

    <div class="highlight-box">
      <strong>Why Use Fragments?</strong>
      <ul style="margin-top: 10px;">
        <li><strong>DRY (Don't Repeat Yourself):</strong> Define fields once, use everywhere</li>
        <li><strong>Consistency:</strong> Same fields across all queries using the fragment</li>
        <li><strong>Maintainability:</strong> Update fields in one place, applies everywhere</li>
        <li><strong>Component-Query Colocation:</strong> Components can declare their own data needs</li>
        <li><strong>Type Safety:</strong> Fragments are type-checked against your schema</li>
      </ul>
    </div>

    <h3>Basic Fragment Syntax</h3>

    <pre><code><span class="comment">// Define a fragment</span>
<span class="keyword">fragment</span> <span class="fragment">UserFields</span> <span class="keyword">on</span> <span class="type">User</span> {
  <span class="field">id</span>
  <span class="field">name</span>
  <span class="field">email</span>
  <span class="field">avatar</span>
}

<span class="comment">// Use it in a query with spread operator (...)</span>
<span class="keyword">query</span> <span class="type">GetUsers</span> {
  <span class="field">users</span> {
    <span class="fragment">...UserFields</span>
  }
}

<span class="comment">// Use in another query</span>
<span class="keyword">query</span> <span class="type">GetCurrentUser</span> {
  <span class="field">me</span> {
    <span class="fragment">...UserFields</span>
    <span class="field">role</span>
    <span class="field">settings</span> {
      <span class="field">theme</span>
      <span class="field">notifications</span>
    }
  }
}</code></pre>

    <div class="concept-box">
      The <code class="inline-code">on Type</code> syntax specifies which GraphQL type the fragment applies to. This enables type checking â€” you can only spread <code class="inline-code">UserFields</code> on a field that returns a <code class="inline-code">User</code> type.
    </div>

    <!-- Section 6.2 -->
    <h2>6.2 Fragments in Apollo Client</h2>

    <p>In Apollo Client, you define fragments using the <code class="inline-code">gql</code> tag and include them in your queries using template literal interpolation.</p>

    <pre><code><span class="keyword">import</span> { <span class="type">gql</span> } <span class="keyword">from</span> <span class="string">'@apollo/client'</span>;

<span class="comment">// Define the fragment</span>
<span class="keyword">const</span> <span class="const">USER_FIELDS</span> = <span class="function">gql</span><span class="string">`
  fragment UserFields on User {
    id
    name
    email
    avatar
    createdAt
  }
`</span>;

<span class="comment">// Include in a query using template literal interpolation</span>
<span class="keyword">const</span> <span class="const">GET_USERS</span> = <span class="function">gql</span><span class="string">`
  </span>${<span class="const">USER_FIELDS</span>}<span class="string">
  query GetUsers {
    users {
      ...UserFields
      posts {
        id
        title
      }
    }
  }
`</span>;

<span class="comment">// Use the same fragment in another query</span>
<span class="keyword">const</span> <span class="const">GET_USER_BY_ID</span> = <span class="function">gql</span><span class="string">`
  </span>${<span class="const">USER_FIELDS</span>}<span class="string">
  query GetUser($id: ID!) {
    user(id: $id) {
      ...UserFields
      followers {
        ...UserFields
      }
    }
  }
`</span>;</code></pre>

    <div class="warning-box">
      You MUST include the fragment definition in the query document (via interpolation). Just spreading <code class="inline-code">...UserFields</code> without including the fragment definition will cause a GraphQL error.
    </div>

    <!-- Section 6.3 -->
    <h2>6.3 Nested Fragments</h2>

    <p>Fragments can include other fragments, enabling you to compose complex data requirements from smaller, reusable pieces.</p>

    <pre><code><span class="comment">// Base user fragment</span>
<span class="keyword">const</span> <span class="const">USER_BASIC</span> = <span class="function">gql</span><span class="string">`
  fragment UserBasic on User {
    id
    name
    avatar
  }
`</span>;

<span class="comment">// Extended user fragment that includes UserBasic</span>
<span class="keyword">const</span> <span class="const">USER_WITH_STATS</span> = <span class="function">gql</span><span class="string">`
  </span>${<span class="const">USER_BASIC</span>}<span class="string">
  fragment UserWithStats on User {
    ...UserBasic
    followersCount
    postsCount
    likesReceived
  }
`</span>;

<span class="comment">// Post fragment that uses user fragment</span>
<span class="keyword">const</span> <span class="const">POST_WITH_AUTHOR</span> = <span class="function">gql</span><span class="string">`
  </span>${<span class="const">USER_BASIC</span>}<span class="string">
  fragment PostWithAuthor on Post {
    id
    title
    content
    createdAt
    author {
      ...UserBasic
    }
  }
`</span>;

<span class="comment">// Query using nested fragments</span>
<span class="keyword">const</span> <span class="const">GET_FEED</span> = <span class="function">gql</span><span class="string">`
  </span>${<span class="const">POST_WITH_AUTHOR</span>}<span class="string">
  </span>${<span class="const">USER_WITH_STATS</span>}<span class="string">
  query GetFeed {
    feed {
      ...PostWithAuthor
      likedBy {
        ...UserWithStats
      }
    }
  }
`</span>;</code></pre>

    <div class="diagram">
      <svg viewBox="0 0 700 280" xmlns="http://www.w3.org/2000/svg">
        <text x="350" y="25" fill="#e4e4e7" font-size="16" font-weight="bold" text-anchor="middle">Fragment Composition</text>
        
        <!-- UserBasic (root) -->
        <rect x="280" y="50" width="140" height="50" rx="8" fill="#0f766e"/>
        <text x="350" y="80" fill="white" font-size="12" text-anchor="middle">UserBasic</text>
        
        <!-- Arrows down -->
        <line x1="320" y1="100" x2="200" y2="140" stroke="#6b7280" stroke-width="2"/>
        <line x1="380" y1="100" x2="500" y2="140" stroke="#6b7280" stroke-width="2"/>
        
        <!-- UserWithStats -->
        <rect x="100" y="140" width="160" height="50" rx="8" fill="#1e40af"/>
        <text x="180" y="170" fill="white" font-size="11" text-anchor="middle">UserWithStats</text>
        <text x="180" y="183" fill="#94a3b8" font-size="9" text-anchor="middle">...UserBasic + stats</text>
        
        <!-- PostWithAuthor -->
        <rect x="440" y="140" width="160" height="50" rx="8" fill="#7c2d12"/>
        <text x="520" y="170" fill="white" font-size="11" text-anchor="middle">PostWithAuthor</text>
        <text x="520" y="183" fill="#94a3b8" font-size="9" text-anchor="middle">...UserBasic in author</text>
        
        <!-- Final Query -->
        <line x1="180" y1="190" x2="280" y2="230" stroke="#6b7280" stroke-width="2"/>
        <line x1="520" y1="190" x2="420" y2="230" stroke="#6b7280" stroke-width="2"/>
        
        <rect x="250" y="230" width="200" height="40" rx="8" fill="#4c1d95"/>
        <text x="350" y="255" fill="white" font-size="12" text-anchor="middle">GET_FEED Query</text>
      </svg>
    </div>

    <!-- Section 6.4 -->
    <h2>6.4 Colocated Fragments Pattern â€” Production Standard</h2>

    <p>The colocated fragments pattern is the recommended approach for production React applications. Each component defines its own fragment declaring exactly what data it needs.</p>

    <div class="pattern-card">
      <h4><span class="badge badge-recommended">RECOMMENDED</span> Component-Fragment Colocation</h4>
      <p>Components define fragments next to where they're used. This creates a clear contract between components and their data requirements.</p>
    </div>

    <h3>File Structure</h3>

    <div class="file-structure">
      <span class="folder">src/</span><br>
      <span class="folder">â”œâ”€â”€ components/</span><br>
      <span class="folder">â”‚   â”œâ”€â”€ UserCard/</span><br>
      <span class="file">â”‚   â”‚   â”œâ”€â”€ UserCard.tsx</span><br>
      <span class="highlight">â”‚   â”‚   â”œâ”€â”€ UserCard.fragment.ts</span> â† Fragment definition<br>
      <span class="file">â”‚   â”‚   â””â”€â”€ index.ts</span><br>
      <span class="folder">â”‚   â”œâ”€â”€ PostCard/</span><br>
      <span class="file">â”‚   â”‚   â”œâ”€â”€ PostCard.tsx</span><br>
      <span class="highlight">â”‚   â”‚   â”œâ”€â”€ PostCard.fragment.ts</span><br>
      <span class="file">â”‚   â”‚   â””â”€â”€ index.ts</span><br>
      <span class="folder">â”‚   â””â”€â”€ CommentItem/</span><br>
      <span class="file">â”‚       â”œâ”€â”€ CommentItem.tsx</span><br>
      <span class="highlight">â”‚       â”œâ”€â”€ CommentItem.fragment.ts</span><br>
      <span class="file">â”‚       â””â”€â”€ index.ts</span><br>
      <span class="folder">â””â”€â”€ graphql/</span><br>
      <span class="folder">    â””â”€â”€ queries/</span><br>
      <span class="file">        â””â”€â”€ posts.ts</span> â† Composes fragments into queries
    </div>

    <h3>Implementation Example</h3>

    <pre><code><span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
<span class="comment">// components/UserCard/UserCard.fragment.ts</span>
<span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
<span class="keyword">import</span> { <span class="type">gql</span> } <span class="keyword">from</span> <span class="string">'@apollo/client'</span>;

<span class="comment">// Naming convention: ComponentName_typeName</span>
<span class="keyword">export const</span> <span class="const">USER_CARD_FRAGMENT</span> = <span class="function">gql</span><span class="string">`
  fragment UserCard_user on User {
    id
    name
    avatar
    bio
  }
`</span>;

<span class="comment">// TypeScript type for the fragment data</span>
<span class="keyword">export interface</span> <span class="type">UserCardFragment</span> {
  <span class="field">id</span>: <span class="type">string</span>;
  <span class="field">name</span>: <span class="type">string</span>;
  <span class="field">avatar</span>: <span class="type">string</span>;
  <span class="field">bio</span>: <span class="type">string</span> | <span class="keyword">null</span>;
}</code></pre>

    <pre><code><span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
<span class="comment">// components/UserCard/UserCard.tsx</span>
<span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
<span class="keyword">import</span> { <span class="type">UserCardFragment</span> } <span class="keyword">from</span> <span class="string">'./UserCard.fragment'</span>;

<span class="keyword">interface</span> <span class="type">Props</span> {
  <span class="field">user</span>: <span class="type">UserCardFragment</span>;
}

<span class="keyword">export function</span> <span class="function">UserCard</span>({ <span class="param">user</span> }: <span class="type">Props</span>) {
  <span class="keyword">return</span> (
    <span class="keyword">&lt;</span>div className=<span class="string">"user-card"</span><span class="keyword">&gt;</span>
      <span class="keyword">&lt;</span>img <span class="field">src</span>={user.avatar} <span class="field">alt</span>={user.name} <span class="keyword">/&gt;</span>
      <span class="keyword">&lt;</span>h3<span class="keyword">&gt;</span>{user.name}<span class="keyword">&lt;/</span>h3<span class="keyword">&gt;</span>
      {user.bio && <span class="keyword">&lt;</span>p<span class="keyword">&gt;</span>{user.bio}<span class="keyword">&lt;/</span>p<span class="keyword">&gt;</span>}
    <span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>
  );
}</code></pre>

    <pre><code><span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
<span class="comment">// components/PostCard/PostCard.fragment.ts</span>
<span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
<span class="keyword">import</span> { <span class="type">gql</span> } <span class="keyword">from</span> <span class="string">'@apollo/client'</span>;
<span class="keyword">import</span> { <span class="const">USER_CARD_FRAGMENT</span> } <span class="keyword">from</span> <span class="string">'../UserCard/UserCard.fragment'</span>;

<span class="keyword">export const</span> <span class="const">POST_CARD_FRAGMENT</span> = <span class="function">gql</span><span class="string">`
  </span>${<span class="const">USER_CARD_FRAGMENT</span>}<span class="string">
  fragment PostCard_post on Post {
    id
    title
    excerpt
    coverImage
    createdAt
    author {
      ...UserCard_user
    }
  }
`</span>;</code></pre>

    <pre><code><span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
<span class="comment">// graphql/queries/posts.ts - Compose into final query</span>
<span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
<span class="keyword">import</span> { <span class="type">gql</span> } <span class="keyword">from</span> <span class="string">'@apollo/client'</span>;
<span class="keyword">import</span> { <span class="const">POST_CARD_FRAGMENT</span> } <span class="keyword">from</span> <span class="string">'@/components/PostCard/PostCard.fragment'</span>;

<span class="keyword">export const</span> <span class="const">GET_POSTS</span> = <span class="function">gql</span><span class="string">`
  </span>${<span class="const">POST_CARD_FRAGMENT</span>}<span class="string">
  query GetPosts($first: Int!, $after: String) {
    posts(first: $first, after: $after) {
      edges {
        node {
          ...PostCard_post
        }
      }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
`</span>;</code></pre>

    <div class="best-practice">
      <strong>Naming Convention:</strong> Use <code class="inline-code">ComponentName_typeName</code> for fragment names (e.g., <code class="inline-code">UserCard_user</code>, <code class="inline-code">PostCard_post</code>). This makes it clear which component owns the fragment and what type it applies to.
    </div>

    <!-- Section 6.5 -->
    <h2>6.5 Benefits of Colocated Fragments</h2>

    <div class="diagram">
      <svg viewBox="0 0 750 300" xmlns="http://www.w3.org/2000/svg">
        <text x="375" y="25" fill="#e4e4e7" font-size="16" font-weight="bold" text-anchor="middle">Without vs With Colocated Fragments</text>
        
        <!-- Without -->
        <rect x="20" y="50" width="340" height="230" rx="10" fill="#7f1d1d" fill-opacity="0.3" stroke="#ef4444"/>
        <text x="190" y="75" fill="#f87171" font-size="13" font-weight="bold" text-anchor="middle">âŒ Without Fragments</text>
        
        <text x="40" y="105" fill="#94a3b8" font-size="10">GET_POSTS query:</text>
        <text x="50" y="125" fill="#fbbf24" font-size="9">  author { id name avatar bio email }</text>
        
        <text x="40" y="155" fill="#94a3b8" font-size="10">GET_USER query:</text>
        <text x="50" y="175" fill="#fbbf24" font-size="9">  user { id name avatar bio }</text>
        <text x="50" y="190" fill="#f87171" font-size="9">  â†‘ Missing email! Bug!</text>
        
        <text x="40" y="220" fill="#94a3b8" font-size="10">Problems:</text>
        <text x="50" y="240" fill="#f87171" font-size="9">â€¢ Duplicated field lists</text>
        <text x="50" y="255" fill="#f87171" font-size="9">â€¢ Easy to miss fields</text>
        <text x="50" y="270" fill="#f87171" font-size="9">â€¢ Hard to maintain</text>
        
        <!-- With -->
        <rect x="390" y="50" width="340" height="230" rx="10" fill="#065f46" fill-opacity="0.3" stroke="#10b981"/>
        <text x="560" y="75" fill="#34d399" font-size="13" font-weight="bold" text-anchor="middle">âœ“ With Colocated Fragments</text>
        
        <text x="410" y="105" fill="#94a3b8" font-size="10">UserCard.fragment.ts:</text>
        <text x="420" y="125" fill="#2dd4bf" font-size="9">  fragment UserCard_user on User {</text>
        <text x="420" y="140" fill="#2dd4bf" font-size="9">    id name avatar bio</text>
        <text x="420" y="155" fill="#2dd4bf" font-size="9">  }</text>
        
        <text x="410" y="185" fill="#94a3b8" font-size="10">All queries use: ...UserCard_user</text>
        
        <text x="410" y="215" fill="#94a3b8" font-size="10">Benefits:</text>
        <text x="420" y="235" fill="#34d399" font-size="9">â€¢ Single source of truth</text>
        <text x="420" y="250" fill="#34d399" font-size="9">â€¢ Update once, applies everywhere</text>
        <text x="420" y="265" fill="#34d399" font-size="9">â€¢ Type-safe with generated types</text>
      </svg>
    </div>

    <!-- Section 6.6 -->
    <h2>6.6 Fragments with useFragment Hook</h2>

    <p>Apollo Client 3.8+ provides the <code class="inline-code">useFragment</code> hook for reading fragment data directly from the cache. This enables fine-grained component updates.</p>

    <pre><code><span class="keyword">import</span> { <span class="type">useFragment</span> } <span class="keyword">from</span> <span class="string">'@apollo/client'</span>;
<span class="keyword">import</span> { <span class="const">USER_CARD_FRAGMENT</span> } <span class="keyword">from</span> <span class="string">'./UserCard.fragment'</span>;

<span class="keyword">function</span> <span class="function">UserCard</span>({ <span class="param">userId</span> }: { <span class="param">userId</span>: <span class="type">string</span> }) {
  <span class="comment">// Read fragment data directly from cache</span>
  <span class="keyword">const</span> { data, complete } = <span class="function">useFragment</span>({
    <span class="field">fragment</span>: <span class="const">USER_CARD_FRAGMENT</span>,
    <span class="field">from</span>: {
      <span class="field">__typename</span>: <span class="string">'User'</span>,
      <span class="field">id</span>: userId,
    },
  });

  <span class="keyword">if</span> (!complete) {
    <span class="keyword">return</span> <span class="keyword">&lt;</span>UserCardSkeleton <span class="keyword">/&gt;</span>;
  }

  <span class="keyword">return</span> (
    <span class="keyword">&lt;</span>div className=<span class="string">"user-card"</span><span class="keyword">&gt;</span>
      <span class="keyword">&lt;</span>img <span class="field">src</span>={data.avatar} <span class="field">alt</span>={data.name} <span class="keyword">/&gt;</span>
      <span class="keyword">&lt;</span>h3<span class="keyword">&gt;</span>{data.name}<span class="keyword">&lt;/</span>h3<span class="keyword">&gt;</span>
    <span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>
  );
}</code></pre>

    <div class="concept-box">
      <strong>useFragment Benefits:</strong><br><br>
      â€¢ <strong>Selective Re-renders:</strong> Component only re-renders when its specific fragment data changes<br>
      â€¢ <strong>No Prop Drilling:</strong> Child components can read their data directly from cache<br>
      â€¢ <strong>Lazy Loading:</strong> Fragment data can be incomplete (partial cache hit)
    </div>

    <!-- Section 6.7 -->
    <h2>6.7 Fragments for Cache Operations</h2>

    <p>Fragments are essential when reading from or writing to the Apollo cache.</p>

    <h3>Reading Fragments from Cache</h3>

    <pre><code><span class="keyword">import</span> { <span class="type">useApolloClient</span> } <span class="keyword">from</span> <span class="string">'@apollo/client'</span>;

<span class="keyword">function</span> <span class="function">useUserData</span>(userId: <span class="type">string</span>) {
  <span class="keyword">const</span> client = <span class="function">useApolloClient</span>();
  
  <span class="comment">// Read a fragment from cache</span>
  <span class="keyword">const</span> user = client.<span class="function">readFragment</span>({
    <span class="field">id</span>: <span class="string">`User:</span>${userId}<span class="string">`</span>,  <span class="comment">// Cache ID: __typename:id</span>
    <span class="field">fragment</span>: <span class="function">gql</span><span class="string">`
      fragment UserData on User {
        id
        name
        email
      }
    `</span>,
  });
  
  <span class="keyword">return</span> user;
}</code></pre>

    <h3>Writing Fragments to Cache</h3>

    <pre><code><span class="keyword">function</span> <span class="function">updateUserInCache</span>(userId: <span class="type">string</span>, newName: <span class="type">string</span>) {
  client.<span class="function">writeFragment</span>({
    <span class="field">id</span>: <span class="string">`User:</span>${userId}<span class="string">`</span>,
    <span class="field">fragment</span>: <span class="function">gql</span><span class="string">`
      fragment UpdateUserName on User {
        name
      }
    `</span>,
    <span class="field">data</span>: {
      <span class="field">name</span>: newName,
    },
  });
}</code></pre>

    <h3>Using Fragments in Mutation update Functions</h3>

    <pre><code><span class="keyword">const</span> <span class="const">POST_FRAGMENT</span> = <span class="function">gql</span><span class="string">`
  fragment NewPost on Post {
    id
    title
    content
    createdAt
    author {
      id
      name
    }
  }
`</span>;

<span class="keyword">const</span> [createPost] = <span class="function">useMutation</span>(<span class="const">CREATE_POST</span>, {
  <span class="function">update</span>(cache, { data: { createPost } }) {
    <span class="comment">// Write the new post to cache</span>
    <span class="keyword">const</span> newPostRef = cache.<span class="function">writeFragment</span>({
      <span class="field">data</span>: createPost,
      <span class="field">fragment</span>: <span class="const">POST_FRAGMENT</span>,
    });
    
    <span class="comment">// Add to the posts list</span>
    cache.<span class="function">modify</span>({
      <span class="field">fields</span>: {
        <span class="function">posts</span>(existingPosts = []) {
          <span class="keyword">return</span> [newPostRef, ...existingPosts];
        },
      },
    });
  },
});</code></pre>

    <!-- Section 6.8 -->
    <h2>6.8 Inline Fragments for Union/Interface Types</h2>

    <p>When querying union or interface types, use inline fragments to specify fields for each possible type.</p>

    <pre><code><span class="comment">// Schema: union SearchResult = User | Post | Comment</span>

<span class="keyword">const</span> <span class="const">SEARCH</span> = <span class="function">gql</span><span class="string">`
  query Search($term: String!) {
    search(term: $term) {
      __typename
      
      ... on User {
        id
        name
        avatar
      }
      
      ... on Post {
        id
        title
        excerpt
      }
      
      ... on Comment {
        id
        text
        author {
          name
        }
      }
    }
  }
`</span>;

<span class="comment">// In your component:</span>
<span class="keyword">function</span> <span class="function">SearchResults</span>({ <span class="param">results</span> }) {
  <span class="keyword">return</span> results.<span class="function">map</span>(result => {
    <span class="keyword">switch</span> (result.__typename) {
      <span class="keyword">case</span> <span class="string">'User'</span>:
        <span class="keyword">return</span> <span class="keyword">&lt;</span>UserCard <span class="field">key</span>={result.id} <span class="field">user</span>={result} <span class="keyword">/&gt;</span>;
      <span class="keyword">case</span> <span class="string">'Post'</span>:
        <span class="keyword">return</span> <span class="keyword">&lt;</span>PostCard <span class="field">key</span>={result.id} <span class="field">post</span>={result} <span class="keyword">/&gt;</span>;
      <span class="keyword">case</span> <span class="string">'Comment'</span>:
        <span class="keyword">return</span> <span class="keyword">&lt;</span>CommentCard <span class="field">key</span>={result.id} <span class="field">comment</span>={result} <span class="keyword">/&gt;</span>;
      <span class="keyword">default</span>:
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
  });
}</code></pre>

    <!-- Section 6.9 -->
    <h2>6.9 Fragment Types with GraphQL Code Generator</h2>

    <p>For production apps, use GraphQL Code Generator to automatically generate TypeScript types for your fragments.</p>

    <pre><code><span class="comment"># codegen.yml</span>
<span class="field">schema</span>: <span class="string">'http://localhost:4000/graphql'</span>
<span class="field">documents</span>: <span class="string">'src/**/*.{ts,tsx}'</span>
<span class="field">generates</span>:
  <span class="string">src/graphql/generated.ts</span>:
    <span class="field">plugins</span>:
      - typescript
      - typescript-operations
      - typescript-react-apollo
    <span class="field">config</span>:
      <span class="field">withHooks</span>: <span class="keyword">true</span>
      <span class="field">withFragmentTypes</span>: <span class="keyword">true</span></code></pre>

    <pre><code><span class="comment">// After running codegen, you get typed fragments:</span>

<span class="keyword">import</span> { <span class="type">UserCard_UserFragment</span> } <span class="keyword">from</span> <span class="string">'@/graphql/generated'</span>;

<span class="keyword">interface</span> <span class="type">Props</span> {
  <span class="field">user</span>: <span class="type">UserCard_UserFragment</span>;  <span class="comment">// Auto-generated type!</span>
}

<span class="keyword">function</span> <span class="function">UserCard</span>({ <span class="param">user</span> }: <span class="type">Props</span>) {
  <span class="comment">// TypeScript knows all available fields</span>
  <span class="keyword">return</span> <span class="keyword">&lt;</span>div<span class="keyword">&gt;</span>{user.name}<span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>;  <span class="comment">// âœ“ Type-safe!</span>
}</code></pre>

    <div class="tip-box">
      GraphQL Code Generator with fragments gives you end-to-end type safety. If you add a field to a fragment, TypeScript will tell you everywhere that field is now available. If you remove one, you'll get errors where it's still being used.
    </div>

    <!-- Section 6.10 -->
    <h2>6.10 Fragment Best Practices Summary</h2>

    <table class="comparison-table">
      <tr>
        <th>Practice</th>
        <th>Description</th>
      </tr>
      <tr>
        <td>âœ“ Colocate fragments</td>
        <td>Define fragments next to the components that use them</td>
      </tr>
      <tr>
        <td>âœ“ Use naming convention</td>
        <td><code>ComponentName_typeName</code> (e.g., <code>UserCard_user</code>)</td>
      </tr>
      <tr>
        <td>âœ“ Keep fragments focused</td>
        <td>Include only fields the component actually uses</td>
      </tr>
      <tr>
        <td>âœ“ Compose fragments</td>
        <td>Build complex fragments from simpler ones</td>
      </tr>
      <tr>
        <td>âœ“ Generate types</td>
        <td>Use GraphQL Code Generator for TypeScript types</td>
      </tr>
      <tr>
        <td>âœ“ Use for cache ops</td>
        <td>Use fragments with readFragment/writeFragment</td>
      </tr>
      <tr>
        <td>âœ— Avoid giant fragments</td>
        <td>Don't create "kitchen sink" fragments with all fields</td>
      </tr>
      <tr>
        <td>âœ— Avoid circular deps</td>
        <td>Be careful with fragment dependencies across files</td>
      </tr>
    </table>

    <div class="warning-box">
      Fragments are critical for maintainable GraphQL applications. In interviews, be prepared to explain:<br><br>
      â€¢ Why colocated fragments improve maintainability<br>
      â€¢ How fragments enable selective re-rendering with useFragment<br>
      â€¢ How to use fragments with cache.writeFragment in mutations
    </div>

    <div class="chapter-nav">
      <button class="nav-btn">â† Chapter 5: useMutation</button>
      <button class="nav-btn">Next: Chapter 7 â€” Subscriptions â†’</button>
    </div>
  </div>
</body>
</html>
