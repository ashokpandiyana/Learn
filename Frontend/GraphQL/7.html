<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 7: Subscriptions</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, #1a0533 0%, #0f172a 100%);
      color: #e4e4e7;
      line-height: 1.7;
      padding: 40px 20px;
      min-height: 100vh;
    }
    .container { max-width: 950px; margin: 0 auto; }
    h1 {
      font-size: 2.5rem;
      background: linear-gradient(90deg, #a855f7, #ec4899);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 10px;
    }
    .subtitle { color: #a1a1aa; font-size: 1.1rem; margin-bottom: 40px; }
    h2 {
      color: #a855f7;
      font-size: 1.6rem;
      margin: 40px 0 20px;
      padding-bottom: 10px;
      border-bottom: 2px solid #3f3f46;
    }
    h3 { color: #c084fc; font-size: 1.2rem; margin: 25px 0 15px; }
    h4 { color: #d8b4fe; font-size: 1rem; margin: 20px 0 10px; }
    p { margin-bottom: 15px; color: #d4d4d8; }
    .highlight-box {
      background: linear-gradient(135deg, #581c87 0%, #3b0764 100%);
      border-left: 4px solid #a855f7;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .warning-box {
      background: linear-gradient(135deg, #78350f 0%, #451a03 100%);
      border-left: 4px solid #f59e0b;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .warning-box::before { content: "âš ï¸ INTERVIEW HIGHLIGHT: "; font-weight: bold; color: #fbbf24; }
    .tip-box {
      background: linear-gradient(135deg, #064e3b 0%, #022c22 100%);
      border-left: 4px solid #10b981;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .tip-box::before { content: "ğŸ“ PRODUCTION TIP: "; font-weight: bold; color: #34d399; }
    .concept-box {
      background: linear-gradient(135deg, #1e3a8a 0%, #1e1b4b 100%);
      border-left: 4px solid #3b82f6;
      padding: 20px;
      border-radius: 0 12px 12px 0;
      margin: 20px 0;
    }
    .concept-box::before { content: "ğŸ’¡ KEY CONCEPT: "; font-weight: bold; color: #60a5fa; }
    pre {
      background: #0a0a15;
      border: 1px solid #3f3f46;
      border-radius: 12px;
      padding: 20px;
      overflow-x: auto;
      margin: 15px 0;
      font-size: 0.85rem;
    }
    code { font-family: 'Fira Code', 'Consolas', monospace; }
    .inline-code {
      background: #3f3f46;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.85rem;
    }
    .keyword { color: #c084fc; }
    .type { color: #38bdf8; }
    .string { color: #4ade80; }
    .comment { color: #6b7280; font-style: italic; }
    .field { color: #fbbf24; }
    .function { color: #f472b6; }
    .const { color: #fb923c; }
    .param { color: #67e8f9; }
    .diagram {
      background: #0a0a15;
      border-radius: 12px;
      padding: 30px;
      margin: 20px 0;
      text-align: center;
      overflow-x: auto;
    }
    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      background: #1e293b;
      border-radius: 12px;
      overflow: hidden;
      font-size: 0.9rem;
    }
    .comparison-table th {
      background: linear-gradient(90deg, #7c3aed, #db2777);
      padding: 14px;
      text-align: left;
      font-weight: 600;
    }
    .comparison-table td {
      padding: 12px 14px;
      border-bottom: 1px solid #334155;
    }
    .comparison-table tr:last-child td { border-bottom: none; }
    ul, ol { margin: 15px 0 15px 25px; }
    li { margin: 8px 0; color: #d4d4d8; }
    .chapter-nav {
      display: flex;
      justify-content: space-between;
      margin-top: 50px;
      padding-top: 30px;
      border-top: 1px solid #3f3f46;
    }
    .nav-btn {
      padding: 12px 24px;
      background: linear-gradient(90deg, #7c3aed, #db2777);
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }
    .step-container {
      position: relative;
      padding-left: 50px;
      margin: 20px 0;
    }
    .step-num {
      position: absolute;
      left: 0;
      top: 0;
      width: 35px;
      height: 35px;
      background: linear-gradient(135deg, #a855f7, #ec4899);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }
    .use-case-card {
      background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
      border: 1px solid #374151;
      border-radius: 12px;
      padding: 20px;
      margin: 15px 0;
    }
    .use-case-card h4 { color: #a855f7; margin-bottom: 10px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Chapter 7</h1>
    <p class="subtitle">Subscriptions â€” Real-time Data with GraphQL</p>

    <!-- Section 7.1 -->
    <h2>7.1 What Are Subscriptions?</h2>
    
    <p>Subscriptions are GraphQL's solution for real-time data. Unlike queries (one-time fetch) and mutations (one-time write), subscriptions maintain a persistent connection to the server, pushing data to the client whenever events occur.</p>

    <div class="diagram">
      <svg viewBox="0 0 800 250" xmlns="http://www.w3.org/2000/svg">
        <text x="400" y="25" fill="#e4e4e7" font-size="16" font-weight="bold" text-anchor="middle">Query vs Subscription</text>
        
        <!-- Query (Request-Response) -->
        <rect x="30" y="50" width="340" height="180" rx="10" fill="#1e3a8a" fill-opacity="0.3" stroke="#3b82f6"/>
        <text x="200" y="75" fill="#60a5fa" font-size="13" font-weight="bold" text-anchor="middle">Query (Request-Response)</text>
        
        <rect x="60" y="95" width="80" height="35" rx="5" fill="#3b82f6"/>
        <text x="100" y="117" fill="white" font-size="11" text-anchor="middle">Client</text>
        
        <rect x="260" y="95" width="80" height="35" rx="5" fill="#1e40af"/>
        <text x="300" y="117" fill="white" font-size="11" text-anchor="middle">Server</text>
        
        <line x1="140" y1="112" x2="260" y2="112" stroke="#60a5fa" stroke-width="2" marker-end="url(#arrowBlue)"/>
        <text x="200" y="105" fill="#94a3b8" font-size="9" text-anchor="middle">Request</text>
        
        <line x1="260" y1="125" x2="140" y2="125" stroke="#60a5fa" stroke-width="2" marker-end="url(#arrowBlueRev)"/>
        <text x="200" y="140" fill="#94a3b8" font-size="9" text-anchor="middle">Response (once)</text>
        
        <text x="200" y="180" fill="#94a3b8" font-size="10" text-anchor="middle">Connection closes after response</text>
        <text x="200" y="200" fill="#60a5fa" font-size="10" text-anchor="middle">HTTP Protocol</text>
        
        <!-- Subscription (Persistent) -->
        <rect x="430" y="50" width="340" height="180" rx="10" fill="#581c87" fill-opacity="0.3" stroke="#a855f7"/>
        <text x="600" y="75" fill="#c084fc" font-size="13" font-weight="bold" text-anchor="middle">Subscription (Persistent)</text>
        
        <rect x="460" y="95" width="80" height="35" rx="5" fill="#a855f7"/>
        <text x="500" y="117" fill="white" font-size="11" text-anchor="middle">Client</text>
        
        <rect x="660" y="95" width="80" height="35" rx="5" fill="#7c3aed"/>
        <text x="700" y="117" fill="white" font-size="11" text-anchor="middle">Server</text>
        
        <line x1="540" y1="105" x2="660" y2="105" stroke="#c084fc" stroke-width="2" marker-end="url(#arrowPurple)"/>
        <text x="600" y="98" fill="#94a3b8" font-size="9" text-anchor="middle">Subscribe</text>
        
        <line x1="660" y1="115" x2="540" y2="115" stroke="#ec4899" stroke-width="2" marker-end="url(#arrowPink)"/>
        <line x1="660" y1="125" x2="540" y2="125" stroke="#ec4899" stroke-width="2" marker-end="url(#arrowPink)"/>
        <line x1="660" y1="135" x2="540" y2="135" stroke="#ec4899" stroke-width="2" marker-end="url(#arrowPink)"/>
        <text x="600" y="155" fill="#94a3b8" font-size="9" text-anchor="middle">Push events (many)</text>
        
        <text x="600" y="180" fill="#94a3b8" font-size="10" text-anchor="middle">Connection stays open</text>
        <text x="600" y="200" fill="#c084fc" font-size="10" text-anchor="middle">WebSocket Protocol</text>
        
        <defs>
          <marker id="arrowBlue" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#60a5fa"/>
          </marker>
          <marker id="arrowBlueRev" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
            <polygon points="10 0, 0 3.5, 10 7" fill="#60a5fa"/>
          </marker>
          <marker id="arrowPurple" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#c084fc"/>
          </marker>
          <marker id="arrowPink" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
            <polygon points="10 0, 0 3.5, 10 7" fill="#ec4899"/>
          </marker>
        </defs>
      </svg>
    </div>

    <h3>Common Use Cases</h3>
    
    <div class="use-case-card">
      <h4>ğŸ’¬ Chat Applications</h4>
      <p>New messages pushed to all participants in real-time</p>
    </div>
    
    <div class="use-case-card">
      <h4>ğŸ”” Notifications</h4>
      <p>Alerts, mentions, and updates delivered instantly</p>
    </div>
    
    <div class="use-case-card">
      <h4>ğŸ“Š Live Dashboards</h4>
      <p>Stock prices, metrics, and analytics updating in real-time</p>
    </div>
    
    <div class="use-case-card">
      <h4>ğŸ® Multiplayer Games</h4>
      <p>Player positions, scores, and game state synchronized</p>
    </div>
    
    <div class="use-case-card">
      <h4>ğŸ“ Collaborative Editing</h4>
      <p>Document changes visible to all editors immediately</p>
    </div>

    <!-- Section 7.2 -->
    <h2>7.2 WebSocket Setup with Apollo Client</h2>

    <p>Subscriptions require WebSocket transport. Apollo Client uses a split link to route subscriptions through WebSocket while queries/mutations use HTTP.</p>

    <div class="step-container">
      <div class="step-num">1</div>
      <h4>Install Dependencies</h4>
      <pre><code>npm install @apollo/client graphql graphql-ws</code></pre>
    </div>

    <div class="step-container">
      <div class="step-num">2</div>
      <h4>Create WebSocket Link</h4>
      <pre><code><span class="keyword">import</span> { <span class="type">GraphQLWsLink</span> } <span class="keyword">from</span> <span class="string">'@apollo/client/link/subscriptions'</span>;
<span class="keyword">import</span> { <span class="type">createClient</span> } <span class="keyword">from</span> <span class="string">'graphql-ws'</span>;

<span class="keyword">const</span> <span class="const">wsLink</span> = <span class="keyword">new</span> <span class="function">GraphQLWsLink</span>(
  <span class="function">createClient</span>({
    <span class="field">url</span>: <span class="string">'wss://your-api.com/graphql'</span>,
    
    <span class="comment">// Authentication</span>
    <span class="field">connectionParams</span>: {
      <span class="field">authToken</span>: localStorage.<span class="function">getItem</span>(<span class="string">'token'</span>),
    },
    
    <span class="comment">// Or dynamic auth (function form)</span>
    <span class="function">connectionParams</span>: () => ({
      <span class="field">authToken</span>: localStorage.<span class="function">getItem</span>(<span class="string">'token'</span>),
    }),
  })
);</code></pre>
    </div>

    <div class="step-container">
      <div class="step-num">3</div>
      <h4>Create Split Link</h4>
      <pre><code><span class="keyword">import</span> { 
  <span class="type">split</span>, 
  <span class="type">HttpLink</span>,
  <span class="type">ApolloClient</span>,
  <span class="type">InMemoryCache</span>,
} <span class="keyword">from</span> <span class="string">'@apollo/client'</span>;
<span class="keyword">import</span> { <span class="type">getMainDefinition</span> } <span class="keyword">from</span> <span class="string">'@apollo/client/utilities'</span>;

<span class="comment">// HTTP Link for queries and mutations</span>
<span class="keyword">const</span> <span class="const">httpLink</span> = <span class="keyword">new</span> <span class="function">HttpLink</span>({
  <span class="field">uri</span>: <span class="string">'https://your-api.com/graphql'</span>,
});

<span class="comment">// Split based on operation type</span>
<span class="keyword">const</span> <span class="const">splitLink</span> = <span class="function">split</span>(
  ({ query }) => {
    <span class="keyword">const</span> definition = <span class="function">getMainDefinition</span>(query);
    <span class="keyword">return</span> (
      definition.kind === <span class="string">'OperationDefinition'</span> &&
      definition.operation === <span class="string">'subscription'</span>
    );
  },
  wsLink,    <span class="comment">// Use WebSocket for subscriptions</span>
  httpLink,  <span class="comment">// Use HTTP for everything else</span>
);

<span class="comment">// Create Apollo Client</span>
<span class="keyword">const</span> <span class="const">client</span> = <span class="keyword">new</span> <span class="function">ApolloClient</span>({
  <span class="field">link</span>: splitLink,
  <span class="field">cache</span>: <span class="keyword">new</span> <span class="function">InMemoryCache</span>(),
});</code></pre>
    </div>

    <div class="concept-box">
      The <code class="inline-code">split</code> function acts like a router: it checks each operation and directs subscriptions to WebSocket, while queries and mutations go through HTTP. This is essential because HTTP cannot maintain persistent connections.
    </div>

    <!-- Section 7.3 -->
    <h2>7.3 Advanced WebSocket Configuration</h2>

    <pre><code><span class="keyword">import</span> { <span class="type">createClient</span> } <span class="keyword">from</span> <span class="string">'graphql-ws'</span>;

<span class="keyword">const</span> <span class="const">wsClient</span> = <span class="function">createClient</span>({
  <span class="field">url</span>: <span class="string">'wss://api.example.com/graphql'</span>,
  
  <span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
  <span class="comment">// AUTHENTICATION</span>
  <span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
  <span class="function">connectionParams</span>: <span class="keyword">async</span> () => {
    <span class="keyword">const</span> token = <span class="keyword">await</span> <span class="function">getAuthToken</span>();
    <span class="keyword">return</span> { <span class="field">authToken</span>: token };
  },
  
  <span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
  <span class="comment">// RECONNECTION</span>
  <span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
  <span class="field">shouldRetry</span>: () => <span class="keyword">true</span>,
  <span class="field">retryAttempts</span>: 5,
  <span class="function">retryWait</span>: <span class="keyword">async</span> (retries) => {
    <span class="comment">// Exponential backoff</span>
    <span class="keyword">await</span> <span class="keyword">new</span> <span class="type">Promise</span>(resolve => 
      <span class="function">setTimeout</span>(resolve, Math.<span class="function">min</span>(1000 * 2 ** retries, 30000))
    );
  },
  
  <span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
  <span class="comment">// LIFECYCLE EVENTS</span>
  <span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
  <span class="field">on</span>: {
    <span class="function">connected</span>: (socket) => {
      console.<span class="function">log</span>(<span class="string">'âœ… WebSocket connected'</span>);
    },
    
    <span class="function">closed</span>: (event) => {
      console.<span class="function">log</span>(<span class="string">'âŒ WebSocket closed'</span>, event);
    },
    
    <span class="function">error</span>: (error) => {
      console.<span class="function">error</span>(<span class="string">'ğŸ”´ WebSocket error'</span>, error);
    },
    
    <span class="function">connecting</span>: () => {
      console.<span class="function">log</span>(<span class="string">'ğŸ”„ WebSocket connecting...'</span>);
    },
    
    <span class="function">ping</span>: (received) => {
      console.<span class="function">log</span>(received ? <span class="string">'Pong received'</span> : <span class="string">'Ping sent'</span>);
    },
    
    <span class="function">pong</span>: (received) => {
      console.<span class="function">log</span>(received ? <span class="string">'Ping received'</span> : <span class="string">'Pong sent'</span>);
    },
  },
  
  <span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
  <span class="comment">// KEEP-ALIVE</span>
  <span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
  <span class="field">keepAlive</span>: 10000,  <span class="comment">// Ping every 10 seconds</span>
  
  <span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
  <span class="comment">// LAZY CONNECTION (connect on first subscribe)</span>
  <span class="comment">// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span>
  <span class="field">lazy</span>: <span class="keyword">true</span>,  
  <span class="field">lazyCloseTimeout</span>: 3000,  <span class="comment">// Close after 3s of no subscriptions</span>
});

<span class="keyword">const</span> <span class="const">wsLink</span> = <span class="keyword">new</span> <span class="function">GraphQLWsLink</span>(wsClient);</code></pre>

    <div class="tip-box">
      Use <code class="inline-code">lazy: true</code> in production to only establish WebSocket connections when actually needed. This saves resources when users don't need real-time features immediately.
    </div>

    <!-- Section 7.4 -->
    <h2>7.4 useSubscription Hook</h2>

    <p>The <code class="inline-code">useSubscription</code> hook is the primary way to consume subscriptions in React components.</p>

    <pre><code><span class="keyword">import</span> { <span class="type">useSubscription</span>, <span class="type">gql</span> } <span class="keyword">from</span> <span class="string">'@apollo/client'</span>;

<span class="keyword">const</span> <span class="const">MESSAGE_SUBSCRIPTION</span> = <span class="function">gql</span><span class="string">`
  subscription OnMessageAdded($channelId: ID!) {
    messageAdded(channelId: $channelId) {
      id
      content
      createdAt
      sender {
        id
        name
        avatar
      }
    }
  }
`</span>;

<span class="keyword">function</span> <span class="function">ChatMessages</span>({ <span class="param">channelId</span> }) {
  <span class="keyword">const</span> { data, loading, error } = <span class="function">useSubscription</span>(<span class="const">MESSAGE_SUBSCRIPTION</span>, {
    <span class="field">variables</span>: { <span class="field">channelId</span> },
    
    <span class="comment">// Called on each new message</span>
    <span class="function">onData</span>: ({ data }) => {
      console.<span class="function">log</span>(<span class="string">'New message:'</span>, data.data.messageAdded);
      <span class="comment">// Play notification sound, update unread count, etc.</span>
      <span class="function">playNotificationSound</span>();
    },
    
    <span class="comment">// Called on subscription complete</span>
    <span class="function">onComplete</span>: () => {
      console.<span class="function">log</span>(<span class="string">'Subscription completed'</span>);
    },
    
    <span class="comment">// Called on error</span>
    <span class="function">onError</span>: (error) => {
      console.<span class="function">error</span>(<span class="string">'Subscription error:'</span>, error);
    },
    
    <span class="comment">// Skip subscription conditionally</span>
    <span class="field">skip</span>: !channelId,
  });

  <span class="keyword">if</span> (loading) <span class="keyword">return</span> <span class="keyword">&lt;</span>p<span class="keyword">&gt;</span>Connecting...<span class="keyword">&lt;/</span>p<span class="keyword">&gt;</span>;
  <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="keyword">&lt;</span>p<span class="keyword">&gt;</span>Error: {error.message}<span class="keyword">&lt;/</span>p<span class="keyword">&gt;</span>;

  <span class="comment">// data contains the LATEST message from subscription</span>
  <span class="keyword">return</span> (
    <span class="keyword">&lt;</span>div className=<span class="string">"new-message-indicator"</span><span class="keyword">&gt;</span>
      {data && (
        <span class="keyword">&lt;</span>p<span class="keyword">&gt;</span>New: {data.messageAdded.content}<span class="keyword">&lt;/</span>p<span class="keyword">&gt;</span>
      )}
    <span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>
  );
}</code></pre>

    <div class="warning-box">
      <code class="inline-code">useSubscription</code> only provides the <strong>latest</strong> event. It doesn't accumulate messages. For a full message list, combine with <code class="inline-code">useQuery</code> and <code class="inline-code">subscribeToMore</code> (covered next).
    </div>

    <!-- Section 7.5 -->
    <h2>7.5 subscribeToMore â€” The Production Pattern</h2>

    <p>The <code class="inline-code">subscribeToMore</code> pattern combines initial data fetching with real-time updates. This is the recommended approach for most real-time UIs.</p>

    <pre><code><span class="keyword">import</span> { <span class="type">useQuery</span>, <span class="type">gql</span> } <span class="keyword">from</span> <span class="string">'@apollo/client'</span>;
<span class="keyword">import</span> { <span class="type">useEffect</span> } <span class="keyword">from</span> <span class="string">'react'</span>;

<span class="keyword">const</span> <span class="const">GET_MESSAGES</span> = <span class="function">gql</span><span class="string">`
  query GetMessages($channelId: ID!) {
    messages(channelId: $channelId) {
      id
      content
      createdAt
      sender {
        id
        name
        avatar
      }
    }
  }
`</span>;

<span class="keyword">const</span> <span class="const">MESSAGE_ADDED</span> = <span class="function">gql</span><span class="string">`
  subscription OnMessageAdded($channelId: ID!) {
    messageAdded(channelId: $channelId) {
      id
      content
      createdAt
      sender {
        id
        name
        avatar
      }
    }
  }
`</span>;

<span class="keyword">function</span> <span class="function">ChatRoom</span>({ <span class="param">channelId</span> }) {
  <span class="keyword">const</span> { data, loading, error, subscribeToMore } = <span class="function">useQuery</span>(<span class="const">GET_MESSAGES</span>, {
    <span class="field">variables</span>: { <span class="field">channelId</span> },
  });

  <span class="comment">// Set up subscription when component mounts</span>
  <span class="function">useEffect</span>(() => {
    <span class="keyword">const</span> unsubscribe = <span class="function">subscribeToMore</span>({
      <span class="field">document</span>: <span class="const">MESSAGE_ADDED</span>,
      <span class="field">variables</span>: { <span class="field">channelId</span> },
      
      <span class="comment">// How to merge new data with existing</span>
      <span class="function">updateQuery</span>: (prev, { subscriptionData }) => {
        <span class="keyword">if</span> (!subscriptionData.data) <span class="keyword">return</span> prev;
        
        <span class="keyword">const</span> newMessage = subscriptionData.data.messageAdded;
        
        <span class="comment">// Check for duplicates</span>
        <span class="keyword">const</span> exists = prev.messages.<span class="function">some</span>(
          msg => msg.id === newMessage.id
        );
        <span class="keyword">if</span> (exists) <span class="keyword">return</span> prev;
        
        <span class="comment">// Return merged result</span>
        <span class="keyword">return</span> {
          ...prev,
          <span class="field">messages</span>: [...prev.messages, newMessage],
        };
      },
      
      <span class="comment">// Error handling</span>
      <span class="function">onError</span>: (error) => {
        console.<span class="function">error</span>(<span class="string">'Subscription error:'</span>, error);
      },
    });

    <span class="comment">// Cleanup: unsubscribe when component unmounts or channelId changes</span>
    <span class="keyword">return</span> () => <span class="function">unsubscribe</span>();
  }, [channelId, subscribeToMore]);

  <span class="keyword">if</span> (loading) <span class="keyword">return</span> <span class="keyword">&lt;</span>LoadingSpinner <span class="keyword">/&gt;</span>;
  <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="keyword">&lt;</span>Error message={error.message} <span class="keyword">/&gt;</span>;

  <span class="keyword">return</span> (
    <span class="keyword">&lt;</span>div className=<span class="string">"chat-messages"</span><span class="keyword">&gt;</span>
      {data.messages.<span class="function">map</span>(message => (
        <span class="keyword">&lt;</span>Message <span class="field">key</span>={message.id} <span class="field">message</span>={message} <span class="keyword">/&gt;</span>
      ))}
    <span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>
  );
}</code></pre>

    <div class="diagram">
      <svg viewBox="0 0 750 200" xmlns="http://www.w3.org/2000/svg">
        <text x="375" y="25" fill="#e4e4e7" font-size="14" font-weight="bold" text-anchor="middle">subscribeToMore Flow</text>
        
        <!-- Step 1 -->
        <rect x="30" y="50" width="150" height="60" rx="8" fill="#1e40af"/>
        <text x="105" y="75" fill="white" font-size="11" text-anchor="middle">1. useQuery</text>
        <text x="105" y="92" fill="#94a3b8" font-size="9" text-anchor="middle">Fetch initial messages</text>
        
        <!-- Arrow -->
        <line x1="180" y1="80" x2="220" y2="80" stroke="#6b7280" stroke-width="2" marker-end="url(#arr)"/>
        
        <!-- Step 2 -->
        <rect x="220" y="50" width="150" height="60" rx="8" fill="#7c3aed"/>
        <text x="295" y="75" fill="white" font-size="11" text-anchor="middle">2. subscribeToMore</text>
        <text x="295" y="92" fill="#94a3b8" font-size="9" text-anchor="middle">Open subscription</text>
        
        <!-- Arrow -->
        <line x1="370" y1="80" x2="410" y2="80" stroke="#6b7280" stroke-width="2" marker-end="url(#arr)"/>
        
        <!-- Step 3 -->
        <rect x="410" y="50" width="150" height="60" rx="8" fill="#059669"/>
        <text x="485" y="75" fill="white" font-size="11" text-anchor="middle">3. New Event</text>
        <text x="485" y="92" fill="#94a3b8" font-size="9" text-anchor="middle">Server pushes message</text>
        
        <!-- Arrow -->
        <line x1="560" y1="80" x2="600" y2="80" stroke="#6b7280" stroke-width="2" marker-end="url(#arr)"/>
        
        <!-- Step 4 -->
        <rect x="600" y="50" width="130" height="60" rx="8" fill="#dc2626"/>
        <text x="665" y="75" fill="white" font-size="11" text-anchor="middle">4. updateQuery</text>
        <text x="665" y="92" fill="#94a3b8" font-size="9" text-anchor="middle">Merge into cache</text>
        
        <!-- Bottom: Result -->
        <rect x="250" y="140" width="250" height="45" rx="8" fill="#1f2937" stroke="#a855f7"/>
        <text x="375" y="168" fill="#c084fc" font-size="11" text-anchor="middle">UI auto-updates with merged data</text>
        
        <!-- Arrow down -->
        <line x1="665" y1="110" x2="500" y2="145" stroke="#a855f7" stroke-width="2"/>
        
        <defs>
          <marker id="arr" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#6b7280"/>
          </marker>
        </defs>
      </svg>
    </div>

    <div class="warning-box">
      <code class="inline-code">subscribeToMore</code> is the preferred pattern for production. It loads initial data with a query, then adds real-time updates via subscription. The <code class="inline-code">updateQuery</code> function merges new data with existing cache data.
    </div>

    <!-- Section 7.6 -->
    <h2>7.6 Multiple Subscriptions</h2>

    <pre><code><span class="keyword">function</span> <span class="function">ChatRoom</span>({ <span class="param">channelId</span> }) {
  <span class="keyword">const</span> { data, subscribeToMore } = <span class="function">useQuery</span>(<span class="const">GET_CHANNEL_DATA</span>, {
    <span class="field">variables</span>: { <span class="field">channelId</span> },
  });

  <span class="function">useEffect</span>(() => {
    <span class="comment">// Subscription 1: New messages</span>
    <span class="keyword">const</span> unsubMessages = <span class="function">subscribeToMore</span>({
      <span class="field">document</span>: <span class="const">MESSAGE_ADDED</span>,
      <span class="field">variables</span>: { <span class="field">channelId</span> },
      <span class="function">updateQuery</span>: (prev, { subscriptionData }) => {
        <span class="comment">// Add new message</span>
        <span class="keyword">return</span> {
          ...prev,
          <span class="field">channel</span>: {
            ...prev.channel,
            <span class="field">messages</span>: [...prev.channel.messages, subscriptionData.data.messageAdded],
          },
        };
      },
    });

    <span class="comment">// Subscription 2: Typing indicators</span>
    <span class="keyword">const</span> unsubTyping = <span class="function">subscribeToMore</span>({
      <span class="field">document</span>: <span class="const">USER_TYPING</span>,
      <span class="field">variables</span>: { <span class="field">channelId</span> },
      <span class="function">updateQuery</span>: (prev, { subscriptionData }) => {
        <span class="keyword">return</span> {
          ...prev,
          <span class="field">channel</span>: {
            ...prev.channel,
            <span class="field">typingUsers</span>: subscriptionData.data.userTyping,
          },
        };
      },
    });

    <span class="comment">// Subscription 3: User presence</span>
    <span class="keyword">const</span> unsubPresence = <span class="function">subscribeToMore</span>({
      <span class="field">document</span>: <span class="const">USER_PRESENCE_CHANGED</span>,
      <span class="field">variables</span>: { <span class="field">channelId</span> },
      <span class="function">updateQuery</span>: (prev, { subscriptionData }) => {
        <span class="keyword">const</span> { userId, status } = subscriptionData.data.presenceChanged;
        <span class="keyword">return</span> {
          ...prev,
          <span class="field">channel</span>: {
            ...prev.channel,
            <span class="field">members</span>: prev.channel.members.<span class="function">map</span>(m => 
              m.id === userId ? { ...m, <span class="field">status</span> } : m
            ),
          },
        };
      },
    });

    <span class="comment">// Cleanup all subscriptions</span>
    <span class="keyword">return</span> () => {
      <span class="function">unsubMessages</span>();
      <span class="function">unsubTyping</span>();
      <span class="function">unsubPresence</span>();
    };
  }, [channelId, subscribeToMore]);

  <span class="keyword">return</span> <span class="keyword">&lt;</span>ChatUI data={data} <span class="keyword">/&gt;</span>;
}</code></pre>

    <!-- Section 7.7 -->
    <h2>7.7 Subscription with Cache Updates</h2>

    <p>Instead of using <code class="inline-code">updateQuery</code>, you can update the cache directly using the <code class="inline-code">onData</code> callback:</p>

    <pre><code><span class="keyword">function</span> <span class="function">ChatRoom</span>({ <span class="param">channelId</span> }) {
  <span class="keyword">const</span> client = <span class="function">useApolloClient</span>();
  
  <span class="comment">// Subscribe with direct cache manipulation</span>
  <span class="function">useSubscription</span>(<span class="const">MESSAGE_ADDED</span>, {
    <span class="field">variables</span>: { <span class="field">channelId</span> },
    <span class="function">onData</span>: ({ data: { data } }) => {
      <span class="keyword">const</span> newMessage = data.messageAdded;
      
      <span class="comment">// Update cache directly</span>
      client.cache.<span class="function">modify</span>({
        <span class="field">id</span>: client.cache.<span class="function">identify</span>({ 
          <span class="field">__typename</span>: <span class="string">'Channel'</span>, 
          <span class="field">id</span>: channelId 
        }),
        <span class="field">fields</span>: {
          <span class="function">messages</span>(existingMessages = []) {
            <span class="keyword">const</span> newRef = client.cache.<span class="function">writeFragment</span>({
              <span class="field">data</span>: newMessage,
              <span class="field">fragment</span>: <span class="const">MESSAGE_FRAGMENT</span>,
            });
            <span class="keyword">return</span> [...existingMessages, newRef];
          },
          <span class="function">messageCount</span>(existing) {
            <span class="keyword">return</span> existing + 1;
          },
        },
      });
      
      <span class="comment">// Side effects</span>
      <span class="keyword">if</span> (newMessage.sender.id !== currentUserId) {
        <span class="function">playNotificationSound</span>();
        <span class="function">showToast</span>(<span class="string">`New message from </span>${newMessage.sender.name}<span class="string">`</span>);
      }
    },
  });
  
  <span class="comment">// Query for initial + cached data</span>
  <span class="keyword">const</span> { data } = <span class="function">useQuery</span>(<span class="const">GET_MESSAGES</span>, {
    <span class="field">variables</span>: { <span class="field">channelId</span> },
  });

  <span class="keyword">return</span> <span class="keyword">&lt;</span>MessageList messages={data?.messages} <span class="keyword">/&gt;</span>;
}</code></pre>

    <!-- Section 7.8 -->
    <h2>7.8 Handling Connection States</h2>

    <pre><code><span class="keyword">import</span> { <span class="type">useState</span>, <span class="type">useEffect</span> } <span class="keyword">from</span> <span class="string">'react'</span>;

<span class="comment">// Create a connection status hook</span>
<span class="keyword">function</span> <span class="function">useWebSocketStatus</span>(wsClient) {
  <span class="keyword">const</span> [status, setStatus] = <span class="function">useState</span>(<span class="string">'connecting'</span>);
  
  <span class="function">useEffect</span>(() => {
    <span class="keyword">const</span> listeners = {
      <span class="function">connecting</span>: () => <span class="function">setStatus</span>(<span class="string">'connecting'</span>),
      <span class="function">connected</span>: () => <span class="function">setStatus</span>(<span class="string">'connected'</span>),
      <span class="function">closed</span>: () => <span class="function">setStatus</span>(<span class="string">'disconnected'</span>),
      <span class="function">error</span>: () => <span class="function">setStatus</span>(<span class="string">'error'</span>),
    };
    
    <span class="comment">// Register listeners</span>
    Object.<span class="function">entries</span>(listeners).<span class="function">forEach</span>(([event, handler]) => {
      wsClient.<span class="function">on</span>(event, handler);
    });
    
    <span class="keyword">return</span> () => {
      <span class="comment">// Cleanup</span>
      wsClient.<span class="function">dispose</span>();
    };
  }, [wsClient]);
  
  <span class="keyword">return</span> status;
}

<span class="comment">// Use in component</span>
<span class="keyword">function</span> <span class="function">ChatApp</span>() {
  <span class="keyword">const</span> status = <span class="function">useWebSocketStatus</span>(wsClient);
  
  <span class="keyword">return</span> (
    <span class="keyword">&lt;</span>div<span class="keyword">&gt;</span>
      <span class="keyword">&lt;</span>ConnectionIndicator <span class="field">status</span>={status} <span class="keyword">/&gt;</span>
      
      {status === <span class="string">'connected'</span> ? (
        <span class="keyword">&lt;</span>ChatRoom <span class="keyword">/&gt;</span>
      ) : status === <span class="string">'connecting'</span> ? (
        <span class="keyword">&lt;</span>p<span class="keyword">&gt;</span>Connecting to chat...<span class="keyword">&lt;/</span>p<span class="keyword">&gt;</span>
      ) : (
        <span class="keyword">&lt;</span>p<span class="keyword">&gt;</span>Connection lost. Reconnecting...<span class="keyword">&lt;/</span>p<span class="keyword">&gt;</span>
      )}
    <span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>
  );
}</code></pre>

    <!-- Section 7.9 -->
    <h2>7.9 Complete Chat Example</h2>

    <pre><code><span class="comment">// Complete production-ready chat implementation</span>

<span class="keyword">const</span> <span class="const">MESSAGES_QUERY</span> = <span class="function">gql</span><span class="string">`
  query GetMessages($channelId: ID!, $limit: Int!, $before: String) {
    channel(id: $channelId) {
      id
      name
      messages(limit: $limit, before: $before) {
        edges {
          node {
            id
            content
            createdAt
            sender { id name avatar }
          }
        }
        pageInfo {
          hasPreviousPage
          startCursor
        }
      }
    }
  }
`</span>;

<span class="keyword">const</span> <span class="const">MESSAGE_ADDED_SUB</span> = <span class="function">gql</span><span class="string">`
  subscription OnMessageAdded($channelId: ID!) {
    messageAdded(channelId: $channelId) {
      id
      content
      createdAt
      sender { id name avatar }
    }
  }
`</span>;

<span class="keyword">function</span> <span class="function">Chat</span>({ <span class="param">channelId</span> }) {
  <span class="keyword">const</span> messagesEndRef = <span class="function">useRef</span>(<span class="keyword">null</span>);
  
  <span class="keyword">const</span> { data, loading, fetchMore, subscribeToMore } = <span class="function">useQuery</span>(
    <span class="const">MESSAGES_QUERY</span>,
    { <span class="field">variables</span>: { <span class="field">channelId</span>, <span class="field">limit</span>: 50 } }
  );

  <span class="comment">// Subscribe to new messages</span>
  <span class="function">useEffect</span>(() => {
    <span class="keyword">const</span> unsubscribe = <span class="function">subscribeToMore</span>({
      <span class="field">document</span>: <span class="const">MESSAGE_ADDED_SUB</span>,
      <span class="field">variables</span>: { <span class="field">channelId</span> },
      <span class="function">updateQuery</span>: (prev, { subscriptionData }) => {
        <span class="keyword">if</span> (!subscriptionData.data) <span class="keyword">return</span> prev;
        
        <span class="keyword">const</span> newMessage = subscriptionData.data.messageAdded;
        
        <span class="keyword">return</span> {
          ...prev,
          <span class="field">channel</span>: {
            ...prev.channel,
            <span class="field">messages</span>: {
              ...prev.channel.messages,
              <span class="field">edges</span>: [
                ...prev.channel.messages.edges,
                { <span class="field">__typename</span>: <span class="string">'MessageEdge'</span>, <span class="field">node</span>: newMessage },
              ],
            },
          },
        };
      },
    });

    <span class="keyword">return</span> () => <span class="function">unsubscribe</span>();
  }, [channelId, subscribeToMore]);

  <span class="comment">// Auto-scroll on new messages</span>
  <span class="function">useEffect</span>(() => {
    messagesEndRef.current?.<span class="function">scrollIntoView</span>({ <span class="field">behavior</span>: <span class="string">'smooth'</span> });
  }, [data?.channel?.messages?.edges?.length]);

  <span class="comment">// Load older messages</span>
  <span class="keyword">const</span> <span class="function">loadMore</span> = () => {
    <span class="keyword">const</span> { startCursor } = data.channel.messages.pageInfo;
    <span class="function">fetchMore</span>({
      <span class="field">variables</span>: { <span class="field">before</span>: startCursor },
    });
  };

  <span class="keyword">if</span> (loading) <span class="keyword">return</span> <span class="keyword">&lt;</span>ChatSkeleton <span class="keyword">/&gt;</span>;

  <span class="keyword">return</span> (
    <span class="keyword">&lt;</span>div className=<span class="string">"chat"</span><span class="keyword">&gt;</span>
      {data.channel.messages.pageInfo.hasPreviousPage && (
        <span class="keyword">&lt;</span>button <span class="field">onClick</span>={loadMore}<span class="keyword">&gt;</span>Load older messages<span class="keyword">&lt;/</span>button<span class="keyword">&gt;</span>
      )}
      
      {data.channel.messages.edges.<span class="function">map</span>(({ node }) => (
        <span class="keyword">&lt;</span>Message <span class="field">key</span>={node.id} <span class="field">message</span>={node} <span class="keyword">/&gt;</span>
      ))}
      
      <span class="keyword">&lt;</span>div <span class="field">ref</span>={messagesEndRef} <span class="keyword">/&gt;</span>
    <span class="keyword">&lt;/</span>div<span class="keyword">&gt;</span>
  );
}</code></pre>

    <div class="tip-box">
      For production chat apps: (1) Implement message deduplication, (2) Add optimistic sending, (3) Handle offline queueing, (4) Implement read receipts via subscriptions, (5) Use virtualization for long message lists.
    </div>

    <div class="chapter-nav">
      <button class="nav-btn">â† Chapter 6: Fragments</button>
      <button class="nav-btn">Next: Chapter 8 â€” Caching â†’</button>
    </div>
  </div>
</body>
</html>
