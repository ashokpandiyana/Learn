# Chapter 14: Security, Compliance & Hardening

## Introduction to API Security

Security is non-negotiable in production. This chapter covers:
- OWASP Top 10 for APIs
- Security headers
- Input validation and sanitization
- Secrets management
- Compliance considerations (GDPR, HIPAA, PCI-DSS)
- Security auditing

---

## OWASP Top 10 API Security Risks

### 1. Broken Object Level Authorization (BOLA)

```python
# ❌ VULNERABLE: No authorization check
@app.get("/users/{user_id}/orders")
async def get_user_orders(user_id: int):
    # Anyone can access any user's orders!
    orders = db.query(Order).filter(Order.user_id == user_id).all()
    return orders

# ✅ SECURE: Verify user can access resource
@app.get("/users/{user_id}/orders")
async def get_user_orders(
    user_id: int,
    current_user: User = Depends(get_current_user)
):
    # Check authorization
    if current_user.id != user_id and not current_user.is_admin:
        raise HTTPException(
            status_code=403,
            detail="Not authorized to access this resource"
        )
    
    orders = db.query(Order).filter(Order.user_id == user_id).all()
    return orders
```

### 2. Broken Authentication

```python
# ❌ VULNERABLE: Weak token verification
def verify_token(token: str):
    # No expiration check, weak secret
    payload = jwt.decode(token, "secret", algorithms=["HS256"])
    return payload

# ✅ SECURE: Proper token verification
from jose import JWTError, jwt
from datetime import datetime

def verify_token(token: str):
    try:
        payload = jwt.decode(
            token,
            settings.SECRET_KEY,
            algorithms=[settings.ALGORITHM]
        )
        
        # Check expiration
        exp = payload.get("exp")
        if exp and datetime.fromtimestamp(exp) < datetime.now():
            raise HTTPException(status_code=401, detail="Token expired")
        
        return payload
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")
```

### 3. Excessive Data Exposure

```python
# ❌ VULNERABLE: Exposing sensitive data
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    user = db.query(User).filter(User.id == user_id).first()
    # Returns everything including hashed_password, ssn, etc.
    return user

# ✅ SECURE: Use response models to filter data
class UserPublic(BaseModel):
    id: int
    username: str
    email: str
    # Excludes: hashed_password, ssn, internal_notes

@app.get("/users/{user_id}", response_model=UserPublic)
async def get_user(user_id: int):
    user = db.query(User).filter(User.id == user_id).first()
    # Only UserPublic fields are returned
    return user
```

### 4. Lack of Resources & Rate Limiting

```python
# ❌ VULNERABLE: No rate limiting
@app.get("/search")
async def search(q: str):
    # Can be abused for DoS attacks
    results = expensive_search(q)
    return results

# ✅ SECURE: Implement rate limiting
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

@app.get("/search")
@limiter.limit("10/minute")
async def search(request: Request, q: str):
    results = expensive_search(q)
    return results

# Or use dependency
from fastapi import Depends

async def rate_limit_dependency(request: Request):
    """Rate limit as dependency"""
    # Check rate limit using Redis
    client_ip = request.client.host
    key = f"rate_limit:{client_ip}"
    
    count = redis.incr(key)
    if count == 1:
        redis.expire(key, 60)  # 1 minute window
    
    if count > 100:
        raise HTTPException(
            status_code=429,
            detail="Rate limit exceeded",
            headers={"Retry-After": "60"}
        )

@app.get("/api/resource")
async def resource(
    request: Request,
    _: None = Depends(rate_limit_dependency)
):
    return {"data": "protected"}
```

### 5. Broken Function Level Authorization

```python
# ❌ VULNERABLE: No role check
@app.delete("/users/{user_id}")
async def delete_user(user_id: int, current_user: User = Depends(get_current_user)):
    # Any authenticated user can delete any user!
    db.query(User).filter(User.id == user_id).delete()
    return {"message": "User deleted"}

# ✅ SECURE: Check user role
@app.delete("/users/{user_id}")
async def delete_user(
    user_id: int,
    current_user: User = Depends(get_current_user)
):
    # Only admins can delete users
    if not current_user.is_admin:
        raise HTTPException(
            status_code=403,
            detail="Admin privileges required"
        )
    
    # Prevent self-deletion
    if current_user.id == user_id:
        raise HTTPException(
            status_code=400,
            detail="Cannot delete your own account"
        )
    
    db.query(User).filter(User.id == user_id).delete()
    return {"message": "User deleted"}
```

### 6. Mass Assignment

```python
# ❌ VULNERABLE: Accepts any field
class UserUpdate(BaseModel):
    pass  # Empty model accepts everything!

@app.patch("/users/{user_id}")
async def update_user(user_id: int, update_data: dict):
    # User could set is_admin=True, balance=1000000, etc.
    for key, value in update_data.items():
        setattr(user, key, value)

# ✅ SECURE: Explicitly define allowed fields
class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    username: Optional[str] = None
    # Only these fields can be updated
    
    # Explicitly forbid admin fields
    model_config = ConfigDict(extra='forbid')

@app.patch("/users/{user_id}")
async def update_user(user_id: int, update_data: UserUpdate):
    # Only allowed fields are updated
    user = get_user(user_id)
    for field, value in update_data.model_dump(exclude_unset=True).items():
        setattr(user, field, value)
```

### 7. Security Misconfiguration

```python
# ❌ VULNERABLE: Debug mode in production, CORS misconfigured
app = FastAPI(debug=True)  # Shows stack traces!

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allows any origin!
    allow_credentials=True
)

# ✅ SECURE: Proper configuration
from config import get_settings

settings = get_settings()

app = FastAPI(
    debug=settings.DEBUG,  # False in production
    docs_url="/docs" if settings.DEBUG else None,  # Hide docs
    redoc_url="/redoc" if settings.DEBUG else None
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,  # Specific origins only
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"]
)
```

### 8. Injection

```python
# ❌ VULNERABLE: SQL Injection
@app.get("/users")
async def search_users(username: str):
    # SQL injection vulnerability!
    query = f"SELECT * FROM users WHERE username = '{username}'"
    results = db.execute(query)

# ✅ SECURE: Use parameterized queries
@app.get("/users")
async def search_users(username: str, db: Session = Depends(get_db)):
    # SQLAlchemy automatically parameterizes
    results = db.query(User).filter(User.username == username).all()
    return results

# ❌ VULNERABLE: Command Injection
import subprocess

@app.get("/ping")
async def ping(host: str):
    # Command injection vulnerability!
    result = subprocess.run(f"ping -c 1 {host}", shell=True)

# ✅ SECURE: Validate input and avoid shell=True
import re

@app.get("/ping")
async def ping(host: str):
    # Validate hostname format
    if not re.match(r'^[a-zA-Z0-9.-]+$', host):
        raise HTTPException(status_code=400, detail="Invalid hostname")
    
    # Don't use shell=True
    result = subprocess.run(["ping", "-c", "1", host], capture_output=True)
    return {"output": result.stdout.decode()}
```

### 9. Improper Assets Management

```python
# ❌ VULNERABLE: Old API versions still active
@app.get("/api/v1/users")  # Vulnerable old version
async def get_users_v1():
    return db.query(User).all()  # Returns all data

@app.get("/api/v2/users")  # New secure version
async def get_users_v2(current_user: User = Depends(get_current_user)):
    return filtered_users()

# ✅ SECURE: Deprecate and remove old versions
@app.get("/api/v1/users", deprecated=True)
async def get_users_v1():
    raise HTTPException(
        status_code=410,
        detail="This endpoint has been removed. Use /api/v2/users"
    )

@app.get("/api/v2/users")
async def get_users_v2(current_user: User = Depends(get_current_user)):
    return filtered_users()
```

### 10. Insufficient Logging & Monitoring

```python
# ❌ VULNERABLE: No logging
@app.post("/login")
async def login(credentials: Credentials):
    user = authenticate(credentials)
    # No logging of failed attempts, successful logins, etc.
    return {"token": generate_token(user)}

# ✅ SECURE: Comprehensive logging
import logging

logger = logging.getLogger(__name__)

@app.post("/login")
async def login(credentials: Credentials, request: Request):
    client_ip = request.client.host
    
    try:
        user = authenticate(credentials)
        
        # Log successful login
        logger.info(
            "Login successful",
            extra={
                "user_id": user.id,
                "username": credentials.username,
                "ip": client_ip,
                "timestamp": datetime.now()
            }
        )
        
        return {"token": generate_token(user)}
        
    except AuthenticationError:
        # Log failed attempt
        logger.warning(
            "Login failed",
            extra={
                "username": credentials.username,
                "ip": client_ip,
                "timestamp": datetime.now()
            }
        )
        
        # Check for brute force
        failed_attempts = redis.incr(f"failed_login:{client_ip}")
        if failed_attempts > 5:
            logger.critical(
                "Possible brute force attack",
                extra={"ip": client_ip}
            )
        
        raise HTTPException(status_code=401, detail="Invalid credentials")
```

---

## Security Headers

### Implementing Security Headers

```python
from fastapi import FastAPI
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from starlette.middleware.sessions import SessionMiddleware

app = FastAPI()

# Add trusted host middleware
app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=["example.com", "*.example.com"]
)

# Session middleware with secure settings
app.add_middleware(
    SessionMiddleware,
    secret_key=settings.SECRET_KEY,
    session_cookie="session",
    max_age=3600,
    same_site="lax",
    https_only=True  # Only over HTTPS
)

# Security headers middleware
@app.middleware("http")
async def add_security_headers(request: Request, call_next):
    response = await call_next(request)
    
    # Prevent clickjacking
    response.headers["X-Frame-Options"] = "DENY"
    
    # Prevent MIME sniffing
    response.headers["X-Content-Type-Options"] = "nosniff"
    
    # XSS Protection (legacy but still useful)
    response.headers["X-XSS-Protection"] = "1; mode=block"
    
    # HSTS - Force HTTPS
    response.headers["Strict-Transport-Security"] = \
        "max-age=31536000; includeSubDomains; preload"
    
    # Content Security Policy
    response.headers["Content-Security-Policy"] = \
        "default-src 'self'; " \
        "script-src 'self' 'unsafe-inline'; " \
        "style-src 'self' 'unsafe-inline'; " \
        "img-src 'self' data: https:; " \
        "font-src 'self'; " \
        "connect-src 'self'; " \
        "frame-ancestors 'none'"
    
    # Referrer Policy
    response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
    
    # Permissions Policy (formerly Feature Policy)
    response.headers["Permissions-Policy"] = \
        "geolocation=(), microphone=(), camera=()"
    
    return response
```

---

## Input Validation & Sanitization

### Comprehensive Input Validation

```python
from pydantic import BaseModel, field_validator, Field
import bleach  # uv pip install bleach
import re

class UserInput(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    email: EmailStr
    bio: str = Field(..., max_length=500)
    website: Optional[HttpUrl] = None
    
    @field_validator('username')
    @classmethod
    def validate_username(cls, v):
        # Only allow alphanumeric and underscore
        if not re.match(r'^[a-zA-Z0-9_]+$', v):
            raise ValueError('Username must be alphanumeric')
        
        # Check against reserved words
        reserved = ['admin', 'root', 'system', 'api']
        if v.lower() in reserved:
            raise ValueError('Username not available')
        
        return v
    
    @field_validator('bio')
    @classmethod
    def sanitize_bio(cls, v):
        # Remove potentially dangerous HTML
        allowed_tags = ['p', 'br', 'strong', 'em']
        sanitized = bleach.clean(v, tags=allowed_tags, strip=True)
        return sanitized
    
    @field_validator('website')
    @classmethod
    def validate_website(cls, v):
        if v and not str(v).startswith(('http://', 'https://')):
            raise ValueError('Website must start with http:// or https://')
        return v
```

### File Upload Validation

```python
from fastapi import UploadFile, File, HTTPException
import magic  # uv pip install python-magic
from pathlib import Path

ALLOWED_EXTENSIONS = {'.jpg', '.jpeg', '.png', '.gif', '.pdf'}
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB

async def validate_file(file: UploadFile):
    """Validate uploaded file"""
    
    # Check file extension
    file_ext = Path(file.filename).suffix.lower()
    if file_ext not in ALLOWED_EXTENSIONS:
        raise HTTPException(
            status_code=400,
            detail=f"File type {file_ext} not allowed"
        )
    
    # Check file size
    content = await file.read()
    if len(content) > MAX_FILE_SIZE:
        raise HTTPException(
            status_code=400,
            detail="File too large"
        )
    
    # Verify actual file type (not just extension)
    mime = magic.from_buffer(content, mime=True)
    allowed_mimes = [
        'image/jpeg', 'image/png', 'image/gif',
        'application/pdf'
    ]
    if mime not in allowed_mimes:
        raise HTTPException(
            status_code=400,
            detail="Invalid file type"
        )
    
    # Reset file pointer
    await file.seek(0)
    
    return file

@app.post("/upload")
async def upload_file(file: UploadFile = File(...)):
    """Upload file with validation"""
    validated_file = await validate_file(file)
    
    # Generate safe filename
    import uuid
    safe_filename = f"{uuid.uuid4()}{Path(file.filename).suffix}"
    
    # Save file
    file_path = Path("uploads") / safe_filename
    with open(file_path, "wb") as f:
        f.write(await validated_file.read())
    
    return {"filename": safe_filename}
```

---

## Secrets Management

### Using Environment Variables

```python
# ❌ BAD: Hardcoded secrets
DATABASE_URL = "postgresql://user:password123@localhost/db"
SECRET_KEY = "super-secret-key-123"
AWS_ACCESS_KEY = "AKIAIOSFODNN7EXAMPLE"

# ✅ GOOD: Environment variables
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    DATABASE_URL: str
    SECRET_KEY: str
    AWS_ACCESS_KEY_ID: str
    AWS_SECRET_ACCESS_KEY: str
    
    class Config:
        env_file = ".env"
        case_sensitive = True

settings = Settings()
```

### AWS Secrets Manager Integration

```bash
uv pip install boto3
```

```python
# secrets.py
import boto3
import json
from functools import lru_cache

@lru_cache()
def get_secret(secret_name: str) -> dict:
    """Get secret from AWS Secrets Manager"""
    client = boto3.client('secretsmanager', region_name='us-east-1')
    
    try:
        response = client.get_secret_value(SecretId=secret_name)
        return json.loads(response['SecretString'])
    except Exception as e:
        logger.error(f"Error fetching secret: {e}")
        raise

# Usage
database_credentials = get_secret("prod/database")
DATABASE_URL = database_credentials["connection_string"]
```

### HashiCorp Vault Integration

```bash
uv pip install hvac
```

```python
# vault.py
import hvac
from functools import lru_cache

@lru_cache()
def get_vault_client():
    """Initialize Vault client"""
    client = hvac.Client(url='https://vault.example.com')
    client.auth.approle.login(
        role_id='your-role-id',
        secret_id='your-secret-id'
    )
    return client

def get_vault_secret(path: str) -> dict:
    """Get secret from Vault"""
    client = get_vault_client()
    response = client.secrets.kv.v2.read_secret_version(path=path)
    return response['data']['data']

# Usage
db_secrets = get_vault_secret('database/credentials')
```

---

## Compliance Considerations

### GDPR Compliance

```python
from datetime import datetime, timedelta

class GDPRCompliance:
    """GDPR compliance utilities"""
    
    @staticmethod
    async def export_user_data(user_id: int, db: Session) -> dict:
        """
        Right to data portability (Art. 20)
        User can request all their data
        """
        user = db.query(User).filter(User.id == user_id).first()
        orders = db.query(Order).filter(Order.user_id == user_id).all()
        
        return {
            "personal_data": {
                "email": user.email,
                "name": user.full_name,
                "created_at": user.created_at.isoformat()
            },
            "orders": [order.to_dict() for order in orders],
            "export_date": datetime.now().isoformat()
        }
    
    @staticmethod
    async def delete_user_data(user_id: int, db: Session):
        """
        Right to erasure (Art. 17)
        Hard delete or anonymize user data
        """
        user = db.query(User).filter(User.id == user_id).first()
        
        # Anonymize instead of delete (for legal records)
        user.email = f"deleted_{user_id}@example.com"
        user.full_name = "Deleted User"
        user.phone = None
        user.address = None
        user.deleted_at = datetime.now()
        
        db.commit()
    
    @staticmethod
    async def delete_old_data(db: Session):
        """
        Data minimization (Art. 5)
        Delete data older than retention period
        """
        retention_period = timedelta(days=365 * 7)  # 7 years
        cutoff_date = datetime.now() - retention_period
        
        # Delete old logs
        db.query(AuditLog).filter(
            AuditLog.created_at < cutoff_date
        ).delete()
        
        db.commit()
```

### PCI-DSS Compliance (Payment Cards)

```python
# ❌ NEVER store credit card data directly
class Payment(BaseModel):
    card_number: str  # NEVER DO THIS!
    cvv: str  # NEVER DO THIS!
    expiry: str

# ✅ Use payment processor tokens
class Payment(BaseModel):
    payment_token: str  # Token from Stripe/PayPal
    amount: Decimal
    currency: str = "USD"

@app.post("/payments")
async def process_payment(payment: Payment):
    # Use payment processor's API
    result = stripe.charge.create(
        amount=int(payment.amount * 100),
        currency=payment.currency,
        source=payment.payment_token
    )
    
    # Store only non-sensitive data
    db_payment = PaymentRecord(
        user_id=current_user.id,
        amount=payment.amount,
        payment_processor_id=result.id,
        last_four=result.card.last4  # Only last 4 digits
    )
    
    return {"status": "success"}
```

### HIPAA Compliance (Healthcare)

```python
class HIPAACompliance:
    """HIPAA compliance utilities"""
    
    @staticmethod
    def encrypt_phi(data: str) -> str:
        """Encrypt Protected Health Information"""
        from cryptography.fernet import Fernet
        
        key = get_encryption_key()
        f = Fernet(key)
        return f.encrypt(data.encode()).decode()
    
    @staticmethod
    def audit_log_access(user_id: int, resource: str, action: str):
        """
        HIPAA requires audit logging of all PHI access
        """
        AuditLog.create(
            user_id=user_id,
            resource=resource,
            action=action,
            timestamp=datetime.now(),
            ip_address=request.client.host
        )
    
    @staticmethod
    async def verify_minimum_necessary(
        user: User,
        requested_data: List[str]
    ) -> bool:
        """
        Minimum necessary standard
        Only provide data needed for job function
        """
        user_role_permissions = get_role_permissions(user.role)
        
        for field in requested_data:
            if field not in user_role_permissions:
                return False
        
        return True
```

---

## Security Auditing

### Security Audit Logging

```python
from enum import Enum
from datetime import datetime

class AuditEventType(str, Enum):
    LOGIN_SUCCESS = "login_success"
    LOGIN_FAILURE = "login_failure"
    LOGOUT = "logout"
    PASSWORD_CHANGE = "password_change"
    DATA_ACCESS = "data_access"
    DATA_MODIFICATION = "data_modification"
    PERMISSION_CHANGE = "permission_change"
    SECURITY_VIOLATION = "security_violation"

class SecurityAuditLog:
    """Security audit logging"""
    
    @staticmethod
    def log_event(
        event_type: AuditEventType,
        user_id: Optional[int],
        ip_address: str,
        details: dict
    ):
        """Log security event"""
        log_entry = AuditLog(
            event_type=event_type,
            user_id=user_id,
            ip_address=ip_address,
            timestamp=datetime.now(),
            details=json.dumps(details)
        )
        
        db.add(log_entry)
        db.commit()
        
        # Also log to external system
        if event_type == AuditEventType.SECURITY_VIOLATION:
            send_alert_to_security_team(log_entry)

# Usage in endpoints
@app.post("/login")
async def login(credentials: Credentials, request: Request):
    try:
        user = authenticate(credentials)
        
        SecurityAuditLog.log_event(
            event_type=AuditEventType.LOGIN_SUCCESS,
            user_id=user.id,
            ip_address=request.client.host,
            details={"username": credentials.username}
        )
        
        return {"token": generate_token(user)}
        
    except AuthenticationError:
        SecurityAuditLog.log_event(
            event_type=AuditEventType.LOGIN_FAILURE,
            user_id=None,
            ip_address=request.client.host,
            details={"username": credentials.username}
        )
        
        raise HTTPException(status_code=401)
```

---

## Summary

In Chapter 14, you learned:
- OWASP Top 10 API Security Risks and mitigations
- Security headers implementation
- Comprehensive input validation and sanitization
- Secrets management strategies
- Compliance considerations (GDPR, PCI-DSS, HIPAA)
- Security audit logging

**Security Checklist:**
- ✅ Implement proper authorization checks (BOLA)
- ✅ Use strong authentication (JWT with expiration)
- ✅ Filter sensitive data (response models)
- ✅ Implement rate limiting
- ✅ Check function-level authorization (roles)
- ✅ Prevent mass assignment attacks
- ✅ Proper security configuration
- ✅ Prevent injection attacks
- ✅ Deprecate old API versions
- ✅ Comprehensive logging and monitoring
- ✅ Add security headers
- ✅ Validate and sanitize all input
- ✅ Never store secrets in code
- ✅ Consider compliance requirements
- ✅ Implement audit logging

**Next: Chapter 15 - Real-World Architectures & Patterns**