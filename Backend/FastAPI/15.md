# Chapter 15: Real-World Architectures & Patterns

## Introduction to Software Architecture

This chapter covers production-grade architectures:
- Clean Architecture and Domain-Driven Design
- Microservices patterns
- Event-driven architecture
- Frontend integration
- Real-world design patterns

---

## Clean Architecture with FastAPI

### Layered Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Presentation Layer              â”‚
â”‚  (FastAPI Routes, Controllers)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Application Layer               â”‚
â”‚  (Use Cases, Business Logic)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Domain Layer                    â”‚
â”‚  (Entities, Value Objects, Rules)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Infrastructure Layer            â”‚
â”‚  (Database, External APIs, Cache)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Project Structure

```
app/
â”œâ”€â”€ api/                    # Presentation Layer
â”‚   â”œâ”€â”€ v1/
â”‚   â”‚   â”œâ”€â”€ endpoints/
â”‚   â”‚   â”‚   â”œâ”€â”€ users.py
â”‚   â”‚   â”‚   â”œâ”€â”€ orders.py
â”‚   â”‚   â”‚   â””â”€â”€ products.py
â”‚   â”‚   â””â”€â”€ router.py
â”‚   â””â”€â”€ dependencies.py
â”‚
â”œâ”€â”€ application/            # Application Layer
â”‚   â”œâ”€â”€ use_cases/
â”‚   â”‚   â”œâ”€â”€ user/
â”‚   â”‚   â”‚   â”œâ”€â”€ create_user.py
â”‚   â”‚   â”‚   â”œâ”€â”€ update_user.py
â”‚   â”‚   â”‚   â””â”€â”€ delete_user.py
â”‚   â”‚   â””â”€â”€ order/
â”‚   â”‚       â”œâ”€â”€ create_order.py
â”‚   â”‚       â””â”€â”€ cancel_order.py
â”‚   â””â”€â”€ services/
â”‚       â”œâ”€â”€ email_service.py
â”‚       â””â”€â”€ notification_service.py
â”‚
â”œâ”€â”€ domain/                 # Domain Layer
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”œâ”€â”€ user.py
â”‚   â”‚   â”œâ”€â”€ order.py
â”‚   â”‚   â””â”€â”€ product.py
â”‚   â”œâ”€â”€ value_objects/
â”‚   â”‚   â”œâ”€â”€ email.py
â”‚   â”‚   â”œâ”€â”€ money.py
â”‚   â”‚   â””â”€â”€ address.py
â”‚   â”œâ”€â”€ repositories/       # Interfaces
â”‚   â”‚   â”œâ”€â”€ user_repository.py
â”‚   â”‚   â””â”€â”€ order_repository.py
â”‚   â””â”€â”€ events/
â”‚       â”œâ”€â”€ user_created.py
â”‚       â””â”€â”€ order_placed.py
â”‚
â””â”€â”€ infrastructure/         # Infrastructure Layer
    â”œâ”€â”€ database/
    â”‚   â”œâ”€â”€ models.py
    â”‚   â”œâ”€â”€ repositories/   # Implementations
    â”‚   â”‚   â”œâ”€â”€ user_repository_impl.py
    â”‚   â”‚   â””â”€â”€ order_repository_impl.py
    â”‚   â””â”€â”€ session.py
    â”œâ”€â”€ external/
    â”‚   â”œâ”€â”€ payment_gateway.py
    â”‚   â””â”€â”€ email_provider.py
    â””â”€â”€ cache/
        â””â”€â”€ redis_cache.py
```

### Domain Layer Example

```python
# domain/entities/order.py
from dataclasses import dataclass
from typing import List
from datetime import datetime
from enum import Enum

class OrderStatus(str, Enum):
    PENDING = "pending"
    CONFIRMED = "confirmed"
    SHIPPED = "shipped"
    DELIVERED = "delivered"
    CANCELLED = "cancelled"

@dataclass
class OrderItem:
    """Value object for order item"""
    product_id: int
    quantity: int
    price: float
    
    def total_price(self) -> float:
        return self.quantity * self.price

class Order:
    """Domain entity for orders"""
    
    def __init__(
        self,
        order_id: int,
        user_id: int,
        items: List[OrderItem],
        status: OrderStatus = OrderStatus.PENDING
    ):
        self.order_id = order_id
        self.user_id = user_id
        self.items = items
        self.status = status
        self.created_at = datetime.now()
        self.updated_at = datetime.now()
    
    def calculate_total(self) -> float:
        """Business logic in domain entity"""
        return sum(item.total_price() for item in self.items)
    
    def confirm(self):
        """Business rule: Can only confirm pending orders"""
        if self.status != OrderStatus.PENDING:
            raise ValueError(f"Cannot confirm order with status {self.status}")
        self.status = OrderStatus.CONFIRMED
        self.updated_at = datetime.now()
    
    def cancel(self):
        """Business rule: Cannot cancel shipped/delivered orders"""
        if self.status in [OrderStatus.SHIPPED, OrderStatus.DELIVERED]:
            raise ValueError(f"Cannot cancel order with status {self.status}")
        self.status = OrderStatus.CANCELLED
        self.updated_at = datetime.now()

# domain/repositories/order_repository.py
from abc import ABC, abstractmethod
from typing import List, Optional

class OrderRepository(ABC):
    """Repository interface (dependency inversion)"""
    
    @abstractmethod
    def create(self, order: Order) -> Order:
        pass
    
    @abstractmethod
    def get_by_id(self, order_id: int) -> Optional[Order]:
        pass
    
    @abstractmethod
    def get_by_user(self, user_id: int) -> List[Order]:
        pass
    
    @abstractmethod
    def update(self, order: Order) -> Order:
        pass
```

### Application Layer (Use Cases)

```python
# application/use_cases/order/create_order.py
from domain.entities.order import Order, OrderItem
from domain.repositories.order_repository import OrderRepository
from application.services.notification_service import NotificationService

class CreateOrderUseCase:
    """Use case for creating orders"""
    
    def __init__(
        self,
        order_repository: OrderRepository,
        notification_service: NotificationService
    ):
        self.order_repository = order_repository
        self.notification_service = notification_service
    
    async def execute(
        self,
        user_id: int,
        items: List[dict]
    ) -> Order:
        """
        Business logic for creating an order
        1. Validate items
        2. Create order entity
        3. Save to database
        4. Send notifications
        """
        # Convert to domain objects
        order_items = [
            OrderItem(
                product_id=item["product_id"],
                quantity=item["quantity"],
                price=item["price"]
            )
            for item in items
        ]
        
        # Create domain entity
        order = Order(
            order_id=None,  # Will be set by repository
            user_id=user_id,
            items=order_items
        )
        
        # Validate business rules
        if order.calculate_total() < 0:
            raise ValueError("Order total cannot be negative")
        
        # Save order
        saved_order = await self.order_repository.create(order)
        
        # Send notification (side effect)
        await self.notification_service.send_order_confirmation(
            user_id, saved_order.order_id
        )
        
        return saved_order

# application/use_cases/order/cancel_order.py
class CancelOrderUseCase:
    """Use case for canceling orders"""
    
    def __init__(
        self,
        order_repository: OrderRepository,
        notification_service: NotificationService
    ):
        self.order_repository = order_repository
        self.notification_service = notification_service
    
    async def execute(self, order_id: int, user_id: int):
        """Cancel order with authorization check"""
        # Get order
        order = await self.order_repository.get_by_id(order_id)
        if not order:
            raise ValueError("Order not found")
        
        # Authorization check
        if order.user_id != user_id:
            raise PermissionError("Not authorized to cancel this order")
        
        # Business logic (in domain entity)
        order.cancel()
        
        # Save changes
        await self.order_repository.update(order)
        
        # Notify user
        await self.notification_service.send_cancellation_notice(user_id, order_id)
```

### Infrastructure Layer (Implementation)

```python
# infrastructure/database/repositories/order_repository_impl.py
from sqlalchemy.orm import Session
from typing import List, Optional
from domain.repositories.order_repository import OrderRepository
from domain.entities.order import Order
from infrastructure.database.models import OrderModel

class OrderRepositoryImpl(OrderRepository):
    """SQLAlchemy implementation of OrderRepository"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def create(self, order: Order) -> Order:
        """Convert domain entity to database model"""
        db_order = OrderModel(
            user_id=order.user_id,
            status=order.status.value,
            total=order.calculate_total(),
            created_at=order.created_at
        )
        
        # Add items
        for item in order.items:
            db_item = OrderItemModel(
                product_id=item.product_id,
                quantity=item.quantity,
                price=item.price
            )
            db_order.items.append(db_item)
        
        self.db.add(db_order)
        self.db.commit()
        self.db.refresh(db_order)
        
        # Convert back to domain entity
        return self._to_domain(db_order)
    
    def get_by_id(self, order_id: int) -> Optional[Order]:
        db_order = self.db.query(OrderModel).filter(
            OrderModel.id == order_id
        ).first()
        
        if not db_order:
            return None
        
        return self._to_domain(db_order)
    
    def _to_domain(self, db_order: OrderModel) -> Order:
        """Convert database model to domain entity"""
        items = [
            OrderItem(
                product_id=item.product_id,
                quantity=item.quantity,
                price=item.price
            )
            for item in db_order.items
        ]
        
        return Order(
            order_id=db_order.id,
            user_id=db_order.user_id,
            items=items,
            status=OrderStatus(db_order.status)
        )
```

### Presentation Layer (FastAPI Routes)

```python
# api/v1/endpoints/orders.py
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from typing import List

from application.use_cases.order.create_order import CreateOrderUseCase
from application.use_cases.order.cancel_order import CancelOrderUseCase
from api.dependencies import get_create_order_use_case, get_current_user

router = APIRouter(prefix="/orders", tags=["orders"])

class OrderItemRequest(BaseModel):
    product_id: int
    quantity: int
    price: float

class CreateOrderRequest(BaseModel):
    items: List[OrderItemRequest]

@router.post("/", status_code=201)
async def create_order(
    request: CreateOrderRequest,
    current_user: User = Depends(get_current_user),
    use_case: CreateOrderUseCase = Depends(get_create_order_use_case)
):
    """
    Create new order
    Route delegates to use case - no business logic here
    """
    try:
        order = await use_case.execute(
            user_id=current_user.id,
            items=[item.model_dump() for item in request.items]
        )
        return {"order_id": order.order_id, "total": order.calculate_total()}
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/{order_id}/cancel")
async def cancel_order(
    order_id: int,
    current_user: User = Depends(get_current_user),
    use_case: CancelOrderUseCase = Depends(get_cancel_order_use_case)
):
    """Cancel order"""
    try:
        await use_case.execute(order_id, current_user.id)
        return {"message": "Order cancelled"}
    except PermissionError:
        raise HTTPException(status_code=403, detail="Not authorized")
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

# api/dependencies.py
from infrastructure.database.repositories.order_repository_impl import OrderRepositoryImpl
from application.services.notification_service import NotificationService

def get_create_order_use_case(
    db: Session = Depends(get_db)
) -> CreateOrderUseCase:
    """Dependency injection for use case"""
    order_repo = OrderRepositoryImpl(db)
    notification_service = NotificationService()
    return CreateOrderUseCase(order_repo, notification_service)
```

---

## Microservices with FastAPI

### Service-to-Service Communication

```python
# services/user_service/main.py
from fastapi import FastAPI

app = FastAPI(title="User Service")

@app.get("/users/{user_id}")
async def get_user(user_id: int):
    return {"id": user_id, "name": "John Doe"}

# services/order_service/main.py
from fastapi import FastAPI
import httpx

app = FastAPI(title="Order Service")

USER_SERVICE_URL = "http://user-service:8000"

@app.post("/orders")
async def create_order(order_data: dict, user_id: int):
    # Call user service
    async with httpx.AsyncClient() as client:
        response = await client.get(f"{USER_SERVICE_URL}/users/{user_id}")
        user = response.json()
    
    # Create order logic
    return {"order": order_data, "user": user}
```

### API Gateway Pattern

```python
# gateway/main.py
from fastapi import FastAPI, HTTPException
import httpx

app = FastAPI(title="API Gateway")

# Service registry
SERVICES = {
    "users": "http://user-service:8000",
    "orders": "http://order-service:8001",
    "products": "http://product-service:8002"
}

@app.api_route("/{service}/{path:path}", methods=["GET", "POST", "PUT", "DELETE"])
async def gateway(service: str, path: str, request: Request):
    """Route requests to appropriate microservice"""
    
    if service not in SERVICES:
        raise HTTPException(status_code=404, detail="Service not found")
    
    service_url = f"{SERVICES[service]}/{path}"
    
    async with httpx.AsyncClient() as client:
        # Forward request
        response = await client.request(
            method=request.method,
            url=service_url,
            headers=dict(request.headers),
            content=await request.body()
        )
        
        return Response(
            content=response.content,
            status_code=response.status_code,
            headers=dict(response.headers)
        )
```

### Service Discovery with Consul

```python
# service_discovery.py
import consul
from typing import Optional

class ServiceDiscovery:
    """Service discovery using Consul"""
    
    def __init__(self):
        self.consul = consul.Consul(host='consul', port=8500)
    
    def register_service(self, name: str, port: int):
        """Register service with Consul"""
        self.consul.agent.service.register(
            name=name,
            service_id=f"{name}-{port}",
            address="localhost",
            port=port,
            check={
                "http": f"http://localhost:{port}/health",
                "interval": "10s"
            }
        )
    
    def get_service(self, name: str) -> Optional[str]:
        """Get service URL from Consul"""
        _, services = self.consul.health.service(name, passing=True)
        
        if not services:
            return None
        
        # Round-robin or random selection
        service = services[0]['Service']
        return f"http://{service['Address']}:{service['Port']}"

# Usage in microservice
@app.on_event("startup")
async def startup():
    sd = ServiceDiscovery()
    sd.register_service("user-service", 8000)
```

---

## Event-Driven Architecture

### Message Queue with RabbitMQ

```bash
uv pip install aio-pika
```

```python
# events/publisher.py
import aio_pika
import json

class EventPublisher:
    """Publish events to message queue"""
    
    def __init__(self, rabbitmq_url: str):
        self.url = rabbitmq_url
        self.connection = None
        self.channel = None
    
    async def connect(self):
        self.connection = await aio_pika.connect_robust(self.url)
        self.channel = await self.connection.channel()
    
    async def publish(self, event_type: str, data: dict):
        """Publish event to exchange"""
        exchange = await self.channel.declare_exchange(
            'events',
            aio_pika.ExchangeType.TOPIC,
            durable=True
        )
        
        message = aio_pika.Message(
            body=json.dumps(data).encode(),
            content_type='application/json',
            delivery_mode=aio_pika.DeliveryMode.PERSISTENT
        )
        
        await exchange.publish(message, routing_key=event_type)

# events/subscriber.py
class EventSubscriber:
    """Subscribe to events from message queue"""
    
    def __init__(self, rabbitmq_url: str):
        self.url = rabbitmq_url
        self.connection = None
        self.channel = None
    
    async def connect(self):
        self.connection = await aio_pika.connect_robust(self.url)
        self.channel = await self.connection.channel()
    
    async def subscribe(self, event_type: str, handler):
        """Subscribe to specific event type"""
        exchange = await self.channel.declare_exchange(
            'events',
            aio_pika.ExchangeType.TOPIC,
            durable=True
        )
        
        queue = await self.channel.declare_queue('', exclusive=True)
        await queue.bind(exchange, routing_key=event_type)
        
        async def on_message(message: aio_pika.IncomingMessage):
            async with message.process():
                data = json.loads(message.body.decode())
                await handler(data)
        
        await queue.consume(on_message)

# Usage in service
# Order service publishes event
publisher = EventPublisher("amqp://guest:guest@rabbitmq/")
await publisher.connect()

@app.post("/orders")
async def create_order(order_data: dict):
    # Create order
    order = create_order_in_db(order_data)
    
    # Publish event
    await publisher.publish(
        'order.created',
        {
            "order_id": order.id,
            "user_id": order.user_id,
            "total": order.total
        }
    )
    
    return order

# Email service subscribes to event
subscriber = EventSubscriber("amqp://guest:guest@rabbitmq/")
await subscriber.connect()

async def handle_order_created(data: dict):
    """Handle order created event"""
    send_order_confirmation_email(
        user_id=data['user_id'],
        order_id=data['order_id']
    )

await subscriber.subscribe('order.created', handle_order_created)
```

### Event Sourcing Pattern

```python
# events/event_store.py
from datetime import datetime
from typing import List
import json

class Event:
    """Base event class"""
    def __init__(self, event_type: str, data: dict):
        self.event_type = event_type
        self.data = data
        self.timestamp = datetime.now()
        self.event_id = generate_uuid()

class EventStore:
    """Store and retrieve events"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def append(self, aggregate_id: str, event: Event):
        """Append event to aggregate stream"""
        event_record = EventRecord(
            aggregate_id=aggregate_id,
            event_type=event.event_type,
            event_data=json.dumps(event.data),
            timestamp=event.timestamp
        )
        self.db.add(event_record)
        self.db.commit()
    
    def get_events(self, aggregate_id: str) -> List[Event]:
        """Get all events for aggregate"""
        records = self.db.query(EventRecord).filter(
            EventRecord.aggregate_id == aggregate_id
        ).order_by(EventRecord.timestamp).all()
        
        return [
            Event(r.event_type, json.loads(r.event_data))
            for r in records
        ]
    
    def rebuild_aggregate(self, aggregate_id: str):
        """Rebuild aggregate state from events"""
        events = self.get_events(aggregate_id)
        
        # Start with empty state
        state = {}
        
        # Apply each event
        for event in events:
            state = apply_event(state, event)
        
        return state
```

---

## Frontend Integration

### CORS Configuration for SPAs

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

# Development CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # React dev server
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Production CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://example.com",
        "https://www.example.com"
    ],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH"],
    allow_headers=["Content-Type", "Authorization"],
)
```

### WebSocket Integration

```python
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from typing import List

app = FastAPI()

class ConnectionManager:
    """Manage WebSocket connections"""
    
    def __init__(self):
        self.active_connections: List[WebSocket] = []
    
    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
    
    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)
    
    async def broadcast(self, message: str):
        """Send message to all connected clients"""
        for connection in self.active_connections:
            await connection.send_text(message)

manager = ConnectionManager()

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            # Broadcast to all clients
            await manager.broadcast(f"Message: {data}")
    except WebSocketDisconnect:
        manager.disconnect(websocket)
        await manager.broadcast("Client disconnected")
```

### GraphQL Integration

```bash
uv pip install strawberry-graphql
```

```python
# graphql_schema.py
import strawberry
from typing import List

@strawberry.type
class User:
    id: int
    name: str
    email: str

@strawberry.type
class Query:
    @strawberry.field
    def user(self, id: int) -> User:
        return get_user_from_db(id)
    
    @strawberry.field
    def users(self) -> List[User]:
        return get_all_users_from_db()

@strawberry.type
class Mutation:
    @strawberry.mutation
    def create_user(self, name: str, email: str) -> User:
        return create_user_in_db(name, email)

schema = strawberry.Schema(query=Query, mutation=Mutation)

# main.py
from strawberry.fastapi import GraphQLRouter

graphql_app = GraphQLRouter(schema)
app.include_router(graphql_app, prefix="/graphql")
```

---

## Complete Production Example

```python
# main.py - Production-ready application
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from contextlib import asynccontextmanager
import logging

from config import get_settings
from api.v1.router import api_router
from core.logging import setup_logging
from core.exceptions import setup_exception_handlers

# Setup
settings = get_settings()
setup_logging()
logger = logging.getLogger(__name__)

# Lifespan
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    logger.info("Starting application")
    
    # Initialize services
    await init_database()
    await init_redis()
    await init_message_queue()
    
    yield
    
    # Shutdown
    logger.info("Shutting down application")
    await close_database()
    await close_redis()

# Create app
app = FastAPI(
    title=settings.APP_NAME,
    version="1.0.0",
    lifespan=lifespan,
    docs_url="/docs" if settings.DEBUG else None,
    redoc_url="/redoc" if settings.DEBUG else None
)

# Middleware
app.add_middleware(GZipMiddleware, minimum_size=1000)
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"]
)

# Exception handlers
setup_exception_handlers(app)

# Routers
app.include_router(api_router, prefix="/api/v1")

# Health check
@app.get("/health")
async def health():
    return {"status": "healthy"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "main:app",
        host=settings.HOST,
        port=settings.PORT,
        reload=settings.DEBUG
    )
```

---

## Summary

In Chapter 15, you learned:
- Clean Architecture with separated layers
- Domain-Driven Design patterns
- Microservices architecture
- Service-to-service communication
- API Gateway pattern
- Event-driven architecture with message queues
- Event sourcing pattern
- Frontend integration (CORS, WebSocket, GraphQL)
- Complete production-ready example

**Architecture Principles:**
- âœ… Separation of concerns
- âœ… Dependency inversion
- âœ… Single responsibility
- âœ… Domain-driven design
- âœ… Microservices when needed
- âœ… Event-driven communication
- âœ… Stateless design
- âœ… API versioning
- âœ… Health checks
- âœ… Monitoring and logging

**Congratulations!** ðŸŽ‰ You've completed all 15 chapters of the FastAPI Complete Learning Roadmap. You now have comprehensive knowledge to build production-ready, scalable, secure FastAPI applications with proper architecture and design patterns!