# Chapter 4: Dependency Injection in Depth

## Introduction to Dependency Injection

Dependency Injection (DI) is one of FastAPI's most powerful features. It allows you to:
- **Write reusable code**: Share logic across multiple endpoints
- **Improve testability**: Easily mock dependencies in tests
- **Manage resources**: Database sessions, auth, caching, etc.
- **Reduce coupling**: Separate concerns cleanly

**Key Concept**: Dependencies are functions that run before your path operation function and can pass data to it.

---

## Basic Dependencies

### Simple Function Dependencies

```python
from fastapi import FastAPI, Depends

app = FastAPI()

# Define a dependency
def common_parameters(q: str = None, skip: int = 0, limit: int = 100):
    """Reusable query parameters"""
    return {"q": q, "skip": skip, "limit": limit}

# Use the dependency
@app.get("/items")
async def read_items(commons: dict = Depends(common_parameters)):
    """Dependency result is passed to the function"""
    return commons

@app.get("/users")
async def read_users(commons: dict = Depends(common_parameters)):
    """Same dependency reused in different endpoint"""
    return {"message": "Users list", "params": commons}

# How it works:
# 1. FastAPI calls common_parameters()
# 2. Gets the return value
# 3. Passes it as 'commons' to your endpoint
```

### Dependencies with Type Annotations

```python
from fastapi import FastAPI, Depends
from pydantic import BaseModel

app = FastAPI()

class CommonQueryParams:
    """Class-based dependency"""
    def __init__(self, q: str = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit

@app.get("/items")
async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
    """Using class as dependency"""
    return {
        "q": commons.q,
        "skip": commons.skip,
        "limit": commons.limit
    }

# Shorthand (when parameter name matches class name)
@app.get("/users")
async def read_users(commons: CommonQueryParams = Depends()):
    """FastAPI infers the dependency from type annotation"""
    return {"q": commons.q}
```

### Async Dependencies

```python
from fastapi import FastAPI, Depends
import asyncio

app = FastAPI()

# Async dependency
async def get_async_data():
    """Dependency can be async for I/O operations"""
    await asyncio.sleep(0.1)  # Simulate async operation
    return {"data": "fetched_asynchronously"}

@app.get("/async-items")
async def read_async_items(data: dict = Depends(get_async_data)):
    """Async endpoint with async dependency"""
    return data

# You can mix sync and async
def sync_dependency():
    """Sync dependency"""
    return {"sync": "data"}

@app.get("/mixed")
async def mixed_endpoint(
    sync_data: dict = Depends(sync_dependency),
    async_data: dict = Depends(get_async_data)
):
    """Mix sync and async dependencies"""
    return {"sync": sync_data, "async": async_data}
```

---

## Sub-Dependencies (Nested Dependencies)

Dependencies can depend on other dependencies, creating a dependency tree.

### Basic Sub-Dependencies

```python
from fastapi import FastAPI, Depends, HTTPException, status
from typing import Optional

app = FastAPI()

# Layer 1: Bottom dependency
def verify_token(token: str):
    """Verify authentication token"""
    if token != "secret-token":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token"
        )
    return token

# Layer 2: Depends on verify_token
def get_current_user(token: str = Depends(verify_token)):
    """Get user from token"""
    # In real app, decode token and fetch user from DB
    return {"username": "john_doe", "token": token}

# Layer 3: Depends on get_current_user
def get_admin_user(current_user: dict = Depends(get_current_user)):
    """Verify user is admin"""
    if current_user.get("username") != "john_doe":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not enough permissions"
        )
    return current_user

# Use in endpoint
@app.get("/admin/users")
async def admin_only(admin: dict = Depends(get_admin_user)):
    """
    Dependency chain:
    verify_token -> get_current_user -> get_admin_user -> endpoint
    """
    return {"message": "Admin access granted", "admin": admin}

@app.get("/profile")
async def user_profile(user: dict = Depends(get_current_user)):
    """Use intermediate dependency"""
    return user
```

### Complex Dependency Tree

```python
from fastapi import FastAPI, Depends, Header
from typing import Optional

app = FastAPI()

# Multiple independent dependencies
def get_db_connection():
    """Simulate database connection"""
    return {"db": "connection"}

def get_cache_connection():
    """Simulate cache connection"""
    return {"cache": "redis_connection"}

def get_user_agent(user_agent: Optional[str] = Header(None)):
    """Get user agent from header"""
    return user_agent

# Dependency that uses multiple sub-dependencies
def get_request_context(
    db: dict = Depends(get_db_connection),
    cache: dict = Depends(get_cache_connection),
    user_agent: str = Depends(get_user_agent)
):
    """Combine multiple dependencies"""
    return {
        "db": db,
        "cache": cache,
        "user_agent": user_agent
    }

@app.get("/context")
async def with_context(context: dict = Depends(get_request_context)):
    """
    Dependency tree:
           get_request_context
          /         |          \
    get_db   get_cache   get_user_agent
    """
    return context
```

---

## Common Dependency Patterns

### Database Session Dependency

```python
from fastapi import FastAPI, Depends
from typing import Generator

app = FastAPI()

# Simulated database session
class DatabaseSession:
    def __init__(self):
        print("Database session created")
        self.connection = "db_connection"
    
    def close(self):
        print("Database session closed")

# Generator dependency with cleanup
def get_db() -> Generator:
    """
    Dependency with cleanup
    Code before yield runs before request
    Code after yield runs after response
    """
    db = DatabaseSession()
    try:
        yield db
    finally:
        db.close()

@app.get("/items")
async def get_items(db: DatabaseSession = Depends(get_db)):
    """
    1. get_db() creates session
    2. Endpoint uses session
    3. Session is closed automatically
    """
    return {"db": db.connection, "items": []}

# With context manager
from contextlib import contextmanager

@contextmanager
def get_db_context():
    """Alternative using context manager"""
    db = DatabaseSession()
    try:
        yield db
    finally:
        db.close()

@app.get("/users")
async def get_users(db: DatabaseSession = Depends(get_db_context)):
    return {"users": [], "db": db.connection}
```

### Authentication Dependency

```python
from fastapi import FastAPI, Depends, HTTPException, status, Header
from typing import Optional
from pydantic import BaseModel

app = FastAPI()

class User(BaseModel):
    id: int
    username: str
    email: str
    is_active: bool = True
    is_admin: bool = False

# Simulated user database
users_db = {
    "token-john": User(id=1, username="john", email="john@example.com"),
    "token-admin": User(id=2, username="admin", email="admin@example.com", is_admin=True),
}

# Authentication dependency
async def get_token(authorization: Optional[str] = Header(None)) -> str:
    """Extract token from Authorization header"""
    if not authorization:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Missing authorization header",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Expected format: "Bearer token-value"
    parts = authorization.split()
    if len(parts) != 2 or parts[0].lower() != "bearer":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authorization header format",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    return parts[1]

# Get current user dependency
async def get_current_user(token: str = Depends(get_token)) -> User:
    """Get user from token"""
    user = users_db.get(token)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user"
        )
    
    return user

# Get current active user (convenience wrapper)
async def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """Ensure user is active"""
    if not current_user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user"
        )
    return current_user

# Admin user dependency
async def get_admin_user(
    current_user: User = Depends(get_current_active_user)
) -> User:
    """Ensure user is admin"""
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not enough permissions"
        )
    return current_user

# Using auth dependencies
@app.get("/users/me")
async def read_users_me(current_user: User = Depends(get_current_active_user)):
    """Public endpoint - any authenticated user"""
    return current_user

@app.get("/admin/dashboard")
async def admin_dashboard(admin: User = Depends(get_admin_user)):
    """Admin-only endpoint"""
    return {"message": "Welcome to admin dashboard", "admin": admin.username}
```

### Pagination Dependency

```python
from fastapi import FastAPI, Depends, Query
from typing import Optional

app = FastAPI()

class PaginationParams:
    """Reusable pagination parameters"""
    def __init__(
        self,
        skip: int = Query(0, ge=0, description="Number of items to skip"),
        limit: int = Query(10, ge=1, le=100, description="Max items to return"),
        page: Optional[int] = Query(None, ge=1, description="Page number (alternative to skip)")
    ):
        # If page is provided, calculate skip
        if page is not None:
            self.skip = (page - 1) * limit
        else:
            self.skip = skip
        
        self.limit = limit
        self.page = page if page is not None else (skip // limit) + 1
    
    @property
    def offset(self):
        return self.skip

@app.get("/items")
async def list_items(pagination: PaginationParams = Depends()):
    """Use pagination dependency"""
    # Simulate fetching items
    all_items = [f"Item {i}" for i in range(100)]
    items = all_items[pagination.skip : pagination.skip + pagination.limit]
    
    return {
        "items": items,
        "page": pagination.page,
        "skip": pagination.skip,
        "limit": pagination.limit,
        "total": len(all_items)
    }
```

### Filtering and Sorting Dependencies

```python
from fastapi import FastAPI, Depends, Query
from typing import Optional, List
from enum import Enum

app = FastAPI()

class SortOrder(str, Enum):
    asc = "asc"
    desc = "desc"

class ItemFilter:
    """Complex filtering dependency"""
    def __init__(
        self,
        category: Optional[str] = Query(None, description="Filter by category"),
        min_price: Optional[float] = Query(None, ge=0),
        max_price: Optional[float] = Query(None, ge=0),
        tags: List[str] = Query([], description="Filter by tags"),
        in_stock: bool = Query(True, description="Show only in-stock items"),
        sort_by: str = Query("name", description="Field to sort by"),
        sort_order: SortOrder = Query(SortOrder.asc)
    ):
        self.category = category
        self.min_price = min_price
        self.max_price = max_price
        self.tags = tags
        self.in_stock = in_stock
        self.sort_by = sort_by
        self.sort_order = sort_order
    
    def apply_filters(self, items: List[dict]) -> List[dict]:
        """Apply all filters to item list"""
        filtered = items
        
        if self.category:
            filtered = [i for i in filtered if i.get("category") == self.category]
        
        if self.min_price is not None:
            filtered = [i for i in filtered if i.get("price", 0) >= self.min_price]
        
        if self.max_price is not None:
            filtered = [i for i in filtered if i.get("price", 0) <= self.max_price]
        
        if self.tags:
            filtered = [
                i for i in filtered 
                if any(tag in i.get("tags", []) for tag in self.tags)
            ]
        
        if self.in_stock:
            filtered = [i for i in filtered if i.get("stock", 0) > 0]
        
        # Sort
        reverse = self.sort_order == SortOrder.desc
        filtered.sort(key=lambda x: x.get(self.sort_by, ""), reverse=reverse)
        
        return filtered

@app.get("/items")
async def list_items(
    filters: ItemFilter = Depends(),
    pagination: PaginationParams = Depends()
):
    """Combine filtering and pagination"""
    # Simulated items
    all_items = [
        {"name": "Item A", "category": "electronics", "price": 100, "stock": 10, "tags": ["new"]},
        {"name": "Item B", "category": "books", "price": 20, "stock": 0, "tags": ["sale"]},
        {"name": "Item C", "category": "electronics", "price": 200, "stock": 5, "tags": ["new", "featured"]},
    ]
    
    # Apply filters
    filtered_items = filters.apply_filters(all_items)
    
    # Apply pagination
    paginated = filtered_items[pagination.skip : pagination.skip + pagination.limit]
    
    return {
        "items": paginated,
        "total": len(filtered_items),
        "page": pagination.page,
        "filters_applied": {
            "category": filters.category,
            "price_range": [filters.min_price, filters.max_price],
            "tags": filters.tags
        }
    }
```

### Settings/Config Dependency

```python
from fastapi import FastAPI, Depends
from pydantic_settings import BaseSettings
from functools import lru_cache

app = FastAPI()

# Settings model
class Settings(BaseSettings):
    """Application settings from environment variables"""
    app_name: str = "My API"
    admin_email: str = "admin@example.com"
    items_per_user: int = 50
    database_url: str = "sqlite:///./test.db"
    secret_key: str = "secret"
    debug: bool = False
    
    class Config:
        env_file = ".env"

# Cache settings (singleton pattern)
@lru_cache()
def get_settings() -> Settings:
    """
    Create settings once and cache it
    Returns same instance for all requests
    """
    return Settings()

# Use settings in endpoints
@app.get("/info")
async def info(settings: Settings = Depends(get_settings)):
    """Access application settings"""
    return {
        "app_name": settings.app_name,
        "admin_email": settings.admin_email,
        "debug": settings.debug
    }

@app.get("/db-info")
async def db_info(settings: Settings = Depends(get_settings)):
    """Settings are cached - same instance as above"""
    return {
        "database_url": settings.database_url
    }
```

---

## Advanced Dependency Concepts

### Dependencies with Yield (Context Managers)

```python
from fastapi import FastAPI, Depends
from typing import Generator
import time

app = FastAPI()

# Dependency with setup and teardown
def get_db() -> Generator:
    """
    Code before yield: setup (runs before request)
    yield: provides value to endpoint
    Code after yield: teardown (runs after response)
    """
    print("Opening database connection")
    db = {"connection": "active"}
    
    try:
        yield db
    finally:
        print("Closing database connection")
        db["connection"] = "closed"

@app.get("/items")
async def get_items(db: dict = Depends(get_db)):
    """
    Execution order:
    1. "Opening database connection"
    2. Endpoint executes with db
    3. "Closing database connection"
    """
    return {"db_status": db["connection"], "items": []}

# With exception handling
def get_db_safe() -> Generator:
    """Safe database dependency with exception handling"""
    db = {"connection": "active"}
    try:
        yield db
    except Exception as e:
        print(f"Error occurred: {e}")
        # Rollback transaction, etc.
        raise
    finally:
        print("Cleanup")
        db["connection"] = "closed"

# Timing dependency
def timer() -> Generator:
    """Measure endpoint execution time"""
    start = time.time()
    yield start
    duration = time.time() - start
    print(f"Request took {duration:.4f} seconds")

@app.get("/timed")
async def timed_endpoint(start_time: float = Depends(timer)):
    """Automatically timed"""
    time.sleep(0.1)  # Simulate work
    return {"started_at": start_time}
```

### Dependency Caching

```python
from fastapi import FastAPI, Depends

app = FastAPI()

call_count = {"expensive": 0, "uncached": 0}

# By default, dependencies are cached per request
async def expensive_operation():
    """Called once per request, result is cached"""
    call_count["expensive"] += 1
    print(f"Expensive operation called: {call_count['expensive']}")
    return "expensive_result"

async def uncached_operation():
    """Called every time, not cached"""
    call_count["uncached"] += 1
    print(f"Uncached operation called: {call_count['uncached']}")
    return "uncached_result"

async def first_consumer(data: str = Depends(expensive_operation)):
    return f"first_{data}"

async def second_consumer(data: str = Depends(expensive_operation)):
    return f"second_{data}"

@app.get("/cached")
async def cached_endpoint(
    first: str = Depends(first_consumer),
    second: str = Depends(second_consumer)
):
    """
    expensive_operation is called ONCE
    Both consumers get cached result
    """
    return {"first": first, "second": second}

@app.get("/uncached")
async def uncached_endpoint(
    data1: str = Depends(uncached_operation, use_cache=False),
    data2: str = Depends(uncached_operation, use_cache=False)
):
    """
    uncached_operation called TWICE
    use_cache=False disables caching
    """
    return {"data1": data1, "data2": data2}
```

### Global Dependencies

```python
from fastapi import FastAPI, Depends, HTTPException, Header
from typing import Optional

# Global dependency for all routes
def verify_api_key(x_api_key: Optional[str] = Header(None)):
    """Verify API key in all requests"""
    if x_api_key != "secret-api-key":
        raise HTTPException(status_code=403, detail="Invalid API Key")
    return x_api_key

# Apply to all routes in the app
app = FastAPI(dependencies=[Depends(verify_api_key)])

@app.get("/items")
async def get_items():
    """Requires valid API key (from global dependency)"""
    return {"items": []}

@app.get("/users")
async def get_users():
    """Also requires valid API key"""
    return {"users": []}

# Router-level dependencies
from fastapi import APIRouter

admin_router = APIRouter(
    prefix="/admin",
    tags=["admin"],
    dependencies=[Depends(get_admin_user)]  # All routes require admin
)

@admin_router.get("/users")
async def admin_get_users():
    """Requires admin (from router dependency)"""
    return {"admin_users": []}

@admin_router.delete("/users/{user_id}")
async def admin_delete_user(user_id: int):
    """Also requires admin"""
    return {"deleted": user_id}

app.include_router(admin_router)
```

### Dependencies as Classes

```python
from fastapi import FastAPI, Depends, Query
from typing import Optional

app = FastAPI()

class CommonQueryParams:
    """Callable class as dependency"""
    def __init__(
        self,
        q: Optional[str] = Query(None),
        skip: int = Query(0, ge=0),
        limit: int = Query(10, ge=1, le=100)
    ):
        self.q = q
        self.skip = skip
        self.limit = limit
    
    def get_filters(self):
        """Method available after initialization"""
        filters = {}
        if self.q:
            filters["q"] = self.q
        return filters

@app.get("/items")
async def read_items(commons: CommonQueryParams = Depends()):
    """FastAPI instantiates the class and passes instance"""
    filters = commons.get_filters()
    return {
        "filters": filters,
        "skip": commons.skip,
        "limit": commons.limit
    }

# Advanced: Class with dependencies
class DatabaseOperations:
    """Class that itself has dependencies"""
    def __init__(self, db = Depends(get_db)):
        self.db = db
    
    def get_items(self, skip: int, limit: int):
        """Method using injected db"""
        return f"Fetching from {self.db}"

@app.get("/advanced-items")
async def get_advanced_items(
    db_ops: DatabaseOperations = Depends(),
    pagination: PaginationParams = Depends()
):
    """Nested class dependencies"""
    return {
        "result": db_ops.get_items(pagination.skip, pagination.limit)
    }
```

---

## Dependency Overrides (Testing)

Dependency overrides are crucial for testing - they allow you to replace dependencies with mocks.

```python
from fastapi import FastAPI, Depends
from fastapi.testclient import TestClient

app = FastAPI()

# Real dependency
def get_database():
    return {"db": "production_database"}

def get_current_user():
    return {"username": "real_user", "id": 1}

@app.get("/users/me")
async def read_user_me(
    db: dict = Depends(get_database),
    user: dict = Depends(get_current_user)
):
    return {"user": user, "db": db}

# Test with overrides
def test_read_user_me():
    """Test with mocked dependencies"""
    
    # Mock dependencies
    def mock_database():
        return {"db": "test_database"}
    
    def mock_current_user():
        return {"username": "test_user", "id": 999}
    
    # Override dependencies
    app.dependency_overrides[get_database] = mock_database
    app.dependency_overrides[get_current_user] = mock_current_user
    
    # Test
    client = TestClient(app)
    response = client.get("/users/me")
    
    assert response.status_code == 200
    assert response.json() == {
        "user": {"username": "test_user", "id": 999},
        "db": {"db": "test_database"}
    }
    
    # Clean up
    app.dependency_overrides.clear()

# Run test
test_read_user_me()
print("Test passed!")
```

---

## Complete Real-World Example

```python
from fastapi import FastAPI, Depends, HTTPException, status, Header
from pydantic import BaseModel
from typing import Optional, List, Generator
from datetime import datetime
from enum import Enum

app = FastAPI()

# ============================================================================
# Models
# ============================================================================

class UserRole(str, Enum):
    admin = "admin"
    moderator = "moderator"
    user = "user"

class User(BaseModel):
    id: int
    username: str
    email: str
    role: UserRole
    is_active: bool = True

class BlogPost(BaseModel):
    id: int
    title: str
    content: str
    author_id: int
    created_at: datetime
    updated_at: datetime
    published: bool = False

# ============================================================================
# Mock Database
# ============================================================================

users_db = {
    1: User(id=1, username="admin", email="admin@example.com", role=UserRole.admin),
    2: User(id=2, username="john", email="john@example.com", role=UserRole.user),
    3: User(id=3, username="mod", email="mod@example.com", role=UserRole.moderator),
}

posts_db = {
    1: BlogPost(
        id=1,
        title="First Post",
        content="Content here",
        author_id=1,
        created_at=datetime.now(),
        updated_at=datetime.now(),
        published=True
    )
}

# ============================================================================
# Database Session Dependency
# ============================================================================

class Database:
    """Simulated database session"""
    def __init__(self):
        self.users = users_db
        self.posts = posts_db
        print("Database session opened")
    
    def close(self):
        print("Database session closed")

def get_db() -> Generator[Database, None, None]:
    """Provide database session with automatic cleanup"""
    db = Database()
    try:
        yield db
    finally:
        db.close()

# ============================================================================
# Authentication Dependencies
# ============================================================================

def get_token(authorization: Optional[str] = Header(None)) -> str:
    """Extract and validate token"""
    if not authorization:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Missing authorization header",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    parts = authorization.split()
    if len(parts) != 2 or parts[0].lower() != "bearer":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authorization header"
        )
    
    return parts[1]

def get_current_user(
    token: str = Depends(get_token),
    db: Database = Depends(get_db)
) -> User:
    """Get current user from token"""
    # In real app: decode JWT and fetch from DB
    # For demo: token is user_id
    try:
        user_id = int(token)
        user = db.users.get(user_id)
    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token"
        )
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found"
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Inactive user"
        )
    
    return user

# ============================================================================
# Authorization Dependencies
# ============================================================================

def require_role(required_role: UserRole):
    """Factory for role-based dependencies"""
    def role_checker(current_user: User = Depends(get_current_user)) -> User:
        # Role hierarchy: admin > moderator > user
        role_hierarchy = {
            UserRole.admin: 3,
            UserRole.moderator: 2,
            UserRole.user: 1
        }
        
        user_level = role_hierarchy[current_user.role]
        required_level = role_hierarchy[required_role]
        
        if user_level < required_level:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Requires {required_role.value} role or higher"
            )
        
        return current_user
    
    return role_checker

# Convenience functions
def get_admin_user(user: User = Depends(require_role(UserRole.admin))) -> User:
    return user

def get_moderator_user(user: User = Depends(require_role(UserRole.moderator))) -> User:
    return user

# ============================================================================
# Pagination & Filtering Dependencies
# ============================================================================

class PaginationParams:
    def __init__(
        self,
        skip: int = 0,
        limit: int = 10
    ):
        self.skip = skip
        self.limit = limit

class PostFilters:
    def __init__(
        self,
        author_id: Optional[int] = None,
        published: Optional[bool] = None,
        search: Optional[str] = None
    ):
        self.author_id = author_id
        self.published = published
        self.search = search
    
    def apply(self, posts: List[BlogPost]) -> List[BlogPost]:
        """Apply filters to posts"""
        filtered = posts
        
        if self.author_id is not None:
            filtered = [p for p in filtered if p.author_id == self.author_id]
        
        if self.published is not None:
            filtered = [p for p in filtered if p.published == self.published]
        
        if self.search:
            search_lower = self.search.lower()
            filtered = [
                p for p in filtered 
                if search_lower in p.title.lower() or search_lower in p.content.lower()
            ]
        
        return filtered

# ============================================================================
# Endpoints
# ============================================================================

@app.get("/users/me")
async def read_current_user(current_user: User = Depends(get_current_user)):
    """Get current user info"""
    return current_user

@app.get("/posts")
async def list_posts(
    db: Database = Depends(get_db),
    filters: PostFilters = Depends(),
    pagination: PaginationParams = Depends(),
    current_user: Optional[User] = Depends(get_current_user)
):
    """
    List posts with filtering and pagination
    Requires authentication
    """
    all_posts = list(db.posts.values())
    
    # Non-admin users can only see published posts
    if current_user.role != UserRole.admin:
        all_posts = [p for p in all_posts if p.published]
    
    # Apply filters
    filtered_posts = filters.apply(all_posts)
    
    # Apply pagination
    paginated = filtered_posts[pagination.skip : pagination.skip + pagination.limit]
    
    return {
        "posts": paginated,
        "total": len(filtered_posts),
        "skip": pagination.skip,
        "limit": pagination.limit
    }

@app.post("/posts")
async def create_post(
    post_data: BlogPost,
    db: Database = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Create new post (authenticated users only)"""
    # Set author to current user
    post_data.author_id = current_user.id
    post_data.id = len(db.posts) + 1
    post_data.created_at = datetime.now()
    post_data.updated_at = datetime.now()
    
    db.posts[post_data.id] = post_data
    return post_data

@app.put("/posts/{post_id}")
async def update_post(
    post_id: int,
    post_data: BlogPost,
    db: Database = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Update post
    Users can only update their own posts
    Moderators and admins can update any post
    """
    post = db.posts.get(post_id)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    
    # Check permissions
    is_author = post.author_id == current_user.id
    is_moderator_or_admin = current_user.role in [UserRole.moderator, UserRole.admin]
    
    if not (is_author or is_moderator_or_admin):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to update this post"
        )
    
    post_data.id = post_id
    post_data.updated_at = datetime.now()
    db.posts[post_id] = post_data
    return post_data

@app.delete("/posts/{post_id}")
async def delete_post(
    post_id: int,
    db: Database = Depends(get_db),
    moderator: User = Depends(get_moderator_user)
):
    """
    Delete post (moderators and admins only)
    Uses role-based dependency
    """
    if post_id not in db.posts:
        raise HTTPException(status_code=404, detail="Post not found")
    
    del db.posts[post_id]
    return {"message": "Post deleted", "deleted_by": moderator.username}

@app.get("/admin/users")
async def list_all_users(
    db: Database = Depends(get_db),
    admin: User = Depends(get_admin_user)
):
    """Admin-only endpoint"""
    return {
        "users": list(db.users.values()),
        "accessed_by": admin.username
    }

# Test the API
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## Best Practices

1. **Keep dependencies focused**: Each dependency should do one thing well
2. **Use sub-dependencies**: Build complex dependencies from simple ones
3. **Leverage caching**: Expensive operations are cached per request by default
4. **Use yield for cleanup**: Database sessions, file handles, etc.
5. **Factory pattern**: Use functions that return dependencies for flexibility
6. **Type hints**: Always use type hints for better IDE support and documentation
7. **Test with overrides**: Use `dependency_overrides` for testing
8. **Global dependencies**: Use sparingly, prefer router-level when possible

## Common Pitfalls

1. **Not using yield for cleanup**: Resources leak without proper cleanup
2. **Forgetting caching**: Expensive operations called multiple times
3. **Circular dependencies**: Dependencies depending on each other
4. **Over-nesting**: Too many dependency levels makes code hard to follow
5. **Ignoring exceptions**: Always handle exceptions in dependencies with cleanup
6. **Not testing**: Dependencies should be unit tested independently

---

## Summary

In Chapter 4, you learned:
- Basic and advanced dependency injection
- Sub-dependencies and dependency trees
- Common patterns: auth, pagination, filtering, database sessions
- Dependencies with yield for resource management
- Dependency caching and overrides for testing
- Real-world example with complete authentication and authorization

**Key Takeaway**: Dependency Injection is FastAPI's superpower. Master it to write clean, testable, maintainable code!

**Next: Chapter 5 - Data Persistence & DB Integration**