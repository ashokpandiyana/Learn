# Chapter 1: FastAPI Fundamentals - Complete Guide

## What is FastAPI?

FastAPI is a modern, high-performance web framework for building APIs with Python 3.8+. It's built on top of Starlette (for web routing) and Pydantic (for data validation).

### Key Features

1. **Speed**: One of the fastest Python frameworks available, comparable to NodeJS and Go
2. **Fast to code**: Increases development speed by ~200-300%
3. **Fewer bugs**: Reduces human-induced errors by ~40%
4. **Intuitive**: Great editor support with auto-completion
5. **Easy**: Designed to be easy to learn and use
6. **Short**: Minimizes code duplication
7. **Robust**: Production-ready code with automatic interactive documentation
8. **Standards-based**: Based on OpenAPI and JSON Schema

### FastAPI vs Flask vs Django

| Feature | FastAPI | Flask | Django |
|---------|---------|-------|--------|
| **Performance** | Very High (async) | Moderate (sync) | Moderate (sync) |
| **Type Hints** | Required & Leveraged | Optional | Optional |
| **Auto Docs** | Built-in (Swagger/ReDoc) | Manual | Via DRF |
| **Validation** | Automatic (Pydantic) | Manual | Forms/Serializers |
| **Async Support** | Native | Limited (Flask 2.0+) | Limited (Django 3.1+) |
| **Learning Curve** | Moderate | Easy | Steep |
| **Use Case** | APIs, Microservices | Small apps, APIs | Full-stack web apps |

**When to choose FastAPI:**
- Building modern REST/GraphQL APIs
- Need high performance and async support
- Want automatic API documentation
- Team comfortable with type hints
- Microservices architecture
- ML model serving

### ASGI vs WSGI

**WSGI (Web Server Gateway Interface)**:
- Synchronous protocol
- One request at a time per worker
- Used by Flask, Django
- Cannot handle WebSockets or long-lived connections efficiently

**ASGI (Asynchronous Server Gateway Interface)**:
- Asynchronous protocol
- Handles multiple requests concurrently
- Used by FastAPI, Starlette
- Supports WebSockets, HTTP/2, long polling
- Better resource utilization

```python
# WSGI (synchronous)
def application(environ, start_response):
    # Blocks until complete
    result = slow_database_query()
    return result

# ASGI (asynchronous)
async def application(scope, receive, send):
    # Can handle other requests while waiting
    result = await slow_database_query()
    return result
```

---

## Project Setup

### Installation with UV

UV is a modern, extremely fast Python package installer and resolver written in Rust.

```bash
# Install UV (if not already installed)
curl -LsSf https://astral.sh/uv/install.sh | sh

# Create a new project directory
mkdir fastapi-project
cd fastapi-project

# Create a virtual environment
uv venv

# Activate the virtual environment
# On Linux/Mac:
source .venv/bin/activate
# On Windows:
.venv\Scripts\activate

# Install FastAPI and Uvicorn
uv pip install fastapi uvicorn[standard]

# For development, also install:
uv pip install python-multipart  # For form data
uv pip install python-jose[cryptography]  # For JWT
uv pip install passlib[bcrypt]  # For password hashing
```

### Creating Your First FastAPI Application

Create a file `main.py`:

```python
from fastapi import FastAPI

# Create FastAPI instance
app = FastAPI(
    title="My API",
    description="This is my awesome API",
    version="1.0.0"
)

@app.get("/")
async def root():
    """Root endpoint returning a welcome message"""
    return {"message": "Hello World"}

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy"}
```

### Running the Application

```bash
# Development mode with auto-reload
uvicorn main:app --reload

# Specify host and port
uvicorn main:app --host 0.0.0.0 --port 8000 --reload

# Production mode (no reload)
uvicorn main:app --host 0.0.0.0 --port 8000 --workers 4
```

**Access your API:**
- API: http://localhost:8000
- Interactive docs (Swagger UI): http://localhost:8000/docs
- Alternative docs (ReDoc): http://localhost:8000/redoc
- OpenAPI schema: http://localhost:8000/openapi.json

### Project Structure

For production applications, organize your code properly:

```
fastapi-project/
â"œâ"€â"€ app/
â"‚   â"œâ"€â"€ __init__.py
â"‚   â"œâ"€â"€ main.py              # Application entry point
â"‚   â"œâ"€â"€ api/                 # API routes
â"‚   â"‚   â"œâ"€â"€ __init__.py
â"‚   â"‚   â"œâ"€â"€ v1/              # API version 1
â"‚   â"‚   â"‚   â"œâ"€â"€ __init__.py
â"‚   â"‚   â"‚   â"œâ"€â"€ endpoints/
â"‚   â"‚   â"‚   â"‚   â"œâ"€â"€ users.py
â"‚   â"‚   â"‚   â"‚   â"œâ"€â"€ items.py
â"‚   â"‚   â"‚   â"‚   â""â"€â"€ auth.py
â"‚   â"‚   â"‚   â""â"€â"€ router.py
â"‚   â"œâ"€â"€ core/                # Core functionality
â"‚   â"‚   â"œâ"€â"€ __init__.py
â"‚   â"‚   â"œâ"€â"€ config.py        # Configuration
â"‚   â"‚   â"œâ"€â"€ security.py      # Security utilities
â"‚   â"‚   â""â"€â"€ dependencies.py  # Shared dependencies
â"‚   â"œâ"€â"€ models/              # Database models
â"‚   â"‚   â"œâ"€â"€ __init__.py
â"‚   â"‚   â"œâ"€â"€ user.py
â"‚   â"‚   â""â"€â"€ item.py
â"‚   â"œâ"€â"€ schemas/             # Pydantic schemas
â"‚   â"‚   â"œâ"€â"€ __init__.py
â"‚   â"‚   â"œâ"€â"€ user.py
â"‚   â"‚   â""â"€â"€ item.py
â"‚   â"œâ"€â"€ services/            # Business logic
â"‚   â"‚   â"œâ"€â"€ __init__.py
â"‚   â"‚   â"œâ"€â"€ user_service.py
â"‚   â"‚   â""â"€â"€ item_service.py
â"‚   â""â"€â"€ db/                  # Database
â"‚       â"œâ"€â"€ __init__.py
â"‚       â"œâ"€â"€ base.py
â"‚       â""â"€â"€ session.py
â"œâ"€â"€ tests/
â"‚   â"œâ"€â"€ __init__.py
â"‚   â"œâ"€â"€ conftest.py
â"‚   â""â"€â"€ test_api/
â"œâ"€â"€ .env
â"œâ"€â"€ .gitignore
â"œâ"€â"€ README.md
â""â"€â"€ requirements.txt
```

**Example `app/main.py`:**

```python
from fastapi import FastAPI
from app.api.v1.router import api_router
from app.core.config import settings

app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json"
)

# Include API router
app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/")
async def root():
    return {"message": "Welcome to the API"}
```

---

## Routing Basics

### Path Operations

FastAPI uses Python decorators to define routes. Each HTTP method has a corresponding decorator.

```python
from fastapi import FastAPI

app = FastAPI()

# GET - Retrieve data
@app.get("/items")
async def get_items():
    return {"items": [{"id": 1, "name": "Item 1"}]}

# POST - Create new resource
@app.post("/items")
async def create_item():
    return {"message": "Item created"}

# PUT - Update entire resource
@app.put("/items/{item_id}")
async def update_item(item_id: int):
    return {"message": f"Item {item_id} updated"}

# PATCH - Partial update
@app.patch("/items/{item_id}")
async def partial_update_item(item_id: int):
    return {"message": f"Item {item_id} partially updated"}

# DELETE - Remove resource
@app.delete("/items/{item_id}")
async def delete_item(item_id: int):
    return {"message": f"Item {item_id} deleted"}

# HEAD - Get headers only (no body)
@app.head("/items")
async def items_headers():
    return {}

# OPTIONS - Describe communication options
@app.options("/items")
async def items_options():
    return {}
```

### Path Parameters

Path parameters are declared in the route path and extracted automatically.

```python
from fastapi import FastAPI, Path
from typing import Optional

app = FastAPI()

# Basic path parameter
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    """Type conversion happens automatically"""
    return {"user_id": user_id, "type": type(user_id).__name__}

# Multiple path parameters
@app.get("/users/{user_id}/items/{item_id}")
async def get_user_item(user_id: int, item_id: int):
    return {"user_id": user_id, "item_id": item_id}

# Path parameter with validation
@app.get("/items/{item_id}")
async def get_item(
    item_id: int = Path(
        ...,  # Required
        title="Item ID",
        description="The ID of the item to retrieve",
        ge=1,  # Greater than or equal to 1
        le=1000  # Less than or equal to 1000
    )
):
    return {"item_id": item_id}

# String path parameter with validation
@app.get("/users/{username}")
async def get_user_by_name(
    username: str = Path(
        ...,
        min_length=3,
        max_length=50,
        regex="^[a-zA-Z0-9_]+$"
    )
):
    return {"username": username}

# Enum path parameter
from enum import Enum

class ModelName(str, Enum):
    alexnet = "alexnet"
    resnet = "resnet"
    lenet = "lenet"

@app.get("/models/{model_name}")
async def get_model(model_name: ModelName):
    """Path parameter limited to enum values"""
    if model_name == ModelName.alexnet:
        return {"model": model_name, "message": "Deep Learning FTW!"}
    
    if model_name.value == "lenet":
        return {"model": model_name, "message": "LeCNN all the images"}
    
    return {"model": model_name, "message": "Have some residuals"}

# Path parameter with file path
@app.get("/files/{file_path:path}")
async def get_file(file_path: str):
    """
    :path converter captures the entire path including slashes
    Example: /files/home/user/docs/file.txt
    """
    return {"file_path": file_path}
```

### Query Parameters

Parameters not in the path are automatically treated as query parameters.

```python
from fastapi import FastAPI, Query
from typing import Optional, List

app = FastAPI()

# Basic query parameters
@app.get("/items")
async def get_items(skip: int = 0, limit: int = 10):
    """
    Access: /items?skip=0&limit=10
    """
    return {"skip": skip, "limit": limit}

# Optional query parameters
@app.get("/items")
async def search_items(
    q: Optional[str] = None,  # Optional string
    published: bool = False    # Default value
):
    """
    Access: /items?q=search&published=true
    """
    result = {"published": published}
    if q:
        result["q"] = q
    return result

# Query parameter with validation
@app.get("/items")
async def get_items_validated(
    q: Optional[str] = Query(
        None,
        min_length=3,
        max_length=50,
        regex="^[a-zA-Z0-9 ]+$",
        title="Search Query",
        description="Search query string"
    ),
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100)
):
    return {"q": q, "skip": skip, "limit": limit}

# List query parameters
@app.get("/items")
async def get_items_by_tags(
    tags: List[str] = Query(
        [],
        title="Tags",
        description="Filter items by tags"
    )
):
    """
    Access: /items?tags=python&tags=fastapi&tags=async
    Returns: ["python", "fastapi", "async"]
    """
    return {"tags": tags}

# Required query parameter
@app.get("/items")
async def get_items_required(
    q: str = Query(..., min_length=3),  # ... means required
    limit: int = 10
):
    return {"q": q, "limit": limit}

# Query parameter aliases
@app.get("/items")
async def get_items_alias(
    q: Optional[str] = Query(
        None,
        alias="item-query",  # Use hyphen in URL
        title="Query string"
    )
):
    """
    Access: /items?item-query=test
    """
    return {"q": q}

# Deprecated query parameter
@app.get("/items")
async def get_items_deprecated(
    q: Optional[str] = Query(
        None,
        deprecated=True,
        description="This parameter is deprecated"
    )
):
    return {"q": q}
```

### Combining Path and Query Parameters

```python
from fastapi import FastAPI, Path, Query
from typing import Optional

app = FastAPI()

@app.get("/users/{user_id}/items")
async def get_user_items(
    user_id: int = Path(..., ge=1),
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
    q: Optional[str] = Query(None, min_length=3)
):
    """
    Access: /users/123/items?skip=0&limit=10&q=search
    """
    return {
        "user_id": user_id,
        "skip": skip,
        "limit": limit,
        "q": q
    }

# Order doesn't matter with type hints
@app.get("/items/{item_id}")
async def read_item(
    q: Optional[str],  # Query parameter first
    item_id: int = Path(..., ge=1)  # Path parameter second
):
    """FastAPI knows which is which based on parameter names"""
    return {"item_id": item_id, "q": q}
```

### Route Order and Matching

FastAPI matches routes in the order they are defined. More specific routes should come before general ones.

```python
from fastapi import FastAPI

app = FastAPI()

# CORRECT ORDER

# Specific route first
@app.get("/users/me")
async def get_current_user():
    return {"user": "current_user"}

# General route second
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    return {"user_id": user_id}

# INCORRECT ORDER - This would cause issues
# @app.get("/users/{user_id}")  # This would match /users/me
# async def get_user(user_id: int):
#     return {"user_id": user_id}
#
# @app.get("/users/me")  # This would never be reached
# async def get_current_user():
#     return {"user": "current_user"}
```

### Route Naming and Tags

```python
from fastapi import FastAPI

app = FastAPI()

# Tags for organization in docs
@app.get("/users", tags=["users"])
async def get_users():
    return {"users": []}

@app.post("/users", tags=["users"])
async def create_user():
    return {"message": "User created"}

@app.get("/items", tags=["items"])
async def get_items():
    return {"items": []}

# Multiple tags
@app.get("/admin/users", tags=["admin", "users"])
async def admin_get_users():
    return {"admin_users": []}

# Operation ID for client generation
@app.get(
    "/users/{user_id}",
    tags=["users"],
    operation_id="getUserById",  # Custom operation ID
    summary="Get a user by ID",
    description="Retrieve a specific user using their unique identifier"
)
async def get_user(user_id: int):
    return {"user_id": user_id}

# Deprecate an endpoint
@app.get(
    "/old-endpoint",
    deprecated=True,
    tags=["legacy"]
)
async def old_endpoint():
    return {"message": "This endpoint is deprecated"}
```

### Response Status Codes

```python
from fastapi import FastAPI, status

app = FastAPI()

@app.post("/items", status_code=status.HTTP_201_CREATED)
async def create_item():
    """Returns 201 instead of default 200"""
    return {"message": "Item created"}

@app.delete("/items/{item_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_item(item_id: int):
    """Returns 204 with no content"""
    return None

@app.get("/items", status_code=200)
async def get_items():
    """Explicit 200 status"""
    return {"items": []}
```

### Complete Routing Example

```python
from fastapi import FastAPI, Path, Query, status
from typing import Optional, List
from enum import Enum

app = FastAPI(
    title="E-commerce API",
    description="A sample e-commerce API",
    version="1.0.0"
)

class Category(str, Enum):
    electronics = "electronics"
    clothing = "clothing"
    books = "books"

# Product endpoints
@app.get(
    "/products",
    tags=["products"],
    summary="List all products",
    description="Get a paginated list of products with optional filtering"
)
async def list_products(
    category: Optional[Category] = None,
    skip: int = Query(0, ge=0, description="Number of items to skip"),
    limit: int = Query(10, ge=1, le=100, description="Number of items to return"),
    search: Optional[str] = Query(None, min_length=3, max_length=100)
):
    return {
        "category": category,
        "skip": skip,
        "limit": limit,
        "search": search,
        "products": []
    }

@app.get(
    "/products/{product_id}",
    tags=["products"],
    summary="Get product by ID"
)
async def get_product(
    product_id: int = Path(..., ge=1, description="The ID of the product")
):
    return {"product_id": product_id}

@app.post(
    "/products",
    tags=["products"],
    status_code=status.HTTP_201_CREATED,
    summary="Create a new product"
)
async def create_product():
    return {"message": "Product created", "id": 1}

# User endpoints
@app.get("/users/me", tags=["users"])
async def get_current_user():
    return {"user": "current_user"}

@app.get("/users/{user_id}", tags=["users"])
async def get_user(user_id: int):
    return {"user_id": user_id}

@app.get("/users/{user_id}/orders", tags=["users", "orders"])
async def get_user_orders(
    user_id: int = Path(..., ge=1),
    status: Optional[str] = Query(None, regex="^(pending|completed|cancelled)$")
):
    return {"user_id": user_id, "status": status, "orders": []}
```

---

## Best Practices

1. **Always use type hints**: FastAPI relies on them for validation and documentation
2. **Use async when possible**: Especially for I/O operations (database, external APIs)
3. **Organize with routers**: Don't put everything in main.py
4. **Validate early**: Use Path, Query, and Pydantic models
5. **Use meaningful tags**: Helps organize documentation
6. **Document your endpoints**: Use docstrings, summary, and description
7. **Version your API**: Use prefixes like `/api/v1`
8. **Handle errors properly**: We'll cover this in chapter 3

## Common Pitfalls

1. **Wrong route order**: Specific routes after general ones won't be reached
2. **Missing async/await**: Mixing sync and async incorrectly
3. **Not using type hints**: Loses FastAPI's main benefits
4. **Ignoring validation**: Not using Query, Path parameters properly
5. **Poor project structure**: Everything in one file becomes unmaintainable

---

## Summary

In Chapter 1, you learned:
- What FastAPI is and why it's powerful
- ASGI vs WSGI concepts
- How to set up a FastAPI project with UV
- Proper project structure for production
- All routing basics: path operations, parameters, query strings
- Route organization with tags and naming
- Best practices and common pitfalls

Next up: **Chapter 2 - Request & Response Modeling with Pydantic**