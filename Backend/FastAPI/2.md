# Chapter 2: Request & Response Modeling with Pydantic

## Introduction to Pydantic

Pydantic is a data validation library that uses Python type hints to validate data. FastAPI uses Pydantic for:
- Request body validation
- Response serialization
- Settings management
- Automatic API documentation

**Key benefits:**
- Runtime type checking
- Automatic data conversion
- Clear error messages
- JSON schema generation
- IDE support with autocomplete

---

## Pydantic Models Basics

### Creating a Basic Model

```python
from pydantic import BaseModel
from typing import Optional
from datetime import datetime

class User(BaseModel):
    """Basic Pydantic model for a user"""
    id: int
    username: str
    email: str
    is_active: bool = True
    created_at: datetime

# Usage
user = User(
    id=1,
    username="john_doe",
    email="john@example.com",
    created_at=datetime.now()
)

print(user.username)  # john_doe
print(user.model_dump())  # Convert to dict
print(user.model_dump_json())  # Convert to JSON string
```

### Field Types

Pydantic supports a wide range of field types:

```python
from pydantic import BaseModel, HttpUrl, EmailStr, UUID4, validator
from typing import Optional, List, Dict, Set, Tuple
from datetime import datetime, date, time
from decimal import Decimal
from enum import Enum
from uuid import UUID

class Status(str, Enum):
    active = "active"
    inactive = "inactive"
    pending = "pending"

class Product(BaseModel):
    # Basic types
    id: int
    name: str
    description: Optional[str] = None
    price: Decimal  # Better for money than float
    quantity: int
    
    # Boolean
    in_stock: bool
    
    # Date and time
    created_at: datetime
    updated_at: datetime
    launch_date: date
    available_at: time
    
    # Collections
    tags: List[str]
    metadata: Dict[str, str]
    categories: Set[str]
    dimensions: Tuple[float, float, float]  # (length, width, height)
    
    # Special types
    url: HttpUrl  # Validated URL
    email: EmailStr  # Validated email
    product_uuid: UUID4  # UUID validation
    
    # Enum
    status: Status
    
    # Nested model
    # We'll cover this next

# Example usage
product = Product(
    id=1,
    name="Laptop",
    price=Decimal("999.99"),
    quantity=10,
    in_stock=True,
    created_at=datetime.now(),
    updated_at=datetime.now(),
    launch_date=date(2024, 1, 1),
    available_at=time(9, 0, 0),
    tags=["electronics", "computer"],
    metadata={"brand": "Dell", "model": "XPS"},
    categories={"laptops", "computers"},
    dimensions=(35.5, 25.0, 2.0),
    url="https://example.com/laptop",
    email="support@example.com",
    product_uuid="123e4567-e89b-12d3-a456-426614174000",
    status=Status.active
)
```

### Field Configuration with Field()

```python
from pydantic import BaseModel, Field
from typing import Optional
from datetime import datetime

class User(BaseModel):
    id: int = Field(..., gt=0, description="User ID must be positive")
    username: str = Field(
        ...,
        min_length=3,
        max_length=50,
        pattern="^[a-zA-Z0-9_]+$",
        description="Username (alphanumeric and underscores only)"
    )
    email: str = Field(..., pattern=r"^[\w\.-]+@[\w\.-]+\.\w+$")
    age: Optional[int] = Field(None, ge=0, le=150, description="User age")
    score: float = Field(0.0, ge=0.0, le=100.0)
    bio: Optional[str] = Field(None, max_length=500)
    
    # Field with example for documentation
    phone: Optional[str] = Field(
        None,
        example="+1-234-567-8900",
        description="Phone number in international format"
    )

# Field validation parameters:
# - gt: greater than
# - ge: greater than or equal
# - lt: less than
# - le: less than or equal
# - min_length: minimum string length
# - max_length: maximum string length
# - pattern: regex pattern
# - ... : required field (no default)
```

### Nested Models

```python
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime

class Address(BaseModel):
    street: str
    city: str
    state: str
    country: str
    zip_code: str

class ContactInfo(BaseModel):
    email: str
    phone: Optional[str] = None
    address: Address

class OrderItem(BaseModel):
    product_id: int
    product_name: str
    quantity: int = Field(..., ge=1)
    price: float = Field(..., gt=0)
    
    @property
    def total_price(self) -> float:
        return self.quantity * self.price

class Order(BaseModel):
    id: int
    user_id: int
    items: List[OrderItem]
    contact: ContactInfo
    created_at: datetime
    notes: Optional[str] = None
    
    @property
    def total_amount(self) -> float:
        return sum(item.total_price for item in self.items)

# Usage
order = Order(
    id=1,
    user_id=100,
    items=[
        OrderItem(product_id=1, product_name="Laptop", quantity=1, price=999.99),
        OrderItem(product_id=2, product_name="Mouse", quantity=2, price=29.99)
    ],
    contact=ContactInfo(
        email="user@example.com",
        phone="+1-234-567-8900",
        address=Address(
            street="123 Main St",
            city="New York",
            state="NY",
            country="USA",
            zip_code="10001"
        )
    ),
    created_at=datetime.now()
)

print(f"Total: ${order.total_amount:.2f}")
```

### Aliases and Field Names

```python
from pydantic import BaseModel, Field

class User(BaseModel):
    # Python uses snake_case, but API might use camelCase
    user_id: int = Field(..., alias="userId")
    first_name: str = Field(..., alias="firstName")
    last_name: str = Field(..., alias="lastName")
    email_address: str = Field(..., alias="email")
    
    class Config:
        # Allow population by field name OR alias
        populate_by_name = True  # Pydantic v2
        # In Pydantic v1: allow_population_by_field_name = True

# Usage with alias
user_data = {
    "userId": 1,
    "firstName": "John",
    "lastName": "Doe",
    "email": "john@example.com"
}
user = User(**user_data)

# Usage with field name (because of populate_by_name)
user_data2 = {
    "user_id": 1,
    "first_name": "Jane",
    "last_name": "Smith",
    "email_address": "jane@example.com"
}
user2 = User(**user_data2)
```

---

## Request Bodies in FastAPI

### Basic Request Body

```python
from fastapi import FastAPI
from pydantic import BaseModel, Field
from typing import Optional

app = FastAPI()

class Item(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    price: float = Field(..., gt=0)
    tax: Optional[float] = Field(None, ge=0)

@app.post("/items")
async def create_item(item: Item):
    """
    Request body is automatically validated against Item model
    """
    item_dict = item.model_dump()
    if item.tax:
        price_with_tax = item.price + item.tax
        item_dict["price_with_tax"] = price_with_tax
    return item_dict

# Example request:
# POST /items
# {
#     "name": "Laptop",
#     "description": "High-performance laptop",
#     "price": 999.99,
#     "tax": 99.99
# }
```

### Combining Path, Query, and Body Parameters

```python
from fastapi import FastAPI, Path, Query
from pydantic import BaseModel
from typing import Optional

app = FastAPI()

class Item(BaseModel):
    name: str
    description: Optional[str] = None
    price: float
    tax: Optional[float] = None

@app.put("/items/{item_id}")
async def update_item(
    item_id: int = Path(..., ge=1),  # Path parameter
    q: Optional[str] = Query(None),   # Query parameter
    item: Item = None                 # Request body
):
    """
    Combines all three parameter types:
    PUT /items/123?q=search
    Body: {"name": "Item", "price": 10.5}
    """
    result = {"item_id": item_id}
    if q:
        result["q"] = q
    if item:
        result.update(item.model_dump())
    return result

# Multiple body parameters
class User(BaseModel):
    username: str
    email: str

@app.post("/users/{user_id}/items")
async def create_user_item(
    user_id: int,
    item: Item,
    user: User
):
    """
    Request body expects both item and user:
    {
        "item": {"name": "Item", "price": 10.5},
        "user": {"username": "john", "email": "john@example.com"}
    }
    """
    return {"user_id": user_id, "item": item, "user": user}
```

### Body with Embedded Fields

```python
from fastapi import FastAPI, Body
from pydantic import BaseModel
from typing import Optional

app = FastAPI()

class Item(BaseModel):
    name: str
    price: float

@app.post("/items")
async def create_item(
    item: Item,
    importance: int = Body(...)  # Single value in body
):
    """
    Request body:
    {
        "item": {"name": "Item", "price": 10.5},
        "importance": 5
    }
    """
    return {"item": item, "importance": importance}

@app.post("/items-embed")
async def create_item_embed(
    item: Item = Body(..., embed=True)  # Embed in body
):
    """
    Without embed, expects: {"name": "Item", "price": 10.5}
    With embed, expects: {"item": {"name": "Item", "price": 10.5}}
    """
    return item
```

### Form Data

```python
from fastapi import FastAPI, Form, File, UploadFile
from typing import Optional

app = FastAPI()

# Install required: uv pip install python-multipart

@app.post("/login")
async def login(
    username: str = Form(...),
    password: str = Form(...)
):
    """
    HTML form submission:
    <form method="post">
        <input name="username" />
        <input name="password" type="password" />
    </form>
    """
    return {"username": username}

@app.post("/profile")
async def update_profile(
    name: str = Form(...),
    bio: Optional[str] = Form(None),
    age: int = Form(...)
):
    return {"name": name, "bio": bio, "age": age}
```

### File Uploads

```python
from fastapi import FastAPI, File, UploadFile, Form
from typing import List
import shutil

app = FastAPI()

# Simple file upload
@app.post("/upload")
async def upload_file(file: bytes = File(...)):
    """
    Receives file as bytes in memory
    Good for small files only
    """
    return {"file_size": len(file)}

# Better: UploadFile
@app.post("/uploadfile")
async def upload_file(file: UploadFile = File(...)):
    """
    UploadFile provides:
    - filename: original filename
    - content_type: MIME type
    - file: file-like object
    """
    # Read content
    content = await file.read()
    
    # Or save to disk
    with open(f"uploads/{file.filename}", "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
    
    return {
        "filename": file.filename,
        "content_type": file.content_type,
        "size": len(content)
    }

# Multiple files
@app.post("/uploadfiles")
async def upload_files(files: List[UploadFile] = File(...)):
    """Upload multiple files at once"""
    return [
        {
            "filename": file.filename,
            "content_type": file.content_type
        }
        for file in files
    ]

# Combine with form data
@app.post("/upload-with-metadata")
async def upload_with_metadata(
    title: str = Form(...),
    description: str = Form(...),
    file: UploadFile = File(...)
):
    """Upload file with additional form data"""
    return {
        "title": title,
        "description": description,
        "filename": file.filename
    }
```

---

## Response Models

### Basic Response Model

```python
from fastapi import FastAPI
from pydantic import BaseModel
from typing import Optional

app = FastAPI()

class ItemInput(BaseModel):
    name: str
    description: Optional[str] = None
    price: float
    tax: Optional[float] = None

class ItemOutput(BaseModel):
    id: int
    name: str
    price: float
    price_with_tax: float

@app.post("/items", response_model=ItemOutput)
async def create_item(item: ItemInput):
    """
    Input and output models can be different
    Response will be validated and serialized according to ItemOutput
    """
    price_with_tax = item.price + (item.tax or 0)
    
    # Even if we return extra fields, only ItemOutput fields are sent
    return {
        "id": 1,
        "name": item.name,
        "price": item.price,
        "price_with_tax": price_with_tax,
        "internal_field": "This won't be in response"  # Filtered out
    }
```

### Response Model with Filtering

```python
from fastapi import FastAPI
from pydantic import BaseModel, EmailStr
from typing import Optional

app = FastAPI()

class UserInDB(BaseModel):
    id: int
    username: str
    email: EmailStr
    hashed_password: str  # Should never be exposed
    is_active: bool
    is_admin: bool

class UserResponse(BaseModel):
    id: int
    username: str
    email: EmailStr
    is_active: bool
    # Note: no hashed_password

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int):
    """
    Even if we return UserInDB, only UserResponse fields are sent
    """
    user_in_db = UserInDB(
        id=user_id,
        username="john_doe",
        email="john@example.com",
        hashed_password="$2b$12$...",  # Won't be in response
        is_active=True,
        is_admin=False
    )
    return user_in_db

# Alternative: exclude specific fields
@app.get("/users-alt/{user_id}", response_model=UserInDB, response_model_exclude={"hashed_password"})
async def get_user_alt(user_id: int):
    """Excludes hashed_password from response"""
    return UserInDB(
        id=user_id,
        username="john_doe",
        email="john@example.com",
        hashed_password="$2b$12$...",
        is_active=True,
        is_admin=False
    )

# Or include only specific fields
@app.get("/users-minimal/{user_id}", response_model=UserInDB, response_model_include={"id", "username"})
async def get_user_minimal(user_id: int):
    """Returns only id and username"""
    return UserInDB(
        id=user_id,
        username="john_doe",
        email="john@example.com",
        hashed_password="$2b$12$...",
        is_active=True,
        is_admin=False
    )
```

### Response Model with Union Types

```python
from fastapi import FastAPI
from pydantic import BaseModel
from typing import Union

app = FastAPI()

class SuccessResponse(BaseModel):
    status: str = "success"
    data: dict

class ErrorResponse(BaseModel):
    status: str = "error"
    message: str
    code: int

@app.get("/items/{item_id}", response_model=Union[SuccessResponse, ErrorResponse])
async def get_item(item_id: int):
    """Response can be either success or error"""
    if item_id < 1:
        return ErrorResponse(
            message="Invalid item ID",
            code=400
        )
    return SuccessResponse(
        data={"id": item_id, "name": "Item"}
    )
```

### Response Model with Lists

```python
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List

app = FastAPI()

class Item(BaseModel):
    id: int
    name: str
    price: float

@app.get("/items", response_model=List[Item])
async def list_items():
    """Returns a list of items"""
    return [
        Item(id=1, name="Item 1", price=10.5),
        Item(id=2, name="Item 2", price=20.0),
        Item(id=3, name="Item 3", price=15.75)
    ]
```

### Working with ORM Models (Config)

```python
from fastapi import FastAPI
from pydantic import BaseModel, ConfigDict
from typing import Optional
from sqlalchemy import Column, Integer, String, Float, Boolean
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

# SQLAlchemy ORM Model
class UserDB(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True)
    email = Column(String, unique=True, index=True)
    is_active = Column(Boolean, default=True)

# Pydantic Model for API
class User(BaseModel):
    id: int
    username: str
    email: str
    is_active: bool
    
    # Pydantic v2 configuration
    model_config = ConfigDict(from_attributes=True)
    
    # In Pydantic v1, you would use:
    # class Config:
    #     orm_mode = True

app = FastAPI()

@app.get("/users/{user_id}", response_model=User)
async def get_user(user_id: int):
    """
    from_attributes allows Pydantic to read from ORM objects
    user = db.query(UserDB).filter(UserDB.id == user_id).first()
    return user  # Works because from_attributes=True
    """
    # Simulated ORM object
    class ORMUser:
        id = user_id
        username = "john_doe"
        email = "john@example.com"
        is_active = True
    
    orm_user = ORMUser()
    return User.model_validate(orm_user)
```

### Custom Error Responses

```python
from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel
from typing import Optional

app = FastAPI()

class ErrorDetail(BaseModel):
    message: str
    error_code: Optional[str] = None
    field: Optional[str] = None

class Item(BaseModel):
    name: str
    price: float

@app.get("/items/{item_id}", 
         response_model=Item,
         responses={
             404: {"model": ErrorDetail, "description": "Item not found"},
             400: {"model": ErrorDetail, "description": "Invalid item ID"}
         })
async def get_item(item_id: int):
    """
    Documents possible error responses in OpenAPI schema
    """
    if item_id < 1:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=ErrorDetail(
                message="Item ID must be positive",
                error_code="INVALID_ID",
                field="item_id"
            ).model_dump()
        )
    
    if item_id > 1000:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=ErrorDetail(
                message="Item not found",
                error_code="NOT_FOUND"
            ).model_dump()
        )
    
    return Item(name="Sample Item", price=99.99)
```

---

## Advanced Pydantic Features

### Validators

```python
from pydantic import BaseModel, field_validator, model_validator
from typing import Optional
import re

class User(BaseModel):
    username: str
    email: str
    password: str
    password_confirm: str
    age: Optional[int] = None
    
    @field_validator('username')
    @classmethod
    def username_alphanumeric(cls, v):
        """Validate single field"""
        if not re.match(r'^[a-zA-Z0-9_]+$', v):
            raise ValueError('Username must be alphanumeric')
        return v.lower()  # Convert to lowercase
    
    @field_validator('email')
    @classmethod
    def email_valid(cls, v):
        """Basic email validation"""
        if '@' not in v:
            raise ValueError('Invalid email')
        return v.lower()
    
    @field_validator('password')
    @classmethod
    def password_strength(cls, v):
        """Validate password strength"""
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters')
        if not re.search(r'[A-Z]', v):
            raise ValueError('Password must contain uppercase letter')
        if not re.search(r'[a-z]', v):
            raise ValueError('Password must contain lowercase letter')
        if not re.search(r'\d', v):
            raise ValueError('Password must contain digit')
        return v
    
    @field_validator('age')
    @classmethod
    def age_valid(cls, v):
        """Validate age range"""
        if v is not None and (v < 0 or v > 150):
            raise ValueError('Age must be between 0 and 150')
        return v
    
    @model_validator(mode='after')
    def passwords_match(self):
        """Validate across multiple fields"""
        if self.password != self.password_confirm:
            raise ValueError('Passwords do not match')
        return self

# Usage
try:
    user = User(
        username="John_Doe123",
        email="john@example.com",
        password="SecurePass123",
        password_confirm="SecurePass123",
        age=25
    )
    print(user)
except ValueError as e:
    print(f"Validation error: {e}")
```

### Computed Fields and Properties

```python
from pydantic import BaseModel, computed_field
from datetime import datetime, date
from typing import Optional

class Person(BaseModel):
    first_name: str
    last_name: str
    birth_date: date
    salary: float
    bonus: Optional[float] = None
    
    @computed_field
    @property
    def full_name(self) -> str:
        """Computed field that appears in serialization"""
        return f"{self.first_name} {self.last_name}"
    
    @computed_field
    @property
    def age(self) -> int:
        """Calculate age from birth date"""
        today = date.today()
        return today.year - self.birth_date.year - (
            (today.month, today.day) < (self.birth_date.month, self.birth_date.day)
        )
    
    @computed_field
    @property
    def total_compensation(self) -> float:
        """Calculate total compensation"""
        return self.salary + (self.bonus or 0)

# Usage
person = Person(
    first_name="John",
    last_name="Doe",
    birth_date=date(1990, 5, 15),
    salary=50000,
    bonus=5000
)

print(person.full_name)  # John Doe
print(person.age)  # Calculated age
print(person.total_compensation)  # 55000
print(person.model_dump())  # Includes computed fields
```

### Model Configuration

```python
from pydantic import BaseModel, ConfigDict, Field
from datetime import datetime

class StrictModel(BaseModel):
    """Strict validation - no type coercion"""
    model_config = ConfigDict(strict=True)
    
    id: int  # Must be int, "123" will fail
    name: str

class FlexibleModel(BaseModel):
    """Default - type coercion allowed"""
    id: int  # "123" will be converted to 123
    name: str

class ImmutableModel(BaseModel):
    """Immutable - cannot change after creation"""
    model_config = ConfigDict(frozen=True)
    
    id: int
    name: str

class ValidateAssignmentModel(BaseModel):
    """Validate on assignment, not just creation"""
    model_config = ConfigDict(validate_assignment=True)
    
    id: int = Field(..., gt=0)
    name: str = Field(..., min_length=1)

# Immutable example
immutable = ImmutableModel(id=1, name="Test")
# immutable.name = "New"  # Raises ValidationError

# Validate on assignment
validated = ValidateAssignmentModel(id=1, name="Test")
# validated.id = -1  # Raises ValidationError
validated.id = 2  # OK
```

---

## Complete Example: CRUD API with Pydantic

```python
from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel, Field, EmailStr, ConfigDict
from typing import Optional, List
from datetime import datetime
from uuid import UUID, uuid4

app = FastAPI(title="User Management API")

# Database simulation
fake_users_db = {}

# Pydantic Models
class UserBase(BaseModel):
    """Base user model with shared fields"""
    email: EmailStr
    username: str = Field(..., min_length=3, max_length=50)
    full_name: Optional[str] = None
    is_active: bool = True

class UserCreate(UserBase):
    """Model for creating a user"""
    password: str = Field(..., min_length=8)

class UserUpdate(BaseModel):
    """Model for updating a user - all fields optional"""
    email: Optional[EmailStr] = None
    username: Optional[str] = Field(None, min_length=3, max_length=50)
    full_name: Optional[str] = None
    is_active: Optional[bool] = None
    password: Optional[str] = Field(None, min_length=8)

class UserInDB(UserBase):
    """Model representing user in database"""
    id: UUID
    hashed_password: str
    created_at: datetime
    updated_at: datetime
    
    model_config = ConfigDict(from_attributes=True)

class UserResponse(UserBase):
    """Model for API responses - no sensitive data"""
    id: UUID
    created_at: datetime
    updated_at: datetime

# Helper functions
def hash_password(password: str) -> str:
    """Simulate password hashing"""
    return f"hashed_{password}"

# API Endpoints
@app.post("/users", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(user: UserCreate):
    """Create a new user"""
    # Check if user exists
    if any(u.email == user.email for u in fake_users_db.values()):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    
    # Create user
    user_id = uuid4()
    now = datetime.now()
    
    user_in_db = UserInDB(
        id=user_id,
        email=user.email,
        username=user.username,
        full_name=user.full_name,
        is_active=user.is_active,
        hashed_password=hash_password(user.password),
        created_at=now,
        updated_at=now
    )
    
    fake_users_db[user_id] = user_in_db
    return user_in_db

@app.get("/users", response_model=List[UserResponse])
async def list_users(
    skip: int = 0,
    limit: int = 100,
    active_only: bool = False
):
    """List all users with pagination"""
    users = list(fake_users_db.values())
    
    if active_only:
        users = [u for u in users if u.is_active]
    
    return users[skip : skip + limit]

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: UUID):
    """Get a specific user by ID"""
    if user_id not in fake_users_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    return fake_users_db[user_id]

@app.patch("/users/{user_id}", response_model=UserResponse)
async def update_user(user_id: UUID, user_update: UserUpdate):
    """Partially update a user"""
    if user_id not in fake_users_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    stored_user = fake_users_db[user_id]
    
    # Update only provided fields
    update_data = user_update.model_dump(exclude_unset=True)
    
    if "password" in update_data:
        update_data["hashed_password"] = hash_password(update_data.pop("password"))
    
    update_data["updated_at"] = datetime.now()
    
    # Create updated user
    updated_user = stored_user.model_copy(update=update_data)
    fake_users_db[user_id] = updated_user
    
    return updated_user

@app.delete("/users/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_user(user_id: UUID):
    """Delete a user"""
    if user_id not in fake_users_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    del fake_users_db[user_id]
```

---

## Best Practices

1. **Separate models for different purposes**: Create, Update, InDB, Response
2. **Use Field() for validation and documentation**: Makes API docs better
3. **Use response_model**: Ensures consistent output and filters sensitive data
4. **Validate early**: Pydantic catches errors before they reach your logic
5. **Use computed fields**: For derived data that should appear in responses
6. **Configure properly**: Use from_attributes for ORM integration
7. **Document with examples**: Use Field(example=...) for better docs
8. **Use validators wisely**: For complex business logic validation

## Common Pitfalls

1. **Not using response_model**: Exposes internal data accidentally
2. **Mixing input and output models**: Security risk with password fields
3. **Forgetting from_attributes**: ORM objects won't work with Pydantic
4. **Over-validation**: Too strict validation hurts usability
5. **Not using exclude_unset for PATCH**: Updates all fields instead of just provided ones

---

## Summary

In Chapter 2, you learned:
- Pydantic fundamentals and field types
- Request body handling with different data types
- Response models and filtering sensitive data
- Form data and file uploads
- Advanced validation with validators
- Complete CRUD example with proper models

**Next: Chapter 3 - Path Operation Details & Validation**