# Chapter 5: Data Persistence & DB Integration

## Introduction to Database Integration

FastAPI works seamlessly with both SQL and NoSQL databases. This chapter focuses on:
- SQLAlchemy ORM for SQL databases
- Async database access
- Database migrations with Alembic
- Redis for caching
- Best practices for production

---

## SQL Databases with SQLAlchemy

### Installation

```bash
# Install SQLAlchemy and database driver
uv pip install sqlalchemy

# For PostgreSQL
uv pip install psycopg2-binary

# For PostgreSQL (async)
uv pip install asyncpg

# For MySQL
uv pip install pymysql

# For SQLite (built-in, no driver needed)
```

### Basic SQLAlchemy Setup (Synchronous)

```python
# database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# Database URL
# SQLite: "sqlite:///./test.db"
# PostgreSQL: "postgresql://user:password@localhost/dbname"
# MySQL: "mysql+pymysql://user:password@localhost/dbname"

SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"

# Create engine
engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    connect_args={"check_same_thread": False}  # Only for SQLite
)

# Create SessionLocal class
SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

# Base class for models
Base = declarative_base()

# Dependency to get DB session
def get_db():
    """
    Provide database session with automatic cleanup
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### Creating Models

```python
# models/user.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database import Base

class User(Base):
    """User database model"""
    __tablename__ = "users"
    
    # Columns
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String)
    is_active = Column(Boolean, default=True)
    is_admin = Column(Boolean, default=False)
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    items = relationship("Item", back_populates="owner")
    posts = relationship("Post", back_populates="author")

class Item(Base):
    """Item database model"""
    __tablename__ = "items"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)
    description = Column(String)
    owner_id = Column(Integer, ForeignKey("users.id"))
    
    # Relationship
    owner = relationship("User", back_populates="items")

class Post(Base):
    """Post database model"""
    __tablename__ = "posts"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, nullable=False)
    content = Column(String)
    published = Column(Boolean, default=False)
    author_id = Column(Integer, ForeignKey("users.id"))
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationship
    author = relationship("User", back_populates="posts")
```

### Pydantic Schemas

```python
# schemas/user.py
from pydantic import BaseModel, EmailStr, ConfigDict
from typing import Optional, List
from datetime import datetime

# Base schemas
class UserBase(BaseModel):
    email: EmailStr
    username: str
    full_name: Optional[str] = None

class UserCreate(UserBase):
    password: str

class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    username: Optional[str] = None
    full_name: Optional[str] = None
    password: Optional[str] = None
    is_active: Optional[bool] = None

class UserInDB(UserBase):
    id: int
    is_active: bool
    is_admin: bool
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    # Configure Pydantic to work with SQLAlchemy models
    model_config = ConfigDict(from_attributes=True)

class User(UserInDB):
    """Public user schema (no sensitive data)"""
    pass

# Item schemas
class ItemBase(BaseModel):
    title: str
    description: Optional[str] = None

class ItemCreate(ItemBase):
    pass

class ItemUpdate(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None

class Item(ItemBase):
    id: int
    owner_id: int
    
    model_config = ConfigDict(from_attributes=True)

# User with relationships
class UserWithItems(User):
    items: List[Item] = []
```

### CRUD Operations

```python
# crud/user.py
from sqlalchemy.orm import Session
from typing import List, Optional
from models.user import User
from schemas.user import UserCreate, UserUpdate
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

# Create
def create_user(db: Session, user: UserCreate) -> User:
    """Create a new user"""
    hashed_password = get_password_hash(user.password)
    db_user = User(
        email=user.email,
        username=user.username,
        full_name=user.full_name,
        hashed_password=hashed_password
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

# Read
def get_user(db: Session, user_id: int) -> Optional[User]:
    """Get user by ID"""
    return db.query(User).filter(User.id == user_id).first()

def get_user_by_email(db: Session, email: str) -> Optional[User]:
    """Get user by email"""
    return db.query(User).filter(User.email == email).first()

def get_user_by_username(db: Session, username: str) -> Optional[User]:
    """Get user by username"""
    return db.query(User).filter(User.username == username).first()

def get_users(
    db: Session,
    skip: int = 0,
    limit: int = 100,
    is_active: Optional[bool] = None
) -> List[User]:
    """Get list of users with pagination"""
    query = db.query(User)
    
    if is_active is not None:
        query = query.filter(User.is_active == is_active)
    
    return query.offset(skip).limit(limit).all()

# Update
def update_user(db: Session, user_id: int, user_update: UserUpdate) -> Optional[User]:
    """Update user"""
    db_user = get_user(db, user_id)
    if not db_user:
        return None
    
    update_data = user_update.model_dump(exclude_unset=True)
    
    # Hash password if updating
    if "password" in update_data:
        update_data["hashed_password"] = get_password_hash(update_data.pop("password"))
    
    for field, value in update_data.items():
        setattr(db_user, field, value)
    
    db.commit()
    db.refresh(db_user)
    return db_user

# Delete
def delete_user(db: Session, user_id: int) -> bool:
    """Delete user"""
    db_user = get_user(db, user_id)
    if not db_user:
        return False
    
    db.delete(db_user)
    db.commit()
    return True

# Authentication
def authenticate_user(db: Session, username: str, password: str) -> Optional[User]:
    """Authenticate user by username and password"""
    user = get_user_by_username(db, username)
    if not user:
        return None
    if not verify_password(password, user.hashed_password):
        return None
    return user
```

### Complete FastAPI Integration

```python
# main.py
from fastapi import FastAPI, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from database import engine, get_db, Base
from models import user as models
from schemas import user as schemas
from crud import user as crud

# Create tables
Base.metadata.create_all(bind=engine)

app = FastAPI(title="User Management API")

# ============================================================================
# User Endpoints
# ============================================================================

@app.post("/users", response_model=schemas.User, status_code=status.HTTP_201_CREATED)
async def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):
    """Create a new user"""
    # Check if user exists
    db_user = crud.get_user_by_email(db, email=user.email)
    if db_user:
        raise HTTPException(
            status_code=400,
            detail="Email already registered"
        )
    
    db_user = crud.get_user_by_username(db, username=user.username)
    if db_user:
        raise HTTPException(
            status_code=400,
            detail="Username already taken"
        )
    
    return crud.create_user(db=db, user=user)

@app.get("/users", response_model=List[schemas.User])
async def list_users(
    skip: int = 0,
    limit: int = 100,
    is_active: bool = None,
    db: Session = Depends(get_db)
):
    """List users"""
    users = crud.get_users(db, skip=skip, limit=limit, is_active=is_active)
    return users

@app.get("/users/{user_id}", response_model=schemas.User)
async def get_user(user_id: int, db: Session = Depends(get_db)):
    """Get user by ID"""
    db_user = crud.get_user(db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return db_user

@app.patch("/users/{user_id}", response_model=schemas.User)
async def update_user(
    user_id: int,
    user: schemas.UserUpdate,
    db: Session = Depends(get_db)
):
    """Update user"""
    db_user = crud.update_user(db, user_id=user_id, user_update=user)
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return db_user

@app.delete("/users/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_user(user_id: int, db: Session = Depends(get_db)):
    """Delete user"""
    success = crud.delete_user(db, user_id=user_id)
    if not success:
        raise HTTPException(status_code=404, detail="User not found")
```

---

## Async Database Access

### Async SQLAlchemy Setup

```bash
# Install async SQLAlchemy
uv pip install sqlalchemy[asyncio] asyncpg
```

```python
# database_async.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# Async database URL (note the +asyncpg)
DATABASE_URL = "postgresql+asyncpg://user:password@localhost/dbname"

# Create async engine
engine = create_async_engine(
    DATABASE_URL,
    echo=True,  # Log SQL queries
    future=True
)

# Create async session factory
AsyncSessionLocal = sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)

Base = declarative_base()

# Async dependency
async def get_async_db():
    """Provide async database session"""
    async with AsyncSessionLocal() as session:
        yield session
```

### Async CRUD Operations

```python
# crud/user_async.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy import update, delete
from typing import List, Optional
from models.user import User
from schemas.user import UserCreate, UserUpdate

# Create
async def create_user(db: AsyncSession, user: UserCreate) -> User:
    """Create user asynchronously"""
    db_user = User(
        email=user.email,
        username=user.username,
        full_name=user.full_name,
        hashed_password=get_password_hash(user.password)
    )
    db.add(db_user)
    await db.commit()
    await db.refresh(db_user)
    return db_user

# Read
async def get_user(db: AsyncSession, user_id: int) -> Optional[User]:
    """Get user by ID"""
    result = await db.execute(
        select(User).filter(User.id == user_id)
    )
    return result.scalar_one_or_none()

async def get_users(
    db: AsyncSession,
    skip: int = 0,
    limit: int = 100
) -> List[User]:
    """Get list of users"""
    result = await db.execute(
        select(User).offset(skip).limit(limit)
    )
    return result.scalars().all()

# Update
async def update_user(
    db: AsyncSession,
    user_id: int,
    user_update: UserUpdate
) -> Optional[User]:
    """Update user"""
    update_data = user_update.model_dump(exclude_unset=True)
    
    if "password" in update_data:
        update_data["hashed_password"] = get_password_hash(
            update_data.pop("password")
        )
    
    stmt = (
        update(User)
        .where(User.id == user_id)
        .values(**update_data)
    )
    await db.execute(stmt)
    await db.commit()
    
    return await get_user(db, user_id)

# Delete
async def delete_user(db: AsyncSession, user_id: int) -> bool:
    """Delete user"""
    stmt = delete(User).where(User.id == user_id)
    result = await db.execute(stmt)
    await db.commit()
    return result.rowcount > 0
```

### Async FastAPI Endpoints

```python
# main_async.py
from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List

from database_async import get_async_db
from crud import user_async as crud
from schemas import user as schemas

app = FastAPI()

@app.post("/users", response_model=schemas.User)
async def create_user(
    user: schemas.UserCreate,
    db: AsyncSession = Depends(get_async_db)
):
    """Create user (async)"""
    return await crud.create_user(db, user)

@app.get("/users", response_model=List[schemas.User])
async def list_users(
    skip: int = 0,
    limit: int = 100,
    db: AsyncSession = Depends(get_async_db)
):
    """List users (async)"""
    return await crud.get_users(db, skip=skip, limit=limit)

@app.get("/users/{user_id}", response_model=schemas.User)
async def get_user(
    user_id: int,
    db: AsyncSession = Depends(get_async_db)
):
    """Get user (async)"""
    user = await crud.get_user(db, user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user
```

---

## Database Migrations with Alembic

### Installation and Setup

```bash
# Install Alembic
uv pip install alembic

# Initialize Alembic
alembic init alembic
```

### Configure Alembic

```python
# alembic/env.py
from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool
from alembic import context

# Import your models
from database import Base
from models.user import User
from models.item import Item

# this is the Alembic Config object
config = context.config

# Set database URL
config.set_main_option(
    "sqlalchemy.url",
    "postgresql://user:password@localhost/dbname"
)

# Import all models for autogenerate
target_metadata = Base.metadata

def run_migrations_offline():
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online():
    """Run migrations in 'online' mode."""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
```

### Common Alembic Commands

```bash
# Create initial migration
alembic revision --autogenerate -m "Initial migration"

# Apply migrations
alembic upgrade head

# Downgrade one version
alembic downgrade -1

# Show current version
alembic current

# Show migration history
alembic history

# Create empty migration (for custom changes)
alembic revision -m "Custom migration"

# Upgrade to specific version
alembic upgrade <revision_id>

# Downgrade to specific version
alembic downgrade <revision_id>
```

### Example Migration File

```python
# alembic/versions/001_initial_migration.py
"""Initial migration

Revision ID: 001
Revises: 
Create Date: 2024-01-01 12:00:00
"""
from alembic import op
import sqlalchemy as sa

# revision identifiers
revision = '001'
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    """Create initial tables"""
    # Users table
    op.create_table(
        'users',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('email', sa.String(), nullable=False),
        sa.Column('username', sa.String(), nullable=False),
        sa.Column('hashed_password', sa.String(), nullable=False),
        sa.Column('full_name', sa.String(), nullable=True),
        sa.Column('is_active', sa.Boolean(), nullable=True),
        sa.Column('is_admin', sa.Boolean(), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), 
                  server_default=sa.text('now()'), nullable=True),
        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index('ix_users_email', 'users', ['email'], unique=True)
    op.create_index('ix_users_username', 'users', ['username'], unique=True)

def downgrade():
    """Drop tables"""
    op.drop_index('ix_users_username', table_name='users')
    op.drop_index('ix_users_email', table_name='users')
    op.drop_table('users')
```

---

## Redis for Caching and Sessions

### Installation

```bash
# Install redis client
uv pip install redis aioredis
```

### Redis Connection

```python
# redis_client.py
import redis
from typing import Optional
import json

class RedisClient:
    """Redis client wrapper"""
    
    def __init__(self, host: str = "localhost", port: int = 6379, db: int = 0):
        self.client = redis.Redis(
            host=host,
            port=port,
            db=db,
            decode_responses=True
        )
    
    def set(self, key: str, value: any, expire: int = None):
        """Set key with optional expiration (seconds)"""
        value_str = json.dumps(value)
        if expire:
            self.client.setex(key, expire, value_str)
        else:
            self.client.set(key, value_str)
    
    def get(self, key: str) -> Optional[any]:
        """Get value by key"""
        value = self.client.get(key)
        if value:
            return json.loads(value)
        return None
    
    def delete(self, key: str):
        """Delete key"""
        self.client.delete(key)
    
    def exists(self, key: str) -> bool:
        """Check if key exists"""
        return bool(self.client.exists(key))
    
    def increment(self, key: str, amount: int = 1) -> int:
        """Increment value"""
        return self.client.incrby(key, amount)
    
    def expire(self, key: str, seconds: int):
        """Set expiration on key"""
        self.client.expire(key, seconds)

# Create global instance
redis_client = RedisClient()
```

### Caching Pattern

```python
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
from redis_client import redis_client
from database import get_db
from crud import user as crud
import json

app = FastAPI()

def get_cached_user(user_id: int):
    """Get user from cache or database"""
    cache_key = f"user:{user_id}"
    
    # Try cache first
    cached_user = redis_client.get(cache_key)
    if cached_user:
        return cached_user
    
    return None

@app.get("/users/{user_id}")
async def get_user_cached(user_id: int, db: Session = Depends(get_db)):
    """Get user with caching"""
    # Check cache
    cached = get_cached_user(user_id)
    if cached:
        return {"source": "cache", "user": cached}
    
    # Get from database
    user = crud.get_user(db, user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Cache for 5 minutes
    user_dict = {
        "id": user.id,
        "username": user.username,
        "email": user.email
    }
    redis_client.set(f"user:{user_id}", user_dict, expire=300)
    
    return {"source": "database", "user": user_dict}

@app.patch("/users/{user_id}")
async def update_user_invalidate_cache(
    user_id: int,
    user_update: schemas.UserUpdate,
    db: Session = Depends(get_db)
):
    """Update user and invalidate cache"""
    user = crud.update_user(db, user_id, user_update)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Invalidate cache
    redis_client.delete(f"user:{user_id}")
    
    return user
```

### Rate Limiting with Redis

```python
from fastapi import FastAPI, Request, HTTPException
from redis_client import redis_client
import time

app = FastAPI()

def rate_limit(key: str, limit: int, window: int) -> bool:
    """
    Rate limiting using sliding window
    key: identifier (e.g., user_id, ip)
    limit: max requests
    window: time window in seconds
    """
    current = int(time.time())
    window_start = current - window
    
    # Use sorted set for sliding window
    redis_key = f"rate_limit:{key}"
    
    # Remove old entries
    redis_client.client.zremrangebyscore(redis_key, 0, window_start)
    
    # Count requests in current window
    request_count = redis_client.client.zcard(redis_key)
    
    if request_count >= limit:
        return False
    
    # Add current request
    redis_client.client.zadd(redis_key, {str(current): current})
    redis_client.client.expire(redis_key, window)
    
    return True

@app.middleware("http")
async def rate_limit_middleware(request: Request, call_next):
    """Rate limit middleware"""
    # Use IP address as identifier
    client_ip = request.client.host
    
    # Allow 100 requests per minute
    if not rate_limit(client_ip, limit=100, window=60):
        raise HTTPException(
            status_code=429,
            detail="Rate limit exceeded"
        )
    
    response = await call_next(request)
    return response
```

---

## Transaction Management

### Basic Transactions

```python
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError

def transfer_item(
    db: Session,
    item_id: int,
    from_user_id: int,
    to_user_id: int
):
    """Transfer item between users with transaction"""
    try:
        # Start transaction (implicit with session)
        item = db.query(Item).filter(Item.id == item_id).first()
        if not item or item.owner_id != from_user_id:
            raise ValueError("Item not found or not owned by user")
        
        # Update item owner
        item.owner_id = to_user_id
        
        # Create transaction record
        transaction = Transaction(
            item_id=item_id,
            from_user_id=from_user_id,
            to_user_id=to_user_id
        )
        db.add(transaction)
        
        # Commit transaction
        db.commit()
        
        return True
    except Exception as e:
        # Rollback on error
        db.rollback()
        raise e
```

### Advanced Transaction Handling

```python
from contextlib import contextmanager

@contextmanager
def transaction(db: Session):
    """Transaction context manager"""
    try:
        yield db
        db.commit()
    except Exception:
        db.rollback()
        raise

# Usage
def complex_operation(db: Session):
    with transaction(db):
        # Multiple database operations
        user = create_user(db, user_data)
        item = create_item(db, item_data)
        link_user_item(db, user.id, item.id)
        # If any fails, all rollback
```

---

## Complete Example: E-commerce with Database

```python
# models/ecommerce.py
from sqlalchemy import Column, Integer, String, Float, Boolean, DateTime, ForeignKey, Enum
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database import Base
import enum

class OrderStatus(enum.Enum):
    pending = "pending"
    processing = "processing"
    shipped = "shipped"
    delivered = "delivered"
    cancelled = "cancelled"

class Product(Base):
    __tablename__ = "products"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False, index=True)
    description = Column(String)
    price = Column(Float, nullable=False)
    stock = Column(Integer, default=0)
    category = Column(String, index=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    order_items = relationship("OrderItem", back_populates="product")

class Order(Base):
    __tablename__ = "orders"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    total_amount = Column(Float, nullable=False)
    status = Column(Enum(OrderStatus), default=OrderStatus.pending)
    shipping_address = Column(String, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    user = relationship("User")
    order_items = relationship("OrderItem", back_populates="order")

class OrderItem(Base):
    __tablename__ = "order_items"
    
    id = Column(Integer, primary_key=True, index=True)
    order_id = Column(Integer, ForeignKey("orders.id"))
    product_id = Column(Integer, ForeignKey("products.id"))
    quantity = Column(Integer, nullable=False)
    price_at_purchase = Column(Float, nullable=False)
    
    order = relationship("Order", back_populates="order_items")
    product = relationship("Product", back_populates="order_items")

# crud/order.py
from sqlalchemy.orm import Session
from models.ecommerce import Order, OrderItem, Product, OrderStatus
from typing import List

def create_order(
    db: Session,
    user_id: int,
    items: List[dict],
    shipping_address: str
) -> Order:
    """Create order with transaction"""
    try:
        total_amount = 0
        order_items = []
        
        # Validate and calculate
        for item_data in items:
            product = db.query(Product).filter(
                Product.id == item_data["product_id"]
            ).first()
            
            if not product:
                raise ValueError(f"Product {item_data['product_id']} not found")
            
            if product.stock < item_data["quantity"]:
                raise ValueError(
                    f"Insufficient stock for {product.name}"
                )
            
            # Update stock
            product.stock -= item_data["quantity"]
            
            # Calculate amount
            item_total = product.price * item_data["quantity"]
            total_amount += item_total
            
            # Create order item
            order_item = OrderItem(
                product_id=product.id,
                quantity=item_data["quantity"],
                price_at_purchase=product.price
            )
            order_items.append(order_item)
        
        # Create order
        order = Order(
            user_id=user_id,
            total_amount=total_amount,
            shipping_address=shipping_address,
            order_items=order_items
        )
        
        db.add(order)
        db.commit()
        db.refresh(order)
        
        return order
        
    except Exception as e:
        db.rollback()
        raise e

# main.py
@app.post("/orders", response_model=schemas.Order)
async def create_order_endpoint(
    order_data: schemas.OrderCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Create new order"""
    try:
        order = create_order(
            db,
            user_id=current_user.id,
            items=order_data.items,
            shipping_address=order_data.shipping_address
        )
        
        # Invalidate product cache
        for item in order_data.items:
            redis_client.delete(f"product:{item.product_id}")
        
        return order
        
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
```

---

## Best Practices

1. **Use connection pooling**: SQLAlchemy handles this automatically
2. **Always use sessions properly**: Use dependency injection with cleanup
3. **Index frequently queried columns**: email, username, foreign keys
4. **Use transactions**: For operations that must succeed or fail together
5. **Lazy vs eager loading**: Use `joinedload` for relationships when needed
6. **Cache expensive queries**: Use Redis for frequently accessed data
7. **Handle database errors**: Catch and handle `SQLAlchemyError`
8. **Use migrations**: Never modify database manually in production
9. **Async for I/O bound**: Use async SQLAlchemy for high concurrency
10. **Monitor queries**: Log slow queries and optimize

## Common Pitfalls

1. **N+1 queries**: Loading relationships in loops
2. **Not closing sessions**: Memory leaks
3. **Missing indexes**: Slow queries on large tables
4. **No transaction handling**: Data inconsistency
5. **Storing sensitive data unencrypted**: Always hash passwords
6. **Not using connection pooling**: Poor performance
7. **Mixing sync and async**: Causes blocking

---

## Summary

In Chapter 5, you learned:
- SQLAlchemy ORM setup and models
- CRUD operations (sync and async)
- Database migrations with Alembic
- Redis for caching and rate limiting
- Transaction management
- Complete e-commerce example

**Next: Chapter 6 - Authentication, Authorization & Security**