# Chapter 3: Path Operation Details & Validation

## Advanced Parameter Handling

### Path Parameters with Detailed Validation

```python
from fastapi import FastAPI, Path
from typing import Optional
from enum import Enum

app = FastAPI()

# Basic path parameter with constraints
@app.get("/items/{item_id}")
async def get_item(
    item_id: int = Path(
        ...,  # Required
        title="Item ID",
        description="The unique identifier of the item",
        ge=1,  # Greater than or equal to 1
        le=1000,  # Less than or equal to 1000
        example=42
    )
):
    return {"item_id": item_id}

# String path parameter with length and pattern validation
@app.get("/users/{username}")
async def get_user(
    username: str = Path(
        ...,
        min_length=3,
        max_length=50,
        pattern="^[a-zA-Z0-9_-]+$",
        description="Username (alphanumeric, underscore, hyphen only)",
        example="john_doe"
    )
):
    return {"username": username}

# Float/Decimal path parameter
@app.get("/prices/{price}")
async def get_price(
    price: float = Path(
        ...,
        gt=0,  # Greater than 0
        lt=1000000,  # Less than 1 million
        description="Price in USD"
    )
):
    return {"price": price}

# Multiple path parameters with validation
@app.get("/stores/{store_id}/products/{product_id}")
async def get_store_product(
    store_id: int = Path(..., ge=1, description="Store ID"),
    product_id: int = Path(..., ge=1, description="Product ID")
):
    return {"store_id": store_id, "product_id": product_id}

# Path parameter with Enum
class Category(str, Enum):
    electronics = "electronics"
    books = "books"
    clothing = "clothing"
    food = "food"

@app.get("/categories/{category}")
async def get_category(
    category: Category = Path(..., description="Product category")
):
    return {
        "category": category,
        "category_name": category.value
    }
```

### Query Parameters with Advanced Validation

```python
from fastapi import FastAPI, Query
from typing import Optional, List, Set
from datetime import date, datetime

app = FastAPI()

# Query parameter with all validation options
@app.get("/search")
async def search_items(
    q: str = Query(
        ...,  # Required
        min_length=3,
        max_length=100,
        pattern="^[a-zA-Z0-9 ]+$",
        title="Search Query",
        description="Search term for items",
        example="laptop computer"
    ),
    skip: int = Query(
        0,
        ge=0,
        description="Number of items to skip"
    ),
    limit: int = Query(
        10,
        ge=1,
        le=100,
        description="Maximum number of items to return"
    )
):
    return {"q": q, "skip": skip, "limit": limit}

# Optional query parameter with default None
@app.get("/items")
async def list_items(
    category: Optional[str] = Query(
        None,
        min_length=3,
        max_length=50,
        description="Filter by category"
    ),
    min_price: Optional[float] = Query(
        None,
        ge=0,
        description="Minimum price"
    ),
    max_price: Optional[float] = Query(
        None,
        ge=0,
        description="Maximum price"
    )
):
    filters = {}
    if category:
        filters["category"] = category
    if min_price is not None:
        filters["min_price"] = min_price
    if max_price is not None:
        filters["max_price"] = max_price
    return {"filters": filters}

# List query parameters
@app.get("/filter")
async def filter_items(
    tags: List[str] = Query(
        [],  # Default empty list
        min_length=2,  # Each tag min 2 chars
        max_length=20,  # Each tag max 20 chars
        description="Filter by tags"
    ),
    colors: Set[str] = Query(
        set(),
        description="Filter by colors (unique values)"
    )
):
    """
    Usage: /filter?tags=python&tags=fastapi&colors=red&colors=blue
    """
    return {"tags": tags, "colors": list(colors)}

# Query parameter with alias
@app.get("/items")
async def search_with_alias(
    item_query: str = Query(
        ...,
        alias="item-query",  # Use kebab-case in URL
        min_length=3,
        description="Search query"
    )
):
    """
    Usage: /items?item-query=laptop
    """
    return {"query": item_query}

# Date range query parameters
@app.get("/reports")
async def get_reports(
    start_date: Optional[date] = Query(
        None,
        description="Start date (YYYY-MM-DD)"
    ),
    end_date: Optional[date] = Query(
        None,
        description="End date (YYYY-MM-DD)"
    )
):
    return {
        "start_date": start_date,
        "end_date": end_date
    }

# Datetime query parameter
@app.get("/events")
async def get_events(
    created_after: Optional[datetime] = Query(
        None,
        description="Filter events created after this datetime"
    )
):
    return {"created_after": created_after}

# Deprecated query parameter
@app.get("/legacy")
async def legacy_endpoint(
    old_param: Optional[str] = Query(
        None,
        deprecated=True,
        description="This parameter is deprecated, use new_param instead"
    ),
    new_param: Optional[str] = Query(
        None,
        description="New parameter to use"
    )
):
    return {"old_param": old_param, "new_param": new_param}
```

### Header Parameters

```python
from fastapi import FastAPI, Header
from typing import Optional, List

app = FastAPI()

# Basic header parameter
@app.get("/items")
async def read_items(
    user_agent: Optional[str] = Header(None)
):
    """
    Header name is automatically converted from snake_case to kebab-case
    user_agent becomes User-Agent
    """
    return {"User-Agent": user_agent}

# Header with custom name
@app.get("/items")
async def read_items(
    x_token: str = Header(
        ...,
        description="Authentication token"
    )
):
    """
    x_token becomes X-Token header
    """
    return {"X-Token": x_token}

# Multiple header values (for duplicate headers)
@app.get("/items")
async def read_items(
    x_token: List[str] = Header(
        [],
        description="Multiple tokens"
    )
):
    """
    Handles multiple X-Token headers
    """
    return {"X-Token values": x_token}

# Header with validation
@app.get("/items")
async def read_items(
    x_api_key: str = Header(
        ...,
        min_length=32,
        max_length=32,
        description="API Key (32 characters)"
    )
):
    return {"api_key_length": len(x_api_key)}

# Common headers
@app.get("/items")
async def read_items(
    user_agent: Optional[str] = Header(None),
    accept_language: Optional[str] = Header(None),
    authorization: Optional[str] = Header(None),
    content_type: Optional[str] = Header(None)
):
    return {
        "user_agent": user_agent,
        "language": accept_language,
        "auth": authorization,
        "content_type": content_type
    }

# Disable automatic header name conversion
@app.get("/items")
async def read_items(
    x_custom_header: str = Header(
        ...,
        convert_underscores=False  # Keep exact name
    )
):
    return {"header": x_custom_header}
```

### Cookie Parameters

```python
from fastapi import FastAPI, Cookie, Response
from typing import Optional

app = FastAPI()

# Basic cookie parameter
@app.get("/items")
async def read_items(
    session_id: Optional[str] = Cookie(None)
):
    return {"session_id": session_id}

# Cookie with validation
@app.get("/items")
async def read_items(
    ads_id: str = Cookie(
        ...,
        min_length=36,
        max_length=36,
        description="Advertisement tracking ID"
    )
):
    return {"ads_id": ads_id}

# Setting cookies in response
@app.post("/login")
async def login(response: Response):
    """
    Set cookies in the response
    """
    response.set_cookie(
        key="session_id",
        value="abc123xyz",
        max_age=3600,  # 1 hour
        httponly=True,  # Not accessible via JavaScript
        secure=True,  # Only over HTTPS
        samesite="lax"  # CSRF protection
    )
    return {"message": "Logged in successfully"}

# Delete cookie
@app.post("/logout")
async def logout(response: Response):
    response.delete_cookie(key="session_id")
    return {"message": "Logged out successfully"}

# Multiple cookies
@app.get("/preferences")
async def get_preferences(
    theme: Optional[str] = Cookie("light"),
    language: Optional[str] = Cookie("en"),
    timezone: Optional[str] = Cookie("UTC")
):
    return {
        "theme": theme,
        "language": language,
        "timezone": timezone
    }
```

---

## Request Lifecycle & Order of Evaluation

Understanding how FastAPI processes requests is crucial for debugging and building complex applications.

### Request Processing Flow

```python
from fastapi import FastAPI, Depends, Request
from typing import Optional
import time

app = FastAPI()

# 1. Middleware (runs first, wraps everything)
@app.middleware("http")
async def log_requests(request: Request, call_next):
    """Middleware runs before any endpoint"""
    start_time = time.time()
    print(f"1. Middleware: Request started - {request.url}")
    
    response = await call_next(request)
    
    process_time = time.time() - start_time
    print(f"6. Middleware: Request completed in {process_time:.4f}s")
    response.headers["X-Process-Time"] = str(process_time)
    return response

# 2. Dependencies (evaluated in order of definition)
async def first_dependency():
    print("2. First dependency executed")
    return "first"

async def second_dependency(first: str = Depends(first_dependency)):
    print("3. Second dependency executed (depends on first)")
    return f"{first}_second"

async def third_dependency(second: str = Depends(second_dependency)):
    print("4. Third dependency executed (depends on second)")
    return f"{second}_third"

# 3. Path operation function
@app.get("/demo")
async def demo_endpoint(
    result: str = Depends(third_dependency),
    item_id: Optional[int] = None
):
    """
    Execution order:
    1. Middleware (before)
    2. Dependencies (in order of dependency chain)
    3. Path operation function
    4. Response model validation (if specified)
    5. Middleware (after)
    """
    print("5. Endpoint function executed")
    return {"result": result, "item_id": item_id}

# Test: GET http://localhost:8000/demo
# Output:
# 1. Middleware: Request started
# 2. First dependency executed
# 3. Second dependency executed (depends on first)
# 4. Third dependency executed (depends on second)
# 5. Endpoint function executed
# 6. Middleware: Request completed
```

### Dependency Evaluation Order

```python
from fastapi import FastAPI, Depends

app = FastAPI()

# Dependencies are cached per request
call_count = {"count": 0}

async def expensive_dependency():
    """This runs only ONCE per request, even if used multiple times"""
    call_count["count"] += 1
    print(f"Expensive operation called (count: {call_count['count']})")
    return "expensive_result"

async def first_dep(data: str = Depends(expensive_dependency)):
    print("First dependency using expensive_dependency")
    return f"first_{data}"

async def second_dep(data: str = Depends(expensive_dependency)):
    print("Second dependency using expensive_dependency")
    return f"second_{data}"

@app.get("/cached")
async def cached_endpoint(
    first: str = Depends(first_dep),
    second: str = Depends(second_dep)
):
    """
    expensive_dependency runs only ONCE
    Both first_dep and second_dep get the cached result
    """
    return {"first": first, "second": second}

# To disable caching, use use_cache=False
async def uncached_dep():
    print("Uncached operation")
    return "uncached"

@app.get("/uncached")
async def uncached_endpoint(
    data1: str = Depends(uncached_dep, use_cache=False),
    data2: str = Depends(uncached_dep, use_cache=False)
):
    """This will call uncached_dep twice"""
    return {"data1": data1, "data2": data2}
```

### Event Handlers and Lifecycle

```python
from fastapi import FastAPI
from contextlib import asynccontextmanager

# Modern approach (FastAPI 0.109+): Lifespan
@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Lifespan context manager runs on startup and shutdown
    """
    # Startup
    print("Application starting up...")
    # Initialize resources: DB connections, load ML models, etc.
    db_connection = "database_connection"
    cache_connection = "redis_connection"
    
    # Store in app state
    app.state.db = db_connection
    app.state.cache = cache_connection
    
    yield  # Application runs here
    
    # Shutdown
    print("Application shutting down...")
    # Cleanup: close connections, save state, etc.
    app.state.db = None
    app.state.cache = None

app = FastAPI(lifespan=lifespan)

# Legacy approach (still works): Event handlers
app2 = FastAPI()

@app2.on_event("startup")
async def startup_event():
    """Runs once when application starts"""
    print("Application started (legacy)")
    app2.state.startup_time = "2024-01-01"

@app2.on_event("shutdown")
async def shutdown_event():
    """Runs once when application shuts down"""
    print("Application stopped (legacy)")

@app.get("/")
async def root():
    """Access app state from lifespan"""
    return {
        "db": app.state.db,
        "cache": app.state.cache
    }
```

---

## Custom Responses

### Different Response Types

```python
from fastapi import FastAPI
from fastapi.responses import (
    JSONResponse,
    PlainTextResponse,
    HTMLResponse,
    RedirectResponse,
    StreamingResponse,
    FileResponse,
    Response
)
import io
import time

app = FastAPI()

# 1. JSONResponse (default)
@app.get("/json")
async def json_response():
    """Standard JSON response (default)"""
    return {"message": "Hello World"}

@app.get("/json-custom", response_class=JSONResponse)
async def custom_json_response():
    """Explicit JSON response with custom headers"""
    content = {"message": "Custom JSON"}
    headers = {"X-Custom-Header": "Value"}
    return JSONResponse(content=content, headers=headers)

# 2. PlainTextResponse
@app.get("/text", response_class=PlainTextResponse)
async def text_response():
    """Plain text response"""
    return "Hello World in plain text"

# 3. HTMLResponse
@app.get("/html", response_class=HTMLResponse)
async def html_response():
    """HTML response"""
    html_content = """
    <html>
        <head>
            <title>FastAPI HTML</title>
        </head>
        <body>
            <h1>Hello from FastAPI</h1>
            <p>This is an HTML response</p>
        </body>
    </html>
    """
    return html_content

# 4. RedirectResponse
@app.get("/redirect")
async def redirect():
    """Redirect to another URL"""
    return RedirectResponse(url="/docs")

@app.get("/redirect-external")
async def redirect_external():
    """Redirect to external URL"""
    return RedirectResponse(
        url="https://fastapi.tiangolo.com",
        status_code=307  # Temporary redirect
    )

# 5. StreamingResponse
async def generate_data():
    """Generator for streaming data"""
    for i in range(10):
        yield f"Data chunk {i}\n"
        time.sleep(0.5)  # Simulate slow data generation

@app.get("/stream")
async def stream_response():
    """Stream data to client"""
    return StreamingResponse(
        generate_data(),
        media_type="text/plain"
    )

async def generate_csv():
    """Generate CSV data on the fly"""
    yield "id,name,email\n"
    for i in range(100):
        yield f"{i},User{i},user{i}@example.com\n"

@app.get("/download-csv")
async def download_csv():
    """Download CSV file (streaming)"""
    return StreamingResponse(
        generate_csv(),
        media_type="text/csv",
        headers={"Content-Disposition": "attachment; filename=users.csv"}
    )

# 6. FileResponse
@app.get("/download-file")
async def download_file():
    """Download a static file"""
    return FileResponse(
        path="path/to/file.pdf",
        filename="document.pdf",
        media_type="application/pdf"
    )

@app.get("/image")
async def get_image():
    """Serve an image file"""
    return FileResponse(
        path="path/to/image.jpg",
        media_type="image/jpeg"
    )

# 7. Custom Response with Manual Control
@app.get("/custom")
async def custom_response():
    """Full manual control over response"""
    content = b"Custom binary content"
    headers = {
        "X-Custom-Header": "CustomValue",
        "Cache-Control": "max-age=3600"
    }
    return Response(
        content=content,
        status_code=200,
        headers=headers,
        media_type="application/octet-stream"
    )

# 8. Response with Cookies
@app.get("/with-cookies")
async def response_with_cookies():
    """Set cookies in response"""
    response = JSONResponse(content={"message": "Cookies set"})
    response.set_cookie(
        key="my_cookie",
        value="cookie_value",
        max_age=3600,
        httponly=True,
        secure=True,
        samesite="lax"
    )
    return response

# 9. Empty response (204 No Content)
@app.delete("/items/{item_id}", status_code=204)
async def delete_item(item_id: int):
    """Delete without returning content"""
    # Perform deletion
    return Response(status_code=204)
```

### Custom Response Models with Multiple Status Codes

```python
from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel
from typing import Union

app = FastAPI()

class Item(BaseModel):
    id: int
    name: str
    price: float

class Error(BaseModel):
    detail: str
    code: str

@app.get(
    "/items/{item_id}",
    response_model=Item,
    responses={
        200: {
            "description": "Successful Response",
            "model": Item,
        },
        404: {
            "description": "Item not found",
            "model": Error,
        },
        400: {
            "description": "Invalid item ID",
            "model": Error,
        }
    }
)
async def get_item(item_id: int):
    """
    Documents all possible responses in OpenAPI
    """
    if item_id < 1:
        raise HTTPException(
            status_code=400,
            detail="Item ID must be positive"
        )
    
    if item_id > 100:
        raise HTTPException(
            status_code=404,
            detail="Item not found"
        )
    
    return Item(id=item_id, name="Sample Item", price=99.99)

# Alternative: Return different response types
@app.get("/status/{status_code}")
async def get_status(status_code: int):
    """Return different response types based on status code"""
    if status_code == 200:
        return JSONResponse(
            content={"message": "Success"},
            status_code=200
        )
    elif status_code == 301:
        return RedirectResponse(url="/docs", status_code=301)
    elif status_code == 404:
        return JSONResponse(
            content={"error": "Not found"},
            status_code=404
        )
    else:
        return PlainTextResponse(
            content=f"Status code: {status_code}",
            status_code=status_code
        )
```

---

## Error Handling and Custom Exceptions

### Basic Error Handling

```python
from fastapi import FastAPI, HTTPException, status
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse
from pydantic import BaseModel, ValidationError

app = FastAPI()

# 1. HTTPException (built-in)
@app.get("/items/{item_id}")
async def get_item(item_id: int):
    """Raise HTTPException for error cases"""
    if item_id < 1:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Item ID must be positive"
        )
    
    if item_id > 100:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Item with ID {item_id} not found",
            headers={"X-Error": "Item-Not-Found"}
        )
    
    return {"item_id": item_id}

# 2. Custom Exception Classes
class ItemNotFoundError(Exception):
    """Custom exception for item not found"""
    def __init__(self, item_id: int):
        self.item_id = item_id
        self.message = f"Item {item_id} not found"
        super().__init__(self.message)

class InsufficientStockError(Exception):
    """Custom exception for insufficient stock"""
    def __init__(self, item_id: int, available: int, requested: int):
        self.item_id = item_id
        self.available = available
        self.requested = requested
        super().__init__(f"Insufficient stock for item {item_id}")

# 3. Custom Exception Handlers
@app.exception_handler(ItemNotFoundError)
async def item_not_found_handler(request, exc: ItemNotFoundError):
    """Handle ItemNotFoundError"""
    return JSONResponse(
        status_code=404,
        content={
            "error": "Item not found",
            "item_id": exc.item_id,
            "message": exc.message
        }
    )

@app.exception_handler(InsufficientStockError)
async def insufficient_stock_handler(request, exc: InsufficientStockError):
    """Handle InsufficientStockError"""
    return JSONResponse(
        status_code=409,
        content={
            "error": "Insufficient stock",
            "item_id": exc.item_id,
            "available": exc.available,
            "requested": exc.requested,
            "message": str(exc)
        }
    )

@app.get("/shop/items/{item_id}")
async def buy_item(item_id: int, quantity: int = 1):
    """Use custom exceptions"""
    # Simulate checking item existence
    if item_id > 100:
        raise ItemNotFoundError(item_id)
    
    # Simulate checking stock
    available_stock = 5
    if quantity > available_stock:
        raise InsufficientStockError(item_id, available_stock, quantity)
    
    return {"message": "Purchase successful", "item_id": item_id, "quantity": quantity}

# 4. Override default validation error handler
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc: RequestValidationError):
    """Custom validation error response"""
    errors = []
    for error in exc.errors():
        errors.append({
            "field": " -> ".join(str(loc) for loc in error["loc"]),
            "message": error["msg"],
            "type": error["type"]
        })
    
    return JSONResponse(
        status_code=422,
        content={
            "error": "Validation Error",
            "details": errors
        }
    )

# 5. Generic exception handler
@app.exception_handler(Exception)
async def generic_exception_handler(request, exc: Exception):
    """Catch-all for unhandled exceptions"""
    return JSONResponse(
        status_code=500,
        content={
            "error": "Internal Server Error",
            "message": "An unexpected error occurred"
            # Don't expose internal error details in production
        }
    )
```

### Structured Error Responses

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime

app = FastAPI()

# Error response models
class ValidationError(BaseModel):
    field: str
    message: str
    error_type: str

class ErrorResponse(BaseModel):
    error: str = Field(..., description="Error category")
    message: str = Field(..., description="Human-readable error message")
    error_code: str = Field(..., description="Machine-readable error code")
    timestamp: datetime = Field(default_factory=datetime.now)
    details: Optional[List[ValidationError]] = None
    request_id: Optional[str] = None

# Usage in endpoints
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    """Structured error response"""
    if user_id < 1:
        error = ErrorResponse(
            error="validation_error",
            message="User ID must be a positive integer",
            error_code="INVALID_USER_ID",
            details=[
                ValidationError(
                    field="user_id",
                    message="Must be greater than 0",
                    error_type="value_error"
                )
            ]
        )
        raise HTTPException(
            status_code=400,
            detail=error.model_dump()
        )
    
    if user_id > 1000:
        error = ErrorResponse(
            error="not_found",
            message=f"User with ID {user_id} does not exist",
            error_code="USER_NOT_FOUND"
        )
        raise HTTPException(
            status_code=404,
            detail=error.model_dump()
        )
    
    return {"user_id": user_id, "username": "john_doe"}
```

---

## Complete Example: E-commerce API with Advanced Validation

```python
from fastapi import FastAPI, HTTPException, status, Path, Query, Depends
from pydantic import BaseModel, Field, validator
from typing import Optional, List
from datetime import datetime
from enum import Enum
from uuid import UUID, uuid4

app = FastAPI(title="E-commerce API", version="1.0.0")

# Enums
class OrderStatus(str, Enum):
    pending = "pending"
    processing = "processing"
    shipped = "shipped"
    delivered = "delivered"
    cancelled = "cancelled"

class PaymentMethod(str, Enum):
    credit_card = "credit_card"
    debit_card = "debit_card"
    paypal = "paypal"
    bank_transfer = "bank_transfer"

# Models
class Product(BaseModel):
    id: UUID = Field(default_factory=uuid4)
    name: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=2000)
    price: float = Field(..., gt=0, description="Price in USD")
    stock: int = Field(..., ge=0)
    category: str
    
    @validator('price')
    def validate_price(cls, v):
        # Round to 2 decimal places
        return round(v, 2)

class OrderItem(BaseModel):
    product_id: UUID
    quantity: int = Field(..., ge=1, le=100)
    
    @validator('quantity')
    def validate_quantity(cls, v):
        if v > 50:
            # Warning for large quantities
            pass
        return v

class CreateOrder(BaseModel):
    customer_email: str = Field(..., pattern=r'^[\w\.-]+@[\w\.-]+\.\w+$')
    items: List[OrderItem] = Field(..., min_items=1, max_items=50)
    payment_method: PaymentMethod
    shipping_address: str = Field(..., min_length=10)
    notes: Optional[str] = Field(None, max_length=500)
    
    @validator('items')
    def validate_items(cls, v):
        if not v:
            raise ValueError('Order must contain at least one item')
        
        # Check for duplicate products
        product_ids = [item.product_id for item in v]
        if len(product_ids) != len(set(product_ids)):
            raise ValueError('Duplicate products in order')
        
        return v

class Order(BaseModel):
    id: UUID = Field(default_factory=uuid4)
    customer_email: str
    items: List[OrderItem]
    total_amount: float
    status: OrderStatus = OrderStatus.pending
    payment_method: PaymentMethod
    shipping_address: str
    notes: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)

# In-memory storage
products_db = {}
orders_db = {}

# Endpoints
@app.post("/products", response_model=Product, status_code=status.HTTP_201_CREATED)
async def create_product(product: Product):
    """Create a new product"""
    products_db[product.id] = product
    return product

@app.get("/products", response_model=List[Product])
async def list_products(
    category: Optional[str] = Query(None, description="Filter by category"),
    min_price: Optional[float] = Query(None, ge=0),
    max_price: Optional[float] = Query(None, ge=0),
    in_stock_only: bool = Query(False, description="Show only in-stock products"),
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100)
):
    """List products with filtering and pagination"""
    products = list(products_db.values())
    
    # Apply filters
    if category:
        products = [p for p in products if p.category == category]
    
    if min_price is not None:
        products = [p for p in products if p.price >= min_price]
    
    if max_price is not None:
        products = [p for p in products if p.price <= max_price]
    
    if in_stock_only:
        products = [p for p in products if p.stock > 0]
    
    # Pagination
    return products[skip : skip + limit]

@app.get("/products/{product_id}", response_model=Product)
async def get_product(
    product_id: UUID = Path(..., description="Product UUID")
):
    """Get a specific product"""
    if product_id not in products_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Product {product_id} not found"
        )
    return products_db[product_id]

@app.post("/orders", response_model=Order, status_code=status.HTTP_201_CREATED)
async def create_order(order_data: CreateOrder):
    """Create a new order"""
    # Validate products exist and calculate total
    total_amount = 0.0
    
    for item in order_data.items:
        if item.product_id not in products_db:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Product {item.product_id} not found"
            )
        
        product = products_db[item.product_id]
        
        # Check stock
        if product.stock < item.quantity:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail=f"Insufficient stock for {product.name}. Available: {product.stock}, Requested: {item.quantity}"
            )
        
        total_amount += product.price * item.quantity
        
        # Update stock
        product.stock -= item.quantity
    
    # Create order
    order = Order(
        customer_email=order_data.customer_email,
        items=order_data.items,
        total_amount=round(total_amount, 2),
        payment_method=order_data.payment_method,
        shipping_address=order_data.shipping_address,
        notes=order_data.notes
    )
    
    orders_db[order.id] = order
    return order

@app.get("/orders/{order_id}", response_model=Order)
async def get_order(
    order_id: UUID = Path(..., description="Order UUID")
):
    """Get order by ID"""
    if order_id not in orders_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Order {order_id} not found"
        )
    return orders_db[order_id]

@app.patch("/orders/{order_id}/status")
async def update_order_status(
    order_id: UUID,
    new_status: OrderStatus
):
    """Update order status"""
    if order_id not in orders_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Order {order_id} not found"
        )
    
    order = orders_db[order_id]
    
    # Validate status transition
    valid_transitions = {
        OrderStatus.pending: [OrderStatus.processing, OrderStatus.cancelled],
        OrderStatus.processing: [OrderStatus.shipped, OrderStatus.cancelled],
        OrderStatus.shipped: [OrderStatus.delivered],
        OrderStatus.delivered: [],
        OrderStatus.cancelled: []
    }
    
    if new_status not in valid_transitions[order.status]:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Cannot transition from {order.status} to {new_status}"
        )
    
    order.status = new_status
    order.updated_at = datetime.now()
    
    return {"message": "Status updated", "order_id": order_id, "new_status": new_status}

@app.get("/orders")
async def list_orders(
    customer_email: Optional[str] = Query(None),
    status: Optional[OrderStatus] = Query(None),
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100)
):
    """List orders with filtering"""
    orders = list(orders_db.values())
    
    if customer_email:
        orders = [o for o in orders if o.customer_email == customer_email]
    
    if status:
        orders = [o for o in orders if o.status == status]
    
    return orders[skip : skip + limit]
```

---

## Best Practices

1. **Use type hints everywhere**: FastAPI relies on them for validation
2. **Validate early**: Use Path, Query, Header parameters with constraints
3. **Custom exceptions**: Create domain-specific exceptions
4. **Structured errors**: Use consistent error response format
5. **Document responses**: Use `responses` parameter to document all possible responses
6. **Use appropriate response classes**: Don't return JSON for files or streams
7. **Handle validation errors**: Provide clear, actionable error messages
8. **Set proper status codes**: Use semantic HTTP status codes

## Common Pitfalls

1. **Forgetting validation on path/query parameters**: Always validate user input
2. **Poor error messages**: Generic "Invalid input" doesn't help users
3. **Wrong response class**: Using default JSON for binary/stream data
4. **Not documenting error responses**: OpenAPI docs incomplete
5. **Inconsistent error format**: Different errors return different structures
6. **Exposing internal errors**: Never leak stack traces or internal details

---

## Summary

In Chapter 3, you learned:
- Advanced parameter validation (Path, Query, Header, Cookie)
- Request lifecycle and order of evaluation
- Custom response types and their use cases
- Error handling with custom exceptions
- Structured error responses
- Complete e-commerce example with validation

**Next Steps**: Chapter 4 covers Dependency Injection in depth, which is crucial for building reusable, testable components!