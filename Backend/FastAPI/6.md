# Chapter 6: Authentication, Authorization & Security

## Introduction to API Security

Security is critical for any production API. This chapter covers:
- Authentication (Who are you?)
- Authorization (What can you do?)
- Password security
- JWT tokens
- OAuth2 implementation
- Security best practices

---

## Basic Security Concepts

### Authentication vs Authorization

```
┌─────────────────────────────────────────────────────────────┐
│                    API Security Flow                         │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. AUTHENTICATION (Who are you?)                           │
│     ├─ Username/Password                                     │
│     ├─ API Keys                                              │
│     ├─ OAuth2 Tokens                                         │
│     └─ JWT                                                   │
│                                                              │
│  2. AUTHORIZATION (What can you do?)                         │
│     ├─ Role-Based Access Control (RBAC)                     │
│     ├─ Permission-Based Access                              │
│     ├─ Resource Ownership                                   │
│     └─ Scope-Based Access                                   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Common Authentication Methods

| Method | Pros | Cons | Use Case |
|--------|------|------|----------|
| **Session Cookies** | Simple, stateful | Not scalable, CSRF risk | Traditional web apps |
| **API Keys** | Simple, good for services | Hard to rotate, no expiry | Service-to-service |
| **JWT** | Stateless, scalable | Token size, revocation hard | Modern APIs, microservices |
| **OAuth2** | Standard, delegated access | Complex setup | Third-party integration |

---

## Password Security

### Installation

```bash
# Install password hashing library
uv pip install passlib[bcrypt]

# For JWT tokens
uv pip install python-jose[cryptography]
```

### Password Hashing

```python
# auth/password.py
from passlib.context import CryptContext

# Create password context
pwd_context = CryptContext(
    schemes=["bcrypt"],
    deprecated="auto",
    bcrypt__rounds=12  # Cost factor (higher = more secure, slower)
)

def hash_password(password: str) -> str:
    """
    Hash password using bcrypt
    - Automatically generates salt
    - One-way function (cannot reverse)
    - Each hash is unique even for same password
    """
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify password against hash
    - Constant-time comparison (prevents timing attacks)
    - Returns True if password matches
    """
    return pwd_context.verify(plain_password, hashed_password)

# Example usage
if __name__ == "__main__":
    password = "SecurePassword123!"
    
    # Hash password
    hashed = hash_password(password)
    print(f"Original: {password}")
    print(f"Hashed: {hashed}")
    
    # Verify password
    print(f"Correct password: {verify_password(password, hashed)}")  # True
    print(f"Wrong password: {verify_password('WrongPass', hashed)}")  # False
    
    # Same password, different hashes
    hash1 = hash_password(password)
    hash2 = hash_password(password)
    print(f"Hashes are different: {hash1 != hash2}")  # True
```

### Password Validation

```python
# auth/validation.py
import re
from typing import List

class PasswordValidator:
    """Validate password strength"""
    
    @staticmethod
    def validate(password: str) -> tuple[bool, List[str]]:
        """
        Validate password against security requirements
        Returns (is_valid, error_messages)
        """
        errors = []
        
        # Length check
        if len(password) < 8:
            errors.append("Password must be at least 8 characters long")
        
        if len(password) > 128:
            errors.append("Password must not exceed 128 characters")
        
        # Complexity checks
        if not re.search(r"[a-z]", password):
            errors.append("Password must contain at least one lowercase letter")
        
        if not re.search(r"[A-Z]", password):
            errors.append("Password must contain at least one uppercase letter")
        
        if not re.search(r"\d", password):
            errors.append("Password must contain at least one digit")
        
        if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", password):
            errors.append("Password must contain at least one special character")
        
        # Common password check (simplified)
        common_passwords = [
            "password", "12345678", "qwerty", "abc123", 
            "password123", "admin", "letmein"
        ]
        if password.lower() in common_passwords:
            errors.append("Password is too common")
        
        return (len(errors) == 0, errors)

# Usage in Pydantic model
from pydantic import BaseModel, field_validator

class UserCreate(BaseModel):
    username: str
    email: str
    password: str
    
    @field_validator('password')
    @classmethod
    def validate_password(cls, v):
        is_valid, errors = PasswordValidator.validate(v)
        if not is_valid:
            raise ValueError("; ".join(errors))
        return v
```

---

## JWT (JSON Web Tokens)

### Understanding JWT Structure

```
JWT = header.payload.signature

Header (Base64):
{
  "alg": "HS256",
  "typ": "JWT"
}

Payload (Base64):
{
  "sub": "user_id",
  "username": "john_doe",
  "exp": 1234567890,
  "iat": 1234567800
}

Signature:
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret_key
)
```

### JWT Implementation

```python
# auth/jwt.py
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from jose import JWTError, jwt
from pydantic import BaseModel

# Configuration
SECRET_KEY = "your-secret-key-keep-it-secret-and-strong"  # Use env var in production
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
REFRESH_TOKEN_EXPIRE_DAYS = 7

class TokenData(BaseModel):
    """Data extracted from token"""
    username: Optional[str] = None
    user_id: Optional[int] = None

class Token(BaseModel):
    """Token response"""
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

def create_access_token(
    data: Dict[str, Any],
    expires_delta: Optional[timedelta] = None
) -> str:
    """
    Create JWT access token
    
    Args:
        data: Payload data to encode
        expires_delta: Token expiration time
    
    Returns:
        Encoded JWT token
    """
    to_encode = data.copy()
    
    # Set expiration
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({
        "exp": expire,
        "iat": datetime.utcnow()  # Issued at
    })
    
    # Encode token
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def create_refresh_token(data: Dict[str, Any]) -> str:
    """Create JWT refresh token (longer expiry)"""
    expires_delta = timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode = data.copy()
    expire = datetime.utcnow() + expires_delta
    to_encode.update({"exp": expire, "type": "refresh"})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def decode_token(token: str) -> Dict[str, Any]:
    """
    Decode and verify JWT token
    
    Args:
        token: JWT token string
    
    Returns:
        Decoded payload
    
    Raises:
        JWTError: If token is invalid or expired
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError as e:
        raise e

def verify_token(token: str) -> Optional[TokenData]:
    """
    Verify token and extract user data
    
    Returns:
        TokenData if valid, None if invalid
    """
    try:
        payload = decode_token(token)
        username: str = payload.get("sub")
        user_id: int = payload.get("user_id")
        
        if username is None:
            return None
        
        return TokenData(username=username, user_id=user_id)
    except JWTError:
        return None

# Example usage
if __name__ == "__main__":
    # Create token
    user_data = {
        "sub": "john_doe",
        "user_id": 123,
        "role": "user"
    }
    
    token = create_access_token(user_data)
    print(f"Token: {token}\n")
    
    # Decode token
    decoded = decode_token(token)
    print(f"Decoded: {decoded}\n")
    
    # Verify token
    token_data = verify_token(token)
    print(f"Verified: {token_data}")
```

---

## OAuth2 with Password Flow

### OAuth2 Setup

```python
# auth/oauth2.py
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from typing import Optional

from database import get_db
from auth.jwt import verify_token, create_access_token, create_refresh_token
from auth.password import verify_password
from models.user import User

# OAuth2 scheme (token URL is the login endpoint)
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/login")

def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
) -> User:
    """
    Dependency to get current authenticated user
    
    Usage:
        @app.get("/protected")
        async def protected(user: User = Depends(get_current_user)):
            return {"user": user.username}
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    # Verify token
    token_data = verify_token(token)
    if token_data is None or token_data.username is None:
        raise credentials_exception
    
    # Get user from database
    user = db.query(User).filter(User.username == token_data.username).first()
    if user is None:
        raise credentials_exception
    
    return user

def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """
    Dependency to get current active user
    Ensures user account is not disabled
    """
    if not current_user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Inactive user account"
        )
    return current_user

def authenticate_user(db: Session, username: str, password: str) -> Optional[User]:
    """
    Authenticate user by username and password
    
    Returns:
        User if credentials are valid, None otherwise
    """
    user = db.query(User).filter(User.username == username).first()
    if not user:
        return None
    if not verify_password(password, user.hashed_password):
        return None
    return user
```

### Login Endpoint

```python
# routers/auth.py
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from datetime import timedelta

from database import get_db
from auth.oauth2 import authenticate_user
from auth.jwt import (
    create_access_token,
    create_refresh_token,
    Token,
    ACCESS_TOKEN_EXPIRE_MINUTES
)
from schemas.user import UserCreate, User as UserSchema
from crud.user import create_user

router = APIRouter(prefix="/auth", tags=["authentication"])

@router.post("/register", response_model=UserSchema)
async def register(user: UserCreate, db: Session = Depends(get_db)):
    """
    Register new user
    
    Request body:
    {
      "username": "john_doe",
      "email": "john@example.com",
      "password": "SecurePass123!"
    }
    """
    # Check if user exists
    existing_user = db.query(User).filter(
        (User.username == user.username) | (User.email == user.email)
    ).first()
    
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username or email already registered"
        )
    
    # Create user
    db_user = create_user(db, user)
    return db_user

@router.post("/login", response_model=Token)
async def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    """
    Login endpoint - OAuth2 compatible
    
    Form data:
    - username: Username
    - password: Password
    
    Returns:
    - access_token: JWT access token
    - refresh_token: JWT refresh token
    - token_type: "bearer"
    
    Usage:
    curl -X POST "http://localhost:8000/auth/login" \
         -H "Content-Type: application/x-www-form-urlencoded" \
         -d "username=john_doe&password=SecurePass123!"
    """
    # Authenticate user
    user = authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Check if user is active
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User account is disabled"
        )
    
    # Create tokens
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username, "user_id": user.id},
        expires_delta=access_token_expires
    )
    refresh_token = create_refresh_token(
        data={"sub": user.username, "user_id": user.id}
    )
    
    return Token(
        access_token=access_token,
        refresh_token=refresh_token,
        token_type="bearer"
    )

@router.post("/refresh", response_model=Token)
async def refresh_token(
    refresh_token: str,
    db: Session = Depends(get_db)
):
    """
    Refresh access token using refresh token
    
    Request body:
    {
      "refresh_token": "eyJ..."
    }
    """
    from auth.jwt import decode_token, JWTError
    
    try:
        payload = decode_token(refresh_token)
        
        # Verify it's a refresh token
        if payload.get("type") != "refresh":
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid refresh token"
            )
        
        username = payload.get("sub")
        if username is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid refresh token"
            )
        
        # Get user
        user = db.query(User).filter(User.username == username).first()
        if not user or not user.is_active:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found or inactive"
            )
        
        # Create new access token
        access_token = create_access_token(
            data={"sub": user.username, "user_id": user.id}
        )
        
        return Token(access_token=access_token, token_type="bearer")
        
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token"
        )

@router.get("/me", response_model=UserSchema)
async def get_current_user_info(
    current_user: User = Depends(get_current_active_user)
):
    """
    Get current user information
    Requires authentication (Bearer token)
    
    Usage:
    curl -X GET "http://localhost:8000/auth/me" \
         -H "Authorization: Bearer eyJ..."
    """
    return current_user

@router.post("/logout")
async def logout(current_user: User = Depends(get_current_active_user)):
    """
    Logout endpoint
    
    Note: With JWT, logout is typically handled client-side
    by deleting the token. For true server-side logout,
    implement token blacklisting (covered later).
    """
    return {"message": "Successfully logged out"}
```

---

## Role-Based Access Control (RBAC)

### Role Model

```python
# models/role.py
from sqlalchemy import Column, Integer, String, Table, ForeignKey
from sqlalchemy.orm import relationship
from database import Base

# Many-to-many relationship table
user_roles = Table(
    'user_roles',
    Base.metadata,
    Column('user_id', Integer, ForeignKey('users.id')),
    Column('role_id', Integer, ForeignKey('roles.id'))
)

class Role(Base):
    """Role model for RBAC"""
    __tablename__ = "roles"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True, nullable=False)
    description = Column(String)
    
    # Relationships
    users = relationship("User", secondary=user_roles, back_populates="roles")
    permissions = relationship("Permission", back_populates="role")

class Permission(Base):
    """Permission model"""
    __tablename__ = "permissions"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True, nullable=False)
    description = Column(String)
    role_id = Column(Integer, ForeignKey("roles.id"))
    
    # Relationship
    role = relationship("Role", back_populates="permissions")

# Update User model
class User(Base):
    # ... existing fields ...
    
    # Relationships
    roles = relationship("Role", secondary=user_roles, back_populates="users")
    
    def has_role(self, role_name: str) -> bool:
        """Check if user has specific role"""
        return any(role.name == role_name for role in self.roles)
    
    def has_permission(self, permission_name: str) -> bool:
        """Check if user has specific permission"""
        for role in self.roles:
            if any(perm.name == permission_name for perm in role.permissions):
                return True
        return False
```

### Role-Based Dependencies

```python
# auth/rbac.py
from fastapi import Depends, HTTPException, status
from typing import List
from auth.oauth2 import get_current_active_user
from models.user import User

def require_roles(required_roles: List[str]):
    """
    Dependency factory for role-based access control
    
    Usage:
        @app.get("/admin")
        async def admin_only(user: User = Depends(require_roles(["admin"]))):
            return {"message": "Admin access"}
    """
    def role_checker(current_user: User = Depends(get_current_active_user)) -> User:
        # Check if user has any of the required roles
        user_has_role = any(
            current_user.has_role(role) for role in required_roles
        )
        
        if not user_has_role:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"User must have one of these roles: {', '.join(required_roles)}"
            )
        
        return current_user
    
    return role_checker

def require_permissions(required_permissions: List[str]):
    """
    Dependency factory for permission-based access control
    
    Usage:
        @app.delete("/posts/{post_id}")
        async def delete_post(
            post_id: int,
            user: User = Depends(require_permissions(["delete_posts"]))
        ):
            return {"message": "Post deleted"}
    """
    def permission_checker(current_user: User = Depends(get_current_active_user)) -> User:
        # Check if user has all required permissions
        has_all_permissions = all(
            current_user.has_permission(perm) for perm in required_permissions
        )
        
        if not has_all_permissions:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Missing required permissions: {', '.join(required_permissions)}"
            )
        
        return current_user
    
    return permission_checker

# Convenience functions for common roles
def require_admin(user: User = Depends(require_roles(["admin"]))) -> User:
    """Require admin role"""
    return user

def require_moderator(user: User = Depends(require_roles(["moderator", "admin"]))) -> User:
    """Require moderator or admin role"""
    return user

# Usage in endpoints
from fastapi import APIRouter

router = APIRouter()

@router.get("/admin/dashboard")
async def admin_dashboard(admin: User = Depends(require_admin)):
    """Admin-only endpoint"""
    return {"message": "Welcome to admin dashboard", "admin": admin.username}

@router.post("/posts")
async def create_post(
    post_data: dict,
    user: User = Depends(require_permissions(["create_posts"]))
):
    """Create post - requires specific permission"""
    return {"message": "Post created", "author": user.username}

@router.delete("/posts/{post_id}")
async def delete_post(
    post_id: int,
    user: User = Depends(require_permissions(["delete_posts"]))
):
    """Delete post - requires specific permission"""
    return {"message": "Post deleted"}
```

---

## Advanced Security Features

### Token Blacklisting

```python
# auth/token_blacklist.py
from redis import Redis
from datetime import datetime, timedelta
from auth.jwt import decode_token

redis_client = Redis(host='localhost', port=6379, db=0, decode_responses=True)

def blacklist_token(token: str):
    """
    Add token to blacklist
    Token is stored until its expiration
    """
    try:
        payload = decode_token(token)
        exp_timestamp = payload.get("exp")
        
        if exp_timestamp:
            # Calculate TTL (time until expiration)
            exp_datetime = datetime.fromtimestamp(exp_timestamp)
            ttl = int((exp_datetime - datetime.utcnow()).total_seconds())
            
            if ttl > 0:
                # Store token in Redis with TTL
                redis_client.setex(
                    name=f"blacklist:{token}",
                    time=ttl,
                    value="1"
                )
    except Exception:
        pass

def is_token_blacklisted(token: str) -> bool:
    """Check if token is blacklisted"""
    return redis_client.exists(f"blacklist:{token}") > 0

def get_current_user_with_blacklist_check(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
) -> User:
    """
    Get current user with blacklist check
    Use this instead of get_current_user for enhanced security
    """
    # Check blacklist
    if is_token_blacklisted(token):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has been revoked"
        )
    
    # Proceed with normal verification
    return get_current_user(token, db)

# Updated logout endpoint
@router.post("/logout")
async def logout_with_blacklist(
    token: str = Depends(oauth2_scheme),
    current_user: User = Depends(get_current_active_user)
):
    """Logout with token blacklisting"""
    blacklist_token(token)
    return {"message": "Successfully logged out"}
```

### Rate Limiting

```python
# auth/rate_limit.py
from fastapi import HTTPException, status, Request
from redis import Redis
from datetime import datetime, timedelta

redis_client = Redis(host='localhost', port=6379, db=0, decode_responses=True)

class RateLimiter:
    """Rate limiter using sliding window"""
    
    def __init__(self, requests: int, window: int):
        """
        Args:
            requests: Maximum number of requests
            window: Time window in seconds
        """
        self.requests = requests
        self.window = window
    
    def is_allowed(self, key: str) -> bool:
        """
        Check if request is allowed
        
        Args:
            key: Identifier (user_id, IP address, etc.)
        
        Returns:
            True if allowed, False if rate limit exceeded
        """
        now = datetime.utcnow().timestamp()
        window_start = now - self.window
        
        # Redis sorted set key
        redis_key = f"rate_limit:{key}"
        
        # Remove old entries
        redis_client.zremrangebyscore(redis_key, 0, window_start)
        
        # Count requests in current window
        request_count = redis_client.zcard(redis_key)
        
        if request_count >= self.requests:
            return False
        
        # Add current request
        redis_client.zadd(redis_key, {str(now): now})
        redis_client.expire(redis_key, self.window)
        
        return True
    
    def get_remaining(self, key: str) -> int:
        """Get remaining requests in current window"""
        redis_key = f"rate_limit:{key}"
        request_count = redis_client.zcard(redis_key)
        return max(0, self.requests - request_count)

# Rate limit dependency
def rate_limit_dependency(
    requests: int = 100,
    window: int = 60
):
    """
    Rate limit dependency factory
    
    Usage:
        @app.get("/api/resource")
        async def endpoint(
            _: None = Depends(rate_limit_dependency(requests=10, window=60))
        ):
            return {"data": "..."}
    """
    limiter = RateLimiter(requests, window)
    
    async def check_rate_limit(request: Request):
        # Use IP address as identifier
        client_ip = request.client.host
        
        if not limiter.is_allowed(client_ip):
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail="Rate limit exceeded",
                headers={
                    "X-RateLimit-Limit": str(requests),
                    "X-RateLimit-Remaining": str(limiter.get_remaining(client_ip)),
                    "X-RateLimit-Reset": str(window)
                }
            )
    
    return check_rate_limit

# Usage
@router.get("/limited")
async def limited_endpoint(
    _: None = Depends(rate_limit_dependency(requests=5, window=60))
):
    """Endpoint with rate limiting (5 requests per minute)"""
    return {"message": "Success"}
```

---

## Security Best Practices

### CORS (Cross-Origin Resource Sharing)

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",  # React dev server
        "https://yourdomain.com"   # Production frontend
    ],
    allow_credentials=True,
    allow_methods=["*"],  # Or ["GET", "POST", "PUT", "DELETE"]
    allow_headers=["*"],  # Or specific headers
)

# For development only (allow all)
# app.add_middleware(
#     CORSMiddleware,
#     allow_origins=["*"],
#     allow_credentials=True,
#     allow_methods=["*"],
#     allow_headers=["*"],
# )
```

### HTTPS and Secure Cookies

```python
from fastapi import Response

@app.post("/login")
async def login(response: Response):
    # Set secure cookie
    response.set_cookie(
        key="access_token",
        value="token_value",
        httponly=True,        # Prevents JavaScript access
        secure=True,          # HTTPS only
        samesite="lax",       # CSRF protection
        max_age=1800,         # 30 minutes
        domain=".yourdomain.com"  # Cookie domain
    )
    return {"message": "Logged in"}
```

### Environment Variables for Secrets

```python
# config.py
from pydantic_settings import BaseSettings
from functools import lru_cache

class Settings(BaseSettings):
    """Application settings from environment variables"""
    
    # Security
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # Database
    DATABASE_URL: str
    
    # Redis
    REDIS_HOST: str = "localhost"
    REDIS_PORT: int = 6379
    
    # CORS
    CORS_ORIGINS: list = ["http://localhost:3000"]
    
    class Config:
        env_file = ".env"
        case_sensitive = True

@lru_cache()
def get_settings() -> Settings:
    """Get cached settings"""
    return Settings()

# .env file:
# SECRET_KEY=your-super-secret-key-change-this
# DATABASE_URL=postgresql://user:pass@localhost/dbname
# REDIS_HOST=localhost
# CORS_ORIGINS=["http://localhost:3000","https://yourdomain.com"]
```

### SQL Injection Prevention

```python
# ALWAYS use parameterized queries with SQLAlchemy
from sqlalchemy import text

# ❌ DANGEROUS - SQL Injection vulnerability
user_input = "'; DROP TABLE users; --"
query = f"SELECT * FROM users WHERE username = '{user_input}'"
db.execute(text(query))

# ✅ SAFE - Parameterized query
user_input = "john_doe"
query = text("SELECT * FROM users WHERE username = :username")
db.execute(query, {"username": user_input})

# ✅ SAFE - SQLAlchemy ORM (automatically parameterized)
user = db.query(User).filter(User.username == user_input).first()
```

### Input Validation

```python
from pydantic import BaseModel, Field, validator
from typing import Optional

class UserInput(BaseModel):
    """Always validate and sanitize user input"""
    
    username: str = Field(..., min_length=3, max_length=50, regex="^[a-zA-Z0-9_]+$")
    email: str = Field(..., regex=r'^[\w\.-]+@[\w\.-]+\.\w+$')
    age: Optional[int] = Field(None, ge=0, le=150)
    
    @validator('username')
    @classmethod
    def username_no_sql(cls, v):
        """Additional SQL injection prevention"""
        dangerous_chars = ["'", '"', ";", "--", "/*", "*/"]
        if any(char in v for char in dangerous_chars):
            raise ValueError("Invalid characters in username")
        return v
```

---

## Complete Security Example

```python
# main.py - Complete secure FastAPI application
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from sqlalchemy.orm import Session

from config import get_settings
from database import get_db, engine, Base
from routers import auth, users, posts
from auth.oauth2 import get_current_active_user
from auth.rate_limit import rate_limit_dependency

# Settings
settings = get_settings()

# Create tables
Base.metadata.create_all(bind=engine)

# Initialize app
app = FastAPI(
    title="Secure API",
    version="1.0.0",
    docs_url="/docs" if settings.DEBUG else None,  # Disable docs in production
    redoc_url="/redoc" if settings.DEBUG else None
)

# Security Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH"],
    allow_headers=["*"],
)

app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=["yourdomain.com", "*.yourdomain.com"]
)

# Include routers
app.include_router(auth.router)
app.include_router(users.router)
app.include_router(posts.router)

# Public endpoints
@app.get("/")
async def root():
    return {"message": "Welcome to the API"}

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy"}

# Protected endpoint with rate limiting
@app.get("/protected")
async def protected_endpoint(
    current_user: User = Depends(get_current_active_user),
    _: None = Depends(rate_limit_dependency(requests=10, window=60))
):
    """Protected endpoint with authentication and rate limiting"""
    return {
        "message": "This is a protected resource",
        "user": current_user.username
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        ssl_keyfile="path/to/key.pem",    # For HTTPS
        ssl_certfile="path/to/cert.pem"   # For HTTPS
    )
```

---

## Summary

In Chapter 6, you learned:
- Password security with bcrypt hashing
- JWT token creation and validation
- OAuth2 implementation with FastAPI
- Role-Based Access Control (RBAC)
- Token blacklisting and rate limiting
- Security best practices (CORS, HTTPS, input validation)
- Complete secure API example

### Security Checklist

- ✅ Use strong password hashing (bcrypt with high cost factor)
- ✅ Implement JWT with proper expiration
- ✅ Use HTTPS in production
- ✅ Set secure cookie flags (httponly, secure, samesite)
- ✅ Implement rate limiting
- ✅ Validate and sanitize all user input
- ✅ Use parameterized queries (prevent SQL injection)
- ✅ Store secrets in environment variables
- ✅ Implement proper CORS policies
- ✅ Use role-based access control
- ✅ Implement token blacklisting for logout
- ✅ Keep dependencies updated
- ✅ Log security events
- ✅ Implement account lockout after failed attempts

**Congratulations!** You now have a solid foundation in FastAPI security. These concepts are critical for building production-ready APIs!

