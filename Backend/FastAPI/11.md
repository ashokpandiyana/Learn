# Chapter 11: Testing & Quality

## Introduction to Testing FastAPI Applications

Testing is crucial for:
- Ensuring code correctness
- Preventing regressions
- Documenting behavior
- Enabling refactoring
- Building confidence

**Testing Pyramid:**
```
       /\
      /  \     E2E Tests (Few)
     /----\
    /      \   Integration Tests (Some)
   /--------\
  /          \ Unit Tests (Many)
 /____________\
```

---

## Installation

```bash
# Install testing dependencies
uv pip install pytest pytest-asyncio httpx

# Coverage reporting
uv pip install pytest-cov

# Mocking
uv pip install pytest-mock

# Faker for test data
uv pip install faker
```

---

## Testing FastAPI Apps with TestClient

### Basic TestClient Usage

```python
# test_main.py
from fastapi import FastAPI
from fastapi.testclient import TestClient

# Your app
app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Hello World"}

@app.get("/items/{item_id}")
async def get_item(item_id: int, q: str = None):
    return {"item_id": item_id, "q": q}

# Create test client
client = TestClient(app)

def test_root():
    """Test root endpoint"""
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "Hello World"}

def test_get_item():
    """Test item endpoint with path and query params"""
    response = client.get("/items/42?q=test")
    assert response.status_code == 200
    assert response.json() == {"item_id": 42, "q": "test"}

def test_get_item_no_query():
    """Test item endpoint without query param"""
    response = client.get("/items/42")
    assert response.status_code == 200
    assert response.json() == {"item_id": 42, "q": None}
```

### Testing POST Requests

```python
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    price: float
    description: str = None

@app.post("/items", status_code=201)
async def create_item(item: Item):
    return item

def test_create_item():
    """Test creating an item"""
    response = client.post(
        "/items",
        json={
            "name": "Test Item",
            "price": 10.5,
            "description": "A test item"
        }
    )
    assert response.status_code == 201
    data = response.json()
    assert data["name"] == "Test Item"
    assert data["price"] == 10.5

def test_create_item_invalid():
    """Test validation errors"""
    response = client.post(
        "/items",
        json={
            "name": "Test",
            # Missing required 'price' field
        }
    )
    assert response.status_code == 422  # Validation error
    assert "price" in str(response.json())
```

### Testing with Headers and Cookies

```python
@app.get("/protected")
async def protected_route(authorization: str = Header(None)):
    if authorization != "Bearer valid-token":
        raise HTTPException(status_code=401, detail="Unauthorized")
    return {"message": "Protected data"}

def test_protected_route_with_auth():
    """Test authenticated request"""
    response = client.get(
        "/protected",
        headers={"Authorization": "Bearer valid-token"}
    )
    assert response.status_code == 200

def test_protected_route_without_auth():
    """Test unauthorized request"""
    response = client.get("/protected")
    assert response.status_code == 401

def test_with_cookies():
    """Test with cookies"""
    response = client.get(
        "/items",
        cookies={"session_id": "test-session"}
    )
    assert response.status_code == 200
```

---

## Async Testing

### Using pytest-asyncio

```python
# test_async.py
import pytest
from httpx import AsyncClient
from main import app

@pytest.mark.asyncio
async def test_root_async():
    """Test async endpoint"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.get("/")
        assert response.status_code == 200
        assert response.json() == {"message": "Hello World"}

@pytest.mark.asyncio
async def test_create_item_async():
    """Test async POST request"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.post(
            "/items",
            json={"name": "Async Item", "price": 15.0}
        )
        assert response.status_code == 201
```

### Configure pytest for Async

```python
# conftest.py
import pytest
import asyncio

# Configure asyncio for pytest
@pytest.fixture(scope="session")
def event_loop():
    """Create event loop for tests"""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()
```

---

## Dependency Overrides for Testing

### Basic Dependency Override

```python
# app.py
from fastapi import FastAPI, Depends

app = FastAPI()

def get_database():
    """Production database"""
    return {"db": "production"}

@app.get("/data")
async def get_data(db = Depends(get_database)):
    return {"database": db["db"]}

# test_dependencies.py
def test_with_mock_database():
    """Test with overridden dependency"""
    
    # Mock database
    def get_test_database():
        return {"db": "test"}
    
    # Override dependency
    app.dependency_overrides[get_database] = get_test_database
    
    # Test
    response = client.get("/data")
    assert response.status_code == 200
    assert response.json() == {"database": "test"}
    
    # Clean up
    app.dependency_overrides.clear()
```

### Testing with Database

```python
# conftest.py
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from database import Base, get_db

# Test database URL
SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"

@pytest.fixture(scope="function")
def db_session():
    """Create test database session"""
    # Create test engine
    engine = create_engine(
        SQLALCHEMY_DATABASE_URL,
        connect_args={"check_same_thread": False}
    )
    
    # Create tables
    Base.metadata.create_all(bind=engine)
    
    # Create session
    TestingSessionLocal = sessionmaker(bind=engine)
    session = TestingSessionLocal()
    
    yield session
    
    # Cleanup
    session.close()
    Base.metadata.drop_all(bind=engine)

@pytest.fixture(scope="function")
def client(db_session):
    """Create test client with overridden database"""
    
    def override_get_db():
        try:
            yield db_session
        finally:
            db_session.close()
    
    app.dependency_overrides[get_db] = override_get_db
    
    with TestClient(app) as test_client:
        yield test_client
    
    app.dependency_overrides.clear()

# test_with_db.py
def test_create_user(client, db_session):
    """Test creating user with database"""
    response = client.post(
        "/users",
        json={
            "username": "testuser",
            "email": "test@example.com",
            "password": "testpass123"
        }
    )
    assert response.status_code == 201
    
    # Verify in database
    from models import User
    user = db_session.query(User).filter_by(username="testuser").first()
    assert user is not None
    assert user.email == "test@example.com"
```

### Testing Authentication

```python
# conftest.py
from auth.oauth2 import get_current_user
from models import User

@pytest.fixture
def mock_user():
    """Create mock user"""
    return User(
        id=1,
        username="testuser",
        email="test@example.com",
        is_active=True
    )

@pytest.fixture
def authenticated_client(mock_user):
    """Create client with authenticated user"""
    
    def override_get_current_user():
        return mock_user
    
    app.dependency_overrides[get_current_user] = override_get_current_user
    
    with TestClient(app) as test_client:
        yield test_client
    
    app.dependency_overrides.clear()

# test_auth.py
def test_protected_endpoint(authenticated_client):
    """Test endpoint requiring authentication"""
    response = authenticated_client.get("/users/me")
    assert response.status_code == 200
    assert response.json()["username"] == "testuser"

def test_admin_endpoint(mock_user):
    """Test admin-only endpoint"""
    # Make user admin
    mock_user.is_admin = True
    
    def override_get_current_user():
        return mock_user
    
    app.dependency_overrides[get_current_user] = override_get_current_user
    
    response = client.get("/admin/dashboard")
    assert response.status_code == 200
    
    app.dependency_overrides.clear()
```

---

## Mocking External Services

### Mocking HTTP Requests

```python
# app.py
import httpx

@app.get("/weather/{city}")
async def get_weather(city: str):
    """Get weather from external API"""
    async with httpx.AsyncClient() as client:
        response = await client.get(
            f"https://api.weather.com/{city}"
        )
        return response.json()

# test_mocking.py
import pytest
from unittest.mock import AsyncMock, patch

@pytest.mark.asyncio
async def test_get_weather():
    """Test with mocked external API"""
    
    # Mock response
    mock_response = AsyncMock()
    mock_response.json.return_value = {
        "city": "London",
        "temperature": 15,
        "condition": "Cloudy"
    }
    
    # Patch httpx
    with patch("httpx.AsyncClient.get", return_value=mock_response):
        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.get("/weather/London")
            
            assert response.status_code == 200
            data = response.json()
            assert data["city"] == "London"
            assert data["temperature"] == 15
```

### Mocking Database Operations

```python
from unittest.mock import MagicMock

def test_get_user_mocked():
    """Test with mocked database"""
    
    # Create mock session
    mock_db = MagicMock()
    mock_user = User(
        id=1,
        username="testuser",
        email="test@example.com"
    )
    
    # Configure mock
    mock_db.query.return_value.filter.return_value.first.return_value = mock_user
    
    # Override dependency
    def get_mock_db():
        return mock_db
    
    app.dependency_overrides[get_db] = get_mock_db
    
    # Test
    response = client.get("/users/1")
    assert response.status_code == 200
    assert response.json()["username"] == "testuser"
    
    # Verify mock was called
    mock_db.query.assert_called_once()
    
    app.dependency_overrides.clear()
```

---

## Testing Patterns

### Parametrized Tests

```python
import pytest

@pytest.mark.parametrize("item_id,expected_status", [
    (1, 200),
    (2, 200),
    (999, 404),
])
def test_get_item_parametrized(item_id, expected_status):
    """Test multiple scenarios with parameters"""
    response = client.get(f"/items/{item_id}")
    assert response.status_code == expected_status

@pytest.mark.parametrize("username,email,password,expected_status", [
    ("valid", "valid@email.com", "Password123!", 201),
    ("a", "valid@email.com", "Password123!", 422),  # Too short
    ("valid", "invalid-email", "Password123!", 422),  # Invalid email
    ("valid", "valid@email.com", "weak", 422),  # Weak password
])
def test_user_validation(username, email, password, expected_status):
    """Test user validation with different inputs"""
    response = client.post(
        "/users",
        json={
            "username": username,
            "email": email,
            "password": password
        }
    )
    assert response.status_code == expected_status
```

### Fixture Factories

```python
# conftest.py
from faker import Faker

fake = Faker()

@pytest.fixture
def user_factory(db_session):
    """Factory for creating test users"""
    def create_user(**kwargs):
        user_data = {
            "username": fake.user_name(),
            "email": fake.email(),
            "password": "testpass123",
            **kwargs
        }
        
        user = User(
            username=user_data["username"],
            email=user_data["email"],
            hashed_password=hash_password(user_data["password"])
        )
        db_session.add(user)
        db_session.commit()
        db_session.refresh(user)
        return user
    
    return create_user

@pytest.fixture
def post_factory(db_session, user_factory):
    """Factory for creating test posts"""
    def create_post(author=None, **kwargs):
        if author is None:
            author = user_factory()
        
        post_data = {
            "title": fake.sentence(),
            "content": fake.text(),
            "author_id": author.id,
            **kwargs
        }
        
        post = Post(**post_data)
        db_session.add(post)
        db_session.commit()
        db_session.refresh(post)
        return post
    
    return create_post

# test_with_factories.py
def test_create_post(client, user_factory, post_factory):
    """Test using factories"""
    user = user_factory(username="testuser")
    post = post_factory(author=user, title="Test Post")
    
    response = client.get(f"/posts/{post.id}")
    assert response.status_code == 200
    assert response.json()["title"] == "Test Post"
```

---

## Testing Error Handling

### Testing Exception Handlers

```python
@app.exception_handler(ValueError)
async def value_error_handler(request, exc):
    return JSONResponse(
        status_code=400,
        content={"error": "bad_request", "message": str(exc)}
    )

@app.get("/divide/{a}/{b}")
async def divide(a: int, b: int):
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return {"result": a / b}

def test_division_by_zero():
    """Test error handling"""
    response = client.get("/divide/10/0")
    assert response.status_code == 400
    assert "Cannot divide by zero" in response.json()["message"]

def test_validation_error():
    """Test validation error response"""
    response = client.post(
        "/users",
        json={"username": "test"}  # Missing required fields
    )
    assert response.status_code == 422
    errors = response.json()["detail"]
    assert any("email" in str(error) for error in errors)
```

---

## Integration Tests

### Testing Complete Workflows

```python
def test_user_registration_and_login_flow(client, db_session):
    """Test complete user flow"""
    
    # 1. Register user
    register_response = client.post(
        "/auth/register",
        json={
            "username": "newuser",
            "email": "new@example.com",
            "password": "SecurePass123!"
        }
    )
    assert register_response.status_code == 201
    
    # 2. Login
    login_response = client.post(
        "/auth/login",
        data={
            "username": "newuser",
            "password": "SecurePass123!"
        }
    )
    assert login_response.status_code == 200
    token = login_response.json()["access_token"]
    
    # 3. Access protected resource
    profile_response = client.get(
        "/users/me",
        headers={"Authorization": f"Bearer {token}"}
    )
    assert profile_response.status_code == 200
    assert profile_response.json()["username"] == "newuser"
    
    # 4. Update profile
    update_response = client.patch(
        "/users/me",
        headers={"Authorization": f"Bearer {token}"},
        json={"email": "updated@example.com"}
    )
    assert update_response.status_code == 200
    
    # 5. Verify update
    verify_response = client.get(
        "/users/me",
        headers={"Authorization": f"Bearer {token}"}
    )
    assert verify_response.json()["email"] == "updated@example.com"
```

### Testing CRUD Operations

```python
class TestItemCRUD:
    """Test all CRUD operations for items"""
    
    def test_create_item(self, authenticated_client):
        response = authenticated_client.post(
            "/items",
            json={"name": "Test Item", "price": 10.0}
        )
        assert response.status_code == 201
        assert "id" in response.json()
    
    def test_read_item(self, authenticated_client, item_factory):
        item = item_factory()
        response = authenticated_client.get(f"/items/{item.id}")
        assert response.status_code == 200
        assert response.json()["name"] == item.name
    
    def test_update_item(self, authenticated_client, item_factory):
        item = item_factory()
        response = authenticated_client.patch(
            f"/items/{item.id}",
            json={"price": 20.0}
        )
        assert response.status_code == 200
        assert response.json()["price"] == 20.0
    
    def test_delete_item(self, authenticated_client, item_factory, db_session):
        item = item_factory()
        item_id = item.id
        
        response = authenticated_client.delete(f"/items/{item_id}")
        assert response.status_code == 204
        
        # Verify deletion
        from models import Item
        deleted_item = db_session.query(Item).filter_by(id=item_id).first()
        assert deleted_item is None
```

---

## Code Coverage

### Running Tests with Coverage

```bash
# Run tests with coverage
pytest --cov=app --cov-report=html --cov-report=term

# Run specific test file
pytest tests/test_users.py -v

# Run tests matching pattern
pytest -k "test_user" -v

# Run with markers
pytest -m "slow" -v
```

### Coverage Configuration

```ini
# pytest.ini or setup.cfg
[tool:pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    --strict-markers
    --cov=app
    --cov-report=term-missing
    --cov-report=html
    --cov-fail-under=80

markers =
    slow: marks tests as slow
    integration: marks tests as integration tests
    unit: marks tests as unit tests
```

### Pytest Markers

```python
import pytest

@pytest.mark.unit
def test_fast_unit_test():
    """Quick unit test"""
    assert 1 + 1 == 2

@pytest.mark.integration
def test_database_integration(db_session):
    """Integration test with database"""
    pass

@pytest.mark.slow
def test_slow_operation():
    """Test that takes time"""
    import time
    time.sleep(2)
    assert True

# Run only unit tests
# pytest -m unit

# Run only integration tests
# pytest -m integration

# Skip slow tests
# pytest -m "not slow"
```

---

## Testing Best Practices

### Test Organization

```python
# tests/
# ├── conftest.py           # Shared fixtures
# ├── test_auth.py          # Auth tests
# ├── test_users.py         # User tests
# ├── test_posts.py         # Post tests
# └── integration/
#     └── test_workflows.py # Integration tests

# Good test structure
def test_function_name_should_describe_behavior():
    """
    Arrange: Set up test data
    Act: Execute the code being tested
    Assert: Verify the results
    """
    # Arrange
    user_data = {"username": "test", "email": "test@example.com"}
    
    # Act
    response = client.post("/users", json=user_data)
    
    # Assert
    assert response.status_code == 201
    assert response.json()["username"] == "test"
```

### DRY in Tests

```python
# conftest.py
@pytest.fixture
def base_user_data():
    """Base user data for tests"""
    return {
        "username": "testuser",
        "email": "test@example.com",
        "password": "TestPass123!"
    }

@pytest.fixture
def create_test_user(client, base_user_data):
    """Helper to create test user"""
    def _create_user(**kwargs):
        data = {**base_user_data, **kwargs}
        response = client.post("/users", json=data)
        return response.json()
    return _create_user

# test_users.py
def test_create_user_valid(create_test_user):
    """Test creating valid user"""
    user = create_test_user()
    assert "id" in user

def test_create_user_custom_email(create_test_user):
    """Test creating user with custom email"""
    user = create_test_user(email="custom@example.com")
    assert user["email"] == "custom@example.com"
```

---

## Complete Test Suite Example

```python
# tests/conftest.py
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from faker import Faker

from main import app
from database import Base, get_db
from models import User, Post
from auth.password import hash_password

fake = Faker()

# Test database
SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"
engine = create_engine(SQLALCHEMY_DATABASE_URL)
TestingSessionLocal = sessionmaker(bind=engine)

@pytest.fixture(scope="function")
def db_session():
    """Create test database"""
    Base.metadata.create_all(bind=engine)
    session = TestingSessionLocal()
    yield session
    session.close()
    Base.metadata.drop_all(bind=engine)

@pytest.fixture(scope="function")
def client(db_session):
    """Create test client"""
    def override_get_db():
        try:
            yield db_session
        finally:
            pass
    
    app.dependency_overrides[get_db] = override_get_db
    with TestClient(app) as test_client:
        yield test_client
    app.dependency_overrides.clear()

@pytest.fixture
def user_factory(db_session):
    """User factory"""
    def create_user(**kwargs):
        user_data = {
            "username": fake.user_name(),
            "email": fake.email(),
            "password": "TestPass123!",
            **kwargs
        }
        user = User(
            username=user_data["username"],
            email=user_data["email"],
            hashed_password=hash_password(user_data["password"])
        )
        db_session.add(user)
        db_session.commit()
        db_session.refresh(user)
        return user
    return create_user

@pytest.fixture
def authenticated_client(client, user_factory):
    """Client with authenticated user"""
    user = user_factory()
    response = client.post(
        "/auth/login",
        data={"username": user.username, "password": "TestPass123!"}
    )
    token = response.json()["access_token"]
    client.headers = {"Authorization": f"Bearer {token}"}
    return client

# tests/test_users.py
class TestUserEndpoints:
    """Test user endpoints"""
    
    def test_create_user(self, client):
        response = client.post(
            "/users",
            json={
                "username": "newuser",
                "email": "new@example.com",
                "password": "SecurePass123!"
            }
        )
        assert response.status_code == 201
        assert response.json()["username"] == "newuser"
    
    def test_create_user_duplicate_username(self, client, user_factory):
        existing_user = user_factory(username="duplicate")
        
        response = client.post(
            "/users",
            json={
                "username": "duplicate",
                "email": "new@example.com",
                "password": "SecurePass123!"
            }
        )
        assert response.status_code == 400
    
    def test_get_current_user(self, authenticated_client):
        response = authenticated_client.get("/users/me")
        assert response.status_code == 200
        assert "username" in response.json()
    
    def test_update_user(self, authenticated_client):
        response = authenticated_client.patch(
            "/users/me",
            json={"email": "updated@example.com"}
        )
        assert response.status_code == 200
        assert response.json()["email"] == "updated@example.com"

# Run tests
# pytest tests/ -v --cov=app --cov-report=html
```

---

## Summary

In Chapter 11, you learned:
- Testing FastAPI with TestClient and AsyncClient
- Dependency overrides for isolated testing
- Mocking external services and databases
- Parametrized tests for multiple scenarios
- Fixture factories for test data
- Integration testing workflows
- Code coverage measurement
- Testing best practices and organization
- Complete test suite example

**Key Testing Principles:**
- ✅ Test behavior, not implementation
- ✅ Use dependency overrides for isolation
- ✅ Mock external dependencies
- ✅ Aim for high coverage (>80%)
- ✅ Write readable, maintainable tests
- ✅ Keep tests fast and independent
- ✅ Use factories for test data
- ✅ Test both success and failure cases

**Next: Chapter 12 - OpenAPI, Documentation & Client Generation**