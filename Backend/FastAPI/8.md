# Chapter 8: Advanced Routing & API Design

## Introduction to Modular API Design

Large applications need proper organization:
- Separate concerns by domain
- Version APIs for backward compatibility
- Implement consistent patterns
- Design RESTful endpoints
- Handle complex data operations

---

## APIRouter for Modular Design

### Basic Router Usage

```python
# routers/users.py
from fastapi import APIRouter, Depends, HTTPException
from typing import List

# Create router
router = APIRouter(
    prefix="/users",
    tags=["users"],
    responses={404: {"description": "Not found"}}
)

@router.get("/", response_model=List[User])
async def list_users(skip: int = 0, limit: int = 100):
    """List all users"""
    return get_users(skip, limit)

@router.post("/", response_model=User, status_code=201)
async def create_user(user: UserCreate):
    """Create new user"""
    return create_new_user(user)

@router.get("/{user_id}", response_model=User)
async def get_user(user_id: int):
    """Get user by ID"""
    user = get_user_by_id(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user

@router.put("/{user_id}", response_model=User)
async def update_user(user_id: int, user: UserUpdate):
    """Update user"""
    return update_user_data(user_id, user)

@router.delete("/{user_id}", status_code=204)
async def delete_user(user_id: int):
    """Delete user"""
    delete_user_by_id(user_id)

# routers/items.py
from fastapi import APIRouter

router = APIRouter(
    prefix="/items",
    tags=["items"]
)

@router.get("/")
async def list_items():
    return {"items": []}

# main.py
from fastapi import FastAPI
from routers import users, items

app = FastAPI()

# Include routers
app.include_router(users.router)
app.include_router(items.router)

# Results in:
# GET  /users
# POST /users
# GET  /users/{user_id}
# PUT  /users/{user_id}
# DELETE /users/{user_id}
# GET  /items
```

### Router with Dependencies

```python
# routers/admin.py
from fastapi import APIRouter, Depends
from auth.dependencies import get_current_admin_user

# Router-level dependency (applies to all routes)
router = APIRouter(
    prefix="/admin",
    tags=["admin"],
    dependencies=[Depends(get_current_admin_user)]
)

@router.get("/dashboard")
async def admin_dashboard():
    """
    Admin-only endpoint
    get_current_admin_user dependency runs automatically
    """
    return {"message": "Admin dashboard"}

@router.get("/users")
async def list_all_users():
    """All routes in this router require admin"""
    return {"users": []}
```

### Nested Routers

```python
# routers/api_v1/users.py
from fastapi import APIRouter

router = APIRouter()

@router.get("/")
async def list_users():
    return {"users": []}

# routers/api_v1/items.py
from fastapi import APIRouter

router = APIRouter()

@router.get("/")
async def list_items():
    return {"items": []}

# routers/api_v1/router.py
from fastapi import APIRouter
from . import users, items

# Create main v1 router
api_router = APIRouter()

# Include sub-routers
api_router.include_router(users.router, prefix="/users", tags=["users"])
api_router.include_router(items.router, prefix="/items", tags=["items"])

# main.py
from fastapi import FastAPI
from routers.api_v1.router import api_router

app = FastAPI()

# Include v1 API
app.include_router(api_router, prefix="/api/v1")

# Results in:
# /api/v1/users
# /api/v1/items
```

---

## API Versioning

### URI Versioning (Recommended)

```python
# routers/api_v1/users.py
from fastapi import APIRouter

router = APIRouter()

@router.get("/")
async def list_users_v1():
    """Version 1: Returns basic user info"""
    return {"users": [{"id": 1, "name": "John"}]}

# routers/api_v2/users.py
from fastapi import APIRouter

router = APIRouter()

@router.get("/")
async def list_users_v2():
    """Version 2: Returns enhanced user info with email"""
    return {
        "users": [
            {
                "id": 1,
                "name": "John",
                "email": "john@example.com",
                "created_at": "2024-01-01"
            }
        ]
    }

# main.py
from fastapi import FastAPI
from routers.api_v1 import router as v1_router
from routers.api_v2 import router as v2_router

app = FastAPI()

# Include different versions
app.include_router(v1_router.api_router, prefix="/api/v1")
app.include_router(v2_router.api_router, prefix="/api/v2")

# Access:
# GET /api/v1/users - Old version
# GET /api/v2/users - New version
```

### Header Versioning

```python
from fastapi import FastAPI, Header, HTTPException

app = FastAPI()

@app.get("/users")
async def get_users(api_version: str = Header(default="v1", alias="X-API-Version")):
    """
    Version specified in header
    X-API-Version: v1 or v2
    """
    if api_version == "v1":
        return {"users": [{"id": 1, "name": "John"}]}
    elif api_version == "v2":
        return {"users": [{"id": 1, "name": "John", "email": "john@example.com"}]}
    else:
        raise HTTPException(status_code=400, detail="Unsupported API version")
```

### Query Parameter Versioning

```python
@app.get("/users")
async def get_users(version: str = "v1"):
    """
    Version in query parameter
    GET /users?version=v1
    GET /users?version=v2
    """
    if version == "v1":
        return {"users": [{"id": 1, "name": "John"}]}
    elif version == "v2":
        return {"users": [{"id": 1, "name": "John", "email": "john@example.com"}]}
    else:
        raise HTTPException(status_code=400, detail="Unsupported version")
```

---

## Pagination Patterns

### Offset-Based Pagination

```python
from fastapi import APIRouter, Query
from typing import List, Optional
from pydantic import BaseModel

router = APIRouter()

class PaginatedResponse(BaseModel):
    """Standard pagination response"""
    items: List[dict]
    total: int
    page: int
    page_size: int
    pages: int

@router.get("/items", response_model=PaginatedResponse)
async def list_items(
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(10, ge=1, le=100, description="Items per page"),
    search: Optional[str] = None
):
    """
    Offset-based pagination
    GET /items?page=2&page_size=10
    """
    # Calculate offset
    skip = (page - 1) * page_size
    
    # Get items (simulated)
    all_items = get_all_items(search=search)
    total = len(all_items)
    items = all_items[skip : skip + page_size]
    
    # Calculate total pages
    pages = (total + page_size - 1) // page_size
    
    return {
        "items": items,
        "total": total,
        "page": page,
        "page_size": page_size,
        "pages": pages
    }
```

### Cursor-Based Pagination

```python
from typing import Optional
from datetime import datetime

class CursorPaginatedResponse(BaseModel):
    """Cursor pagination response"""
    items: List[dict]
    next_cursor: Optional[str] = None
    has_more: bool

@router.get("/posts", response_model=CursorPaginatedResponse)
async def list_posts(
    cursor: Optional[str] = None,
    limit: int = Query(20, ge=1, le=100)
):
    """
    Cursor-based pagination (better for real-time data)
    GET /posts?cursor=2024-01-01T12:00:00&limit=20
    """
    # Parse cursor (timestamp in this example)
    if cursor:
        cursor_time = datetime.fromisoformat(cursor)
        # Get posts after cursor
        posts = get_posts_after(cursor_time, limit + 1)
    else:
        # Get first page
        posts = get_latest_posts(limit + 1)
    
    # Check if there are more items
    has_more = len(posts) > limit
    items = posts[:limit]
    
    # Generate next cursor
    next_cursor = None
    if has_more and items:
        next_cursor = items[-1]["created_at"].isoformat()
    
    return {
        "items": items,
        "next_cursor": next_cursor,
        "has_more": has_more
    }
```

### Keyset Pagination

```python
@router.get("/users")
async def list_users_keyset(
    last_id: Optional[int] = None,
    limit: int = Query(20, ge=1, le=100)
):
    """
    Keyset pagination (using ID)
    GET /users?last_id=100&limit=20
    """
    if last_id:
        # Get users with ID > last_id
        users = get_users_after_id(last_id, limit + 1)
    else:
        # Get first page
        users = get_users(limit + 1)
    
    has_more = len(users) > limit
    items = users[:limit]
    
    return {
        "users": items,
        "last_id": items[-1]["id"] if items else None,
        "has_more": has_more
    }
```

---

## Filtering and Sorting

### Advanced Filtering

```python
from fastapi import APIRouter, Query
from typing import Optional, List
from enum import Enum
from datetime import date

router = APIRouter()

class SortOrder(str, Enum):
    asc = "asc"
    desc = "desc"

class ProductCategory(str, Enum):
    electronics = "electronics"
    clothing = "clothing"
    books = "books"
    food = "food"

@router.get("/products")
async def search_products(
    # Text search
    q: Optional[str] = Query(None, min_length=2, description="Search query"),
    
    # Category filter
    category: Optional[ProductCategory] = None,
    
    # Price range
    min_price: Optional[float] = Query(None, ge=0),
    max_price: Optional[float] = Query(None, ge=0),
    
    # Rating filter
    min_rating: Optional[float] = Query(None, ge=0, le=5),
    
    # Boolean filters
    in_stock: Optional[bool] = None,
    on_sale: Optional[bool] = None,
    
    # Date filters
    created_after: Optional[date] = None,
    created_before: Optional[date] = None,
    
    # Array filters
    tags: List[str] = Query([], description="Filter by tags"),
    
    # Sorting
    sort_by: str = Query("created_at", description="Field to sort by"),
    sort_order: SortOrder = Query(SortOrder.desc),
    
    # Pagination
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100)
):
    """
    Advanced filtering and sorting
    GET /products?q=laptop&category=electronics&min_price=500&max_price=2000
                   &in_stock=true&sort_by=price&sort_order=asc&page=1
    """
    # Build filters
    filters = {}
    
    if q:
        filters["search"] = q
    if category:
        filters["category"] = category
    if min_price is not None:
        filters["min_price"] = min_price
    if max_price is not None:
        filters["max_price"] = max_price
    if min_rating is not None:
        filters["min_rating"] = min_rating
    if in_stock is not None:
        filters["in_stock"] = in_stock
    if on_sale is not None:
        filters["on_sale"] = on_sale
    if created_after:
        filters["created_after"] = created_after
    if created_before:
        filters["created_before"] = created_before
    if tags:
        filters["tags"] = tags
    
    # Apply filters and sorting
    products = search_products_db(
        filters=filters,
        sort_by=sort_by,
        sort_order=sort_order.value,
        skip=(page - 1) * page_size,
        limit=page_size
    )
    
    return {
        "products": products,
        "filters": filters,
        "page": page,
        "page_size": page_size
    }
```

### Dynamic Filtering with Query Object

```python
from pydantic import BaseModel
from typing import Optional, List

class ProductFilters(BaseModel):
    """Reusable filter model"""
    search: Optional[str] = None
    category: Optional[str] = None
    min_price: Optional[float] = None
    max_price: Optional[float] = None
    tags: List[str] = []
    in_stock: bool = True

class SortParams(BaseModel):
    """Sort parameters"""
    field: str = "created_at"
    order: str = "desc"

@router.get("/products-v2")
async def search_products_v2(
    filters: ProductFilters = Depends(),
    sort: SortParams = Depends(),
    page: int = 1,
    page_size: int = 20
):
    """
    Cleaner approach using dependency injection
    """
    products = search_products_db(
        filters=filters.model_dump(exclude_none=True),
        sort_by=sort.field,
        sort_order=sort.order,
        skip=(page - 1) * page_size,
        limit=page_size
    )
    
    return {"products": products}
```

---

## Bulk Operations

### Bulk Create

```python
from typing import List

@router.post("/users/bulk", response_model=List[User])
async def create_users_bulk(users: List[UserCreate]):
    """
    Create multiple users at once
    POST /users/bulk
    Body: [
        {"email": "user1@example.com", "username": "user1"},
        {"email": "user2@example.com", "username": "user2"}
    ]
    """
    created_users = []
    errors = []
    
    for user_data in users:
        try:
            user = create_user(user_data)
            created_users.append(user)
        except Exception as e:
            errors.append({
                "user": user_data.model_dump(),
                "error": str(e)
            })
    
    return {
        "created": created_users,
        "errors": errors,
        "success_count": len(created_users),
        "error_count": len(errors)
    }
```

### Bulk Update

```python
@router.patch("/users/bulk")
async def update_users_bulk(updates: List[dict]):
    """
    Update multiple users
    PATCH /users/bulk
    Body: [
        {"id": 1, "email": "new1@example.com"},
        {"id": 2, "username": "newname"}
    ]
    """
    results = []
    
    for update in updates:
        user_id = update.get("id")
        if not user_id:
            results.append({"error": "Missing user ID"})
            continue
        
        try:
            user = update_user(user_id, update)
            results.append({"success": True, "user": user})
        except Exception as e:
            results.append({"success": False, "id": user_id, "error": str(e)})
    
    return {"results": results}
```

### Bulk Delete

```python
@router.delete("/users/bulk")
async def delete_users_bulk(user_ids: List[int]):
    """
    Delete multiple users
    DELETE /users/bulk
    Body: [1, 2, 3, 4, 5]
    """
    deleted = []
    failed = []
    
    for user_id in user_ids:
        try:
            delete_user(user_id)
            deleted.append(user_id)
        except Exception as e:
            failed.append({"id": user_id, "error": str(e)})
    
    return {
        "deleted": deleted,
        "failed": failed,
        "deleted_count": len(deleted),
        "failed_count": len(failed)
    }
```

---

## Partial Updates with PATCH

### Proper PATCH Implementation

```python
from pydantic import BaseModel
from typing import Optional

class UserUpdate(BaseModel):
    """All fields optional for PATCH"""
    email: Optional[str] = None
    username: Optional[str] = None
    full_name: Optional[str] = None
    is_active: Optional[bool] = None

@router.patch("/users/{user_id}", response_model=User)
async def update_user_partial(user_id: int, user_update: UserUpdate):
    """
    Partial update - only update provided fields
    PATCH /users/1
    Body: {"email": "new@example.com"}
    """
    # Get existing user
    user = get_user(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Update only provided fields
    update_data = user_update.model_dump(exclude_unset=True)
    
    for field, value in update_data.items():
        setattr(user, field, value)
    
    save_user(user)
    return user
```

### JSON Patch (RFC 6902)

```python
from typing import List
from enum import Enum

class PatchOperation(str, Enum):
    add = "add"
    remove = "remove"
    replace = "replace"
    move = "move"
    copy = "copy"
    test = "test"

class JsonPatch(BaseModel):
    op: PatchOperation
    path: str
    value: Optional[any] = None
    from_: Optional[str] = None

@router.patch("/users/{user_id}/json-patch")
async def update_user_json_patch(user_id: int, patches: List[JsonPatch]):
    """
    JSON Patch format
    PATCH /users/1/json-patch
    Body: [
        {"op": "replace", "path": "/email", "value": "new@example.com"},
        {"op": "remove", "path": "/middle_name"}
    ]
    """
    user = get_user(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    user_dict = user.model_dump()
    
    for patch in patches:
        if patch.op == PatchOperation.replace:
            # Remove leading slash
            field = patch.path.lstrip("/")
            user_dict[field] = patch.value
        elif patch.op == PatchOperation.remove:
            field = patch.path.lstrip("/")
            user_dict.pop(field, None)
        # Implement other operations...
    
    updated_user = User(**user_dict)
    save_user(updated_user)
    return updated_user
```

---

## Complex Request/Response Patterns

### Request with Multiple Body Parts

```python
from fastapi import File, Form, UploadFile

@router.post("/posts")
async def create_post_with_image(
    title: str = Form(...),
    content: str = Form(...),
    tags: List[str] = Form([]),
    published: bool = Form(False),
    image: UploadFile = File(None)
):
    """
    Create post with form data and file upload
    Content-Type: multipart/form-data
    """
    # Save image if provided
    image_url = None
    if image:
        image_url = save_uploaded_file(image)
    
    post = create_post({
        "title": title,
        "content": content,
        "tags": tags,
        "published": published,
        "image_url": image_url
    })
    
    return post
```

### Nested Resource Endpoints

```python
# User's posts
@router.get("/users/{user_id}/posts")
async def get_user_posts(
    user_id: int,
    skip: int = 0,
    limit: int = 20
):
    """Get all posts by specific user"""
    posts = get_posts_by_user(user_id, skip, limit)
    return {"posts": posts}

@router.post("/users/{user_id}/posts")
async def create_user_post(
    user_id: int,
    post: PostCreate,
    current_user: User = Depends(get_current_user)
):
    """Create post for specific user"""
    # Verify user can create posts for this user_id
    if current_user.id != user_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    post_data = post.model_dump()
    post_data["user_id"] = user_id
    return create_post(post_data)

# Post's comments
@router.get("/posts/{post_id}/comments")
async def get_post_comments(post_id: int):
    """Get all comments for a post"""
    return get_comments_by_post(post_id)

@router.post("/posts/{post_id}/comments")
async def create_comment(
    post_id: int,
    comment: CommentCreate,
    current_user: User = Depends(get_current_user)
):
    """Create comment on post"""
    comment_data = comment.model_dump()
    comment_data["post_id"] = post_id
    comment_data["user_id"] = current_user.id
    return create_new_comment(comment_data)
```

---

## Error Handling Patterns

### Consistent Error Response

```python
from pydantic import BaseModel
from typing import Optional, List

class ErrorDetail(BaseModel):
    field: Optional[str] = None
    message: str
    code: str

class ErrorResponse(BaseModel):
    error: str
    message: str
    details: Optional[List[ErrorDetail]] = None
    request_id: Optional[str] = None

@router.get("/users/{user_id}")
async def get_user(user_id: int, request: Request):
    """Get user with consistent error response"""
    user = get_user_by_id(user_id)
    
    if not user:
        error = ErrorResponse(
            error="not_found",
            message=f"User with ID {user_id} not found",
            request_id=request.headers.get("X-Request-ID")
        )
        raise HTTPException(
            status_code=404,
            detail=error.model_dump()
        )
    
    return user
```

### Global Exception Handler

```python
from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError

app = FastAPI()

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Custom validation error handler"""
    errors = []
    for error in exc.errors():
        errors.append(ErrorDetail(
            field=".".join(str(loc) for loc in error["loc"]),
            message=error["msg"],
            code=error["type"]
        ))
    
    error_response = ErrorResponse(
        error="validation_error",
        message="Request validation failed",
        details=errors,
        request_id=request.headers.get("X-Request-ID")
    )
    
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content=error_response.model_dump()
    )
```

---

## Complete Example: Blog API

```python
# main.py - Complete blog API with advanced patterns
from fastapi import FastAPI, APIRouter, Depends, HTTPException, Query
from typing import List, Optional
from datetime import datetime
from enum import Enum

app = FastAPI(title="Blog API", version="2.0.0")

# ========== Models ==========

class PostStatus(str, Enum):
    draft = "draft"
    published = "published"
    archived = "archived"

class PostBase(BaseModel):
    title: str
    content: str
    tags: List[str] = []
    status: PostStatus = PostStatus.draft

class PostCreate(PostBase):
    pass

class PostUpdate(BaseModel):
    title: Optional[str] = None
    content: Optional[str] = None
    tags: Optional[List[str]] = None
    status: Optional[PostStatus] = None

class Post(PostBase):
    id: int
    author_id: int
    created_at: datetime
    updated_at: datetime
    view_count: int = 0

class PostWithAuthor(Post):
    author: User

class PaginatedPosts(BaseModel):
    posts: List[PostWithAuthor]
    total: int
    page: int
    pages: int

# ========== Router ==========

router = APIRouter(prefix="/api/v2/posts", tags=["posts"])

# List posts with advanced filtering
@router.get("/", response_model=PaginatedPosts)
async def list_posts(
    # Search
    q: Optional[str] = None,
    
    # Filters
    status: Optional[PostStatus] = None,
    author_id: Optional[int] = None,
    tags: List[str] = Query([]),
    
    # Date range
    created_after: Optional[datetime] = None,
    created_before: Optional[datetime] = None,
    
    # Sorting
    sort_by: str = "created_at",
    sort_order: str = "desc",
    
    # Pagination
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100)
):
    """
    List posts with filtering, sorting, and pagination
    GET /api/v2/posts?q=fastapi&status=published&tags=python&page=1
    """
    filters = {
        "search": q,
        "status": status,
        "author_id": author_id,
        "tags": tags,
        "created_after": created_after,
        "created_before": created_before
    }
    
    # Remove None values
    filters = {k: v for k, v in filters.items() if v is not None}
    
    # Get posts
    posts, total = get_posts_paginated(
        filters=filters,
        sort_by=sort_by,
        sort_order=sort_order,
        skip=(page - 1) * page_size,
        limit=page_size
    )
    
    return {
        "posts": posts,
        "total": total,
        "page": page,
        "pages": (total + page_size - 1) // page_size
    }

# Create post
@router.post("/", response_model=Post, status_code=201)
async def create_post(
    post: PostCreate,
    current_user: User = Depends(get_current_user)
):
    """Create new post"""
    post_data = post.model_dump()
    post_data["author_id"] = current_user.id
    return create_new_post(post_data)

# Get single post
@router.get("/{post_id}", response_model=PostWithAuthor)
async def get_post(post_id: int):
    """Get post by ID"""
    post = get_post_by_id(post_id)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    
    # Increment view count
    increment_view_count(post_id)
    
    return post

# Partial update
@router.patch("/{post_id}", response_model=Post)
async def update_post(
    post_id: int,
    post_update: PostUpdate,
    current_user: User = Depends(get_current_user)
):
    """Partially update post"""
    post = get_post_by_id(post_id)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    
    # Check authorization
    if post.author_id != current_user.id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    # Update only provided fields
    update_data = post_update.model_dump(exclude_unset=True)
    return update_post_by_id(post_id, update_data)

# Delete post
@router.delete("/{post_id}", status_code=204)
async def delete_post(
    post_id: int,
    current_user: User = Depends(get_current_user)
):
    """Delete post"""
    post = get_post_by_id(post_id)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    
    if post.author_id != current_user.id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    delete_post_by_id(post_id)

# Bulk operations
@router.post("/bulk", response_model=List[Post])
async def create_posts_bulk(
    posts: List[PostCreate],
    current_user: User = Depends(get_current_user)
):
    """Create multiple posts"""
    created = []
    for post_data in posts:
        post_dict = post_data.model_dump()
        post_dict["author_id"] = current_user.id
        post = create_new_post(post_dict)
        created.append(post)
    return created

# Nested resource: post comments
@router.get("/{post_id}/comments")
async def get_post_comments(
    post_id: int,
    skip: int = 0,
    limit: int = 20
):
    """Get comments for a post"""
    return get_comments(post_id, skip, limit)

# Include router
app.include_router(router)
```

---

## Best Practices

1. **Use APIRouter for organization**: Separate concerns by domain
2. **Implement versioning early**: Start with /api/v1 from day one
3. **Consistent pagination**: Choose one pattern and stick to it
4. **Smart filtering**: Use Pydantic models for complex filters
5. **Proper PATCH**: Use `exclude_unset=True` for partial updates
6. **RESTful design**: Follow REST conventions for predictable APIs
7. **Nested resources carefully**: Only for true parent-child relationships
8. **Bulk operations**: Provide detailed results (success/failure per item)

## Common Pitfalls

1. **Inconsistent endpoints**: /users vs /user, /get-users vs /users
2. **Wrong HTTP methods**: Using GET for mutations, POST for queries
3. **Over-nesting**: /users/1/posts/2/comments/3/likes
4. **Ignoring query limits**: No max limit on pagination
5. **Poor error messages**: Generic "Bad Request" without details
6. **Missing versioning**: Can't change API without breaking clients

---

## Summary

In Chapter 8, you learned:
- APIRouter for modular design
- API versioning strategies
- Pagination patterns (offset, cursor, keyset)
- Advanced filtering and sorting
- Bulk operations
- Partial updates with PATCH
- Nested resources
- Error handling patterns
- Complete blog API example

**Next: Chapter 9 - Validation, Serialization & Performance**